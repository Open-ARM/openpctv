diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index fa83d58..c4d89c7 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -501,14 +501,7 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   if (m_renderMethod & RENDER_BYPASS)
   {
-    // FIXME : move in its own render mode instead of mixup with BYPASS
-    if (m_format == RENDER_FMT_IMX)
-    {
-      int index = m_iYV12RenderBuffer;
-      CDVDVideoCodecIMX *imx = m_buffers[index].imx;
 
-      imx->RenderFrame();
-    }
 
     ManageDisplay();
     // if running bypass, then the player might need the src/dst rects
@@ -522,14 +515,21 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     int iHeight = CDisplaySettings::Get().GetResolutionInfo(res).iHeight;
 
     g_graphicsContext.BeginPaint();
-    glScissor(0,
-              0,
-              iWidth,
-              iHeight);
-    glClearColor(GLfloat(0.0), GLfloat(0.0), GLfloat(0.0), 0);
-    glClear(GL_COLOR_BUFFER_BIT);
+    if (clear)
+    {
+      glScissor(0,
+                0,
+                iWidth,
+                iHeight);
+      glClearColor(GLfloat(0.0), GLfloat(0.0), GLfloat(0.0), 0);
+      glClear(GL_COLOR_BUFFER_BIT);
+    }
 
     g_graphicsContext.SetScissors(m_destRect);
+   /* CLog::Log(LOGDEBUG, "%s - m_destRect : %f %f %f %f\n",
+              __FUNCTION__, m_destRect.x1,  m_destRect.x2, m_destRect.y1,m_destRect.y2);*/
+
+
 /*    glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);*/
     glClearColor(GLfloat(2.0/31.0), GLfloat(2.0/63.0), GLfloat(2.0/31.0), 0);
@@ -537,6 +537,20 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
     g_graphicsContext.SetScissors(old);
     g_graphicsContext.EndPaint();
+
+    // FIXME : move in its own render mode instead of mixup with BYPASS
+    if (m_format == RENDER_FMT_IMX)
+    {
+      int index = m_iYV12RenderBuffer;
+      struct v4l2_crop crop;
+
+      crop.c.top = (int)m_destRect.y1;
+      crop.c.left = (int)m_destRect.x1;
+      crop.c.width =  (int)(m_destRect.x2 -  m_destRect.x1);
+      crop.c.height = (int)(m_destRect.y2 - m_destRect.y1);
+      CDVDVideoCodecIMX *imx = m_buffers[index].imx;
+      imx->RenderFrame(crop);
+    }
     return;
   }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index a9ddd8d..eb6db1d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -507,7 +507,7 @@ bool CDVDVideoCodecIMX::VpuPushFrame(VpuFrameBuffer *frameBuffer, VpuFieldType f
 }
 
 
-void CDVDVideoCodecIMX::RenderFrame(void)
+void CDVDVideoCodecIMX::RenderFrame(struct v4l2_crop &destRect)
 {
   /* Warning : called from renderer thread
    * Especially do not call any VPU functions as they are not thread safe
@@ -519,6 +519,7 @@ void CDVDVideoCodecIMX::RenderFrame(void)
   struct v4l2_format fmt;
   int stream_trigger;
   struct v4l2_control ctrl;
+  bool crop_update = false;
 
   /* lock has to be acquired that soon even if queue is modified far later
    * (to prevent compiler optimization that will race...)
@@ -549,6 +550,19 @@ void CDVDVideoCodecIMX::RenderFrame(void)
   } else
     m_pushed_frames++;
 
+
+  if ((m_crop.c.top != destRect.c.top) ||
+      (m_crop.c.left != destRect.c.left) ||
+      (m_crop.c.width != destRect.c.width) ||
+      (m_crop.c.height !=  destRect.c.height))
+  {
+     CLog::Log(LOGNOTICE, "%s - Newcrop : %d % d %d %d\n",
+              __FUNCTION__, destRect.c.top, destRect.c.left, destRect.c.width, destRect.c.height);
+
+    m_crop.c = destRect.c;
+    crop_update = true;
+  }
+
   if (!m_streamon)
   {
     if (outputFrame.field != m_current_field)
@@ -629,7 +643,24 @@ void CDVDVideoCodecIMX::RenderFrame(void)
       /* We have to repeat crop command after streamon for some vids
       * FIXME check why in drivers...
       */
-      ioctl(m_v4lfd, VIDIOC_S_CROP, &m_crop);
+      ret = ioctl(m_v4lfd, VIDIOC_S_CROP, &m_crop);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - S_CROP failed (ret %d : %s)\n",
+                __FUNCTION__, ret, strerror(errno));
+      }
+    }
+  }
+  else
+  {
+    if (crop_update)
+    {
+      ret = ioctl(m_v4lfd, VIDIOC_S_CROP, &m_crop);
+      if (ret < 0)
+      {
+        CLog::Log(LOGERROR, "%s - S_CROP failed (ret %d : %s)\n",
+                __FUNCTION__, ret, strerror(errno));
+      }
     }
   }
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index 9418cf0..cdd3714 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -69,7 +69,7 @@ public:
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
   virtual unsigned GetAllowedReferences();
   
-  void RenderFrame(void);
+  void RenderFrame(struct v4l2_crop &);
 protected:
 
   CDVDStreamInfo      m_hints;
