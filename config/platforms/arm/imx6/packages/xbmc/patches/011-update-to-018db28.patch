diff --git a/language/English/strings.po b/language/English/strings.po
index 93d0c3c..6ea89f5 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6594,9 +6594,25 @@ msgctxt "#14100"
 msgid "Stop ripping CD"
 msgstr ""
 
-#empty strings from id 14101 to 15014
+#empty strings from id 14101 to 15011
+
+#: xbmc/video/VideoDatabase.cpp
+msgctxt "#15012"
+msgid "Unavailable source"
+msgstr ""
+
+#: xbmc/video/VideoDatabase.cpp
+msgctxt "#15013"
+msgid "What would you like to do with media items from the following unavailable source?"
+msgstr ""
+
+#: xbmc/video/VideoDatabase.cpp
+msgctxt "#15014"
+msgid "Keep"
+msgstr ""
 
 #: xbmc/dialogs/GUIDialogFavourites.cpp
+#: xbmc/video/VideoDatabase.cpp
 msgctxt "#15015"
 msgid "Remove"
 msgstr ""
diff --git a/tools/android/packaging/xbmc/src/org/xbmc/xbmc/Main.java b/tools/android/packaging/xbmc/src/org/xbmc/xbmc/Main.java
index a94f925..35ad608 100644
--- a/tools/android/packaging/xbmc/src/org/xbmc/xbmc/Main.java
+++ b/tools/android/packaging/xbmc/src/org/xbmc/xbmc/Main.java
@@ -3,10 +3,12 @@ package org.xbmc.xbmc;
 import android.app.NativeActivity;
 import android.content.Intent;
 import android.os.Bundle;
+import android.util.Log;
 
 public class Main extends NativeActivity 
 {
   native void _onNewIntent(Intent intent);
+
   public Main() 
   {
     super();
@@ -22,7 +24,11 @@ public class Main extends NativeActivity
   protected void onNewIntent(Intent intent)
   {
     super.onNewIntent(intent);
-    _onNewIntent(intent);
+    try {
+      _onNewIntent(intent);
+    } catch (UnsatisfiedLinkError e) {
+      Log.e("Main", "Native not registered");
+    }
   }
 
 }
diff --git a/tools/android/packaging/xbmc/src/org/xbmc/xbmc/XBMCBroadcastReceiver.java b/tools/android/packaging/xbmc/src/org/xbmc/xbmc/XBMCBroadcastReceiver.java
index a3c7886..93e37a4 100644
--- a/tools/android/packaging/xbmc/src/org/xbmc/xbmc/XBMCBroadcastReceiver.java
+++ b/tools/android/packaging/xbmc/src/org/xbmc/xbmc/XBMCBroadcastReceiver.java
@@ -13,6 +13,10 @@ public class XBMCBroadcastReceiver extends BroadcastReceiver
   public void onReceive(Context context, Intent intent)
   {
     Log.d("XBMCBroadcastReceiver", "Received Intent");
-    _onReceive(intent);
+    try {
+      _onReceive(intent);
+    } catch (UnsatisfiedLinkError e) {
+      Log.e("XBMCBroadcastReceiver", "Native not registered");
+    }
   }
 }
diff --git a/xbmc/addons/Repository.cpp b/xbmc/addons/Repository.cpp
index 19c48d7..de67eb0 100644
--- a/xbmc/addons/Repository.cpp
+++ b/xbmc/addons/Repository.cpp
@@ -236,7 +236,8 @@ bool CRepositoryUpdateJob::DoWork()
     if (ShouldCancel(0,0))
       break;
 
-    if (!CAddonInstaller::Get().CheckDependencies(addons[i]))
+    bool deps_met = CAddonInstaller::Get().CheckDependencies(addons[i]);
+    if (!deps_met && addons[i]->Props().broken.empty())
       addons[i]->Props().broken = "DEPSNOTMET";
 
     // invalidate the art associated with this item
@@ -248,7 +249,8 @@ bool CRepositoryUpdateJob::DoWork()
     AddonPtr addon;
     CAddonMgr::Get().GetAddon(addons[i]->ID(),addon);
     if (addon && addons[i]->Version() > addon->Version() &&
-        !database.IsAddonBlacklisted(addons[i]->ID(),addons[i]->Version().c_str()))
+        !database.IsAddonBlacklisted(addons[i]->ID(),addons[i]->Version().c_str()) &&
+        deps_met)
     {
       if (CSettings::Get().GetBool("general.addonautoupdate") || addon->Type() >= ADDON_VIZ_LIBRARY)
       {
diff --git a/xbmc/android/activity/AndroidExtra.h b/xbmc/android/activity/AndroidExtra.h
index ea1b1f0..7b1c9ff 100644
--- a/xbmc/android/activity/AndroidExtra.h
+++ b/xbmc/android/activity/AndroidExtra.h
@@ -26,6 +26,11 @@ extern float AMotionEvent_getAxisValue(const AInputEvent* motion_event, int32_t
 extern typeof(AMotionEvent_getAxisValue) *p_AMotionEvent_getAxisValue;
 #define AMotionEvent_getAxisValue (*p_AMotionEvent_getAxisValue)
 
+// missing in NDK
+extern int32_t AMotionEvent_getButtonState(const AInputEvent* motion_event);
+extern typeof(AMotionEvent_getButtonState) *p_AMotionEvent_getButtonState;
+#define AMotionEvent_getButtonState (*p_AMotionEvent_getButtonState)
+
  //Additional defines from android.view.KeyEvent (http://developer.android.com/reference/android/view/KeyEvent.html)
 #define AKEYCODE_ESCAPE 111
 #define AKEYCODE_FORWARD_DEL 112
@@ -41,6 +46,12 @@ extern typeof(AMotionEvent_getAxisValue) *p_AMotionEvent_getAxisValue;
 //Additional defines from android.view.MotionEvent (http://developer.android.com/reference/android/view/MotionEvent.html)
 #define AMOTION_EVENT_ACTION_SCROLL 0x08
 
+#define AMOTION_EVENT_BUTTON_PRIMARY 0x00000001
+#define AMOTION_EVENT_BUTTON_SECONDARY 0x00000002
+#define AMOTION_EVENT_BUTTON_TERTIARY 0x00000004
+#define AMOTION_EVENT_BUTTON_BACK 0x00000008
+#define AMOTION_EVENT_BUTTON_FORWARD 0x00000010
+
 #define AINPUT_SOURCE_CLASS_JOYSTICK 0x00000010
 
 #define AINPUT_SOURCE_GAMEPAD  (0x00000400 | AINPUT_SOURCE_CLASS_BUTTON)
diff --git a/xbmc/android/activity/AndroidMouse.cpp b/xbmc/android/activity/AndroidMouse.cpp
index a25c255..0665bbb 100644
--- a/xbmc/android/activity/AndroidMouse.cpp
+++ b/xbmc/android/activity/AndroidMouse.cpp
@@ -29,6 +29,7 @@
 //#define DEBUG_VERBOSE
 
 CAndroidMouse::CAndroidMouse()
+  : m_lastButtonState(0)
 {
 }
 
@@ -43,22 +44,23 @@ bool CAndroidMouse::onMouseEvent(AInputEvent* event)
 
   int32_t eventAction = AMotionEvent_getAction(event);
   int8_t mouseAction = eventAction & AMOTION_EVENT_ACTION_MASK;
-  size_t mousePointer = eventAction >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;
+  size_t mousePointerIdx = eventAction >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;
+  int32_t mousePointerId = AMotionEvent_getPointerId(event, mousePointerIdx);
 
 #ifdef DEBUG_VERBOSE
-  CXBMCApp::android_printf("%s pointer:%i", __PRETTY_FUNCTION__, mousePointer);
+  CXBMCApp::android_printf("%s idx:%i, id:%i", __PRETTY_FUNCTION__, mousePointerIdx, mousePointerId);
 #endif
-  float x = AMotionEvent_getX(event, mousePointer);
-  float y = AMotionEvent_getY(event, mousePointer);
+  float x = AMotionEvent_getX(event, mousePointerIdx);
+  float y = AMotionEvent_getY(event, mousePointerIdx);
 
   switch (mouseAction)
   {
     case AMOTION_EVENT_ACTION_UP:
     case AMOTION_EVENT_ACTION_DOWN:
-      MouseButton(x,y,mouseAction);
+      MouseButton(x,y,mouseAction,AMotionEvent_getButtonState(event));
       return true;
     case AMOTION_EVENT_ACTION_SCROLL:
-      MouseWheel(x, y, AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_VSCROLL, mousePointer));
+      MouseWheel(x, y, AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_VSCROLL, mousePointerIdx));
       return true;
     default:
       MouseMove(x,y);
@@ -87,22 +89,33 @@ void CAndroidMouse::MouseMove(float x, float y)
   CWinEvents::MessagePush(&newEvent);
 }
 
-void CAndroidMouse::MouseButton(float x, float y, int32_t action)
+void CAndroidMouse::MouseButton(float x, float y, int32_t action, int32_t buttons)
 {
 #ifdef DEBUG_VERBOSE
-  CXBMCApp::android_printf("%s: x:%f, y:%f, action:%i", __PRETTY_FUNCTION__, x, y, action);
+  CXBMCApp::android_printf("%s: x:%f, y:%f, action:%i, buttons:%i", __PRETTY_FUNCTION__, x, y, action, buttons);
 #endif
   XBMC_Event newEvent;
 
   memset(&newEvent, 0, sizeof(newEvent));
 
+  int32_t checkButtons = buttons;
+  if (action ==  AMOTION_EVENT_ACTION_UP)
+    checkButtons = m_lastButtonState;
+
   newEvent.type = (action ==  AMOTION_EVENT_ACTION_DOWN) ? XBMC_MOUSEBUTTONDOWN : XBMC_MOUSEBUTTONUP;
   newEvent.button.state = (action ==  AMOTION_EVENT_ACTION_DOWN) ? XBMC_PRESSED : XBMC_RELEASED;
   newEvent.button.type = newEvent.type;
   newEvent.button.x = x;
   newEvent.button.y = y;
-  newEvent.button.button = XBMC_BUTTON_LEFT;
+  if (checkButtons & AMOTION_EVENT_BUTTON_PRIMARY)
+    newEvent.button.button = XBMC_BUTTON_LEFT;
+  else if (checkButtons & AMOTION_EVENT_BUTTON_SECONDARY)
+    newEvent.button.button = XBMC_BUTTON_RIGHT;
+  else if (checkButtons & AMOTION_EVENT_BUTTON_TERTIARY)
+    newEvent.button.button = XBMC_BUTTON_MIDDLE;
   CWinEvents::MessagePush(&newEvent);
+
+  m_lastButtonState = buttons;
 }
 
 void CAndroidMouse::MouseWheel(float x, float y, float value)
diff --git a/xbmc/android/activity/AndroidMouse.h b/xbmc/android/activity/AndroidMouse.h
index f1746a6..10199a2 100644
--- a/xbmc/android/activity/AndroidMouse.h
+++ b/xbmc/android/activity/AndroidMouse.h
@@ -33,6 +33,9 @@ protected:
 
 private:
   void MouseMove(float x, float y);
-  void MouseButton(float x, float y, int32_t type);
+  void MouseButton(float x, float y, int32_t type, int32_t buttons);
   void MouseWheel(float x, float y, float value);
+
+private:
+  int32_t m_lastButtonState;
 };
diff --git a/xbmc/android/activity/EventLoop.cpp b/xbmc/android/activity/EventLoop.cpp
index 851ff51..fdf3358 100644
--- a/xbmc/android/activity/EventLoop.cpp
+++ b/xbmc/android/activity/EventLoop.cpp
@@ -25,6 +25,7 @@
 #include <dlfcn.h>
 
 typeof(AMotionEvent_getAxisValue) *p_AMotionEvent_getAxisValue;
+typeof(AMotionEvent_getButtonState) *p_AMotionEvent_getButtonState;
 
 CEventLoop::CEventLoop(android_app* application)
   : m_enabled(false),
@@ -50,7 +51,9 @@ void CEventLoop::run(IActivityHandler &activityHandler, IInputHandler &inputHand
 
   // missing in early NDKs, is present in r9b+
   p_AMotionEvent_getAxisValue = (typeof(AMotionEvent_getAxisValue)*) dlsym(RTLD_DEFAULT, "AMotionEvent_getAxisValue");
-  CXBMCApp::android_printf("CEventLoop: AMotionEvent_getAxisValue: %p", p_AMotionEvent_getAxisValue);
+  // missing in NDK
+  p_AMotionEvent_getButtonState = (typeof(AMotionEvent_getButtonState)*) dlsym(RTLD_DEFAULT, "AMotionEvent_getButtonState");
+  CXBMCApp::android_printf("CEventLoop: AMotionEvent_getAxisValue: %p, AMotionEvent_getButtonState: %p", p_AMotionEvent_getAxisValue, p_AMotionEvent_getButtonState);
 
   CXBMCApp::android_printf("CEventLoop: starting event loop");
   while (1)
diff --git a/xbmc/android/activity/XBMCApp.cpp b/xbmc/android/activity/XBMCApp.cpp
index 036601a..1b95381 100644
--- a/xbmc/android/activity/XBMCApp.cpp
+++ b/xbmc/android/activity/XBMCApp.cpp
@@ -401,17 +401,32 @@ bool CXBMCApp::HasLaunchIntent(const string &package)
 // Note intent, dataType, dataURI all default to ""
 bool CXBMCApp::StartActivity(const string &package, const string &intent, const string &dataType, const string &dataURI)
 {
-  CJNIIntent newIntent = GetPackageManager().getLaunchIntentForPackage(package);
+  CJNIIntent newIntent = intent.empty() ?
+    GetPackageManager().getLaunchIntentForPackage(package) :
+    CJNIIntent(intent);
+
   if (!newIntent)
     return false;
 
   if (!dataURI.empty())
-    newIntent.setData(dataURI);
+  {
+    CJNIURI jniURI = CJNIURI::parse(dataURI);
+
+    if (!jniURI)
+      return false;
+
+    newIntent.setDataAndType(jniURI, dataType); 
+  }
 
-  if (!intent.empty())
-    newIntent.setAction(intent);
+  newIntent.setPackage(package);
+  startActivity(newIntent);
+  if (xbmc_jnienv()->ExceptionOccurred())
+  {
+    CLog::Log(LOGERROR, "CXBMCApp::StartActivity - ExceptionOccurred launching %s", package.c_str());
+    xbmc_jnienv()->ExceptionClear();
+    return false;
+  }
 
-   startActivity(newIntent);
   return true;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index b9fcf97..34501b0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -1117,6 +1117,16 @@ int CDVDVideoCodecIMX::Decode(BYTE *pData, int iSize, double dts, double pts)
 
     do // Decode as long as the VPU consumes data
     {
+      if (m_decOpenParam.CodecFormat == VPU_V_MPEG2)
+      {
+        parse_mpeg2_aspect_ratio(inData.pVirAddr, inData.nSize);
+      }
+      else
+      {
+        m_display_width = m_initInfo.PicCropRect.nRight - m_initInfo.PicCropRect.nLeft;
+        m_display_height = m_initInfo.PicCropRect.nBottom - m_initInfo.PicCropRect.nTop;
+      }
+
       retry = false;
       ret = VPU_DecDecodeBuf(m_vpuHandle, &inData, &decRet);
       if (ret != VPU_DEC_RET_SUCCESS)
@@ -1349,8 +1359,8 @@ bool CDVDVideoCodecIMX::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
   pDvdVideoPicture->iWidth = m_initInfo.PicCropRect.nRight - m_initInfo.PicCropRect.nLeft;
   pDvdVideoPicture->iHeight = m_initInfo.PicCropRect.nBottom - m_initInfo.PicCropRect.nTop;
-  pDvdVideoPicture->iDisplayWidth = m_initInfo.PicCropRect.nRight - m_initInfo.PicCropRect.nLeft;
-  pDvdVideoPicture->iDisplayHeight = m_initInfo.PicCropRect.nBottom - m_initInfo.PicCropRect.nTop;
+  pDvdVideoPicture->iDisplayWidth = m_display_width;
+  pDvdVideoPicture->iDisplayHeight =  m_display_height;
   pDvdVideoPicture->format = RENDER_FMT_IMX;
   pDvdVideoPicture->imx = this;
   return true;
@@ -1532,3 +1542,65 @@ void CDVDVideoCodecIMX::bitstream_alloc_and_copy(
     (*poutbuf + offset + sps_pps_size)[2] = 1;
   }
 }
+
+
+static inline unsigned char *Seek4bytesCode(unsigned char *pData, int len, unsigned int n4byteCode)
+{
+  if(len >= 4)
+  {
+    unsigned int code = (pData[0]<<16) | (pData[1]<<8) | (pData[2]);
+    len -= 3;
+    pData += 3;
+    while(len > 0)
+    {
+      code = (code<<8) | *pData++ ;
+      len--;
+      if(code == n4byteCode)
+      {
+        return pData-4;
+      }
+    }
+  }
+  return NULL;
+}
+
+uint8_t *CDVDVideoCodecIMX::parse_mpeg2_aspect_ratio(uint8_t *pData, int iSize)
+{
+  uint8_t *pSeqHead = Seek4bytesCode(pData, iSize, 0x000001b3);
+
+  if (pSeqHead)
+  {
+    iSize -= pSeqHead - pData;
+
+    if (iSize >= 12)
+    {
+      int width, height, aspect_ratio_code;
+
+      width  = (pSeqHead[4] << 4) | (pSeqHead[5] >> 4);
+      height = ((pSeqHead[5] & 0x0f) << 8) | pSeqHead[6];
+      aspect_ratio_code = pSeqHead[7] >> 4;
+
+      switch (aspect_ratio_code)
+      {
+      case 2:                   // IAR 4:3
+          m_display_width = (height * 4) / 3;
+          break;
+      case 3:                   // IAR 16:9
+          m_display_width = (height * 16) / 9;
+          break;
+      case 4:                   // IAR 2.21:1
+          m_display_width = (height * 221) / 100;
+          break;
+      default:                  // PAR 1:1
+          m_display_width = width;
+      }
+
+      m_display_height = height;
+
+      return pSeqHead;
+    }
+  }
+
+  return 0;
+}
+
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index cdd3714..65a2a9d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -141,4 +141,8 @@ protected:
   uint32_t          m_sps_pps_size;
   omx_bitstream_ctx m_sps_pps_context; 
   bool m_convert_bitstream;
+
+  uint8_t *parse_mpeg2_aspect_ratio(uint8_t *pData, int iSize);
+  int m_display_width;
+  int m_display_height;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/StageFrightVideoPrivate.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/StageFrightVideoPrivate.cpp
index 0390233..5031df8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/StageFrightVideoPrivate.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/StageFrightVideoPrivate.cpp
@@ -352,54 +352,31 @@ bool CStageFrightVideoPrivate::InitSurfaceTexture()
    if (mVideoNativeWindow != NULL)
     return false;
 
-  mVideoTextureId = -1;
-
-  // We MUST create the GLES texture on the main thread
-  // to match where the valid GLES context is located.
-  // It would be nice to move this out of here, we would need
-  // to create/fetch/create from g_RenderMananger. But g_RenderMananger
-  // does not know we are using MediaCodec until Configure and we
-  // we need m_surfaceTexture valid before then. Chicken, meet Egg.
-  if (m_g_application->IsCurrentThread())
-  {
-    // localize GLuint so we do not spew gles includes in our header
-    GLuint texture_id;
-
-    glGenTextures(1, &texture_id);
-    glBindTexture(  GL_TEXTURE_EXTERNAL_OES, texture_id);
-    glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    glBindTexture(  GL_TEXTURE_EXTERNAL_OES, 0);
-    mVideoTextureId = texture_id;
-  }
-  else
-  {
-    ThreadMessageCallback callbackData;
-    callbackData.callback = &CallbackInitSurfaceTexture;
-    callbackData.userptr  = (void*)this;
-
-    ThreadMessage msg;
-    msg.dwMessage = TMSG_CALLBACK;
-    msg.lpVoid = (void*)&callbackData;
-
-    // wait for it.
-    m_g_applicationMessenger->SendMessage(msg, true);
-
-    mSurfTexture = new CJNISurfaceTexture(mVideoTextureId);
-    mSurface = new CJNISurface(*mSurfTexture);
+   //FIXME: Playing back-to-back vids induces a bug when properly generating textures between runs.
+   //       Symptoms are upside down vid, "updateTexImage: error binding external texture" in log, and crash
+   //       after stopping.
+   //       Workaround is to always use the same, arbitrary chosen, texture ids.
+  mVideoTextureId = 0xbaad;
+
+  glBindTexture(  GL_TEXTURE_EXTERNAL_OES, mVideoTextureId);
+  glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameterf(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  glBindTexture(  GL_TEXTURE_EXTERNAL_OES, 0);
+
+  mSurfTexture = new CJNISurfaceTexture(mVideoTextureId);
+  mSurface = new CJNISurface(*mSurfTexture);
+
+  JNIEnv* env = xbmc_jnienv();
+  mVideoNativeWindow = ANativeWindow_fromSurface(env, mSurface->get_raw());
+  native_window_api_connect(mVideoNativeWindow.get(), NATIVE_WINDOW_API_MEDIA);
 
-    JNIEnv* env = xbmc_jnienv();
-    mVideoNativeWindow = ANativeWindow_fromSurface(env, mSurface->get_raw());
-    native_window_api_connect(mVideoNativeWindow.get(), NATIVE_WINDOW_API_MEDIA);
-
-  #if defined(DEBUG_VERBOSE)
-    CLog::Log(LOGDEBUG, "%s: <<< InitSurfaceTexture texid(%d) natwin(%p)\n", CLASSNAME, mVideoTextureId, mVideoNativeWindow.get());
-  #endif
-  }
+#if defined(DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s: <<< InitSurfaceTexture texid(%d) natwin(%p)\n", CLASSNAME, mVideoTextureId, mVideoNativeWindow.get());
+#endif
 
-  return (mVideoTextureId != -1);
+  return true;
 }
 
 void CStageFrightVideoPrivate::ReleaseSurfaceTexture()
@@ -420,8 +397,6 @@ void CStageFrightVideoPrivate::ReleaseSurfaceTexture()
   delete mSurface;
   delete mSurfTexture;
 
-  if (mVideoTextureId > 0)
-    glDeleteTextures(1, &mVideoTextureId);
 #if defined(DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s: <<< ReleaseSurfaceTexture\n", CLASSNAME);
 #endif
diff --git a/xbmc/guilib/JpegIO.cpp b/xbmc/guilib/JpegIO.cpp
index 314e1fd..ee59d9f 100644
--- a/xbmc/guilib/JpegIO.cpp
+++ b/xbmc/guilib/JpegIO.cpp
@@ -374,8 +374,9 @@ bool CJpegIO::Read(unsigned char* buffer, unsigned int bufSize, unsigned int min
     m_cinfo.scale_denom = 8;
     m_cinfo.out_color_space = JCS_RGB;
     unsigned int maxtexsize = g_Windowing.GetMaxTextureSize();
-    for (m_cinfo.scale_num = 1; m_cinfo.scale_num <= 8; m_cinfo.scale_num++)
+    for (unsigned int scale = 1; scale <= 8; scale++)
     {
+      m_cinfo.scale_num = scale;
       jpeg_calc_output_dimensions(&m_cinfo);
       if ((m_cinfo.output_width > maxtexsize) || (m_cinfo.output_height > maxtexsize))
       {
diff --git a/xbmc/utils/RegExp.cpp b/xbmc/utils/RegExp.cpp
index 459deb2..5afa971 100644
--- a/xbmc/utils/RegExp.cpp
+++ b/xbmc/utils/RegExp.cpp
@@ -252,9 +252,9 @@ int CRegExp::PrivateRegFind(size_t bufferLen, const char *str, unsigned int star
       {
         const size_t startPos = (m_iOvector[0] > fragmentLen) ? CUtf8Utils::RFindValidUtf8Char(m_subject, m_iOvector[0] - fragmentLen) : 0;
         if (m_iOvector[0] >= 0 && startPos != std::string::npos)
-          CLog::Log(LOGERROR, "PCRE: Bad UTF-8 character, error code: %d, position: %d. Text before bad char: \"%s\"", m_iOvector[0], m_iOvector[1], m_subject.substr(startPos, m_iOvector[0] - startPos + 1).c_str());
+          CLog::Log(LOGERROR, "PCRE: Bad UTF-8 character, error code: %d, position: %d. Text before bad char: \"%s\"", m_iOvector[1], m_iOvector[0], m_subject.substr(startPos, m_iOvector[0] - startPos + 1).c_str());
         else
-          CLog::Log(LOGERROR, "PCRE: Bad UTF-8 character, error code: %d, position: %d", m_iOvector[0], m_iOvector[1]);
+          CLog::Log(LOGERROR, "PCRE: Bad UTF-8 character, error code: %d, position: %d", m_iOvector[1], m_iOvector[0]);
         return -1;
       }
     case PCRE_ERROR_BADUTF8_OFFSET:
diff --git a/xbmc/utils/XMLUtils.cpp b/xbmc/utils/XMLUtils.cpp
index 6216b35..b0c86db 100644
--- a/xbmc/utils/XMLUtils.cpp
+++ b/xbmc/utils/XMLUtils.cpp
@@ -336,10 +336,10 @@ void XMLUtils::SetPath(TiXmlNode* pRootNode, const char *strTag, const CStdStrin
 
 void XMLUtils::SetDate(TiXmlNode* pRootNode, const char *strTag, const CDateTime& date)
 {
-  SetString(pRootNode, strTag, date.GetAsDBDate());
+  SetString(pRootNode, strTag, date.IsValid() ? date.GetAsDBDate() : "");
 }
 
 void XMLUtils::SetDateTime(TiXmlNode* pRootNode, const char *strTag, const CDateTime& dateTime)
 {
-  SetString(pRootNode, strTag, dateTime.GetAsDBDateTime());
+  SetString(pRootNode, strTag, dateTime.IsValid() ? dateTime.GetAsDBDateTime() : "");
 }
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 769e6e0..8a634c1 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -18,6 +18,7 @@
  *
  */
 
+#include "ApplicationMessenger.h"
 #include "threads/SystemClock.h"
 #include "VideoDatabase.h"
 #include "video/windows/GUIWindowVideoBase.h"
@@ -8002,10 +8003,10 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     BeginTransaction();
 
     // find all the files
-    CStdString sql;
+    CStdString sql = "SELECT files.idFile, files.strFileName, path.strPath FROM files, path WHERE files.idPath = path.idPath";
     if (paths)
     {
-      if (paths->size() == 0)
+      if (paths->empty())
       {
         RollbackTransaction();
         ANNOUNCEMENT::CAnnouncementManager::Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnCleanFinished");
@@ -8013,12 +8014,10 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
       }
 
       CStdString strPaths;
-      for (std::set<int>::const_iterator i = paths->begin(); i != paths->end(); ++i)
-        strPaths += StringUtils::Format(",%i",*i);
-      sql = PrepareSQL("select * from files, path where files.idPath=path.idPath and path.idPath in (%s)", strPaths.substr(1).c_str());
+      for (std::set<int>::const_iterator it = paths->begin(); it != paths->end(); ++it)
+        strPaths += StringUtils::Format(",%i", *it);
+      sql += PrepareSQL(" AND path.idPath IN (%s)", strPaths.substr(1).c_str());
     }
-    else
-      sql = "select * from files, path where files.idPath = path.idPath";
 
     m_pDS->query(sql.c_str());
     if (m_pDS->num_rows() == 0) return;
@@ -8043,24 +8042,17 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
       }
     }
 
-    CStdString filesToDelete = "";
-    CStdString moviesToDelete = "";
-    CStdString episodesToDelete = "";
-    CStdString musicVideosToDelete = "";
-
-    std::vector<int> movieIDs;
-    std::vector<int> episodeIDs;
-    std::vector<int> musicVideoIDs;
+    std::string filesToTestForDelete;
 
     int total = m_pDS->num_rows();
     int current = 0;
 
     while (!m_pDS->eof())
     {
-      CStdString path = m_pDS->fv("path.strPath").get_asString();
-      CStdString fileName = m_pDS->fv("files.strFileName").get_asString();
+      std::string path = m_pDS->fv("path.strPath").get_asString();
+      std::string fileName = m_pDS->fv("files.strFileName").get_asString();
       CStdString fullPath;
-      ConstructPath(fullPath,path,fileName);
+      ConstructPath(fullPath, path, fileName);
 
       // get the first stacked file
       if (URIUtils::IsStack(fullPath))
@@ -8068,296 +8060,302 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
 
       // remove optical, non-existing files
       if (URIUtils::IsOnDVD(fullPath) || !CFile::Exists(fullPath, false))
-        filesToDelete += m_pDS->fv("files.idFile").get_asString() + ",";
+        filesToTestForDelete += m_pDS->fv("files.idFile").get_asString() + ",";
 
-      if (!handle)
+      if (handle == NULL && progress != NULL)
       {
-        if (progress)
+        progress->SetPercentage(current * 100 / total);
+        progress->Progress();
+        if (progress->IsCanceled())
         {
-          progress->SetPercentage(current * 100 / total);
-          progress->Progress();
-          if (progress->IsCanceled())
-          {
-            progress->Close();
-            m_pDS->close();
-            ANNOUNCEMENT::CAnnouncementManager::Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnCleanFinished");
-            return;
-          }
+          progress->Close();
+          m_pDS->close();
+          ANNOUNCEMENT::CAnnouncementManager::Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnCleanFinished");
+          return;
         }
       }
-      else
-        handle->SetPercentage(current/(float)total*100);
+      else if (handle != NULL)
+        handle->SetPercentage(current * 100 / (float)total);
 
       m_pDS->next();
       current++;
     }
     m_pDS->close();
 
+    std::string filesToDelete;
+
     // Add any files that don't have a valid idPath entry to the filesToDelete list.
-    sql = "select files.idFile from files where idPath not in (select idPath from path)";
-    m_pDS->query(sql.c_str());
+    m_pDS->query("SELECT files.idFile FROM files WHERE NOT EXISTS (SELECT 1 FROM path WHERE path.idPath = files.idPath)");
     while (!m_pDS->eof())
     {
-      filesToDelete += m_pDS->fv("files.idFile").get_asString() + ",";
+      string file = m_pDS->fv("files.idFile").get_asString() + ",";
+      filesToTestForDelete += file;
+      filesToDelete += file;
+
       m_pDS->next();
     }
     m_pDS->close();
 
-    if ( ! filesToDelete.empty() )
+    std::map<int, bool> pathsDeleteDecisions;
+    std::vector<int> movieIDs;
+    std::vector<int> tvshowIDs;
+    std::vector<int> episodeIDs;
+    std::vector<int> musicVideoIDs;
+
+    if (!filesToTestForDelete.empty())
     {
-      StringUtils::TrimRight(filesToDelete, ",");
-      // now grab them movies
-      sql = PrepareSQL("select idMovie from movie where idFile in (%s)",filesToDelete.c_str());
-      m_pDS->query(sql.c_str());
-      while (!m_pDS->eof())
-      {
-        movieIDs.push_back(m_pDS->fv(0).get_asInt());
-        moviesToDelete += m_pDS->fv(0).get_asString() + ",";
-        m_pDS->next();
-      }
-      m_pDS->close();
-      // now grab them episodes
-      sql = PrepareSQL("select idEpisode from episode where idFile in (%s)",filesToDelete.c_str());
-       m_pDS->query(sql.c_str());
-      while (!m_pDS->eof())
-      {
-        episodeIDs.push_back(m_pDS->fv(0).get_asInt());
-        episodesToDelete += m_pDS->fv(0).get_asString() + ",";
-        m_pDS->next();
-      }
-      m_pDS->close();
+      StringUtils::TrimRight(filesToTestForDelete, ",");
 
-      // now grab them musicvideos
-      sql = PrepareSQL("select idMVideo from musicvideo where idFile in (%s)",filesToDelete.c_str());
-      m_pDS->query(sql.c_str());
-      while (!m_pDS->eof())
-      {
-        musicVideoIDs.push_back(m_pDS->fv(0).get_asInt());
-        musicVideosToDelete += m_pDS->fv(0).get_asString() + ",";
-        m_pDS->next();
-      }
-      m_pDS->close();
+      movieIDs = CleanMediaType("movie", filesToTestForDelete, pathsDeleteDecisions, filesToDelete, !showProgress);
+      episodeIDs = CleanMediaType("episode", filesToTestForDelete, pathsDeleteDecisions, filesToDelete, !showProgress);
+      musicVideoIDs = CleanMediaType("musicvideo", filesToTestForDelete, pathsDeleteDecisions, filesToDelete, !showProgress);
     }
 
-    if (progress)
+    if (progress != NULL)
     {
       progress->SetPercentage(100);
       progress->Progress();
     }
 
-    if ( ! filesToDelete.empty() )
+    if (!filesToDelete.empty())
     {
-      filesToDelete = "(" + filesToDelete + ")";
+      filesToDelete = "(" + StringUtils::TrimRight(filesToDelete, ",") + ")";
+
       CLog::Log(LOGDEBUG, "%s: Cleaning files table", __FUNCTION__);
-      sql = "delete from files where idFile in " + filesToDelete;
+      sql = "DELETE FROM files WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning streamdetails table", __FUNCTION__);
-      sql = "delete from streamdetails where idFile in " + filesToDelete;
+      sql = "DELETE FROM streamdetails WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning bookmark table", __FUNCTION__);
-      sql = "delete from bookmark where idFile in " + filesToDelete;
+      sql = "DELETE FROM bookmark WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning settings table", __FUNCTION__);
-      sql = "delete from settings where idFile in " + filesToDelete;
+      sql = "DELETE FROM settings WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning stacktimes table", __FUNCTION__);
-      sql = "delete from stacktimes where idFile in " + filesToDelete;
+      sql = "DELETE FROM stacktimes WHERE idFile IN " + filesToDelete;
       m_pDS->exec(sql.c_str());
     }
 
-    if ( ! moviesToDelete.empty() )
+    if (!movieIDs.empty())
     {
+      std::string moviesToDelete;
+      for (std::vector<int>::const_iterator it = movieIDs.begin(); it != movieIDs.end(); ++it)
+        moviesToDelete += StringUtils::Format("%i,", *it);
       moviesToDelete = "(" + StringUtils::TrimRight(moviesToDelete, ",") + ")";
 
       CLog::Log(LOGDEBUG, "%s: Cleaning movie table", __FUNCTION__);
-      sql = "delete from movie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM movie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning actorlinkmovie table", __FUNCTION__);
-      sql = "delete from actorlinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM actorlinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning directorlinkmovie table", __FUNCTION__);
-      sql = "delete from directorlinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM directorlinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning writerlinkmovie table", __FUNCTION__);
-      sql = "delete from writerlinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM writerlinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning genrelinkmovie table", __FUNCTION__);
-      sql = "delete from genrelinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM genrelinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning countrylinkmovie table", __FUNCTION__);
-      sql = "delete from countrylinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM countrylinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning studiolinkmovie table", __FUNCTION__);
-      sql = "delete from studiolinkmovie where idMovie in " + moviesToDelete;
+      sql = "DELETE FROM studiolinkmovie WHERE idMovie IN " + moviesToDelete;
       m_pDS->exec(sql.c_str());
     }
 
-    if ( ! episodesToDelete.empty() )
+    if (!episodeIDs.empty())
     {
+      std::string episodesToDelete;
+      for (std::vector<int>::const_iterator it = episodeIDs.begin(); it != episodeIDs.end(); ++it)
+        episodesToDelete += StringUtils::Format("%i,", *it);
       episodesToDelete = "(" + StringUtils::TrimRight(episodesToDelete, ",") + ")";
 
       CLog::Log(LOGDEBUG, "%s: Cleaning episode table", __FUNCTION__);
-      sql = "delete from episode where idEpisode in " + episodesToDelete;
+      sql = "DELETE FROM episode WHERE idEpisode IN " + episodesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning actorlinkepisode table", __FUNCTION__);
-      sql = "delete from actorlinkepisode where idEpisode in " + episodesToDelete;
+      sql = "DELETE FROM actorlinkepisode WHERE idEpisode IN " + episodesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning directorlinkepisode table", __FUNCTION__);
-      sql = "delete from directorlinkepisode where idEpisode in " + episodesToDelete;
+      sql = "DELETE FROM directorlinkepisode WHERE idEpisode IN " + episodesToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning writerlinkepisode table", __FUNCTION__);
-      sql = "delete from writerlinkepisode where idEpisode in " + episodesToDelete;
+      sql = "DELETE FROM writerlinkepisode WHERE idEpisode IN " + episodesToDelete;
       m_pDS->exec(sql.c_str());
     }
 
     CLog::Log(LOGDEBUG, "%s: Cleaning paths that don't exist and have content set...", __FUNCTION__);
-    sql = "select * from path "
-            "where not ((strContent IS NULL OR strContent='') "
-                   "and (strSettings IS NULL OR strSettings='') "
-                   "and (strHash IS NULL OR strHash='') "
-                   "and (exclude IS NULL OR exclude!=1))";
+    sql = "SELECT path.idPath, path.strPath FROM path "
+            "WHERE NOT ((strContent IS NULL OR strContent = '') "
+                   "AND (strSettings IS NULL OR strSettings = '') "
+                   "AND (strHash IS NULL OR strHash = '') "
+                   "AND (exclude IS NULL OR exclude != 1))";
     m_pDS->query(sql.c_str());
-    CStdString strIds;
+    std::string strIds;
     while (!m_pDS->eof())
     {
-      if (!CDirectory::Exists(m_pDS->fv("path.strPath").get_asString()))
-        strIds += StringUtils::Format("%i,", m_pDS->fv("path.idPath").get_asInt());
+      std::map<int, bool>::const_iterator pathsDeleteDecision = pathsDeleteDecisions.find(m_pDS->fv(0).get_asInt());
+      if ((pathsDeleteDecision != pathsDeleteDecisions.end() && pathsDeleteDecision->second) ||
+          (pathsDeleteDecision == pathsDeleteDecisions.end() && !CDirectory::Exists(m_pDS->fv(1).get_asString())))
+        strIds += m_pDS->fv(0).get_asString() + ",";
+
       m_pDS->next();
     }
     m_pDS->close();
+
     if (!strIds.empty())
     {
-      StringUtils::TrimRight(strIds, ",");
-      sql = PrepareSQL("delete from path where idPath in (%s)",strIds.c_str());
+      sql = PrepareSQL("DELETE FROM path WHERE idPath IN (%s)", StringUtils::TrimRight(strIds, ",").c_str());
       m_pDS->exec(sql.c_str());
-      sql = PrepareSQL("delete from tvshowlinkpath where idPath in (%s)",strIds.c_str());
+      sql = "DELETE FROM tvshowlinkpath WHERE NOT EXISTS (SELECT 1 FROM path WHERE path.idPath = tvshowlinkpath.idPath)";
       m_pDS->exec(sql.c_str());
     }
-    sql = "delete from tvshowlinkpath where idPath not in (select idPath from path)";
-    m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning tvshow table", __FUNCTION__);
-    sql = "delete from tvshow where idShow not in (select idShow from tvshowlinkpath)";
+    sql = "DELETE FROM tvshow WHERE NOT EXISTS (SELECT 1 FROM tvshowlinkpath WHERE tvshowlinkpath.idShow = tvshow.idShow)";
     m_pDS->exec(sql.c_str());
 
-    std::vector<int> tvshowIDs;
-    CStdString showsToDelete;
-    sql = "select tvshow.idShow from tvshow "
-            "join tvshowlinkpath on tvshow.idShow=tvshowlinkpath.idShow "
-            "join path on path.idPath=tvshowlinkpath.idPath "
-          "where tvshow.idShow not in (select idShow from episode) "
-            "and (path.strContent IS NULL OR path.strContent='')";
+    std::string tvshowsToDelete;
+    sql = "SELECT tvshow.idShow FROM tvshow "
+            "JOIN tvshowlinkpath ON tvshow.idShow = tvshowlinkpath.idShow "
+            "JOIN path ON path.idPath = tvshowlinkpath.idPath "
+          "WHERE NOT EXISTS (SELECT 1 FROM episode WHERE episode.idShow = tvshow.idShow) "
+            "AND (path.strContent IS NULL OR path.strContent = '')";
     m_pDS->query(sql.c_str());
     while (!m_pDS->eof())
     {
       tvshowIDs.push_back(m_pDS->fv(0).get_asInt());
-      showsToDelete += m_pDS->fv(0).get_asString() + ",";
+      tvshowsToDelete += m_pDS->fv(0).get_asString() + ",";
       m_pDS->next();
     }
     m_pDS->close();
-    if (!showsToDelete.empty())
+    if (!tvshowsToDelete.empty())
     {
-      sql = "delete from tvshow where idShow in (" + StringUtils::TrimRight(showsToDelete, ",") + ")";
+      sql = "DELETE FROM tvshow WHERE idShow IN (" + StringUtils::TrimRight(tvshowsToDelete, ",") + ")";
       m_pDS->exec(sql.c_str());
-    }
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning actorlinktvshow table", __FUNCTION__);
-    sql = "delete from actorlinktvshow where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning actorlinktvshow table", __FUNCTION__);
+      sql = "DELETE FROM actorlinktvshow WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = actorlinktvshow.idShow)";
+      m_pDS->exec(sql.c_str());
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning directorlinktvshow table", __FUNCTION__);
-    sql = "delete from directorlinktvshow where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning directorlinktvshow table", __FUNCTION__);
+      sql = "DELETE FROM directorlinktvshow WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = directorlinktvshow.idShow)";
+      m_pDS->exec(sql.c_str());
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning tvshowlinkpath table", __FUNCTION__);
-    sql = "delete from tvshowlinkpath where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning tvshowlinkpath table", __FUNCTION__);
+      sql = "DELETE FROM tvshowlinkpath WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = tvshowlinkpath.idShow)";
+      m_pDS->exec(sql.c_str());
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning genrelinktvshow table", __FUNCTION__);
-    sql = "delete from genrelinktvshow where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning genrelinktvshow table", __FUNCTION__);
+      sql = "DELETE FROM genrelinktvshow WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = genrelinktvshow.idShow)";
+      m_pDS->exec(sql.c_str());
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning seasons table", __FUNCTION__);
-    sql = "delete from seasons where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning seasons table", __FUNCTION__);
+      sql = "DELETE FROM seasons WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = seasons.idShow)";
+      m_pDS->exec(sql.c_str());
 
-    CLog::Log(LOGDEBUG, "%s: Cleaning movielinktvshow table", __FUNCTION__);
-    sql = "delete from movielinktvshow where idShow not in (select idShow from tvshow)";
-    m_pDS->exec(sql.c_str());
-    sql = "delete from movielinktvshow where idMovie not in (select distinct idMovie from movie)";
-    m_pDS->exec(sql.c_str());
+      CLog::Log(LOGDEBUG, "%s: Cleaning movielinktvshow table", __FUNCTION__);
+      sql = "DELETE FROM movielinktvshow WHERE NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.idShow = movielinktvshow.idShow)";
+      m_pDS->exec(sql.c_str());
+      sql = "DELETE FROM movielinktvshow WHERE NOT EXISTS (SELECT 1 FROM movie WHERE movie.idMovie = movielinktvshow.idMovie)";
+      m_pDS->exec(sql.c_str());
+    }
 
-    if ( ! musicVideosToDelete.empty() )
+    if (!musicVideoIDs.empty())
     {
+      std::string musicVideosToDelete;
+      for (std::vector<int>::const_iterator it = musicVideoIDs.begin(); it != musicVideoIDs.end(); ++it)
+        musicVideosToDelete += StringUtils::Format("%i,", *it);
       musicVideosToDelete = "(" + StringUtils::TrimRight(musicVideosToDelete, ",") + ")";
 
       CLog::Log(LOGDEBUG, "%s: Cleaning musicvideo table", __FUNCTION__);
-      sql = "delete from musicvideo where idMVideo in " + musicVideosToDelete;
+      sql = "DELETE FROM musicvideo WHERE idMVideo IN " + musicVideosToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning artistlinkmusicvideo table", __FUNCTION__);
-      sql = "delete from artistlinkmusicvideo where idMVideo in " + musicVideosToDelete;
+      sql = "DELETE FROM artistlinkmusicvideo WHERE idMVideo IN " + musicVideosToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning directorlinkmusicvideo table" ,__FUNCTION__);
-      sql = "delete from directorlinkmusicvideo where idMVideo in " + musicVideosToDelete;
+      sql = "DELETE FROM directorlinkmusicvideo WHERE idMVideo IN " + musicVideosToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning genrelinkmusicvideo table" ,__FUNCTION__);
-      sql = "delete from genrelinkmusicvideo where idMVideo in " + musicVideosToDelete;
+      sql = "DELETE FROM genrelinkmusicvideo WHERE idMVideo IN " + musicVideosToDelete;
       m_pDS->exec(sql.c_str());
 
       CLog::Log(LOGDEBUG, "%s: Cleaning studiolinkmusicvideo table", __FUNCTION__);
-      sql = "delete from studiolinkmusicvideo where idMVideo in " + musicVideosToDelete;
+      sql = "DELETE FROM studiolinkmusicvideo WHERE idMVideo IN " + musicVideosToDelete;
       m_pDS->exec(sql.c_str());
     }
 
     CLog::Log(LOGDEBUG, "%s: Cleaning path table", __FUNCTION__);
-    sql = StringUtils::Format("delete from path "
-                                "where (strContent is null or strContent='') "
-                                  "and (strSettings is null or strSettings='') "
-                                  "and (strHash is null or strHash='') "
-                                  "and (exclude is null or exclude!=1) "
-                                  "and idPath not in (select distinct idPath from files) "
-                                  "and idPath not in (select distinct idPath from tvshowlinkpath) "
-                                  "and idPath not in (select distinct c%02d from movie) "
-                                  "and idPath not in (select distinct c%02d from tvshow) "
-                                  "and idPath not in (select distinct c%02d from episode) "
-                                  "and idPath not in (select distinct c%02d from musicvideo)"
+    sql = StringUtils::Format("DELETE FROM path "
+                                "WHERE (strContent IS NULL OR strContent = '') "
+                                  "AND (strSettings IS NULL OR strSettings = '') "
+                                  "and (strHash IS NULL OR strHash = '') "
+                                  "AND (exclude IS NULL OR exclude != 1) "
+                                  "AND NOT EXISTS (SELECT 1 FROM files WHERE files.idPath = path.idPath) "
+                                  "AND NOT EXISTS (SELECT 1 FROM tvshowlinkpath WHERE tvshowlinkpath.idPath = path.idPath) "
+                                  "AND NOT EXISTS (SELECT 1 FROM movie WHERE movie.c%02d = path.idPath) "
+                                  "AND NOT EXISTS (SELECT 1 FROM tvshow WHERE tvshow.c%02d = path.idPath) "
+                                  "AND NOT EXISTS (SELECT 1 FROM episode WHERE episode.c%02d = path.idPath) "
+                                  "AND NOT EXISTS (SELECT 1 FROM musicvideo WHERE musicvideo.c%02d = path.idPath)"
                 , VIDEODB_ID_PARENTPATHID, VIDEODB_ID_TV_PARENTPATHID, VIDEODB_ID_EPISODE_PARENTPATHID, VIDEODB_ID_MUSICVIDEO_PARENTPATHID );
     m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning genre table", __FUNCTION__);
-    sql = "delete from genre where idGenre not in (select distinct idGenre from genrelinkmovie) and idGenre not in (select distinct idGenre from genrelinktvshow) and idGenre not in (select distinct idGenre from genrelinkmusicvideo)";
+    sql = "DELETE FROM genre "
+            "WHERE NOT EXISTS (SELECT 1 FROM genrelinkmovie WHERE genrelinkmovie.idGenre = genre.idGenre) "
+              "AND NOT EXISTS (SELECT 1 FROM genrelinktvshow WHERE genrelinktvshow.idGenre = genre.idGenre) "
+              "AND NOT EXISTS (SELECT 1 FROM genrelinkmusicvideo WHERE genrelinkmusicvideo.idGenre = genre.idGenre)";
     m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning country table", __FUNCTION__);
-    sql = "delete from country where idCountry not in (select distinct idCountry from countrylinkmovie)";
+    sql = "DELETE FROM country WHERE NOT EXISTS (SELECT 1 FROM countrylinkmovie WHERE countrylinkmovie.idCountry = country.idCountry)";
     m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning actor table of actors, directors and writers", __FUNCTION__);
-    sql = "delete from actors where idActor not in (select distinct idActor from actorlinkmovie) and idActor not in (select distinct idDirector from directorlinkmovie) and idActor not in (select distinct idWriter from writerlinkmovie) and idActor not in (select distinct idActor from actorlinktvshow) and idActor not in (select distinct idActor from actorlinkepisode) and idActor not in (select distinct idDirector from directorlinktvshow) and idActor not in (select distinct idDirector from directorlinkepisode) and idActor not in (select distinct idWriter from writerlinkepisode) and idActor not in (select distinct idArtist from artistlinkmusicvideo) and idActor not in (select distinct idDirector from directorlinkmusicvideo)";
+    sql = "DELETE FROM actors "
+            "WHERE NOT EXISTS (SELECT 1 FROM actorlinkmovie WHERE actorlinkmovie.idActor = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM directorlinkmovie WHERE directorlinkmovie.idDirector = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM writerlinkmovie WHERE writerlinkmovie.idWriter = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM actorlinktvshow WHERE actorlinktvshow.idActor = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM actorlinkepisode WHERE actorlinkepisode.idActor = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM directorlinktvshow WHERE directorlinktvshow.idDirector = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM directorlinkepisode WHERE directorlinkepisode.idDirector = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM writerlinkepisode WHERE writerlinkepisode.idWriter = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM artistlinkmusicvideo WHERE artistlinkmusicvideo.idArtist = actors.idActor) "
+              "AND NOT EXISTS (SELECT 1 FROM directorlinkmusicvideo WHERE directorlinkmusicvideo.idDirector = actors.idActor)";
     m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning studio table", __FUNCTION__);
-    sql = "delete from studio where idStudio not in (select distinct idStudio from studiolinkmovie) and idStudio not in (select distinct idStudio from studiolinkmusicvideo) and idStudio not in (select distinct idStudio from studiolinktvshow)";
+    sql = "DELETE FROM studio "
+            "WHERE NOT EXISTS (SELECT 1 FROM studiolinkmovie WHERE studiolinkmovie.idStudio = studio.idStudio) "
+              "AND NOT EXISTS (SELECT 1 FROM studiolinkmusicvideo WHERE studiolinkmusicvideo.idStudio = studio.idStudio) "
+              "AND NOT EXISTS (SELECT 1 FROM studiolinktvshow WHERE studiolinktvshow.idStudio = studio.idStudio)";
     m_pDS->exec(sql.c_str());
 
     CLog::Log(LOGDEBUG, "%s: Cleaning set table", __FUNCTION__);
-    sql = "delete from sets where idSet not in (select distinct idSet from movie)";
+    sql = "DELETE FROM sets WHERE NOT EXISTS (SELECT 1 FROM movie WHERE movie.idSet = sets.idSet)";
     m_pDS->exec(sql.c_str());
 
     CommitTransaction();
@@ -8372,17 +8370,17 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
     time = XbmcThreads::SystemClockMillis() - time;
     CLog::Log(LOGNOTICE, "%s: Cleaning videodatabase done. Operation took %s", __FUNCTION__, StringUtils::SecondsToTimeString(time / 1000).c_str());
 
-    for (unsigned int i = 0; i < movieIDs.size(); i++)
-      AnnounceRemove("movie", movieIDs[i]);
+    for (std::vector<int>::const_iterator it = movieIDs.begin(); it != movieIDs.end(); ++it)
+      AnnounceRemove("movie", *it);
 
-    for (unsigned int i = 0; i < episodeIDs.size(); i++)
-      AnnounceRemove("episode", episodeIDs[i]);
+    for (std::vector<int>::const_iterator it = episodeIDs.begin(); it != episodeIDs.end(); ++it)
+      AnnounceRemove("episode", *it);
 
-    for (unsigned int i = 0; i < tvshowIDs.size(); i++)
-      AnnounceRemove("tvshow", tvshowIDs[i]);
+    for (std::vector<int>::const_iterator it = tvshowIDs.begin(); it != tvshowIDs.end(); ++it)
+      AnnounceRemove("tvshow", *it);
 
-    for (unsigned int i = 0; i < musicVideoIDs.size(); i++)
-      AnnounceRemove("musicvideo", musicVideoIDs[i]);
+    for (std::vector<int>::const_iterator it = musicVideoIDs.begin(); it != musicVideoIDs.end(); ++it)
+      AnnounceRemove("musicvideo", *it);
   }
   catch (...)
   {
@@ -8395,6 +8393,105 @@ void CVideoDatabase::CleanDatabase(CGUIDialogProgressBarHandle* handle, const se
   ANNOUNCEMENT::CAnnouncementManager::Announce(ANNOUNCEMENT::VideoLibrary, "xbmc", "OnCleanFinished");
 }
 
+std::vector<int> CVideoDatabase::CleanMediaType(const std::string &mediaType, const std::string &cleanableFileIDs,
+                                                std::map<int, bool> &pathsDeleteDecisions, std::string &deletedFileIDs, bool silent)
+{
+  std::vector<int> cleanedIDs;
+  if (mediaType.empty() || cleanableFileIDs.empty())
+    return cleanedIDs;
+
+  std::string table = mediaType;
+  std::string idField;
+  std::string parentPathIdField;
+  bool isEpisode = false;
+  if (mediaType == "movie")
+  {
+    idField = "idMovie";
+    parentPathIdField = StringUtils::Format("%s.c%02d", table.c_str(), VIDEODB_ID_PARENTPATHID);
+  }
+  else if (mediaType == "episode")
+  {
+    idField = "idEpisode";
+    parentPathIdField = StringUtils::Format("tvshow.c%02d", VIDEODB_ID_TV_PARENTPATHID);
+    isEpisode = true;
+  }
+  else if (mediaType == "musicvideo")
+  {
+    idField = "idMVideo";
+    parentPathIdField = StringUtils::Format("%s.c%02d", table.c_str(), VIDEODB_ID_MUSICVIDEO_PARENTPATHID);
+  }
+  else
+    return cleanedIDs;
+
+  // now grab them media items
+  std::string sql = PrepareSQL("SELECT %s.%s, %s.idFile, %s, path.idPath, parentPath.strPath FROM %s "
+                                 "JOIN files ON files.idFile = %s.idFile "
+                                 "JOIN path ON path.idPath = files.idPath ",
+                               table.c_str(), idField.c_str(), table.c_str(), parentPathIdField.c_str(), table.c_str(),
+                               table.c_str());
+
+  if (isEpisode)
+    sql += "JOIN tvshow ON tvshow.idShow = episode.idShow ";
+
+  sql += PrepareSQL("JOIN path as parentPath ON parentPath.idPath = %s "
+                    "WHERE %s.idFile IN (%s)",
+                    parentPathIdField.c_str(),
+                    table.c_str(), cleanableFileIDs.c_str());
+
+  m_pDS->query(sql.c_str());
+  while (!m_pDS->eof())
+  {
+    int parentPathID = m_pDS->fv(2).get_asInt();
+    std::map<int, bool>::const_iterator pathsDeleteDecision = pathsDeleteDecisions.find(parentPathID);
+    bool del = true;
+    if (pathsDeleteDecision == pathsDeleteDecisions.end())
+    {
+      std::string parentPath = m_pDS->fv(4).get_asString();
+      if (!CDirectory::Exists(parentPath, false))
+      {
+        // in silent mode assume that the files are just temporarily missing
+        if (silent)
+          del = false;
+        else
+        {
+          CGUIDialogYesNo* pDialog = (CGUIDialogYesNo*)g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO);
+          if (pDialog != NULL)
+          {
+            pDialog->SetHeading(15012);
+            pDialog->SetLine(1, 15013);
+            pDialog->SetLine(2, parentPath);
+            pDialog->SetChoice(0, 15015);
+            pDialog->SetChoice(1, 15014);
+
+            //send message and wait for user input
+            ThreadMessage tMsg = { TMSG_DIALOG_DOMODAL, WINDOW_DIALOG_YES_NO, (unsigned int)g_windowManager.GetActiveWindow() };
+            CApplicationMessenger::Get().SendMessage(tMsg, true);
+
+            del = !pDialog->IsConfirmed();
+          }
+        }
+      }
+
+      pathsDeleteDecisions.insert(make_pair(parentPathID, del));
+    }
+    else
+      del = pathsDeleteDecision->second;
+
+    pathsDeleteDecisions.insert(make_pair(m_pDS->fv(3).get_asInt(), del));
+
+    if (del)
+    {
+      deletedFileIDs += m_pDS->fv(1).get_asString() + ",";
+      cleanedIDs.push_back(m_pDS->fv(0).get_asInt());
+    }
+
+    m_pDS->next();
+  }
+  m_pDS->close();
+
+  return cleanedIDs;
+}
+
 void CVideoDatabase::DumpToDummyFiles(const CStdString &path)
 {
   // get all tvshows
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 2fe6c39..44f94fa 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -843,6 +843,9 @@ private:
    */
   CStdString GetSafeFile(const CStdString &dir, const CStdString &name) const;
 
+  std::vector<int> CleanMediaType(const std::string &mediaType, const std::string &cleanableFileIDs,
+                                  std::map<int, bool> &pathsDeleteDecisions, std::string &deletedFileIDs, bool silent);
+
   void AnnounceRemove(std::string content, int id);
   void AnnounceUpdate(std::string content, int id);
 };
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 07cba40..b538603 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -237,7 +237,7 @@ bool CVideoInfoTag::Save(TiXmlNode *node, const CStdString &tag, bool savePathIn
   XMLUtils::SetFloat(&resume, "total", (float)m_resumePoint.totalTimeInSeconds);
   movie->InsertEndChild(resume);
 
-  XMLUtils::SetString(movie, "dateadded", m_dateAdded.GetAsDBDateTime());
+  XMLUtils::SetDateTime(movie, "dateadded", m_dateAdded);
 
   if (additionalNode)
     movie->InsertEndChild(*additionalNode);
@@ -769,10 +769,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
     XMLUtils::GetDouble(resume, "total", m_resumePoint.totalTimeInSeconds);
   }
 
-  // dateAdded
-  CStdString dateAdded;
-  XMLUtils::GetString(movie, "dateadded", dateAdded);
-  m_dateAdded.SetFromDBDateTime(dateAdded);
+  XMLUtils::GetDateTime(movie, "dateadded", m_dateAdded);
 }
 
 bool CVideoInfoTag::HasStreamDetails() const
