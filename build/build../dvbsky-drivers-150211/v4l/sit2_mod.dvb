/*+++ *******************************************************************\ 
*     SIT2  - DVB-T2/T/C demodulator and tuner
*
*     --------------------------------------------------------------- 
*     This software is provided "AS IS" without warranty of any kind, 
*     either expressed or implied, including but not limited to the 
*     implied warranties of noninfringement, merchantability and/or 
*     fitness for a particular purpose.
*     --------------------------------------------------------------- 
*   
*     Copyright (c) 2013 ShenZhen Bestunar Ltd,Inc.
*     All rights reserved. 
*     Max Nibble <nibble.max@gmail.com>
*
*
\******************************************************************* ---*/ 
#include <linux/delay.h>
#include <linux/errno.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/string.h>
//#include <linux/slab.h>
#include <asm/div64.h>
//#include "kmem_func.h"
#include "dvb_frontend.h"
#include "sit2.h"
#include "sit2_op.h"

static void sit2_drv_release(struct dvb_frontend *fe)
{
	struct sit2_state *state = fe->demodulator_priv;
	kfree(state);
}

static const struct dvb_frontend_ops sit2_ops = {
	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
	/*.delsys = { SYS_DVBC_ANNEX_A },*/
	/* default: DVB-T/T2 */
	.info = {
		.name = "Sit2 DVB-T2/C",
		.frequency_stepsize = 62500,
		.frequency_min = 48000000,
		.frequency_max = 870000000,
		.symbol_rate_min = 870000,
		.symbol_rate_max = 7500000,
		.caps =	FE_CAN_FEC_1_2			|
			FE_CAN_FEC_2_3			|
			FE_CAN_FEC_3_4			|
			FE_CAN_FEC_5_6			|
			FE_CAN_FEC_7_8			|
			FE_CAN_FEC_AUTO			|
			FE_CAN_QPSK			|
			FE_CAN_QAM_16			|
			FE_CAN_QAM_32			|
			FE_CAN_QAM_64			|
			FE_CAN_QAM_128			|
			FE_CAN_QAM_256			|
			FE_CAN_QAM_AUTO			|
			FE_CAN_TRANSMISSION_MODE_AUTO	|
			FE_CAN_GUARD_INTERVAL_AUTO	|
			FE_CAN_HIERARCHY_AUTO		|
			FE_CAN_MUTE_TS			|
			FE_CAN_2G_MODULATION		|
			FE_CAN_MULTISTREAM
		},

	.release		= sit2_drv_release,
	.init			= sit2_drv_init,
	.sleep			= sit2_drv_sleep,

	.tune			= sit2_drv_tune,
	.set_frontend		= sit2_drv_set_frontend,
	.get_frontend		= sit2_drv_get_frontend,
	.get_frontend_algo	= sit2_drv_get_frontend_algo,

	.read_status		= sit2_drv_read_status,
	.read_snr		= sit2_drv_read_snr,
	.read_ber		= sit2_drv_read_ber,
	.read_ucblocks		= sit2_drv_read_ucblocks,
	.read_signal_strength	= sit2_drv_read_signal_strength,
};

struct dvb_frontend *sit2_attach(const struct sit2_config *config,
		struct i2c_adapter *i2c)
{
	struct sit2_state *state = NULL;
	state = kzalloc(sizeof(struct sit2_state), GFP_KERNEL);
	
	if (!state) {
#ifdef _SIT2_DEBUG_
		dev_err(&i2c->dev, "%s: kzalloc() failed\n",
				KBUILD_MODNAME);
#endif
		goto error;
	}	
	sit2_op_attach(state, config, i2c);
	
	memcpy(&state->frontend.ops, &sit2_ops,
	       sizeof(struct dvb_frontend_ops));
	state->frontend.demodulator_priv = state;
	return &state->frontend;
error:
	kfree(state);
	return NULL;
}
EXPORT_SYMBOL(sit2_attach);

MODULE_DESCRIPTION("sit2 demodulator driver");
MODULE_AUTHOR("Max Nibble <nibble.max@gmail.com>");
MODULE_LICENSE("GPL");
