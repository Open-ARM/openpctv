diff -uNr xbmc-13.2rc1-Gotham.orig/configure.in xbmc-13.2rc1-Gotham/configure.in
--- xbmc-13.2rc1-Gotham.orig/configure.in	2014-08-13 18:26:13.168539059 +0800
+++ xbmc-13.2rc1-Gotham/configure.in	2014-08-13 18:27:01.700779715 +0800
@@ -188,13 +188,16 @@
 libcec_enabled="== libcec enabled. =="
 libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
 
-# External library message strings
-external_libraries_enabled="== Use of all supported external libraries enabled. =="
-external_libraries_disabled="== Use of all supported external libraries disabled. =="
 dashes="------------------------"
 final_message="\n  XBMC Configuration:"
 final_message="\n$dashes$final_message\n$dashes"
 
+AC_ARG_WITH([ffmpeg],
+  [AS_HELP_STRING([--with-ffmpeg],
+  [ffmpeg options: auto (search pkg-config or auto build), force (always build ffmpeg), shared (link dynamically), path_to_ffmpeg [default=force]])],
+  [ffmpeg_dir=$with_ffmpeg],
+  [with_ffmpeg=force])
+
 AC_ARG_ENABLE([shared-lib],
   [AS_HELP_STRING([--enable-shared-lib],
   [build libxbmc. helpful for tests (default is no)])],
@@ -207,30 +210,12 @@
   [use_debug=$enableval],
   [use_debug=yes])
 
-AC_ARG_WITH([arch],
-  [AS_HELP_STRING([--with-arch],
-  [build with given arch passing to internal ffmpeg (default is no, needed for crosscompiling)])],
-  [use_arch=$withval],
-  [use_arch=no])
-
 AC_ARG_WITH([platform],
   [AS_HELP_STRING([--with-platform],
   [use a pre-configured config for common arm boards])],
   [use_platform=$withval],
   [use_platform=none])
 
-AC_ARG_WITH([cpu],
-  [AS_HELP_STRING([--with-cpu],
-  [build with given cpu passing to ffmpeg (default is no)])],
-  [use_cpu=$withval],
-  [use_cpu=no])
-
-AC_ARG_ENABLE([neon],
-  [AS_HELP_STRING([--enable-neon],
-  [enable neon passing to ffmpeg (default is no)])],
-  [use_neon=$enableval],
-  [use_neon=no])
-
 AC_ARG_ENABLE([optimizations],
   [AS_HELP_STRING([--enable-optimizations],
   [enable optimization (default is yes)])],
@@ -423,12 +408,6 @@
   [use_upnp=$enableval],
   [use_upnp=yes])
 
-AC_ARG_ENABLE([ffmpeg_libvorbis],
-  [AS_HELP_STRING([--enable-ffmpeg-libvorbis],
-  [enable FFmpeg vorbis encoding (default is no)])],
-  [use_ffmpeg_libvorbis=$enableval],
-  [use_ffmpeg_libvorbis=no])
-
 AC_ARG_ENABLE([dvdcss],
   [AS_HELP_STRING([--enable-dvdcss],
   [enable DVDCSS support (default is yes)])],
@@ -562,13 +541,6 @@
   [add_codecs=$enableval],
   [add_codecs=no])
 
-### External libraries options
-AC_ARG_ENABLE([external-libraries],
-  [AS_HELP_STRING([--enable-external-libraries],
-  [enable use of all supported external libraries (default is no) 'Linux only'])],
-  [use_external_libraries=$enableval],
-  [use_external_libraries=no])
-
 AC_ARG_ENABLE([libav-compat],
   [AS_HELP_STRING([--enable-libav-compat],
   [build a wrapper around libav to provide the functions needed by XBMC. This is
@@ -602,17 +574,6 @@
 READELF="${READELF:-readelf}"
 NM="${NM:-nm}"
 
-use_external_ffmpeg=no
-use_static_ffmpeg=no
-
-# ffmpeg needs the output of uname -s (e.x. linux, darwin) for the target_os
-# there is no autoconf variable which will give
-# the correct output format when doing cross compilation
-# so we have to use our own var here
-# defaults to the build side target_os
-# and should be overridden for cross below (see android)
-ffmpeg_target_os=$(tolower $(uname -s))
-
 # host detection and setup
 case $host in
   i*86*-linux-android*)
@@ -620,7 +581,6 @@
      ARCH="i486-linux"
      use_arch="x86"
      use_cpu="i686"
-     ffmpeg_target_os=linux
      use_joystick=no
      use_gles=yes
      use_optical_drive=no
@@ -634,7 +594,7 @@
         use_arch="x86"
         use_cpu="i686"
      fi
-     use_static_ffmpeg=yes
+     USE_STATIC_FFMPEG=1
      ;;
   x86_64-*-linux-gnu*|x86_64-*-linux-uclibc*)
      ARCH="x86_64-linux"
@@ -642,7 +602,7 @@
         use_arch="x86_64"
         use_cpu="x86_64"
      fi
-     use_static_ffmpeg=yes
+     USE_STATIC_FFMPEG=1
      ;;
   i386-*-freebsd*)
      ARCH="x86-freebsd"
@@ -691,21 +651,19 @@
   arm*-*-linux-gnu*|arm*-*-linux-uclibc*)
      ARCH="arm"
      use_arch="arm"
-     ffmpeg_target_os=linux
      use_joystick=no
      use_neon=yes
      use_gles=yes
      use_sdl=no
      use_x11=no
      use_wayland=no
-     use_static_ffmpeg=yes
+     USE_STATIC_FFMPEG=1
      ;;
   arm*-*linux-android*)
      target_platform=target_android
      use_arch="arm"
      use_cpu=cortex-a9
      ARCH="arm"
-     ffmpeg_target_os=linux
      use_joystick=no
      use_neon=yes
      use_gles=yes
@@ -750,7 +708,6 @@
      USE_OMXLIB=1; AC_DEFINE([HAVE_OMXLIB],[1],["Define to 1 if OMX libs is enabled"])
      CFLAGS="$CFLAGS"
      CXXFLAGS="$CXXFLAGS"
-     ffmpeg_target_os=linux
      ;;
 esac
 
@@ -826,7 +783,6 @@
   CXXFLAGS="$CXXFLAGS -I$LOCALBASE/include"
   CPPFLAGS="$CPPFLAGS -I$LOCALBASE/include"
   LDFLAGS="$LDFLAGS -L$LOCALBASE/lib"
-  FFMPEG_EXTRACFLAGS="-I$LOCALBASE/include"
 fi
 if test "$host_vendor" = "apple" ; then
   # standard xbmc paths
@@ -847,14 +803,12 @@
     LIBS="$LIBS -framework SystemConfiguration"
     LIBS="$LIBS -framework VideoDecodeAcceleration"
   fi
-  USE_EXTERNAL_FFMPEG=1
 elif test "$target_platform" = "target_raspberry_pi"; then
   ARCH="arm"
   use_arch="arm"
 elif test "$use_arch" = "arm"; then
   CFLAGS="$CFLAGS -mno-apcs-stack-check"
   CXXFLAGS="$CXXFLAGS -mno-apcs-stack-check"
-  FFMPEG_EXTRACFLAGS=""
   if test "$use_tegra" = "yes"; then
     # Compile for ARMv7a architecture, need to test gcc for vfpv3-d16 support 
     SAVE_CFLAGS="$CFLAGS"
@@ -863,7 +817,6 @@
       [AC_LANG_SOURCE([int foo;])],
       [ CFLAGS="$SAVE_CFLAGS -Wno-psabi -Wa,-march=armv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork"
         CXXFLAGS="$CXXFLAGS -Wno-psabi -Wa,-march=armv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork"
-        FFMPEG_EXTRACFLAGS="$FFMPEG_EXTRACFLAGS -mtune=cortex-a9 -mfpu=vfpv3-d16"
         use_cpu=cortex-a9],
       [ CFLAGS="$SAVE_CFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
         CXXFLAGS="$CXXFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"    
@@ -872,19 +825,22 @@
     if test "$use_neon" = "yes"; then 
       CFLAGS="$CFLAGS -mfpu=neon -mvectorize-with-neon-quad"
       CXXFLAGS="$CXXFLAGS -mfpu=neon -mvectorize-with-neon-quad"
-      FFMPEG_EXTRACFLAGS="$FFMPEG_EXTRACFLAGS -mfpu=neon"
     fi
   fi
 fi
-if test "$use_static_ffmpeg" = "yes"; then
-  USE_STATIC_FFMPEG=1
-  AC_DEFINE([USE_STATIC_FFMPEG], [1], [link ffmpeg statically])
-  # ffmpeg may depend on gnutls and vorbisenc, we add those libs at the end of linker
-  # command in order to resolve any missing symbols
-  GNUTLS_ALL_LIBS=`${PKG_CONFIG} --static --libs-only-l --silence-errors gnutls`
-  HOGWEED_ALL_LIBS=`${PKG_CONFIG} --static --libs-only-l --silence-errors hogweed nettle`
-  VORBISENC_ALL_LIBS=`${PKG_CONFIG} --static --libs-only-l --silence-errors vorbisenc`
-fi 
+
+use_sse4=no
+if test "$ARCH" = "x86_64-linux" || test "$ARCH" = "i486-linux"; then
+    SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="-msse4.1"
+    AC_COMPILE_IFELSE(
+      [AC_LANG_SOURCE([int foo;])],
+      [ use_sse4=yes
+        USE_SSE4=1],
+      [ use_sse=no
+        USE_SSE4=0])
+    CFLAGS="$SAVE_CFLAGS"
+fi
 
 # Checks for library functions.
 AC_FUNC_ALLOCA
@@ -1128,7 +1084,7 @@
    AC_CHECK_LIB([gcrypt],[gcry_control],, AC_MSG_ERROR($missing_library))
    AC_DEFINE([HAVE_GCRYPT],[1],[Define if we have gcrypt])
 fi
-PKG_CHECK_MODULES([GNUTLS], [gnutls], [have_gnutls=yes];AC_DEFINE([HAVE_GNUTLS], [1], [Define if we have gnutls]), AC_MSG_WARN("gnutls not found, ffmpeg TLS support disabled"))
+PKG_CHECK_MODULES([GNUTLS], [gnutls], [have_gnutls=yes];AC_DEFINE([HAVE_GNUTLS], [1], [Define if we have gnutls]), AC_MSG_WARN("gnutls not found"))
 
 AC_CHECK_LIB([bz2],         [main],, AC_MSG_ERROR($missing_library))
 AC_CHECK_LIB([jpeg],        [main],, AC_MSG_ERROR($missing_library)) # check for cximage
@@ -1773,40 +1729,111 @@
   AC_MSG_NOTICE($libcap_disabled)
 fi
 
-### External libraries checks
+# FFmpeg
+FFMPEG_LIBNAMES="libavcodec >= 55.39.101
+                 libavfilter >= 3.90.100
+                 libavformat >= 55.19.104
+                 libavutil >= 52.48.101
+                 libpostproc >= 52.3.100
+                 libswscale >= 2.5.101
+                 libswresample >= 0.17.104"
+
+ffmpeg_build="${abs_top_srcdir}/tools/depends/target/ffmpeg"
+FFMPEG_VER_SHA=$(grep "VERSION=" ${ffmpeg_build}/FFMPEG-VERSION | sed 's/VERSION=//g')
+AC_DEFINE_UNQUOTED([FFMPEG_VER_SHA], ["$FFMPEG_VER_SHA"], [FFmpeg version hash])
+
+if test "$with_ffmpeg" = "shared"; then
+  # allow linking against shared ffmpeg libs
+  # a proper version must be installed, we won't build ffmpeg
+  USE_STATIC_FFMPEG=0
+  AC_DEFINE([USE_STATIC_FFMPEG], [0], [FFmpeg linked dynamically])
+fi
+if test "${USE_STATIC_FFMPEG}" = "1"; then
+  AC_DEFINE([USE_STATIC_FFMPEG], [1], [FFmpeg linked statically])
+  ff_libs=$(${ECHO} ${FFMPEG_LIBNAMES} | ${AWK} '/lib/{print $1}' ORS=' ')
+  if test -n "${PKG_CONFIG_SYSROOT_DIR}"; then
+    # workaround for cross compiling with buildroot on different buildsystem
+    # Rpi buildroots pkg-config returns static libs with
+    # PKG_CONFIG_SYSROOT_DIR prefixed, OEs does not
+    # so lets make sure we always prefix in case PKG_CONFIG_SYSROOT_DIR is defined
+    pkg_cfg_prefix="${PKG_CONFIG_SYSROOT_DIR}"
+  elif test "${target_platform}" = "target_raspberry_pi" && test "${USE_BUILDROOT}" = "1"; then
+      pkg_cfg_prefix=${SYSROOT}
+  fi
+
+  if test "$cross_compiling" != "yes"; then
+    if test "$use_debug" != "yes"; then
+      FFMPEG_OPTS="-r"
+    fi
+    if test "$use_optimizations" != "yes"; then
+      FFMPEG_OPTS="${FFMPEG_OPTS} --disable-optimizations"
+    fi
+
+    if test "$with_ffmpeg" = "auto" || test "$with_ffmpeg" = "yes"; then
+      SAVE_INCLUDES="$INCLUDES"
+      SAVE_LIBS="$LIBS"
+      # check for system installed ffmpeg. We require minimum versions.
+      PKG_CHECK_MODULES([FFMPEG], [$FFMPEG_LIBNAMES],
+        [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"; FFMPEG_FOUND="true"],
+        [FFMPEG_FOUND="false"])
+
+      if test "${USE_STATIC_FFMPEG}" = "1" && test "$FFMPEG_FOUND" = "true"; then
+        # we need to check if static libs are available
+        FFMPEG_LIBDIR=$(${PKG_CONFIG} --static --variable=libdir libavcodec)
+        for ff_lib in ${ff_libs}; do
+          if test -f ${FFMPEG_LIBDIR}/${ff_lib}.a; then :; else
+            AC_MSG_NOTICE("${FFMPEG_LIBDIR}/${ff_lib}.a not found")
+            FFMPEG_FOUND="false"
+            # restore includes and libs, the ones we found are invalid
+            INCLUDES="$SAVE_INCLUDES"
+            LIBS="$SAVE_LIBS"
+            unset FFMPEG_LIBS FFMPEG_CFLAGS FFMPEG_LIBDIR
+          fi
+        done
+      fi
+      if test "$with_ffmpeg" = "yes" || test "$FFMPEG_FOUND" = "false"; then
+        # ffmpeg not found with pkg-config, lets install it
+        AC_MSG_NOTICE("Installing FFmpeg")
+        CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" ${ffmpeg_build}/autobuild.sh ${FFMPEG_OPTS}
+        export PKG_CONFIG_PATH="${ffmpeg_build}/ffmpeg-install/lib/pkgconfig:$PKG_CONFIG_PATH"
+      fi
 
-# Hacks for supporting libav
+    elif test "$with_ffmpeg" = "force"; then
+      # always build our ffmpeg
+      AC_MSG_NOTICE("FFmpeg installation forced by user - installing our version")
+      CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" ${ffmpeg_build}/autobuild.sh ${FFMPEG_OPTS}
+      export PKG_CONFIG_PATH="${ffmpeg_build}/ffmpeg-install/lib/pkgconfig:$PKG_CONFIG_PATH"
 
-USE_LIBAV_HACKS=0
-if test "$use_libav_hacks" = "yes"; then
-    export PKG_CONFIG_PATH="${srcdir}/lib/xbmc-libav-hacks/pkgconfig/:$PKG_CONFIG_PATH"
-    USE_LIBAV_HACKS=1
-    AC_DEFINE([USE_LIBAV_HACKS], [1], [Whether to use libav compatibility hacks.])
+    elif test "$with_ffmpeg" != "no"; then
+      # user passed --with-ffmpeg=/some/path, lets use it
+      AC_MSG_NOTICE("using ffmpeg: ${with_ffmpeg}")
+      export PKG_CONFIG_PATH="${with_ffmpeg}/lib/pkgconfig:$PKG_CONFIG_PATH"
+    fi
+  fi
 fi
 
-# External FFmpeg
-if test "$use_external_ffmpeg" = "yes"; then
-  FFMPEG_LIBNAMES="libavcodec libavfilter libavformat libavutil libpostproc libswscale libswresample"
-
+if test "$FFMPEG_FOUND" != "true"; then
   PKG_CHECK_MODULES([FFMPEG], [$FFMPEG_LIBNAMES],
-                    [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"],
-                    AC_MSG_ERROR($missing_library))
-
-  # in case the headers are in a custom directory
-  SAVE_CPPFLAGS="$CPPFLAGS"
-  CPPFLAGS="$CPPFLAGS $FFMPEG_CFLAGS"
-
-  AC_CHECK_HEADERS([libavcodec/avcodec.h libavfilter/avfilter.h libavformat/avformat.h libavutil/avutil.h libpostproc/postprocess.h libswscale/swscale.h],,
-  [AC_MSG_ERROR($missing_headers)])
-
-  AC_MSG_NOTICE($external_ffmpeg_enabled)
-  USE_EXTERNAL_FFMPEG=1
-  AC_DEFINE([USE_EXTERNAL_FFMPEG], [1], [Whether to use external FFmpeg libraries.])
+    [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"; FFMPEG_FOUND="true"], 
+    [AC_MSG_ERROR("ffmpeg not found")])
+fi
 
-  CPPFLAGS="$SAVE_CPPFLAGS"
-else
-  AC_MSG_NOTICE($external_ffmpeg_disabled)
-  USE_EXTERNAL_FFMPEG=0
+if test "${USE_STATIC_FFMPEG}" = "1"; then
+  # get the libdir for static linking
+  FFMPEG_LIBDIR=${pkg_cfg_prefix}$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --static --variable=libdir libavcodec)
+  GNUTLS_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors gnutls)
+  VORBISENC_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors vorbisenc)
+
+  # check if static libs are available
+  for ff_lib in ${ff_libs}; do
+    if test -f ${FFMPEG_LIBDIR}/${ff_lib}.a; then :; else
+      AC_MSG_ERROR("${FFMPEG_LIBDIR}/${ff_lib}.a not found")
+    fi
+    # filter out libs we link statically
+    filter=$(${ECHO} ${ff_lib} | ${SED} 's/lib/-l/g')
+    LIBS=$(${ECHO} ${LIBS} | ${SED} "s/${filter}//g")
+  done
+  LIBS=$(${ECHO} ${LIBS} | ${SED} ':a;N;$!ba;s/\n/ /g')
 fi
 
 echo "Checking for SWIG installation"
@@ -2486,12 +2513,6 @@
 
 ### External libraries messages
 
-if test "$use_external_ffmpeg" = "yes"; then
-  final_message="$final_message\n  External FFmpeg:\tYes"
-else
-  final_message="$final_message\n  External FFmpeg:\tNo"
-fi
-
 if test "$host_vendor" = "apple" ; then
   # built internal but referenced as external, we link directly to them.
   # this MUST be the last thing before OUTPUT_FILES as they do not
@@ -2523,7 +2544,6 @@
     xbmc/cores/Makefile \
     xbmc/cores/VideoRenderers/Makefile \
     xbmc/cores/dvdplayer/Makefile \
-    lib/Makefile \
     lib/libdvd/Makefile \
     xbmc/cores/DllLoader/Makefile \
     xbmc/cores/DllLoader/exports/Makefile \
@@ -2602,6 +2622,10 @@
 OUTPUT_FILES="$OUTPUT_FILES xbmc/cores/dvdplayer/DVDCodecs/Video/libstagefrightICS/Makefile"
 fi
 
+if test "$use_sse4" = "yes"; then
+OUTPUT_FILES="$OUTPUT_FILES xbmc/linux/sse4/Makefile"
+fi
+
 OUTPUT_FILES="$OUTPUT_FILES \
   xbmc/interfaces/python/Makefile \
   xbmc/interfaces/python/test/Makefile"
@@ -2630,9 +2654,11 @@
 AC_SUBST(DISABLE_RSXS)
 AC_SUBST(DISABLE_FISHBMC)
 AC_SUBST(DISABLE_PROJECTM)
-AC_SUBST(USE_SKIN_TOUCHED)
-AC_SUBST(USE_EXTERNAL_FFMPEG)
+AC_SUBST(FFMPEG_LIBDIR)
 AC_SUBST(USE_STATIC_FFMPEG)
+AC_SUBST(GNUTLS_ALL_LIBS)
+AC_SUBST(VORBISENC_ALL_LIBS)
+AC_SUBST(USE_SKIN_TOUCHED)
 AC_SUBST(USE_LIBAV_HACKS)
 AC_SUBST(PYTHON_VERSION)
 AC_SUBST(OUTPUT_FILES)
@@ -2681,6 +2707,7 @@
 AC_SUBST(GNUTLS_ALL_LIBS)
 AC_SUBST(HOGWEED_ALL_LIBS)
 AC_SUBST(VORBISENC_ALL_LIBS)
+AC_SUBST(USE_SSE4)
 
 # pushd and popd are not available in other shells besides bash, so implement
 # our own pushd/popd functions
@@ -2732,132 +2759,6 @@
 ])
 ])
 
-XB_CONFIG_MODULE([lib/ffmpeg], [
-  if test "$host_vendor" = "apple" ; then
-    ffmpg_config="--target-os=$ffmpeg_target_os"
-    # handle disables first, we do individual enables later
-    ffmpg_config="$ffmpg_config --disable-muxers   --disable-encoders"
-    ffmpg_config="$ffmpg_config --disable-devices  --disable-doc"
-    ffmpg_config="$ffmpg_config --disable-ffplay   --disable-ffmpeg"
-    ffmpg_config="$ffmpg_config --disable-ffprobe  --disable-ffserver"
-    ffmpg_config="$ffmpg_config --enable-vda       --disable-crystalhd"
-    ffmpg_config="$ffmpg_config --disable-decoder=mpeg_xvmc"
-
-    # handle conditional enables/disables
-    if test "$use_debug" = "no"; then
-      ffmpg_config="$ffmpg_config --disable-debug"
-    fi
-    if test "$use_cpu"  != "no";  then
-      ffmpg_config="$ffmpg_config --cpu=$use_cpu"
-    fi
-    if test "$use_arch" != "no"; then
-      ffmpg_config="$ffmpg_config --arch=$use_arch --enable-cross-compile"
-    fi
-    if test "$use_arch"  = "arm"; then
-      ffmpg_config="$ffmpg_config --enable-pic"
-      ffmpg_config="$ffmpg_config --disable-armv5te --disable-armv6t2"
-      if test "$use_neon"  = "yes"; then
-        ffmpg_config="$ffmpg_config --enable-neon"
-      else
-        ffmpg_config="$ffmpg_config --disable-neon"
-      fi
-    else
-      ffmpg_config="$ffmpg_config --disable-amd3dnow"
-    fi
-    if test "$use_ffmpeg_libvorbis" = "yes"; then
-      ffmpg_config="$ffmpg_config --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis"
-    else
-      ffmpg_config="$ffmpg_config --disable-libvorbis"
-    fi
-    if test "$have_gnutls" = "yes"; then
-      ffmpg_config="$ffmpg_config --enable-gnutls"
-    fi
-
-    # handle individual enables
-    ffmpg_config="$ffmpg_config --enable-gpl"
-    ffmpg_config="$ffmpg_config --enable-postproc"
-    ffmpg_config="$ffmpg_config --enable-static      --enable-pthreads"
-    ffmpg_config="$ffmpg_config --enable-muxer=spdif --enable-muxer=adts --enable-muxer=asf --enable-muxer=ipod"
-    ffmpg_config="$ffmpg_config --enable-encoder=ac3 --enable-encoder=aac --enable-encoder=wmav2"
-    ffmpg_config="$ffmpg_config --enable-protocol=http"
-    ffmpg_config="$ffmpg_config --enable-runtime-cpudetect"
-
-    # ffmpeg will not compile with llvm-gcc-4.2, use clang instead
-    case $CC in
-      *llvm-gcc-4.2*)
-        ffmpg_config="$ffmpg_config --cc=clang" ;;
-      *)
-        ffmpg_config="$ffmpg_config --cc=$CC" ;;
-    esac
-    
-    # extra-cflags must be passed alone or it gets expanded wrong by the ffmpeg configure
-    FFMPEG_EXTRACFLAGS="$CFLAGS $FFMPEG_EXTRACFLAGS -w -D_DARWIN_C_SOURCE -Dattribute_deprecated="
-
-    LDFLAGS="$LDFLAGS" ./configure --extra-cflags="$FFMPEG_EXTRACFLAGS" $ffmpg_config --as="$AS"
-
-    # if using llvm-gcc-4.2 as assembler, -MMD is not enough to generate
-    # dependency files in the right place, replace it with something that works
-    case $AS in
-      *llvm-gcc-4.2*)
-        sed -ie "s#AS_DEPFLAGS=-MMD#AS_DEPFLAGS=-MMD -MF \$(\@:.o=.d) -MT \$\@#" config.mak ;;
-    esac
-
-    # ffmpeg will use yasm found at ${prefix}/bin during configure
-    # but then hardcodes 'yasm' in config.mak, fix it.
-    sed -ie "s#YASM=yasm#YASM=${YASM}#" config.mak
-    sed -ie "s#YASMDEP=yasm#YASMDEP=${YASM}#" config.mak
-    sed -ie "s# -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112 # #" config.mak
-  else
-    CFLAGS="" \
-    CPPFLAGS="" \
-    CXXFLAGS="" \
-    LDFLAGS="$(echo "$LDFLAGS" | sed "s/-Wl,-Bsymbolic-functions//g")" \
-    ./configure \
-      --extra-cflags="$PASSED_CFLAGS $FFMPEG_EXTRACFLAGS" \
-      `if test "$use_debug" = "no"; then echo --disable-debug; fi` \
-      `if test "$cross_compiling" = "yes"; then echo --enable-cross-compile; fi` \
-      `if test "$use_arch" != "no"; then echo --arch=$use_arch; fi`\
-      `if test "$use_cpu" != "no"; then echo --cpu=$use_cpu; fi`\
-      `if test "$use_neon" = "yes"; then echo --enable-neon; else echo --disable-neon; fi`\
-      --target-os=$ffmpeg_target_os \
-      --disable-muxers \
-      --enable-muxer=spdif \
-      --enable-muxer=adts \
-      --enable-muxer=asf \
-      --enable-muxer=ipod \
-      --disable-encoders \
-      --enable-encoder=ac3 \
-      --enable-encoder=aac \
-      --enable-encoder=wmav2 \
-      `if test "$use_ffmpeg_libvorbis" = "yes"; then echo --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis; else echo --disable-libvorbis; fi` \
-      --disable-decoder=mpeg_xvmc \
-      --disable-devices \
-      --disable-ffprobe \
-      --disable-ffplay \
-      --disable-ffserver \
-      --disable-ffmpeg \
-      --disable-crystalhd \
-      `if test "$use_static_ffmpeg" = "yes"; then echo --enable-static --disable-shared; else echo --disable-static --enable-shared; fi` \
-      --disable-doc \
-      --enable-postproc \
-      --enable-gpl \
-      `if test "x$use_vdpau" != "xno"; then echo --enable-vdpau; else echo --disable-vdpau; fi` \
-      `if test "x$use_vaapi" != "xno"; then echo --enable-vaapi; else echo --disable-vaapi; fi` \
-      `if test "$use_optimizations" != "no"; then echo --enable-optimizations; else echo --disable-optimizations; fi` \
-      --enable-protocol=http \
-      `if test "$have_gnutls" = "yes"; then echo --enable-gnutls; fi` \
-      --enable-pthreads \
-      --enable-runtime-cpudetect \
-      `if test "$use_hardcoded_tables" = "yes"; then echo --enable-hardcoded-tables; else echo --disable-hardcoded-tables; fi`\
-      `if test "$target_platform" = "target_android"; then echo "--custom-libname-with-major=\\$(SLIBPREF)\\$(FULLNAME)-\\$(LIBMAJOR)-${ARCH}\\$(SLIBSUF)"; \
-       else echo "--custom-libname-with-major=\\$(FULLNAME)-\\$(LIBMAJOR)-${ARCH}\\$(SLIBSUF)"; fi` \
-      `case $host_cpu in i?86*) echo --disable-pic ;; *) echo --enable-pic ;; esac` \
-      --cc="$CC" &&
-      sed -i -e "s#define HAVE_SYMVER 1#define HAVE_SYMVER 0#" config.h &&
-      sed -i -e "s#define HAVE_SYMVER_GNU_ASM 1#define HAVE_SYMVER_GNU_ASM 0#" config.h
-  fi
-], [$USE_EXTERNAL_FFMPEG])
-
 XB_CONFIG_MODULE([lib/libdvd/libdvdcss], [
   ./configure \
     CC="$CC" \
diff -uNr xbmc-13.2rc1-Gotham.orig/language/English/strings.po xbmc-13.2rc1-Gotham/language/English/strings.po
--- xbmc-13.2rc1-Gotham.orig/language/English/strings.po	2014-08-13 18:26:53.112737132 +0800
+++ xbmc-13.2rc1-Gotham/language/English/strings.po	2014-08-13 18:27:01.704779734 +0800
@@ -1021,7 +1021,9 @@
 msgid "Sizing: (%i,%i)->(%i,%i) (Zoom x%2.2f) AR:%2.2f:1 (Pixels: %2.2f:1) (VShift: %2.2f)"
 msgstr ""
 
-#empty string with id 246
+msgctxt "#246"
+msgid "Monitor"
+msgstr ""
 
 msgctxt "#247"
 msgid "Scripts"
@@ -6090,7 +6092,13 @@
 msgid "Hardware accelerated"
 msgstr ""
 
-#empty strings from id 13457 to 13499
+#. Option for video related setting #13454: sw filter
+#: system/settings/settings.xml
+msgctxt "#13457"
+msgid "Use SW Filter for VAAPI"
+msgstr ""
+
+#empty strings from id 13458 to 13499
 
 #: system/settings/settings.xml
 msgctxt "#13500"
@@ -6556,7 +6564,7 @@
 msgid "Allow file renaming and deletion"
 msgstr ""
 
-#empty strings from id 14072 to 14073
+#empty strings from id 14073 to 14073
 
 msgctxt "#14074"
 msgid "Set timezone"
@@ -6694,7 +6702,12 @@
 msgid "Acceleration"
 msgstr ""
 
-#empty strings from id 14102 to 15011
+#: xbmc/settings/settings.xml
+msgctxt "#14102"
+msgid "Switch off other Monitor"
+msgstr ""
+
+#empty strings from id 14103 to 15011
 
 #: xbmc/video/VideoDatabase.cpp
 msgctxt "#15012"
@@ -15170,7 +15183,14 @@
 msgid "Defines whether video decoding should be performed in software (requires more CPU) or with hardware acceleration where possible."
 msgstr ""
 
-#empty strings from id 36432 to 36499
+#. Description for video related setting #13457: vaapi sw filter 
+#: system/settings/settings.xml
+msgctxt "#36432"
+msgid "This option enables the deinterlacing methods available for software decoding. It gives the possiblity to use high quality deinterlacers in combination with VAAPI."
+msgstr ""
+
+#empty strings from id 36433 to 36499
+
 #end reservation
 
 #: system/settings/settings.xml
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllAvCodec.h xbmc-13.2rc1-Gotham/lib/DllAvCodec.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllAvCodec.h	2014-08-13 18:26:42.512684569 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllAvCodec.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,281 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "DllAvUtil.h"
-#include "utils/log.h"
-
-extern "C" {
-#ifndef HAVE_MMX
-#define HAVE_MMX
-#endif
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif
-
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libavcodec/avcodec.h>
-#else
-  #include "libavcodec/avcodec.h"
-#endif
-}
-
-#include "threads/SingleLock.h"
-
-class DllAvCodecInterface
-{
-public:
-  virtual ~DllAvCodecInterface() {}
-  virtual void avcodec_register_all(void)=0;
-  virtual void avcodec_flush_buffers(AVCodecContext *avctx)=0;
-  virtual int avcodec_open2_dont_call(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)=0;
-  virtual AVCodec *avcodec_find_decoder(enum AVCodecID id)=0;
-  virtual AVCodec *avcodec_find_encoder(enum AVCodecID id)=0;
-  virtual int avcodec_close_dont_call(AVCodecContext *avctx)=0;
-  virtual AVFrame *avcodec_alloc_frame(void)=0;
-  virtual int avpicture_fill(AVPicture *picture, uint8_t *ptr, PixelFormat pix_fmt, int width, int height)=0;
-  virtual int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt)=0;
-  virtual int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, AVPacket *avpkt)=0;
-  virtual int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)=0;
-  virtual int avcodec_encode_audio2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr)=0;
-  virtual int avpicture_get_size(PixelFormat pix_fmt, int width, int height)=0;
-  virtual AVCodecContext *avcodec_alloc_context3(AVCodec *codec)=0;
-  virtual void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)=0;
-  virtual void avcodec_get_context_defaults3(AVCodecContext *s, AVCodec *codec)=0;
-  virtual AVCodecParserContext *av_parser_init(int codec_id)=0;
-  virtual int av_parser_parse2(AVCodecParserContext *s,AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size,
-                    const uint8_t *buf, int buf_size,
-                    int64_t pts, int64_t dts, int64_t pos)=0;
-  virtual void av_parser_close(AVCodecParserContext *s)=0;
-  virtual AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)=0;
-  virtual int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
-    AVCodecContext *avctx, const char *args,
-    uint8_t **poutbuf, int *poutbuf_size,
-    const uint8_t *buf, int buf_size, int keyframe) =0;
-  virtual void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc) =0;
-  virtual void avpicture_free(AVPicture *picture)=0;
-  virtual void av_free_packet(AVPacket *pkt)=0;
-  virtual int avpicture_alloc(AVPicture *picture, PixelFormat pix_fmt, int width, int height)=0;
-  virtual enum PixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum PixelFormat *fmt)=0;
-  virtual AVCodec *av_codec_next(AVCodec *c)=0;
-  virtual int av_dup_packet(AVPacket *pkt)=0;
-  virtual void av_init_packet(AVPacket *pkt)=0;
-  virtual int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align) = 0;
-  virtual void avcodec_free_frame(AVFrame **frame)=0;
-  virtual int av_codec_is_decoder(const AVCodec *codec)=0;
-  virtual AVDictionary* av_frame_get_metadata(const AVFrame* frame)=0;
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-
-// Use direct layer
-class DllAvCodec : public DllDynamic, DllAvCodecInterface
-{
-public:
-  static CCriticalSection m_critSection;
-
-  virtual ~DllAvCodec() {}
-  virtual void avcodec_register_all()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    ::avcodec_register_all();
-  }
-  virtual void avcodec_flush_buffers(AVCodecContext *avctx) { ::avcodec_flush_buffers(avctx); }
-  virtual int avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avcodec_open2(avctx, codec, options);
-  }
-  virtual int avcodec_open2_dont_call(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options) { *(volatile int *)0x0 = 0; return 0; }
-  virtual int avcodec_close_dont_call(AVCodecContext *avctx) { *(volatile int *)0x0 = 0; return 0; }
-  virtual AVCodec *avcodec_find_decoder(enum AVCodecID id) { return ::avcodec_find_decoder(id); }
-  virtual AVCodec *avcodec_find_encoder(enum AVCodecID id) { return ::avcodec_find_encoder(id); }
-  virtual int avcodec_close(AVCodecContext *avctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avcodec_close(avctx);
-  }
-  virtual AVFrame *avcodec_alloc_frame() { return ::avcodec_alloc_frame(); }
-  virtual int avpicture_fill(AVPicture *picture, uint8_t *ptr, PixelFormat pix_fmt, int width, int height) { return ::avpicture_fill(picture, ptr, pix_fmt, width, height); }
-  virtual int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { return ::avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt); }
-  virtual int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, AVPacket *avpkt) { return ::avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt); }
-  virtual int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt) { return ::avcodec_decode_subtitle2(avctx, sub, got_sub_ptr, avpkt); }
-  virtual int avcodec_encode_audio2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet_ptr) { return ::avcodec_encode_audio2(avctx, avpkt, frame, got_packet_ptr); }
-  virtual int avpicture_get_size(PixelFormat pix_fmt, int width, int height) { return ::avpicture_get_size(pix_fmt, width, height); }
-  virtual AVCodecContext *avcodec_alloc_context3(AVCodec *codec) { return ::avcodec_alloc_context3(codec); }
-  virtual void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode) { ::avcodec_string(buf, buf_size, enc, encode); }
-  virtual void avcodec_get_context_defaults3(AVCodecContext *s, AVCodec *codec) { ::avcodec_get_context_defaults3(s, codec); }
-
-  virtual AVCodecParserContext *av_parser_init(int codec_id) { return ::av_parser_init(codec_id); }
-  virtual int av_parser_parse2(AVCodecParserContext *s,AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size,
-                    const uint8_t *buf, int buf_size,
-                    int64_t pts, int64_t dts, int64_t pos)
-  {
-    return ::av_parser_parse2(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
-  }
-  virtual void av_parser_close(AVCodecParserContext *s) { ::av_parser_close(s); }
-
-  virtual AVBitStreamFilterContext *av_bitstream_filter_init(const char *name) { return ::av_bitstream_filter_init(name); }
-  virtual int av_bitstream_filter_filter(AVBitStreamFilterContext *bsfc,
-    AVCodecContext *avctx, const char *args,
-    uint8_t **poutbuf, int *poutbuf_size,
-    const uint8_t *buf, int buf_size, int keyframe) { return ::av_bitstream_filter_filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size, keyframe); }
-  virtual void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc) { ::av_bitstream_filter_close(bsfc); }
-
-  virtual void avpicture_free(AVPicture *picture) { ::avpicture_free(picture); }
-  virtual void av_free_packet(AVPacket *pkt) { ::av_free_packet(pkt); }
-  virtual int avpicture_alloc(AVPicture *picture, PixelFormat pix_fmt, int width, int height) { return ::avpicture_alloc(picture, pix_fmt, width, height); }
-  virtual enum PixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum PixelFormat *fmt) { return ::avcodec_default_get_format(s, fmt); }
-  virtual AVCodec *av_codec_next(AVCodec *c) { return ::av_codec_next(c); }
-
-  virtual int av_dup_packet(AVPacket *pkt) { return ::av_dup_packet(pkt); }
-  virtual void av_init_packet(AVPacket *pkt) { return ::av_init_packet(pkt); }
-  virtual int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align) { return ::avcodec_fill_audio_frame(frame, nb_channels, sample_fmt, buf, buf_size, align); }
-  virtual void avcodec_free_frame(AVFrame **frame) { return ::avcodec_free_frame(frame); };
-  virtual int av_codec_is_decoder(const AVCodec *codec) { return ::av_codec_is_decoder(codec); }
-  virtual AVDictionary* av_frame_get_metadata(const AVFrame* frame) { return ::av_frame_get_metadata(frame); }
-
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllAvCodec: Using libavcodec system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-};
-#else
-class DllAvCodec : public DllDynamic, DllAvCodecInterface
-{
-  DECLARE_DLL_WRAPPER(DllAvCodec, DLL_PATH_LIBAVCODEC)
-  DEFINE_FUNC_ALIGNED1(void, __cdecl, avcodec_flush_buffers, AVCodecContext*)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, avcodec_open2_dont_call, AVCodecContext*, AVCodec *, AVDictionary **)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_video2, AVCodecContext*, AVFrame*, int*, AVPacket*)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_audio4, AVCodecContext*, AVFrame*, int*, AVPacket*)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_subtitle2, AVCodecContext*, AVSubtitle*, int*, AVPacket*)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_encode_audio2, AVCodecContext*, AVPacket*, const AVFrame*, int*)
-  DEFINE_FUNC_ALIGNED1(AVCodecContext*, __cdecl, avcodec_alloc_context3, AVCodec *)
-  DEFINE_FUNC_ALIGNED1(AVCodecParserContext*, __cdecl, av_parser_init, int)
-  DEFINE_FUNC_ALIGNED9(int, __cdecl, av_parser_parse2, AVCodecParserContext*,AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)
-  DEFINE_METHOD1(int, av_dup_packet, (AVPacket *p1))
-  DEFINE_METHOD1(void, av_init_packet, (AVPacket *p1))
-
-  LOAD_SYMBOLS();
-
-  DEFINE_METHOD0(void, avcodec_register_all_dont_call)
-  DEFINE_METHOD1(AVCodec*, avcodec_find_decoder, (enum AVCodecID p1))
-  DEFINE_METHOD1(AVCodec*, avcodec_find_encoder, (enum AVCodecID p1))
-  DEFINE_METHOD1(int, avcodec_close_dont_call, (AVCodecContext *p1))
-  DEFINE_METHOD0(AVFrame*, avcodec_alloc_frame)
-  DEFINE_METHOD5(int, avpicture_fill, (AVPicture *p1, uint8_t *p2, PixelFormat p3, int p4, int p5))
-  DEFINE_METHOD3(int, avpicture_get_size, (PixelFormat p1, int p2, int p3))
-  DEFINE_METHOD4(void, avcodec_string, (char *p1, int p2, AVCodecContext *p3, int p4))
-  DEFINE_METHOD2(void, avcodec_get_context_defaults3, (AVCodecContext *p1, AVCodec *p2))
-  DEFINE_METHOD1(void, av_parser_close, (AVCodecParserContext *p1))
-  DEFINE_METHOD1(void, avpicture_free, (AVPicture *p1))
-  DEFINE_METHOD1(AVBitStreamFilterContext*, av_bitstream_filter_init, (const char *p1))
-  DEFINE_METHOD8(int, av_bitstream_filter_filter, (AVBitStreamFilterContext* p1, AVCodecContext* p2, const char* p3, uint8_t** p4, int* p5, const uint8_t* p6, int p7, int p8))
-  DEFINE_METHOD1(void, av_bitstream_filter_close, (AVBitStreamFilterContext *p1))
-  DEFINE_METHOD1(void, av_free_packet, (AVPacket *p1))
-  DEFINE_METHOD4(int, avpicture_alloc, (AVPicture *p1, PixelFormat p2, int p3, int p4))
-  DEFINE_METHOD2(enum PixelFormat, avcodec_default_get_format, (struct AVCodecContext *p1, const enum PixelFormat *p2))
-  DEFINE_METHOD6(int, avcodec_fill_audio_frame, (AVFrame* p1, int p2, enum AVSampleFormat p3, const uint8_t* p4, int p5, int p6))
-  DEFINE_METHOD1(void, avcodec_free_frame, (AVFrame **p1))
-  DEFINE_METHOD1(AVCodec*, av_codec_next, (AVCodec *p1))
-  DEFINE_METHOD1(int, av_codec_is_decoder, (const AVCodec *p1))
-  DEFINE_METHOD1(AVDictionary*, av_frame_get_metadata, (const AVFrame* p1))
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(avcodec_flush_buffers)
-    RESOLVE_METHOD_RENAME(avcodec_open2,avcodec_open2_dont_call)
-    RESOLVE_METHOD_RENAME(avcodec_close,avcodec_close_dont_call)
-    RESOLVE_METHOD(avcodec_find_decoder)
-    RESOLVE_METHOD(avcodec_find_encoder)
-    RESOLVE_METHOD(avcodec_alloc_frame)
-    RESOLVE_METHOD_RENAME(avcodec_register_all, avcodec_register_all_dont_call)
-    RESOLVE_METHOD(avpicture_fill)
-    RESOLVE_METHOD(avcodec_decode_video2)
-    RESOLVE_METHOD(avcodec_decode_audio4)
-    RESOLVE_METHOD(avcodec_decode_subtitle2)
-    RESOLVE_METHOD(avcodec_encode_audio2)
-    RESOLVE_METHOD(avpicture_get_size)
-    RESOLVE_METHOD(avcodec_alloc_context3)
-    RESOLVE_METHOD(avcodec_string)
-    RESOLVE_METHOD(avcodec_get_context_defaults3)
-    RESOLVE_METHOD(av_parser_init)
-    RESOLVE_METHOD(av_parser_parse2)
-    RESOLVE_METHOD(av_parser_close)
-    RESOLVE_METHOD(av_bitstream_filter_init)
-    RESOLVE_METHOD(av_bitstream_filter_filter)
-    RESOLVE_METHOD(av_bitstream_filter_close)
-    RESOLVE_METHOD(avpicture_free)
-    RESOLVE_METHOD(avpicture_alloc)
-    RESOLVE_METHOD(av_free_packet)
-    RESOLVE_METHOD(avcodec_default_get_format)
-    RESOLVE_METHOD(av_codec_next)
-    RESOLVE_METHOD(av_dup_packet)
-    RESOLVE_METHOD(av_init_packet)
-    RESOLVE_METHOD(avcodec_fill_audio_frame)
-    RESOLVE_METHOD(avcodec_free_frame)
-    RESOLVE_METHOD(av_codec_is_decoder)
-    RESOLVE_METHOD(av_frame_get_metadata)
-  END_METHOD_RESOLVE()
-
-  /* dependencies of libavcodec */
-  DllAvUtil m_dllAvUtil;
-
-public:
-    static CCriticalSection m_critSection;
-    int avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)
-    {
-      CSingleLock lock(DllAvCodec::m_critSection);
-      return avcodec_open2_dont_call(avctx,codec, options);
-    }
-    int avcodec_close(AVCodecContext *avctx)
-    {
-      CSingleLock lock(DllAvCodec::m_critSection);
-      return avcodec_close_dont_call(avctx);
-    }
-    void avcodec_register_all()
-    {
-      CSingleLock lock(DllAvCodec::m_critSection);
-      avcodec_register_all_dont_call();
-    }
-    virtual bool Load()
-    {
-      if (!m_dllAvUtil.Load())
-	return false;
-      return DllDynamic::Load();
-    }
-};
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllAvFilter.h xbmc-13.2rc1-Gotham/lib/DllAvFilter.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllAvFilter.h	2014-08-13 18:26:39.548669866 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllAvFilter.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,313 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-#include "DllSwResample.h"
-#include "utils/log.h"
-
-extern "C" {
-#ifndef HAVE_MMX
-#define HAVE_MMX
-#endif
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libavfilter/avfilter.h>
-  #include <libavfilter/avfiltergraph.h>
-  #include <libavfilter/buffersink.h>
-#if LIBAVFILTER_VERSION_MICRO >= 100 && LIBAVFILTER_VERSION_INT < AV_VERSION_INT(3,43,100)
-  #include <libavfilter/avcodec.h>
-#endif
-  #include <libavfilter/buffersrc.h>
-#else
-  #include "libavfilter/avfilter.h"
-  #include "libavfilter/avfiltergraph.h"
-  #include "libavfilter/buffersink.h"
-#if LIBAVFILTER_VERSION_MICRO >= 100 && LIBAVFILTER_VERSION_INT < AV_VERSION_INT(3,43,100)
-  #include "libavfilter/avcodec.h"
-#endif
-  #include "libavfilter/buffersrc.h"
-#endif
-}
-
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(3,43,100)
-#define LIBAVFILTER_AVFRAME_BASED
-#endif
-
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(3,78,100)
-  #define HAVE_AVFILTER_GRAPH_PARSE_PTR
-#endif
-
-#include "threads/SingleLock.h"
-
-class DllAvFilterInterface
-{
-public:
-  virtual ~DllAvFilterInterface() {}
-  virtual void avfilter_free(AVFilterContext *filter)=0;
-  virtual void avfilter_graph_free(AVFilterGraph **graph)=0;
-  virtual int avfilter_graph_create_filter(AVFilterContext **filt_ctx, AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)=0;
-  virtual AVFilter *avfilter_get_by_name(const char *name)=0;
-  virtual AVFilterGraph *avfilter_graph_alloc(void)=0;
-  virtual AVFilterInOut *avfilter_inout_alloc()=0;
-  virtual void avfilter_inout_free(AVFilterInOut **inout)=0;
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-  virtual int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)=0;
-#else
-  virtual int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)=0;
-#endif
-  virtual int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)=0;
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersrc_add_frame(AVFilterContext *buffer_filter, AVFrame *frame)=0;
-#else
-  virtual int av_buffersrc_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int flags)=0;
-  virtual void avfilter_unref_buffer(AVFilterBufferRef *ref)=0;
-#endif
-  virtual int avfilter_link(AVFilterContext *src, unsigned srcpad, AVFilterContext *dst, unsigned dstpad)=0;
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame) = 0;
-#else
-  virtual int av_buffersink_get_buffer_ref(AVFilterContext *buffer_sink, AVFilterBufferRef **bufref, int flags)=0;
-#endif
-  virtual AVBufferSinkParams *av_buffersink_params_alloc()=0;
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersink_poll_frame(AVFilterContext *ctx)=0;
-#endif
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-// Use direct mapping
-class DllAvFilter : public DllDynamic, DllAvFilterInterface
-{
-public:
-  virtual ~DllAvFilter() {}
-  virtual void avfilter_free(AVFilterContext *filter)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    ::avfilter_free(filter);
-  }
-  virtual void avfilter_graph_free(AVFilterGraph **graph)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    ::avfilter_graph_free(graph);
-  }
-  void avfilter_register_all()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    ::avfilter_register_all();
-  }
-  virtual int avfilter_graph_create_filter(AVFilterContext **filt_ctx, AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx) { return ::avfilter_graph_create_filter(filt_ctx, filt, name, args, opaque, graph_ctx); }
-  virtual AVFilter *avfilter_get_by_name(const char *name) { return ::avfilter_get_by_name(name); }
-  virtual AVFilterGraph *avfilter_graph_alloc() { return ::avfilter_graph_alloc(); }
-  virtual AVFilterInOut *avfilter_inout_alloc()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avfilter_inout_alloc();
-  }
-  virtual void avfilter_inout_free(AVFilterInOut **inout)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    ::avfilter_inout_free(inout);
-  }
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-  virtual int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx);
-  }
-#else
-  virtual int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx);
-  }
-#endif
-  virtual int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
-  {
-    return ::avfilter_graph_config(graphctx, log_ctx);
-  }
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersrc_add_frame(AVFilterContext *buffer_filter, AVFrame* frame) { return ::av_buffersrc_add_frame(buffer_filter, frame); }
-#else
-  virtual int av_buffersrc_add_frame(AVFilterContext *buffer_filter, AVFrame* frame, int flags) { return ::av_buffersrc_add_frame(buffer_filter, frame, flags); }
-  virtual void avfilter_unref_buffer(AVFilterBufferRef *ref) { ::avfilter_unref_buffer(ref); }
-#endif
-  virtual int avfilter_link(AVFilterContext *src, unsigned srcpad, AVFilterContext *dst, unsigned dstpad) { return ::avfilter_link(src, srcpad, dst, dstpad); }
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame) { return ::av_buffersink_get_frame(ctx, frame); }
-#else
-  virtual int av_buffersink_get_buffer_ref(AVFilterContext *buffer_sink, AVFilterBufferRef **bufref, int flags) { return ::av_buffersink_get_buffer_ref(buffer_sink, bufref, flags); }
-#endif
-  virtual AVBufferSinkParams *av_buffersink_params_alloc() { return ::av_buffersink_params_alloc(); }
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  virtual int av_buffersink_poll_frame(AVFilterContext *ctx) { return ::av_buffersink_poll_frame(ctx); }
-#endif
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllAvFilter: Using libavfilter system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-};
-#else
-class DllAvFilter : public DllDynamic, DllAvFilterInterface
-{
-  DECLARE_DLL_WRAPPER(DllAvFilter, DLL_PATH_LIBAVFILTER)
-
-  LOAD_SYMBOLS()
-
-  DEFINE_METHOD1(void, avfilter_free_dont_call, (AVFilterContext *p1))
-  DEFINE_METHOD1(void, avfilter_graph_free_dont_call, (AVFilterGraph **p1))
-  DEFINE_METHOD0(void, avfilter_register_all_dont_call)
-  DEFINE_METHOD6(int, avfilter_graph_create_filter, (AVFilterContext **p1, AVFilter *p2, const char *p3, const char *p4, void *p5, AVFilterGraph *p6))
-  DEFINE_METHOD1(AVFilter*, avfilter_get_by_name, (const char *p1))
-  DEFINE_METHOD0(AVFilterGraph*, avfilter_graph_alloc)
-  DEFINE_METHOD0(AVFilterInOut*, avfilter_inout_alloc_dont_call)
-  DEFINE_METHOD1(void, avfilter_inout_free_dont_call, (AVFilterInOut **p1))
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-  DEFINE_FUNC_ALIGNED5(int, __cdecl, avfilter_graph_parse_ptr_dont_call, AVFilterGraph *, const char *, AVFilterInOut **, AVFilterInOut **, void *)
-#else
-  DEFINE_FUNC_ALIGNED5(int, __cdecl, avfilter_graph_parse_dont_call, AVFilterGraph *, const char *, AVFilterInOut **, AVFilterInOut **, void *)
-#endif
-  DEFINE_FUNC_ALIGNED2(int, __cdecl, avfilter_graph_config_dont_call, AVFilterGraph *, void *)
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  DEFINE_METHOD2(int, av_buffersrc_add_frame, (AVFilterContext *p1, AVFrame *p2))
-#else
-  DEFINE_METHOD3(int, av_buffersrc_add_frame, (AVFilterContext *p1, AVFrame *p2, int p3))
-  DEFINE_METHOD1(void, avfilter_unref_buffer, (AVFilterBufferRef *p1))
-#endif
-  DEFINE_METHOD4(int, avfilter_link, (AVFilterContext *p1, unsigned p2, AVFilterContext *p3, unsigned p4))
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  DEFINE_FUNC_ALIGNED2(int                , __cdecl, av_buffersink_get_frame, AVFilterContext *, AVFrame *);
-#else
-  DEFINE_FUNC_ALIGNED3(int                , __cdecl, av_buffersink_get_buffer_ref, AVFilterContext *, AVFilterBufferRef **, int);
-#endif
-  DEFINE_FUNC_ALIGNED0(AVBufferSinkParams*, __cdecl, av_buffersink_params_alloc);
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  DEFINE_FUNC_ALIGNED1(int                , __cdecl, av_buffersink_poll_frame, AVFilterContext *);
-#endif
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD_RENAME(avfilter_free, avfilter_free_dont_call)
-    RESOLVE_METHOD_RENAME(avfilter_graph_free, avfilter_graph_free_dont_call)
-    RESOLVE_METHOD_RENAME(avfilter_register_all, avfilter_register_all_dont_call)
-    RESOLVE_METHOD(avfilter_graph_create_filter)
-    RESOLVE_METHOD(avfilter_get_by_name)
-    RESOLVE_METHOD(avfilter_graph_alloc)
-    RESOLVE_METHOD_RENAME(avfilter_inout_alloc, avfilter_inout_alloc_dont_call)
-    RESOLVE_METHOD_RENAME(avfilter_inout_free, avfilter_inout_free_dont_call)
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-    RESOLVE_METHOD_RENAME(avfilter_graph_parse_ptr, avfilter_graph_parse_ptr_dont_call)
-#else
-    RESOLVE_METHOD_RENAME(avfilter_graph_parse, avfilter_graph_parse_dont_call)
-#endif
-    RESOLVE_METHOD_RENAME(avfilter_graph_config, avfilter_graph_config_dont_call)
-    RESOLVE_METHOD(av_buffersrc_add_frame)
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-    RESOLVE_METHOD(avfilter_unref_buffer)
-#endif
-    RESOLVE_METHOD(avfilter_link)
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-    RESOLVE_METHOD(av_buffersink_get_frame)
-#else
-    RESOLVE_METHOD(av_buffersink_get_buffer_ref)
-#endif
-    RESOLVE_METHOD(av_buffersink_params_alloc)
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-    RESOLVE_METHOD(av_buffersink_poll_frame)
-#endif
-  END_METHOD_RESOLVE()
-
-  /* dependencies of libavfilter */
-  DllAvUtil m_dllAvUtil;
-  DllSwResample m_dllSwResample;
-  DllAvFormat m_dllAvFormat;
-
-public:
-  void avfilter_free(AVFilterContext *filter)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    avfilter_free_dont_call(filter);
-  }
-  void avfilter_graph_free(AVFilterGraph **graph)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    avfilter_graph_free_dont_call(graph);
-  }
-  void avfilter_register_all()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    avfilter_register_all_dont_call();
-  }
-  AVFilterInOut* avfilter_inout_alloc()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return avfilter_inout_alloc_dont_call();
-  }
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-  int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return avfilter_graph_parse_ptr_dont_call(graph, filters, inputs, outputs, log_ctx);
-  }
-#else
-  int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return avfilter_graph_parse_dont_call(graph, filters, inputs, outputs, log_ctx);
-  }
-#endif
-  void avfilter_inout_free(AVFilterInOut **inout)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    avfilter_inout_free_dont_call(inout);
-  }
-  int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return avfilter_graph_config_dont_call(graphctx, log_ctx);
-  }
-  virtual bool Load()
-  {
-    if (!m_dllAvUtil.Load())
-      return false;
-    if (!m_dllSwResample.Load())
-      return false;
-    if (!m_dllAvFormat.Load())
-      return false;
-    return DllDynamic::Load();
-  }
-};
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllAvFormat.h xbmc-13.2rc1-Gotham/lib/DllAvFormat.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllAvFormat.h	2014-08-13 18:26:30.460624807 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllAvFormat.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,322 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "DllAvCodec.h"
-
-extern "C" {
-#ifndef HAVE_MMX
-#define HAVE_MMX
-#endif
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libavformat/avformat.h>
-  /* xbmc_read_frame_flush() is defined for us in lib/xbmc-dll-symbols/DllAvFormat.c */
-  void xbmc_read_frame_flush(AVFormatContext *s);
-#else
-  #include "libavformat/avformat.h"
-  #if defined(TARGET_DARWIN) || defined(USE_STATIC_FFMPEG)
-    void ff_read_frame_flush(AVFormatContext *s);    // internal replacement 
-    #define xbmc_read_frame_flush ff_read_frame_flush
-  #endif
-#endif
-}
-
-/* Flag introduced without a version bump */
-#ifndef AVSEEK_FORCE
-#define AVSEEK_FORCE 0x20000
-#endif
-
-#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(55,12,100)
-#define AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE
-#endif
-
-typedef int64_t offset_t;
-
-class DllAvFormatInterface
-{
-public:
-  virtual ~DllAvFormatInterface() {}
-  virtual void av_register_all_dont_call(void)=0;
-  virtual void avformat_network_init_dont_call(void)=0;
-  virtual void avformat_network_deinit_dont_call(void)=0;
-  virtual AVInputFormat *av_find_input_format(const char *short_name)=0;
-  virtual void avformat_close_input(AVFormatContext **s)=0;
-  virtual int av_read_frame(AVFormatContext *s, AVPacket *pkt)=0;
-  virtual void av_read_frame_flush(AVFormatContext *s)=0;
-  virtual int av_read_play(AVFormatContext *s)=0;
-  virtual int av_read_pause(AVFormatContext *s)=0;
-  virtual int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)=0;
-#if (!defined USE_EXTERNAL_FFMPEG) && (!defined TARGET_DARWIN) && (!defined USE_STATIC_FFMPEG)
-  virtual int avformat_find_stream_info_dont_call(AVFormatContext *ic, AVDictionary **options)=0;
-#endif
-  virtual int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)=0;
-  virtual AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
-                            int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
-                            int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
-                            offset_t (*seek)(void *opaque, offset_t offset, int whence))=0;
-  virtual AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)=0;
-  virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max)=0;
-  virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size)=0;
-  virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)=0;
-  virtual int avio_open(AVIOContext **s, const char *filename, int flags)=0;
-  virtual int avio_close(AVIOContext *s)=0;
-  virtual int avio_open_dyn_buf(AVIOContext **s)=0;
-  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)=0;
-  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence)=0;
-  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size)=0;
-  virtual void avio_w8(AVIOContext *s, int b)=0;
-  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size)=0;
-  virtual void avio_wb24(AVIOContext *s, unsigned int val)=0;
-  virtual void avio_wb32(AVIOContext *s, unsigned int val)=0;
-  virtual void avio_wb16(AVIOContext *s, unsigned int val)=0;
-  virtual AVFormatContext *avformat_alloc_context(void)=0;
-  virtual int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename) = 0;
-  virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c)=0;
-  virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)=0;
-  virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options)=0;
-  virtual int av_write_trailer(AVFormatContext *s)=0;
-  virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt)=0;
-#if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-  virtual AVRational av_stream_get_r_frame_rate(const AVStream *s)=0;
-#endif
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-
-// Use direct mapping
-class DllAvFormat : public DllDynamic, DllAvFormatInterface
-{
-public:
-  virtual ~DllAvFormat() {}
-  virtual void av_register_all() 
-  { 
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::av_register_all();
-  } 
-  virtual void av_register_all_dont_call() { *(volatile int* )0x0 = 0; } 
-  virtual void avformat_network_init_dont_call() { *(volatile int* )0x0 = 0; } 
-  virtual void avformat_network_deinit_dont_call() { *(volatile int* )0x0 = 0; } 
-  virtual AVInputFormat *av_find_input_format(const char *short_name) { return ::av_find_input_format(short_name); }
-  virtual void avformat_close_input(AVFormatContext **s) { ::avformat_close_input(s); }
-  virtual int av_read_frame(AVFormatContext *s, AVPacket *pkt) { return ::av_read_frame(s, pkt); }
-  virtual void av_read_frame_flush(AVFormatContext *s) { ::xbmc_read_frame_flush(s); }
-  virtual int av_read_play(AVFormatContext *s) { return ::av_read_play(s); }
-  virtual int av_read_pause(AVFormatContext *s) { return ::av_read_pause(s); }
-  virtual int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { return ::av_seek_frame(s, stream_index, timestamp, flags); }
-  virtual int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avformat_find_stream_info(ic, options);
-  }
-  virtual int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
-  { return ::avformat_open_input(ps, filename, fmt, options); }
-  virtual AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
-                            int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
-                            int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
-                            offset_t (*seek)(void *opaque, offset_t offset, int whence)) { return ::avio_alloc_context(buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek); }
-  virtual AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened) {return ::av_probe_input_format(pd, is_opened); }
-  virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max) {*score_max = 100; return ::av_probe_input_format(pd, is_opened); } // Use av_probe_input_format, this is not exported by ffmpeg's headers
-  virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { return ::av_probe_input_buffer(pb, fmt, filename, logctx, offset, max_probe_size); }
-  virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output) { ::av_dump_format(ic, index, url, is_output); }
-  virtual int avio_open(AVIOContext **s, const char *filename, int flags) { return ::avio_open(s, filename, flags); }
-  virtual int avio_close(AVIOContext *s) { return ::avio_close(s); }
-  virtual int avio_open_dyn_buf(AVIOContext **s) { return ::avio_open_dyn_buf(s); }
-  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) { return ::avio_close_dyn_buf(s, pbuffer); }
-  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence) { return ::avio_seek(s, offset, whence); }
-  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size) { return ::avio_read(s, buf, size); }
-  virtual void avio_w8(AVIOContext *s, int b) { ::avio_w8(s, b); }
-  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size) { ::avio_write(s, buf, size); }
-  virtual void avio_wb24(AVIOContext *s, unsigned int val) { ::avio_wb24(s, val); }
-  virtual void avio_wb32(AVIOContext *s, unsigned int val) { ::avio_wb32(s, val); }
-  virtual void avio_wb16(AVIOContext *s, unsigned int val) { ::avio_wb16(s, val); }
-  virtual AVFormatContext *avformat_alloc_context() { return ::avformat_alloc_context(); }
-  virtual int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename){ return ::avformat_alloc_output_context2(ctx,oformat,format_name,filename); }
-  virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c) { return ::avformat_new_stream(s, c); }
-  virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type) { return ::av_guess_format(short_name, filename, mime_type); }
-  virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options) { return ::avformat_write_header (s, options); }
-  virtual int av_write_trailer(AVFormatContext *s) { return ::av_write_trailer(s); }
-  virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt) { return ::av_write_frame(s, pkt); }
-#if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-  virtual AVRational av_stream_get_r_frame_rate(const AVStream *s) { return ::av_stream_get_r_frame_rate(s); }
-#endif
-
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllAvFormat: Using libavformat system library");
-#endif
-    CSingleLock lock(DllAvCodec::m_critSection);
-    if (++m_avformat_refcnt == 1)
-      ::avformat_network_init();
-    return true;
-  }
-  virtual void Unload() {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    if (--m_avformat_refcnt == 0)
-      ::avformat_network_deinit();
-  }
-
-protected:
-  static int m_avformat_refcnt;
-};
-
-#else
-
-class DllAvFormat : public DllDynamic, DllAvFormatInterface
-{
-  DECLARE_DLL_WRAPPER(DllAvFormat, DLL_PATH_LIBAVFORMAT)
-
-  LOAD_SYMBOLS()
-
-  DEFINE_METHOD0(void, av_register_all_dont_call)
-  DEFINE_METHOD0(void, avformat_network_init_dont_call)
-  DEFINE_METHOD0(void, avformat_network_deinit_dont_call)
-  DEFINE_METHOD1(AVInputFormat*, av_find_input_format, (const char *p1))
-  DEFINE_METHOD1(void, avformat_close_input, (AVFormatContext **p1))
-  DEFINE_METHOD1(int, av_read_play, (AVFormatContext *p1))
-  DEFINE_METHOD1(int, av_read_pause, (AVFormatContext *p1))
-  DEFINE_METHOD1(void, av_read_frame_flush, (AVFormatContext *p1))
-  DEFINE_FUNC_ALIGNED2(int, __cdecl, av_read_frame, AVFormatContext *, AVPacket *)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, av_seek_frame, AVFormatContext*, int, int64_t, int)
-  DEFINE_FUNC_ALIGNED2(int, __cdecl, avformat_find_stream_info_dont_call, AVFormatContext*, AVDictionary **)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avformat_open_input, AVFormatContext **, const char *, AVInputFormat *, AVDictionary **)
-  DEFINE_FUNC_ALIGNED2(AVInputFormat*, __cdecl, av_probe_input_format, AVProbeData*, int)
-  DEFINE_FUNC_ALIGNED3(AVInputFormat*, __cdecl, av_probe_input_format2, AVProbeData*, int, int*)
-  DEFINE_FUNC_ALIGNED6(int, __cdecl, av_probe_input_buffer, AVIOContext *, AVInputFormat **, const char *, void *, unsigned int, unsigned int)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, avio_read, AVIOContext*, unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_w8, AVIOContext*, int)
-  DEFINE_FUNC_ALIGNED3(void, __cdecl, avio_write, AVIOContext*, const unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb24, AVIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb32, AVIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb16, AVIOContext*, unsigned int)
-  DEFINE_METHOD7(AVIOContext *, avio_alloc_context, (unsigned char *p1, int p2, int p3, void *p4,
-                  int (*p5)(void *opaque, uint8_t *buf, int buf_size),
-                  int (*p6)(void *opaque, uint8_t *buf, int buf_size),
-                  offset_t (*p7)(void *opaque, offset_t offset, int whence)))
-  DEFINE_METHOD4(void, av_dump_format, (AVFormatContext *p1, int p2, const char *p3, int p4))
-  DEFINE_METHOD3(int, avio_open, (AVIOContext **p1, const char *p2, int p3))
-  DEFINE_METHOD1(int, avio_close, (AVIOContext *p1))
-  DEFINE_METHOD1(int, avio_open_dyn_buf, (AVIOContext **p1))
-  DEFINE_METHOD2(int, avio_close_dyn_buf, (AVIOContext *p1, uint8_t **p2))
-  DEFINE_METHOD3(offset_t, avio_seek, (AVIOContext *p1, offset_t p2, int p3))
-  DEFINE_METHOD0(AVFormatContext *, avformat_alloc_context)
-  DEFINE_METHOD4(int, avformat_alloc_output_context2, (AVFormatContext **p1, AVOutputFormat *p2, const char *p3, const char *p4))
-  DEFINE_METHOD2(AVStream *, avformat_new_stream, (AVFormatContext *p1, AVCodec *p2))
-  DEFINE_METHOD3(AVOutputFormat *, av_guess_format, (const char *p1, const char *p2, const char *p3))
-  DEFINE_METHOD2(int, avformat_write_header , (AVFormatContext *p1, AVDictionary **p2))
-  DEFINE_METHOD1(int, av_write_trailer, (AVFormatContext *p1))
-  DEFINE_METHOD2(int, av_write_frame  , (AVFormatContext *p1, AVPacket *p2))
-#if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-  DEFINE_METHOD1(AVRational, av_stream_get_r_frame_rate, (const AVStream *p1))
-#endif
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD_RENAME(av_register_all, av_register_all_dont_call)
-    RESOLVE_METHOD_RENAME(avformat_network_init,   avformat_network_init_dont_call)
-    RESOLVE_METHOD_RENAME(avformat_network_deinit, avformat_network_deinit_dont_call)
-    RESOLVE_METHOD(av_find_input_format)
-    RESOLVE_METHOD(avformat_close_input)
-    RESOLVE_METHOD(av_read_frame)
-    RESOLVE_METHOD(av_read_play)
-    RESOLVE_METHOD(av_read_pause)
-    RESOLVE_METHOD(av_read_frame_flush)
-    RESOLVE_METHOD(av_seek_frame)
-    RESOLVE_METHOD_RENAME(avformat_find_stream_info, avformat_find_stream_info_dont_call)
-    RESOLVE_METHOD(avformat_open_input)
-    RESOLVE_METHOD(avio_alloc_context)
-    RESOLVE_METHOD(av_probe_input_format)
-    RESOLVE_METHOD(av_probe_input_format2)
-    RESOLVE_METHOD(av_probe_input_buffer)
-    RESOLVE_METHOD(av_dump_format)
-    RESOLVE_METHOD(avio_open)
-    RESOLVE_METHOD(avio_close)
-    RESOLVE_METHOD(avio_open_dyn_buf)
-    RESOLVE_METHOD(avio_close_dyn_buf)
-    RESOLVE_METHOD(avio_seek)
-    RESOLVE_METHOD(avio_read)
-    RESOLVE_METHOD(avio_w8)
-    RESOLVE_METHOD(avio_write)
-    RESOLVE_METHOD(avio_wb24)
-    RESOLVE_METHOD(avio_wb32)
-    RESOLVE_METHOD(avio_wb16)
-    RESOLVE_METHOD(avformat_alloc_context)
-    RESOLVE_METHOD(avformat_alloc_output_context2)
-    RESOLVE_METHOD(avformat_new_stream)
-    RESOLVE_METHOD(av_guess_format)
-    RESOLVE_METHOD(avformat_write_header)
-    RESOLVE_METHOD(av_write_trailer)
-    RESOLVE_METHOD(av_write_frame)
-#if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-    RESOLVE_METHOD(av_stream_get_r_frame_rate)
-#endif
-  END_METHOD_RESOLVE()
-
-  /* dependencies of libavformat */
-  DllAvCodec m_dllAvCodec;
-  // DllAvUtil loaded implicitely by m_dllAvCodec
-
-public:
-  void av_register_all()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    av_register_all_dont_call();
-  }
-  int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    return avformat_find_stream_info_dont_call(ic, options);
-  }
-
-  virtual bool Load()
-  {
-    if (!m_dllAvCodec.Load())
-      return false;
-    bool loaded = DllDynamic::Load();
-
-    CSingleLock lock(DllAvCodec::m_critSection);
-    if (++m_avformat_refcnt == 1 && loaded)
-      avformat_network_init_dont_call();
-    return loaded;
-  }
-
-  virtual void Unload()
-  {
-    CSingleLock lock(DllAvCodec::m_critSection);
-    if (--m_avformat_refcnt == 0 && DllDynamic::IsLoaded())
-      avformat_network_deinit_dont_call();
-
-    DllDynamic::Unload();
-  }
-
-protected:
-  static int m_avformat_refcnt;
-};
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllAvUtil.h xbmc-13.2rc1-Gotham/lib/DllAvUtil.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllAvUtil.h	2014-08-13 18:26:30.428624644 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllAvUtil.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,291 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "utils/log.h"
-
-#ifndef __GNUC__
-#pragma warning(push)
-#pragma warning(disable:4244)
-#endif
-
-extern "C" {
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libavutil/avutil.h>
-  // for av_get_default_channel_layout
-  #include <libavutil/audioconvert.h>
-  #include <libavutil/crc.h>
-  #include <libavutil/fifo.h>
-  // for LIBAVCODEC_VERSION_INT:
-  #include <libavcodec/avcodec.h>
-  // for enum AVSampleFormat
-  #include <libavutil/samplefmt.h>
-  #include <libavutil/opt.h>
-  #include <libavutil/mem.h>
-  #include <libavutil/mathematics.h>
-  #if (defined USE_LIBAV_HACKS)
-    #include "xbmc-libav-hacks/libav_hacks.h"
-  #endif
-#else
-  #include "libavutil/avutil.h"
-  //for av_get_default_channel_layout
-  #include "libavutil/audioconvert.h"
-  #include "libavutil/crc.h"
-  #include "libavutil/opt.h"
-  #include "libavutil/mem.h"
-  #include "libavutil/fifo.h"
-  // for enum AVSampleFormat
-  #include "libavutil/samplefmt.h"
-#endif
-}
-
-#if LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(52,29,100)
-#define AVFRAME_IN_LAVU
-#endif
-
-#ifndef __GNUC__
-#pragma warning(pop)
-#endif
-
-// calback used for logging
-void ff_avutil_log(void* ptr, int level, const char* format, va_list va);
-
-class DllAvUtilInterface
-{
-public:
-  virtual ~DllAvUtilInterface() {}
-  virtual void av_log_set_callback(void (*)(void*, int, const char*, va_list))=0;
-  virtual void *av_malloc(unsigned int size)=0;
-  virtual void *av_mallocz(unsigned int size)=0;
-  virtual void *av_realloc(void *ptr, unsigned int size)=0;
-  virtual void av_free(void *ptr)=0;
-  virtual void av_freep(void *ptr)=0;
-  virtual int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding)=0;
-  virtual int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)=0;
-  virtual int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size)=0;
-  virtual const AVCRC* av_crc_get_table(AVCRCId crc_id)=0;
-  virtual uint32_t av_crc(const AVCRC *ctx, uint32_t crc, const uint8_t *buffer, size_t length)=0;
-  virtual int av_opt_set(void *obj, const char *name, const char *val, int search_flags)=0;
-  virtual int av_opt_set_double(void *obj, const char *name, double val, int search_flags)=0;
-  virtual int av_opt_set_int(void *obj, const char *name, int64_t val, int search_flags)=0;
-  virtual AVFifoBuffer *av_fifo_alloc(unsigned int size) = 0;
-  virtual void av_fifo_free(AVFifoBuffer *f) = 0;
-  virtual void av_fifo_reset(AVFifoBuffer *f) = 0;
-  virtual int av_fifo_size(AVFifoBuffer *f) = 0;
-  virtual int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int)) = 0;
-  virtual int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int)) = 0;
-  virtual char *av_strdup(const char *s)=0;
-  virtual int av_get_bytes_per_sample(enum AVSampleFormat p1) = 0;
-  virtual AVDictionaryEntry *av_dict_get(AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags) = 0;
-  virtual int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)=0;
-  virtual void av_dict_free(AVDictionary **pm) = 0;
-  virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
-  virtual int64_t av_get_default_channel_layout(int nb_channels)=0;
-  virtual int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
-  virtual int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt) = 0;
-  virtual int av_get_channel_layout_channel_index (uint64_t channel_layout, uint64_t channel) = 0;
-  virtual int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
-  virtual int av_samples_copy(uint8_t **dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt) = 0;
-  virtual uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index) = 0;
-#if defined(AVFRAME_IN_LAVU)
-  virtual void av_frame_free(AVFrame **frame)=0;
-  virtual AVFrame *av_frame_alloc(void)=0;
-  virtual void av_frame_unref(AVFrame *frame)=0;
-  virtual void av_frame_move_ref(AVFrame *dst, AVFrame *src)=0;
-#endif
-};
-
-#if defined (USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-// Use direct layer
-class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
-{
-public:
-
-  virtual ~DllAvUtilBase() {}
-   virtual void av_log_set_callback(void (*foo)(void*, int, const char*, va_list)) { ::av_log_set_callback(foo); }
-   virtual void *av_malloc(unsigned int size) { return ::av_malloc(size); }
-   virtual void *av_mallocz(unsigned int size) { return ::av_mallocz(size); }
-   virtual void *av_realloc(void *ptr, unsigned int size) { return ::av_realloc(ptr, size); }
-   virtual void av_free(void *ptr) { ::av_free(ptr); }
-   virtual void av_freep(void *ptr) { ::av_freep(ptr); }
-   virtual int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding d) { return ::av_rescale_rnd(a, b, c, d); }
-   virtual int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) { return ::av_rescale_q(a, bq, cq); }
-   virtual int av_crc_init(AVCRC *ctx, int le, int bits, uint32_t poly, int ctx_size) { return ::av_crc_init(ctx, le, bits, poly, ctx_size); }
-   virtual const AVCRC* av_crc_get_table(AVCRCId crc_id) { return ::av_crc_get_table(crc_id); }
-   virtual uint32_t av_crc(const AVCRC *ctx, uint32_t crc, const uint8_t *buffer, size_t length) { return ::av_crc(ctx, crc, buffer, length); }
-   virtual int av_opt_set(void *obj, const char *name, const char *val, int search_flags) { return ::av_opt_set(obj, name, val, search_flags); }
-   virtual int av_opt_set_double(void *obj, const char *name, double val, int search_flags) { return ::av_opt_set_double(obj, name, val, search_flags); }
-   virtual int av_opt_set_int(void *obj, const char *name, int64_t val, int search_flags) { return ::av_opt_set_int(obj, name, val, search_flags); }
-  virtual AVFifoBuffer *av_fifo_alloc(unsigned int size) {return ::av_fifo_alloc(size); }
-  virtual void av_fifo_free(AVFifoBuffer *f) { ::av_fifo_free(f); }
-  virtual void av_fifo_reset(AVFifoBuffer *f) { ::av_fifo_reset(f); }
-  virtual int av_fifo_size(AVFifoBuffer *f) { return ::av_fifo_size(f); }
-  virtual int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int))
-    { return ::av_fifo_generic_read(f, dest, buf_size, func); }
-  virtual int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int))
-    { return ::av_fifo_generic_write(f, src, size, func); }
-  virtual char *av_strdup(const char *s) { return ::av_strdup(s); }
-  virtual int av_get_bytes_per_sample(enum AVSampleFormat p1)
-    { return ::av_get_bytes_per_sample(p1); }
-  virtual AVDictionaryEntry *av_dict_get(AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags){ return ::av_dict_get(m, key, prev, flags); }
-  virtual int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags) { return ::av_dict_set(pm, key, value, flags); }
-  virtual void av_dict_free(AVDictionary **pm) { ::av_dict_free(pm); }
-  virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
-    { return ::av_samples_get_buffer_size(linesize, nb_channels, nb_samples, sample_fmt, align); }
-  virtual int64_t av_get_default_channel_layout(int nb_channels) { return ::av_get_default_channel_layout(nb_channels); }
-  virtual int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
-    { return ::av_samples_alloc(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align); }
-  virtual int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt) { return ::av_sample_fmt_is_planar(sample_fmt); }
-  virtual int av_get_channel_layout_channel_index (uint64_t channel_layout, uint64_t channel) { return ::av_get_channel_layout_channel_index(channel_layout, channel); }
-  virtual int av_samples_fill_arrays(uint8_t **audio_data, int *linesize, const uint8_t *buf, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
-    { return ::av_samples_fill_arrays(audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align); }
-  virtual int av_samples_copy(uint8_t **dst, uint8_t *const *src, int dst_offset, int src_offset, int nb_samples, int nb_channels, enum AVSampleFormat sample_fmt)
-    { return ::av_samples_copy(dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt); }
-  virtual uint64_t av_channel_layout_extract_channel(uint64_t channel_layout, int index)
-    { return ::av_channel_layout_extract_channel(channel_layout, index); }
-#if defined(AVFRAME_IN_LAVU)
-  virtual void av_frame_free(AVFrame **frame) { return ::av_frame_free(frame); }
-  virtual AVFrame *av_frame_alloc() { return ::av_frame_alloc(); }
-  virtual void av_frame_unref(AVFrame *frame) { return ::av_frame_unref(frame); }
-  virtual void av_frame_move_ref(AVFrame *dst, AVFrame *src) { return ::av_frame_move_ref(dst,src); }
-#endif
-
-   // DLL faking.
-   virtual bool ResolveExports() { return true; }
-   virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-     CLog::Log(LOGDEBUG, "DllAvUtilBase: Using libavutil system library");
-#endif
-     return true;
-   }
-   virtual void Unload() {}
-};
-
-#else
-
-class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
-{
-  DECLARE_DLL_WRAPPER(DllAvUtilBase, DLL_PATH_LIBAVUTIL)
-
-  LOAD_SYMBOLS()
-
-  DEFINE_METHOD1(void, av_log_set_callback, (void (*p1)(void*, int, const char*, va_list)))
-  DEFINE_METHOD1(void*, av_malloc, (unsigned int p1))
-  DEFINE_METHOD1(void*, av_mallocz, (unsigned int p1))
-  DEFINE_METHOD2(void*, av_realloc, (void *p1, unsigned int p2))
-  DEFINE_METHOD1(void, av_free, (void *p1))
-  DEFINE_METHOD1(void, av_freep, (void *p1))
-  DEFINE_METHOD4(int64_t, av_rescale_rnd, (int64_t p1, int64_t p2, int64_t p3, enum AVRounding p4));
-  DEFINE_METHOD3(int64_t, av_rescale_q, (int64_t p1, AVRational p2, AVRational p3));
-  DEFINE_METHOD1(const AVCRC*, av_crc_get_table, (AVCRCId p1))
-  DEFINE_METHOD5(int, av_crc_init, (AVCRC *p1, int p2, int p3, uint32_t p4, int p5));
-  DEFINE_METHOD4(uint32_t, av_crc, (const AVCRC *p1, uint32_t p2, const uint8_t *p3, size_t p4));
-  DEFINE_METHOD4(int, av_opt_set, (void *p1, const char *p2, const char *p3, int p4));
-  DEFINE_METHOD4(int, av_opt_set_double, (void *p1, const char *p2, double p3, int p4))
-  DEFINE_METHOD4(int, av_opt_set_int, (void *p1, const char *p2, int64_t p3, int p4))
-  DEFINE_METHOD1(AVFifoBuffer*, av_fifo_alloc, (unsigned int p1))
-  DEFINE_METHOD1(void, av_fifo_free, (AVFifoBuffer *p1))
-  DEFINE_METHOD1(void, av_fifo_reset, (AVFifoBuffer *p1))
-  DEFINE_METHOD1(int, av_fifo_size, (AVFifoBuffer *p1))
-  DEFINE_METHOD4(int, av_fifo_generic_read, (AVFifoBuffer *p1, void *p2, int p3, void (*p4)(void*, void*, int)))
-  DEFINE_METHOD4(int, av_fifo_generic_write, (AVFifoBuffer *p1, void *p2, int p3, int (*p4)(void*, void*, int)))
-  DEFINE_METHOD1(char*, av_strdup, (const char *p1))
-  DEFINE_METHOD1(int, av_get_bytes_per_sample, (enum AVSampleFormat p1))
-  DEFINE_METHOD4(AVDictionaryEntry *, av_dict_get, (AVDictionary *p1, const char *p2, const AVDictionaryEntry *p3, int p4))
-  DEFINE_METHOD4(int, av_dict_set, (AVDictionary **p1, const char *p2, const char *p3, int p4));
-  DEFINE_METHOD1(void, av_dict_free, (AVDictionary **p1));
-  DEFINE_METHOD5(int, av_samples_get_buffer_size, (int *p1, int p2, int p3, enum AVSampleFormat p4, int p5))
-  DEFINE_METHOD1(int64_t, av_get_default_channel_layout, (int p1))
-  DEFINE_METHOD6(int, av_samples_alloc, (uint8_t **p1, int *p2, int p3, int p4, enum AVSampleFormat p5, int p6))
-  DEFINE_METHOD1(int, av_sample_fmt_is_planar, (enum AVSampleFormat p1))
-  DEFINE_METHOD2(int, av_get_channel_layout_channel_index, (uint64_t p1, uint64_t p2))
-  DEFINE_METHOD7(int, av_samples_fill_arrays, (uint8_t **p1, int *p2, const uint8_t *p3, int p4, int p5, enum AVSampleFormat p6, int p7))
-  DEFINE_METHOD7(int, av_samples_copy, (uint8_t **p1, uint8_t *const *p2, int p3, int p4, int p5, int p6, enum AVSampleFormat p7))
-  DEFINE_METHOD2(uint64_t, av_channel_layout_extract_channel, (uint64_t p1, int p2))
-#if defined(AVFRAME_IN_LAVU)
-  DEFINE_METHOD1(void, av_frame_free, (AVFrame **p1))
-  DEFINE_METHOD0(AVFrame *, av_frame_alloc)
-  DEFINE_METHOD1(void, av_frame_unref, (AVFrame *p1))
-  DEFINE_METHOD2(void, av_frame_move_ref, (AVFrame *p1, AVFrame* p2))
-#endif
-
-  public:
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(av_log_set_callback)
-    RESOLVE_METHOD(av_malloc)
-    RESOLVE_METHOD(av_mallocz)
-    RESOLVE_METHOD(av_realloc)
-    RESOLVE_METHOD(av_free)
-    RESOLVE_METHOD(av_freep)
-    RESOLVE_METHOD(av_rescale_rnd)
-    RESOLVE_METHOD(av_rescale_q)
-    RESOLVE_METHOD(av_crc_init)
-    RESOLVE_METHOD(av_crc_get_table)
-    RESOLVE_METHOD(av_crc)
-    RESOLVE_METHOD(av_opt_set)
-    RESOLVE_METHOD(av_opt_set_double)
-    RESOLVE_METHOD(av_opt_set_int)
-    RESOLVE_METHOD(av_fifo_alloc)
-    RESOLVE_METHOD(av_fifo_free)
-    RESOLVE_METHOD(av_fifo_reset)
-    RESOLVE_METHOD(av_fifo_size)
-    RESOLVE_METHOD(av_fifo_generic_read)
-    RESOLVE_METHOD(av_fifo_generic_write)
-    RESOLVE_METHOD(av_strdup)
-    RESOLVE_METHOD(av_get_bytes_per_sample)
-    RESOLVE_METHOD(av_dict_get)
-    RESOLVE_METHOD(av_dict_set)
-    RESOLVE_METHOD(av_dict_free)
-    RESOLVE_METHOD(av_samples_get_buffer_size)
-    RESOLVE_METHOD(av_get_default_channel_layout)
-    RESOLVE_METHOD(av_samples_alloc)
-    RESOLVE_METHOD(av_sample_fmt_is_planar)
-    RESOLVE_METHOD(av_get_channel_layout_channel_index)
-    RESOLVE_METHOD(av_samples_fill_arrays)
-    RESOLVE_METHOD(av_samples_copy)
-    RESOLVE_METHOD(av_channel_layout_extract_channel)
-#if defined(AVFRAME_IN_LAVU)
-    RESOLVE_METHOD(av_frame_free)
-    RESOLVE_METHOD(av_frame_alloc)
-    RESOLVE_METHOD(av_frame_unref)
-    RESOLVE_METHOD(av_frame_move_ref)
-#endif
-  END_METHOD_RESOLVE()
-};
-
-#endif
-
-class DllAvUtil : public DllAvUtilBase
-{
-public:
-  virtual bool Load()
-  {
-    if( DllAvUtilBase::Load() )
-    {
-      DllAvUtilBase::av_log_set_callback(ff_avutil_log);
-      return true;
-    }
-    return false;
-  }
-};
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllPostProc.h xbmc-13.2rc1-Gotham/lib/DllPostProc.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllPostProc.h	2014-08-13 18:26:38.832666321 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllPostProc.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,129 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "utils/log.h"
-
-extern "C" {
-#define HAVE_MMX
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-  
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libavutil/avutil.h>
-  #include <libpostproc/postprocess.h>
-#else
-  #include "libavutil/avutil.h"
-  #include "libpostproc/postprocess.h"
-#endif
-}
-
-#include "utils/CPUInfo.h"
-
-inline int PPCPUFlags()
-{
-  unsigned int cpuFeatures = g_cpuInfo.GetCPUFeatures();
-  int flags = 0;
-
-  if (cpuFeatures & CPU_FEATURE_MMX)
-    flags |= PP_CPU_CAPS_MMX;
-  if (cpuFeatures & CPU_FEATURE_MMX2)
-    flags |= PP_CPU_CAPS_MMX2;
-  if (cpuFeatures & CPU_FEATURE_3DNOW)
-    flags |= PP_CPU_CAPS_3DNOW;
-  if (cpuFeatures & CPU_FEATURE_ALTIVEC)
-    flags |= PP_CPU_CAPS_ALTIVEC;
-
-  return flags;
-}
-
-class DllPostProcInterface
-{
-public:
-   virtual ~DllPostProcInterface() {}
-  virtual void pp_postprocess(uint8_t * src[3], int srcStride[3], uint8_t * dst[3], int dstStride[3],
-                   int horizontalSize, int verticalSize, QP_STORE_T *QP_store,  int QP_stride,
-		           pp_mode *mode, pp_context *ppContext, int pict_type)=0;	           
-  virtual pp_mode *pp_get_mode_by_name_and_quality(char *name, int quality)=0;
-  virtual void pp_free_mode(pp_mode *mode)=0;
-  virtual pp_context *pp_get_context(int width, int height, int flags)=0;
-  virtual void pp_free_context(pp_context *ppContext)=0;
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-
-// We call directly.
-class DllPostProc : public DllDynamic, DllPostProcInterface
-{
-public:
-  
-  virtual ~DllPostProc() {}
-  virtual void pp_postprocess(uint8_t * src[3], int srcStride[3], uint8_t * dst[3], int dstStride[3],
-                  int horizontalSize, int verticalSize, QP_STORE_T *QP_store,  int QP_stride,
-                  pp_mode *mode, pp_context *ppContext, int pict_type) { ::pp_postprocess((const uint8_t** )src, srcStride, dst, dstStride, horizontalSize, verticalSize, QP_store, QP_stride, mode, ppContext, pict_type); }             
-  virtual pp_mode *pp_get_mode_by_name_and_quality(char *name, int quality) { return ::pp_get_mode_by_name_and_quality(name, quality); }
-  virtual void pp_free_mode(pp_mode *mode) { ::pp_free_mode(mode); }
-  virtual pp_context *pp_get_context(int width, int height, int flags) { return ::pp_get_context(width, height, flags); }
-  virtual void pp_free_context(pp_context *ppContext) { ::pp_free_context(ppContext); }
-  
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllPostProc: Using libpostproc system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-};
-
-#else
-class DllPostProc : public DllDynamic, DllPostProcInterface
-{
-  DECLARE_DLL_WRAPPER(DllPostProc, DLL_PATH_LIBPOSTPROC)
-  DEFINE_METHOD11(void, pp_postprocess, (uint8_t* p1[3], int p2[3], uint8_t * p3[3], int p4[3],
-                      int p5, int p6, QP_STORE_T *p7,  int p8,
-                      pp_mode *p9, pp_context *p10, int p11))
-  DEFINE_METHOD2(pp_mode*, pp_get_mode_by_name_and_quality, (char *p1, int p2))
-  DEFINE_METHOD1(void, pp_free_mode, (pp_mode *p1))
-  DEFINE_METHOD3(pp_context*, pp_get_context, (int p1, int p2, int p3))
-  DEFINE_METHOD1(void, pp_free_context, (pp_context *p1))
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(pp_postprocess)
-    RESOLVE_METHOD(pp_get_mode_by_name_and_quality)
-    RESOLVE_METHOD(pp_free_mode)
-    RESOLVE_METHOD(pp_get_context)
-    RESOLVE_METHOD(pp_free_context)
-  END_METHOD_RESOLVE()
-};
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllSwResample.h xbmc-13.2rc1-Gotham/lib/DllSwResample.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllSwResample.h	2014-08-13 18:26:14.768546989 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllSwResample.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,131 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "utils/log.h"
-
-extern "C" {
-#ifndef HAVE_MMX
-#define HAVE_MMX
-#endif
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-#if (defined USE_EXTERNAL_FFMPEG)
-  #if (defined USE_LIBAV_HACKS)
-    #include "xbmc-libav-hacks/libav_hacks.h"
-  #else
-    #include <libswresample/swresample.h>
-  #endif
-#else
-  #include "libswresample/swresample.h"
-#endif
-}
-
-class DllSwResampleInterface
-{
-public:
-  virtual ~DllSwResampleInterface() {}
-  virtual struct SwrContext *swr_alloc_set_opts(struct SwrContext *s, int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, int64_t in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx)=0;
-  virtual int swr_init(struct SwrContext *s)=0;
-  virtual void swr_free(struct SwrContext **s)=0;
-  virtual int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count)=0;
-  virtual int64_t swr_get_delay(struct SwrContext *s, int64_t base) = 0;
-  virtual int swr_set_channel_mapping(struct SwrContext *s, const int *channel_map) = 0;
-  virtual int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride) = 0;
-  virtual int swr_set_compensation(struct SwrContext *s, int sample_delta, int compensation_distance) = 0;
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-
-// Use direct mapping
-class DllSwResample : public DllDynamic, DllSwResampleInterface
-{
-public:
-  virtual ~DllSwResample() {}
-
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllAvFormat: Using libswresample system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-  virtual struct SwrContext *swr_alloc_set_opts(struct SwrContext *s, int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate, int64_t in_ch_layout, enum AVSampleFormat in_sample_fmt, int in_sample_rate, int log_offset, void *log_ctx) { return ::swr_alloc_set_opts(s, out_ch_layout, out_sample_fmt, out_sample_rate, in_ch_layout, in_sample_fmt, in_sample_rate, log_offset, log_ctx); }
-  virtual int swr_init(struct SwrContext *s) { return ::swr_init(s); }
-  virtual void swr_free(struct SwrContext **s){ return ::swr_free(s); }
-  virtual int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count){ return ::swr_convert(s, out, out_count, in, in_count); }
-  virtual int64_t swr_get_delay(struct SwrContext *s, int64_t base) { return ::swr_get_delay(s, base); }
-  virtual int swr_set_channel_mapping (struct SwrContext *s, const int *channel_map) { return ::swr_set_channel_mapping(s, channel_map); }
-  virtual int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride) { return ::swr_set_matrix(s, matrix, stride); }
-  virtual int swr_set_compensation(struct SwrContext *s, int sample_delta, int compensation_distance) { return ::swr_set_compensation(s, sample_delta, compensation_distance); }
-};
-
-#else
-
-class DllSwResample : public DllDynamic, DllSwResampleInterface
-{
-  DECLARE_DLL_WRAPPER(DllSwResample, DLL_PATH_LIBSWRESAMPLE)
-
-  LOAD_SYMBOLS()
-
-  DEFINE_METHOD9(SwrContext*, swr_alloc_set_opts, (struct SwrContext *p1, int64_t p2, enum AVSampleFormat p3, int p4, int64_t p5, enum AVSampleFormat p6, int p7, int p8, void * p9));
-  DEFINE_METHOD1(int, swr_init, (struct SwrContext *p1))
-  DEFINE_METHOD1(void, swr_free, (struct SwrContext **p1))
-  DEFINE_METHOD5(int, swr_convert, (struct SwrContext *p1, uint8_t **p2, int p3, const uint8_t **p4, int p5))
-  DEFINE_METHOD2(int64_t, swr_get_delay, (struct SwrContext *p1, int64_t p2))
-  DEFINE_METHOD2(int, swr_set_channel_mapping, (struct SwrContext *p1, const int *p2))
-  DEFINE_METHOD3(int, swr_set_matrix, (struct SwrContext *p1, const double *p2, int p3))
-  DEFINE_METHOD3(int, swr_set_compensation, (struct SwrContext *p1, int p2, int p3))
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(swr_alloc_set_opts)
-    RESOLVE_METHOD(swr_init)
-    RESOLVE_METHOD(swr_free)
-    RESOLVE_METHOD(swr_convert)
-    RESOLVE_METHOD(swr_get_delay)
-    RESOLVE_METHOD(swr_set_channel_mapping)
-    RESOLVE_METHOD(swr_set_matrix)
-    RESOLVE_METHOD(swr_set_compensation)
-  END_METHOD_RESOLVE()
-
-  /* dependencies of libavformat */
-  DllAvUtil m_dllAvUtil;
-
-public:
-
-  virtual bool Load()
-  {
-    if (!m_dllAvUtil.Load())
-      return false;
-    return DllDynamic::Load();
-  }
-};
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/DllSwScale.h xbmc-13.2rc1-Gotham/lib/DllSwScale.h
--- xbmc-13.2rc1-Gotham.orig/lib/DllSwScale.h	2014-08-13 18:26:22.396584815 +0800
+++ xbmc-13.2rc1-Gotham/lib/DllSwScale.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,153 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "DllAvUtil.h"
-#include "utils/log.h"
-
-extern "C" {
-#ifndef HAVE_MMX
-#define HAVE_MMX
-#endif
-
-#ifndef __STDC_CONSTANT_MACROS
-#define __STDC_CONSTANT_MACROS
-#endif
-
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS
-#endif
-
-#ifndef __GNUC__
-#pragma warning(disable:4244)
-#endif
-
-#if (defined USE_EXTERNAL_FFMPEG)
-  #include <libswscale/swscale.h>
-#else
-  #include "libswscale/swscale.h"
-#endif
-}
-
-#include "../xbmc/utils/CPUInfo.h"
-
-inline int SwScaleCPUFlags()
-{
-  unsigned int cpuFeatures = g_cpuInfo.GetCPUFeatures();
-  int flags = 0;
-
-  if (cpuFeatures & CPU_FEATURE_MMX)
-    flags |= SWS_CPU_CAPS_MMX;
-  if (cpuFeatures & CPU_FEATURE_MMX2)
-    flags |= SWS_CPU_CAPS_MMX2;
-  if (cpuFeatures & CPU_FEATURE_3DNOW)
-    flags |= SWS_CPU_CAPS_3DNOW;
-  if (cpuFeatures & CPU_FEATURE_ALTIVEC)
-    flags |= SWS_CPU_CAPS_ALTIVEC;
-
-  return flags;
-}
-
-class DllSwScaleInterface
-{
-public:
-   virtual ~DllSwScaleInterface() {}
-
-   virtual struct SwsContext *sws_getCachedContext(struct SwsContext *context,
-                                             int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,
-                                  SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)=0;
-
-   virtual struct SwsContext *sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,
-                                  SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)=0;
-
-   virtual int sws_scale(struct SwsContext *context, uint8_t* src[], int srcStride[], int srcSliceY,
-                         int srcSliceH, uint8_t* dst[], int dstStride[])=0;
-
-   virtual void sws_freeContext(struct SwsContext *context)=0;
-};
-
-#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) || (defined USE_STATIC_FFMPEG)
-
-// We call into this library directly.
-class DllSwScale : public DllDynamic, public DllSwScaleInterface
-{
-public:
-  virtual ~DllSwScale() {}
-  virtual struct SwsContext *sws_getCachedContext(struct SwsContext *context,
-                                            int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,
-                               SwsFilter *srcFilter, SwsFilter *dstFilter, double *param) 
-    { return ::sws_getCachedContext(context, srcW, srcH, (enum PixelFormat)srcFormat, dstW, dstH, (enum PixelFormat)dstFormat, flags, srcFilter, dstFilter, param); }
-
-  virtual struct SwsContext *sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,
-                               SwsFilter *srcFilter, SwsFilter *dstFilter, double *param) 
-    { return ::sws_getContext(srcW, srcH, (enum PixelFormat)srcFormat, dstW, dstH, (enum PixelFormat)dstFormat, flags, srcFilter, dstFilter, param); }
-
-  virtual int sws_scale(struct SwsContext *context, uint8_t* src[], int srcStride[], int srcSliceY,
-                int srcSliceH, uint8_t* dst[], int dstStride[])  
-    { return ::sws_scale(context, src, srcStride, srcSliceY, srcSliceH, dst, dstStride); }
-  virtual void sws_freeContext(struct SwsContext *context) { ::sws_freeContext(context); }
-  
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if !defined(TARGET_DARWIN) && !defined(USE_STATIC_FFMPEG)
-    CLog::Log(LOGDEBUG, "DllSwScale: Using libswscale system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-};
-
-#else
-
-class DllSwScale : public DllDynamic, public DllSwScaleInterface
-{
-  DECLARE_DLL_WRAPPER(DllSwScale, DLL_PATH_LIBSWSCALE)
-  DEFINE_METHOD11(struct SwsContext *, sws_getCachedContext, ( struct SwsContext *p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8,
-							 SwsFilter * p9, SwsFilter * p10, double * p11))
-  DEFINE_METHOD10(struct SwsContext *, sws_getContext, ( int p1, int p2, int p3, int p4, int p5, int p6, int p7, 
-							 SwsFilter * p8, SwsFilter * p9, double * p10))
-  DEFINE_METHOD7(int, sws_scale, (struct SwsContext *p1, uint8_t** p2, int *p3, int p4, int p5, uint8_t **p6, int *p7))
-  DEFINE_METHOD1(void, sws_freeContext, (struct SwsContext *p1))
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(sws_getCachedContext)
-    RESOLVE_METHOD(sws_getContext)
-    RESOLVE_METHOD(sws_scale)
-    RESOLVE_METHOD(sws_freeContext)
-  END_METHOD_RESOLVE()
-
-  /* dependency of libswscale */
-  DllAvUtil m_dllAvUtil;
-
-public:
-  virtual bool Load()
-  {
-    if (!m_dllAvUtil.Load())
-      return false;
-    return DllDynamic::Load();
-  }
-};
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/Makefile.in xbmc-13.2rc1-Gotham/lib/Makefile.in
--- xbmc-13.2rc1-Gotham.orig/lib/Makefile.in	2014-08-13 18:26:41.232678223 +0800
+++ xbmc-13.2rc1-Gotham/lib/Makefile.in	1970-01-01 08:00:00.000000000 +0800
@@ -1,103 +0,0 @@
-ARCH=@ARCH@
-
-AR=@AR@
-LD=@LD@
-CC=@CC@
-CXX=@CXX@
-SYSDIR=@abs_top_srcdir@/system/players/dvdplayer
-
-ifeq (@USE_ANDROID@,1)
-AVPREFIX=lib
-else
-AVPREFIX=
-endif
-
-AVFORMAT_SO=$(AVPREFIX)avformat-54-$(ARCH).so
-AVCODEC_SO=$(AVPREFIX)avcodec-54-$(ARCH).so
-AVUTIL_SO=$(AVPREFIX)avutil-52-$(ARCH).so
-AVFILTER_SO=$(AVPREFIX)avfilter-3-$(ARCH).so
-SWSCALE_SO=$(AVPREFIX)swscale-2-$(ARCH).so
-POSTPROC_SO=$(AVPREFIX)postproc-52-$(ARCH).so
-SWRESAMPLE_SO=$(AVPREFIX)swresample-0-$(ARCH).so
-
-DIRS=
-ifneq (@USE_EXTERNAL_FFMPEG@,1)
-  DIRS+=ffmpeg
-endif
-
-LIBS=
-ifneq (@USE_EXTERNAL_FFMPEG@,1)
-ifneq (@USE_STATIC_FFMPEG@,1)
-  LIBS+=$(AVUTIL_SO) \
-	$(AVCODEC_SO) \
-	$(AVFORMAT_SO) \
-	$(POSTPROC_SO) \
-	$(AVFILTER_SO) \
-	$(SWSCALE_SO) \
-	$(SWRESAMPLE_SO)
-endif
-endif
-
-.PHONY: $(DIRS) codecs
-
-ifneq ($(findstring osx,$(ARCH)), osx)
-ifneq (@USE_STATIC_FFMPEG@,1)
-
-codecs: $(addprefix $(SYSDIR)/, $(LIBS));
-
-$(SYSDIR)/$(AVUTIL_SO): ffmpeg/libavutil/libavutil.so
-	cp ffmpeg/libavutil/libavutil.so $@
-
-$(SYSDIR)/$(AVCODEC_SO): ffmpeg/libavcodec/libavcodec.so
-	cp ffmpeg/libavcodec/libavcodec.so $@
-
-$(SYSDIR)/$(AVFORMAT_SO): ffmpeg/libavformat/libavformat.so
-	cp ffmpeg/libavformat/libavformat.so $@
-
-$(SYSDIR)/$(AVFILTER_SO): ffmpeg/libavfilter/libavfilter.so
-	cp ffmpeg/libavfilter/libavfilter.so $@
-
-$(SYSDIR)/$(SWSCALE_SO): ffmpeg/libswscale/libswscale.so
-	cp ffmpeg/libswscale/libswscale.so $@
-
-$(SYSDIR)/$(POSTPROC_SO): ffmpeg/libpostproc/libpostproc.so
-	cp ffmpeg/libpostproc/libpostproc.so $@
-
-$(SYSDIR)/$(SWRESAMPLE_SO): ffmpeg/libswresample/libswresample.so
-	cp ffmpeg/libswresample/libswresample.so $@
-
-ffmpeg/libavutil/libavutil.so     : ffmpeg;
-ffmpeg/libavcodec/libavcodec.so   : ffmpeg;
-ffmpeg/libavformat/libavformat.so : ffmpeg;
-ffmpeg/libavfilter/libavfilter.so : ffmpeg;
-ffmpeg/libswscale/libswscale.so   : ffmpeg;
-ffmpeg/libpostproc/libpostproc.so : ffmpeg;
-ffmpeg/libswresample/libswresample.so : ffmpeg;
-endif
-endif
-
-ifeq (@USE_STATIC_FFMPEG@,1)
-ffmpeg/libavutil/libavutil.a     : ffmpeg;
-ffmpeg/libavcodec/libavcodec.a   : ffmpeg;
-ffmpeg/libavformat/libavformat.a : ffmpeg;
-ffmpeg/libavfilter/libavfilter.a : ffmpeg;
-ffmpeg/libswscale/libswscale.a   : ffmpeg;
-ffmpeg/libpostproc/libpostproc.a : ffmpeg;
-ffmpeg/libswresample/libswresample.a : ffmpeg;
-endif
-
-ffmpeg:
-	$(MAKE) -C $@
-ifeq ($(findstring osx,$(ARCH)), osx)
-	-$(AR) d ffmpeg/libavcodec/libavcodec.a log2_tab.o
-	-$(AR) d ffmpeg/libavformat/libavformat.a log2_tab.o
-	-$(AR) d ffmpeg/libswresample/libswresample.a log2_tab.o
-endif
-
-clean:
-	rm -f $(addprefix $(SYSDIR)/, $(LIBS))
-	for d in $(DIRS); do (if test -f "$$d/Makefile"; then ($(MAKE) -C "$$d" clean); fi ); done
-
-distclean:
-	rm -f $(addprefix $(SYSDIR)/, $(LIBS))
-	for d in $(DIRS); do (if test -f "$$d/Makefile"; then ($(MAKE) -C "$$d" distclean || $(MAKE) -C "$$d" clean); fi ); done
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/win32/ffmpeg_dxva2/dxva2api.h xbmc-13.2rc1-Gotham/lib/win32/ffmpeg_dxva2/dxva2api.h
--- xbmc-13.2rc1-Gotham.orig/lib/win32/ffmpeg_dxva2/dxva2api.h	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/lib/win32/ffmpeg_dxva2/dxva2api.h	2014-08-13 18:27:00.788775196 +0800
@@ -0,0 +1,502 @@
+/*****************************************************************************
+ * dxva2api.h: DXVA 2 interface
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * $Id$
+ *
+ * Authors: Geoffroy Couprie <geal _AT_ videolan _DOT_ org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef _DXVA2API_H
+#define _DXVA2API_H
+
+#define MINGW_DXVA2API_H_VERSION (2)
+
+#if __GNUC__ >=3
+#pragma GCC system_header
+#endif
+
+#include <objbase.h>
+#include <d3d9.h>
+
+/* Define it to allow using nameless struct/union (non C99 compliant) to match
+ * the official documentation. */
+//#define DXVA2API_USE_BITFIELDS
+
+/****************STRUCTURES******************/
+#pragma pack(push, 1)
+
+typedef struct _DXVA2_ExtendedFormat {
+#ifdef DXVA2API_USE_BITFIELDS
+  union {
+    struct {
+      UINT SampleFormat           : 8;
+      UINT VideoChromaSubsampling : 4;
+      UINT NominalRange           : 3;
+      UINT VideoTransferMatrix    : 3;
+      UINT VideoLighting          : 4;
+      UINT VideoPrimaries         : 5;
+      UINT VideoTransferFunction  : 5;
+    };
+    UINT value;
+  };
+#else
+    UINT value;
+#endif
+} DXVA2_ExtendedFormat;
+
+typedef struct _DXVA2_Frequency {
+  UINT Numerator;
+  UINT Denominator;
+} DXVA2_Frequency;
+
+typedef struct _DXVA2_VideoDesc {
+  UINT SampleWidth;
+  UINT SampleHeight;
+  DXVA2_ExtendedFormat SampleFormat;
+  D3DFORMAT Format;
+  DXVA2_Frequency InputSampleFreq;
+  DXVA2_Frequency OutputFrameFreq;
+  UINT UABProtectionLevel;
+  UINT Reserved;
+} DXVA2_VideoDesc;
+
+typedef struct _DXVA2_ConfigPictureDecode {
+  GUID guidConfigBitstreamEncryption;
+  GUID guidConfigMBcontrolEncryption;
+  GUID guidConfigResidDiffEncryption;
+  UINT ConfigBitstreamRaw;
+  UINT ConfigMBcontrolRasterOrder;
+  UINT ConfigResidDiffHost;
+  UINT ConfigSpatialResid8;
+  UINT ConfigResid8Subtraction;
+  UINT ConfigSpatialHost8or9Clipping;
+  UINT ConfigSpatialResidInterleaved;
+  UINT ConfigIntraResidUnsigned;
+  UINT ConfigResidDiffAccelerator;
+  UINT ConfigHostInverseScan;
+  UINT ConfigSpecificIDCT;
+  UINT Config4GroupedCoefs;
+  USHORT ConfigMinRenderTargetBuffCount;
+  USHORT ConfigDecoderSpecific;
+} DXVA2_ConfigPictureDecode;
+
+typedef struct _DXVA2_DecodeBufferDesc {
+  DWORD CompressedBufferType;
+  UINT BufferIndex;
+  UINT DataOffset;
+  UINT DataSize;
+  UINT FirstMBaddress;
+  UINT NumMBsInBuffer;
+  UINT Width;
+  UINT Height;
+  UINT Stride;
+  UINT ReservedBits;
+  PVOID pvPVPState;
+} DXVA2_DecodeBufferDesc;
+
+typedef struct _DXVA2_DecodeExtensionData {
+  UINT Function;
+  PVOID pPrivateInputData;
+  UINT PrivateInputDataSize;
+  PVOID pPrivateOutputData;
+  UINT PrivateOutputDataSize;
+} DXVA2_DecodeExtensionData;
+
+typedef struct _DXVA2_DecodeExecuteParams {
+  UINT NumCompBuffers;
+  DXVA2_DecodeBufferDesc *pCompressedBuffers;
+  DXVA2_DecodeExtensionData *pExtensionData;
+} DXVA2_DecodeExecuteParams;
+
+enum {
+    DXVA2_VideoDecoderRenderTarget	= 0,
+	DXVA2_VideoProcessorRenderTarget	= 1,
+	DXVA2_VideoSoftwareRenderTarget	= 2
+};
+
+enum {
+    DXVA2_PictureParametersBufferType	= 0,
+	DXVA2_MacroBlockControlBufferType	= 1,
+	DXVA2_ResidualDifferenceBufferType	= 2,
+	DXVA2_DeblockingControlBufferType	= 3,
+	DXVA2_InverseQuantizationMatrixBufferType	= 4,
+	DXVA2_SliceControlBufferType	= 5,
+	DXVA2_BitStreamDateBufferType	= 6,
+	DXVA2_MotionVectorBuffer	= 7,
+	DXVA2_FilmGrainBuffer	= 8
+};
+
+/* DXVA MPEG-I/II and VC-1 */
+typedef struct _DXVA_PictureParameters {
+    USHORT  wDecodedPictureIndex;
+    USHORT  wDeblockedPictureIndex;
+    USHORT  wForwardRefPictureIndex;
+    USHORT  wBackwardRefPictureIndex;
+    USHORT  wPicWidthInMBminus1;
+    USHORT  wPicHeightInMBminus1;
+    UCHAR   bMacroblockWidthMinus1;
+    UCHAR   bMacroblockHeightMinus1;
+    UCHAR   bBlockWidthMinus1;
+    UCHAR   bBlockHeightMinus1;
+    UCHAR   bBPPminus1;
+    UCHAR   bPicStructure;
+    UCHAR   bSecondField;
+    UCHAR   bPicIntra;
+    UCHAR   bPicBackwardPrediction;
+    UCHAR   bBidirectionalAveragingMode;
+    UCHAR   bMVprecisionAndChromaRelation;
+    UCHAR   bChromaFormat;
+    UCHAR   bPicScanFixed;
+    UCHAR   bPicScanMethod;
+    UCHAR   bPicReadbackRequests;
+    UCHAR   bRcontrol;
+    UCHAR   bPicSpatialResid8;
+    UCHAR   bPicOverflowBlocks;
+    UCHAR   bPicExtrapolation;
+    UCHAR   bPicDeblocked;
+    UCHAR   bPicDeblockConfined;
+    UCHAR   bPic4MVallowed;
+    UCHAR   bPicOBMC;
+    UCHAR   bPicBinPB;
+    UCHAR   bMV_RPS;
+    UCHAR   bReservedBits;
+    USHORT  wBitstreamFcodes;
+    USHORT  wBitstreamPCEelements;
+    UCHAR   bBitstreamConcealmentNeed;
+    UCHAR   bBitstreamConcealmentMethod;
+} DXVA_PictureParameters, *LPDXVA_PictureParameters;
+
+typedef struct _DXVA_QmatrixData {
+    BYTE    bNewQmatrix[4];
+    WORD    Qmatrix[4][8 * 8];
+} DXVA_QmatrixData, *LPDXVA_QmatrixData;
+
+typedef struct _DXVA_SliceInfo {
+    USHORT  wHorizontalPosition;
+    USHORT  wVerticalPosition;
+    UINT    dwSliceBitsInBuffer;
+    UINT    dwSliceDataLocation;
+    UCHAR   bStartCodeBitOffset;
+    UCHAR   bReservedBits;
+    USHORT  wMBbitOffset;
+    USHORT  wNumberMBsInSlice;
+    USHORT  wQuantizerScaleCode;
+    USHORT  wBadSliceChopping;
+} DXVA_SliceInfo, *LPDXVA_SliceInfo;
+
+/* DXVA H264 */
+typedef struct {
+#ifdef DXVA2API_USE_BITFIELDS
+    union {
+        struct {
+            UCHAR Index7Bits     : 7;
+            UCHAR AssociatedFlag : 1;
+        };
+        UCHAR bPicEntry;
+    };
+#else
+    UCHAR bPicEntry;
+#endif
+} DXVA_PicEntry_H264;
+
+
+typedef struct {
+    USHORT wFrameWidthInMbsMinus1;
+    USHORT wFrameHeightInMbsMinus1;
+    DXVA_PicEntry_H264 CurrPic;
+    UCHAR  num_ref_frames;
+#ifdef DXVA2API_USE_BITFIELDS
+    union {
+        struct {
+            USHORT field_pic_flag           : 1;
+            USHORT MbaffFrameFlag           : 1;
+            USHORT residual_colour_transform_flag : 1;
+            USHORT sp_for_switch_flag       : 1;
+            USHORT chroma_format_idc        : 2;
+            USHORT RefPicFlag               : 1;
+            USHORT constrained_intra_pred_flag : 1;
+            USHORT weighted_pred_flag       : 1;
+            USHORT weighted_bipred_idc      : 2;
+            USHORT MbsConsecutiveFlag       : 1;
+            USHORT frame_mbs_only_flag      : 1;
+            USHORT transform_8x8_mode_flag  : 1;
+            USHORT MinLumaBipredSize8x8Flag : 1;
+            USHORT IntraPicFlag             : 1;
+        };
+        USHORT wBitFields;
+    };
+#else
+    USHORT wBitFields;
+#endif
+    UCHAR   bit_depth_luma_minus8;
+    UCHAR   bit_depth_chroma_minus8;
+    USHORT  Reserved16Bits;
+    UINT    StatusReportFeedbackNumber;
+    DXVA_PicEntry_H264 RefFrameList[16];
+    INT     CurrFieldOrderCnt[2];
+    INT     FieldOrderCntList[16][2];
+    CHAR    pic_init_qs_minus26;
+    CHAR    chroma_qp_index_offset;
+    CHAR    second_chroma_qp_index_offset;
+    UCHAR   ContinuationFlag;
+    CHAR    pic_init_qp_minus26;
+    UCHAR   num_ref_idx_l0_active_minus1;
+    UCHAR   num_ref_idx_l1_active_minus1;
+    UCHAR   Reserved8BitsA;
+    USHORT  FrameNumList[16];
+
+    UINT    UsedForReferenceFlags;
+    USHORT  NonExistingFrameFlags;
+    USHORT  frame_num;
+    UCHAR   log2_max_frame_num_minus4;
+    UCHAR   pic_order_cnt_type;
+    UCHAR   log2_max_pic_order_cnt_lsb_minus4;
+    UCHAR   delta_pic_order_always_zero_flag;
+    UCHAR   direct_8x8_inference_flag;
+    UCHAR   entropy_coding_mode_flag;
+    UCHAR   pic_order_present_flag;
+    UCHAR   num_slice_groups_minus1;
+    UCHAR   slice_group_map_type;
+    UCHAR   deblocking_filter_control_present_flag;
+    UCHAR   redundant_pic_cnt_present_flag;
+    UCHAR   Reserved8BitsB;
+    USHORT  slice_group_change_rate_minus1;
+    UCHAR   SliceGroupMap[810];
+} DXVA_PicParams_H264;
+
+typedef struct {
+    UCHAR   bScalingLists4x4[6][16];
+    UCHAR   bScalingLists8x8[2][64];
+} DXVA_Qmatrix_H264;
+
+
+typedef struct {
+    UINT    BSNALunitDataLocation;
+    UINT    SliceBytesInBuffer;
+    USHORT  wBadSliceChopping;
+    USHORT  first_mb_in_slice;
+    USHORT  NumMbsForSlice;
+    USHORT  BitOffsetToSliceData;
+    UCHAR   slice_type;
+    UCHAR   luma_log2_weight_denom;
+    UCHAR   chroma_log2_weight_denom;
+
+    UCHAR   num_ref_idx_l0_active_minus1;
+    UCHAR   num_ref_idx_l1_active_minus1;
+    CHAR    slice_alpha_c0_offset_div2;
+    CHAR    slice_beta_offset_div2;
+    UCHAR   Reserved8Bits;
+    DXVA_PicEntry_H264 RefPicList[2][32];
+    SHORT   Weights[2][32][3][2];
+    CHAR    slice_qs_delta;
+    CHAR    slice_qp_delta;
+    UCHAR   redundant_pic_cnt;
+    UCHAR   direct_spatial_mv_pred_flag;
+    UCHAR   cabac_init_idc;
+    UCHAR   disable_deblocking_filter_idc;
+    USHORT  slice_id;
+} DXVA_Slice_H264_Long;
+
+typedef struct {
+    UINT    BSNALunitDataLocation;
+    UINT    SliceBytesInBuffer;
+    USHORT  wBadSliceChopping;
+} DXVA_Slice_H264_Short;
+
+typedef struct {
+    USHORT  wFrameWidthInMbsMinus1;
+    USHORT  wFrameHeightInMbsMinus1;
+    DXVA_PicEntry_H264 InPic;
+    DXVA_PicEntry_H264 OutPic;
+    USHORT  PicOrderCnt_offset;
+    INT     CurrPicOrderCnt;
+    UINT    StatusReportFeedbackNumber;
+    UCHAR   model_id;
+    UCHAR   separate_colour_description_present_flag;
+    UCHAR   film_grain_bit_depth_luma_minus8;
+    UCHAR   film_grain_bit_depth_chroma_minus8;
+    UCHAR   film_grain_full_range_flag;
+    UCHAR   film_grain_colour_primaries;
+    UCHAR   film_grain_transfer_characteristics;
+    UCHAR   film_grain_matrix_coefficients;
+    UCHAR   blending_mode_id;
+    UCHAR   log2_scale_factor;
+    UCHAR   comp_model_present_flag[4];
+    UCHAR   num_intensity_intervals_minus1[4];
+    UCHAR   num_model_values_minus1[4];
+    UCHAR   intensity_interval_lower_bound[3][16];
+    UCHAR   intensity_interval_upper_bound[3][16];
+    SHORT   comp_model_value[3][16][8];
+} DXVA_FilmGrainChar_H264;
+
+#pragma pack(pop)
+
+/*************INTERFACES************/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef _COM_interface IDirectXVideoDecoderService IDirectXVideoDecoderService;
+typedef _COM_interface IDirectXVideoDecoder IDirectXVideoDecoder;
+
+#undef INTERFACE
+#define INTERFACE IDirectXVideoDecoder
+DECLARE_INTERFACE_(IDirectXVideoDecoder,IUnknown)
+{
+	STDMETHOD(QueryInterface)(THIS_ REFIID,PVOID*) PURE;
+	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+	STDMETHOD_(ULONG,Release)(THIS) PURE;
+	STDMETHOD(GetVideoDecoderService)(THIS_ IDirectXVideoDecoderService**) PURE;
+	STDMETHOD(GetCreationParameters)(THIS_ GUID*,DXVA2_VideoDesc*,DXVA2_ConfigPictureDecode*,IDirect3DSurface9***,UINT*) PURE;
+	STDMETHOD(GetBuffer)(THIS_ UINT,void**,UINT*) PURE;
+	STDMETHOD(ReleaseBuffer)(THIS_ UINT) PURE;
+	STDMETHOD(BeginFrame)(THIS_ IDirect3DSurface9 *,void*) PURE;
+	STDMETHOD(EndFrame)(THIS_ HANDLE *) PURE;
+	STDMETHOD(Execute)(THIS_ const DXVA2_DecodeExecuteParams*) PURE;
+
+
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectXVideoDecoder_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectXVideoDecoder_AddRef(p)	(p)->lpVtbl->AddRef(p)
+#define IDirectXVideoDecoder_Release(p)	(p)->lpVtbl->Release(p)
+#define IDirectXVideoDecoder_BeginFrame(p,a,b)	(p)->lpVtbl->BeginFrame(p,a,b)
+#define IDirectXVideoDecoder_EndFrame(p,a)	(p)->lpVtbl->EndFrame(p,a)
+#define IDirectXVideoDecoder_Execute(p,a)	(p)->lpVtbl->Execute(p,a)
+#define IDirectXVideoDecoder_GetBuffer(p,a,b,c)	(p)->lpVtbl->GetBuffer(p,a,b,c)
+#define IDirectXVideoDecoder_GetCreationParameters(p,a,b,c,d,e)	(p)->lpVtbl->GetCreationParameters(p,a,b,c,d,e)
+#define IDirectXVideoDecoder_GetVideoDecoderService(p,a)	(p)->lpVtbl->GetVideoDecoderService(p,a)
+#define IDirectXVideoDecoder_ReleaseBuffer(p,a)	(p)->lpVtbl->ReleaseBuffer(p,a)
+#else
+#define IDirectXVideoDecoder_QueryInterface(p,a,b)	(p)->QueryInterface(a,b)
+#define IDirectXVideoDecoder_AddRef(p)	(p)->AddRef()
+#define IDirectXVideoDecoder_Release(p)	(p)->Release()
+#define IDirectXVideoDecoder_BeginFrame(p,a,b)	(p)->BeginFrame(a,b)
+#define IDirectXVideoDecoder_EndFrame(p,a)	(p)->EndFrame(a)
+#define IDirectXVideoDecoder_Execute(p,a)	(p)->Execute(a)
+#define IDirectXVideoDecoder_GetBuffer(p,a,b,c)	(p)->GetBuffer(a,b,c)
+#define IDirectXVideoDecoder_GetCreationParameters(p,a,b,c,d,e)	(p)->GetCreationParameters(a,b,c,d,e)
+#define IDirectXVideoDecoder_GetVideoDecoderService(p,a)	(p)->GetVideoDecoderService(a)
+#define IDirectXVideoDecoder_ReleaseBuffer(p,a)	(p)->ReleaseBuffer(a)
+#endif
+
+#undef INTERFACE
+#define INTERFACE IDirectXVideoAccelerationService
+DECLARE_INTERFACE_(IDirectXVideoAccelerationService,IUnknown)
+{
+    STDMETHOD(QueryInterface)(THIS_ REFIID,PVOID*) PURE;
+	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+	STDMETHOD_(ULONG,Release)(THIS) PURE;
+    STDMETHOD(CreateSurface)(THIS_ UINT,UINT,UINT,D3DFORMAT,D3DPOOL,DWORD,DWORD,IDirect3DSurface9**,HANDLE*) PURE;
+
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectXVideoAccelerationService_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectXVideoAccelerationService_AddRef(p)	(p)->lpVtbl->AddRef(p)
+#define IDirectXVideoAccelerationService_Release(p)	(p)->lpVtbl->Release(p)
+#define IDirectXVideoAccelerationService_CreateSurface(p,a,b,c,d,e,f,g,h,i)	(p)->lpVtbl->CreateSurface(p,a,b,c,d,e,f,g,h,i)
+#else
+#define IDirectXVideoAccelerationService_QueryInterface(p,a,b)	(p)->QueryInterface(a,b)
+#define IDirectXVideoAccelerationService_AddRef(p)	(p)->AddRef()
+#define IDirectXVideoAccelerationService_Release(p)	(p)->Release()
+#define IDirectXVideoAccelerationService_CreateSurface(p,a,b,c,d,e,f,g,h,i)	(p)->CreateSurface(a,b,c,d,e,f,g,h,i)
+#endif
+
+#undef INTERFACE
+#define INTERFACE IDirectXVideoDecoderService
+DECLARE_INTERFACE_(IDirectXVideoDecoderService,IDirectXVideoAccelerationService)
+{
+    STDMETHOD(QueryInterface)(THIS_ REFIID,PVOID*) PURE;
+	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+	STDMETHOD_(ULONG,Release)(THIS) PURE;
+    STDMETHOD(CreateSurface)(THIS_ UINT,UINT,UINT,D3DFORMAT,D3DPOOL,DWORD,DWORD,IDirect3DSurface9**,HANDLE*) PURE;
+    STDMETHOD(GetDecoderDeviceGuids)(THIS_ UINT*,GUID **) PURE;
+    STDMETHOD(GetDecoderRenderTargets)(THIS_ REFGUID,UINT*,D3DFORMAT**) PURE;
+    STDMETHOD(GetDecoderConfigurations)(THIS_ REFGUID,const DXVA2_VideoDesc*,IUnknown*,UINT*,DXVA2_ConfigPictureDecode**) PURE;
+    STDMETHOD(CreateVideoDecoder)(THIS_ REFGUID,const DXVA2_VideoDesc*,DXVA2_ConfigPictureDecode*,IDirect3DSurface9**,UINT,IDirectXVideoDecoder**) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirectXVideoDecoderService_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirectXVideoDecoderService_AddRef(p)	(p)->lpVtbl->AddRef(p)
+#define IDirectXVideoDecoderService_Release(p)	(p)->lpVtbl->Release(p)
+#define IDirectXVideoDecoderService_CreateSurface(p,a,b,c,d,e,f,g,h,i)	(p)->lpVtbl->CreateSurface(p,a,b,c,d,e,f,g,h,i)
+#define IDirectXVideoDecoderService_CreateVideoDecoder(p,a,b,c,d,e,f)	(p)->lpVtbl->CreateVideoDecoder(p,a,b,c,d,e,f)
+#define IDirectXVideoDecoderService_GetDecoderConfigurations(p,a,b,c,d,e)	(p)->lpVtbl->GetDecoderConfigurations(p,a,b,c,d,e)
+#define IDirectXVideoDecoderService_GetDecoderDeviceGuids(p,a,b)	(p)->lpVtbl->GetDecoderDeviceGuids(p,a,b)
+#define IDirectXVideoDecoderService_GetDecoderRenderTargets(p,a,b,c)	(p)->lpVtbl->GetDecoderRenderTargets(p,a,b,c)
+#else
+#define IDirectXVideoDecoderService_QueryInterface(p,a,b)	(p)->QueryInterface(a,b)
+#define IDirectXVideoDecoderService_AddRef(p)	(p)->AddRef()
+#define IDirectXVideoDecoderService_Release(p)	(p)->Release()
+#define IDirectXVideoDecoderService_CreateSurface(p,a,b,c,d,e,f,g,h,i)	(p)->CreateSurface(a,b,c,d,e,f,g,h,i)
+#define IDirectXVideoDecoderService_CreateVideoDecoder(p,a,b,c,d,e,f)	(p)->CreateVideoDecoder(a,b,c,d,e,f)
+#define IDirectXVideoDecoderService_GetDecoderConfigurations(p,a,b,c,d,e)	(p)->GetDecoderConfigurations(a,b,c,d,e)
+#define IDirectXVideoDecoderService_GetDecoderDeviceGuids(p,a,b)	(p)->GetDecoderDeviceGuids(a,b)
+#define IDirectXVideoDecoderService_GetDecoderRenderTargets(p,a,b,c)	(p)->GetDecoderRenderTargets(a,b,c)
+#endif
+
+#undef INTERFACE
+#define INTERFACE IDirect3DDeviceManager9
+DECLARE_INTERFACE_(IDirect3DDeviceManager9,IUnknown)
+{
+    STDMETHOD(QueryInterface)(THIS_ REFIID,PVOID*) PURE;
+	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
+	STDMETHOD_(ULONG,Release)(THIS) PURE;
+    STDMETHOD(ResetDevice)(THIS_ IDirect3DDevice9*,UINT) PURE;
+    STDMETHOD(OpenDeviceHandle)(THIS_ HANDLE*) PURE;
+    STDMETHOD(CloseDeviceHandle)( THIS_ HANDLE) PURE;
+    STDMETHOD(TestDevice)( THIS_ HANDLE) PURE;
+    STDMETHOD(LockDevice)( THIS_ HANDLE,IDirect3DDevice9**,BOOL) PURE;
+    STDMETHOD(UnlockDevice)( THIS_ HANDLE,BOOL) PURE;
+    STDMETHOD(GetVideoService)( THIS_ HANDLE,REFIID,void**) PURE;
+};
+
+#if !defined(__cplusplus) || defined(CINTERFACE)
+#define IDirect3DDeviceManager9_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
+#define IDirect3DDeviceManager9_AddRef(p)	(p)->lpVtbl->AddRef(p)
+#define IDirect3DDeviceManager9_Release(p)	(p)->lpVtbl->Release(p)
+#define IDirect3DDeviceManager9_ResetDevice(p,a,b) (p)->lpVtbl->ResetDevice(p,a,b)
+#define IDirect3DDeviceManager9_OpenDeviceHandle(p,a) (p)->lpVtbl->OpenDeviceHandle(p,a)
+#define IDirect3DDeviceManager9_CloseDeviceHandle(p,a) (p)->lpVtbl->CloseDeviceHandle(p,a)
+#define IDirect3DDeviceManager9_TestDevice(p,a) (p)->lpVtbl->TestDevice(p,a)
+#define IDirect3DDeviceManager9_LockDevice(p,a,b,c) (p)->lpVtbl->LockDevice(p,a,b,c)
+#define IDirect3DDeviceManager9_UnlockDevice(p,a,b) (p)->lpVtbl->UnlockDevice(p,a,b)
+#define IDirect3DDeviceManager9_GetVideoService(p,a,b,c) (p)->lpVtbl->GetVideoService(p,a,b,c)
+#else
+#define IDirect3DDeviceManager9_QueryInterface(p,a,b)	(p)->QueryInterface(a,b)
+#define IDirect3DDeviceManager9_AddRef(p)	(p)->AddRef()
+#define IDirect3DDeviceManager9_Release(p)	(p)->Release()
+#define IDirect3DDeviceManager9_ResetDevice(p,a,b) (p)->ResetDevice(a,b)
+#define IDirect3DDeviceManager9_OpenDeviceHandle(p,a) (p)->OpenDeviceHandle(a)
+#define IDirect3DDeviceManager9_CloseDeviceHandle(p,a) (p)->CloseDeviceHandle(a)
+#define IDirect3DDeviceManager9_TestDevice(p,a) (p)->TestDevice(a)
+#define IDirect3DDeviceManager9_LockDevice(p,a,b,c) (p)->LockDevice(a,b,c)
+#define IDirect3DDeviceManager9_UnlockDevice(p,a,b) (p)->UnlockDevice(a,b)
+#define IDirect3DDeviceManager9_GetVideoService(p,a,b,c) (p)->GetVideoService(a,b,c)
+#endif
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif //_DXVA2API_H
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-dll-symbols/DllAvFormat.c xbmc-13.2rc1-Gotham/lib/xbmc-dll-symbols/DllAvFormat.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-dll-symbols/DllAvFormat.c	2014-08-13 18:26:32.360634228 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-dll-symbols/DllAvFormat.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,126 +0,0 @@
-/*
- * various utility functions used within FFmpeg
- * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/* Functions defined here are functions that cannot be resolved through the
- * ffmpeg shared libraries, yet are used in XBMC.
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#if (defined USE_EXTERNAL_FFMPEG)
-#include <libavformat/avformat.h>
-
-/* Taken from libavformat/utils.c */
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(54,0,0)
-static void flush_packet_queue(AVFormatContext *s)
-{
-    AVPacketList *pktl;
-
-    for(;;) {
-        pktl = s->packet_buffer;
-        if (!pktl)
-            break;
-        s->packet_buffer = pktl->next;
-        av_free_packet(&pktl->pkt);
-        av_free(pktl);
-    }
-    while(s->raw_packet_buffer){
-        pktl = s->raw_packet_buffer;
-        s->raw_packet_buffer = pktl->next;
-        av_free_packet(&pktl->pkt);
-        av_free(pktl);
-    }
-    s->packet_buffer_end=
-    s->raw_packet_buffer_end= NULL;
-#ifdef RAW_PACKET_BUFFER_SIZE
-    // Added on: 2009-06-25
-    s->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
-#endif
-}
-#else
-static void free_packet_buffer(AVPacketList **pkt_buf, AVPacketList **pkt_buf_end)
-{
-    while (*pkt_buf) {
-        AVPacketList *pktl = *pkt_buf;
-        *pkt_buf = pktl->next;
-        av_free_packet(&pktl->pkt);
-        av_freep(&pktl);
-    }
-    *pkt_buf_end = NULL;
-}
-/* XXX: suppress the packet queue */
-static void flush_packet_queue(AVFormatContext *s)
-{
-    free_packet_buffer(&s->parse_queue,       &s->parse_queue_end);
-    free_packet_buffer(&s->packet_buffer,     &s->packet_buffer_end);
-    free_packet_buffer(&s->raw_packet_buffer, &s->raw_packet_buffer_end);
-
-    s->raw_packet_buffer_remaining_size = RAW_PACKET_BUFFER_SIZE;
-}
-#endif
-
-/* Taken from libavformat/utils.c
- * Original name is ff_read_frame_flush
- * */
-void xbmc_read_frame_flush(AVFormatContext *s)
-{
-    AVStream *st;
-    int i, j;
-
-    flush_packet_queue(s);
-
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(54,0,0)
-    s->cur_st = NULL;
-#endif
-
-    /* for each stream, reset read state */
-    for(i = 0; i < s->nb_streams; i++) {
-        st = s->streams[i];
-
-        if (st->parser) {
-            av_parser_close(st->parser);
-            st->parser = NULL;
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(54,0,0)
-            av_free_packet(&st->cur_pkt);
-#endif
-        }
-        st->last_IP_pts = AV_NOPTS_VALUE;
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(54,0,0)
-        st->cur_dts = AV_NOPTS_VALUE; /* we set the current DTS to an unspecified origin */
-        st->reference_dts = AV_NOPTS_VALUE;
-        /* fail safe */
-        st->cur_ptr = NULL;
-        st->cur_len = 0;
-#else
-#define RELATIVE_TS_BASE (INT64_MAX - (1LL<<48))
-        if(st->first_dts == AV_NOPTS_VALUE) st->cur_dts = RELATIVE_TS_BASE;
-        else                                st->cur_dts = AV_NOPTS_VALUE; /* we set the current DTS to an unspecified origin */
-#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(55,0,0)
-        st->reference_dts = AV_NOPTS_VALUE;
-#endif
-
-        st->probe_packets = MAX_PROBE_PACKETS;
-#endif
-
-        for(j=0; j<MAX_REORDER_DELAY+1; j++)
-            st->pts_buffer[j]= AV_NOPTS_VALUE;
-    }
-}
-#endif /* (defined USE_EXTERNAL_FFMPEG) */
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-dll-symbols/Makefile xbmc-13.2rc1-Gotham/lib/xbmc-dll-symbols/Makefile
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-dll-symbols/Makefile	2014-08-13 18:26:32.364634243 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-dll-symbols/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1,6 +0,0 @@
-SRCS = DllAvFormat.c
-
-LIB = dll-symbols.a
-
-include ../../Makefile.include
--include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/accessors.c xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/accessors.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/accessors.c	2014-08-13 18:26:30.908627027 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/accessors.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,35 +0,0 @@
-/*
- *      Copyright (C) 2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#include "libav_hacks.h"
-
-AVDictionary *av_frame_get_metadata (const AVFrame *frame)
-{
-    return NULL;
-}
-
-AVRational av_stream_get_r_frame_rate(const AVStream *s)
-{
-    AVRational zero;
-    zero.num = 0;
-    zero.den = 1;
-    return zero;
-}
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/alloc_output_context2.c xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/alloc_output_context2.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/alloc_output_context2.c	2014-08-13 18:26:30.912627042 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/alloc_output_context2.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
-/*
- * Code copied from libavformat/mux.c
- *
- * Original license is:
- *
- * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libav_hacks.h"
-
-#include <libavutil/avstring.h>
-
-int avformat_alloc_output_context2(AVFormatContext **avctx, AVOutputFormat *oformat,
-                                   const char *format, const char *filename)
-{
-    AVFormatContext *s = avformat_alloc_context();
-    int ret = 0;
-
-    *avctx = NULL;
-    if (!s)
-        goto nomem;
-
-    if (!oformat) {
-        if (format) {
-            oformat = av_guess_format(format, NULL, NULL);
-            if (!oformat) {
-                av_log(s, AV_LOG_ERROR, "Requested output format '%s' is not a suitable output format\n", format);
-                ret = AVERROR(EINVAL);
-                goto error;
-            }
-        } else {
-            oformat = av_guess_format(NULL, filename, NULL);
-            if (!oformat) {
-                ret = AVERROR(EINVAL);
-                av_log(s, AV_LOG_ERROR, "Unable to find a suitable output format for '%s'\n",
-                       filename);
-                goto error;
-            }
-        }
-    }
-
-    s->oformat = oformat;
-    if (s->oformat->priv_data_size > 0) {
-        s->priv_data = av_mallocz(s->oformat->priv_data_size);
-        if (!s->priv_data)
-            goto nomem;
-        if (s->oformat->priv_class) {
-            *(const AVClass**)s->priv_data= s->oformat->priv_class;
-            av_opt_set_defaults(s->priv_data);
-        }
-    } else
-        s->priv_data = NULL;
-
-    if (filename)
-        av_strlcpy(s->filename, filename, sizeof(s->filename));
-    *avctx = s;
-    return 0;
-nomem:
-    av_log(s, AV_LOG_ERROR, "Out of memory\n");
-    ret = AVERROR(ENOMEM);
-error:
-    avformat_free_context(s);
-    return ret;
-}
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/buffersink.c xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/buffersink.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/buffersink.c	2014-08-13 18:26:30.924627107 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/buffersink.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-/*
- * Code copied from libavfilter/buffersink.c
- *
- * Original license is:
- *
- * Copyright (c) 2011 Stefano Sabatini
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libav_hacks.h"
-
-AVBufferSinkParams *av_buffersink_params_alloc(void)
-{
-    static const int pixel_fmts[] = { AV_PIX_FMT_NONE };
-    AVBufferSinkParams *params = av_malloc(sizeof(AVBufferSinkParams));
-    if (!params)
-        return NULL;
-
-    params->pixel_fmts = pixel_fmts;
-    return params;
-}
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/graphparser.c xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/graphparser.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/graphparser.c	2014-08-13 18:26:30.888626923 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/graphparser.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,451 +0,0 @@
-/*
- * Copied code from libavfilter/graphparser.c
- *
- * Original license is:
- *
- * filter graph parser
- * Copyright (c) 2008 Vitor Sessak
- * Copyright (c) 2007 Bobby Bingham
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-#include "libav_hacks.h"
-
-#include <libavutil/avstring.h>
-#include <libavutil/mem.h>
-
-#define WHITESPACES " \n\t"
-
-/**
- * Link two filters together.
- *
- * @see avfilter_link()
- */
-static int link_filter(AVFilterContext *src, int srcpad,
-                       AVFilterContext *dst, int dstpad,
-                       void *log_ctx)
-{
-    int ret;
-    if ((ret = avfilter_link(src, srcpad, dst, dstpad))) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Cannot create the link %s:%d -> %s:%d\n",
-               src->filter->name, srcpad, dst->filter->name, dstpad);
-        return ret;
-    }
-
-    return 0;
-}
-
-/**
- * Parse the name of a link, which has the format "[linkname]".
- *
- * @return a pointer (that need to be freed after use) to the name
- * between parenthesis
- */
-static char *parse_link_name(const char **buf, void *log_ctx)
-{
-    const char *start = *buf;
-    char *name;
-    (*buf)++;
-
-    name = av_get_token(buf, "]");
-
-    if (!name[0]) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Bad (empty?) label found in the following: \"%s\".\n", start);
-        goto fail;
-    }
-
-    if (*(*buf)++ != ']') {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Mismatched '[' found in the following: \"%s\".\n", start);
-    fail:
-        av_freep(&name);
-    }
-
-    return name;
-}
-
-/**
- * Create an instance of a filter, initialize and insert it in the
- * filtergraph in *ctx.
- *
- * @param filt_ctx put here a filter context in case of successful creation and configuration, NULL otherwise.
- * @param ctx the filtergraph context
- * @param index an index which is supposed to be unique for each filter instance added to the filtergraph
- * @param filt_name the name of the filter to create
- * @param args the arguments provided to the filter during its initialization
- * @param log_ctx the log context to use
- * @return 0 in case of success, a negative AVERROR code otherwise
- */
-static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,
-                         const char *filt_name, const char *args, void *log_ctx)
-{
-    AVFilter *filt;
-    char inst_name[30];
-    char tmp_args[256];
-    int ret;
-
-    snprintf(inst_name, sizeof(inst_name), "Parsed_%s_%d", filt_name, index);
-
-    filt = avfilter_get_by_name(filt_name);
-
-    if (!filt) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "No such filter: '%s'\n", filt_name);
-        return AVERROR(EINVAL);
-    }
-
-    *filt_ctx = avfilter_graph_alloc_filter(ctx, filt, inst_name);
-    if (!*filt_ctx) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Error creating filter '%s'\n", filt_name);
-        return AVERROR(ENOMEM);
-    }
-
-    if (!strcmp(filt_name, "scale") && args && !strstr(args, "flags") &&
-        ctx->scale_sws_opts) {
-        snprintf(tmp_args, sizeof(tmp_args), "%s:%s",
-                 args, ctx->scale_sws_opts);
-        args = tmp_args;
-    }
-
-    ret = avfilter_init_str(*filt_ctx, args);
-    if (ret < 0) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Error initializing filter '%s'", filt_name);
-        if (args)
-            av_log(log_ctx, AV_LOG_ERROR, " with args '%s'", args);
-        av_log(log_ctx, AV_LOG_ERROR, "\n");
-        return ret;
-    }
-
-    return 0;
-}
-
-/**
- * Parse a string of the form FILTER_NAME[=PARAMS], and create a
- * corresponding filter instance which is added to graph with
- * create_filter().
- *
- * @param filt_ctx Pointer that is set to the created and configured filter
- *                 context on success, set to NULL on failure.
- * @param filt_ctx put here a pointer to the created filter context on
- * success, NULL otherwise
- * @param buf pointer to the buffer to parse, *buf will be updated to
- * point to the char next after the parsed string
- * @param index an index which is assigned to the created filter
- * instance, and which is supposed to be unique for each filter
- * instance added to the filtergraph
- * @return 0 in case of success, a negative AVERROR code otherwise
- */
-static int parse_filter(AVFilterContext **filt_ctx, const char **buf, AVFilterGraph *graph,
-                        int index, void *log_ctx)
-{
-    char *opts = NULL;
-    char *name = av_get_token(buf, "=,;[\n");
-    int ret;
-
-    if (**buf == '=') {
-        (*buf)++;
-        opts = av_get_token(buf, "[],;\n");
-    }
-
-    ret = create_filter(filt_ctx, graph, index, name, opts, log_ctx);
-    av_free(name);
-    av_free(opts);
-    return ret;
-}
-
-static AVFilterInOut *extract_inout(const char *label, AVFilterInOut **links)
-{
-    AVFilterInOut *ret;
-
-    while (*links && (!(*links)->name || strcmp((*links)->name, label)))
-        links = &((*links)->next);
-
-    ret = *links;
-
-    if (ret) {
-        *links = ret->next;
-        ret->next = NULL;
-    }
-
-    return ret;
-}
-
-static void insert_inout(AVFilterInOut **inouts, AVFilterInOut *element)
-{
-    element->next = *inouts;
-    *inouts = element;
-}
-
-static void append_inout(AVFilterInOut **inouts, AVFilterInOut **element)
-{
-    while (*inouts && (*inouts)->next)
-        inouts = &((*inouts)->next);
-
-    if (!*inouts)
-        *inouts = *element;
-    else
-        (*inouts)->next = *element;
-    *element = NULL;
-}
-
-static int link_filter_inouts(AVFilterContext *filt_ctx,
-                              AVFilterInOut **curr_inputs,
-                              AVFilterInOut **open_inputs, void *log_ctx)
-{
-    int pad, ret;
-
-    for (pad = 0; pad < filt_ctx->nb_inputs; pad++) {
-        AVFilterInOut *p = *curr_inputs;
-
-        if (p) {
-            *curr_inputs = (*curr_inputs)->next;
-            p->next = NULL;
-        } else if (!(p = av_mallocz(sizeof(*p))))
-            return AVERROR(ENOMEM);
-
-        if (p->filter_ctx) {
-            ret = link_filter(p->filter_ctx, p->pad_idx, filt_ctx, pad, log_ctx);
-            av_free(p->name);
-            av_free(p);
-            if (ret < 0)
-                return ret;
-        } else {
-            p->filter_ctx = filt_ctx;
-            p->pad_idx = pad;
-            append_inout(open_inputs, &p);
-        }
-    }
-
-    if (*curr_inputs) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Too many inputs specified for the \"%s\" filter.\n",
-               filt_ctx->filter->name);
-        return AVERROR(EINVAL);
-    }
-
-    pad = filt_ctx->nb_outputs;
-    while (pad--) {
-        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));
-        if (!currlinkn)
-            return AVERROR(ENOMEM);
-        currlinkn->filter_ctx  = filt_ctx;
-        currlinkn->pad_idx = pad;
-        insert_inout(curr_inputs, currlinkn);
-    }
-
-    return 0;
-}
-
-static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,
-                        AVFilterInOut **open_outputs, void *log_ctx)
-{
-    AVFilterInOut *parsed_inputs = NULL;
-    int pad = 0;
-
-    while (**buf == '[') {
-        char *name = parse_link_name(buf, log_ctx);
-        AVFilterInOut *match;
-
-        if (!name)
-            return AVERROR(EINVAL);
-
-        /* First check if the label is not in the open_outputs list */
-        match = extract_inout(name, open_outputs);
-
-        if (match) {
-            av_free(name);
-        } else {
-            /* Not in the list, so add it as an input */
-            if (!(match = av_mallocz(sizeof(AVFilterInOut)))) {
-                av_free(name);
-                return AVERROR(ENOMEM);
-            }
-            match->name    = name;
-            match->pad_idx = pad;
-        }
-
-        append_inout(&parsed_inputs, &match);
-
-        *buf += strspn(*buf, WHITESPACES);
-        pad++;
-    }
-
-    append_inout(&parsed_inputs, curr_inputs);
-    *curr_inputs = parsed_inputs;
-
-    return pad;
-}
-
-static int parse_outputs(const char **buf, AVFilterInOut **curr_inputs,
-                         AVFilterInOut **open_inputs,
-                         AVFilterInOut **open_outputs, void *log_ctx)
-{
-    int ret, pad = 0;
-
-    while (**buf == '[') {
-        char *name = parse_link_name(buf, log_ctx);
-        AVFilterInOut *match;
-
-        AVFilterInOut *input = *curr_inputs;
-
-        if (!name)
-            return AVERROR(EINVAL);
-
-        if (!input) {
-            av_log(log_ctx, AV_LOG_ERROR,
-                   "No output pad can be associated to link label '%s'.\n", name);
-            av_free(name);
-            return AVERROR(EINVAL);
-        }
-        *curr_inputs = (*curr_inputs)->next;
-
-        /* First check if the label is not in the open_inputs list */
-        match = extract_inout(name, open_inputs);
-
-        if (match) {
-            if ((ret = link_filter(input->filter_ctx, input->pad_idx,
-                                   match->filter_ctx, match->pad_idx, log_ctx)) < 0) {
-                av_free(name);
-                return ret;
-            }
-            av_free(match->name);
-            av_free(name);
-            av_free(match);
-            av_free(input);
-        } else {
-            /* Not in the list, so add the first input as a open_output */
-            input->name = name;
-            insert_inout(open_outputs, input);
-        }
-        *buf += strspn(*buf, WHITESPACES);
-        pad++;
-    }
-
-    return pad;
-}
-
-static int parse_sws_flags(const char **buf, AVFilterGraph *graph)
-{
-    char *p = strchr(*buf, ';');
-
-    if (strncmp(*buf, "sws_flags=", 10))
-        return 0;
-
-    if (!p) {
-        av_log(graph, AV_LOG_ERROR, "sws_flags not terminated with ';'.\n");
-        return AVERROR(EINVAL);
-    }
-
-    *buf += 4;  // keep the 'flags=' part
-
-    av_freep(&graph->scale_sws_opts);
-    if (!(graph->scale_sws_opts = av_mallocz(p - *buf + 1)))
-        return AVERROR(ENOMEM);
-    av_strlcpy(graph->scale_sws_opts, *buf, p - *buf + 1);
-
-    *buf = p + 1;
-    return 0;
-}
-
-int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters,
-                         AVFilterInOut **open_inputs_ptr, AVFilterInOut **open_outputs_ptr,
-                         void *log_ctx)
-{
-    int index = 0, ret = 0;
-    char chr = 0;
-
-    AVFilterInOut *curr_inputs = NULL;
-    AVFilterInOut *open_inputs  = open_inputs_ptr  ? *open_inputs_ptr  : NULL;
-    AVFilterInOut *open_outputs = open_outputs_ptr ? *open_outputs_ptr : NULL;
-
-    if ((ret = parse_sws_flags(&filters, graph)) < 0)
-        goto end;
-
-    do {
-        AVFilterContext *filter;
-        const char *filterchain = filters;
-        filters += strspn(filters, WHITESPACES);
-
-        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)
-            goto end;
-
-        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)
-            goto end;
-
-        if (filter->input_count == 1 && !curr_inputs && !index) {
-            /* First input pad, assume it is "[in]" if not specified */
-            const char *tmp = "[in]";
-            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)
-                goto end;
-        }
-
-        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)
-            goto end;
-
-        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,
-                                 log_ctx)) < 0)
-            goto end;
-
-        filters += strspn(filters, WHITESPACES);
-        chr = *filters++;
-
-        if (chr == ';' && curr_inputs) {
-            av_log(log_ctx, AV_LOG_ERROR,
-                   "Invalid filterchain containing an unlabelled output pad: \"%s\"\n",
-                   filterchain);
-            ret = AVERROR(EINVAL);
-            goto end;
-        }
-        index++;
-    } while (chr == ',' || chr == ';');
-
-    if (chr) {
-        av_log(log_ctx, AV_LOG_ERROR,
-               "Unable to parse graph description substring: \"%s\"\n",
-               filters - 1);
-        ret = AVERROR(EINVAL);
-        goto end;
-    }
-
-    if (curr_inputs) {
-        /* Last output pad, assume it is "[out]" if not specified */
-        const char *tmp = "[out]";
-        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,
-                                 log_ctx)) < 0)
-            goto end;
-    }
-
-end:
-    /* clear open_in/outputs only if not passed as parameters */
-    if (open_inputs_ptr) *open_inputs_ptr = open_inputs;
-    else avfilter_inout_free(&open_inputs);
-    if (open_outputs_ptr) *open_outputs_ptr = open_outputs;
-    else avfilter_inout_free(&open_outputs);
-    avfilter_inout_free(&curr_inputs);
-
-    if (ret < 0) {
-        while (graph->nb_filters)
-            avfilter_free(graph->filters[0]);
-        av_freep(&graph->filters);
-    }
-    return ret;
-}
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/libav_hacks.h xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/libav_hacks.h
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/libav_hacks.h	2014-08-13 18:26:30.912627042 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/libav_hacks.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,96 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#ifndef __LIBAV_HACKS_H
-#define __LIBAV_HACKS_H
-
-#include <libavutil/avutil.h>
-#include <libavutil/opt.h>
-#include <libavresample/avresample.h>
-#include <libavformat/avformat.h>
-#include <libavfilter/avfilter.h>
-
-#if LIBAVUTIL_VERSION_MICRO >= 100
-#error "You should not enable libav hacks when building against FFmpeg."
-#endif
-
-#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,8,0)
-#error "Your libav version is too old. Please update to libav-10 or git master."
-#endif
-
-// libavutil
-
-#define AVFRAME_IN_LAVU
-
-#define AV_CODEC_ID_OTF AV_CODEC_ID_TTF
-#define AV_CODEC_ID_SUBRIP  AV_CODEC_ID_FIRST_SUBTITLE
-
-AVDictionary *av_frame_get_metadata       (const AVFrame *frame);
-
-// libavformat
-
-int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat,
-                const char *format_name, const char *filename);
-
-#define AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE
-
-AVRational av_stream_get_r_frame_rate(const AVStream *s);
-
-// libavresample
-
-#define SwrContext AVAudioResampleContext
-
-struct SwrContext *swr_alloc_set_opts(struct SwrContext *s,
-                int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
-                int64_t  in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
-                int log_offset, void *log_ctx);
-
-int swr_init(struct SwrContext *s);
-
-void swr_free(struct SwrContext **s);
-
-int swr_convert(struct SwrContext *s, uint8_t **out, int out_count,
-                const uint8_t **in , int in_count);
-
-int64_t swr_get_delay(struct SwrContext *s, int64_t base);
-
-int swr_set_channel_mapping(struct SwrContext *s, const int *channel_map);
-
-int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride);
-
-int swr_set_compensation(struct SwrContext *s, int sample_delta, int compensation_distance);
-
-// libavfilter
-
-#define LIBAVFILTER_AVFRAME_BASED
-
-typedef struct {
-    const enum AVPixelFormat *pixel_fmts; ///< list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
-} AVBufferSinkParams;
-
-AVBufferSinkParams *av_buffersink_params_alloc(void);
-
-#define HAVE_AVFILTER_GRAPH_PARSE_PTR
-
-int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters,
-                             AVFilterInOut **inputs, AVFilterInOut **outputs,
-                             void *log_ctx);
-
-#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/Makefile xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/Makefile
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/Makefile	2014-08-13 18:26:30.912627042 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/Makefile	1970-01-01 08:00:00.000000000 +0800
@@ -1,6 +0,0 @@
-SRCS = swresample.c alloc_output_context2.c buffersink.c accessors.c graphparser.c
-
-LIB = dll-libavhacks.a
-
-include ../../Makefile.include
--include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/pkgconfig/libswresample.pc xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/pkgconfig/libswresample.pc
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/pkgconfig/libswresample.pc	2014-08-13 18:26:30.912627042 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/pkgconfig/libswresample.pc	1970-01-01 08:00:00.000000000 +0800
@@ -1,4 +0,0 @@
-Name: libswresample to libavresample
-Version: 0
-Description: Hack to provide libswresample through libavresample
-Requires: libavresample
diff -uNr xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/swresample.c xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/swresample.c
--- xbmc-13.2rc1-Gotham.orig/lib/xbmc-libav-hacks/swresample.c	2014-08-13 18:26:30.924627107 +0800
+++ xbmc-13.2rc1-Gotham/lib/xbmc-libav-hacks/swresample.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,80 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "libav_hacks.h"
-
-#include <libavutil/mathematics.h>
-#include <libavutil/opt.h>
-
-struct SwrContext *swr_alloc_set_opts(struct SwrContext *s,
-                int64_t out_ch_layout, enum AVSampleFormat out_sample_fmt, int out_sample_rate,
-                int64_t  in_ch_layout, enum AVSampleFormat  in_sample_fmt, int  in_sample_rate,
-                int log_offset, void *log_ctx)
-{
-    AVAudioResampleContext *ret = avresample_alloc_context();
-    av_opt_set_int(ret, "out_channel_layout", out_ch_layout  , 0);
-    av_opt_set_int(ret, "out_sample_fmt"    , out_sample_fmt , 0);
-    av_opt_set_int(ret, "out_sample_rate"   , out_sample_rate, 0);
-    av_opt_set_int(ret, "in_channel_layout" , in_ch_layout   , 0);
-    av_opt_set_int(ret, "in_sample_fmt"     , in_sample_fmt  , 0);
-    av_opt_set_int(ret, "in_sample_rate"    , in_sample_rate , 0);
-    return ret;
-}
-
-
-int swr_init(struct SwrContext *s)
-{
-    return avresample_open(s);
-}
-
-void swr_free(struct SwrContext **s)
-{
-    avresample_close(*s);
-    *s = NULL;
-}
-
-int swr_convert(struct SwrContext *s, uint8_t **out, int out_count,
-                const uint8_t **in , int in_count)
-{
-    return avresample_convert(s, out, 0, out_count, (uint8_t**)in, 0,in_count);
-}
-
-int64_t swr_get_delay(struct SwrContext *s, int64_t base)
-{
-    int64_t in_sr, out_sr;
-    av_opt_get_int(s, "in_sample_rate", 0, &in_sr);
-    av_opt_get_int(s, "out_sample_rate", 0, &out_sr);
-    return av_rescale_rnd(avresample_available(s), base, out_sr, AV_ROUND_UP) + av_rescale_rnd(avresample_get_delay(s), base, in_sr, AV_ROUND_UP);
-}
-
-int swr_set_channel_mapping(struct SwrContext *s, const int *channel_map)
-{
-    return avresample_set_channel_mapping(s, channel_map);
-}
-
-int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride)
-{
-    return avresample_set_matrix(s, matrix, stride);
-}
-
-int swr_set_compensation(struct SwrContext *s, int sample_delta, int compensation_distance)
-{
-    return avresample_set_compensation(s, sample_delta, compensation_distance);
-}
diff -uNr xbmc-13.2rc1-Gotham.orig/m4/ax_append_compile_flags.m4 xbmc-13.2rc1-Gotham/m4/ax_append_compile_flags.m4
--- xbmc-13.2rc1-Gotham.orig/m4/ax_append_compile_flags.m4	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/m4/ax_append_compile_flags.m4	2014-08-13 18:27:01.108776783 +0800
@@ -0,0 +1,100 @@
+# ===========================================================================
+#  http://www.gnu.org/software/autoconf-archive/ax_append_compile_flags.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_COMPILE_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS])
+#
+# DESCRIPTION
+#
+#   For every FLAG1, FLAG2 it is checked whether the compiler works with the
+#   flag.  If it does, the flag is added FLAGS-VARIABLE
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  During the check the flag is always added to the
+#   current language's flags.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   NOTE: This macro depends on the AX_APPEND_FLAG and
+#   AX_CHECK_COMPILE_FLAG. Please keep this macro in sync with
+#   AX_APPEND_LINK_FLAGS.
+#
+# LICENSE
+#
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 4
+
+AC_DEFUN([AX_APPEND_COMPILE_FLAGS],
+[AX_REQUIRE_DEFINED([AX_CHECK_COMPILE_FLAG])
+AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
+for flag in $1; do
+  AX_CHECK_COMPILE_FLAG([$flag], [AX_APPEND_FLAG([$flag], [$2])], [], [$3])
+done
+])dnl AX_APPEND_COMPILE_FLAGS
+
+
+AC_DEFUN([AX_APPEND_FLAG],
+[AC_PREREQ(2.59)dnl for _AC_LANG_PREFIX
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])dnl
+AS_VAR_SET_IF(FLAGS,
+  [case " AS_VAR_GET(FLAGS) " in
+    *" $1 "*)
+      AC_RUN_LOG([: FLAGS already contains $1])
+      ;;
+    *)
+      AC_RUN_LOG([: FLAGS="$FLAGS $1"])
+      AS_VAR_SET(FLAGS, ["AS_VAR_GET(FLAGS) $1"])
+      ;;
+   esac],
+  [AS_VAR_SET(FLAGS,["$1"])])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
+
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.59)dnl for _AC_LANG_PREFIX
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_IF([test x"AS_VAR_GET(CACHEVAR)" = xyes],
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
diff -uNr xbmc-13.2rc1-Gotham.orig/m4/ax_append_flag.m4 xbmc-13.2rc1-Gotham/m4/ax_append_flag.m4
--- xbmc-13.2rc1-Gotham.orig/m4/ax_append_flag.m4	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/m4/ax_append_flag.m4	2014-08-13 18:27:01.108776783 +0800
@@ -0,0 +1,69 @@
+# ===========================================================================
+#      http://www.gnu.org/software/autoconf-archive/ax_append_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
+#   added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 2
+
+AC_DEFUN([AX_APPEND_FLAG],
+[AC_PREREQ(2.59)dnl for _AC_LANG_PREFIX
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])dnl
+AS_VAR_SET_IF(FLAGS,
+  [case " AS_VAR_GET(FLAGS) " in
+    *" $1 "*)
+      AC_RUN_LOG([: FLAGS already contains $1])
+      ;;
+    *)
+      AC_RUN_LOG([: FLAGS="$FLAGS $1"])
+      AS_VAR_SET(FLAGS, ["AS_VAR_GET(FLAGS) $1"])
+      ;;
+   esac],
+  [AS_VAR_SET(FLAGS,["$1"])])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
diff -uNr xbmc-13.2rc1-Gotham.orig/m4/ax_check_compile_flag.m4 xbmc-13.2rc1-Gotham/m4/ax_check_compile_flag.m4
--- xbmc-13.2rc1-Gotham.orig/m4/ax_check_compile_flag.m4	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/m4/ax_check_compile_flag.m4	2014-08-13 18:27:01.108776783 +0800
@@ -0,0 +1,74 @@
+# ===========================================================================
+#   http://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the current language's compiler
+#   or gives an error.  (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 3
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.59)dnl for _AC_LANG_PREFIX
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_IF([test x"AS_VAR_GET(CACHEVAR)" = xyes],
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
diff -uNr xbmc-13.2rc1-Gotham.orig/m4/ax_require_defined.m4 xbmc-13.2rc1-Gotham/m4/ax_require_defined.m4
--- xbmc-13.2rc1-Gotham.orig/m4/ax_require_defined.m4	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/m4/ax_require_defined.m4	2014-08-13 18:27:01.108776783 +0800
@@ -0,0 +1,37 @@
+# ===========================================================================
+#    http://www.gnu.org/software/autoconf-archive/ax_require_defined.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_REQUIRE_DEFINED(MACRO)
+#
+# DESCRIPTION
+#
+#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
+#   been defined and thus are available for use.  This avoids random issues
+#   where a macro isn't expanded.  Instead the configure script emits a
+#   non-fatal:
+#
+#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
+#
+#   It's like AC_REQUIRE except it doesn't expand the required macro.
+#
+#   Here's an example:
+#
+#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 1
+
+AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
+  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
+])dnl AX_REQUIRE_DEFINED
diff -uNr xbmc-13.2rc1-Gotham.orig/Makefile.in xbmc-13.2rc1-Gotham/Makefile.in
--- xbmc-13.2rc1-Gotham.orig/Makefile.in	2014-08-13 18:26:50.592724636 +0800
+++ xbmc-13.2rc1-Gotham/Makefile.in	2014-08-13 18:27:01.700779715 +0800
@@ -35,7 +35,6 @@
                    lib/libXDAAP/libxdaap.a \
                    lib/libhts/libhts.a \
                    lib/libsquish/libsquish.a \
-                   lib/xbmc-dll-symbols/dll-symbols.a \
                    xbmc/addons/addons.a \
                    xbmc/cdrip/cdrip.a \
                    xbmc/cores/AudioEngine/audioengine.a \
@@ -187,10 +186,6 @@
 DIRECTORY_ARCHIVES += xbmc/cores/omxplayer/omxplayer.a
 endif
 
-ifeq (@USE_LIBAV_HACKS@,1)
-DIRECTORY_ARCHIVES += lib/xbmc-libav-hacks/dll-libavhacks.a
-endif
-
 PAPCODECS_DIRS= \
 	lib/nosefart \
 	lib/timidity \
@@ -317,6 +312,12 @@
 endif
 endif
 
+ifeq (@USE_SSE4@,1)
+LIBSSE4+=sse4
+sse4 : force
+	$(MAKE) -C xbmc/linux/sse4
+endif
+
 CHECK_PROGRAMS = xbmc-test
 
 CLEAN_FILES += $(CHECK_PROGRAMS) $(CHECK_EXTENSIONS)
@@ -394,7 +395,6 @@
 	$(MAKE) -C lib/addons/library.xbmc.gui
 	$(MAKE) -C lib/addons/library.xbmc.pvr
 dvdpcodecs: dllloader
-	$(MAKE) -C lib
 	$(MAKE) -C lib/libdvd
 
 ifeq (@USE_LIBSTAGEFRIGHT@,1)
@@ -445,7 +445,7 @@
 
 codecs: papcodecs dvdpcodecs dvdpextcodecs
 
-libs: libhdhomerun imagelib libexif system/libcpluff-@ARCH@.so $(CMYTH)
+libs: $(LIBSSE4) libhdhomerun imagelib libexif system/libcpluff-@ARCH@.so $(CMYTH)
 
 externals: codecs libs visualizations screensavers libaddon pvraddons
 
@@ -474,13 +474,13 @@
 endif
 
 ifeq (@USE_STATIC_FFMPEG@,1)
-FFMPEGOBJS = lib/ffmpeg/libavcodec/libavcodec.a \
-             lib/ffmpeg/libavfilter/libavfilter.a \
-             lib/ffmpeg/libswresample/libswresample.a \
-             lib/ffmpeg/libavformat/libavformat.a \
-             lib/ffmpeg/libavutil/libavutil.a \
-             lib/ffmpeg/libpostproc/libpostproc.a \
-             lib/ffmpeg/libswscale/libswscale.a
+FFMPEGOBJS = @FFMPEG_LIBDIR@/libavcodec.a \
+             @FFMPEG_LIBDIR@/libavfilter.a \
+             @FFMPEG_LIBDIR@/libswresample.a \
+             @FFMPEG_LIBDIR@/libavformat.a \
+             @FFMPEG_LIBDIR@/libavutil.a \
+             @FFMPEG_LIBDIR@/libpostproc.a \
+             @FFMPEG_LIBDIR@/libswscale.a
 DYNOBJSXBMC+= $(FFMPEGOBJS)
 LIBS+= @GNUTLS_ALL_LIBS@ @VORBISENC_ALL_LIBS@ @HOGWEED_ALL_LIBS@
 
diff -uNr xbmc-13.2rc1-Gotham.orig/Makefile.include.in xbmc-13.2rc1-Gotham/Makefile.include.in
--- xbmc-13.2rc1-Gotham.orig/Makefile.include.in	2014-08-13 18:26:12.548535984 +0800
+++ xbmc-13.2rc1-Gotham/Makefile.include.in	2014-08-13 18:27:00.392773228 +0800
@@ -44,9 +44,6 @@
 INCLUDES+=-I@abs_top_srcdir@/addons/library.xbmc.pvr
 INCLUDES+=-I@abs_top_srcdir@/addons/library.xbmc.codec
 INCLUDES+=$(sort @INCLUDES@)
-ifneq (@USE_EXTERNAL_FFMPEG@,1)
-	INCLUDES+=-I@abs_top_srcdir@/lib/ffmpeg
-endif
 INCLUDES+=-I@abs_top_srcdir@/xbmc/linux
 INCLUDES+=-I@abs_top_srcdir@/xbmc/cores/dvdplayer
 DEFINES+= \
diff -uNr xbmc-13.2rc1-Gotham.orig/project/VS2010Express/XBMC.vcxproj xbmc-13.2rc1-Gotham/project/VS2010Express/XBMC.vcxproj
--- xbmc-13.2rc1-Gotham.orig/project/VS2010Express/XBMC.vcxproj	2014-08-13 18:26:13.608541240 +0800
+++ xbmc-13.2rc1-Gotham/project/VS2010Express/XBMC.vcxproj	2014-08-13 18:27:00.848775490 +0800
@@ -142,7 +142,7 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug (DirectX)|Win32'">
     <ClCompile>
-      <AdditionalIncludeDirectories>..\..\;..\..\xbmc\;..\..\xbmc\cores\dvdplayer;..\..\xbmc\win32;..\..\lib;..\..\lib\ffmpeg;..\..\lib\ffmpeg\include-xbmc-win32;..\..\lib\libUPnP\Platinum\Source\Devices\MediaRenderer;..\..\lib\libUPnP\Platinum\Source\Devices\MediaConnect;..\..\lib\libUPnP\Platinum\Source\Devices\MediaServer;..\..\lib\libUPnP\Platinum\Source\Platinum;..\..\lib\libUPnP\Platinum\Source\Core;..\..\lib\libUPnP\Platinum\Source\Extras;..\..\lib\libUPnP\Neptune\Source\Core;..\..\lib\libUPnP\Neptune\Source\System\Win32;..\..\lib\win32\pcre;..\..\lib\win32;..\..\xbmc\cores\AudioEngine\;..\..\addons\library.xbmc.gui;..\..\addons\library.xbmc.addon;..\..\addons\library.xbmc.pvr;..\..\addons\library.xbmc.codec;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>..\..\;..\..\xbmc\;..\..\xbmc\cores\dvdplayer;..\..\xbmc\win32;..\..\lib;..\..\lib\win32\ffmpeg;..\..\lib\libUPnP\Platinum\Source\Devices\MediaRenderer;..\..\lib\libUPnP\Platinum\Source\Devices\MediaConnect;..\..\lib\libUPnP\Platinum\Source\Devices\MediaServer;..\..\lib\libUPnP\Platinum\Source\Platinum;..\..\lib\libUPnP\Platinum\Source\Core;..\..\lib\libUPnP\Platinum\Source\Extras;..\..\lib\libUPnP\Neptune\Source\Core;..\..\lib\libUPnP\Neptune\Source\System\Win32;..\..\lib\win32\pcre;..\..\lib\win32;..\..\xbmc\cores\AudioEngine\;..\..\addons\library.xbmc.gui;..\..\addons\library.xbmc.addon;..\..\addons\library.xbmc.pvr;..\..\addons\library.xbmc.codec;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>NOMINMAX;_USE_32BIT_TIME_T;HAS_DX;D3D_DEBUG_INFO;__STDC_CONSTANT_MACROS;_SECURE_SCL=0;TAGLIB_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <ExceptionHandling>Async</ExceptionHandling>
       <PrecompiledHeader>Use</PrecompiledHeader>
@@ -158,12 +158,13 @@
       <IgnoreSpecificDefaultLibraries>libc;msvcrt;libcmt;msvcrtd;msvcprtd;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
       <ModuleDefinitionFile>
       </ModuleDefinitionFile>
-      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;libmicrohttpd-5.dll;ssh.dll;sqlite3.dll;libsamplerate-0.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
+      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;libmicrohttpd-5.dll;ssh.dll;sqlite3.dll;libsamplerate-0.dll;avcodec-55.dll;avfilter-4.dll;avformat-55.dll;avutil-52.dll;postproc-52.dll;swresample-0.dll;swscale-2.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
       <ProgramDatabaseFile>$(OutDir)XBMC.pdb</ProgramDatabaseFile>
       <EntryPointSymbol>
       </EntryPointSymbol>
       <RandomizedBaseAddress>true</RandomizedBaseAddress>
       <DataExecutionPrevention>true</DataExecutionPrevention>
+      <AdditionalLibraryDirectories>..\..\lib\win32\ffmpeg\.libs;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
     </Link>
     <Manifest>
       <AdditionalManifestFiles>VC90.CRT.x86.manifest;win81.manifest;%(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -206,7 +207,7 @@
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release (DirectX)|Win32'">
     <ClCompile>
       <AdditionalOptions>/MP %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalIncludeDirectories>..\..\;..\..\xbmc\;..\..\xbmc\cores\dvdplayer;..\..\xbmc\win32;..\..\lib;..\..\lib\ffmpeg;..\..\lib\ffmpeg\include-xbmc-win32;..\..\lib\libUPnP\Platinum\Source\Devices\MediaRenderer;..\..\lib\libUPnP\Platinum\Source\Devices\MediaConnect;..\..\lib\libUPnP\Platinum\Source\Devices\MediaServer;..\..\lib\libUPnP\Platinum\Source\Platinum;..\..\lib\libUPnP\Platinum\Source\Core;..\..\lib\libUPnP\Platinum\Source\Extras;..\..\lib\libUPnP\Neptune\Source\Core;..\..\lib\libUPnP\Neptune\Source\System\Win32;..\..\lib\win32\pcre;..\..\lib\win32;..\..\xbmc\cores\AudioEngine\;..\..\addons\library.xbmc.gui;..\..\addons\library.xbmc.addon;..\..\addons\library.xbmc.pvr;..\..\addons\library.xbmc.codec;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>..\..\;..\..\xbmc\;..\..\xbmc\cores\dvdplayer;..\..\xbmc\win32;..\..\lib;..\..\lib\win32\ffmpeg;..\..\lib\libUPnP\Platinum\Source\Devices\MediaRenderer;..\..\lib\libUPnP\Platinum\Source\Devices\MediaConnect;..\..\lib\libUPnP\Platinum\Source\Devices\MediaServer;..\..\lib\libUPnP\Platinum\Source\Platinum;..\..\lib\libUPnP\Platinum\Source\Core;..\..\lib\libUPnP\Platinum\Source\Extras;..\..\lib\libUPnP\Neptune\Source\Core;..\..\lib\libUPnP\Neptune\Source\System\Win32;..\..\lib\win32\pcre;..\..\lib\win32;..\..\xbmc\cores\AudioEngine\;..\..\addons\library.xbmc.gui;..\..\addons\library.xbmc.addon;..\..\addons\library.xbmc.pvr;..\..\addons\library.xbmc.codec;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>NOMINMAX;_USE_32BIT_TIME_T;HAS_DX;__STDC_CONSTANT_MACROS;TAGLIB_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <ExceptionHandling>Async</ExceptionHandling>
       <PrecompiledHeader>Use</PrecompiledHeader>
@@ -220,11 +221,12 @@
       <AdditionalDependencies>D3dx9.lib;DInput8.lib;DSound.lib;winmm.lib;Mpr.lib;Iphlpapi.lib;PowrProf.lib;setupapi.lib;dwmapi.lib;yajl.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)XBMC.exe</OutputFile>
       <IgnoreSpecificDefaultLibraries>libc;msvcrt;libci;msvcprt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
-      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;libmicrohttpd-5.dll;ssh.dll;sqlite3.dll;libsamplerate-0.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
+      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;libmicrohttpd-5.dll;ssh.dll;sqlite3.dll;libsamplerate-0.dll;avcodec-55.dll;avfilter-4.dll;avformat-55.dll;avutil-52.dll;postproc-52.dll;swresample-0.dll;swscale-2.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <ProgramDatabaseFile>$(OutDir)XBMC.pdb</ProgramDatabaseFile>
       <RandomizedBaseAddress>true</RandomizedBaseAddress>
       <DataExecutionPrevention>true</DataExecutionPrevention>
+      <AdditionalLibraryDirectories>..\..\lib\win32\ffmpeg\.libs;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
     </Link>
     <Manifest>
       <AdditionalManifestFiles>VC90.CRT.x86.manifest;win81.manifest;%(AdditionalManifestFiles)</AdditionalManifestFiles>
@@ -323,6 +325,7 @@
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxPVRClient.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamBluray.cpp" />
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDInputStreams\DVDInputStreamPVRManager.cpp" />
+    <ClCompile Include="..\..\xbmc\cores\FFmpeg.cpp" />
     <ClCompile Include="..\..\xbmc\cores\paplayer\PCMCodec.cpp" />
     <ClCompile Include="..\..\xbmc\cores\VideoRenderers\OverlayRendererGUI.cpp" />
     <ClCompile Include="..\..\xbmc\cores\VideoRenderers\RenderCapture.cpp" />
@@ -994,6 +997,7 @@
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Audio\DVDAudioCodecPassthrough.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxBXA.h" />
     <ClInclude Include="..\..\xbmc\cores\dvdplayer\DVDDemuxers\DVDDemuxCDDA.h" />
+    <ClInclude Include="..\..\xbmc\cores\FFmpeg.h" />
     <ClInclude Include="..\..\xbmc\cores\paplayer\PCMCodec.h" />
     <ClInclude Include="..\..\xbmc\cores\VideoRenderers\OverlayRendererGUI.h" />
     <ClInclude Include="..\..\xbmc\dialogs\GUIDialogKeyboardGeneric.h" />
@@ -2911,4 +2915,4 @@
     </VisualStudio>
   </ProjectExtensions>
   <Import Project="$(SolutionDir)\$(ProjectFileName).targets.user" Condition="Exists('$(SolutionDir)\$(ProjectFileName).targets.user')" />
-</Project>
\ 文件尾没有 newline 字符
+</Project>
diff -uNr xbmc-13.2rc1-Gotham.orig/project/VS2010Express/XBMC.vcxproj.filters xbmc-13.2rc1-Gotham/project/VS2010Express/XBMC.vcxproj.filters
--- xbmc-13.2rc1-Gotham.orig/project/VS2010Express/XBMC.vcxproj.filters	2014-08-13 18:26:13.784542113 +0800
+++ xbmc-13.2rc1-Gotham/project/VS2010Express/XBMC.vcxproj.filters	2014-08-13 18:27:00.880775652 +0800
@@ -3104,6 +3104,9 @@
     <ClCompile Include="..\..\xbmc\cores\dvdplayer\DVDCodecs\Video\DVDVideoCodec.cpp">
       <Filter>cores\dvdplayer\DVDCodecs\Video</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\cores\FFmpeg.cpp">
+      <Filter>cores</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\xbmc\win32\pch.h">
@@ -6094,6 +6097,9 @@
     <ClInclude Include="..\..\xbmc\win32\IMMNotificationClient.h">
       <Filter>win32</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\cores\FFmpeg.h">
+      <Filter>cores</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\..\xbmc\win32\XBMC_PC.rc">
@@ -6123,4 +6129,4 @@
       <Filter>interfaces\swig</Filter>
     </None>
   </ItemGroup>
-</Project>
\ 文件尾没有 newline 字符
+</Project>
diff -uNr xbmc-13.2rc1-Gotham.orig/project/Win32BuildSetup/buildffmpeg.sh xbmc-13.2rc1-Gotham/project/Win32BuildSetup/buildffmpeg.sh
--- xbmc-13.2rc1-Gotham.orig/project/Win32BuildSetup/buildffmpeg.sh	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/project/Win32BuildSetup/buildffmpeg.sh	2014-08-13 18:27:00.944775966 +0800
@@ -0,0 +1,106 @@
+#!/bin/bash
+
+MAKEFLAGS=""
+BGPROCESSFILE="$2"
+
+BASE_URL=$(grep "BASE_URL=" ../../tools/depends/target/ffmpeg/FFMPEG-VERSION | sed 's/BASE_URL=//g')
+VERSION=$(grep "VERSION=" ../../tools/depends/target/ffmpeg/FFMPEG-VERSION | sed 's/VERSION=//g')
+LIBNAME=ffmpeg
+ARCHIVE=$LIBNAME-$VERSION.tar.gz
+
+CUR_DIR=`pwd`
+DEPS_DIR=$CUR_DIR/../BuildDependencies
+LIB_DIR=$CUR_DIR/../../lib/win32
+WGET=$DEPS_DIR/bin/wget
+UNZIP=$CUR_DIR/tools/7z/7za
+
+cd $LIB_DIR
+
+if [ "$1" == "clean" ]
+then
+  echo removing $LIBNAME
+  if [ -d $LIBNAME ]
+  then
+    rm -r $LIBNAME
+  fi
+fi
+
+if [ ! -d $LIBNAME ]; then
+  if [ ! -f $VERSION.tar.gz ]; then
+    $WGET --no-check-certificate $BASE_URL/$VERSION.tar.gz -O $VERSION.tar.gz
+  fi
+  $UNZIP x -y $VERSION.tar.gz
+  $UNZIP x -y $VERSION.tar
+  mv $LIBNAME-$VERSION $LIBNAME
+  cd $LIBNAME
+else
+  cd $LIBNAME
+  if [ -d .libs ]; then
+    rm -r .libs
+  fi
+fi
+
+if [ ! -d .libs ]; then
+  mkdir .libs
+fi
+
+if [ $NUMBER_OF_PROCESSORS > 1 ]; then
+  if [ $NUMBER_OF_PROCESSORS > 4 ]; then
+    MAKEFLAGS=-j4
+  else
+    MAKEFLAGS=-j$NUMBER_OF_PROCESSORS
+  fi
+fi
+
+# add --enable-debug (remove --disable-debug ofc) to get ffmpeg log messages in xbmc.log
+# the resulting debug dll's are twice to fourth time the size of the release binaries
+
+OPTIONS="
+--enable-shared \
+--enable-memalign-hack \
+--enable-gpl \
+--enable-w32threads \
+--enable-postproc \
+--enable-zlib \
+--disable-static \
+--disable-debug \
+--disable-ffplay \
+--disable-ffserver \
+--disable-ffmpeg \
+--disable-ffprobe \
+--disable-devices \
+--disable-doc \
+--disable-crystalhd \
+--enable-muxer=spdif \
+--enable-muxer=adts \
+--enable-muxer=asf \
+--enable-muxer=ipod \
+--enable-muxer=ogg \
+--enable-encoder=ac3 \
+--enable-encoder=aac \
+--enable-encoder=wmav2 \
+--enable-encoder=libvorbis \
+--enable-protocol=http \
+--enable-runtime-cpudetect \
+--enable-dxva2 \
+--cpu=i686 \
+--enable-gnutls"
+
+echo configuring $LIBNAME
+./configure --extra-cflags="-fno-common -I/xbmc/lib/win32/ffmpeg_dxva2 -DNDEBUG" --extra-ldflags="-L/xbmc/system/players/dvdplayer" ${OPTIONS} &&
+
+make $MAKEFLAGS &&
+cp lib*/*.dll .libs/ &&
+cp lib*/*.lib .libs/ &&
+cp .libs/avcodec-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/avformat-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/avutil-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/avfilter-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/postproc-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/swresample-*.dll /xbmc/system/players/dvdplayer/ &&
+cp .libs/swscale-*.dll /xbmc/system/players/dvdplayer/
+
+#remove the bgprocessfile for signaling the process end
+if [ -f $BGPROCESSFILE ]; then
+  rm $BGPROCESSFILE
+fi
\ 文件尾没有 newline 字符
diff -uNr xbmc-13.2rc1-Gotham.orig/system/keymaps/keyboard.xml xbmc-13.2rc1-Gotham/system/keymaps/keyboard.xml
--- xbmc-13.2rc1-Gotham.orig/system/keymaps/keyboard.xml	2014-08-13 18:26:52.128732253 +0800
+++ xbmc-13.2rc1-Gotham/system/keymaps/keyboard.xml	2014-08-13 18:27:01.656779496 +0800
@@ -119,6 +119,9 @@
       <prev_track>SkipPrevious</prev_track>
       <stop>Stop</stop>
       <play_pause>Pause</play_pause>
+      <fastforward>FastForward</fastforward>
+      <rewind>Rewind</rewind>
+      <record/>
       <launch_mail></launch_mail>
       <launch_media_select>XBMC.ActivateWindow(MyMusic)</launch_media_select>
       <launch_app1_pc_icon>ActivateWindow(MyPrograms)</launch_app1_pc_icon>
diff -uNr xbmc-13.2rc1-Gotham.orig/system/settings/settings.xml xbmc-13.2rc1-Gotham/system/settings/settings.xml
--- xbmc-13.2rc1-Gotham.orig/system/settings/settings.xml	2014-08-13 18:26:52.108732150 +0800
+++ xbmc-13.2rc1-Gotham/system/settings/settings.xml	2014-08-13 18:27:01.704779734 +0800
@@ -715,6 +715,21 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.usevaapiswfilter" type="boolean" parent="videoplayer.usevaapi" label="13457" help="36432">
+          <requirement>HAVE_LIBVA</requirement>
+          <dependencies>
+            <dependency type="enable">
+              <and>
+                <condition setting="videoplayer.usevaapi" operator="is">true</condition>
+                <condition setting="videoplayer.decodingmethod" operator="is">1</condition>
+              </and>
+            </dependency>
+            <dependency type="visible" on="property" name="codecoptionvisible" setting="videoplayer.usevaapivc1" operator="is">true</dependency>
+          </dependencies>
+          <level>3</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoplayer.usedxva2" type="boolean" label="13427" help="36158">
           <requirement>HasDXVA2</requirement>
           <dependencies>
@@ -2251,6 +2266,21 @@
   <section id="system" label="13000" help="36349">
     <category id="videoscreen" label="21373" help="36603">
       <group id="1">
+        <setting id="videoscreen.monitor" type="string" label="246" help="">
+          <requirement>HAS_GLX</requirement>
+          <level>0</level>
+          <default>Default</default>
+          <constraints>
+            <options>monitors</options>
+          </constraints>
+          <control type="spinner" format="string" delayed="true" />
+        </setting>
+        <setting id="videoscreen.monitorsingle" type="boolean" label="14102" help="">
+          <requirement>HAS_GLX</requirement>
+          <level>0</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -2272,6 +2302,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.screenmode" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="list" format="string" />
         </setting>
@@ -2301,6 +2332,7 @@
           <control type="toggle" />
         </setting>
         <setting id="videoscreen.blankdisplays" type="boolean" parent="videoscreen.screen" label="13130" help="36355">
+          <requirement>!HAS_GLX</requirement>
           <level>1</level>
           <default>false</default>
           <dependencies>
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/buildsteps/android/configure-depends xbmc-13.2rc1-Gotham/tools/buildsteps/android/configure-depends
--- xbmc-13.2rc1-Gotham.orig/tools/buildsteps/android/configure-depends	2014-08-13 18:26:51.144727373 +0800
+++ xbmc-13.2rc1-Gotham/tools/buildsteps/android/configure-depends	2014-08-13 18:27:01.160777037 +0800
@@ -11,5 +11,6 @@
     --with-ndk=$NDK_PATH \
     $(if [ "$SDK_VERSION" != "Default" ]; then echo --with-sdk=android-$SDK_VERSION;fi) \
     --with-toolchain=$TOOLCHAIN \
-    --prefix=$XBMC_DEPENDS_ROOT
+    --prefix=$XBMC_DEPENDS_ROOT \
+    --enable-neon
 fi
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/buildsteps/defaultenv xbmc-13.2rc1-Gotham/tools/buildsteps/defaultenv
--- xbmc-13.2rc1-Gotham.orig/tools/buildsteps/defaultenv	2014-08-13 18:26:51.144727373 +0800
+++ xbmc-13.2rc1-Gotham/tools/buildsteps/defaultenv	2014-08-13 18:27:00.948775985 +0800
@@ -45,7 +45,7 @@
   ;;
 
   rbpi)
-    JENKINS_RBPI_DEVENV=/home/jenkins/rbpi-dev
+    JENKINS_RBPI_DEVENV=${JENKINS_RBPI_DEVENV:-"/home/jenkins/rbpi-dev"}
     DEFAULT_XBMC_DEPENDS_ROOT=$WORKSPACE/tools/depends/xbmc-depends
     DEFAULT_CONFIGURATION="Debug"
   ;;
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/buildsteps/rbpi/configure-depends xbmc-13.2rc1-Gotham/tools/buildsteps/rbpi/configure-depends
--- xbmc-13.2rc1-Gotham.orig/tools/buildsteps/rbpi/configure-depends	2014-08-13 18:26:51.140727350 +0800
+++ xbmc-13.2rc1-Gotham/tools/buildsteps/rbpi/configure-depends	2014-08-13 18:27:00.956776025 +0800
@@ -7,25 +7,7 @@
   cd $WORKSPACE/tools/depends;
 
   PATH="$PATH:$JENKINS_RBPI_DEVENV/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin" \
-  CFLAGS="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard \
-  -mfpu=vfp -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated \
-  -Wno-deprecated-declarations -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include \
-  -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vcos/pthreads \
-  -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vmcs_host/linux" \
-  CXXFLAGS="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s \
-  -mfloat-abi=hard -mfpu=vfp -mabi=aapcs-linux -Wno-psabi \
-  -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
-  -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include \
-  -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vcos/pthreads \
-  -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vmcs_host/linux" \
-  LDFLAGS="-L$JENKINS_RBPI_DEVENV/firmware/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
-  -lvchiq_arm" \
-  ./configure --host=arm-linux-gnueabihf --prefix=$XBMC_DEPENDS_ROOT --with-tarballs=$TARBALLS \
+  ./configure --with-platform=raspberry-pi --host=arm-linux-gnueabihf --prefix=$XBMC_DEPENDS_ROOT --with-tarballs=$TARBALLS \
     --with-toolchain=$JENKINS_RBPI_DEVENV/tools/arm-bcm2708/arm-bcm2708hardfp-linux-gnueabi/arm-bcm2708hardfp-linux-gnueabi/sysroot \
-    --build=i686-linux \
-      CFLAGS="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard \
-      -mfpu=vfp -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated \
-      -Wno-deprecated-declarations -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include \
-      -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vcos/pthreads \
-      -isystem$JENKINS_RBPI_DEVENV/firmware/opt/vc/include/interface/vmcs_host/linux"
+    --with-firmware=$JENKINS_RBPI_DEVENV/firmware --build=i686-linux
 fi
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/darwin/Configurations/App.xcconfig xbmc-13.2rc1-Gotham/tools/darwin/Configurations/App.xcconfig
--- xbmc-13.2rc1-Gotham.orig/tools/darwin/Configurations/App.xcconfig	2014-08-13 18:26:51.984731539 +0800
+++ xbmc-13.2rc1-Gotham/tools/darwin/Configurations/App.xcconfig	2014-08-13 18:27:01.088776680 +0800
@@ -20,9 +20,9 @@
 
 XBMC_DEPENDS_ROOT = /Users/Shared/xbmc-depends
 
-HEADER_SEARCH_PATHS = $(inherited) $SRCROOT xbmc xbmc/linux xbmc/osx xbmc/cores/dvdplayer lib lib/ffmpeg $XBMC_DEPENDS/include $XBMC_DEPENDS/include/libcec $XBMC_DEPENDS/include/mysql $XBMC_DEPENDS/include/freetype2 $XBMC_DEPENDS/include/python2.6
+HEADER_SEARCH_PATHS = $(inherited) $SRCROOT xbmc xbmc/linux xbmc/osx xbmc/cores/dvdplayer lib $XBMC_DEPENDS/include $XBMC_DEPENDS/include/libcec $XBMC_DEPENDS/include/mysql $XBMC_DEPENDS/include/freetype2 $XBMC_DEPENDS/include/python2.6
 
-LIBRARY_SEARCH_PATHS = $(inherited) $(SRCROOT) $(SRCROOT)/lib/libRTV $(SRCROOT)/lib/libXDAAP $(SRCROOT)/lib/cmyth/libcmyth $(SRCROOT)/lib/cmyth/librefmem $(SRCROOT)/lib/libsquish $(SRCROOT)/lib/SlingboxLib $(SRCROOT)/xbmc/interfaces/json-rpc "$(SRCROOT)/lib/ffmpeg/libavcodec" "$(SRCROOT)/lib/ffmpeg/libavutil" "$(SRCROOT)/lib/ffmpeg/libavformat" "$(SRCROOT)/lib/ffmpeg/libavfilter" "$(SRCROOT)/lib/ffmpeg/libavdevice" "$(SRCROOT)/lib/ffmpeg/libswresample" "$(SRCROOT)/lib/ffmpeg/libpostproc" "$(SRCROOT)/lib/ffmpeg/libswscale" "$(SRCROOT)/xbmc/interfaces/python" "$(SRCROOT)/xbmc/interfaces/legacy"
+LIBRARY_SEARCH_PATHS = $(inherited) $(SRCROOT) $(SRCROOT)/lib/libRTV $(SRCROOT)/lib/libXDAAP $(SRCROOT)/lib/cmyth/libcmyth $(SRCROOT)/lib/cmyth/librefmem $(SRCROOT)/lib/libsquish $(SRCROOT)/lib/SlingboxLib $(SRCROOT)/xbmc/interfaces/json-rpc "$(SRCROOT)/xbmc/interfaces/python" "$(SRCROOT)/xbmc/interfaces/legacy"
 FRAMEWORK_SEARCH_PATHS = $(inherited) "$(SDKROOT)/System/Library/PrivateFrameworks/" "$(SDKROOT)/System/Library/Frameworks/"
 
 XBMC_OTHER_LDFLAGS_COMMON = $(inherited) -Wl,-headerpad_max_install_names -Wl,-all_load -L$XBMC_DEPENDS/lib -lbz2 -lintl -lexpat -lssl -lgpg-error -lresolv -lffi -lssh -llzo2 -lpcre -lpcrecpp -lfribidi -lfreetype -lfontconfig -lsqlite3 -lsamplerate -ltinyxml -lmicrohttpd -lsmbclient -lpython2.6 -lyajl -ljpeg -lcrypto -lgcrypt -lavdevice -lavfilter -lavcodec -lavformat -lpostproc -lavutil -lswresample -lswscale -ltag -L$XBMC_DEPENDS/lib/mysql -lmysqlclient -lxml2 -lxslt
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/configure.in xbmc-13.2rc1-Gotham/tools/depends/configure.in
--- xbmc-13.2rc1-Gotham.orig/tools/depends/configure.in	2014-08-13 18:26:51.460728937 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/configure.in	2014-08-13 18:27:01.112776799 +0800
@@ -5,12 +5,27 @@
 AC_CONFIG_FILES([target/config.site native/config.site.native Makefile.include target/Toolchain.cmake])
 AC_CANONICAL_HOST
 m4_include([../../m4/xbmc_arch.m4])
+m4_include([../../m4/ax_require_defined.m4])
+m4_include([../../m4/ax_append_flag.m4])
+m4_include([../../m4/ax_check_compile_flag.m4])
+m4_include([../../m4/ax_append_compile_flags.m4])
+
 
 AC_ARG_WITH([toolchain],
   [AS_HELP_STRING([--with-toolchain],
   [specify path to toolchain. Required for android. Defaults to xcode root for darwin, /usr for linux])],
   [use_toolchain=$withval])
 
+AC_ARG_WITH([platform],
+  [AS_HELP_STRING([--with-platform],
+  [target platform [auto]])],
+  [use_platform=$withval])
+
+AC_ARG_WITH([firmware],
+  [AS_HELP_STRING([--with-firmware],
+  [platform specific firmware []])],
+  [use_firmware=$withval])
+
 AC_ARG_WITH([tarballs],
   [AS_HELP_STRING([--with-tarballs],
   [path where tarballs will be saved [prefix/xbmc-tarballs]])],
@@ -21,6 +36,18 @@
   [optional. specify target cpu. guessed if not specified])],
   [use_cpu=$withval],use_cpu=auto)
 
+AC_ARG_ENABLE([neon],
+  [AS_HELP_STRING([--enable-neon],
+  [enable neon support (default is no)])],
+  [use_neon=$enableval],
+  [use_neon=no])
+
+AC_ARG_ENABLE([tegra],
+  [AS_HELP_STRING([--enable-tegra],
+  [enable Tegra2 arm (default is no)])],
+  [use_tegra=$enableval],
+  [use_tegra=no])
+
 AC_ARG_WITH([ndk],
   [AS_HELP_STRING([--with-ndk],
   [specify path to ndk (required for android only)])],
@@ -83,15 +110,25 @@
 platform_cxx=g++
 case $host in
   arm*-*linux-android*)
-    if test "x$use_cpu" = "xauto"; then
+    if test "x$use_cpu" = "xauto" || test "x$use_cpu" = "xarmeabi-v7a"; then
       use_cpu="armeabi-v7a"
+      AX_APPEND_COMPILE_FLAGS([$passed_cflags -march=armv7-a -mtune=cortex-a9 -mfloat-abi=softfp], [platform_cflags])
+      use_neon="yes"
+    fi
+    if test "$use_neon" = "yes"; then
+      AX_APPEND_COMPILE_FLAGS([$passed_cflags -mfpu=neon -mvectorize-with-neon-quad], [platform_cflags])
+    fi
+    if test "$use_tegra" = "yes"; then
+      AX_CHECK_COMPILE_FLAG(-mfpu=vfpv3-d16,
+        [AX_APPEND_COMPILE_FLAGS([$passed_cflags -Wno-psabi -Wa,-march=arv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork],
+          [platform_cflags])],
+        [AX_APPEND_COMPILE_FLAGS([$passed_cflags -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork],
+          [platform_cflags])],
+      )
     fi
     use_sdk="${use_sdk:-android-14}"
     deps_dir="$use_host-$use_sdk"
     platform_cflags="-DANDROID -Os -fexceptions"
-    if test "x$use_cpu" = "xarmeabi-v7a"; then
-      platform_cflags+=" -march=armv7-a -mtune=cortex-a9 -mfloat-abi=softfp -mfpu=neon"
-    fi
     platform_ldflags="-L$prefix/$deps_dir/lib/$use_sdk"
     platform_cxxflags="$platform_cflags -frtti"
     platform_includes="-I$prefix/$deps_dir/include/$use_sdk"
@@ -120,14 +157,27 @@
     cross_compiling="yes"
   ;;
   arm*-*-linux-gnu*|arm*-*-linux-uclibc*)
-    if test "x$use_cpu" = "xauto"; then
-      use_cpu=$host_cpu
+    if test "$use_platform" = "auto"; then
+      if test "x$use_cpu" = "xauto"; then
+        use_cpu=$host_cpu
+      fi
+      if test "$use_neon" = "yes"; then
+        AX_APPEND_COMPILE_FLAGS([$passed_cflags -mfpu=neon -mvectorize-with-neon-quad], [platform_cflags])
+      fi
+      if test "$use_tegra" = "yes"; then
+        AX_CHECK_COMPILE_FLAG(-mfpu=vfpv3-d16,
+          [AX_APPEND_COMPILE_FLAGS([$passed_cflags -Wno-psabi -Wa,-march=arv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork],
+            [platform_cflags])],
+          [AX_APPEND_COMPILE_FLAGS([$passed_cflags -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork],
+            [platform_cflags])],
+        )
+      fi
+      use_toolchain="${use_toolchain:-/usr}"
+      platform_cflags="-Os -fPIC -DPIC"
+      platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
+      platform_cxxflags="$platform_cflags"
+      platform_os="linux"
     fi
-    use_toolchain="${use_toolchain:-/usr}"
-    platform_cflags="-Os -fPIC -DPIC"
-    platform_ldflags="-Wl,-rpath-link=$prefix/$deps_dir/lib"
-    platform_cxxflags="$platform_cflags"
-    platform_os="linux"
   ;;
   *i686*-linux-gnu*|i*86*-*-linux-uclibc*)
     use_cpu=$host_cpu
@@ -269,6 +319,37 @@
     AC_MSG_ERROR(unsupported host ($use_host))
 esac
 
+if test "$use_platform" = "raspberry-pi"; then
+  if test -d "${use_firmware}/opt/vc/include"; then
+    :
+  else
+    AC_MSG_ERROR([Raspberry Pi firmware not found])
+  fi
+  use_neon=no
+  use_arch="arm"
+  use_cpu="arm1176jzf-s"
+  use_hardcoded_tables="yes"
+  use_alsa="no"
+  ARCH="arm"
+  platform_os="linux"
+  cross_compiling="yes"
+  use_host="arm-linux-gnueabihf"
+  deps_dir="$use_host"
+  platform_cflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard \
+   -mfpu=vfp -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated \
+   -Wno-deprecated-declarations -isystem${use_firmware}/opt/vc/include \
+   -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
+   -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
+  platform_cxxflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s \
+   -mfloat-abi=hard -mfpu=vfp -mabi=aapcs-linux -Wno-psabi \
+   -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
+   -isystem${use_firmware}/opt/vc/include \
+   -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
+   -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
+  platform_ldflags="-L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
+   -lvchiq_arm"
+fi
+
 XBMC_SETUP_ARCH_DEFINES()
 
 platform_cflags+=" $passed_cflags"
@@ -407,6 +488,7 @@
 AC_SUBST(use_toolchain)
 AC_SUBST(use_build_toolchain)
 AC_SUBST(use_tarballs)
+AC_SUBST(use_platform)
 AC_SUBST(cross_compiling)
 AC_SUBST(platform_cflags)
 AC_SUBST(platform_cxxflags)
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/Makefile.include.in xbmc-13.2rc1-Gotham/tools/depends/Makefile.include.in
--- xbmc-13.2rc1-Gotham.orig/tools/depends/Makefile.include.in	2014-08-13 18:26:51.428728777 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/Makefile.include.in	2014-08-13 18:27:00.976776128 +0800
@@ -18,6 +18,7 @@
 OS=@platform_os@
 CROSS_COMPILING=@cross_compiling@
 ARCH_DEFINES=@ARCH_DEFINES@
+TARGET_PLATFORM=@use_platform@
 
 HAS_ZLIB=@has_zlib@
 NEED_LIBICONV=@need_libiconv@
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/README xbmc-13.2rc1-Gotham/tools/depends/README
--- xbmc-13.2rc1-Gotham.orig/tools/depends/README	2014-08-13 18:26:51.492729100 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/README	2014-08-13 18:27:00.980776144 +0800
@@ -23,6 +23,9 @@
 Linux:
   ARM toolchain (codesourcery/lenaro/etc)
     ./configure --with-toolchain=/opt/toolchains/my-example-toolchain/  --prefix=/opt/xbmc-deps --host=arm-linux-gnueabi
+  RASPBERRY-PI:
+    PATH="/opt/rbp-dev/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin:$PATH" ./configure --with-platform=raspberry-pi --host=arm-linux-gnueabihf --prefix=/opt/xbmc-deps --with-tarballs=/opt/xbmc-tarballs --with-toolchain=/opt/rbp-dev/tools/arm-bcm2708/arm-bcm2708hardfp-linux-gnueabi/arm-bcm2708hardfp-linux-gnueabi/sysroot --with-firmware=/opt/rbp-dev/firmware --build=i686-linux
+
   Native toolchain
     ./configure --with-toolchain=/usr --prefix=/opt/xbmc-deps --host=x86_64-linux-gnu
 
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/autobuild.sh xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/autobuild.sh
--- xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/autobuild.sh	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/autobuild.sh	2014-08-13 18:27:00.996776223 +0800
@@ -0,0 +1,167 @@
+#!/bin/bash
+#
+#      Copyright (C) 2005-2013 Team XBMC
+#      http://xbmc.org
+#
+#  This Program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2, or (at your option)
+#  any later version.
+#
+#  This Program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with XBMC; see the file COPYING.  If not, see
+#  <http://www.gnu.org/licenses/>.
+#
+
+
+MYDIR=$(cd $(dirname $0); pwd)
+cd $MYDIR
+FFMPEG_PREFIX=${MYDIR}/ffmpeg-install
+
+BASE_URL=$(grep "BASE_URL=" FFMPEG-VERSION | sed 's/BASE_URL=//g')
+VERSION=$(grep "VERSION=" FFMPEG-VERSION | sed 's/VERSION=//g')
+ARCHIVE=ffmpeg-${VERSION}.tar.gz
+
+function usage {
+  echo "usage $(basename $0) 
+       [-p | --prefix]    ... ffmepg install prefix
+       [-d | --download]  ... no build, download tarfile only
+       [-r | --release]   ... disable debugging symbols
+       [-j]               ... make concurrency level
+       [--cpu=CPU]        ... minimum required CPU
+       [--arch=ARCH]      ... select architecture
+       [--disable-optimizations]
+  "
+}
+
+while :
+do
+  case $1 in
+    -h | --help)
+      usage
+      exit 0
+      ;;
+    -p | --prefix)
+      FFMPEG_PREFIX=$2
+      shift 2
+      ;; 
+    --prefix=*)
+      FFMPEG_PREFIX=${1#*=}
+      shift
+      ;; 
+    -d | --download)
+      downloadonly=true 
+      shift
+      ;;
+    -r | --release)
+      FLAGS="$FLAGS --disable-debug" 
+      shift
+      ;;
+    --disable-optimizations)
+      FLAGS="$FLAGS --disable-optimizations"
+      shift
+      ;;
+    --cpu=*)
+      FLAGS="$FLAGS --cpu=${1#*=}"
+      shift
+      ;;
+    --arch=*)
+      FLAGS="$FLAGS --arch=${1#*=}"
+      shift
+      ;;
+    --extra-cflags=*)
+      FLAGS="$FLAGS --extra-cflags=\"${1#*=}\""
+      shift
+      ;;
+    --extra-cxxflags=*)
+      FLAGS="$FLAGS --extra-cxxflags=\"${1#*=}\""
+      shift
+      ;;
+    -j)
+      BUILDTHREADS=$2
+      shift 2
+      ;;
+    --)
+      shift
+      break
+      ;;
+    -*)
+      echo "WARN: Unknown option (ignored): $1" >&2
+      shift
+      ;;
+    *)
+      break
+      ;;
+  esac
+done
+
+BUILDTHREADS=${BUILDTHREADS:-$(grep -c processor /proc/cpuinfo)}
+
+[ -z ${VERSION} ] && exit 3
+if [ -f ${FFMPEG_PREFIX}/lib/pkgconfig/libavcodec.pc ] && [ -f .ffmpeg-installed ]
+then
+  CURVER=$(cat .ffmpeg-installed)
+  [ "$VERSION" == "$CURVER" ] && exit 0
+fi
+
+[ -f ${ARCHIVE} ] || curl -Ls --create-dirs -f -o ${ARCHIVE} ${BASE_URL}/${VERSION}.tar.gz
+[ $downloadonly ] && exit 0
+
+[ -d ffmpeg-${VERSION} ] && rm -rf ffmpeg-${VERSION} && rm .ffmpeg-installed >/dev/null 2>&1
+if [ -d ${FFMPEG_PREFIX} ]
+then
+  [ -w ${FFMPEG_PREFIX} ] || SUDO="sudo"
+else
+  [ -w $(dirname ${FFMPEG_PREFIX}) ] || SUDO="sudo"
+fi
+
+mkdir ffmpeg-${VERSION}
+cd ffmpeg-${VERSION} || exit 2
+tar --strip-components=1 -xf ../${ARCHIVE}
+
+CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
+./configure --prefix=$FFMPEG_PREFIX \
+	--extra-version="xbmc-${VERSION}" \
+	--disable-devices \
+	--disable-ffplay \
+	--disable-ffmpeg \
+	--disable-ffprobe \
+	--disable-ffserver \
+	--disable-doc \
+	--enable-gpl \
+	--enable-runtime-cpudetect \
+	--enable-postproc \
+	--enable-vaapi \
+	--enable-vdpau \
+	--enable-bzlib \
+	--enable-gnutls \
+	--enable-muxer=spdif \
+	--enable-muxer=adts \
+	--enable-muxer=asf \
+	--enable-muxer=ipod \
+	--enable-encoder=ac3 \
+	--enable-encoder=aac \
+	--enable-encoder=wmav2 \
+	--enable-protocol=http \
+	--enable-libvorbis \
+	--enable-muxer=ogg \
+	--enable-encoder=libvorbis \
+	--enable-nonfree \
+	--enable-pthreads \
+	--enable-zlib \
+        ${FLAGS}
+
+make -j ${BUILDTHREADS} 
+if [ $? -eq 0 ]
+then
+  [ ${SUDO} ] && echo "Root priviledges are required to install to ${FFMPEG_PREFIX}"
+  ${SUDO} make install && echo "$VERSION" > ../.ffmpeg-installed
+else
+  echo "ERROR: building ffmpeg failed"
+  exit 1
+fi
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/FFMPEG-VERSION xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/FFMPEG-VERSION
--- xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/FFMPEG-VERSION	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/FFMPEG-VERSION	2014-08-13 18:27:00.944775966 +0800
@@ -0,0 +1,5 @@
+LIBNAME=ffmpeg
+BASE_URL=https://github.com/xbmc/FFmpeg/archive
+VERSION=2.2-Helix-alpha1
+ARCHIVE=$(LIBNAME)-$(VERSION).tar.gz
+
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/Makefile xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/Makefile
--- xbmc-13.2rc1-Gotham.orig/tools/depends/target/ffmpeg/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/target/ffmpeg/Makefile	2014-08-13 18:27:01.000776247 +0800
@@ -0,0 +1,82 @@
+include ../../Makefile.include
+include FFMPEG-VERSION
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile
+
+# set to "yes" to enable patching
+# we don't apply patches until we move to a vanilla ffmpeg tarball
+APPLY_PATCHES=no
+
+# configuration settings
+ffmpg_config = --prefix=$(PREFIX) --extra-version="xbmc-$(VERSION)"
+ffmpg_config += --cc=$(CC) --cxx=$(CXX)
+ffmpg_config += --disable-devices --disable-doc
+ffmpg_config += --disable-ffplay --disable-ffmpeg
+ffmpg_config += --disable-ffprobe --disable-ffserver
+ffmpg_config += --enable-gpl --enable-runtime-cpudetect
+ffmpg_config += --enable-postproc --enable-pthreads
+ffmpg_config += --enable-muxer=spdif --enable-muxer=adts
+ffmpg_config += --enable-muxer=asf --enable-muxer=ipod
+ffmpg_config += --enable-encoder=ac3 --enable-encoder=aac
+ffmpg_config += --enable-encoder=wmav2 --enable-protocol=http
+ifeq ($(CROSS_COMPILING), yes)
+  ffmpg_config += --arch=$(CPU) --enable-cross-compile
+endif
+ifeq ($(OS), linux)
+  ffmpg_config += --target-os=$(OS) --cpu=$(CPU)
+  ffmpg_config += --enable-vdpau --enable-vaapi --enable-gnutls
+  ffmpg_config += --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis
+endif
+ifeq ($(OS), android)
+  ifeq ($(findstring arm, $(CPU)), arm)
+    ffmpg_config += --cpu=cortex-a9
+  else
+    ffmpg_config += --cpu=i686 --disable-mmx
+  endif
+  ffmpg_config += --target-os=linux
+endif
+ifeq ($(OS), ios)
+  ffmpg_config += --cpu=cortex-a8 --yasmexe=$(NATIVEPREFIX)/bin/yasm
+  ffmpg_config += --disable-decoder=mpeg_xvmc --enable-vda --disable-crystalhd
+  ffmpg_config += --target-os=darwin
+endif
+ifeq ($(OS), osx)
+  ffmpg_config += --disable-decoder=mpeg_xvmc --enable-vda --disable-crystalhd
+  ffmpg_config += --target-os=darwin
+endif
+ifeq ($(findstring arm, $(CPU)), arm)
+  ffmpg_config += --enable-pic --disable-armv5te --disable-armv6t2
+endif
+ifeq ($(Configuration), Release)
+  ffmpg_config += --disable-debug
+endif
+
+
+CLEAN_FILES=$(ARCHIVE) $(PLATFORM)
+
+all: .installed-$(PLATFORM)
+
+$(TARBALLS_LOCATION)/$(ARCHIVE):
+	cd $(TARBALLS_LOCATION); $(RETRIEVE_TOOL) -Ls --create-dirs -f -o $(TARBALLS_LOCATION)/$(ARCHIVE) $(BASE_URL)/$(VERSION).tar.gz
+
+$(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
+	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
+	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig\npkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
+	cd $(PLATFORM);\
+	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
+	./configure $(ffmpg_config)
+
+build: $(PLATFORM)
+	$(MAKE) -C $(PLATFORM)
+
+.installed-$(PLATFORM): build
+	$(MAKE) -C $(PLATFORM) install
+	touch $@
+
+clean:
+	$(MAKE) -C $(PLATFORM) clean
+	rm -f .installed-$(PLATFORM)
+
+distclean::
+	rm -rf $(PLATFORM) .installed-$(PLATFORM)
+
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/depends/target/Makefile xbmc-13.2rc1-Gotham/tools/depends/target/Makefile
--- xbmc-13.2rc1-Gotham.orig/tools/depends/target/Makefile	2014-08-13 18:26:51.772730481 +0800
+++ xbmc-13.2rc1-Gotham/tools/depends/target/Makefile	2014-08-13 18:27:00.980776144 +0800
@@ -15,7 +15,7 @@
 	python26 afpfs-ng libshairplay \
 	libplist libcec libbluray boost tinyxml dummy-libxbmc \
 	libamplayer libssh taglib xbmc-pvr-addons libusb libnfs libmp3lame \
-	pythonmodule-pil libxslt
+	pythonmodule-pil libxslt ffmpeg
 
 ifeq ($(ENABLE_GPLV3),1)
   DEPENDS+=samba-gplv3 libcdio-gplv3
@@ -56,11 +56,12 @@
 LINUX_SYSTEM_LIBS=
 ifeq ($(OS),linux)
   #not for raspberry pi
-  ifneq ($(CPU),arm)
+  ifneq ($(TARGET_PLATFORM),raspberry-pi)
     DEPENDS += alsa-lib libsdl linux-system-libs
     ALSA_LIB = alsa-lib
     LINUX_SYSTEM_LIBS = linux-system-libs
   endif
+  FFMPEG_DEPENDS = gnutls
 endif
 
 .PHONY: $(DEPENDS)
@@ -96,6 +97,7 @@
 pythonmodule-pil: $(ZLIB) libjpeg-turbo libpng freetype2 python26
 libsdl: $(LINUX_SYSTEM_LIBS)
 libxslt: libgcrypt
+ffmpeg: $(ICONV) $(ZLIB) bzip2 libvorbis $(FFMPEG_DEPENDS)
 
 .installed-$(PLATFORM): $(DEPENDS)
 	touch $@
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/ffmpeg/Makefile xbmc-13.2rc1-Gotham/tools/rbp/depends/ffmpeg/Makefile
--- xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/ffmpeg/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/tools/rbp/depends/ffmpeg/Makefile	2014-08-13 18:27:00.996776223 +0800
@@ -0,0 +1,61 @@
+include ../../Makefile.include
+include ../depends.mk
+include ../../../depends/target/ffmpeg/FFMPEG-VERSION
+DEPS= ../../Makefile.include ../depends.mk ../../../depends/target/ffmpeg/FFMPEG-VERSION Makefile
+
+# set to "yes" to enable patching
+# we don't apply patches until we move to a vanilla ffmpeg tarball
+APPLY_PATCHES=no
+
+# configuration settings
+ffmpg_config = --sysroot=$(SYSROOT) --prefix=$(PREFIX) --extra-version="xbmc-$(VERSION)"
+ffmpg_config += --enable-cross-compile --target-os=linux --cpu=arm1176jzf-s --arch=arm
+ffmpg_config += --cc=$(CC) --cxx=$(CXX)
+ffmpg_config += --disable-devices --disable-doc
+ffmpg_config += --disable-ffplay --disable-ffmpeg
+ffmpg_config += --disable-ffprobe --disable-ffserver
+ffmpg_config += --enable-gpl --enable-runtime-cpudetect
+ffmpg_config += --enable-postproc --enable-pthreads
+ffmpg_config += --enable-muxer=spdif --enable-muxer=adts
+ffmpg_config += --enable-muxer=asf --enable-muxer=ipod
+ffmpg_config += --enable-encoder=ac3 --enable-encoder=aac
+ffmpg_config += --enable-encoder=wmav2 --enable-protocol=http
+ffmpg_config += --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis
+ffmpg_config += --disable-vaapi --disable-vdpau --disable-crystalhd
+#ffmpg_config += --enable-gnutls
+ifeq ($(Configuration), Release)
+  ffmpg_config += --disable-debug
+endif
+
+
+CLEAN_FILES=$(ARCHIVE) rpi
+
+all: .installed
+
+$(TARBALLS_LOCATION)/$(ARCHIVE):
+	cd $(TARBALLS_LOCATION); $(RETRIEVE_TOOL) -Ls --create-dirs -f -o $(TARBALLS_LOCATION)/$(ARCHIVE) $(BASE_URL)/$(VERSION).tar.gz
+
+rpi: $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
+	rm -rf rpi; mkdir -p rpi
+	cd rpi; $(ARCHIVE_TOOL) --strip-components=1 -xf $(TARBALLS_LOCATION)/$(ARCHIVE)
+	if test "$(APPLY_PATCHES)" = "yes"; then \
+	  cd rpi; \
+	  for PATCH in ../patches/*.patch ; do \
+	    patch -p1 < $${PATCH}; \
+	  done; \
+        fi
+	cd rpi;\
+	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
+	./configure $(ffmpg_config)
+
+.installed: rpi
+	$(MAKE) -j $(JOBS) -C rpi || exit 1
+	$(MAKE) -C rpi install && touch $@
+
+clean:
+	$(MAKE) -C rpi clean
+	rm -f .installed
+
+distclean::
+	rm -rf rpi .installed
+
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/Makefile xbmc-13.2rc1-Gotham/tools/rbp/depends/Makefile
--- xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/Makefile	2014-08-13 18:26:52.012731671 +0800
+++ xbmc-13.2rc1-Gotham/tools/rbp/depends/Makefile	2014-08-13 18:27:00.788775196 +0800
@@ -2,10 +2,10 @@
 
 ifeq ($(USE_BUILDROOT),1)
 	BUILDTOOLS = 
-	SUBDIRS = xbmc
+	SUBDIRS = ffmpeg xbmc
 else
 	BUILDTOOLS = help2man autoconf automake libtool pkg-config yasm cmake patchelf
-	SUBDIRS = liblzo2 tiff libnfs jasper libplist libshairplay tinyxml xbmc
+	SUBDIRS = liblzo2 tiff libnfs jasper libplist libshairplay tinyxml ffmpeg xbmc
 endif
 
 IMAGENAME = xbmc-rbp-`date +'%y%m%d'`
@@ -18,7 +18,7 @@
 	for d in $(BUILDTOOLS); do $(MAKE) -C $$d; done
 
 subdirs:
-	for d in $(SUBDIRS); do $(MAKE) -C $$d; done
+	for d in $(SUBDIRS); do if test -f "$$d/.installed"; then :; else $(MAKE) -C $$d || exit 1; fi; done
 
 clean:
 	for d in $(BUILDTOOLS); do $(MAKE) -C $$d clean; done
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/xbmc/Makefile xbmc-13.2rc1-Gotham/tools/rbp/depends/xbmc/Makefile
--- xbmc-13.2rc1-Gotham.orig/tools/rbp/depends/xbmc/Makefile	2014-08-13 18:26:52.000731615 +0800
+++ xbmc-13.2rc1-Gotham/tools/rbp/depends/xbmc/Makefile	2014-08-13 18:27:00.788775196 +0800
@@ -5,6 +5,7 @@
 
 ifeq ($(USE_BUILDROOT),1)
 	export PATH:=$(PREFIX)/bin:$(BUILDROOT)/output/host/usr/bin:$(SYSROOT)/usr/bin:$(PATH)
+	export PKG_CONFIG_PATH=$(PREFIX)/lib/pkgconfig
 endif
 
 CONFIGURE=./configure --prefix=$(PREFIX) --build=$(BUILD) --host=$(HOST) \
diff -uNr xbmc-13.2rc1-Gotham.orig/tools/rbp/setup-sdk.sh xbmc-13.2rc1-Gotham/tools/rbp/setup-sdk.sh
--- xbmc-13.2rc1-Gotham.orig/tools/rbp/setup-sdk.sh	2014-08-13 18:26:52.000731615 +0800
+++ xbmc-13.2rc1-Gotham/tools/rbp/setup-sdk.sh	2014-08-13 18:27:00.788775196 +0800
@@ -5,9 +5,9 @@
 USE_BUILDROOT=1
 
 if [ "$USE_BUILDROOT" = "1" ]; then
-  BUILDROOT=/opt/xbmc-bcm/buildroot
-  TARBALLS=/opt/xbmc-tarballs
-  XBMCPREFIX=/opt/xbmc-bcm/xbmc-bin
+  BUILDROOT=${BUILDROOT:-"/opt/xbmc-bcm/buildroot"}
+  TARBALLS=${TARBALLS:-"/opt/xbmc-tarballs"}
+  XBMCPREFIX=${XBMCPREFIX:-"/opt/xbmc-bcm/xbmc-bin"}
 
   SDKSTAGE=$BUILDROOT/output/staging
   TARGETFS=$BUILDROOT/output/target
@@ -21,8 +21,15 @@
   BUILDROOT=/opt/bcm-rootfs
 fi
 
-sudo mkdir -p $XBMCPREFIX
-sudo chmod 777 $XBMCPREFIX
+if [ -d $XBMCPREFIX ]
+then
+  [ -O $XBMCPREFIX ] || SUDO="sudo"
+else
+  [ -w $(dirname $XBMCPREFIX) ] || SUDO="sudo"
+fi
+
+$SUDO mkdir -p $XBMCPREFIX
+$SUDO chmod 777 $XBMCPREFIX
 mkdir -p $XBMCPREFIX/lib
 mkdir -p $XBMCPREFIX/include
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/addons/AddonCallbacksCodec.cpp xbmc-13.2rc1-Gotham/xbmc/addons/AddonCallbacksCodec.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/addons/AddonCallbacksCodec.cpp	2014-08-13 18:26:10.088523788 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/addons/AddonCallbacksCodec.cpp	2014-08-13 18:27:00.520773862 +0800
@@ -21,10 +21,13 @@
 #include "Application.h"
 #include "Addon.h"
 #include "AddonCallbacksCodec.h"
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
 #include "utils/StringUtils.h"
 
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+}
+
 namespace ADDON
 {
 class CCodecIds
@@ -57,23 +60,12 @@
 private:
   CCodecIds(void)
   {
-    DllAvCodec  dllAvCodec;
-    DllAvFormat dllAvFormat;
-
-    // load ffmpeg and register formats
-    if (!dllAvCodec.Load() || !dllAvFormat.Load())
-    {
-      CLog::Log(LOGWARNING, "failed to load ffmpeg");
-      return;
-    }
-    dllAvFormat.av_register_all();
-
     // get ids and names
     AVCodec* codec = NULL;
     xbmc_codec_t tmp;
-    while ((codec = dllAvCodec.av_codec_next(codec)))
+    while ((codec = av_codec_next(codec)))
     {
-      if (dllAvCodec.av_codec_is_decoder(codec))
+      if (av_codec_is_decoder(codec))
       {
         tmp.codec_type = (xbmc_codec_type_t)codec->type;
         tmp.codec_id   = codec->id;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/Application.cpp xbmc-13.2rc1-Gotham/xbmc/Application.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/Application.cpp	2014-08-13 18:26:09.368520216 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/Application.cpp	2014-08-13 18:27:01.612779282 +0800
@@ -348,6 +348,8 @@
 #include "utils/AMLUtils.h"
 #endif
 
+#include "cores/FFmpeg.h"
+
 using namespace std;
 using namespace ADDON;
 using namespace XFILE;
@@ -737,6 +739,14 @@
   CLog::Log(LOGNOTICE, "Running on Android %d-bit API level %d (%s, %s)", g_sysinfo.GetKernelBitness(), CJNIBuild::SDK_INT, g_sysinfo.GetLinuxDistro().c_str(), g_sysinfo.GetUnameVersion().c_str());
 #elif defined(TARGET_POSIX)
   CLog::Log(LOGNOTICE, "Running on Linux %d-bit (%s, %s)", g_sysinfo.GetKernelBitness(), g_sysinfo.GetLinuxDistro().c_str(), g_sysinfo.GetUnameVersion().c_str());
+  CLog::Log(LOGNOTICE, "FFmpeg version: %s, statically linked: %d", FFMPEG_VERSION, USE_STATIC_FFMPEG);
+if (!strstr(FFMPEG_VERSION, FFMPEG_VER_SHA))
+{
+  if (strstr(FFMPEG_VERSION, "xbmc"))
+    CLog::Log(LOGNOTICE, "WARNING: unknown ffmpeg-xbmc version detected");
+  else
+    CLog::Log(LOGNOTICE, "WARNING: unsupported ffmpeg version detected");
+}
 #elif defined(TARGET_WINDOWS)
   CLog::Log(LOGNOTICE, "Running on %s", g_sysinfo.GetKernelVersion().c_str());
 #endif
@@ -785,6 +795,17 @@
   CEnvironment::setenv("OS", "win32");
 #endif
 
+  // register ffmpeg lockmanager callback
+  av_lockmgr_register(&ffmpeg_lockmgr_cb);
+  // register avcodec
+  avcodec_register_all();
+  // register avformat
+  av_register_all();
+  // register avfilter
+  avfilter_register_all();
+  // set avutil callback
+  av_log_set_callback(ff_avutil_log);
+
   g_powerManager.Initialize();
 
   // Load the AudioEngine before settings as they need to query the engine
@@ -915,7 +936,7 @@
 
   uint32_t sdlFlags = 0;
 
-#if defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)
+#if (defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)) && !defined(HAS_GLX)
   sdlFlags |= SDL_INIT_VIDEO;
 #endif
 
@@ -2311,10 +2332,11 @@
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();
@@ -3612,6 +3634,9 @@
     CAEFactory::Shutdown();
     CAEFactory::UnLoadEngine();
 
+    // unregister ffmpeg lock manager call back
+    av_lockmgr_register(NULL);
+
     CLog::Log(LOGNOTICE, "stopped");
   }
   catch (...)
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cdrip/EncoderFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cdrip/EncoderFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cdrip/EncoderFFmpeg.cpp	2014-08-13 18:26:06.648506729 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cdrip/EncoderFFmpeg.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -58,19 +58,15 @@
 
 bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int iInBits)
 {
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllAvFormat.Load() || !m_dllSwResample.Load()) return false;
-  m_dllAvFormat.av_register_all();
-  m_dllAvCodec.avcodec_register_all();
-
   CStdString filename = URIUtils::GetFileName(strFile);
-  if(m_dllAvFormat.avformat_alloc_output_context2(&m_Format,NULL,NULL,filename.c_str()))
+  if(avformat_alloc_output_context2(&m_Format,NULL,NULL,filename.c_str()))
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Unable to guess the output format for the file %s", filename.c_str());
     return false;
   }
 
   AVCodec *codec;
-  codec = m_dllAvCodec.avcodec_find_encoder(m_Format->oformat->audio_codec);
+  codec = avcodec_find_encoder(m_Format->oformat->audio_codec);
 
   if (!codec)
   {
@@ -78,10 +74,10 @@
     return false;
   }
 
-  m_Format->pb = m_dllAvFormat.avio_alloc_context(m_BCBuffer, sizeof(m_BCBuffer), AVIO_FLAG_WRITE, this,  NULL, avio_write_callback, avio_seek_callback);
+  m_Format->pb = avio_alloc_context(m_BCBuffer, sizeof(m_BCBuffer), AVIO_FLAG_WRITE, this,  NULL, avio_write_callback, avio_seek_callback);
   if (!m_Format->pb)
   {
-    m_dllAvUtil.av_freep(&m_Format);
+    av_freep(&m_Format);
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to allocate ByteIOContext");
     return false;
   }
@@ -89,11 +85,11 @@
   m_Format->bit_rate = CSettings::Get().GetInt("audiocds.bitrate") * 1000;
 
   /* add a stream to it */
-  m_Stream = m_dllAvFormat.avformat_new_stream(m_Format, codec);
+  m_Stream = avformat_new_stream(m_Format, codec);
   if (!m_Stream)
   {
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format);
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to allocate AVStream context");
     return false;
   }
@@ -105,7 +101,7 @@
   m_CodecCtx->bit_rate       = m_Format->bit_rate;
   m_CodecCtx->sample_rate    = iInRate;
   m_CodecCtx->channels       = iInChannels;
-  m_CodecCtx->channel_layout = m_dllAvUtil.av_get_default_channel_layout(iInChannels);
+  m_CodecCtx->channel_layout = av_get_default_channel_layout(iInChannels);
   m_CodecCtx->time_base.num  = 1;
   m_CodecCtx->time_base.den  = iInRate;
   /* Allow experimental encoders (like FFmpeg builtin AAC encoder) */
@@ -123,9 +119,9 @@
     case 16: m_InFormat = AV_SAMPLE_FMT_S16; break;
     case 32: m_InFormat = AV_SAMPLE_FMT_S32; break;
     default:
-      m_dllAvUtil.av_freep(&m_Stream);
-      m_dllAvUtil.av_freep(&m_Format->pb);
-      m_dllAvUtil.av_freep(&m_Format);
+      av_freep(&m_Stream);
+      av_freep(&m_Format->pb);
+      av_freep(&m_Format);
       return false;
   }
 
@@ -134,30 +130,30 @@
 
   m_NeedConversion = (m_OutFormat != m_InFormat);
 
-  if (m_OutFormat <= AV_SAMPLE_FMT_NONE || m_dllAvCodec.avcodec_open2(m_CodecCtx, codec, NULL))
+  if (m_OutFormat <= AV_SAMPLE_FMT_NONE || avcodec_open2(m_CodecCtx, codec, NULL))
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to open the codec %s", codec->long_name ? codec->long_name : codec->name);
-    m_dllAvUtil.av_freep(&m_Stream);
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
+    av_freep(&m_Stream);
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format);
     return false;
   }
 
   /* calculate how many bytes we need per frame */
   m_NeededFrames = m_CodecCtx->frame_size;
-  m_NeededBytes  = m_dllAvUtil.av_samples_get_buffer_size(NULL, iInChannels, m_NeededFrames, m_InFormat, 0);
-  m_Buffer       = (uint8_t*)m_dllAvUtil.av_malloc(m_NeededBytes);
+  m_NeededBytes  = av_samples_get_buffer_size(NULL, iInChannels, m_NeededFrames, m_InFormat, 0);
+  m_Buffer       = (uint8_t*)av_malloc(m_NeededBytes);
   m_BufferSize   = 0;
 
-  m_BufferFrame = m_dllAvCodec.avcodec_alloc_frame();
+  m_BufferFrame = av_frame_alloc();
   if(!m_BufferFrame || !m_Buffer)
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to allocate necessary buffers");
-    if(m_BufferFrame) m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
-    if(m_Buffer) m_dllAvUtil.av_freep(&m_Buffer);
-    m_dllAvUtil.av_freep(&m_Stream);
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
+    if(m_BufferFrame) av_frame_free(&m_BufferFrame);
+    if(m_Buffer) av_freep(&m_Buffer);
+    av_freep(&m_Stream);
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format);
     return false;
   }
 
@@ -165,59 +161,59 @@
   m_BufferFrame->format         = m_InFormat;
   m_BufferFrame->channel_layout = m_CodecCtx->channel_layout;
 
-  m_dllAvCodec.avcodec_fill_audio_frame(m_BufferFrame, iInChannels, m_InFormat, m_Buffer, m_NeededBytes, 0);
+  avcodec_fill_audio_frame(m_BufferFrame, iInChannels, m_InFormat, m_Buffer, m_NeededBytes, 0);
 
   if(m_NeedConversion)
   {
-    m_SwrCtx = m_dllSwResample.swr_alloc_set_opts(NULL,
+    m_SwrCtx = swr_alloc_set_opts(NULL,
                     m_CodecCtx->channel_layout, m_OutFormat, m_CodecCtx->sample_rate,
                     m_CodecCtx->channel_layout, m_InFormat, m_CodecCtx->sample_rate,
                     0, NULL);
-    if(!m_SwrCtx || m_dllSwResample.swr_init(m_SwrCtx) < 0)
+    if(!m_SwrCtx || swr_init(m_SwrCtx) < 0)
     {
       CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to initialize the resampler");
-      m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
-      m_dllAvUtil.av_freep(&m_Buffer);
-      m_dllAvUtil.av_freep(&m_Stream);
-      m_dllAvUtil.av_freep(&m_Format->pb);
-      m_dllAvUtil.av_freep(&m_Format);
+      av_frame_free(&m_BufferFrame);
+      av_freep(&m_Buffer);
+      av_freep(&m_Stream);
+      av_freep(&m_Format->pb);
+      av_freep(&m_Format);
       return false;
     }
 
-    m_ResampledBufferSize = m_dllAvUtil.av_samples_get_buffer_size(NULL, iInChannels, m_NeededFrames, m_OutFormat, 0);
-    m_ResampledBuffer = (uint8_t*)m_dllAvUtil.av_malloc(m_ResampledBufferSize);
-    m_ResampledFrame = m_dllAvCodec.avcodec_alloc_frame();
+    m_ResampledBufferSize = av_samples_get_buffer_size(NULL, iInChannels, m_NeededFrames, m_OutFormat, 0);
+    m_ResampledBuffer = (uint8_t*)av_malloc(m_ResampledBufferSize);
+    m_ResampledFrame = av_frame_alloc();
     if(!m_ResampledBuffer || !m_ResampledFrame)
     {
       CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to allocate a frame for resampling");
-      if (m_ResampledFrame)  m_dllAvCodec.avcodec_free_frame(&m_ResampledFrame);
-      if (m_ResampledBuffer) m_dllAvUtil.av_freep(&m_ResampledBuffer);
-      if (m_SwrCtx)          m_dllSwResample.swr_free(&m_SwrCtx);
-      m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
-      m_dllAvUtil.av_freep(&m_Buffer);
-      m_dllAvUtil.av_freep(&m_Stream);
-      m_dllAvUtil.av_freep(&m_Format->pb);
-      m_dllAvUtil.av_freep(&m_Format);
+      if (m_ResampledFrame)  av_frame_free(&m_ResampledFrame);
+      if (m_ResampledBuffer) av_freep(&m_ResampledBuffer);
+      if (m_SwrCtx)          swr_free(&m_SwrCtx);
+      av_frame_free(&m_BufferFrame);
+      av_freep(&m_Buffer);
+      av_freep(&m_Stream);
+      av_freep(&m_Format->pb);
+      av_freep(&m_Format);
       return false;
     }
     m_ResampledFrame->nb_samples     = m_NeededFrames;
     m_ResampledFrame->format         = m_OutFormat;
     m_ResampledFrame->channel_layout = m_CodecCtx->channel_layout;
-    m_dllAvCodec.avcodec_fill_audio_frame(m_ResampledFrame, iInChannels, m_OutFormat, m_ResampledBuffer, m_ResampledBufferSize, 0);
+    avcodec_fill_audio_frame(m_ResampledFrame, iInChannels, m_OutFormat, m_ResampledBuffer, m_ResampledBufferSize, 0);
   }
 
   /* set input stream information and open the file */
   if (!CEncoder::Init(strFile, iInChannels, iInRate, iInBits))
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to call CEncoder::Init");
-    if (m_ResampledFrame ) m_dllAvCodec.avcodec_free_frame(&m_ResampledFrame);
-    if (m_ResampledBuffer) m_dllAvUtil.av_freep(&m_ResampledBuffer);
-    if (m_SwrCtx)          m_dllSwResample.swr_free(&m_SwrCtx);
-    m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
-    m_dllAvUtil.av_freep(&m_Buffer);
-    m_dllAvUtil.av_freep(&m_Stream);
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
+    if (m_ResampledFrame ) av_frame_free(&m_ResampledFrame);
+    if (m_ResampledBuffer) av_freep(&m_ResampledBuffer);
+    if (m_SwrCtx)          swr_free(&m_SwrCtx);
+    av_frame_free(&m_BufferFrame);
+    av_freep(&m_Buffer);
+    av_freep(&m_Stream);
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format);
     return false;
   }
 
@@ -230,17 +226,17 @@
   SetTag("encoder"     , "XBMC FFmpeg Encoder");
 
   /* write the header */
-  if (m_dllAvFormat.avformat_write_header(m_Format, NULL) != 0)
+  if (avformat_write_header(m_Format, NULL) != 0)
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to write the header");
-    if (m_ResampledFrame ) m_dllAvCodec.avcodec_free_frame(&m_ResampledFrame);
-    if (m_ResampledBuffer) m_dllAvUtil.av_freep(&m_ResampledBuffer);
-    if (m_SwrCtx)          m_dllSwResample.swr_free(&m_SwrCtx);
-    m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
-    m_dllAvUtil.av_freep(&m_Buffer);
-    m_dllAvUtil.av_freep(&m_Stream);
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
+    if (m_ResampledFrame ) av_frame_free(&m_ResampledFrame);
+    if (m_ResampledBuffer) av_freep(&m_ResampledBuffer);
+    if (m_SwrCtx)          swr_free(&m_SwrCtx);
+    av_frame_free(&m_BufferFrame);
+    av_freep(&m_Buffer);
+    av_freep(&m_Stream);
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format);
     return false;
   }
 
@@ -251,7 +247,7 @@
 
 void CEncoderFFmpeg::SetTag(const CStdString tag, const CStdString value)
 {
-  m_dllAvUtil.av_dict_set(&m_Format->metadata, tag.c_str(), value.c_str(), 0);
+  av_dict_set(&m_Format->metadata, tag.c_str(), value.c_str(), 0);
 }
 
 int CEncoderFFmpeg::avio_write_callback(void *opaque, uint8_t *buf, int buf_size)
@@ -296,13 +292,13 @@
   int encoded, got_output;
   AVFrame* frame;
 
-  m_dllAvCodec.av_init_packet(&m_Pkt);
+  av_init_packet(&m_Pkt);
   m_Pkt.data = NULL;
   m_Pkt.size = 0;
 
   if(m_NeedConversion)
   {
-    if (m_dllSwResample.swr_convert(m_SwrCtx, m_ResampledFrame->extended_data, m_NeededFrames, (const uint8_t**)m_BufferFrame->extended_data, m_NeededFrames) < 0)
+    if (swr_convert(m_SwrCtx, m_ResampledFrame->extended_data, m_NeededFrames, (const uint8_t**)m_BufferFrame->extended_data, m_NeededFrames) < 0)
     {
       CLog::Log(LOGERROR, "CEncoderFFmpeg::WriteFrame - Error resampling audio");
       return false;
@@ -311,7 +307,7 @@
   }
   else frame = m_BufferFrame;
 
-  encoded = m_dllAvCodec.avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
+  encoded = avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
 
   m_BufferSize = 0;
 
@@ -323,15 +319,15 @@
   if (got_output)
   {
     if (m_CodecCtx->coded_frame && m_CodecCtx->coded_frame->pts != AV_NOPTS_VALUE)
-      m_Pkt.pts = m_dllAvUtil.av_rescale_q(m_CodecCtx->coded_frame->pts, m_Stream->time_base, m_CodecCtx->time_base);
+      m_Pkt.pts = av_rescale_q(m_CodecCtx->coded_frame->pts, m_Stream->time_base, m_CodecCtx->time_base);
 
-    if (m_dllAvFormat.av_write_frame(m_Format, &m_Pkt) < 0) {
+    if (av_write_frame(m_Format, &m_Pkt) < 0) {
       CLog::Log(LOGERROR, "CEncoderFFMmpeg::WriteFrame - Failed to write the frame data");
       return false;
     }
   }
 
-  m_dllAvCodec.av_free_packet(&m_Pkt);
+  av_free_packet(&m_Pkt);
 
   return true;
 }
@@ -348,34 +344,30 @@
     }
 
     /* Flush if needed */
-    m_dllAvUtil.av_freep(&m_Buffer);
-    m_dllAvCodec.avcodec_free_frame(&m_BufferFrame);
+    av_freep(&m_Buffer);
+    av_frame_free(&m_BufferFrame);
 
-    if (m_SwrCtx)          m_dllSwResample.swr_free(&m_SwrCtx);
-    if (m_ResampledFrame ) m_dllAvCodec.avcodec_free_frame(&m_ResampledFrame);
-    if (m_ResampledBuffer) m_dllAvUtil.av_freep(&m_ResampledBuffer);
+    if (m_SwrCtx)          swr_free(&m_SwrCtx);
+    if (m_ResampledFrame ) av_frame_free(&m_ResampledFrame);
+    if (m_ResampledBuffer) av_freep(&m_ResampledBuffer);
     m_NeedConversion = false;
 
     WriteFrame();
 
     /* write the trailer */
-    m_dllAvFormat.av_write_trailer(m_Format);
+    av_write_trailer(m_Format);
     FlushStream();
     FileClose();
 
     /* cleanup */
-    m_dllAvCodec.avcodec_close(m_CodecCtx);
-    m_dllAvUtil.av_freep(&m_Stream    );
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format    );
+    avcodec_close(m_CodecCtx);
+    av_freep(&m_Stream    );
+    av_freep(&m_Format->pb);
+    av_freep(&m_Format    );
   }
 
   m_BufferSize = 0;
 
-  m_dllAvFormat.Unload();
-  m_dllAvUtil  .Unload();
-  m_dllAvCodec .Unload();
-  m_dllSwResample.Unload();
   return true;
 }
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cdrip/EncoderFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cdrip/EncoderFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cdrip/EncoderFFmpeg.h	2014-08-13 18:26:06.648506729 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cdrip/EncoderFFmpeg.h	2014-08-13 18:27:00.544773981 +0800
@@ -22,10 +22,13 @@
  */
 
 #include "Encoder.h"
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
-#include "DllSwResample.h"
+
+extern "C" {
+#include "libavformat/avformat.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+#include "libswresample/swresample.h"
+}
 
 class CEncoderFFmpeg : public CEncoder
 {
@@ -38,10 +41,6 @@
   void AddTag(int key, const char* value);
 
 private:
-  DllAvCodec  m_dllAvCodec;
-  DllAvUtil   m_dllAvUtil;
-  DllAvFormat m_dllAvFormat;
-  DllSwResample m_dllSwResample;
 
   AVFormatContext  *m_Format;
   AVCodecContext   *m_CodecCtx;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2014-08-13 18:26:07.420510552 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -46,10 +46,10 @@
 CAEEncoderFFmpeg::~CAEEncoderFFmpeg()
 {
   Reset();
-  m_dllAvUtil.av_freep(&m_CodecCtx);
-  m_dllAvUtil.av_freep(&m_ResampBuffer);
+  av_freep(&m_CodecCtx);
+  av_freep(&m_ResampBuffer);
   if (m_SwrCtx)
-    m_dllSwResample.swr_free(&m_SwrCtx);
+    swr_free(&m_SwrCtx);
 }
 
 bool CAEEncoderFFmpeg::IsCompatible(AEAudioFormat format)
@@ -102,11 +102,6 @@
 {
   Reset();
 
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllSwResample.Load())
-    return false;
-
-  m_dllAvCodec.avcodec_register_all();
-
   bool ac3 = CSettings::Get().GetBool("audiooutput.ac3passthrough");
 
   AVCodec *codec = NULL;
@@ -119,7 +114,7 @@
     m_CodecID   = AV_CODEC_ID_DTS;
     m_PackFunc  = &CAEPackIEC61937::PackDTS_1024;
     m_BitRate   = DTS_ENCODE_BITRATE;
-    codec = m_dllAvCodec.avcodec_find_encoder(m_CodecID);
+    codec = avcodec_find_encoder(m_CodecID);
   }
 #endif
 
@@ -130,14 +125,14 @@
     m_CodecID   = AV_CODEC_ID_AC3;
     m_PackFunc  = &CAEPackIEC61937::PackAC3;
     m_BitRate   = AC3_ENCODE_BITRATE;
-    codec = m_dllAvCodec.avcodec_find_encoder(m_CodecID);
+    codec = avcodec_find_encoder(m_CodecID);
   }
 
   /* check we got the codec */
   if (!codec)
     return false;
 
-  m_CodecCtx                 = m_dllAvCodec.avcodec_alloc_context3(codec);
+  m_CodecCtx                 = avcodec_alloc_context3(codec);
   m_CodecCtx->bit_rate       = m_BitRate;
   m_CodecCtx->sample_rate    = format.m_sampleRate;
   m_CodecCtx->channel_layout = AV_CH_LAYOUT_5POINT1_BACK;
@@ -220,9 +215,9 @@
   m_CodecCtx->channels = BuildChannelLayout(m_CodecCtx->channel_layout, m_Layout);
 
   /* open the codec */
-  if (m_dllAvCodec.avcodec_open2(m_CodecCtx, codec, NULL))
+  if (avcodec_open2(m_CodecCtx, codec, NULL))
   {
-    m_dllAvUtil.av_freep(&m_CodecCtx);
+    av_freep(&m_CodecCtx);
     return false;
   }
 
@@ -239,11 +234,11 @@
 
   if (m_NeedConversion)
   {
-    m_SwrCtx = m_dllSwResample.swr_alloc_set_opts(NULL,
+    m_SwrCtx = swr_alloc_set_opts(NULL,
                       m_CodecCtx->channel_layout, m_CodecCtx->sample_fmt, m_CodecCtx->sample_rate,
                       m_CodecCtx->channel_layout, AV_SAMPLE_FMT_FLT, m_CodecCtx->sample_rate,
                       0, NULL);
-    if (!m_SwrCtx || m_dllSwResample.swr_init(m_SwrCtx) < 0)
+    if (!m_SwrCtx || swr_init(m_SwrCtx) < 0)
     {
       CLog::Log(LOGERROR, "CAEEncoderFFmpeg::Initialize - Failed to initialise resampler.");
       return false;
@@ -284,14 +279,14 @@
 
   /* size of the buffer sent to the encoder: either from the input data or after
    * conversion, in all cases it is in the m_CodecCtx->sample_fmt format */
-  int buf_size = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_CodecCtx->channels, frames, m_CodecCtx->sample_fmt, 0);
+  int buf_size = av_samples_get_buffer_size(NULL, m_CodecCtx->channels, frames, m_CodecCtx->sample_fmt, 0);
   assert(buf_size>0);
 
   /* allocate the input frame
    * sadly, we have to alloc/dealloc it everytime since we have no guarantee the
    * data argument will be constant over iterated calls and the frame needs to
    * setup pointers inside data */
-  frame = m_dllAvCodec.avcodec_alloc_frame();
+  frame = av_frame_alloc();
   if (!frame)
     return 0;
 
@@ -303,43 +298,43 @@
   {
     if (!m_ResampBuffer || buf_size > m_ResampBufferSize)
     {
-      m_ResampBuffer = (uint8_t*)m_dllAvUtil.av_realloc(m_ResampBuffer, buf_size);
+      m_ResampBuffer = (uint8_t*)av_realloc(m_ResampBuffer, buf_size);
       if (!m_ResampBuffer)
       {
         CLog::Log(LOGERROR, "CAEEncoderFFmpeg::Encode - Failed to allocate %i bytes buffer for resampling", buf_size);
-        m_dllAvCodec.avcodec_free_frame(&frame);
+        av_frame_free(&frame);
         return 0;
       }
       m_ResampBufferSize = buf_size;
     }
 
-    m_dllAvCodec.avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt, m_ResampBuffer, buf_size, 0);
+    avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt, m_ResampBuffer, buf_size, 0);
 
     /* important note: the '&input' here works because we convert from a packed
      * format (ie, interleaved). If it were to be used to convert from planar
      * formats (ie, non-interleaved, which is not currently supported by AE),
      * we would need to adapt it or it would segfault. */
-    if (m_dllSwResample.swr_convert(m_SwrCtx, frame->extended_data, frames, &input, frames) < 0)
+    if (swr_convert(m_SwrCtx, frame->extended_data, frames, &input, frames) < 0)
     {
       CLog::Log(LOGERROR, "CAEEncoderFFmpeg::Encode - Resampling failed");
-      m_dllAvCodec.avcodec_free_frame(&frame);
+      av_frame_free(&frame);
       return 0;
     }
   }
   else
-    m_dllAvCodec.avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt,
+    avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt,
                     input, buf_size, 0);
 
   /* initialize the output packet */
-  m_dllAvCodec.av_init_packet(&m_Pkt);
+  av_init_packet(&m_Pkt);
   m_Pkt.size      = sizeof(m_Buffer) - IEC61937_DATA_OFFSET;
   m_Pkt.data      = m_Buffer + IEC61937_DATA_OFFSET;
 
   /* encode it */
-  int ret = m_dllAvCodec.avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
+  int ret = avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
 
   /* free temporary data */
-  m_dllAvCodec.avcodec_free_frame(&frame);
+  av_frame_free(&frame);
 
   if (ret < 0 || !got_output)
   {
@@ -356,7 +351,7 @@
   }
 
   /* free the packet */
-  m_dllAvCodec.av_free_packet(&m_Pkt);
+  av_free_packet(&m_Pkt);
 
   /* return the number of frames used */
   return m_NeededFrames;
@@ -374,7 +369,7 @@
    * sadly, we have to alloc/dealloc it everytime since we have no guarantee the
    * data argument will be constant over iterated calls and the frame needs to
    * setup pointers inside data */
-  frame = m_dllAvCodec.avcodec_alloc_frame();
+  frame = av_frame_alloc();
   if (!frame)
     return 0;
 
@@ -382,19 +377,19 @@
   frame->format         = m_CodecCtx->sample_fmt;
   frame->channel_layout = m_CodecCtx->channel_layout;
 
-  m_dllAvCodec.avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt,
+  avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt,
                     in, in_size, 0);
 
   /* initialize the output packet */
-  m_dllAvCodec.av_init_packet(&m_Pkt);
+  av_init_packet(&m_Pkt);
   m_Pkt.size      = out_size - IEC61937_DATA_OFFSET;
   m_Pkt.data      = out + IEC61937_DATA_OFFSET;
 
   /* encode it */
-  int ret = m_dllAvCodec.avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
+  int ret = avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
 
   /* free temporary data */
-  m_dllAvCodec.avcodec_free_frame(&frame);
+  av_frame_free(&frame);
 
   if (ret < 0 || !got_output)
   {
@@ -406,7 +401,7 @@
   m_PackFunc(NULL, m_Pkt.size, out);
 
   /* free the packet */
-  m_dllAvCodec.av_free_packet(&m_Pkt);
+  av_free_packet(&m_Pkt);
 
   /* return the number of frames used */
   return m_NeededFrames;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2014-08-13 18:26:07.424510577 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h	2014-08-13 18:27:00.568774100 +0800
@@ -23,11 +23,12 @@
 #include "cores/AudioEngine/Utils/AERemap.h"
 #include "cores/AudioEngine/Utils/AEPackIEC61937.h"
 
+extern "C" {
+#include "libswresample/swresample.h"
+}
+
 /* ffmpeg re-defines this, so undef it to squash the warning */
 #undef restrict
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-#include "DllSwResample.h"
 
 class CAEEncoderFFmpeg: public IAEEncoder
 {
@@ -48,11 +49,6 @@
   virtual int GetData(uint8_t **data);
   virtual double GetDelay(unsigned int bufferSize);
 private:
-  DllAvCodec  m_dllAvCodec;
-  DllAvFormat m_dllAvFormat;
-  DllAvUtil   m_dllAvUtil;
-  DllSwResample m_dllSwResample;
-
   std::string                m_CodecName;
   AVCodecID                  m_CodecID;
   unsigned int              m_BitRate;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h	2014-08-13 18:26:07.464510775 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h	2014-08-13 18:27:00.572774125 +0800
@@ -19,12 +19,15 @@
  *
  */
 
-#include "DllAvUtil.h"
-#include "DllSwResample.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Interfaces/AE.h"
 #include <deque>
 
+extern "C" {
+#include "libavutil/avutil.h"
+#include "libswresample/swresample.h"
+}
+
 namespace ActiveAE
 {
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp	2014-08-13 18:27:01.628779358 +0800
@@ -30,8 +30,8 @@
 #include "settings/AdvancedSettings.h"
 #include "windowing/WindowingFactory.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 #define MAX_BUFFER_TIME 0.1   // max time of a buffer in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)
@@ -178,10 +178,6 @@
   m_controlPort.Purge();
   m_dataPort.Purge();
   m_sink.Dispose();
-
-  m_dllAvFormat.Unload();
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
 }
 
 //-----------------------------------------------------------------------------
@@ -2055,7 +2051,7 @@
     int available_samples = it->sound->GetSound(false)->nb_samples - it->samples_played;
     int mix_samples = std::min(max_samples, available_samples);
     int start = it->samples_played *
-                m_dllAvUtil.av_get_bytes_per_sample(it->sound->GetSound(false)->config.fmt) *
+                av_get_bytes_per_sample(it->sound->GetSound(false)->config.fmt) *
                 it->sound->GetSound(false)->config.channels /
                 it->sound->GetSound(false)->planes;
 
@@ -2139,13 +2135,6 @@
 
 bool CActiveAE::Initialize()
 {
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllAvFormat.Load())
-  {
-    CLog::Log(LOGERROR,"CActiveAE::Initialize - failed to load ffmpeg libraries");
-    return false;
-  }
-  m_dllAvFormat.av_register_all();
-
   Create();
   Message *reply;
   if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
@@ -2401,19 +2390,19 @@
 uint8_t **CActiveAE::AllocSoundSample(SampleConfig &config, int &samples, int &bytes_per_sample, int &planes, int &linesize)
 {
   uint8_t **buffer;
-  planes = m_dllAvUtil.av_sample_fmt_is_planar(config.fmt) ? config.channels : 1;
+  planes = av_sample_fmt_is_planar(config.fmt) ? config.channels : 1;
   buffer = new uint8_t*[planes];
 
   // align buffer to 16 in order to be compatible with sse in CAEConvert
-  m_dllAvUtil.av_samples_alloc(buffer, &linesize, config.channels,
+  av_samples_alloc(buffer, &linesize, config.channels,
                                  samples, config.fmt, 16);
-  bytes_per_sample = m_dllAvUtil.av_get_bytes_per_sample(config.fmt);
+  bytes_per_sample = av_get_bytes_per_sample(config.fmt);
   return buffer;
 }
 
 void CActiveAE::FreeSoundSample(uint8_t **data)
 {
-  m_dllAvUtil.av_freep(data);
+  av_freep(data);
   delete [] data;
 }
 
@@ -2457,9 +2446,9 @@
   }
   int fileSize = sound->GetFileSize();
 
-  fmt_ctx = m_dllAvFormat.avformat_alloc_context();
-  unsigned char* buffer = (unsigned char*)m_dllAvUtil.av_malloc(SOUNDBUFFER_SIZE+FF_INPUT_BUFFER_PADDING_SIZE);
-  io_ctx = m_dllAvFormat.avio_alloc_context(buffer, SOUNDBUFFER_SIZE, 0,
+  fmt_ctx = avformat_alloc_context();
+  unsigned char* buffer = (unsigned char*)av_malloc(SOUNDBUFFER_SIZE+FF_INPUT_BUFFER_PADDING_SIZE);
+  io_ctx = avio_alloc_context(buffer, SOUNDBUFFER_SIZE, 0,
                                             sound, CActiveAESound::Read, NULL, CActiveAESound::Seek);
   io_ctx->max_packet_size = sound->GetChunkSize();
   if(io_ctx->max_packet_size)
@@ -2470,22 +2459,22 @@
 
   fmt_ctx->pb = io_ctx;
 
-  m_dllAvFormat.av_probe_input_buffer(io_ctx, &io_fmt, file.c_str(), NULL, 0, 0);
+  av_probe_input_buffer(io_ctx, &io_fmt, file.c_str(), NULL, 0, 0);
   if (!io_fmt)
   {
-    m_dllAvFormat.avformat_close_input(&fmt_ctx);
+    avformat_close_input(&fmt_ctx);
     delete sound;
     return NULL;
   }
 
   // find decoder
-  if (m_dllAvFormat.avformat_open_input(&fmt_ctx, file.c_str(), NULL, NULL) == 0)
+  if (avformat_open_input(&fmt_ctx, file.c_str(), NULL, NULL) == 0)
   {
     fmt_ctx->flags |= AVFMT_FLAG_NOPARSE;
-    if (m_dllAvFormat.avformat_find_stream_info(fmt_ctx, NULL) >= 0)
+    if (avformat_find_stream_info(fmt_ctx, NULL) >= 0)
     {
       dec_ctx = fmt_ctx->streams[0]->codec;
-      dec = m_dllAvCodec.avcodec_find_decoder(dec_ctx->codec_id);
+      dec = avcodec_find_decoder(dec_ctx->codec_id);
       config.sample_rate = dec_ctx->sample_rate;
       config.channels = dec_ctx->channels;
       config.channel_layout = dec_ctx->channel_layout;
@@ -2493,39 +2482,39 @@
   }
   if (dec == NULL)
   {
-    m_dllAvFormat.avformat_close_input(&fmt_ctx);
+    avformat_close_input(&fmt_ctx);
     delete sound;
     return NULL;
   }
 
-  dec_ctx = m_dllAvCodec.avcodec_alloc_context3(dec);
+  dec_ctx = avcodec_alloc_context3(dec);
   dec_ctx->sample_rate = config.sample_rate;
   dec_ctx->channels = config.channels;
   if (!config.channel_layout)
-    config.channel_layout = m_dllAvUtil.av_get_default_channel_layout(config.channels);
+    config.channel_layout = av_get_default_channel_layout(config.channels);
   dec_ctx->channel_layout = config.channel_layout;
 
   AVPacket avpkt;
   AVFrame *decoded_frame = NULL;
-  decoded_frame = m_dllAvCodec.avcodec_alloc_frame();
+  decoded_frame = av_frame_alloc();
 
-  if (m_dllAvCodec.avcodec_open2(dec_ctx, dec, NULL) >= 0)
+  if (avcodec_open2(dec_ctx, dec, NULL) >= 0)
   {
     bool init = false;
 
     // decode until eof
-    m_dllAvCodec.av_init_packet(&avpkt);
+    av_init_packet(&avpkt);
     int len;
-    while (m_dllAvFormat.av_read_frame(fmt_ctx, &avpkt) >= 0)
+    while (av_read_frame(fmt_ctx, &avpkt) >= 0)
     {
       int got_frame = 0;
-      len = m_dllAvCodec.avcodec_decode_audio4(dec_ctx, decoded_frame, &got_frame, &avpkt);
+      len = avcodec_decode_audio4(dec_ctx, decoded_frame, &got_frame, &avpkt);
       if (len < 0)
       {
-        m_dllAvCodec.avcodec_close(dec_ctx);
-        m_dllAvUtil.av_free(dec_ctx);
-        m_dllAvUtil.av_free(&decoded_frame);
-        m_dllAvFormat.avformat_close_input(&fmt_ctx);
+        avcodec_close(dec_ctx);
+        av_free(dec_ctx);
+        av_free(&decoded_frame);
+        avformat_close_input(&fmt_ctx);
         delete sound;
         return NULL;
       }
@@ -2533,7 +2522,7 @@
       {
         if (!init)
         {
-          int samples = fileSize / m_dllAvUtil.av_get_bytes_per_sample(dec_ctx->sample_fmt) / config.channels;
+          int samples = fileSize / av_get_bytes_per_sample(dec_ctx->sample_fmt) / config.channels;
           config.fmt = dec_ctx->sample_fmt;
           config.bits_per_sample = dec_ctx->bits_per_coded_sample;
           sound->InitSound(true, config, samples);
@@ -2543,12 +2532,12 @@
                           decoded_frame->nb_samples, decoded_frame->linesize[0]);
       }
     }
-    m_dllAvCodec.avcodec_close(dec_ctx);
+    avcodec_close(dec_ctx);
   }
 
-  m_dllAvUtil.av_free(dec_ctx);
-  m_dllAvUtil.av_free(decoded_frame);
-  m_dllAvFormat.avformat_close_input(&fmt_ctx);
+  av_free(dec_ctx);
+  av_free(decoded_frame);
+  avformat_close_input(&fmt_ctx);
 
   sound->Finish();
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h	2014-08-13 18:27:00.572774125 +0800
@@ -31,9 +31,11 @@
 #include <queue>
 
 // ffmpeg
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
+extern "C" {
+#include "libavformat/avformat.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+}
 
 class IAESink;
 class IAEEncoder;
@@ -347,11 +349,6 @@
   bool m_vizInitialized;
   CCriticalSection m_vizLock;
 
-  // ffmpeg
-  DllAvFormat m_dllAvFormat;
-  DllAvCodec  m_dllAvCodec;
-  DllAvUtil   m_dllAvUtil;
-
   // polled via the interface
   float m_aeVolume;
   bool m_aeMuted;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp	2014-08-13 18:27:00.572774125 +0800
@@ -19,24 +19,26 @@
  */
 
 #include "ActiveAEResample.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
 
 using namespace ActiveAE;
 
 CActiveAEResample::CActiveAEResample()
 {
   m_pContext = NULL;
-  m_loaded = false;
-  if (m_dllAvUtil.Load() && m_dllSwResample.Load())
-    m_loaded = true;
+  m_loaded = true;
 }
 
 CActiveAEResample::~CActiveAEResample()
 {
   if (m_pContext)
-    m_dllSwResample.swr_free(&m_pContext);
-
-  m_dllAvUtil.Unload();
-  m_dllSwResample.Unload();
+    swr_free(&m_pContext);
 }
 
 bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
@@ -56,11 +58,11 @@
   m_src_bits = src_bits;
 
   if (m_dst_chan_layout == 0)
-    m_dst_chan_layout = m_dllAvUtil.av_get_default_channel_layout(m_dst_channels);
+    m_dst_chan_layout = av_get_default_channel_layout(m_dst_channels);
   if (m_src_chan_layout == 0)
-    m_src_chan_layout = m_dllAvUtil.av_get_default_channel_layout(m_src_channels);
+    m_src_chan_layout = av_get_default_channel_layout(m_src_channels);
 
-  m_pContext = m_dllSwResample.swr_alloc_set_opts(NULL, m_dst_chan_layout, m_dst_fmt, m_dst_rate,
+  m_pContext = swr_alloc_set_opts(NULL, m_dst_chan_layout, m_dst_fmt, m_dst_rate,
                                                         m_src_chan_layout, m_src_fmt, m_src_rate,
                                                         0, NULL);
 
@@ -72,24 +74,24 @@
 
   if(quality == AE_QUALITY_HIGH)
   {
-    m_dllAvUtil.av_opt_set_double(m_pContext, "cutoff", 1.0, 0);
-    m_dllAvUtil.av_opt_set_int(m_pContext,"filter_size", 256, 0);
+    av_opt_set_double(m_pContext, "cutoff", 1.0, 0);
+    av_opt_set_int(m_pContext,"filter_size", 256, 0);
   }
   else if(quality == AE_QUALITY_MID)
   {
     // 0.97 is default cutoff so use (1.0 - 0.97) / 2.0 + 0.97
-    m_dllAvUtil.av_opt_set_double(m_pContext, "cutoff", 0.985, 0);
-    m_dllAvUtil.av_opt_set_int(m_pContext,"filter_size", 64, 0);
+    av_opt_set_double(m_pContext, "cutoff", 0.985, 0);
+    av_opt_set_int(m_pContext,"filter_size", 64, 0);
   }
   else if(quality == AE_QUALITY_LOW)
   {
-    m_dllAvUtil.av_opt_set_double(m_pContext, "cutoff", 0.97, 0);
-    m_dllAvUtil.av_opt_set_int(m_pContext,"filter_size", 32, 0);
+    av_opt_set_double(m_pContext, "cutoff", 0.97, 0);
+    av_opt_set_int(m_pContext,"filter_size", 32, 0);
   }
 
   if (m_dst_fmt == AV_SAMPLE_FMT_S32 || m_dst_fmt == AV_SAMPLE_FMT_S32P)
   {
-    m_dllAvUtil.av_opt_set_int(m_pContext, "output_sample_bits", m_dst_bits, 0);
+    av_opt_set_int(m_pContext, "output_sample_bits", m_dst_bits, 0);
   }
 
   // tell resampler to clamp float values
@@ -98,7 +100,7 @@
       (m_src_fmt == AV_SAMPLE_FMT_FLT || m_src_fmt == AV_SAMPLE_FMT_FLTP) &&
       !remapLayout && normalize)
   {
-     m_dllAvUtil.av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
 
   if (remapLayout)
@@ -118,10 +120,10 @@
       }
     }
 
-    m_dllAvUtil.av_opt_set_int(m_pContext, "out_channel_count", m_dst_channels, 0);
-    m_dllAvUtil.av_opt_set_int(m_pContext, "out_channel_layout", m_dst_chan_layout, 0);
+    av_opt_set_int(m_pContext, "out_channel_count", m_dst_channels, 0);
+    av_opt_set_int(m_pContext, "out_channel_layout", m_dst_chan_layout, 0);
 
-    if (m_dllSwResample.swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
     {
       CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
       return false;
@@ -133,7 +135,7 @@
     memset(m_rematrix, 0, sizeof(m_rematrix));
     for (int out=0; out<m_dst_channels; out++)
     {
-      uint64_t out_chan = m_dllAvUtil.av_channel_layout_extract_channel(m_dst_chan_layout, out);
+      uint64_t out_chan = av_channel_layout_extract_channel(m_dst_chan_layout, out);
       switch(out_chan)
       {
         case AV_CH_FRONT_LEFT:
@@ -159,14 +161,14 @@
       }
     }
 
-    if (m_dllSwResample.swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
     {
       CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
       return false;
     }
   }
 
-  if(m_dllSwResample.swr_init(m_pContext) < 0)
+  if(swr_init(m_pContext) < 0)
   {
     CLog::Log(LOGERROR, "CActiveAEResample::Init - init resampler failed");
     return false;
@@ -178,7 +180,7 @@
 {
   if (ratio != 1.0)
   {
-    if (m_dllSwResample.swr_set_compensation(m_pContext,
+    if (swr_set_compensation(m_pContext,
                                             (dst_samples*ratio-dst_samples)*m_dst_rate/m_src_rate,
                                              dst_samples*m_dst_rate/m_src_rate) < 0)
     {
@@ -187,7 +189,7 @@
     }
   }
 
-  int ret = m_dllSwResample.swr_convert(m_pContext, dst_buffer, dst_samples, (const uint8_t**)src_buffer, src_samples);
+  int ret = swr_convert(m_pContext, dst_buffer, dst_samples, (const uint8_t**)src_buffer, src_samples);
   if (ret < 0)
   {
     CLog::Log(LOGERROR, "CActiveAEResample::Resample - resample failed");
@@ -198,28 +200,28 @@
 
 int64_t CActiveAEResample::GetDelay(int64_t base)
 {
-  return m_dllSwResample.swr_get_delay(m_pContext, base);
+  return swr_get_delay(m_pContext, base);
 }
 
 int CActiveAEResample::GetBufferedSamples()
 {
-  return m_dllAvUtil.av_rescale_rnd(m_dllSwResample.swr_get_delay(m_pContext, m_src_rate),
+  return av_rescale_rnd(swr_get_delay(m_pContext, m_src_rate),
                                     m_dst_rate, m_src_rate, AV_ROUND_UP);
 }
 
 int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
 {
-  return m_dllAvUtil.av_rescale_rnd(src_samples, dst_rate, src_rate, AV_ROUND_UP);
+  return av_rescale_rnd(src_samples, dst_rate, src_rate, AV_ROUND_UP);
 }
 
 int CActiveAEResample::GetSrcBufferSize(int samples)
 {
-  return m_dllAvUtil.av_samples_get_buffer_size(NULL, m_src_channels, samples, m_src_fmt, 1);
+  return av_samples_get_buffer_size(NULL, m_src_channels, samples, m_src_fmt, 1);
 }
 
 int CActiveAEResample::GetDstBufferSize(int samples)
 {
-  return m_dllAvUtil.av_samples_get_buffer_size(NULL, m_dst_channels, samples, m_dst_fmt, 1);
+  return av_samples_get_buffer_size(NULL, m_dst_channels, samples, m_dst_fmt, 1);
 }
 
 uint64_t CActiveAEResample::GetAVChannelLayout(CAEChannelInfo &info)
@@ -342,5 +344,5 @@
 
 int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout)
 {
-  return m_dllAvUtil.av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
+  return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
 }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h	2014-08-13 18:26:07.540511147 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h	2014-08-13 18:27:00.572774125 +0800
@@ -19,13 +19,16 @@
  *
  */
 
-#include "DllAvUtil.h"
-#include "DllSwResample.h"
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h"
 #include "cores/AudioEngine/Interfaces/AE.h"
 
+extern "C" {
+#include "libavutil/avutil.h"
+#include "libswresample/swresample.h"
+}
+
 namespace ActiveAE
 {
 
@@ -49,8 +52,6 @@
   int GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout);
 
 protected:
-  DllAvUtil m_dllAvUtil;
-  DllSwResample m_dllSwResample;
   bool m_loaded;
   uint64_t m_src_chan_layout, m_dst_chan_layout;
   int m_src_rate, m_dst_rate;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp	2014-08-13 18:27:00.572774125 +0800
@@ -25,7 +25,10 @@
 #include "ActiveAE.h"
 #include "ActiveAESound.h"
 #include "utils/log.h"
-#include "DllAvUtil.h"
+
+extern "C" {
+#include "libavutil/avutil.h"
+}
 
 using namespace ActiveAE;
 using namespace XFILE;
@@ -151,7 +154,7 @@
   return pFile->Read(buf, size);
 }
 
-offset_t CActiveAESound::Seek(void *h, offset_t pos, int whence)
+int64_t CActiveAESound::Seek(void *h, int64_t pos, int whence)
 {
   CFile* pFile = static_cast<CActiveAESound*>(h)->m_pFile;
   if(whence == AVSEEK_SIZE)
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h	2014-08-13 18:27:00.572774125 +0800
@@ -56,7 +56,7 @@
   bool IsSeekPosible() { return m_isSeekPosible; }
 
   static int Read(void *h, uint8_t* buf, int size);
-  static offset_t Seek(void *h, offset_t pos, int whence);
+  static int64_t Seek(void *h, int64_t pos, int whence);
 
 protected:
   std::string m_filename;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp	2014-08-13 18:26:07.536511132 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp	2014-08-13 18:27:01.716779793 +0800
@@ -276,7 +276,13 @@
       }
     }
     if (!m_inMsgEvent.WaitMSec(200))
+    {
+      double cachetime = GetCacheTime();
+      CSingleLock lock(m_streamLock);
+      CLog::Log(LOGWARNING, "CActiveAEStream::AddData - timeout waiting for buffer, paused: %d, cache time: %f, free buffers: %d",
+                             m_paused, cachetime, m_streamFreeBuffers);
       break;
+    }
   }
   return copied;
 }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2014-08-13 18:26:07.652511702 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h	2014-08-13 18:27:00.572774125 +0800
@@ -19,9 +19,12 @@
  *
  */
 
-#include "DllAvCodec.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
+
 /**
  * IAEEncoder interface for on the fly audio compression
  */
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp	2014-08-13 18:26:07.644511663 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Utils/AEStreamInfo.cpp	2014-08-13 18:27:00.584774180 +0800
@@ -19,6 +19,7 @@
  */
 
 #include "AEStreamInfo.h"
+#include "utils/log.h"
 
 #define IEC61937_PREAMBLE1 0xF872
 #define IEC61937_PREAMBLE2 0x4E1F
@@ -85,13 +86,11 @@
   m_dataIsLE      (false),
   m_packFunc      (NULL)
 {
-  m_dllAvUtil.Load();
-  m_dllAvUtil.av_crc_init(m_crcTrueHD, 0, 16, 0x2D, sizeof(m_crcTrueHD));
+  av_crc_init(m_crcTrueHD, 0, 16, 0x2D, sizeof(m_crcTrueHD));
 }
 
 CAEStreamInfo::~CAEStreamInfo()
 {
-  m_dllAvUtil.Unload();
 }
 
 int CAEStreamInfo::AddData(uint8_t *data, unsigned int size, uint8_t **buffer/* = NULL */, unsigned int *bufferSize/* = 0 */)
@@ -360,7 +359,7 @@
         crc_size = (framesize >> 1) + (framesize >> 3) - 1;
 
       if (crc_size <= size - skip)
-        if (m_dllAvUtil.av_crc(m_dllAvUtil.av_crc_get_table(AV_CRC_16_ANSI), 0, &data[2], crc_size * 2))
+        if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &data[2], crc_size * 2))
           continue;
 
       /* if we get here, we can sync */
@@ -668,7 +667,7 @@
         continue;
 
       /* verify the crc of the audio unit */
-      uint16_t crc = m_dllAvUtil.av_crc(m_crcTrueHD, 0, data + 4, 24);
+      uint16_t crc = av_crc(m_crcTrueHD, 0, data + 4, 24);
       crc ^= (data[29] << 8) | data[28];
       if (((data[31] << 8) | data[30]) != crc)
         continue;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h	2014-08-13 18:26:07.640511648 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/AudioEngine/Utils/AEStreamInfo.h	2014-08-13 18:27:00.584774180 +0800
@@ -26,8 +26,12 @@
 
 /* ffmpeg re-defines this, so undef it to squash the warning */
 #undef restrict
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/crc.h"
+}
 
 class CAEStreamInfo
 {
@@ -67,8 +71,6 @@
   CAEPackIEC61937::PackFunc GetPackFunc      () { return m_packFunc      ; }
   unsigned int              GetBufferSize    () { return m_bufferSize    ; }
 private:
-  DllAvUtil m_dllAvUtil;
-
   uint8_t      m_buffer[MAX_IEC61937_PACKET];
   unsigned int m_bufferSize;
   unsigned int m_skipBytes;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDAudio.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDAudio.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDAudio.h	2014-08-13 18:26:06.804507497 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDAudio.h	2014-08-13 18:27:00.628774402 +0800
@@ -30,7 +30,9 @@
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 class IAEStream;
 
-#include "DllAvCodec.h"
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 
 typedef struct stDVDAudioFrame DVDAudioFrame;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2014-08-13 18:26:06.964508291 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -59,19 +59,14 @@
   AVCodec* pCodec;
   m_bOpenedCodec = false;
 
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllSwResample.Load())
-    return false;
-
-  m_dllAvCodec.avcodec_register_all();
-
-  pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
+  pCodec = avcodec_find_decoder(hints.codec);
   if (!pCodec)
   {
     CLog::Log(LOGDEBUG,"CDVDAudioCodecFFmpeg::Open() Unable to find codec %d", hints.codec);
     return false;
   }
 
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = 1;
@@ -91,7 +86,7 @@
 
   if( hints.extradata && hints.extrasize > 0 )
   {
-    m_pCodecContext->extradata = (uint8_t*)m_dllAvUtil.av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
     if(m_pCodecContext->extradata)
     {
       m_pCodecContext->extradata_size = hints.extrasize;
@@ -99,14 +94,14 @@
     }
   }
 
-  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
+  if (avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDAudioCodecFFmpeg::Open() Unable to open codec");
     Dispose();
     return false;
   }
 
-  m_pFrame1 = m_dllAvCodec.avcodec_alloc_frame();
+  m_pFrame1 = av_frame_alloc();
   m_bOpenedCodec = true;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
 
@@ -115,27 +110,23 @@
 
 void CDVDAudioCodecFFmpeg::Dispose()
 {
-  if (m_pFrame1) m_dllAvUtil.av_free(m_pFrame1);
+  if (m_pFrame1) av_free(m_pFrame1);
   m_pFrame1 = NULL;
 
   if (m_pConvert)
-    m_dllSwResample.swr_free(&m_pConvert);
+    swr_free(&m_pConvert);
 
   if (m_pBuffer2)
-    m_dllAvUtil.av_freep(&m_pBuffer2);
+    av_freep(&m_pBuffer2);
 
   if (m_pCodecContext)
   {
-    if (m_bOpenedCodec) m_dllAvCodec.avcodec_close(m_pCodecContext);
+    if (m_bOpenedCodec) avcodec_close(m_pCodecContext);
     m_bOpenedCodec = false;
-    m_dllAvUtil.av_free(m_pCodecContext);
+    av_free(m_pCodecContext);
     m_pCodecContext = NULL;
   }
 
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
-  m_dllSwResample.Unload();
-
   m_iBufferSize1 = 0;
   m_iBufferSize2 = 0;
   m_iBufferTotalSize2 = 0;
@@ -150,10 +141,10 @@
   m_iBufferSize2 = 0;
 
   AVPacket avpkt;
-  m_dllAvCodec.av_init_packet(&avpkt);
+  av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
-  iBytesUsed = m_dllAvCodec.avcodec_decode_audio4( m_pCodecContext
+  iBytesUsed = avcodec_decode_audio4( m_pCodecContext
                                                  , m_pFrame1
                                                  , &got_frame
                                                  , &avpkt);
@@ -162,7 +153,7 @@
     m_iBufferSize1 = 0;
     return iBytesUsed;
   }
-  m_iBufferSize1 = m_pFrame1->nb_samples * m_pCodecContext->channels * m_dllAvUtil.av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
+  m_iBufferSize1 = m_pFrame1->nb_samples * m_pCodecContext->channels * av_get_bytes_per_sample(m_pCodecContext->sample_fmt);
 
   /* some codecs will attempt to consume more data than what we gave */
   if (iBytesUsed > iSize)
@@ -202,17 +193,17 @@
   if(m_pCodecContext->sample_fmt != AV_SAMPLE_FMT_FLT && m_iBufferSize1 > 0)
   {
     if(m_pConvert && (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
-      m_dllSwResample.swr_free(&m_pConvert);
+      swr_free(&m_pConvert);
 
     if(!m_pConvert)
     {
       m_iSampleFormat = m_pCodecContext->sample_fmt;
-      m_pConvert = m_dllSwResample.swr_alloc_set_opts(NULL,
-                      m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), AV_SAMPLE_FMT_FLT, m_pCodecContext->sample_rate,
-                      m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
+      m_pConvert = swr_alloc_set_opts(NULL,
+                      av_get_default_channel_layout(m_pCodecContext->channels), AV_SAMPLE_FMT_FLT, m_pCodecContext->sample_rate,
+                      av_get_default_channel_layout(m_pCodecContext->channels), m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
                       0, NULL);
 
-      if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+      if(!m_pConvert || swr_init(m_pConvert) < 0)
       {
           CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to convert %d to AV_SAMPLE_FMT_FLT", m_pCodecContext->sample_fmt);
           m_iBufferSize1 = 0;
@@ -221,10 +212,10 @@
       }
     }
 
-    int needed_buf_size = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, AV_SAMPLE_FMT_FLT, 0);
+    int needed_buf_size = av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, AV_SAMPLE_FMT_FLT, 0);
     if(m_iBufferTotalSize2 < needed_buf_size)
     {
-        m_pBuffer2 = (uint8_t*)m_dllAvUtil.av_realloc(m_pBuffer2, needed_buf_size);
+        m_pBuffer2 = (uint8_t*)av_realloc(m_pBuffer2, needed_buf_size);
         if(!m_pBuffer2)
         {
             CLog::Log(LOGERROR, "CDVDAudioCodecFFmpeg::Decode - Unable to allocate a %i bytes buffer for resampling", needed_buf_size);
@@ -237,7 +228,7 @@
     }
 
     int outsamples;
-    outsamples = m_dllSwResample.swr_convert(m_pConvert, &m_pBuffer2, m_iBufferTotalSize2, (const uint8_t**)m_pFrame1->extended_data, m_pFrame1->nb_samples);
+    outsamples = swr_convert(m_pConvert, &m_pBuffer2, m_iBufferTotalSize2, (const uint8_t**)m_pFrame1->extended_data, m_pFrame1->nb_samples);
 
     if(outsamples < 0)
     {
@@ -253,7 +244,7 @@
     }
 
     m_iBufferSize1 = 0;
-    m_iBufferSize2 = m_pFrame1->nb_samples * m_pCodecContext->channels * m_dllAvUtil.av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT);
+    m_iBufferSize2 = m_pFrame1->nb_samples * m_pCodecContext->channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_FLT);
   }
 }
 
@@ -276,7 +267,7 @@
 
 void CDVDAudioCodecFFmpeg::Reset()
 {
-  if (m_pCodecContext) m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
+  if (m_pCodecContext) avcodec_flush_buffers(m_pCodecContext);
   m_iBufferSize1 = 0;
   m_iBufferSize2 = 0;
   m_iBuffered = 0;
@@ -348,7 +339,7 @@
   else
   {
     CLog::Log(LOGINFO, "CDVDAudioCodecFFmpeg::GetChannelMap - FFmpeg reported %d channels, but the layout contains %d ignoring", m_pCodecContext->channels, bits);
-    layout = m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels);
+    layout = av_get_default_channel_layout(m_pCodecContext->channels);
   }
 
   m_channelLayout.Reset();
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2014-08-13 18:26:06.964508291 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h	2014-08-13 18:27:00.632774417 +0800
@@ -21,10 +21,13 @@
  */
 
 #include "DVDAudioCodec.h"
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-#include "DllAvUtil.h"
-#include "DllSwResample.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libswresample/swresample.h"
+}
 
 class CDVDAudioCodecFFmpeg : public CDVDAudioCodec
 {
@@ -63,10 +66,6 @@
   int      m_channels;
   uint64_t m_layout;
 
-  DllAvCodec m_dllAvCodec;
-  DllAvUtil m_dllAvUtil;
-  DllSwResample m_dllSwResample;
-
   void BuildChannelMap();
   void ConvertToFloat();  
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2014-08-13 18:26:07.048508712 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h	2014-08-13 18:27:00.628774402 +0800
@@ -30,7 +30,10 @@
   #include "config.h"
 #endif
 #include <vector>
-#include "DllAvCodec.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 
 struct AVStream;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2014-08-13 18:26:06.964508291 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	2014-08-13 18:27:01.708779758 +0800
@@ -23,7 +23,21 @@
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/log.h"
 #include "utils/fastmemcpy.h"
-#include "DllSwScale.h"
+#include "cores/FFmpeg.h"
+
+#ifdef TARGET_WINDOWS
+#pragma comment(lib, "avcodec.lib")
+#pragma comment(lib, "avfilter.lib")
+#pragma comment(lib, "avformat.lib")
+#pragma comment(lib, "avutil.lib")
+#pragma comment(lib, "postproc.lib")
+#pragma comment(lib, "swresample.lib")
+#pragma comment(lib, "swscale.lib")
+#endif
+
+extern "C" {
+#include "libswscale/swscale.h"
+}
 
 // allocate a new picture (PIX_FMT_YUV420P)
 DVDVideoPicture* CDVDCodecUtils::AllocatePicture(int iWidth, int iHeight)
@@ -241,12 +255,6 @@
 
       //if this is going to be used for anything else than testing the renderer
       //the library should not be loaded on every function call
-      DllSwScale  dllSwScale;
-      if (!dllSwScale.Load())
-      {
-        CLog::Log(LOGERROR,"CDVDCodecUtils::ConvertToYUY2Picture - failed to load rescale libraries!");
-      }
-      else
       {
         // Perform the scaling.
         uint8_t* src[] =       { pSrc->data[0],          pSrc->data[1],      pSrc->data[2],      NULL };
@@ -260,11 +268,11 @@
         else
           dstformat = PIX_FMT_YUYV422;
 
-        struct SwsContext *ctx = dllSwScale.sws_getContext(pSrc->iWidth, pSrc->iHeight, PIX_FMT_YUV420P,
-                                                           pPicture->iWidth, pPicture->iHeight, dstformat,
+        struct SwsContext *ctx = sws_getContext(pSrc->iWidth, pSrc->iHeight, PIX_FMT_YUV420P,
+                                                           pPicture->iWidth, pPicture->iHeight, (AVPixelFormat)dstformat,
                                                            SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
-        dllSwScale.sws_scale(ctx, src, srcStride, 0, pSrc->iHeight, dst, dstStride);
-        dllSwScale.sws_freeContext(ctx);
+        sws_scale(ctx, src, srcStride, 0, pSrc->iHeight, dst, dstStride);
+        sws_freeContext(ctx);
       }
     }
     else
@@ -456,6 +464,7 @@
 ,  { PIX_FMT_YUV420P16,   RENDER_FMT_YUV420P16  }
 ,  { PIX_FMT_UYVY422,     RENDER_FMT_UYVY422    }
 ,  { PIX_FMT_YUYV422,     RENDER_FMT_YUYV422    }
+,  { PIX_FMT_NV12,        RENDER_FMT_NV12       }
 ,  { PIX_FMT_VAAPI_VLD,   RENDER_FMT_VAAPI      }
 ,  { PIX_FMT_DXVA2_VLD,   RENDER_FMT_DXVA       }
 ,  { PIX_FMT_NONE     ,   RENDER_FMT_NONE       }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2014-08-13 18:26:06.960508276 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp	2014-08-13 18:27:00.636774442 +0800
@@ -45,18 +45,14 @@
 
 bool CDVDOverlayCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load()) return false;
-
-  m_dllAvCodec.avcodec_register_all();
-
-  AVCodec* pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
+  AVCodec* pCodec = avcodec_find_decoder(hints.codec);
   if (!pCodec)
   {
     CLog::Log(LOGDEBUG,"%s - Unable to find codec %d", __FUNCTION__, hints.codec);
     return false;
   }
 
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = FF_BUG_AUTODETECT;
@@ -69,7 +65,7 @@
   if( hints.extradata && hints.extrasize > 0 )
   {
     m_pCodecContext->extradata_size = hints.extrasize;
-    m_pCodecContext->extradata = (uint8_t*)m_dllAvUtil.av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
 
     // start parsing of extra data - create a copy to be safe and make it zero-terminating to avoid access violations!
@@ -110,7 +106,7 @@
     delete[] parse_extra;
   }
 
-  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
+  if (avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to open codec");
     return false;
@@ -123,14 +119,11 @@
 {
   if (m_pCodecContext)
   {
-    if (m_pCodecContext->codec) m_dllAvCodec.avcodec_close(m_pCodecContext);
-    m_dllAvUtil.av_free(m_pCodecContext);
+    if (m_pCodecContext->codec) avcodec_close(m_pCodecContext);
+    av_free(m_pCodecContext);
     m_pCodecContext = NULL;
   }
   FreeSubtitle(m_Subtitle);
-
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
 }
 
 void CDVDOverlayCodecFFmpeg::FreeSubtitle(AVSubtitle& sub)
@@ -139,13 +132,13 @@
   {
     if(sub.rects[i])
     {
-      m_dllAvUtil.av_free(sub.rects[i]->pict.data[0]);
-      m_dllAvUtil.av_free(sub.rects[i]->pict.data[1]);
-      m_dllAvUtil.av_freep(&sub.rects[i]);
+      av_free(sub.rects[i]->pict.data[0]);
+      av_free(sub.rects[i]->pict.data[1]);
+      av_freep(&sub.rects[i]);
     }
   }
   if(sub.rects)
-    m_dllAvUtil.av_freep(&sub.rects);
+    av_freep(&sub.rects);
   sub.num_rects = 0;
   sub.start_display_time = 0;
   sub.end_display_time = 0;
@@ -161,13 +154,13 @@
   FreeSubtitle(m_Subtitle);
 
   AVPacket avpkt;
-  m_dllAvCodec.av_init_packet(&avpkt);
+  av_init_packet(&avpkt);
   avpkt.data = pPacket->pData;
   avpkt.size = pPacket->iSize;
   avpkt.pts = pPacket->pts == DVD_NOPTS_VALUE ? AV_NOPTS_VALUE : (int64_t)pPacket->pts;
   avpkt.dts = pPacket->dts == DVD_NOPTS_VALUE ? AV_NOPTS_VALUE : (int64_t)pPacket->dts;
 
-  len = m_dllAvCodec.avcodec_decode_subtitle2(m_pCodecContext, &m_Subtitle, &gotsub, &avpkt);
+  len = avcodec_decode_subtitle2(m_pCodecContext, &m_Subtitle, &gotsub, &avpkt);
 
   if (len < 0)
   {
@@ -216,7 +209,7 @@
   FreeSubtitle(m_Subtitle);
   m_SubtitleIndex = -1;
 
-  m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
+  avcodec_flush_buffers(m_pCodecContext);
 }
 
 CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
@@ -309,9 +302,9 @@
     for(int i=0;i<rect.nb_colors;i++)
       overlay->palette[i] = Endian_SwapLE32(((uint32_t *)rect.pict.data[1])[i]);
 
-    m_dllAvUtil.av_free(rect.pict.data[0]);
-    m_dllAvUtil.av_free(rect.pict.data[1]);
-    m_dllAvUtil.av_freep(&m_Subtitle.rects[m_SubtitleIndex]);
+    av_free(rect.pict.data[0]);
+    av_free(rect.pict.data[1]);
+    av_freep(&m_Subtitle.rects[m_SubtitleIndex]);
     m_SubtitleIndex++;
 
     return overlay;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h	2014-08-13 18:26:06.960508276 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.h	2014-08-13 18:27:00.636774442 +0800
@@ -21,8 +21,11 @@
  */
 
 #include "DVDOverlayCodec.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+}
 
 class CDVDOverlaySpu;
 class CDVDOverlayText;
@@ -50,8 +53,4 @@
 
   int             m_width;
   int             m_height;
-
-  DllAvCodec      m_dllAvCodec;
-  DllAvUtil       m_dllAvUtil;
-
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h	2014-08-13 18:26:06.960508276 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecText.h	2014-08-13 18:27:00.636774442 +0800
@@ -21,7 +21,7 @@
  */
 
 #include "DVDOverlayCodec.h"
-#include "DllAvCodec.h"
+#include "libavcodec/avcodec.h"
 
 class CDVDOverlayText;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2014-08-13 18:26:06.896507958 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/CrystalHD.cpp	2014-08-13 18:27:00.640774457 +0800
@@ -36,9 +36,12 @@
 #include "threads/Thread.h"
 #include "utils/log.h"
 #include "utils/fastmemcpy.h"
-#include "DllSwScale.h"
+extern "C" {
+#include "libswscale/swscale.h"
+}
 #include "utils/TimeUtils.h"
 #include "windowing/WindowingFactory.h"
+#include "cores/FFmpeg.h"
 
 namespace BCM
 {
@@ -248,7 +251,6 @@
   int                 m_aspectratio_x;
   int                 m_aspectratio_y;
   CEvent              m_ready_event;
-  DllSwScale          *m_dllSwScale;
   struct SwsContext   *m_sw_scale_ctx;
 };
 
@@ -348,9 +350,6 @@
   m_aspectratio_y(1)
 {
   m_sw_scale_ctx = NULL;
-  m_dllSwScale = new DllSwScale;
-  m_dllSwScale->Load();
-
   
   if (g_Windowing.GetRenderQuirks() & RENDER_QUIRKS_YV12_PREFERED)
     m_output_YV12 = true;
@@ -366,8 +365,7 @@
     delete m_FreeList.Pop();
     
   if (m_sw_scale_ctx)
-    m_dllSwScale->sws_freeContext(m_sw_scale_ctx);
-  delete m_dllSwScale;
+    sws_freeContext(m_sw_scale_ctx);
 }
 
 unsigned int CMPCOutputThread::GetReadyCount(void)
@@ -949,11 +947,11 @@
                   uint8_t* dst[] =       { pBuffer->m_y_buffer_ptr, pBuffer->m_u_buffer_ptr, pBuffer->m_v_buffer_ptr, NULL };
                   int      dstStride[] = { pBuffer->m_width, pBuffer->m_width/2, pBuffer->m_width/2, 0 };
 
-                  m_sw_scale_ctx = m_dllSwScale->sws_getCachedContext(m_sw_scale_ctx,
+                  m_sw_scale_ctx = sws_getCachedContext(m_sw_scale_ctx,
                     pBuffer->m_width, pBuffer->m_height, PIX_FMT_YUYV422,
                     pBuffer->m_width, pBuffer->m_height, PIX_FMT_YUV420P,
                     SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
-                  m_dllSwScale->sws_scale(m_sw_scale_ctx, src, srcStride, 0, pBuffer->m_height, dst, dstStride);
+                  sws_scale(m_sw_scale_ctx, src, srcStride, 0, pBuffer->m_height, dst, dstStride);
                 }
               break;
               default:
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2014-08-13 18:26:06.832507641 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCrystalHD.cpp	2014-08-13 18:27:00.640774457 +0800
@@ -22,7 +22,9 @@
   #include "config.h"
 #elif defined(TARGET_WINDOWS)
 #include "system.h"
-#include "DllAvCodec.h"
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 #endif
 
 #if defined(HAVE_LIBCRYSTALHD)
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2014-08-13 18:26:06.896507958 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2014-08-13 18:27:01.712779774 +0800
@@ -38,6 +38,7 @@
 #include "utils/log.h"
 #include "boost/shared_ptr.hpp"
 #include "threads/Atomics.h"
+#include "settings/MediaSettings.h"
 
 #ifndef TARGET_POSIX
 #define RINT(x) ((x) >= 0 ? ((int)((x) + 0.5)) : ((int)((x) - 0.5)))
@@ -63,6 +64,13 @@
 #endif
 #include "utils/StringUtils.h"
 
+extern "C" {
+#include "libavutil/opt.h"
+#include "libavfilter/avfilter.h"
+#include "libavfilter/buffersink.h"
+#include "libavfilter/buffersrc.h"
+}
+
 using namespace boost;
 
 enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
@@ -72,7 +80,7 @@
 
   // if frame threading is enabled hw accel is not allowed
   if((EDECODEMETHOD) CSettings::Get().GetInt("videoplayer.decodingmethod") != VS_DECODEMETHOD_HARDWARE || !ctx->IsHardwareAllowed())
-    return ctx->m_dllAvCodec.avcodec_default_get_format(avctx, fmt);
+    return avcodec_default_get_format(avctx, fmt);
 
   const PixelFormat * cur = fmt;
   while(*cur != PIX_FMT_NONE)
@@ -134,7 +142,7 @@
 #endif
     cur++;
   }
-  return ctx->m_dllAvCodec.avcodec_default_get_format(avctx, fmt);
+  return avcodec_default_get_format(avctx, fmt);
 }
 
 CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
@@ -144,11 +152,7 @@
   m_pFilterGraph  = NULL;
   m_pFilterIn     = NULL;
   m_pFilterOut    = NULL;
-#if defined(LIBAVFILTER_AVFRAME_BASED)
   m_pFilterFrame  = NULL;
-#else
-  m_pBufferRef    = NULL;
-#endif
 
   m_iPictureWidth = 0;
   m_iPictureHeight = 0;
@@ -159,11 +163,13 @@
   m_iScreenHeight = 0;
   m_iOrientation = 0;
   m_bSoftware = false;
-  m_isHi10p = false;
+  m_isSWCodec = false;
   m_pHardware = NULL;
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_interlace = false;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -175,16 +181,6 @@
 {
   AVCodec* pCodec;
 
-  if(!m_dllAvUtil.Load()
-  || !m_dllAvCodec.Load()
-  || !m_dllSwScale.Load()
-  || !m_dllPostProc.Load()
-  || !m_dllAvFilter.Load()
-  ) return false;
-
-  m_dllAvCodec.avcodec_register_all();
-  m_dllAvFilter.avfilter_register_all();
-
   m_bSoftware     = hints.software;
   m_iOrientation  = hints.orientation;
 
@@ -213,13 +209,15 @@
       // this is needed to not open the decoders
       m_bSoftware = true;
       // this we need to enable multithreading for hi10p via advancedsettings
-      m_isHi10p = true;
+      m_isSWCodec = true;
       break;
     }
   }
+  else if (hints.codec == AV_CODEC_ID_HEVC)
+    m_isSWCodec = true;
 
   if(pCodec == NULL)
-    pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
+    pCodec = avcodec_find_decoder(hints.codec);
 
   if(pCodec == NULL)
   {
@@ -230,7 +228,7 @@
   CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open() Using codec: %s",pCodec->long_name ? pCodec->long_name : pCodec->name);
 
   if(m_pCodecContext == NULL)
-    m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
+    m_pCodecContext = avcodec_alloc_context3(pCodec);
 
   m_pCodecContext->opaque = (void*)this;
   m_pCodecContext->debug_mv = 0;
@@ -242,12 +240,12 @@
    * sensitive to changes in frame sizes, and it causes crashes
    * during HW accell - so we unset it in this case.
    *
-   * When we detect Hi10p and user did not disable hi10pmultithreading
+   * When we detect a pure SW codec and user did not disable SWmultithreading
    * via advancedsettings.xml we keep the ffmpeg default thread type.
    * */
-  if(m_isHi10p && !g_advancedSettings.m_videoDisableHi10pMultithreading)
+  if(m_isSWCodec && !g_advancedSettings.m_videoDisableSWMultithreading)
   {
-    CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Keep default threading for Hi10p: %d",
+    CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Keep default threading for swcodec: %d",
                         m_pCodecContext->thread_type);
   }
   else if ((EDECODEMETHOD) CSettings::Get().GetInt("videoplayer.decodingmethod") == VS_DECODEMETHOD_SOFTWARE && CSettings::Get().GetBool("videoplayer.useframemtdec"))
@@ -276,7 +274,7 @@
   if( hints.extradata && hints.extrasize > 0 )
   {
     m_pCodecContext->extradata_size = hints.extrasize;
-    m_pCodecContext->extradata = (uint8_t*)m_dllAvUtil.av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
   }
 
@@ -293,28 +291,27 @@
     if (it->m_name == "surfaces")
       m_uSurfacesCount = std::atoi(it->m_value.c_str());
     else
-      m_dllAvUtil.av_opt_set(m_pCodecContext, it->m_name.c_str(), it->m_value.c_str(), 0);
+      av_opt_set(m_pCodecContext, it->m_name.c_str(), it->m_value.c_str(), 0);
   }
 
   int num_threads = std::min(8 /*MAX_THREADS*/, g_cpuInfo.getCPUCount());
   if( num_threads > 1 && !hints.software && m_pHardware == NULL // thumbnail extraction fails when run threaded
   && ( pCodec->id == AV_CODEC_ID_H264
-    || pCodec->id == AV_CODEC_ID_MPEG4 ))
+    || pCodec->id == AV_CODEC_ID_MPEG4
+    || pCodec->id == AV_CODEC_ID_HEVC))
     m_pCodecContext->thread_count = num_threads;
 
-  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
+  if (avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to open codec");
     return false;
   }
 
-  m_pFrame = m_dllAvCodec.avcodec_alloc_frame();
+  m_pFrame = av_frame_alloc();
   if (!m_pFrame) return false;
 
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  m_pFilterFrame = m_dllAvUtil.av_frame_alloc();
+  m_pFilterFrame = av_frame_alloc();
   if (!m_pFilterFrame) return false;
-#endif
 
   UpdateName();
   return true;
@@ -322,39 +319,40 @@
 
 void CDVDVideoCodecFFmpeg::Dispose()
 {
-  if (m_pFrame) m_dllAvUtil.av_free(m_pFrame);
+  if (m_pFrame) av_free(m_pFrame);
   m_pFrame = NULL;
 
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  m_dllAvUtil.av_frame_free(&m_pFilterFrame);
-#endif
+  av_frame_free(&m_pFilterFrame);
 
   if (m_pCodecContext)
   {
-    if (m_pCodecContext->codec) m_dllAvCodec.avcodec_close(m_pCodecContext);
+    if (m_pCodecContext->codec) avcodec_close(m_pCodecContext);
     if (m_pCodecContext->extradata)
     {
-      m_dllAvUtil.av_free(m_pCodecContext->extradata);
+      av_free(m_pCodecContext->extradata);
       m_pCodecContext->extradata = NULL;
       m_pCodecContext->extradata_size = 0;
     }
-    m_dllAvUtil.av_free(m_pCodecContext);
+    av_free(m_pCodecContext);
     m_pCodecContext = NULL;
   }
   SAFE_RELEASE(m_pHardware);
 
   FilterClose();
-
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
-  m_dllAvFilter.Unload();
-  m_dllPostProc.Unload();
 }
 
 void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -379,7 +377,7 @@
 {
   m_filters_next.clear();
 
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     return 0;
 
   if(flags & FILTER_ROTATE)
@@ -453,10 +451,10 @@
     if(section)
       lock = shared_ptr<CSingleLock>(new CSingleLock(*section));
 
-    int result;
+    int result = 0;
     if(pData)
       result = m_pHardware->Check(m_pCodecContext);
-    else
+    else if (!m_pHardware->UseFilter())
       result = m_pHardware->Decode(m_pCodecContext, NULL);
 
     if(result)
@@ -476,13 +474,21 @@
   m_pCodecContext->reordered_opaque = pts_dtoi(pts);
 
   AVPacket avpkt;
-  m_dllAvCodec.av_init_packet(&avpkt);
+  av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
+#define SET_PKT_TS(ts) \
+  if(ts != DVD_NOPTS_VALUE)\
+    avpkt.ts = (ts / DVD_TIME_BASE) * AV_TIME_BASE;\
+  else\
+    avpkt.ts = AV_NOPTS_VALUE
+  SET_PKT_TS(pts);
+  SET_PKT_TS(dts);
+#undef SET_PKT_TS
   /* We lie, but this flag is only used by pngdec.c.
    * Setting it correctly would allow CorePNG decoding. */
   avpkt.flags = AV_PKT_FLAG_KEY;
-  len = m_dllAvCodec.avcodec_decode_video2(m_pCodecContext, m_pFrame, &iGotPicture, &avpkt);
+  len = avcodec_decode_video2(m_pCodecContext, m_pFrame, &iGotPicture, &avpkt);
 
   if(m_iLastKeyframe < m_pCodecContext->has_b_frames + 2)
     m_iLastKeyframe = m_pCodecContext->has_b_frames + 2;
@@ -511,19 +517,60 @@
   || m_pCodecContext->codec_id == AV_CODEC_ID_SVQ3)
     m_started = true;
 
-  if(m_pHardware == NULL)
+  m_interlace = m_pFrame->interlaced_frame;
+
+  if(m_pHardware == NULL || m_pHardware->UseFilter())
   {
+    if (m_pHardware)
+    {
+      m_pFrame->pkt_dts = pts_dtoi(m_dts);
+      int result = m_pHardware->Decode(m_pCodecContext, m_pFrame);
+      if (result == VC_BUFFER || result == VC_ERROR)
+        return result;
+      m_pHardware->MapFrame(m_pCodecContext, m_pFrame);
+      m_dts = pts_itod(m_pFrame->pkt_dts);
+      m_pFrame->pkt_dts = 0;
+    }
+
     bool need_scale = std::find( m_formats.begin()
                                , m_formats.end()
-                               , m_pCodecContext->pix_fmt) == m_formats.end();
+                               , m_pFrame->format) == m_formats.end();
 
     bool need_reopen  = false;
+
+
+    // ask codec to do deinterlacing if possible
+    EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+    EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
+
+    unsigned int mFilters = 0;
+
+    if (mDeintMode != VS_DEINTERLACEMODE_OFF)
+    {
+      if (mDeintMode == VS_DEINTERLACEMODE_FORCE ||
+          m_pFrame->interlaced_frame)
+      {
+        if (mInt == VS_INTERLACEMETHOD_DEINTERLACE)
+          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY;
+        else if(mInt == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
+          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY | CDVDVideoCodec::FILTER_DEINTERLACE_HALFED;
+
+        if (mDeintMode == VS_DEINTERLACEMODE_AUTO && mFilters)
+          mFilters |=  CDVDVideoCodec::FILTER_DEINTERLACE_FLAGGED;
+      }
+    }
+
+    if (!g_renderManager.Supports(RENDERFEATURE_ROTATION))
+      mFilters |= CDVDVideoCodec::FILTER_ROTATE;
+
+    SetFilters(mFilters);
+
     if(!m_filters.Equals(m_filters_next))
       need_reopen = true;
 
     if(m_pFilterIn)
     {
-      if(m_pFilterIn->outputs[0]->format != m_pCodecContext->pix_fmt
+      if(m_pFilterIn->outputs[0]->format != m_pFrame->format
       || m_pFilterIn->outputs[0]->w      != m_pCodecContext->width
       || m_pFilterIn->outputs[0]->h      != m_pCodecContext->height)
         need_reopen = true;
@@ -540,7 +587,7 @@
   }
 
   int result;
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     result = m_pHardware->Decode(m_pCodecContext, m_pFrame);
   else if(m_pFilterGraph)
     result = FilterProcess(m_pFrame);
@@ -556,8 +603,9 @@
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
-  m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
+  avcodec_flush_buffers(m_pCodecContext);
 
   if (m_pHardware)
     m_pHardware->Reset();
@@ -571,14 +619,6 @@
   pDvdVideoPicture->iWidth = m_pFrame->width;
   pDvdVideoPicture->iHeight = m_pFrame->height;
 
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  if(m_pBufferRef)
-  {
-    pDvdVideoPicture->iWidth  = m_pBufferRef->video->w;
-    pDvdVideoPicture->iHeight = m_pBufferRef->video->h;
-  }
-#endif
-
   /* crop of 10 pixels if demuxer asked it */
   if(m_pCodecContext->coded_width  && m_pCodecContext->coded_width  < (int)pDvdVideoPicture->iWidth
                                    && m_pCodecContext->coded_width  > (int)pDvdVideoPicture->iWidth  - 10)
@@ -592,10 +632,6 @@
 
   /* use variable in the frame */
   AVRational pixel_aspect = m_pFrame->sample_aspect_ratio;
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  if (m_pBufferRef)
-    pixel_aspect = m_pBufferRef->video->sample_aspect_ratio;
-#endif
 
   if (pixel_aspect.num == 0)
     aspect_ratio = 0;
@@ -620,7 +656,7 @@
   if (!m_pFrame)
     return false;
 
-  AVDictionaryEntry * entry = m_dllAvUtil.av_dict_get(m_dllAvCodec.av_frame_get_metadata(m_pFrame), "stereo_mode", NULL, 0);
+  AVDictionaryEntry * entry = av_dict_get(av_frame_get_metadata(m_pFrame), "stereo_mode", NULL, 0);
   if(entry && entry->value)
   {
     strncpy(pDvdVideoPicture->stereo_mode, (const char*)entry->value, sizeof(pDvdVideoPicture->stereo_mode));
@@ -635,16 +671,17 @@
   pDvdVideoPicture->chroma_position = m_pCodecContext->chroma_sample_location;
   pDvdVideoPicture->color_primaries = m_pCodecContext->color_primaries;
   pDvdVideoPicture->color_transfer = m_pCodecContext->color_trc;
+  pDvdVideoPicture->color_matrix = m_pCodecContext->colorspace;
   if(m_pCodecContext->color_range == AVCOL_RANGE_JPEG
   || m_pCodecContext->pix_fmt     == PIX_FMT_YUVJ420P)
     pDvdVideoPicture->color_range = 1;
   else
     pDvdVideoPicture->color_range = 0;
 
-  pDvdVideoPicture->qscale_table = m_pFrame->qscale_table;
-  pDvdVideoPicture->qscale_stride = m_pFrame->qstride;
+  int qscale_type;
+  pDvdVideoPicture->qp_table = av_frame_get_qp_table(m_pFrame, &pDvdVideoPicture->qstride, &qscale_type);
 
-  switch (m_pFrame->qscale_type) {
+  switch (qscale_type) {
   case FF_QSCALE_TYPE_MPEG1:
     pDvdVideoPicture->qscale_type = DVP_QSCALE_MPEG1;
     break;
@@ -658,13 +695,43 @@
     pDvdVideoPicture->qscale_type = DVP_QSCALE_UNKNOWN;
   }
 
-  pDvdVideoPicture->dts = m_dts;
+  if (pDvdVideoPicture->iRepeatPicture)
+    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  else
+    pDvdVideoPicture->dts = m_dts;
+
   m_dts = DVD_NOPTS_VALUE;
-  if (m_pFrame->reordered_opaque)
-    pDvdVideoPicture->pts = pts_itod(m_pFrame->reordered_opaque);
+
+  int64_t bpts = av_frame_get_best_effort_timestamp(m_pFrame);
+  if(bpts != AV_NOPTS_VALUE)
+  {
+    pDvdVideoPicture->pts = (double)bpts * DVD_TIME_BASE / AV_TIME_BASE;
+    if (pDvdVideoPicture->pts == m_decoderPts)
+    {
+      pDvdVideoPicture->iRepeatPicture = -0.5;
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+      pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+    }
+  }
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -673,7 +740,7 @@
 
 bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  if(m_pHardware)
+  if(m_pHardware && !m_pHardware->UseFilter())
     return m_pHardware->GetPicture(m_pCodecContext, m_pFrame, pDvdVideoPicture);
 
   if(!GetPictureCommon(pDvdVideoPicture))
@@ -690,21 +757,16 @@
   pDvdVideoPicture->extended_format = 0;
 
   PixelFormat pix_fmt;
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  if(m_pBufferRef)
-    pix_fmt = (PixelFormat)m_pBufferRef->format;
-  else
-#endif
-    pix_fmt = (PixelFormat)m_pFrame->format;
+  pix_fmt = (PixelFormat)m_pFrame->format;
 
   pDvdVideoPicture->format = CDVDCodecUtils::EFormatFromPixfmt(pix_fmt);
+
   return true;
 }
 
 int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters, bool scale)
 {
   int result;
-  AVBufferSinkParams *buffersink_params;
 
   if (m_pFilterGraph)
     FilterClose();
@@ -712,88 +774,81 @@
   if (filters.empty() && !scale)
     return 0;
 
-  if (m_pHardware)
+  if (m_pHardware && !m_pHardware->UseFilter())
   {
     CLog::Log(LOGWARNING, "CDVDVideoCodecFFmpeg::FilterOpen - skipped opening filters on hardware decode");
     return 0;
   }
 
-  if (!(m_pFilterGraph = m_dllAvFilter.avfilter_graph_alloc()))
+  if (!(m_pFilterGraph = avfilter_graph_alloc()))
   {
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - unable to alloc filter graph");
     return -1;
   }
 
-  AVFilter* srcFilter = m_dllAvFilter.avfilter_get_by_name("buffer");
-  AVFilter* outFilter = m_dllAvFilter.avfilter_get_by_name("buffersink"); // should be last filter in the graph for now
+  AVFilter* srcFilter = avfilter_get_by_name("buffer");
+  AVFilter* outFilter = avfilter_get_by_name("buffersink"); // should be last filter in the graph for now
 
   CStdString args = StringUtils::Format("%d:%d:%d:%d:%d:%d:%d",
                                         m_pCodecContext->width,
                                         m_pCodecContext->height,
-                                        m_pCodecContext->pix_fmt,
+                                        m_pFrame->format,
                                         m_pCodecContext->time_base.num,
                                         m_pCodecContext->time_base.den,
                                         m_pCodecContext->sample_aspect_ratio.num,
                                         m_pCodecContext->sample_aspect_ratio.den);
 
-  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterIn, srcFilter, "src", args, NULL, m_pFilterGraph)) < 0)
+  if ((result = avfilter_graph_create_filter(&m_pFilterIn, srcFilter, "src", args, NULL, m_pFilterGraph)) < 0)
   {
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_create_filter: src");
     return result;
   }
 
-  buffersink_params = m_dllAvFilter.av_buffersink_params_alloc();
-  buffersink_params->pixel_fmts = &m_formats[0];
-#ifdef FF_API_OLD_VSINK_API
-  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, (void*)buffersink_params->pixel_fmts, m_pFilterGraph)) < 0)
-#else
-  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, buffersink_params, m_pFilterGraph)) < 0)
-#endif
+  if ((result = avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, NULL, m_pFilterGraph)) < 0)
   {
-    m_dllAvUtil.av_freep(&buffersink_params);
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_create_filter: out");
     return result;
   }
-  m_dllAvUtil.av_freep(&buffersink_params);
+  if ((result = av_opt_set_int_list(m_pFilterOut, "pix_fmts", &m_formats[0],  AV_PIX_FMT_NONE, AV_OPT_SEARCH_CHILDREN)) < 0)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - failed settings pix formats");
+    return result;
+  }
 
   if (!filters.empty())
   {
-    AVFilterInOut* outputs = m_dllAvFilter.avfilter_inout_alloc();
-    AVFilterInOut* inputs  = m_dllAvFilter.avfilter_inout_alloc();
+    AVFilterInOut* outputs = avfilter_inout_alloc();
+    AVFilterInOut* inputs  = avfilter_inout_alloc();
 
-    outputs->name    = m_dllAvUtil.av_strdup("in");
+    outputs->name    = av_strdup("in");
     outputs->filter_ctx = m_pFilterIn;
     outputs->pad_idx = 0;
     outputs->next    = NULL;
 
-    inputs->name    = m_dllAvUtil.av_strdup("out");
+    inputs->name    = av_strdup("out");
     inputs->filter_ctx = m_pFilterOut;
     inputs->pad_idx = 0;
     inputs->next    = NULL;
 
-#if defined(HAVE_AVFILTER_GRAPH_PARSE_PTR)
-    if ((result = m_dllAvFilter.avfilter_graph_parse_ptr(m_pFilterGraph, (const char*)m_filters.c_str(), &inputs, &outputs, NULL)) < 0)
-#else
-    if ((result = m_dllAvFilter.avfilter_graph_parse(m_pFilterGraph, (const char*)m_filters.c_str(), &inputs, &outputs, NULL)) < 0)
-#endif
+    if ((result = avfilter_graph_parse_ptr(m_pFilterGraph, (const char*)m_filters.c_str(), &inputs, &outputs, NULL)) < 0)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_parse");
       return result;
     }
 
-    m_dllAvFilter.avfilter_inout_free(&outputs);
-    m_dllAvFilter.avfilter_inout_free(&inputs);
+    avfilter_inout_free(&outputs);
+    avfilter_inout_free(&inputs);
   }
   else
   {
-    if ((result = m_dllAvFilter.avfilter_link(m_pFilterIn, 0, m_pFilterOut, 0)) < 0)
+    if ((result = avfilter_link(m_pFilterIn, 0, m_pFilterOut, 0)) < 0)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_link");
       return result;
     }
   }
 
-  if ((result = m_dllAvFilter.avfilter_graph_config(m_pFilterGraph, NULL)) < 0)
+  if ((result = avfilter_graph_config(m_pFilterGraph, NULL)) < 0)
   {
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_config");
     return result;
@@ -804,17 +859,9 @@
 
 void CDVDVideoCodecFFmpeg::FilterClose()
 {
-#if !defined(LIBAVFILTER_AVFRAME_BASED)
-  if(m_pBufferRef)
-  {
-    m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
-    m_pBufferRef = NULL;
-  }
-#endif
-
   if (m_pFilterGraph)
   {
-    m_dllAvFilter.avfilter_graph_free(&m_pFilterGraph);
+    avfilter_graph_free(&m_pFilterGraph);
 
     // Disposed by above code
     m_pFilterIn   = NULL;
@@ -828,19 +875,7 @@
 
   if (frame)
   {
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-    // API changed in:
-    // ffmpeg: commit 7e350379f87e7f74420b4813170fe808e2313911 (28 Nov 2012)
-    //         not released (post 1.2)
-    // libav: commit 7e350379f87e7f74420b4813170fe808e2313911 (28 Nov 2012)
-    //        release v9 (5 January 2013)
-    result = m_dllAvFilter.av_buffersrc_add_frame(m_pFilterIn, frame);
-#else
-    // API changed in:
-    // ffmpeg: commit 7bac2a78c2241df4bcc1665703bb71afd9a3e692 (28 Apr 2012)
-    //         release 0.11 (25 May 2012)
-    result = m_dllAvFilter.av_buffersrc_add_frame(m_pFilterIn, frame, 0);
-#endif
+    result = av_buffersrc_add_frame(m_pFilterIn, frame);
     if (result < 0)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_buffersrc_add_frame");
@@ -848,8 +883,7 @@
     }
   }
 
-#if defined(LIBAVFILTER_AVFRAME_BASED)
-  result = m_dllAvFilter.av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
+  result = av_buffersink_get_frame(m_pFilterOut, m_pFilterFrame);
 
   if(result  == AVERROR(EAGAIN) || result == AVERROR_EOF)
     return VC_BUFFER;
@@ -859,54 +893,10 @@
     return VC_ERROR;
   }
 
-  m_dllAvUtil.av_frame_unref(m_pFrame);
-  m_dllAvUtil.av_frame_move_ref(m_pFrame, m_pFilterFrame);
+  av_frame_unref(m_pFrame);
+  av_frame_move_ref(m_pFrame, m_pFilterFrame);
 
   return VC_PICTURE;
-#else
-  int frames;
-
-  if(m_pBufferRef)
-  {
-    m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
-    m_pBufferRef = NULL;
-  }
-
-  if ((frames = m_dllAvFilter.av_buffersink_poll_frame(m_pFilterOut)) < 0)
-  {
-    CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_buffersink_poll_frame");
-    return VC_ERROR;
-  }
-
-  if (frames > 0)
-  {
-
-    result = m_dllAvFilter.av_buffersink_get_buffer_ref(m_pFilterOut, &m_pBufferRef, 0);
-    if(!m_pBufferRef || result < 0)
-    {
-      CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - cur_buf");
-      return VC_ERROR;
-    }
-
-    if(frame == NULL)
-      m_pFrame->reordered_opaque = 0;
-    else
-      m_pFrame->repeat_pict      = -(frames - 1);
-
-    m_pFrame->interlaced_frame = m_pBufferRef->video->interlaced;
-    m_pFrame->top_field_first  = m_pBufferRef->video->top_field_first;
-
-    memcpy(m_pFrame->linesize, m_pBufferRef->linesize, 4*sizeof(int));
-    memcpy(m_pFrame->data    , m_pBufferRef->data    , 4*sizeof(uint8_t*));
-
-    if(frames > 1)
-      return VC_PICTURE;
-    else
-      return VC_PICTURE | VC_BUFFER;
-  }
-
-  return VC_BUFFER;
-#endif
 }
 
 unsigned CDVDVideoCodecFFmpeg::GetConvergeCount()
@@ -924,3 +914,16 @@
   else
     return 0;
 }
+
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+{
+  pts = m_decoderPts;
+  skippedDeint = m_skippedDeint;
+  interlaced = m_interlace;
+  return true;
+}
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2014-08-13 18:26:06.956508251 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2014-08-13 18:27:01.712779774 +0800
@@ -22,12 +22,17 @@
 
 #include "DVDVideoCodec.h"
 #include "DVDResource.h"
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-#include "DllAvUtil.h"
-#include "DllSwScale.h"
-#include "DllAvFilter.h"
-#include "DllPostProc.h"
+#include <string>
+#include "utils/StdString.h"
+
+extern "C" {
+#include "libavfilter/avfilter.h"
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libswscale/swscale.h"
+#include "libpostproc/postprocess.h"
+}
 
 class CCriticalSection;
 
@@ -45,8 +50,11 @@
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
+    virtual bool UseFilter() { return false; }
+    virtual bool MapFrame(AVCodecContext* avctx, AVFrame* frame) { return false; }
   };
 
   CDVDVideoCodecFFmpeg();
@@ -62,6 +70,8 @@
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced);
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -98,11 +108,7 @@
   AVFilterGraph*   m_pFilterGraph;
   AVFilterContext* m_pFilterIn;
   AVFilterContext* m_pFilterOut;
-#if defined(LIBAVFILTER_AVFRAME_BASED)
   AVFrame*         m_pFilterFrame;
-#else
-  AVFilterBufferRef* m_pBufferRef;
-#endif
 
   int m_iPictureWidth;
   int m_iPictureHeight;
@@ -113,18 +119,17 @@
 
   unsigned int m_uSurfacesCount;
 
-  DllAvCodec m_dllAvCodec;
-  DllAvUtil  m_dllAvUtil;
-  DllSwScale m_dllSwScale;
-  DllAvFilter m_dllAvFilter;
-  DllPostProc m_dllPostProc;
-
   std::string m_name;
   bool              m_bSoftware;
-  bool  m_isHi10p;
+  bool  m_isSWCodec;
   IHardwareDecoder *m_pHardware;
   int m_iLastKeyframe;
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
+  bool   m_interlace;
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-08-13 18:26:06.956508251 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2014-08-13 18:27:01.184777156 +0800
@@ -21,13 +21,15 @@
  */
 
 #include "system.h"
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
 
 #include <vector>
 #include <string>
 #include "cores/VideoRenderers/RenderFormats.h"
 
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
+
 struct DVDCodecAvailableType 
 {
   AVCodecID codec;
@@ -106,8 +108,8 @@
   unsigned int extended_format;
   char         stereo_mode[32];
 
-  int8_t* qscale_table; // Quantization parameters, primarily used by filters
-  int qscale_stride;
+  int8_t* qp_table; // Quantization parameters, primarily used by filters
+  int qstride;
   int qscale_type;
 
   unsigned int iWidth;
@@ -132,6 +134,10 @@
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100
+#define DVP_FLAG_DRAIN              0x00000200
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -149,6 +155,8 @@
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+
 class CDVDVideoCodec
 {
 public:
@@ -266,7 +274,6 @@
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
@@ -283,4 +290,36 @@
   * Interact with user settings so that user disabled codecs are disabled
   */
   static bool IsCodecDisabled(DVDCodecAvailableType* map, unsigned int size, AVCodecID id);
+
+   /* For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - skippedDeint : indicates if decoder has just skipped a deinterlacing cycle
+   *   instead of dropping a full frame
+   * - interlaced : when detecting gaps in pts, player needs to know whether
+   *   it's interlaced or not
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case coded does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+  {
+    return false;
+  }
+
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
+  virtual void SetCodecControl(int flags) {}
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2014-08-13 18:26:06.824507601 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp	2014-08-13 18:27:01.088776680 +0800
@@ -24,10 +24,14 @@
 #include "system_gl.h"
 #include "DVDVideoCodecVDA.h"
 
-#include "DllSwScale.h"
+extern "C" {
+#include "libswscale/swscale.h"
+}
+
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
 #include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
+#include "cores/FFmpeg.h"
 #include "osx/CocoaInterface.h"
 #include "windowing/WindowingFactory.h"
 #include "utils/BitstreamConverter.h"
@@ -137,7 +141,6 @@
   pthread_mutex_init(&m_queue_mutex, NULL);
 
   m_bitstream = NULL;
-  m_dllSwScale = NULL;
   memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
   m_DropPictures = false;
   m_decode_async = false;
@@ -267,13 +270,6 @@
 
     if (!m_use_cvBufferRef)
     {
-      m_dllSwScale = new DllSwScale;
-      if (!m_dllSwScale->Load())
-      {
-        CFRelease(avcCData);
-        return false;
-      }
-
       // allocate a YV12 DVDVideoPicture buffer.
       // first make sure all properties are reset.
       memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
@@ -394,9 +390,6 @@
 
   if (m_bitstream)
     delete m_bitstream, m_bitstream = NULL;
-
-  if (m_dllSwScale)
-    delete m_dllSwScale, m_dllSwScale = NULL;
 }
 
 void CDVDVideoCodecVDA::SetDropState(bool bDrop)
@@ -553,7 +546,7 @@
 void CDVDVideoCodecVDA::UYVY422_to_YUV420P(uint8_t *yuv422_ptr, int yuv422_stride, DVDVideoPicture *picture)
 {
   // convert PIX_FMT_UYVY422 to PIX_FMT_YUV420P.
-  struct SwsContext *swcontext = m_dllSwScale->sws_getContext(
+  struct SwsContext *swcontext = sws_getContext(
     m_videobuffer.iWidth, m_videobuffer.iHeight, PIX_FMT_UYVY422, 
     m_videobuffer.iWidth, m_videobuffer.iHeight, PIX_FMT_YUV420P, 
     SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
@@ -565,15 +558,15 @@
     uint8_t  *dst[] = { picture->data[0], picture->data[1], picture->data[2], 0 };
     int dstStride[] = { picture->iLineSize[0], picture->iLineSize[1], picture->iLineSize[2], 0 };
 
-    m_dllSwScale->sws_scale(swcontext, src, srcStride, 0, picture->iHeight, dst, dstStride);
-    m_dllSwScale->sws_freeContext(swcontext);
+    sws_scale(swcontext, src, srcStride, 0, picture->iHeight, dst, dstStride);
+    sws_freeContext(swcontext);
   }
 }
 
 void CDVDVideoCodecVDA::BGRA_to_YUV420P(uint8_t *bgra_ptr, int bgra_stride, DVDVideoPicture *picture)
 {
   // convert PIX_FMT_BGRA to PIX_FMT_YUV420P.
-  struct SwsContext *swcontext = m_dllSwScale->sws_getContext(
+  struct SwsContext *swcontext = sws_getContext(
     m_videobuffer.iWidth, m_videobuffer.iHeight, PIX_FMT_BGRA, 
     m_videobuffer.iWidth, m_videobuffer.iHeight, PIX_FMT_YUV420P, 
     SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
@@ -585,8 +578,8 @@
     uint8_t  *dst[] = { picture->data[0], picture->data[1], picture->data[2], 0 };
     int dstStride[] = { picture->iLineSize[0], picture->iLineSize[1], picture->iLineSize[2], 0 };
 
-    m_dllSwScale->sws_scale(swcontext, src, srcStride, 0, picture->iHeight, dst, dstStride);
-    m_dllSwScale->sws_freeContext(swcontext);
+    sws_scale(swcontext, src, srcStride, 0, picture->iHeight, dst, dstStride);
+    sws_freeContext(swcontext);
   }
 }
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2014-08-13 18:26:06.832507641 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.h	2014-08-13 18:27:00.644774481 +0800
@@ -22,7 +22,6 @@
 #include "DVDVideoCodec.h"
 #include <CoreVideo/CoreVideo.h>
 
-class DllSwScale;
 class CBitstreamConverter;
 struct frame_queue;
 
@@ -66,6 +65,5 @@
 
   CBitstreamConverter *m_bitstream;
 
-  DllSwScale        *m_dllSwScale;
   DVDVideoPicture   m_videobuffer;
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2014-08-13 18:26:06.840507681 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp	2014-08-13 18:27:01.100776739 +0800
@@ -27,13 +27,16 @@
 #include "DVDStreamInfo.h"
 #include "DVDCodecUtils.h"
 #include "DVDVideoCodecVideoToolBox.h"
-#include "lib/DllSwScale.h"
-#include "lib/DllAvFormat.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
 #include "osx/DarwinUtils.h"
 
+extern "C" {
+#include "libswscale/swscale.h"
+#include "libavformat/avformat.h"
+}
+
 #if defined(__cplusplus)
 extern "C"
 {
@@ -436,7 +439,7 @@
   uint8_t* decoderConfig;
 } quicktime_esds_t;
 
-int quicktime_write_mp4_descr_length(DllAvFormat *av_format_ctx, AVIOContext *pb, int length, int compact)
+int quicktime_write_mp4_descr_length(AVIOContext *pb, int length, int compact)
 {
   int i;
   uint8_t b;
@@ -473,45 +476,45 @@
     {
       b |= 0x80;
     }
-    av_format_ctx->avio_w8(pb, b);
+    avio_w8(pb, b);
   }
 
   return numBytes; 
 }
 
-void quicktime_write_esds(DllAvFormat *av_format_ctx, AVIOContext *pb, quicktime_esds_t *esds)
+void quicktime_write_esds(AVIOContext *pb, quicktime_esds_t *esds)
 {
-  av_format_ctx->avio_w8(pb, 0);     // Version
-  av_format_ctx->avio_wb24(pb, 0);     // Flags
+  avio_w8(pb, 0);     // Version
+  avio_wb24(pb, 0);     // Flags
 
   // elementary stream descriptor tag
-  av_format_ctx->avio_w8(pb, 0x03);
-  quicktime_write_mp4_descr_length(av_format_ctx, pb,
+  avio_w8(pb, 0x03);
+  quicktime_write_mp4_descr_length(pb,
     3 + 5 + (13 + 5 + esds->decoderConfigLen) + 3, false);
   // 3 bytes + 5 bytes for tag
-  av_format_ctx->avio_wb16(pb, esds->esid);
-  av_format_ctx->avio_w8(pb, esds->stream_priority);
+  avio_wb16(pb, esds->esid);
+  avio_w8(pb, esds->stream_priority);
 
   // decoder configuration description tag
-  av_format_ctx->avio_w8(pb, 0x04);
-  quicktime_write_mp4_descr_length(av_format_ctx, pb,
+  avio_w8(pb, 0x04);
+  quicktime_write_mp4_descr_length(pb,
     13 + 5 + esds->decoderConfigLen, false);
   // 13 bytes + 5 bytes for tag
-  av_format_ctx->avio_w8(pb, esds->objectTypeId); // objectTypeIndication
-  av_format_ctx->avio_w8(pb, esds->streamType);   // streamType
-  av_format_ctx->avio_wb24(pb, esds->bufferSizeDB); // buffer size
-  av_format_ctx->avio_wb32(pb, esds->maxBitrate);   // max bitrate
-  av_format_ctx->avio_wb32(pb, esds->avgBitrate);   // average bitrate
+  avio_w8(pb, esds->objectTypeId); // objectTypeIndication
+  avio_w8(pb, esds->streamType);   // streamType
+  avio_wb24(pb, esds->bufferSizeDB); // buffer size
+  avio_wb32(pb, esds->maxBitrate);   // max bitrate
+  avio_wb32(pb, esds->avgBitrate);   // average bitrate
 
   // decoder specific description tag
-  av_format_ctx->avio_w8(pb, 0x05);
-  quicktime_write_mp4_descr_length(av_format_ctx, pb, esds->decoderConfigLen, false);
-  av_format_ctx->avio_write(pb, esds->decoderConfig, esds->decoderConfigLen);
+  avio_w8(pb, 0x05);
+  quicktime_write_mp4_descr_length(pb, esds->decoderConfigLen, false);
+  avio_write(pb, esds->decoderConfig, esds->decoderConfigLen);
 
   // sync layer configuration descriptor tag
-  av_format_ctx->avio_w8(pb, 0x06);  // tag
-  av_format_ctx->avio_w8(pb, 0x01);  // length
-  av_format_ctx->avio_w8(pb, 0x7F);  // no SL
+  avio_w8(pb, 0x06);  // tag
+  avio_w8(pb, 0x01);  // length
+  avio_w8(pb, 0x7F);  // no SL
 
   /* no IPI_DescrPointer */
 	/* no IP_IdentificationDataSet */
@@ -523,7 +526,7 @@
 
 }
 
-quicktime_esds_t* quicktime_set_esds(DllAvFormat *av_format_ctx, const uint8_t * decoderConfig, int decoderConfigLen)
+quicktime_esds_t* quicktime_set_esds(const uint8_t * decoderConfig, int decoderConfigLen)
 {
   // ffmpeg's codec->avctx->extradata, codec->avctx->extradata_size
   // are decoderConfig/decoderConfigLen
@@ -652,8 +655,7 @@
   return out;
 }
 
-const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
-  AVIOContext *pb, const uint8_t *buf_in, int size)
+const int avc_parse_nal_units(AVIOContext *pb, const uint8_t *buf_in, int size)
 {
   const uint8_t *p = buf_in;
   const uint8_t *end = p + size;
@@ -665,26 +667,25 @@
   {
     while (!*(nal_start++));
     nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
-    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
+    avio_wb32(pb, nal_end - nal_start);
+    avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
   return size;
 }
 
-const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
-  const uint8_t *buf_in, uint8_t **buf, int *size)
+const int avc_parse_nal_units_buf(const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   AVIOContext *pb;
-  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
+  int ret = avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
-  avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
+  avc_parse_nal_units(pb, buf_in, *size);
 
-  av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
+  av_freep(buf);
+  *size = avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -729,8 +730,7 @@
    field_pic_flag: 0 on the frames,
    (field_pic_flag: 1 would indicate a normal interlaced frame).
 */
-const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
-  AVIOContext *pb, const uint8_t *data, int len)
+const int isom_write_avcc(AVIOContext *pb, const uint8_t *data, int len)
 {
   // extradata from bytestream h264, convert to avcC atom data for bitstream
   if (len > 6)
@@ -742,7 +742,7 @@
       uint32_t sps_size=0, pps_size=0;
       uint8_t *sps=0, *pps=0;
 
-      int ret = avc_parse_nal_units_buf(av_util_ctx, av_format_ctx, data, &buf, &len);
+      int ret = avc_parse_nal_units_buf(data, &buf, &len);
       if (ret < 0)
         return ret;
       start = buf;
@@ -769,26 +769,26 @@
       }
       assert(sps);
 
-      av_format_ctx->avio_w8(pb, 1); /* version */
-      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
-      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
-      av_format_ctx->avio_w8(pb, sps[3]); /* level */
-      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      avio_w8(pb, 1); /* version */
+      avio_w8(pb, sps[1]); /* profile */
+      avio_w8(pb, sps[2]); /* profile compat */
+      avio_w8(pb, sps[3]); /* level */
+      avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      av_format_ctx->avio_wb16(pb, sps_size);
-      av_format_ctx->avio_write(pb, sps, sps_size);
+      avio_wb16(pb, sps_size);
+      avio_write(pb, sps, sps_size);
       if (pps)
       {
-        av_format_ctx->avio_w8(pb, 1); /* number of pps */
-        av_format_ctx->avio_wb16(pb, pps_size);
-        av_format_ctx->avio_write(pb, pps, pps_size);
+        avio_w8(pb, 1); /* number of pps */
+        avio_wb16(pb, pps_size);
+        avio_write(pb, pps, pps_size);
       }
-      av_util_ctx->av_free(start);
+      av_free(start);
     }
     else
     {
-      av_format_ctx->avio_write(pb, data, len);
+      avio_write(pb, data, len);
     }
   }
   return 0;
@@ -1043,8 +1043,6 @@
 
   m_convert_bytestream = false;
   m_convert_3byteTo4byteNALSize = false; 
-  m_dllAvUtil   = NULL;
-  m_dllAvFormat = NULL;
   memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
   m_DropPictures = false;
   m_sort_time_offset = 0.0;
@@ -1060,11 +1058,6 @@
 {
   if (CSettings::Get().GetBool("videoplayer.usevideotoolbox") && !hints.software)
   {
-    m_dllAvUtil = new DllAvUtil;
-    m_dllAvFormat = new DllAvFormat;
-    if (!m_dllAvUtil->Load() || !m_dllAvFormat->Load())
-      return false;
-
     int width  = hints.width;
     int height = hints.height;
     int level  = hints.level;
@@ -1103,16 +1096,16 @@
           AVIOContext *pb;
           quicktime_esds_t *esds;
 
-          if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+          if (avio_open_dyn_buf(&pb) < 0)
             return false;
 
-          esds = quicktime_set_esds(m_dllAvFormat, extradata, extrasize);
-          quicktime_write_esds(m_dllAvFormat, pb, esds);
+          esds = quicktime_set_esds(extradata, extrasize);
+          quicktime_write_esds(pb, esds);
 
           // unhook from ffmpeg's extradata
           extradata = NULL;
           // extract the esds atom decoderConfig from extradata
-          extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
+          extrasize = avio_close_dyn_buf(pb, &extradata);
           free(esds->decoderConfig);
           free(esds);
 
@@ -1120,7 +1113,7 @@
             kVTFormatMPEG4Video, width, height, extradata, extrasize, 'esds');
 
           // done with the converted extradata, we MUST free using av_free
-          m_dllAvUtil->av_free(extradata);
+          av_free(extradata);
         }
         else
         {
@@ -1188,21 +1181,21 @@
             // NAL reformating to bitstream format required
 
             AVIOContext *pb;
-            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+            if (avio_open_dyn_buf(&pb) < 0)
               return false;
 
             m_convert_bytestream = true;
             // create a valid avcC atom data from ffmpeg's extradata
-            isom_write_avcc(m_dllAvUtil, m_dllAvFormat, pb, extradata, extrasize);
+            isom_write_avcc(pb, extradata, extrasize);
             // unhook from ffmpeg's extradata
             extradata = NULL;
             // extract the avcC atom data into extradata getting size into extrasize
-            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
+            extrasize = avio_close_dyn_buf(pb, &extradata);
 
             // check for interlaced and get number of ref frames
             if (!validate_avcC_spc(extradata, extrasize, &m_max_ref_frames, &spsLevel, &spsProfile))
             {
-              m_dllAvUtil->av_free(extradata);
+              av_free(extradata);
               return false;
             }
             
@@ -1221,7 +1214,7 @@
               // Main@L3.2, VTB cannot handle greater than 4 ref frames (ie. flash video)
               CLog::Log(LOGNOTICE, "%s - Main@L3.2 detected, VTB cannot decode with %d ref frames",
                 __FUNCTION__, m_max_ref_frames);
-              m_dllAvUtil->av_free(extradata);
+              av_free(extradata);
               return false;
             }
  
@@ -1230,7 +1223,7 @@
               kVTFormatH264, width, height, extradata, extrasize, 'avcC');
 
             // done with the new converted extradata, we MUST free using av_free
-            m_dllAvUtil->av_free(extradata);
+            av_free(extradata);
             CLog::Log(LOGNOTICE, "%s - created avcC atom of size(%d)", __FUNCTION__, extrasize);
           }
           else
@@ -1314,17 +1307,6 @@
   
   while (m_queue_depth)
     DisplayQueuePop();
-
-  if (m_dllAvUtil)
-  {
-    delete m_dllAvUtil;
-    m_dllAvUtil = NULL;
-  }
-  if (m_dllAvFormat)
-  {
-    delete m_dllAvFormat;
-    m_dllAvFormat = NULL;
-  }
 }
 
 void CDVDVideoCodecVideoToolBox::SetDropState(bool bDrop)
@@ -1348,17 +1330,17 @@
     if (m_convert_bytestream)
     {
       // convert demuxer packet from bytestream (AnnexB) to bitstream
-      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+      if(avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
-      avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
+      avc_parse_nal_units(pb, pData, iSize);
+      demux_size = avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else if (m_convert_3byteTo4byteNALSize)
     {
       // convert demuxer packet from 3 byte NAL sizes to 4 byte
-      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+      if (avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       uint32_t nal_size;
@@ -1367,13 +1349,13 @@
       while (nal_start < end)
       {
         nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->avio_wb32(pb, nal_size);
+        avio_wb32(pb, nal_size);
         nal_start += 3;
-        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
+        avio_write(pb, nal_start, nal_size);
         nal_start += nal_size;
       }
 
-      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
+      demux_size = avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else
@@ -1384,7 +1366,7 @@
     if (!sampleBuff)
     {
       if (demux_size)
-        m_dllAvUtil->av_free(demux_buff);
+        av_free(demux_buff);
       CLog::Log(LOGNOTICE, "%s - CreateSampleBufferFrom failed", __FUNCTION__);
       return VC_ERROR;
     }
@@ -1404,7 +1386,7 @@
       CFRelease(frameInfo);
       CFRelease(sampleBuff);
       if (demux_size)
-        m_dllAvUtil->av_free(demux_buff);
+        av_free(demux_buff);
       return VC_ERROR;
       // VTDecompressionSessionDecodeFrame returned 8969 (codecBadDataErr)
       // VTDecompressionSessionDecodeFrame returned -12350
@@ -1421,14 +1403,14 @@
       CFRelease(frameInfo);
       CFRelease(sampleBuff);
       if (demux_size)
-        m_dllAvUtil->av_free(demux_buff);
+        av_free(demux_buff);
       return VC_ERROR;
     }
 
     CFRelease(frameInfo);
     CFRelease(sampleBuff);
     if (demux_size)
-      m_dllAvUtil->av_free(demux_buff);
+      av_free(demux_buff);
   }
 
   // TODO: queue depth is related to the number of reference frames in encoded h.264.
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2014-08-13 18:26:06.956508251 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.h	2014-08-13 18:27:00.644774481 +0800
@@ -39,8 +39,6 @@
   struct frame_queue  *nextframe;
 } frame_queue;
 
-class DllAvUtil;
-class DllAvFormat;
 class CDVDVideoCodecVideoToolBox : public CDVDVideoCodec
 {
 public:
@@ -80,9 +78,6 @@
 
   bool              m_convert_bytestream;
   bool              m_convert_3byteTo4byteNALSize;
-
-  DllAvUtil         *m_dllAvUtil;
-  DllAvFormat       *m_dllAvFormat;
 };
 
 #endif
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2014-08-13 18:26:06.896507958 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -20,6 +20,7 @@
 
 #include "DVDVideoPPFFmpeg.h"
 #include "utils/log.h"
+#include "cores/FFmpeg.h"
 
 CDVDVideoPPFFmpeg::CDVDVideoPPFFmpeg(const CStdString& mType)
 {
@@ -38,12 +39,12 @@
 {
   if (m_pMode)
   {
-    m_dll.pp_free_mode(m_pMode);
+    pp_free_mode(m_pMode);
     m_pMode = NULL;
   }
   if(m_pContext)
   {
-    m_dll.pp_free_context(m_pContext);
+    pp_free_context(m_pContext);
     m_pContext = NULL;
   }
 
@@ -63,14 +64,10 @@
 
   m_iInitWidth = 0;
   m_iInitHeight = 0;
-
-  m_dll.Unload();
 }
 
 bool CDVDVideoPPFFmpeg::CheckInit(int iWidth, int iHeight)
 {
-  if (!m_dll.IsLoaded() && !m_dll.Load()) return false;
-
   if(m_iInitWidth != iWidth || m_iInitHeight != iHeight)
   {
     if(m_pContext || m_pMode)
@@ -78,12 +75,12 @@
       Dispose();
     }
 
-    m_pContext = m_dll.pp_get_context(m_pSource->iWidth, m_pSource->iHeight, PPCPUFlags() | PP_FORMAT_420);
+    m_pContext = pp_get_context(m_pSource->iWidth, m_pSource->iHeight, PPCPUFlags() | PP_FORMAT_420);
 
     m_iInitWidth = m_pSource->iWidth;
     m_iInitHeight = m_pSource->iHeight;
 
-    m_pMode = m_dll.pp_get_mode_by_name_and_quality((char *)m_sType.c_str(), PP_QUALITY_MAX);
+    m_pMode = pp_get_mode_by_name_and_quality((char *)m_sType.c_str(), PP_QUALITY_MAX);
   }
 
 
@@ -134,10 +131,10 @@
   int pict_type = (m_pSource->qscale_type != DVP_QSCALE_MPEG1) ?
                    PP_PICT_TYPE_QP2 : 0;
 
-  m_dll.pp_postprocess(m_pSource->data, m_pSource->iLineSize,
+  pp_postprocess((const uint8_t**)m_pSource->data, m_pSource->iLineSize,
                 m_pTarget->data, m_pTarget->iLineSize,
                 m_pSource->iWidth, m_pSource->iHeight,
-                m_pSource->qscale_table, m_pSource->qscale_stride,
+                m_pSource->qp_table, m_pSource->qstride,
                 m_pMode, m_pContext,
                 pict_type); //m_pSource->iFrameType);
 
@@ -148,8 +145,8 @@
   m_pTarget->iFrameType = m_pSource->iFrameType;
   m_pTarget->iRepeatPicture = m_pSource->iRepeatPicture;;
   m_pTarget->iDuration = m_pSource->iDuration;
-  m_pTarget->qscale_table = m_pSource->qscale_table;
-  m_pTarget->qscale_stride = m_pSource->qscale_stride;
+  m_pTarget->qp_table = m_pSource->qp_table;
+  m_pTarget->qstride = m_pSource->qstride;
   m_pTarget->qscale_type = m_pSource->qscale_type;
   m_pTarget->iDisplayHeight = m_pSource->iDisplayHeight;
   m_pTarget->iDisplayWidth = m_pSource->iDisplayWidth;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h	2014-08-13 18:26:06.896507958 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoPPFFmpeg.h	2014-08-13 18:27:00.644774481 +0800
@@ -21,7 +21,7 @@
  */
 
 #include "DVDVideoCodec.h"
-#include "DllPostProc.h"
+#include "utils/StdString.h"
 
 class CDVDVideoPPFFmpeg
 {
@@ -52,8 +52,6 @@
   int m_iInitWidth, m_iInitHeight;
   bool CheckInit(int iWidth, int iHeight);
   bool CheckFrameBuffer(const DVDVideoPicture* pSource);
-
-  DllPostProc m_dll;
 };
 
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2014-08-13 18:26:06.836507656 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.cpp	2014-08-13 18:27:00.996776223 +0800
@@ -44,6 +44,7 @@
 #include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "win32/WIN32Util.h"
+#include "utils/Log.h"
 
 #define ALLOW_ADDING_SURFACES 0
 
@@ -72,11 +73,11 @@
 
 
 
-static void RelBufferS(AVCodecContext *avctx, AVFrame *pic)
-{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->RelBuffer(avctx, pic); }
+static void RelBufferS(void *opaque, uint8_t *data)
+{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)opaque)->GetHardware())->RelBuffer(data); }
 
-static int GetBufferS(AVCodecContext *avctx, AVFrame *pic) 
-{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic); }
+static int GetBufferS(AVCodecContext *avctx, AVFrame *pic, int flags) 
+{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic, flags); }
 
 
 DEFINE_GUID(DXVADDI_Intel_ModeH264_A, 0x604F8E64,0x4951,0x4c54,0x88,0xFE,0xAB,0xD2,0x5C,0x15,0xB3,0xD6);
@@ -695,8 +696,7 @@
   if(!OpenDecoder())
     return false;
 
-  avctx->get_buffer      = GetBufferS;
-  avctx->release_buffer  = RelBufferS;
+  avctx->get_buffer2     = GetBufferS;
   avctx->hwaccel_context = m_context;
 
   D3DADAPTER_IDENTIFIER9 AIdentifier = g_Windowing.GetAIdentifier();
@@ -902,10 +902,10 @@
   return false;
 }
 
-void CDecoder::RelBuffer(AVCodecContext *avctx, AVFrame *pic)
+void CDecoder::RelBuffer(uint8_t *data)
 {
   CSingleLock lock(m_section);
-  IDirect3DSurface9* surface = (IDirect3DSurface9*)pic->data[3];
+  IDirect3DSurface9* surface = (IDirect3DSurface9*)data;
 
   for(unsigned i = 0; i < m_buffer_count; i++)
   {
@@ -916,11 +916,9 @@
       break;
     }
   }
-  for(unsigned i = 0; i < 4; i++)
-    pic->data[i] = NULL;
 }
 
-int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic)
+int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags)
 {
   CSingleLock lock(m_section);
   if(avctx->coded_width  != m_format.SampleWidth
@@ -967,7 +965,6 @@
   }
 
   pic->reordered_opaque = avctx->reordered_opaque;
-  pic->type = FF_BUFFER_TYPE_USER;
 
   for(unsigned i = 0; i < 4; i++)
   {
@@ -977,6 +974,13 @@
 
   pic->data[0] = (uint8_t*)buf->surface;
   pic->data[3] = (uint8_t*)buf->surface;
+  AVBufferRef *buffer = av_buffer_create(pic->data[3], 0, RelBufferS, avctx->opaque, 0);
+  if (!buffer)
+  {
+    CLog::Log(LOGERROR, "DXVA - error creating buffer");
+    return -1;
+  }
+  pic->buf[0] = buffer;
   buf->used = true;
 
   return 0;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h	2014-08-13 18:26:06.952508236 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVA.h	2014-08-13 18:27:00.996776223 +0800
@@ -19,7 +19,7 @@
  */
 #pragma once
 
-#include "DllAvCodec.h"
+#include "libavcodec/avcodec.h"
 #include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 #include "guilib/D3DResource.h"
 #include "threads/Event.h"
@@ -62,8 +62,8 @@
 
   bool  OpenTarget(const GUID &guid);
   bool  OpenDecoder();
-  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic);
-  void  RelBuffer(AVCodecContext *avctx, AVFrame *pic);
+  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags);
+  void  RelBuffer(uint8_t *data);
 
   static bool      Supports(enum PixelFormat fmt);
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.cpp	2014-08-13 18:26:06.960508276 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.cpp	2014-08-13 18:27:00.884775668 +0800
@@ -44,6 +44,7 @@
 #include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "win32/WIN32Util.h"
+#include "utils/Log.h"
 
 #define ALLOW_ADDING_SURFACES 0
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.h	2014-08-13 18:26:06.952508236 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/DXVAHD.h	2014-08-13 18:27:00.648774496 +0800
@@ -19,7 +19,7 @@
  */
 #pragma once
 
-#include "DllAvCodec.h"
+#include "libavcodec/avcodec.h"
 #include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 #include "guilib/D3DResource.h"
 #include "threads/Event.h"
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2014-08-13 18:26:06.836507656 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp	2014-08-13 20:04:37.321816176 +0800
@@ -24,6 +24,17 @@
 #include "DVDVideoCodec.h"
 #include <boost/scoped_array.hpp>
 #include <boost/weak_ptr.hpp>
+#include "utils/log.h"
+#include "threads/SingleLock.h"
+#include "XMemUtils.h"
+#include "utils/CPUInfo.h"
+#include "settings/Settings.h"
+
+extern "C" {
+#include "libavutil/avutil.h"
+}
+
+#define CACHED_BUFFER_SIZE 4096
 
 #define CHECK(a) \
 do { \
@@ -72,11 +83,11 @@
   return 0;
 }
 
-static void RelBufferS(AVCodecContext *avctx, AVFrame *pic)
-{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->RelBuffer(avctx, pic); }
+static void RelBufferS(void *opaque, uint8_t *data)
+{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)opaque)->GetHardware())->RelBuffer(data); }
 
-static int GetBufferS(AVCodecContext *avctx, AVFrame *pic) 
-{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic); }
+static int GetBufferS(AVCodecContext *avctx, AVFrame *pic, int flags)
+{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic, flags); }
 
 static inline VASurfaceID GetSurfaceID(AVFrame *pic)
 { return (VASurfaceID)(uintptr_t)pic->data[3]; }
@@ -166,17 +177,22 @@
   m_context         = 0;
   m_hwaccel         = (vaapi_context*)calloc(1, sizeof(vaapi_context));
   memset(m_surfaces, 0, sizeof(*m_surfaces));
+  m_frame_buffer    = NULL;
+  m_cache           = NULL;
 }
 
 CDecoder::~CDecoder()
 {
   Close();
   free(m_hwaccel);
+  _aligned_free(m_frame_buffer);
+  _aligned_free(m_cache);
+  m_dllSSE4.Unload();
 }
 
-void CDecoder::RelBuffer(AVCodecContext *avctx, AVFrame *pic)
+void CDecoder::RelBuffer(uint8_t *data)
 {
-  VASurfaceID surface = GetSurfaceID(pic);
+  VASurfaceID surface = (VASurfaceID)(uintptr_t)data;
 
   for(std::list<CSurfacePtr>::iterator it = m_surfaces_used.begin(); it != m_surfaces_used.end(); ++it)
   {    
@@ -187,13 +203,9 @@
       break;
     }
   }
-  pic->data[0] = NULL;
-  pic->data[1] = NULL;
-  pic->data[2] = NULL;
-  pic->data[3] = NULL;
 }
 
-int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic)
+int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags)
 {
   VASurfaceID surface = GetSurfaceID(pic);
   CSurface*   wrapper = NULL;
@@ -243,16 +255,23 @@
     m_surfaces_free.erase(it);
   }
 
-  pic->type           = FF_BUFFER_TYPE_USER;
   pic->data[0]        = (uint8_t*)wrapper;
   pic->data[1]        = NULL;
   pic->data[2]        = NULL;
-  pic->data[3]        = (uint8_t*)surface;
+  pic->data[3]        = (uint8_t*)(uintptr_t)surface;
   pic->linesize[0]    = 0;
   pic->linesize[1]    = 0;
   pic->linesize[2]    = 0;
   pic->linesize[3]    = 0;
   pic->reordered_opaque= avctx->reordered_opaque;
+
+  AVBufferRef *buffer = av_buffer_create(pic->data[3], 0, RelBufferS, avctx->opaque, 0);
+  if (!buffer)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - error creating buffer", __FUNCTION__);
+    return -1;
+  }
+  pic->buf[0] = buffer;
   return 0;
 }
 
@@ -388,12 +407,18 @@
   if (!EnsureContext(avctx))
     return false;
 
+  if (avctx->width <= 1920 && avctx->height <= 1088)
+    CheckUseFilter();
+  else
+    m_use_filter = false;
+
   m_hwaccel->display     = m_display->get();
 
   avctx->hwaccel_context = m_hwaccel;
-  avctx->get_buffer      = GetBufferS;
-  avctx->reget_buffer    = GetBufferS;
-  avctx->release_buffer  = RelBufferS;
+//  avctx->get_buffer      = GetBufferS;
+//  avctx->reget_buffer    = GetBufferS;
+//  avctx->release_buffer  = RelBufferS;
+  avctx->get_buffer2     = GetBufferS;
   avctx->draw_horiz_band = NULL;
   avctx->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
   return true;
@@ -471,7 +496,35 @@
     return status;
 
   if(frame)
+  {
+    if (m_use_filter)
+    {
+      VASurfaceID surface = GetSurfaceID(frame);
+      std::list<CSurfacePtr>::iterator it;
+      for(it = m_surfaces_used.begin(); it != m_surfaces_used.end(); ++it)
+      {
+        if((*it)->m_id == surface)
+        {
+          m_holder.surface = *it;
+          break;
+        }
+      }
+      if (it == m_surfaces_used.end())
+      {
+        CLog::Log(LOGERROR, "VAAPI::Decode - surface not found");
+        return VC_ERROR;
+      }
+      CProcPic pic;
+      memset(&pic.frame, 0, sizeof(AVFrame));
+      av_frame_ref(&pic.frame, frame);
+      pic.surface = *it;
+      m_surfaces_proc.push_back(pic);
+      if (m_surfaces_proc.size() < m_renderbuffers_count)
+        return VC_BUFFER;
+    }
+
     return VC_BUFFER | VC_PICTURE;
+  }
   else
     return VC_BUFFER;
 }
@@ -549,4 +602,109 @@
   return m_renderbuffers_count;
 }
 
+void CDecoder::Reset()
+{
+  m_surfaces_proc.clear();
+}
+
+void CDecoder::CheckUseFilter()
+{
+  m_use_filter = true;
+  _aligned_free(m_frame_buffer);
+  _aligned_free(m_cache);
+  if (CSettings::Get().GetBool("videoplayer.usevaapiswfilter"))
+  {
+    if (!(g_cpuInfo.GetCPUFeatures() & CPU_FEATURE_SSE4))
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter cpu does not support SSE4");
+      m_use_filter = false;
+      return;
+    }
+    if (!m_dllSSE4.Load())
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter failed loading sse4 lib");
+      m_use_filter = false;
+      return;
+    }
+    VAImage image;
+    VASurfaceID surface = m_surfaces_free.front()->m_id;
+    VAStatus status = vaDeriveImage(m_display->get(), surface, &image);
+    m_use_filter = true;
+    if (status != VA_STATUS_SUCCESS)
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter vaDeriveImage not supported");
+      m_use_filter = false;
+    }
+    if (image.format.fourcc != VA_FOURCC_NV12)
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter image format not NV12");
+      m_use_filter = false;
+    }
+    if ((image.pitches[0] % 64) || (image.pitches[1] % 64))
+    {
+      CLog::Log(LOGNOTICE,"VAAPI::CheckUseFilter patches no multiple of 64");
+      m_use_filter = false;
+    }
+    if (m_use_filter)
+    {
+      m_frame_buffer = (uint8_t*)_aligned_malloc(image.height*image.width*2 + 256, 64);
+      m_cache = (uint8_t*)_aligned_malloc(CACHED_BUFFER_SIZE, 64);
+    }
+    vaDestroyImage(m_display->get(),image.image_id);
+  }
+  else
+  {
+    m_use_filter = false;
+  }
+}
+
+bool CDecoder::MapFrame(AVCodecContext* avctx, AVFrame* frame)
+{
+  if (m_surfaces_proc.empty())
+  {
+    return false;
+  }
+  if(frame)
+  {
+    CProcPic pic = m_surfaces_proc.front();
+    m_surfaces_proc.pop_front();
+    VASurfaceID surface = pic.surface->m_id;
+    VASurfaceStatus surf_status;
+    VAImage image;
+    uint8_t *buf;
+    CHECK(vaQuerySurfaceStatus(m_display->get(), surface, &surf_status))
+    while (surf_status != VASurfaceReady)
+    {
+      Sleep(1);
+      CHECK(vaQuerySurfaceStatus(m_display->get(), surface, &surf_status))
+    }
+    CHECK(vaDeriveImage(m_display->get(), surface, &image));
+    CHECK(vaMapBuffer(m_display->get(), image.buf, (void**)&buf))
+
+    uint8_t *src, *dst;
+    src = buf + image.offsets[0];
+    dst = m_frame_buffer + image.offsets[0];
+    m_dllSSE4.copy_frame(src, dst, m_cache, image.width, image.height, image.pitches[0]);
+    src = buf + image.offsets[1];
+    dst = m_frame_buffer + image.offsets[1];
+    m_dllSSE4.copy_frame(src, dst, m_cache, image.width, image.height/2, image.pitches[1]);
+
+    av_frame_unref(frame);
+    av_frame_move_ref(frame, &pic.frame);
+
+    frame->format = AV_PIX_FMT_NV12;
+    frame->data[0] = m_frame_buffer + image.offsets[0];
+    frame->linesize[0] = image.pitches[0];
+    frame->data[1] = m_frame_buffer + image.offsets[1];
+    frame->linesize[1] = image.pitches[1];
+    frame->data[2] = NULL;
+    frame->data[3] = NULL;
+    frame->pkt_size = image.data_size;
+
+    CHECK(vaUnmapBuffer(m_display->get(), image.buf))
+    CHECK(vaDestroyImage(m_display->get(),image.image_id))
+  }
+  return true;
+}
+
 #endif
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h	2014-08-13 18:26:06.836507656 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.h	2014-08-13 18:27:01.708779758 +0800
@@ -21,15 +21,18 @@
 
 #include "system_gl.h"
 
-#include "DllAvCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
-#include <libavcodec/vaapi.h>
 #include <va/va.h>
 #include <va/va_x11.h>
 #include <va/va_glx.h>
 #include <list>
 #include <boost/shared_ptr.hpp>
+#include "linux/sse4/DllLibSSE4.h"
 
+extern "C" {
+#include "libavcodec/vaapi.h"
+#include "libavcodec/avcodec.h"
+}
 
 namespace VAAPI {
 
@@ -101,11 +104,31 @@
   {}
 };
 
+struct CProcPic
+{
+  AVFrame frame;
+  CSurfacePtr surface;
+  CProcPic()
+  {}
+  CProcPic(const CProcPic &other)
+  {
+    memcpy(&this->frame, &other.frame, sizeof(AVFrame));
+    surface = other.surface;
+  }
+  CProcPic & operator= (const CProcPic &other)
+  {
+    memcpy(&this->frame, &other.frame, sizeof(AVFrame));
+    surface = other.surface;
+    return *this;
+  }
+};
+
 class CDecoder
   : public CDVDVideoCodecFFmpeg::IHardwareDecoder
 {
   bool EnsureContext(AVCodecContext *avctx);
   bool EnsureSurfaces(AVCodecContext *avctx, unsigned n_surfaces_count);
+  void CheckUseFilter();
 public:
   CDecoder();
  ~CDecoder();
@@ -114,12 +137,15 @@
   virtual bool GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture);
   virtual int  Check     (AVCodecContext* avctx);
   virtual void Close();
+  virtual void Reset();
   virtual const std::string Name() { return "vaapi"; }
   virtual CCriticalSection* Section() { if(m_display) return m_display.get(); else return NULL; }
   virtual unsigned GetAllowedReferences();
+  virtual bool UseFilter() { return m_use_filter; }
+  virtual bool MapFrame(AVCodecContext* avctx, AVFrame* frame);
 
-  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic);
-  void  RelBuffer(AVCodecContext *avctx, AVFrame *pic);
+  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags);
+  void  RelBuffer(uint8_t *data);
 
   VADisplay    GetDisplay() { return m_display->get(); }
 protected:
@@ -132,14 +158,20 @@
   int                    m_refs;
   std::list<CSurfacePtr> m_surfaces_used;
   std::list<CSurfacePtr> m_surfaces_free;
+  std::list<CProcPic>    m_surfaces_proc;
 
   CDisplayPtr    m_display;
   VAConfigID     m_config;
   VAContextID    m_context;
+  bool           m_use_filter;
+  uint8_t       *m_frame_buffer;
+  uint8_t       *m_cache;
 
   vaapi_context *m_hwaccel;
 
   CHolder        m_holder; // silly struct to pass data to renderer
+
+  DllLibSSE4     m_dllSSE4;
 };
 
 }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.cpp	2014-08-13 18:26:06.956508251 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.cpp	2014-08-13 18:27:01.096776723 +0800
@@ -22,21 +22,22 @@
 #include "osx/CocoaInterface.h"
 #include "DVDVideoCodec.h"
 #include "DVDCodecs/DVDCodecUtils.h"
+#include "utils/log.h"
 #include "VDA.h"
 
 extern "C" {
-  #include <libavcodec/vda.h>
+  #include "libavcodec/vda.h"
 }
 
 using namespace std;
 using namespace VDA;
 
 
-static void RelBufferS(AVCodecContext *avctx, AVFrame *pic)
-{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->RelBuffer(avctx, pic); }
+static void RelBufferS(void *opaque, uint8_t *data)
+{ ((CDecoder*)((CDVDVideoCodecFFmpeg*)opaque)->GetHardware())->RelBuffer(data); }
 
-static int GetBufferS(AVCodecContext *avctx, AVFrame *pic) 
-{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic); }
+static int GetBufferS(AVCodecContext *avctx, AVFrame *pic, int flags)
+{  return ((CDecoder*)((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetHardware())->GetBuffer(avctx, pic, flags); }
 
 CDecoder::CDecoder()
 : m_renderbuffers_count(0)
@@ -50,20 +51,25 @@
   free(m_ctx);
 }
 
-void CDecoder::RelBuffer(AVCodecContext *avctx, AVFrame *pic)
+void CDecoder::RelBuffer(uint8_t *data)
 {
-  CVPixelBufferRef cv_buffer = (CVPixelBufferRef)pic->data[3];
+  CVPixelBufferRef cv_buffer = (CVPixelBufferRef)data;
   CVPixelBufferRelease(cv_buffer);
-
-  for (int i = 0; i < 4; i++)
-    pic->data[i] = NULL;
 }
 
-int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic)
+int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags)
 {
-  pic->type = FF_BUFFER_TYPE_USER;
-  pic->data[0] = (uint8_t *)1;
+  pic->data[3] = (uint8_t *)(uintptr_t)1;
   pic->reordered_opaque = avctx->reordered_opaque;
+
+  AVBufferRef *buffer = av_buffer_create(pic->data[3], 0, RelBufferS, avctx->opaque, 0);
+  if (!buffer)
+  {
+    CLog::Log(LOGERROR, "VAAPI::%s - error creating buffer", __FUNCTION__);
+    return -1;
+  }
+  pic->buf[0] = buffer;
+
   return 0;
 }
 
@@ -234,9 +240,7 @@
 
   avctx->pix_fmt         = fmt;
   avctx->hwaccel_context = m_ctx;
-  avctx->get_buffer      = GetBufferS;
-  avctx->release_buffer  = RelBufferS;
-
+  avctx->get_buffer2     = GetBufferS;
   return true;
 }
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.h	2014-08-13 18:26:06.880507879 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDA.h	2014-08-13 18:27:01.096776723 +0800
@@ -21,7 +21,6 @@
 
 #include "system_gl.h"
 
-#include "DllAvCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 
 struct vda_context;
@@ -43,8 +42,8 @@
   virtual CCriticalSection* Section() {  return NULL; }
   virtual unsigned GetAllowedReferences();
 
-  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic);
-  void  RelBuffer(AVCodecContext *avctx, AVFrame *pic);
+  int   GetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags);
+  void  RelBuffer(uint8_t *data);
 protected:
   bool                   Create(AVCodecContext* avctx);
   unsigned               m_renderbuffers_count;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2014-08-13 18:26:06.832507641 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2014-08-13 18:27:01.632779377 +0800
@@ -488,7 +488,6 @@
   m_vdpauConfig.videoSurfaces = &m_videoSurfaces;
 
   m_vdpauConfigured = false;
-  m_hwContext.bitstream_buffers_allocated = 0;
   m_DisplayState = VDPAU_OPEN;
   m_vdpauConfig.context = 0;
 }
@@ -530,9 +529,6 @@
   m_DisplayState = VDPAU_OPEN;
   m_vdpauConfigured = false;
 
-  if (!m_dllAvUtil.Load())
-    return false;
-
   m_presentPicture = 0;
 
   {
@@ -581,12 +577,8 @@
 
       // finally setup ffmpeg
       memset(&m_hwContext, 0, sizeof(AVVDPAUContext));
-      m_hwContext.render = CDecoder::Render;
-      m_hwContext.bitstream_buffers_allocated = 0;
-      avctx->get_buffer      = CDecoder::FFGetBuffer;
-      avctx->reget_buffer    = CDecoder::FFGetBuffer;
-      avctx->release_buffer  = CDecoder::FFReleaseBuffer;
-      avctx->draw_horiz_band = CDecoder::FFDrawSlice;
+      m_hwContext.render2 = CDecoder::Render;
+      avctx->get_buffer2     = CDecoder::FFGetBuffer;
       avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
       avctx->hwaccel_context = &m_hwContext;
 
@@ -613,13 +605,6 @@
   FiniVDPAUOutput();
   m_vdpauOutput.Dispose();
 
-  if (m_hwContext.bitstream_buffers_allocated)
-  {
-    m_dllAvUtil.av_freep(&m_hwContext.bitstream_buffers);
-  }
-
-  m_dllAvUtil.Unload();
-
   if (m_vdpauConfig.context)
     m_vdpauConfig.context->Release();
   m_vdpauConfig.context = 0;
@@ -953,7 +938,7 @@
   return true;
 }
 
-int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
+int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags)
 {
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
   CDVDVideoCodecFFmpeg* ctx        = (CDVDVideoCodecFFmpeg*)avctx->opaque;
@@ -995,59 +980,50 @@
   pic->data[1] = pic->data[2] = NULL;
   pic->data[0] = (uint8_t*)(uintptr_t)surf;
   pic->data[3] = (uint8_t*)(uintptr_t)surf;
-
   pic->linesize[0] = pic->linesize[1] =  pic->linesize[2] = 0;
-
-  pic->type= FF_BUFFER_TYPE_USER;
+  AVBufferRef *buffer = av_buffer_create(pic->data[3], 0, FFReleaseBuffer, ctx, 0);
+  if (!buffer)
+  {
+    CLog::Log(LOGERROR, "CVDPAU::%s - error creating buffer", __FUNCTION__);
+    return -1;
+  }
+  pic->buf[0] = buffer;
 
   pic->reordered_opaque= avctx->reordered_opaque;
   return 0;
 }
 
-void CDecoder::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+void CDecoder::FFReleaseBuffer(void *opaque, uint8_t *data)
 {
-  CDVDVideoCodecFFmpeg* ctx        = (CDVDVideoCodecFFmpeg*)avctx->opaque;
-  CDecoder*             vdp        = (CDecoder*)ctx->GetHardware();
+  CDecoder *vdp = (CDecoder*)((CDVDVideoCodecFFmpeg*)opaque)->GetHardware();
 
   VdpVideoSurface surf;
   unsigned int i;
 
   CSingleLock lock(vdp->m_DecoderSection);
 
-  surf = (VdpVideoSurface)(uintptr_t)pic->data[3];
+  surf = (VdpVideoSurface)(uintptr_t)data;
 
   vdp->m_videoSurfaces.ClearReference(surf);
-
-  for(i=0; i<4; i++)
-    pic->data[i]= NULL;
-}
-
-VdpStatus CDecoder::Render( VdpDecoder decoder, VdpVideoSurface target,
-                            VdpPictureInfo const *picture_info,
-                            uint32_t bitstream_buffer_count,
-                            VdpBitstreamBuffer const * bitstream_buffers)
-{
-  return VDP_STATUS_OK;
 }
 
-void CDecoder::FFDrawSlice(struct AVCodecContext *s,
-                                           const AVFrame *src, int offset[4],
-                                           int y, int type, int height)
+int CDecoder::Render(struct AVCodecContext *s, struct AVFrame *src,
+                     const VdpPictureInfo *info, uint32_t buffers_used,
+                     const VdpBitstreamBuffer *buffers)
 {
   CDVDVideoCodecFFmpeg* ctx = (CDVDVideoCodecFFmpeg*)s->opaque;
-  CDecoder*               vdp = (CDecoder*)ctx->GetHardware();
+  CDecoder*             vdp = (CDecoder*)ctx->GetHardware();
 
   // while we are waiting to recover we can't do anything
   CSingleLock lock(vdp->m_DecoderSection);
 
   if(vdp->m_DisplayState != VDPAU_OPEN)
-    return;
+    return -1;
 
-  if(src->linesize[0] || src->linesize[1] || src->linesize[2]
-  || offset[0] || offset[1] || offset[2])
+  if(src->linesize[0] || src->linesize[1] || src->linesize[2])
   {
     CLog::Log(LOGERROR, "CVDPAU::FFDrawSlice - invalid linesizes or offsets provided");
-    return;
+    return -1;
   }
 
   VdpStatus vdp_st;
@@ -1057,37 +1033,34 @@
   if (!vdp->m_videoSurfaces.IsValid(surf))
   {
     CLog::Log(LOGWARNING, "CVDPAU::FFDrawSlice - ignoring invalid buffer");
-    return;
+    return -1;
   }
 
   uint32_t max_refs = 0;
   if(s->codec_id == AV_CODEC_ID_H264)
-    max_refs = vdp->m_hwContext.info.h264.num_ref_frames;
+    max_refs = s->refs;
 
   if(vdp->m_vdpauConfig.vdpDecoder == VDP_INVALID_HANDLE
   || vdp->m_vdpauConfigured == false
   || vdp->m_vdpauConfig.maxReferences < max_refs)
   {
     if(!vdp->ConfigVDPAU(s, max_refs))
-      return;
+      return -1;
   }
 
   uint64_t startTime = CurrentHostCounter();
   uint16_t decoded, processed, rend;
   vdp->m_bufferStats.Get(decoded, processed, rend);
   vdp_st = vdp->m_vdpauConfig.context->GetProcs().vdp_decoder_render(vdp->m_vdpauConfig.vdpDecoder,
-                                   surf,
-                                   (VdpPictureInfo const *)&(vdp->m_hwContext.info),
-                                   vdp->m_hwContext.bitstream_buffers_used,
-                                   vdp->m_hwContext.bitstream_buffers);
+                                                                     surf, info, buffers_used, buffers);
   if (vdp->CheckStatus(vdp_st, __LINE__))
-    vdp->m_DecoderError = true;
-  else
-    vdp->m_DecoderError = false;
+    return -1;
 
   uint64_t diff = CurrentHostCounter() - startTime;
   if (diff*1000/CurrentHostFrequency() > 30)
     CLog::Log(LOGDEBUG, "CVDPAU::DrawSlice - VdpDecoderRender long decoding: %d ms, dec: %d, proc: %d, rend: %d", (int)((diff*1000)/CurrentHostFrequency()), decoded, processed, rend);
+
+  return 0;
 }
 
 
@@ -1099,9 +1072,6 @@
 
   CSingleLock lock(m_DecoderSection);
 
-  if (m_DecoderError && pFrame)
-    return VC_ERROR;
-
   if (!m_vdpauConfigured)
     return VC_ERROR;
 
@@ -1126,8 +1096,7 @@
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -1999,10 +1968,10 @@
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
@@ -2323,8 +2292,7 @@
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2336,8 +2304,7 @@
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
   m_SeenInterlaceFlag |= interlaced;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2359,8 +2326,7 @@
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2014-08-13 18:26:06.816507562 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2014-08-13 18:27:00.996776223 +0800
@@ -40,19 +40,15 @@
 
 #include "system_gl.h"
 
-#include "DllAvUtil.h"
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
-#include "libavcodec/vdpau.h"
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #define GLX_GLXEXT_PROTOTYPES
 #include <GL/glx.h>
 
-#include "DllAvUtil.h"
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
-#include "libavcodec/vdpau.h"
 #include "threads/CriticalSection.h"
 #include "threads/SharedSection.h"
 #include "settings/VideoSettings.h"
@@ -61,6 +57,12 @@
 #include "threads/Thread.h"
 #include "utils/ActorProtocol.h"
 #include <list>
+#include <map>
+
+extern "C" {
+#include "libavutil/avutil.h"
+#include "libavcodec/vdpau.h"
+}
 
 using namespace Actor;
 
@@ -575,15 +577,11 @@
   EINTERLACEMETHOD AutoInterlaceMethod();
   static bool IsVDPAUFormat(PixelFormat fmt);
 
-  static void FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
-  static void FFDrawSlice(struct AVCodecContext *s,
-                          const AVFrame *src, int offset[4],
-                          int y, int type, int height);
-  static int FFGetBuffer(AVCodecContext *avctx, AVFrame *pic);
-  static VdpStatus Render( VdpDecoder decoder, VdpVideoSurface target,
-                           VdpPictureInfo const *picture_info,
-                           uint32_t bitstream_buffer_count,
-                           VdpBitstreamBuffer const * bitstream_buffers);
+  static void FFReleaseBuffer(void *opaque, uint8_t *data);
+  static int FFGetBuffer(AVCodecContext *avctx, AVFrame *pic, int flags);
+  static int Render(struct AVCodecContext *s, struct AVFrame *src,
+                    const VdpPictureInfo *info, uint32_t buffers_used,
+                    const VdpBitstreamBuffer *buffers);
 
   virtual void OnLostDevice();
   virtual void OnResetDevice();
@@ -614,7 +612,6 @@
   int m_ErrorCount;
   bool m_DecoderError;
 
-  DllAvUtil     m_dllAvUtil;
   ThreadIdentifier m_decoderThread;
   bool          m_vdpauConfigured;
   CVdpauConfig  m_vdpauConfig;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2014-08-13 18:26:07.088508910 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2014-08-13 18:27:01.696779699 +0800
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -50,12 +50,15 @@
 #include "utils/TimeUtils.h"
 #include "utils/StringUtils.h"
 #include "URL.h"
+#include "cores/FFmpeg.h"
+
+#define FF_MAX_EXTRADATA_SIZE ((1 << 28) - FF_INPUT_BUFFER_PADDING_SIZE)
 
 void CDemuxStreamAudioFFmpeg::GetStreamInfo(std::string& strInfo)
 {
   if(!m_stream) return;
   char temp[128];
-  m_parent->m_dllAvCodec.avcodec_string(temp, 128, m_stream->codec, 0);
+  avcodec_string(temp, 128, m_stream->codec, 0);
   strInfo = temp;
 }
 
@@ -81,7 +84,7 @@
 {
   if(!m_stream) return;
   char temp[128];
-  m_parent->m_dllAvCodec.avcodec_string(temp, 128, m_stream->codec, 0);
+  avcodec_string(temp, 128, m_stream->codec, 0);
   strInfo = temp;
 }
 
@@ -89,76 +92,10 @@
 {
   if(!m_stream) return;
   char temp[128];
-  m_parent->m_dllAvCodec.avcodec_string(temp, 128, m_stream->codec, 0);
+  avcodec_string(temp, 128, m_stream->codec, 0);
   strInfo = temp;
 }
 
-// these need to be put somewhere that are compiled, we should have some better place for it
-
-int DllAvFormat::m_avformat_refcnt = 0;
-CCriticalSection DllAvCodec::m_critSection;
-static CCriticalSection m_logSection;
-std::map<uintptr_t, CStdString> g_logbuffer;
-
-void ff_avutil_log(void* ptr, int level, const char* format, va_list va)
-{
-  CSingleLock lock(m_logSection);
-  uintptr_t threadId = (uintptr_t)CThread::GetCurrentThreadId();
-  CStdString &buffer = g_logbuffer[threadId];
-
-  AVClass* avc= ptr ? *(AVClass**)ptr : NULL;
-
-  if(level >= AV_LOG_DEBUG && 
-     (g_advancedSettings.m_extraLogLevels & LOGFFMPEG) == 0)
-    return;
-  else if(g_advancedSettings.m_logLevel <= LOG_LEVEL_NORMAL)
-    return;
-
-  int type;
-  switch(level)
-  {
-    case AV_LOG_INFO   : type = LOGINFO;    break;
-    case AV_LOG_ERROR  : type = LOGERROR;   break;
-    case AV_LOG_DEBUG  :
-    default            : type = LOGDEBUG;   break;
-  }
-
-  CStdString message = StringUtils::FormatV(format, va);
-  CStdString prefix = StringUtils::Format("ffmpeg[%X]: ", threadId);
-  if(avc)
-  {
-    if(avc->item_name)
-      prefix += CStdString("[") + avc->item_name(ptr) + "] ";
-    else if(avc->class_name)
-      prefix += CStdString("[") + avc->class_name + "] ";
-  }
-
-  buffer += message;
-  int pos, start = 0;
-  while( (pos = buffer.find_first_of('\n', start)) >= 0 )
-  {
-    if(pos>start)
-      CLog::Log(type, "%s%s", prefix.c_str(), buffer.substr(start, pos-start).c_str());
-    start = pos+1;
-  }
-  buffer.erase(0, start);
-}
-
-static void ff_flush_avutil_log_buffers(void)
-{
-  CSingleLock lock(m_logSection);
-
-  /* Loop through the logbuffer list and remove any blank buffers
-     If the thread using the buffer is still active, it will just
-     add a new buffer next time it writes to the log */
-  std::map<uintptr_t, CStdString>::iterator it;
-  for (it = g_logbuffer.begin(); it != g_logbuffer.end(); )
-    if ((*it).second.empty())
-      g_logbuffer.erase(it++);
-    else
-      ++it;
-}
-
 static int interrupt_cb(void* ctx)
 {
   CDVDDemuxFFmpeg* demuxer = static_cast<CDVDDemuxFFmpeg*>(ctx);
@@ -167,6 +104,7 @@
   return 0;
 }
 
+
 ////////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////////
 /*
@@ -190,7 +128,7 @@
   return -1;
 }
 */
-static offset_t dvd_file_seek(void *h, offset_t pos, int whence)
+static int64_t dvd_file_seek(void *h, int64_t pos, int whence)
 {
   if(interrupt_cb(h))
     return AVERROR_EXIT;
@@ -217,6 +155,8 @@
   m_program = UINT_MAX;
   m_pkt.result = -1;
   memset(&m_pkt.pkt, 0, sizeof(AVPacket));
+  m_streaminfo = true; /* set to true if we want to look for streams before playback */
+  m_checkvideo = false;
 }
 
 CDVDDemuxFFmpeg::~CDVDDemuxFFmpeg()
@@ -237,10 +177,11 @@
   return false;
 }
 
-bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
+bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo)
 {
   AVInputFormat* iformat = NULL;
   std::string strFile;
+  m_streaminfo = streaminfo;
   m_iCurrentPts = DVD_NOPTS_VALUE;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_program = UINT_MAX;
@@ -248,38 +189,26 @@
 
   if (!pInput) return false;
 
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllAvFormat.Load())  {
-    CLog::Log(LOGERROR,"CDVDDemuxFFmpeg::Open - failed to load ffmpeg libraries");
-    return false;
-  }
-
-  // register codecs
-  m_dllAvFormat.av_register_all();
-
   m_pInput = pInput;
   strFile = m_pInput->GetFileName();
 
-  bool streaminfo = true; /* set to true if we want to look for streams before playback*/
-
   if( m_pInput->GetContent().length() > 0 )
   {
     std::string content = m_pInput->GetContent();
 
     /* check if we can get a hint from content */
     if     ( content.compare("video/x-vobsub") == 0 )
-      iformat = m_dllAvFormat.av_find_input_format("mpeg");
+      iformat = av_find_input_format("mpeg");
     else if( content.compare("video/x-dvd-mpeg") == 0 )
-      iformat = m_dllAvFormat.av_find_input_format("mpeg");
+      iformat = av_find_input_format("mpeg");
     else if( content.compare("video/x-mpegts") == 0 )
-      iformat = m_dllAvFormat.av_find_input_format("mpegts");
+      iformat = av_find_input_format("mpegts");
     else if( content.compare("multipart/x-mixed-replace") == 0 )
-      iformat = m_dllAvFormat.av_find_input_format("mjpeg");
-    else if( content.compare("audio/flac") == 0 )
-      iformat = m_dllAvFormat.av_find_input_format("flac");
+      iformat = av_find_input_format("mjpeg");
   }
 
   // open the demuxer
-  m_pFormatContext  = m_dllAvFormat.avformat_alloc_context();
+  m_pFormatContext  = avformat_alloc_context();
   m_pFormatContext->interrupt_callback = int_cb;
 
   // try to abort after 30 seconds
@@ -300,26 +229,26 @@
       // try mmsh, then mmst
       url.SetProtocol("mmsh");
       url.SetProtocolOptions("");
-      result = m_dllAvFormat.avformat_open_input(&m_pFormatContext, url.Get().c_str(), iformat, &options);
+      result = avformat_open_input(&m_pFormatContext, url.Get().c_str(), iformat, &options);
       if (result < 0)
       {
         url.SetProtocol("mmst");
         strFile = url.Get();
       } 
     }
-    if (result < 0 && m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, &options) < 0 )
+    if (result < 0 && avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, &options) < 0 )
     {
       CLog::Log(LOGDEBUG, "Error, could not open file %s", CURL::GetRedacted(strFile).c_str());
       Dispose();
-      m_dllAvUtil.av_dict_free(&options);
+      av_dict_free(&options);
       return false;
     }
-    m_dllAvUtil.av_dict_free(&options);
+    av_dict_free(&options);
   }
   else
   {
-    unsigned char* buffer = (unsigned char*)m_dllAvUtil.av_malloc(FFMPEG_FILE_BUFFER_SIZE);
-    m_ioContext = m_dllAvFormat.avio_alloc_context(buffer, FFMPEG_FILE_BUFFER_SIZE, 0, this, dvd_file_read, NULL, dvd_file_seek);
+    unsigned char* buffer = (unsigned char*)av_malloc(FFMPEG_FILE_BUFFER_SIZE);
+    m_ioContext = avio_alloc_context(buffer, FFMPEG_FILE_BUFFER_SIZE, 0, this, dvd_file_read, NULL, dvd_file_seek);
     m_ioContext->max_packet_size = m_pInput->GetBlockSize();
     if(m_ioContext->max_packet_size)
       m_ioContext->max_packet_size *= FFMPEG_FILE_BUFFER_SIZE / m_ioContext->max_packet_size;
@@ -334,7 +263,7 @@
       bool trySPDIFonly = (m_pInput->GetContent() == "audio/x-spdif-compressed");
 
       if (!trySPDIFonly)
-        m_dllAvFormat.av_probe_input_buffer(m_ioContext, &iformat, strFile.c_str(), NULL, 0, 0);
+        av_probe_input_buffer(m_ioContext, &iformat, strFile.c_str(), NULL, 0, 0);
 
       // Use the more low-level code in case we have been built against an old
       // FFmpeg without the above av_probe_input_buffer(), or in case we only
@@ -351,7 +280,7 @@
         pd.filename = strFile.c_str();
 
         // read data using avformat's buffers
-        pd.buf_size = m_dllAvFormat.avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
+        pd.buf_size = avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
         if (pd.buf_size <= 0)
         {
           CLog::Log(LOGERROR, "%s - error reading from input stream, %s", __FUNCTION__, CURL::GetRedacted(strFile).c_str());
@@ -360,7 +289,7 @@
         memset(pd.buf+pd.buf_size, 0, AVPROBE_PADDING_SIZE);
 
         // restore position again
-        m_dllAvFormat.avio_seek(m_ioContext , 0, SEEK_SET);
+        avio_seek(m_ioContext , 0, SEEK_SET);
 
         // the advancedsetting is for allowing the user to force outputting the
         // 44.1 kHz DTS wav file as PCM, so that an A/V receiver can decode
@@ -374,7 +303,7 @@
           // AC3 is always wrapped in iec61937 (ffmpeg "spdif"), while DTS
           // may be just padded.
           AVInputFormat *iformat2;
-          iformat2 = m_dllAvFormat.av_find_input_format("spdif");
+          iformat2 = av_find_input_format("spdif");
 
           if (iformat2 && iformat2->read_probe(&pd) > AVPROBE_SCORE_MAX / 4)
           {
@@ -383,7 +312,7 @@
           else
           {
             // not spdif or no spdif demuxer, try dts
-            iformat2 = m_dllAvFormat.av_find_input_format("dts");
+            iformat2 = av_find_input_format("dts");
 
             if (iformat2 && iformat2->read_probe(&pd) > AVPROBE_SCORE_MAX / 4)
             {
@@ -406,13 +335,13 @@
 
         /* check if we can get a hint from content */
         if( content.compare("audio/aacp") == 0 )
-          iformat = m_dllAvFormat.av_find_input_format("aac");
+          iformat = av_find_input_format("aac");
         else if( content.compare("audio/aac") == 0 )
-          iformat = m_dllAvFormat.av_find_input_format("aac");
+          iformat = av_find_input_format("aac");
         else if( content.compare("video/flv") == 0 )
-          iformat = m_dllAvFormat.av_find_input_format("flv");
+          iformat = av_find_input_format("flv");
         else if( content.compare("video/x-flv") == 0 )
-          iformat = m_dllAvFormat.av_find_input_format("flv");
+          iformat = av_find_input_format("flv");
       }
 
       if (!iformat)
@@ -432,7 +361,7 @@
 
     m_pFormatContext->pb = m_ioContext;
 
-    if (m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, NULL) < 0)
+    if (avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, NULL) < 0)
     {
       CLog::Log(LOGERROR, "%s - Error, could not open file %s", __FUNCTION__, CURL::GetRedacted(strFile).c_str());
       Dispose();
@@ -448,19 +377,24 @@
   if (iformat && (strcmp(iformat->name, "mjpeg") == 0) && m_ioContext->seekable == 0)
     m_pFormatContext->max_analyze_duration = 500000;
 
+  if (iformat && (strcmp(iformat->name, "mpegts") == 0))
+  {
+    m_pFormatContext->max_analyze_duration = 500000;
+    m_checkvideo = true;
+  }
+
   // we need to know if this is matroska or avi later
   m_bMatroska = strncmp(m_pFormatContext->iformat->name, "matroska", 8) == 0;	// for "matroska.webm"
   m_bAVI = strcmp(m_pFormatContext->iformat->name, "avi") == 0;
 
-  if (streaminfo)
+  if (m_streaminfo)
   {
-    /* too speed up dvd switches, only analyse very short */
+    /* to speed up dvd switches, only analyse very short */
     if(m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD))
       m_pFormatContext->max_analyze_duration = 500000;
 
-
     CLog::Log(LOGDEBUG, "%s - avformat_find_stream_info starting", __FUNCTION__);
-    int iErr = m_dllAvFormat.avformat_find_stream_info(m_pFormatContext, NULL);
+    int iErr = avformat_find_stream_info(m_pFormatContext, NULL);
     if (iErr < 0)
     {
       CLog::Log(LOGWARNING,"could not find codec parameters for %s", CURL::GetRedacted(strFile).c_str());
@@ -477,7 +411,19 @@
       }
     }
     CLog::Log(LOGDEBUG, "%s - av_find_stream_info finished", __FUNCTION__);
+
+    if (m_checkvideo)
+    {
+      // make sure we start video with an i-frame
+      ResetVideoStreams();
+    }
   }
+  else
+  {
+    m_program = 0;
+    m_checkvideo = true;
+  }
+
   // reset any timeout
   m_timeout.SetInfinite();
 
@@ -485,19 +431,22 @@
   m_pFormatContext->flags |= AVFMT_FLAG_NONBLOCK;
 
   // print some extra information
-  m_dllAvFormat.av_dump_format(m_pFormatContext, 0, strFile.c_str(), 0);
+  av_dump_format(m_pFormatContext, 0, strFile.c_str(), 0);
 
   UpdateCurrentPTS();
 
   CreateStreams();
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
 void CDVDDemuxFFmpeg::Dispose()
 {
   m_pkt.result = -1;
-  m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   if (m_pFormatContext)
   {
@@ -506,13 +455,13 @@
       CLog::Log(LOGWARNING, "CDVDDemuxFFmpeg::Dispose - demuxer changed our byte context behind our back, possible memleak");
       m_ioContext = m_pFormatContext->pb;
     }
-    m_dllAvFormat.avformat_close_input(&m_pFormatContext);
+    avformat_close_input(&m_pFormatContext);
   }
 
   if(m_ioContext)
   {
-    m_dllAvUtil.av_free(m_ioContext->buffer);
-    m_dllAvUtil.av_free(m_ioContext);
+    av_free(m_ioContext->buffer);
+    av_free(m_ioContext);
   }
 
   m_ioContext = NULL;
@@ -522,29 +471,25 @@
   DisposeStreams();
 
   m_pInput = NULL;
-
-  m_dllAvFormat.Unload();
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
 }
 
 void CDVDDemuxFFmpeg::Reset()
 {
   CDVDInputStream* pInputStream = m_pInput;
   Dispose();
-  Open(pInputStream);
+  Open(pInputStream, m_streaminfo);
 }
 
 void CDVDDemuxFFmpeg::Flush()
 {
   // naughty usage of an internal ffmpeg function
   if (m_pFormatContext)
-    m_dllAvFormat.av_read_frame_flush(m_pFormatContext);
+    av_read_frame_flush(m_pFormatContext);
 
   m_iCurrentPts = DVD_NOPTS_VALUE;
 
   m_pkt.result = -1;
-  m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 }
 
 void CDVDDemuxFFmpeg::Abort()
@@ -560,12 +505,12 @@
   if(m_speed != DVD_PLAYSPEED_PAUSE && iSpeed == DVD_PLAYSPEED_PAUSE)
   {
     m_pInput->Pause((double)m_iCurrentPts);
-    m_dllAvFormat.av_read_pause(m_pFormatContext);
+    av_read_pause(m_pFormatContext);
   }
   else if(m_speed == DVD_PLAYSPEED_PAUSE && iSpeed != DVD_PLAYSPEED_PAUSE)
   {
     m_pInput->Pause((double)m_iCurrentPts);
-    m_dllAvFormat.av_read_play(m_pFormatContext);
+    av_read_play(m_pFormatContext);
   }
   m_speed = iSpeed;
 
@@ -606,10 +551,10 @@
       const CStdString &value = it->second;
 
       if (name.Equals("seekable"))
-        m_dllAvUtil.av_dict_set(&options, "seekable", value.c_str(), 0);
+        av_dict_set(&options, "seekable", value.c_str(), 0);
       else if (name.Equals("User-Agent"))
       {
-        m_dllAvUtil.av_dict_set(&options, "user-agent", value.c_str(), 0);
+        av_dict_set(&options, "user-agent", value.c_str(), 0);
         hasUserAgent = true;
       }
       else if (!name.Equals("auth") && !name.Equals("Encoding"))
@@ -618,14 +563,14 @@
     }
     if (!hasUserAgent)
       // set default xbmc user-agent.
-      m_dllAvUtil.av_dict_set(&options, "user-agent", g_advancedSettings.m_userAgent.c_str(), 0);
+      av_dict_set(&options, "user-agent", g_advancedSettings.m_userAgent.c_str(), 0);
 
     if (!headers.empty())
-      m_dllAvUtil.av_dict_set(&options, "headers", headers.c_str(), 0);
+      av_dict_set(&options, "headers", headers.c_str(), 0);
 
     std::string cookies;
     if (XFILE::CCurlFile::GetCookies(url, cookies))
-      m_dllAvUtil.av_dict_set(&options, "cookies", cookies.c_str(), 0);
+      av_dict_set(&options, "cookies", cookies.c_str(), 0);
 
   }
   return options;
@@ -636,6 +581,12 @@
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -678,7 +629,7 @@
 
       // timeout reads after 100ms
       m_timeout.Set(20000);
-      m_pkt.result = m_dllAvFormat.av_read_frame(m_pFormatContext, &m_pkt.pkt);
+      m_pkt.result = av_read_frame(m_pFormatContext, &m_pkt.pkt);
       m_timeout.SetInfinite();
     }
 
@@ -717,29 +668,36 @@
         CLog::Log(LOGERROR, "CDVDDemuxFFmpeg::Read() returned invalid packet and eof reached");
 
       m_pkt.result = -1;
-      m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+      av_free_packet(&m_pkt.pkt);
     }
     else
     {
+      ParsePacket(&m_pkt.pkt);
+
       AVStream *stream = m_pFormatContext->streams[m_pkt.pkt.stream_index];
 
-      if (m_program != UINT_MAX)
+      if (IsVideoReady())
       {
-        /* check so packet belongs to selected program */
-        for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
+        if (m_program != UINT_MAX)
         {
-          if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
+          /* check so packet belongs to selected program */
+          for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
           {
-            pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
-            break;
+            if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
+            {
+              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+              break;
+            }
           }
-        }
 
-        if (!pPacket)
-          bReturnEmpty = true;
+          if (!pPacket)
+            bReturnEmpty = true;
+        }
+        else
+          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
       }
       else
-        pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+        bReturnEmpty = true;
 
       if (pPacket)
       {
@@ -775,6 +733,24 @@
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -803,7 +779,7 @@
           if(duration > stream->duration)
           {
             stream->duration = duration;
-            duration = m_dllAvUtil.av_rescale_rnd(stream->duration, (int64_t)stream->time_base.num * AV_TIME_BASE, stream->time_base.den, AV_ROUND_NEAR_INF);
+            duration = av_rescale_rnd(stream->duration, (int64_t)stream->time_base.num * AV_TIME_BASE, stream->time_base.den, AV_ROUND_NEAR_INF);
             if ((m_pFormatContext->duration == (int64_t)AV_NOPTS_VALUE)
                 ||  (m_pFormatContext->duration != (int64_t)AV_NOPTS_VALUE && duration > m_pFormatContext->duration))
               m_pFormatContext->duration = duration;
@@ -815,7 +791,7 @@
         pPacket->iStreamId = m_pkt.pkt.stream_index;
       }
       m_pkt.result = -1;
-      m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+      av_free_packet(&m_pkt.pkt);
     }
   }
   } // end of lock scope
@@ -872,7 +848,7 @@
     time = 0;
 
   m_pkt.result = -1;
-  m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   CDVDInputStream::ISeekTime* ist = dynamic_cast<CDVDInputStream::ISeekTime*>(m_pInput);
   if (ist)
@@ -905,10 +881,19 @@
   int ret;
   {
     CSingleLock lock(m_critSection);
-    ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
+    ret = av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -927,16 +912,175 @@
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
-  int ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, pos, AVSEEK_FLAG_BYTE);
+  int ret = av_seek_frame(m_pFormatContext, -1, pos, AVSEEK_FLAG_BYTE);
 
   if(ret >= 0)
     UpdateCurrentPTS();
 
   m_pkt.result = -1;
-  m_dllAvCodec.av_free_packet(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   return (ret >= 0);
 }
@@ -1085,8 +1229,8 @@
         if (st->iBitsPerSample == 0)
           st->iBitsPerSample = pStream->codec->bits_per_coded_sample;
 	
-        if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
-          st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
+        if(av_dict_get(pStream->metadata, "title", NULL, 0))
+          st->m_description = av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 
         break;
       }
@@ -1104,7 +1248,7 @@
           st->bPTSInvalid = true;
 
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-        AVRational r_frame_rate = m_dllAvFormat.av_stream_get_r_frame_rate(pStream);
+        AVRational r_frame_rate = av_stream_get_r_frame_rate(pStream);
 #else
         AVRational r_frame_rate = pStream->r_frame_rate;
 #endif
@@ -1153,11 +1297,11 @@
         st->iOrientation = 0;
         st->iBitsPerPixel = pStream->codec->bits_per_coded_sample;
 
-        AVDictionaryEntry *rtag = m_dllAvUtil.av_dict_get(pStream->metadata, "rotate", NULL, 0);
+        AVDictionaryEntry *rtag = av_dict_get(pStream->metadata, "rotate", NULL, 0);
         if (rtag) 
           st->iOrientation = atoi(rtag->value);
 
-        rtag = m_dllAvUtil.av_dict_get(pStream->metadata, "stereo_mode", NULL, 0);
+        rtag = av_dict_get(pStream->metadata, "stereo_mode", NULL, 0);
         if (rtag && rtag->value)
           st->stereo_mode = rtag->value;
 
@@ -1198,8 +1342,8 @@
           CDemuxStreamSubtitleFFmpeg* st = new CDemuxStreamSubtitleFFmpeg(this, pStream);
           stream = st;
 	    
-          if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
-            st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
+          if(av_dict_get(pStream->metadata, "title", NULL, 0))
+            st->m_description = av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 	
           break;
         }
@@ -1212,7 +1356,7 @@
         {
           std::string fileName = "special://temp/fonts/";
           XFILE::CDirectory::Create(fileName);
-          AVDictionaryEntry *nameTag = m_dllAvUtil.av_dict_get(pStream->metadata, "filename", NULL, 0);
+          AVDictionaryEntry *nameTag = av_dict_get(pStream->metadata, "filename", NULL, 0);
           if (!nameTag) {
             CLog::Log(LOGERROR, "%s: TTF attachment has no name", __FUNCTION__);
             break;
@@ -1253,7 +1397,7 @@
     stream->pPrivate = pStream;
     stream->flags = (CDemuxStream::EFlags)pStream->disposition;
 
-    AVDictionaryEntry *langTag = m_dllAvUtil.av_dict_get(pStream->metadata, "language", NULL, 0);
+    AVDictionaryEntry *langTag = av_dict_get(pStream->metadata, "language", NULL, 0);
     if (langTag)
       strncpy(stream->language, langTag->value, 3);
 
@@ -1384,7 +1528,7 @@
     if(chapterIdx <= 0)
       return;
 
-    AVDictionaryEntry *titleTag = m_dllAvUtil.av_dict_get(m_pFormatContext->chapters[chapterIdx-1]->metadata,
+    AVDictionaryEntry *titleTag = av_dict_get(m_pFormatContext->chapters[chapterIdx-1]->metadata,
                                                           "title", NULL, 0);
     if (titleTag)
       strChapterName = titleTag->value;
@@ -1465,7 +1609,7 @@
     }
 #endif
 
-    AVCodec *codec = m_dllAvCodec.avcodec_find_decoder(stream->codec);
+    AVCodec *codec = avcodec_find_decoder(stream->codec);
     if (codec)
       strName = codec->name;
   }
@@ -1493,3 +1637,128 @@
   }
   return false;
 }
+
+void CDVDDemuxFFmpeg::ParsePacket(AVPacket *pkt)
+{
+  AVStream *st = m_pFormatContext->streams[pkt->stream_index];
+  CDemuxStream *stream = GetStreamInternal(pkt->stream_index);
+
+  // if the stream is new, tell ffmpeg to parse the stream
+  if (!stream && !st->parser)
+  {
+    st->need_parsing = AVSTREAM_PARSE_FULL;
+  }
+
+  // split extradata
+  if(st->parser && st->parser->parser->split && !st->codec->extradata)
+  {
+    int i = st->parser->parser->split(st->codec, pkt->data, pkt->size);
+    if (i > 0 && i < FF_MAX_EXTRADATA_SIZE)
+    {
+      // Found extradata, fill it in. This will cause
+      // a new stream to be created and used.
+      st->codec->extradata_size = i;
+      st->codec->extradata = (uint8_t*)av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+      if (st->codec->extradata)
+      {
+        CLog::Log(LOGDEBUG, "CDVDDemuxFFmpeg::Read() fetching extradata, extradata_size(%d)", st->codec->extradata_size);
+        memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);
+        memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
+      }
+      else
+      {
+        st->codec->extradata_size = 0;
+      }
+    }
+  }
+
+  // for video we need a decoder to get desired information into codec context
+  if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && st->codec->extradata &&
+      (!st->codec->width || st->codec->pix_fmt == PIX_FMT_NONE))
+  {
+    // open a decoder, it will be cleared down by ffmpeg on closing the stream
+    if (!st->codec->codec)
+    {
+      const AVCodec* codec;
+      AVDictionary *thread_opt = NULL;
+      codec = avcodec_find_decoder(st->codec->codec_id);
+      // Force thread count to 1 since the h264 decoder will not extract
+      // SPS and PPS to extradata during multi-threaded decoding
+      av_dict_set(&thread_opt, "threads", "1", 0);
+      avcodec_open2(st->codec, codec, &thread_opt);
+
+      av_dict_free(&thread_opt);
+    }
+
+    // We don't need to actually decode here
+    // we just want to transport SPS data into codec context
+    st->codec->skip_idct = AVDISCARD_ALL;
+    st->codec->skip_frame = AVDISCARD_ALL;
+    st->codec->skip_loop_filter = AVDISCARD_ALL;
+
+    // We are looking for an IDR frame
+    AVFrame picture;
+    memset(&picture, 0, sizeof(AVFrame));
+    picture.pts = picture.pkt_dts = picture.pkt_pts = picture.best_effort_timestamp = AV_NOPTS_VALUE;
+    picture.pkt_pos = -1;
+    picture.key_frame = 1;
+    picture.format = -1;
+
+    int got_picture = 0;
+    avcodec_decode_video2(st->codec, &picture, &got_picture, pkt);
+  }
+}
+
+bool CDVDDemuxFFmpeg::IsVideoReady()
+{
+  AVStream *st;
+  bool hasVideo = false;
+
+  if(!m_checkvideo)
+    return true;
+
+  if(m_program != UINT_MAX)
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->programs[m_program]->nb_stream_indexes; i++)
+    {
+      int idx = m_pFormatContext->programs[m_program]->stream_index[i];
+      st = m_pFormatContext->streams[idx];
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+      {
+        if (st->codec->width && st->codec->pix_fmt != PIX_FMT_NONE)
+          return true;
+        hasVideo = true;
+      }
+    }
+  }
+  else
+  {
+    for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+    {
+      st = m_pFormatContext->streams[i];
+      if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+      {
+        if (st->codec->width && st->codec->pix_fmt != PIX_FMT_NONE)
+          return true;
+        hasVideo = true;
+      }
+    }
+  }
+  return !hasVideo;
+}
+
+void CDVDDemuxFFmpeg::ResetVideoStreams()
+{
+  AVStream *st;
+  for (unsigned int i = 0; i < m_pFormatContext->nb_streams; i++)
+  {
+    st = m_pFormatContext->streams[i];
+    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
+    {
+      if (st->codec->extradata)
+        av_free(st->codec->extradata);
+      st->codec->extradata = NULL;
+      st->codec->width = 0;
+    }
+  }
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2014-08-13 18:26:07.096508950 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2014-08-13 18:27:01.696779699 +0800
@@ -21,15 +21,14 @@
  */
 
 #include "DVDDemux.h"
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
-
 #include "threads/CriticalSection.h"
 #include "threads/SystemClock.h"
-
 #include <map>
 
+extern "C" {
+#include "libavformat/avformat.h"
+}
+
 class CDVDDemuxFFmpeg;
 class CURL;
 
@@ -89,7 +88,7 @@
   CDVDDemuxFFmpeg();
   virtual ~CDVDDemuxFFmpeg();
 
-  bool Open(CDVDInputStream* pInput);
+  bool Open(CDVDInputStream* pInput, bool streaminfo = true);
   void Dispose();
   void Reset();
   void Flush();
@@ -100,6 +99,7 @@
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -127,6 +127,9 @@
   CDemuxStream* GetStreamInternal(int iStreamId);
   void CreateStreams(unsigned int program = UINT_MAX);
   void DisposeStreams();
+  void ParsePacket(AVPacket *pkt);
+  bool IsVideoReady();
+  void ResetVideoStreams();
 
   AVDictionary *GetFFMpegOptionsFromURL(const CURL &url);
   double ConvertTimestamp(int64_t pts, int den, int num);
@@ -139,10 +142,6 @@
 
   AVIOContext* m_ioContext;
 
-  DllAvFormat m_dllAvFormat;
-  DllAvCodec  m_dllAvCodec;
-  DllAvUtil   m_dllAvUtil;
-
   double   m_iCurrentPts; // used for stream length estimation
   bool     m_bMatroska;
   bool     m_bAVI;
@@ -158,5 +157,10 @@
     AVPacket pkt;       // packet ffmpeg returned
     int      result;    // result from av_read_packet
   }m_pkt;
+
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
+  bool m_streaminfo;
+  bool m_checkvideo;
 };
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2014-08-13 18:26:07.112509029 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2014-08-13 18:27:00.652774521 +0800
@@ -34,7 +34,10 @@
 #if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
   #include "config.h"
 #endif
-#include "DllAvCodec.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 
 #ifndef __GNUC__
 #pragma warning(pop)
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2014-08-13 18:26:07.092508925 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2014-08-13 18:27:01.516778806 +0800
@@ -47,12 +47,12 @@
 {
   if (m_parser)
   {
-    m_parent->m_dllAvCodec.av_parser_close(m_parser);
+    av_parser_close(m_parser);
     m_parser = NULL;
   }
   if (m_context)
   {
-    m_parent->m_dllAvCodec.avcodec_close(m_context);
+    avcodec_close(m_context);
     m_context = NULL;
   }
 }
@@ -113,17 +113,8 @@
 
 bool CDVDDemuxPVRClient::Open(CDVDInputStream* pInput)
 {
-  if (!m_dllAvCodec.Load())
-  {
-    CLog::Log(LOGWARNING, "%s could not load ffmpeg", __FUNCTION__);
-    return false;
-  }
-
   Abort();
 
-  // register codecs
-  m_dllAvCodec.avcodec_register_all();
-
   m_pInput = pInput;
   if (!g_PVRClients->GetPlayingClient(m_pvrClient))
     return false;
@@ -141,8 +132,6 @@
   }
 
   m_pInput = NULL;
-
-  m_dllAvCodec.Unload();
 }
 
 void CDVDDemuxPVRClient::DisposeStream(int iStreamId)
@@ -192,7 +181,7 @@
 
   if(pvr->m_context == NULL)
   {
-    AVCodec *codec = m_dllAvCodec.avcodec_find_decoder(st->codec);
+    AVCodec *codec = avcodec_find_decoder(st->codec);
     if (codec == NULL)
     {
       CLog::Log(LOGERROR, "%s - can't find decoder", __FUNCTION__);
@@ -200,7 +189,7 @@
       return;
     }
 
-    pvr->m_context = m_dllAvCodec.avcodec_alloc_context3(codec);
+    pvr->m_context = avcodec_alloc_context3(codec);
     if(pvr->m_context == NULL)
     {
       CLog::Log(LOGERROR, "%s - can't allocate context", __FUNCTION__);
@@ -231,7 +220,7 @@
 
   uint8_t *outbuf = NULL;
   int      outbuf_size = 0;
-  int len = m_dllAvCodec.av_parser_parse2(pvr->m_parser
+  int len = av_parser_parse2(pvr->m_parser
                                         , pvr->m_context, &outbuf, &outbuf_size
                                         , pkt->pData, pkt->iSize
                                         , (int64_t)(pkt->pts * DVD_TIME_BASE)
@@ -339,15 +328,13 @@
       if (stm)
       {
         st = dynamic_cast<CDemuxStreamAudioPVRClient*>(stm);
-        if (!st
-            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
-            || (st->iChannels != props.stream[i].iChannels))
+        if (!st || (st->codec != (AVCodecID)props.stream[i].iCodecId))
           DisposeStream(i);
       }
       if (!m_streams[i])
       {
         st = new CDemuxStreamAudioPVRClient(this);
-        st->m_parser = m_dllAvCodec.av_parser_init(props.stream[i].iCodecId);
+        st->m_parser = av_parser_init(props.stream[i].iCodecId);
         if(st->m_parser)
           st->m_parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
       }
@@ -358,6 +345,7 @@
       st->iBitsPerSample  = props.stream[i].iBitsPerSample;
       m_streams[i] = st;
       st->m_parser_split = true;
+      st->changes++;
     }
     else if (props.stream[i].iCodecType == XBMC_CODEC_TYPE_VIDEO)
     {
@@ -374,7 +362,7 @@
       if (!m_streams[i])
       {
         st = new CDemuxStreamVideoPVRClient(this);
-        st->m_parser = m_dllAvCodec.av_parser_init(props.stream[i].iCodecId);
+        st->m_parser = av_parser_init(props.stream[i].iCodecId);
         if(st->m_parser)
           st->m_parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
       }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h	2014-08-13 18:26:07.112509029 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.h	2014-08-13 18:27:00.656774534 +0800
@@ -21,11 +21,13 @@
 
 #include "DVDDemux.h"
 #include <map>
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-
 #include "pvr/addons/PVRClient.h"
 
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+}
+
 class CDVDDemuxPVRClient;
 struct PVR_STREAM_PROPERTIES;
 
@@ -108,8 +110,6 @@
   CDemuxStream* m_streams[MAX_STREAMS]; // maximum number of streams that ffmpeg can handle
   boost::shared_ptr<PVR::CPVRClient> m_pvrClient;
 
-  DllAvCodec  m_dllAvCodec;
-
 private:
   void RequestStreams();
   void ParsePacket(DemuxPacket* pPacket);
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2014-08-13 18:26:07.056508752 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2014-08-13 18:27:00.656774534 +0800
@@ -24,7 +24,10 @@
 #include "DVDDemuxUtils.h"
 #include "DVDClock.h"
 #include "utils/log.h"
-#include "DllAvCodec.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 
 void CDVDDemuxUtils::FreeDemuxPacket(DemuxPacket* pPacket)
 {
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp	2014-08-13 18:26:07.056508752 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDDemuxers/DVDFactoryDemuxer.cpp	2014-08-13 18:27:01.692779675 +0800
@@ -99,26 +99,31 @@
   }
 #endif
 
+  bool streaminfo = true; /* Look for streams before playback */
   if (pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
   {
     CDVDInputStreamPVRManager* pInputStreamPVR = (CDVDInputStreamPVRManager*)pInputStream;
     CDVDInputStream* pOtherStream = pInputStreamPVR->GetOtherStream();
+
+    /* Don't parse the streaminfo for some cases of streams to reduce the channel switch time */
+    bool useFastswitch = URIUtils::IsUsingFastSwitch(pInputStream->GetFileName());
+    streaminfo = !useFastswitch;
+
     if(pOtherStream)
     {
       /* Used for MediaPortal PVR addon (uses PVR otherstream for playback of rtsp streams) */
       if (pOtherStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
       {
         auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
-        if(demuxer->Open(pOtherStream))
+        if(demuxer->Open(pOtherStream, streaminfo))
           return demuxer.release();
         else
           return NULL;
       }
     }
 
-    std::string filename = pInputStream->GetFileName();
     /* Use PVR demuxer only for live streams */
-    if (filename.substr(0, 14) == "pvr://channels")
+    if (URIUtils::IsPVRChannel(pInputStream->GetFileName()))
     {
       boost::shared_ptr<CPVRClient> client;
       if (g_PVRClients->GetPlayingClient(client) &&
@@ -133,8 +138,14 @@
     }
   }
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_FFMPEG))
+  {
+    bool useFastswitch = URIUtils::IsUsingFastSwitch(pInputStream->GetFileName());
+    streaminfo = !useFastswitch;
+  }
+
   auto_ptr<CDVDDemuxFFmpeg> demuxer(new CDVDDemuxFFmpeg());
-  if(demuxer->Open(pInputStream))
+  if(demuxer->Open(pInputStream, streaminfo))
     return demuxer.release();
   else
     return NULL;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDFileInfo.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDFileInfo.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2014-08-13 18:26:06.808507522 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDFileInfo.cpp	2014-08-13 18:27:00.660774557 +0800
@@ -46,9 +46,10 @@
 #include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 #include "DVDDemuxers/DVDDemuxVobsub.h"
 
-#include "DllAvCodec.h"
-#include "DllSwScale.h"
+#include "libavcodec/avcodec.h"
+#include "libswscale/swscale.h"
 #include "filesystem/File.h"
+#include "cores/FFmpeg.h"
 #include "TextureCache.h"
 #include "Util.h"
 #include "utils/LangCodeExpander.h"
@@ -263,11 +264,8 @@
               aspect = hint.aspect;
             unsigned int nHeight = (unsigned int)((double)g_advancedSettings.GetThumbSize() / aspect);
 
-            DllSwScale dllSwScale;
-            dllSwScale.Load();
-
             uint8_t *pOutBuf = new uint8_t[nWidth * nHeight * 4];
-            struct SwsContext *context = dllSwScale.sws_getContext(picture.iWidth, picture.iHeight,
+            struct SwsContext *context = sws_getContext(picture.iWidth, picture.iHeight,
                   PIX_FMT_YUV420P, nWidth, nHeight, PIX_FMT_BGRA, SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
 
             if (context)
@@ -277,8 +275,8 @@
               uint8_t *dst[] = { pOutBuf, 0, 0, 0 };
               int     dstStride[] = { (int)nWidth*4, 0, 0, 0 };
               int orientation = DegreeToOrientation(hint.orientation);
-              dllSwScale.sws_scale(context, src, srcStride, 0, picture.iHeight, dst, dstStride);
-              dllSwScale.sws_freeContext(context);
+              sws_scale(context, src, srcStride, 0, picture.iHeight, dst, dstStride);
+              sws_freeContext(context);
 
               details.width = nWidth;
               details.height = nHeight;
@@ -286,7 +284,6 @@
               bOk = true;
             }
 
-            dllSwScale.Unload();
             delete [] pOutBuf;
           }
         }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDMessage.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDMessage.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDMessage.h	2014-08-13 18:26:06.764507299 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDMessage.h	2014-08-13 18:27:01.508778762 +0800
@@ -220,7 +220,7 @@
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -228,6 +228,7 @@
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -235,6 +236,7 @@
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -242,6 +244,7 @@
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayer.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayer.cpp	2014-08-13 18:26:06.808507522 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayer.cpp	2014-08-13 18:27:01.508778762 +0800
@@ -51,7 +51,7 @@
 #include "ApplicationMessenger.h"
 #include "filesystem/File.h"
 #include "pictures/Picture.h"
-#include "DllSwScale.h"
+#include "libswscale/swscale.h"
 #ifdef HAS_VIDEO_PLAYBACK
 #include "cores/VideoRenderers/RenderManager.h"
 #endif
@@ -1633,12 +1633,14 @@
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo.GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1657,7 +1659,7 @@
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2143,7 +2145,7 @@
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2279,9 +2281,10 @@
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2294,6 +2297,13 @@
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet
@@ -3288,7 +3298,7 @@
   return true;
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate)
@@ -3300,19 +3310,23 @@
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3356,7 +3370,7 @@
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayer.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayer.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayer.h	2014-08-13 18:26:06.804507497 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayer.h	2014-08-13 18:27:01.512778782 +0800
@@ -308,7 +308,7 @@
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -357,8 +357,9 @@
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-08-13 18:26:06.808507522 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2014-08-13 18:27:01.708779758 +0800
@@ -38,6 +38,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
@@ -320,8 +321,10 @@
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -431,6 +434,7 @@
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -443,6 +447,7 @@
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -460,8 +465,10 @@
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -507,6 +514,28 @@
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -525,28 +554,6 @@
       // decoder still needs to provide an empty image structure, with correct flags
       m_pVideoCodec->SetDropState(bRequestDrop);
 
-      // ask codec to do deinterlacing if possible
-      EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-      EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
-
-      unsigned int     mFilters = 0;
-
-      if (mDeintMode != VS_DEINTERLACEMODE_OFF)
-      {
-        if (mInt == VS_INTERLACEMETHOD_DEINTERLACE)
-          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY;
-        else if(mInt == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
-          mFilters = CDVDVideoCodec::FILTER_DEINTERLACE_ANY | CDVDVideoCodec::FILTER_DEINTERLACE_HALFED;
-
-        if (mDeintMode == VS_DEINTERLACEMODE_AUTO && mFilters)
-          mFilters |=  CDVDVideoCodec::FILTER_DEINTERLACE_FLAGGED;
-      }
-
-      if (!g_renderManager.Supports(RENDERFEATURE_ROTATION))
-        mFilters |= CDVDVideoCodec::FILTER_ROTATE;
-
-      mFilters = m_pVideoCodec->SetFilters(mFilters);
-
       int iDecoderState = m_pVideoCodec->Decode(pPacket->pData, pPacket->iSize, pPacket->dts, pPacket->pts);
 
       // buffer packets so we can recover should decoder flush for some reason
@@ -559,15 +566,7 @@
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
       // reset the request, the following while loop may break before
       // setting the flag to a new value
       bRequestDrop = false;
@@ -641,6 +640,8 @@
 
             //Deinterlace if codec said format was interlaced or if we have selected we want to deinterlace
             //this video
+            EDEINTERLACEMODE mDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+            EINTERLACEMETHOD mInt       = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
             if ((mDeintMode == VS_DEINTERLACEMODE_AUTO && (picture.iFlags & DVP_FLAG_INTERLACED)) || mDeintMode == VS_DEINTERLACEMODE_FORCE)
             {
               if(mInt == VS_INTERLACEMETHOD_SW_BLEND)
@@ -683,10 +684,20 @@
             }
 
             if (picture.iRepeatPicture)
+            {
+              double pts;
+              int skipped, deint;
+              m_pVideoCodec->GetCodecStats(pts, skipped, deint);
+              picture.iDuration = frametime;
+              if (deint && (frametime <= 0.02*DVD_TIME_BASE))
+                picture.iDuration *= 2;
               picture.iDuration *= picture.iRepeatPicture + 1;
+            }
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();
@@ -1031,13 +1042,16 @@
 
 #ifdef HAS_VIDEO_PLAYBACK
   double config_framerate = m_bFpsInvalid ? 0.0 : m_fFrameRate;
+  double render_framerate = g_graphicsContext.GetFPS();
+  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") == ADJUST_REFRESHRATE_OFF)
+    render_framerate = config_framerate;
   /* check so that our format or aspect has changed. if it has, reconfigure renderer */
   if (!g_renderManager.IsConfigured()
    || ( m_output.width           != pPicture->iWidth )
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 && render_framerate != config_framerate)
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
@@ -1176,33 +1190,12 @@
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimeStamp += iFrameDuration;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
-  {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1235,7 +1228,7 @@
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1455,6 +1448,22 @@
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
@@ -1479,7 +1488,7 @@
   double frameduration = m_pullupCorrection.GetFrameDuration();
 
   if (frameduration == DVD_NOPTS_VALUE ||
-      (g_advancedSettings.m_videoFpsDetect == 1 && m_pullupCorrection.GetPatternLength() > 1))
+      (g_advancedSettings.m_videoFpsDetect == 1 && (m_pullupCorrection.GetPatternLength() > 1 && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;
@@ -1535,3 +1544,138 @@
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  int    interlaced;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iSkippedDeint = 0;
+  int    iBufferLevel;
+
+  m_droppingStats.m_lastPts = pts;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  if (interlaced)
+    iInterval = 2/m_fFrameRate*(double)DVD_TIME_BASE;
+  else
+    iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+
+  m_FlipTimeStamp = m_pClock->GetAbsoluteClock() + max(0.0, iSleepTime) + iInterval;
+
+  if( m_stalled )
+    m_iCurrentPts = DVD_NOPTS_VALUE;
+  else
+    m_iCurrentPts = iRenderPts - max(0.0, iSleepTime);
+
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop
+      && m_droppingStats.m_dropRequests > 0)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iSkippedDeint)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped de-interlacing cycle, Sleeptime: %f, Bufferlevel: %d", iSleepTime, iBufferLevel);
+    }
+    else if (iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        result |= EOS_VERYLATE;
+        if (bNewFrame)
+          m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayerVideo.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2014-08-13 18:26:06.804507497 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2014-08-13 18:27:01.512778782 +0800
@@ -36,6 +36,26 @@
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  double m_lastPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
+
 class CDVDPlayerVideo : public CThread
 {
 public:
@@ -81,7 +101,7 @@
 
   bool InitializedOutputDevice();
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
   int    GetPullupCorrection()                     { return m_pullupCorrection.GetPatternLength(); }
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
@@ -104,6 +124,7 @@
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -129,6 +150,7 @@
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -182,5 +204,7 @@
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDStreamInfo.h xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDStreamInfo.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/dvdplayer/DVDStreamInfo.h	2014-08-13 18:26:06.800507482 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/dvdplayer/DVDStreamInfo.h	2014-08-13 18:27:00.668774591 +0800
@@ -25,7 +25,10 @@
 #endif
 
 #include "DVDDemuxers/DVDDemux.h"
-#include "DllAvCodec.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+}
 
 class CDemuxStream;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/FFmpeg.cpp xbmc-13.2rc1-Gotham/xbmc/cores/FFmpeg.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/FFmpeg.cpp	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/FFmpeg.cpp	2014-08-13 18:27:00.772775117 +0800
@@ -0,0 +1,126 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "cores/FFmpeg.h"
+#include "utils/log.h"
+#include "threads/SharedSection.h"
+#include "utils/StdString.h"
+#include "utils/StringUtils.h"
+#include "threads/Thread.h"
+#include "settings/AdvancedSettings.h"
+#include <map>
+
+/* callback for the ffmpeg lock manager */
+int ffmpeg_lockmgr_cb(void **mutex, enum AVLockOp operation)
+{
+  CSharedSection **lock = (CSharedSection **)mutex;
+
+  switch (operation)
+  {
+    case AV_LOCK_CREATE:
+    {
+      *lock = NULL;
+      *lock = new CSharedSection();
+      if (*lock == NULL)
+        return 1;
+      break;
+    }
+    case AV_LOCK_OBTAIN:
+      (*lock)->lock();
+      break;
+
+    case AV_LOCK_RELEASE:
+      (*lock)->unlock();
+      break;
+
+    case AV_LOCK_DESTROY:
+    {
+      delete *lock;
+      *lock = NULL;
+      break;
+    }
+
+    default:
+      return 1;
+  }
+  return 0;
+}
+
+static CCriticalSection m_logSection;
+std::map<uintptr_t, CStdString> g_logbuffer;
+
+void ff_flush_avutil_log_buffers(void)
+{
+  CSingleLock lock(m_logSection);
+  /* Loop through the logbuffer list and remove any blank buffers
+     If the thread using the buffer is still active, it will just
+     add a new buffer next time it writes to the log */
+  std::map<uintptr_t, CStdString>::iterator it;
+  for (it = g_logbuffer.begin(); it != g_logbuffer.end(); )
+    if ((*it).second.empty())
+      g_logbuffer.erase(it++);
+    else
+      ++it;
+}
+
+void ff_avutil_log(void* ptr, int level, const char* format, va_list va)
+{
+  CSingleLock lock(m_logSection);
+  uintptr_t threadId = (uintptr_t)CThread::GetCurrentThreadId();
+  CStdString &buffer = g_logbuffer[threadId];
+
+  AVClass* avc= ptr ? *(AVClass**)ptr : NULL;
+
+  if(level >= AV_LOG_DEBUG &&
+     (g_advancedSettings.m_extraLogLevels & LOGFFMPEG) == 0)
+    return;
+  else if(g_advancedSettings.m_logLevel <= LOG_LEVEL_NORMAL)
+    return;
+
+  int type;
+  switch(level)
+  {
+    case AV_LOG_INFO   : type = LOGINFO;    break;
+    case AV_LOG_ERROR  : type = LOGERROR;   break;
+    case AV_LOG_DEBUG  :
+    default            : type = LOGDEBUG;   break;
+  }
+
+  CStdString message = StringUtils::FormatV(format, va);
+  CStdString prefix = StringUtils::Format("ffmpeg[%X]: ", threadId);
+  if(avc)
+  {
+    if(avc->item_name)
+      prefix += CStdString("[") + avc->item_name(ptr) + "] ";
+    else if(avc->class_name)
+      prefix += CStdString("[") + avc->class_name + "] ";
+  }
+
+  buffer += message;
+  int pos, start = 0;
+  while( (pos = buffer.find_first_of('\n', start)) >= 0 )
+  {
+    if(pos>start)
+      CLog::Log(type, "%s%s", prefix.c_str(), buffer.substr(start, pos-start).c_str());
+    start = pos+1;
+  }
+  buffer.erase(0, start);
+}
+
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/FFmpeg.h xbmc-13.2rc1-Gotham/xbmc/cores/FFmpeg.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/FFmpeg.h	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/FFmpeg.h	2014-08-13 18:27:01.000776247 +0800
@@ -0,0 +1,76 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#include "utils/CPUInfo.h"
+
+extern "C" {
+#include "libswscale/swscale.h"
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libavutil/ffversion.h"
+#include "libavfilter/avfilter.h"
+#include "libpostproc/postprocess.h"
+}
+
+inline int SwScaleCPUFlags()
+{
+  unsigned int cpuFeatures = g_cpuInfo.GetCPUFeatures();
+  int flags = 0;
+
+  if (cpuFeatures & CPU_FEATURE_MMX)
+    flags |= SWS_CPU_CAPS_MMX;
+  if (cpuFeatures & CPU_FEATURE_MMX2)
+    flags |= SWS_CPU_CAPS_MMX2;
+  if (cpuFeatures & CPU_FEATURE_3DNOW)
+    flags |= SWS_CPU_CAPS_3DNOW;
+  if (cpuFeatures & CPU_FEATURE_ALTIVEC)
+    flags |= SWS_CPU_CAPS_ALTIVEC;
+
+  return flags;
+}
+
+inline int PPCPUFlags()
+{
+  unsigned int cpuFeatures = g_cpuInfo.GetCPUFeatures();
+  int flags = 0;
+
+  if (cpuFeatures & CPU_FEATURE_MMX)
+    flags |= PP_CPU_CAPS_MMX;
+  if (cpuFeatures & CPU_FEATURE_MMX2)
+    flags |= PP_CPU_CAPS_MMX2;
+  if (cpuFeatures & CPU_FEATURE_3DNOW)
+    flags |= PP_CPU_CAPS_3DNOW;
+  if (cpuFeatures & CPU_FEATURE_ALTIVEC)
+    flags |= PP_CPU_CAPS_ALTIVEC;
+
+  return flags;
+}
+
+// callback used for locking
+int ffmpeg_lockmgr_cb(void **mutex, enum AVLockOp operation);
+
+// callback used for logging
+void ff_avutil_log(void* ptr, int level, const char* format, va_list va);
+void ff_flush_avutil_log_buffers(void);
+
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/Makefile.in xbmc-13.2rc1-Gotham/xbmc/cores/Makefile.in
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/Makefile.in	2014-08-13 18:26:07.704511965 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/Makefile.in	2014-08-13 18:27:00.784775172 +0800
@@ -1,4 +1,5 @@
 SRCS = DummyVideoPlayer.cpp
+SRCS += FFmpeg.cpp
 
 LIB = cores.a
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodec.h xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodec.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodec.h	2014-08-13 18:26:07.652511702 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodec.h	2014-08-13 18:27:00.672774615 +0800
@@ -26,7 +26,7 @@
   #include "config.h"
 #endif
 #include <vector>
-#include "DllAvCodec.h"
+#include "libavcodec/avcodec.h"
 
 struct AVStream;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2014-08-13 18:26:07.652511702 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -44,7 +44,7 @@
 
 COMXAudioCodecOMX::~COMXAudioCodecOMX()
 {
-  m_dllAvUtil.av_free(m_pBufferOutput);
+  av_free(m_pBufferOutput);
   m_pBufferOutput = NULL;
   m_iBufferOutputAlloced = 0;
   Dispose();
@@ -55,12 +55,7 @@
   AVCodec* pCodec;
   m_bOpenedCodec = false;
 
-  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllSwResample.Load())
-    return false;
-
-  m_dllAvCodec.avcodec_register_all();
-
-  pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
+  pCodec = avcodec_find_decoder(hints.codec);
   if (!pCodec)
   {
     CLog::Log(LOGDEBUG,"COMXAudioCodecOMX::Open() Unable to find codec %d", hints.codec);
@@ -68,7 +63,7 @@
   }
 
   m_bFirstFrame = true;
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = 1;
@@ -89,18 +84,18 @@
   if( hints.extradata && hints.extrasize > 0 )
   {
     m_pCodecContext->extradata_size = hints.extrasize;
-    m_pCodecContext->extradata = (uint8_t*)m_dllAvUtil.av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + FF_INPUT_BUFFER_PADDING_SIZE);
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
   }
 
-  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
+  if (avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"COMXAudioCodecOMX::Open() Unable to open codec");
     Dispose();
     return false;
   }
 
-  m_pFrame1 = m_dllAvCodec.avcodec_alloc_frame();
+  m_pFrame1 = av_frame_alloc();
   m_bOpenedCodec = true;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
   m_desiredSampleFormat = m_pCodecContext->sample_fmt == AV_SAMPLE_FMT_S16 ? AV_SAMPLE_FMT_S16 : AV_SAMPLE_FMT_FLTP;
@@ -109,26 +104,22 @@
 
 void COMXAudioCodecOMX::Dispose()
 {
-  if (m_pFrame1) m_dllAvUtil.av_free(m_pFrame1);
+  if (m_pFrame1) av_free(m_pFrame1);
   m_pFrame1 = NULL;
 
   if (m_pConvert)
-    m_dllSwResample.swr_free(&m_pConvert);
+    swr_free(&m_pConvert);
 
   if (m_pCodecContext)
   {
-    if (m_pCodecContext->extradata) m_dllAvUtil.av_free(m_pCodecContext->extradata);
+    if (m_pCodecContext->extradata) av_free(m_pCodecContext->extradata);
     m_pCodecContext->extradata = NULL;
-    if (m_bOpenedCodec) m_dllAvCodec.avcodec_close(m_pCodecContext);
+    if (m_bOpenedCodec) avcodec_close(m_pCodecContext);
     m_bOpenedCodec = false;
-    m_dllAvUtil.av_free(m_pCodecContext);
+    av_free(m_pCodecContext);
     m_pCodecContext = NULL;
   }
 
-  m_dllAvCodec.Unload();
-  m_dllAvUtil.Unload();
-  m_dllSwResample.Unload();
-
   m_bGotFrame = false;
 }
 
@@ -139,10 +130,10 @@
 
   AVPacket avpkt;
   m_bGotFrame = false;
-  m_dllAvCodec.av_init_packet(&avpkt);
+  av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
-  iBytesUsed = m_dllAvCodec.avcodec_decode_audio4( m_pCodecContext
+  iBytesUsed = avcodec_decode_audio4( m_pCodecContext
                                                  , m_pFrame1
                                                  , &got_frame
                                                  , &avpkt);
@@ -176,15 +167,15 @@
     return 0;
   int inLineSize, outLineSize;
   /* input audio is aligned */
-  int inputSize = m_dllAvUtil.av_samples_get_buffer_size(&inLineSize, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 0);
+  int inputSize = av_samples_get_buffer_size(&inLineSize, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 0);
   /* output audio will be packed */
-  int outputSize = m_dllAvUtil.av_samples_get_buffer_size(&outLineSize, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1);
+  int outputSize = av_samples_get_buffer_size(&outLineSize, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1);
   bool cont = !m_pFrame1->data[1] || (m_pFrame1->data[1] == m_pFrame1->data[0] + inLineSize && inLineSize == outLineSize && inLineSize * m_pCodecContext->channels == inputSize);
 
   if (m_iBufferOutputAlloced < outputSize)
   {
-     m_dllAvUtil.av_free(m_pBufferOutput);
-     m_pBufferOutput = (BYTE*)m_dllAvUtil.av_malloc(outputSize + FF_INPUT_BUFFER_PADDING_SIZE);
+     av_free(m_pBufferOutput);
+     m_pBufferOutput = (BYTE*)av_malloc(outputSize + FF_INPUT_BUFFER_PADDING_SIZE);
      m_iBufferOutputAlloced = outputSize;
   }
   *dst = m_pBufferOutput;
@@ -194,21 +185,21 @@
   {
     if(m_pConvert && (m_pCodecContext->sample_fmt != m_iSampleFormat || m_channels != m_pCodecContext->channels))
     {
-      m_dllSwResample.swr_free(&m_pConvert);
+      swr_free(&m_pConvert);
       m_channels = m_pCodecContext->channels;
     }
 
     if(!m_pConvert)
     {
       m_iSampleFormat = m_pCodecContext->sample_fmt;
-      m_pConvert = m_dllSwResample.swr_alloc_set_opts(NULL,
-                      m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
+      m_pConvert = swr_alloc_set_opts(NULL,
+                      av_get_default_channel_layout(m_pCodecContext->channels), 
                       m_desiredSampleFormat, m_pCodecContext->sample_rate,
-                      m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels), 
+                      av_get_default_channel_layout(m_pCodecContext->channels), 
                       m_pCodecContext->sample_fmt, m_pCodecContext->sample_rate,
                       0, NULL);
 
-      if(!m_pConvert || m_dllSwResample.swr_init(m_pConvert) < 0)
+      if(!m_pConvert || swr_init(m_pConvert) < 0)
       {
         CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to initialise convert format %d to %d", m_pCodecContext->sample_fmt, m_desiredSampleFormat);
         return 0;
@@ -217,8 +208,8 @@
 
     /* use unaligned flag to keep output packed */
     uint8_t *out_planes[m_pCodecContext->channels];
-    if(m_dllAvUtil.av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
-       m_dllSwResample.swr_convert(m_pConvert, out_planes, m_pFrame1->nb_samples, (const uint8_t **)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
+    if(av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
+       swr_convert(m_pConvert, out_planes, m_pFrame1->nb_samples, (const uint8_t **)m_pFrame1->data, m_pFrame1->nb_samples) < 0)
     {
       CLog::Log(LOGERROR, "COMXAudioCodecOMX::Decode - Unable to convert format %d to %d", (int)m_pCodecContext->sample_fmt, m_desiredSampleFormat);
       outputSize = 0;
@@ -235,8 +226,8 @@
     {
       /* copy to a contiguous buffer */
       uint8_t *out_planes[m_pCodecContext->channels];
-      if (m_dllAvUtil.av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
-        m_dllAvUtil.av_samples_copy(out_planes, m_pFrame1->data, 0, 0, m_pFrame1->nb_samples, m_pCodecContext->channels, m_desiredSampleFormat) < 0 )
+      if (av_samples_fill_arrays(out_planes, NULL, m_pBufferOutput, m_pCodecContext->channels, m_pFrame1->nb_samples, m_desiredSampleFormat, 1) < 0 ||
+        av_samples_copy(out_planes, m_pFrame1->data, 0, 0, m_pFrame1->nb_samples, m_pCodecContext->channels, m_desiredSampleFormat) < 0 )
       {
         outputSize = 0;
       }
@@ -253,7 +244,7 @@
 
 void COMXAudioCodecOMX::Reset()
 {
-  if (m_pCodecContext) m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
+  if (m_pCodecContext) avcodec_flush_buffers(m_pCodecContext);
   m_bGotFrame = false;
 }
 
@@ -302,7 +293,7 @@
   else
   {
     CLog::Log(LOGINFO, "COMXAudioCodecOMX::GetChannelMap - FFmpeg reported %d channels, but the layout contains %d ignoring", m_pCodecContext->channels, bits);
-    layout = m_dllAvUtil.av_get_default_channel_layout(m_pCodecContext->channels);
+    layout = av_get_default_channel_layout(m_pCodecContext->channels);
   }
   return layout;
 }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodecOMX.h xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodecOMX.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2014-08-13 18:26:07.700511941 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudioCodecOMX.h	2014-08-13 18:27:00.676774642 +0800
@@ -21,10 +21,13 @@
  */
 
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvFormat.h"
-#include "DllAvUtil.h"
-#include "DllSwResample.h"
+
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavformat/avformat.h"
+#include "libavutil/avutil.h"
+#include "libswresample/swresample.h"
+}
 
 #include "DVDStreamInfo.h"
 #include "linux/PlatformDefs.h"
@@ -63,7 +66,4 @@
 
   bool m_bFirstFrame;
   bool m_bGotFrame;
-  DllAvCodec m_dllAvCodec;
-  DllAvUtil m_dllAvUtil;
-  DllSwResample m_dllSwResample;
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudio.cpp xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudio.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudio.cpp	2014-08-13 18:26:07.696511926 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudio.cpp	2014-08-13 18:27:00.672774615 +0800
@@ -41,6 +41,10 @@
 #include "cores/AudioEngine/Utils/AEConvert.h"
 #include "cores/AudioEngine/AEFactory.h"
 
+extern "C" {
+#include "libavutil/crc.h"
+}
+
 using namespace std;
 
 static const uint16_t AC3Bitrates[] = {32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 448, 512, 576, 640};
@@ -414,9 +418,6 @@
 
   Deinitialize();
 
-  if(!m_dllAvUtil.Load())
-    return false;
-
   m_HWDecode    = bUseHWDecode;
   m_Passthrough = bUsePassthrough;
 
@@ -746,8 +747,6 @@
   m_extradata = NULL;
   m_extrasize = 0;
 
-  m_dllAvUtil.Unload();
-
   while(!m_ampqueue.empty())
     m_ampqueue.pop_front();
 
@@ -1543,7 +1542,7 @@
     else crc_size = (framesize >> 1) + (framesize >> 3) - 1;
 
     if (crc_size <= iSize - skip)
-      if(m_dllAvUtil.av_crc(m_dllAvUtil.av_crc_get_table(AV_CRC_16_ANSI), 0, &pData[2], crc_size * 2))
+      if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &pData[2], crc_size * 2))
         continue;
 
     /* if we get here, we can sync */
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudio.h xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudio.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXAudio.h	2014-08-13 18:26:07.696511926 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXAudio.h	2014-08-13 18:27:00.672774615 +0800
@@ -36,12 +36,15 @@
 
 #include "OMXClock.h"
 #include "OMXCore.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
 #include "PCMRemap.h"
 
 #include "threads/CriticalSection.h"
 
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+}
+
 #define AUDIO_BUFFER_SECONDS 3
 #define VIS_PACKET_SIZE 512
 
@@ -164,7 +167,6 @@
   COMXCoreTunel     m_omx_tunnel_decoder;
   COMXCoreTunel     m_omx_tunnel_splitter_analog;
   COMXCoreTunel     m_omx_tunnel_splitter_hdmi;
-  DllAvUtil         m_dllAvUtil;
 
   static void CheckOutputBufferSize(void **buffer, int *oldSize, int newSize);
   CCriticalSection m_critSection;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXPlayer.cpp xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXPlayer.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXPlayer.cpp	2014-08-13 18:26:07.656511727 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXPlayer.cpp	2014-08-13 18:27:01.596779198 +0800
@@ -86,7 +86,7 @@
 #include "ApplicationMessenger.h"
 #include "filesystem/File.h"
 #include "pictures/Picture.h"
-#include "DllSwScale.h"
+#include "libswscale/swscale.h"
 #ifdef HAS_VIDEO_PLAYBACK
 #include "cores/VideoRenderers/RenderManager.h"
 #endif
@@ -2548,7 +2548,8 @@
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
 
         m_playSpeed = speed;
-        m_caching = CACHESTATE_DONE;
+        if (m_caching != CACHESTATE_PVR && m_playSpeed != DVD_PLAYSPEED_NORMAL)
+          m_caching = CACHESTATE_DONE;
         m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
         m_av_clock.OMXPause();
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXVideoCodec.h xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXVideoCodec.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/omxplayer/OMXVideoCodec.h	2014-08-13 18:26:07.704511965 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/omxplayer/OMXVideoCodec.h	2014-08-13 18:27:00.992776204 +0800
@@ -89,8 +89,8 @@
   unsigned int extended_format;
   int iGroupId;
 
-  int8_t* qscale_table; // Quantization parameters, primarily used by filters
-  int qscale_stride;
+  int8_t* qp_table; // Quantization parameters, primarily used by filters
+  int qstride;
   int qscale_type;
 
   unsigned int iWidth;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/BaseRenderer.h xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/BaseRenderer.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/BaseRenderer.h	2014-08-13 18:26:07.232509625 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/BaseRenderer.h	2014-08-13 18:27:01.184777156 +0800
@@ -29,7 +29,7 @@
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 class CSetting;
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2014-08-13 18:26:07.188509401 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2014-08-13 18:27:00.604774283 +0800
@@ -40,7 +40,6 @@
 #include "guilib/Texture.h"
 #include "guilib/LocalizeStrings.h"
 #include "threads/SingleLock.h"
-#include "DllSwScale.h"
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "utils/StringUtils.h"
@@ -48,6 +47,11 @@
 #include "RenderFormats.h"
 #include "cores/IPlayer.h"
 #include "cores/dvdplayer/DVDCodecs/DVDCodecUtils.h"
+#include "cores/FFmpeg.h"
+
+extern "C" {
+#include "libswscale/swscale.h"
+}
 
 #ifdef HAVE_LIBVDPAU
 #include "cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
@@ -191,8 +195,6 @@
   m_nonLinStretch = false;
   m_nonLinStretchGui = false;
   m_pixelRatio = 0.0f;
-
-  m_dllSwScale = new DllSwScale;
 }
 
 CLinuxRendererGL::~CLinuxRendererGL()
@@ -213,7 +215,7 @@
 
   if (m_context)
   {
-    m_dllSwScale->sws_freeContext(m_context);
+    sws_freeContext(m_context);
     m_context = NULL;
   }
 
@@ -223,8 +225,6 @@
     delete m_pYUVShader;
     m_pYUVShader = NULL;
   }
-
-  delete m_dllSwScale;
 }
 
 bool CLinuxRendererGL::ValidateRenderer()
@@ -779,9 +779,6 @@
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
 
-  if (!m_dllSwScale->Load())
-    CLog::Log(LOGERROR,"CLinuxRendererGL::PreInit - failed to load rescale libraries!");
-
   return true;
 }
 
@@ -1131,7 +1128,7 @@
 
   if (m_context)
   {
-    m_dllSwScale->sws_freeContext(m_context);
+    sws_freeContext(m_context);
     m_context = NULL;
   }
 
@@ -3159,14 +3156,14 @@
     m_rgbBuffer = (BYTE*)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB) + PBO_OFFSET;
   }
 
-  m_context = m_dllSwScale->sws_getCachedContext(m_context,
-                                                 im->width, im->height, srcFormat,
-                                                 im->width, im->height, PIX_FMT_BGRA,
+  m_context = sws_getCachedContext(m_context,
+                                                 im->width, im->height, (AVPixelFormat)srcFormat,
+                                                 im->width, im->height, (AVPixelFormat)PIX_FMT_BGRA,
                                                  SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
 
   uint8_t *dst[]       = { m_rgbBuffer, 0, 0, 0 };
   int      dstStride[] = { (int)m_sourceWidth * 4, 0, 0, 0 };
-  m_dllSwScale->sws_scale(m_context, src, srcStride, 0, im->height, dst, dstStride);
+  sws_scale(m_context, src, srcStride, 0, im->height, dst, dstStride);
 
   if (m_rgbPbo)
   {
@@ -3239,9 +3236,9 @@
     m_rgbBuffer = (BYTE*)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB) + PBO_OFFSET;
   }
 
-  m_context = m_dllSwScale->sws_getCachedContext(m_context,
-                                                 im->width, im->height >> 1, srcFormat,
-                                                 im->width, im->height >> 1, PIX_FMT_BGRA,
+  m_context = sws_getCachedContext(m_context,
+                                                 im->width, im->height >> 1, (AVPixelFormat)srcFormat,
+                                                 im->width, im->height >> 1, (AVPixelFormat)PIX_FMT_BGRA,
                                                  SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
   uint8_t *dstTop[]    = { m_rgbBuffer, 0, 0, 0 };
   uint8_t *dstBot[]    = { m_rgbBuffer + m_sourceWidth * m_sourceHeight * 2, 0, 0, 0 };
@@ -3249,8 +3246,8 @@
 
   //convert each YUV field to an RGB field, the top field is placed at the top of the rgb buffer
   //the bottom field is placed at the bottom of the rgb buffer
-  m_dllSwScale->sws_scale(m_context, srcTop, srcStrideTop, 0, im->height >> 1, dstTop, dstStride);
-  m_dllSwScale->sws_scale(m_context, srcBot, srcStrideBot, 0, im->height >> 1, dstBot, dstStride);
+  sws_scale(m_context, srcTop, srcStrideTop, 0, im->height >> 1, dstTop, dstStride);
+  sws_scale(m_context, srcBot, srcStrideBot, 0, im->height >> 1, dstBot, dstStride);
 
   if (m_rgbPbo)
   {
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-08-13 18:26:07.188509401 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-08-13 18:27:00.616774338 +0800
@@ -34,6 +34,7 @@
 #include "utils/fastmemcpy.h"
 #include "utils/MathUtils.h"
 #include "utils/GLUtils.h"
+#include "utils/log.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/DisplaySettings.h"
 #include "settings/MediaSettings.h"
@@ -43,7 +44,6 @@
 #include "VideoShaders/VideoFilterShader.h"
 #include "windowing/WindowingFactory.h"
 #include "guilib/Texture.h"
-#include "lib/DllSwScale.h"
 #include "../dvdplayer/DVDCodecs/Video/OpenMaxVideo.h"
 #include "threads/SingleLock.h"
 #include "RenderCapture.h"
@@ -51,6 +51,10 @@
 #include "xbmc/Application.h"
 #include "cores/IPlayer.h"
 
+extern "C" {
+#include "libswscale/swscale.h"
+}
+
 #if defined(__ARM_NEON__)
 #include "yuv2rgb.neon.h"
 #include "utils/CPUInfo.h"
@@ -132,7 +136,6 @@
   m_rgbBuffer = NULL;
   m_rgbBufferSize = 0;
 
-  m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
   m_NumYV12Buffers = 0;
   m_iLastRenderBuffer = 0;
@@ -167,8 +170,6 @@
     delete m_pYUVShader;
     m_pYUVShader = NULL;
   }
-
-  delete m_dllSwScale;
 }
 
 bool CLinuxRendererGLES::ValidateRenderTarget()
@@ -607,9 +608,6 @@
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
 
-  if (!m_dllSwScale->Load())
-    CLog::Log(LOGERROR,"CLinuxRendererGL::PreInit - failed to load rescale libraries!");
-
   return true;
 }
 
@@ -837,9 +835,9 @@
   for (int i = 0; i < NUM_BUFFERS; ++i)
     (this->*m_textureDelete)(i);
 
-  if (m_dllSwScale && m_sw_context)
+  if (m_sw_context)
   {
-    m_dllSwScale->sws_freeContext(m_sw_context);
+    sws_freeContext(m_sw_context);
     m_sw_context = NULL;
   }
 
@@ -1684,7 +1682,7 @@
     else
 #endif
     {
-      m_sw_context = m_dllSwScale->sws_getCachedContext(m_sw_context,
+      m_sw_context = sws_getCachedContext(m_sw_context,
         im->width, im->height, PIX_FMT_YUV420P,
         im->width, im->height, PIX_FMT_RGBA,
         SWS_FAST_BILINEAR, NULL, NULL, NULL);
@@ -1693,7 +1691,7 @@
       int srcStride[] = { im->stride[0], im->stride[1], im->stride[2], 0 };
       uint8_t *dst[]  = { m_rgbBuffer, 0, 0, 0 };
       int dstStride[] = { m_sourceWidth*4, 0, 0, 0 };
-      m_dllSwScale->sws_scale(m_sw_context, src, srcStride, 0, im->height, dst, dstStride);
+      sws_scale(m_sw_context, src, srcStride, 0, im->height, dst, dstStride);
     }
   }
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGLES.h xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-08-13 18:26:07.180509362 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-08-13 18:27:00.616774338 +0800
@@ -115,9 +115,6 @@
 extern YUVCOEF yuv_coef_ebu;
 extern YUVCOEF yuv_coef_smtp240m;
 
-class DllSwScale;
-struct SwsContext;
-
 class CEvent;
 
 class CLinuxRendererGLES : public CBaseRenderer
@@ -314,7 +311,6 @@
   float m_clearColour;
 
   // software scale libraries (fallback if required gl version is not available)
-  DllSwScale  *m_dllSwScale;
   struct SwsContext *m_sw_context;
   BYTE	      *m_rgbBuffer;  // if software scale is used, this will hold the result image
   unsigned int m_rgbBufferSize;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.h xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGL.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.h	2014-08-13 18:26:07.184509387 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/LinuxRendererGL.h	2014-08-13 18:27:00.612774323 +0800
@@ -112,8 +112,6 @@
 extern YUVCOEF yuv_coef_ebu;
 extern YUVCOEF yuv_coef_smtp240m;
 
-class DllSwScale;
-
 class CLinuxRendererGL : public CBaseRenderer
 {
 public:
@@ -312,7 +310,6 @@
   float m_clearColour;
 
   // software scale library (fallback if required gl version is not available)
-  DllSwScale        *m_dllSwScale;
   BYTE              *m_rgbBuffer;  // if software scale is used, this will hold the result image
   unsigned int       m_rgbBufferSize;
   GLuint             m_rgbPbo;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-08-13 18:26:07.168509307 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-08-13 18:27:01.708779758 +0800
@@ -286,6 +286,8 @@
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -631,7 +633,7 @@
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -699,6 +701,7 @@
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -985,10 +988,10 @@
   if (mInt == VS_INTERLACEMETHOD_NONE)
     return VS_INTERLACEMETHOD_NONE;
 
-  if(!m_pRenderer->Supports(mInt))
+  if(m_pRenderer && !m_pRenderer->Supports(mInt))
     mInt = VS_INTERLACEMETHOD_AUTO;
 
-  if (mInt == VS_INTERLACEMETHOD_AUTO)
+  if (m_pRenderer && mInt == VS_INTERLACEMETHOD_AUTO)
     return m_pRenderer->AutoInterlaceMethod();
 
   return mInt;
@@ -1073,6 +1076,8 @@
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1089,3 +1094,12 @@
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/RenderManager.h xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/RenderManager.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/RenderManager.h	2014-08-13 18:26:07.180509362 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/RenderManager.h	2014-08-13 18:27:01.180777140 +0800
@@ -98,10 +98,11 @@
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -176,6 +177,12 @@
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -222,6 +229,7 @@
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -233,6 +241,8 @@
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/WinRenderer.cpp xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/WinRenderer.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/WinRenderer.cpp	2014-08-13 18:26:07.236509639 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/WinRenderer.cpp	2014-08-13 18:27:00.880775652 +0800
@@ -20,7 +20,6 @@
 
 #ifdef HAS_DX
 
-#include "DllSwScale.h"
 #include "Util.h"
 #include "WinRenderer.h"
 #include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
@@ -39,6 +38,7 @@
 #include "VideoShaders/WinVideoFilter.h"
 #include "win32/WIN32Util.h"
 #include "windowing/WindowingFactory.h"
+#include "cores/FFmpeg.h"
 
 typedef struct {
   RenderMethod  method;
@@ -84,11 +84,8 @@
     m_VideoBuffers[i] = NULL;
 
   m_sw_scale_ctx = NULL;
-  m_dllSwScale = NULL;
   m_destWidth = 0;
   m_destHeight = 0;
-  m_dllAvUtil = NULL;
-  m_dllAvCodec = NULL;
   m_bConfigured = false;
   m_clearColour = 0;
   m_format = RENDER_FMT_NONE;
@@ -210,11 +207,6 @@
 
   if (m_renderMethod == RENDER_SW)
   {
-    m_dllSwScale = new DllSwScale();
-
-    if (!m_dllSwScale->Load())
-      CLog::Log(LOGERROR,"CDVDDemuxFFmpeg::Open - failed to load ffmpeg libraries");
-
     if(!m_SWTarget.Create(m_sourceWidth, m_sourceHeight, 1, D3DUSAGE_DYNAMIC, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT))
     {
       CLog::Log(LOGNOTICE, __FUNCTION__": Failed to create sw render target.");
@@ -462,10 +454,9 @@
 
   if (m_sw_scale_ctx)
   {
-    m_dllSwScale->sws_freeContext(m_sw_scale_ctx);
+    sws_freeContext(m_sw_scale_ctx);
     m_sw_scale_ctx = NULL;
   }
-  SAFE_DELETE(m_dllSwScale);
 
   if (m_processor)
   {
@@ -727,7 +718,7 @@
   enum PixelFormat format = PixelFormatFromFormat(m_format);
 
   // 1. convert yuv to rgb
-  m_sw_scale_ctx = m_dllSwScale->sws_getCachedContext(m_sw_scale_ctx,
+  m_sw_scale_ctx = sws_getCachedContext(m_sw_scale_ctx,
                                                       m_sourceWidth, m_sourceHeight, format,
                                                       m_sourceWidth, m_sourceHeight, PIX_FMT_BGRA,
                                                       SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
@@ -756,7 +747,7 @@
   uint8_t *dst[]  = { (uint8_t*) destlr.pBits, 0, 0, 0 };
   int dstStride[] = { destlr.Pitch, 0, 0, 0 };
 
-  m_dllSwScale->sws_scale(m_sw_scale_ctx, src, srcStride, 0, m_sourceHeight, dst, dstStride);
+  sws_scale(m_sw_scale_ctx, src, srcStride, 0, m_sourceHeight, dst, dstStride);
 
   for (unsigned int idx = 0; idx < buf->GetActivePlanes(); idx++)
     if(!(buf->planes[idx].texture.UnlockRect(0)))
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/WinRenderer.h xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/WinRenderer.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/cores/VideoRenderers/WinRenderer.h	2014-08-13 18:26:07.232509625 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/cores/VideoRenderers/WinRenderer.h	2014-08-13 18:27:00.620774363 +0800
@@ -208,9 +208,6 @@
   std::vector<ERenderFormat> m_formats;
 
   // software scale libraries (fallback if required pixel shaders version is not available)
-  DllAvUtil           *m_dllAvUtil;
-  DllAvCodec          *m_dllAvCodec;
-  DllSwScale          *m_dllSwScale;
   struct SwsContext   *m_sw_scale_ctx;
 
   // Software rendering
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/DllPaths_generated_android.h.in xbmc-13.2rc1-Gotham/xbmc/DllPaths_generated_android.h.in
--- xbmc-13.2rc1-Gotham.orig/xbmc/DllPaths_generated_android.h.in	2014-08-13 18:26:07.792512402 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/DllPaths_generated_android.h.in	2014-08-13 18:27:00.788775196 +0800
@@ -75,15 +75,6 @@
 #define DLL_PATH_LIBMAD        "@MAD_SONAME@"
 #define DLL_PATH_LIBSTAGEFRIGHTICS    "libXBMCvcodec_stagefrightICS-@ARCH@.so"
 
-/* ffmpeg */
-#define DLL_PATH_LIBAVCODEC    "libavcodec-54-@ARCH@.so"
-#define DLL_PATH_LIBAVFORMAT   "libavformat-54-@ARCH@.so"
-#define DLL_PATH_LIBAVUTIL     "libavutil-52-@ARCH@.so"
-#define DLL_PATH_LIBPOSTPROC   "libpostproc-52-@ARCH@.so"
-#define DLL_PATH_LIBSWSCALE    "libswscale-2-@ARCH@.so"
-#define DLL_PATH_LIBAVFILTER   "libavfilter-3-@ARCH@.so"
-#define DLL_PATH_LIBSWRESAMPLE "libswresample-0-@ARCH@.so"
-
 /* cdrip */
 #define DLL_PATH_LAME_ENC      "@LAMEENC_SONAME@"
 #define DLL_PATH_OGG           "@OGG_SONAME@"
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/DllPaths_generated.h.in xbmc-13.2rc1-Gotham/xbmc/DllPaths_generated.h.in
--- xbmc-13.2rc1-Gotham.orig/xbmc/DllPaths_generated.h.in	2014-08-13 18:26:10.032523506 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/DllPaths_generated.h.in	2014-08-13 18:27:01.700779715 +0800
@@ -71,15 +71,6 @@
 #define DLL_PATH_LIBMPEG2      "@MPEG2_SONAME@"
 #define DLL_PATH_LIBMAD        "@MAD_SONAME@"
 
-/* ffmpeg */
-#define DLL_PATH_LIBAVCODEC    "special://xbmcbin/system/players/dvdplayer/avcodec-54-@ARCH@.so"
-#define DLL_PATH_LIBAVFORMAT   "special://xbmcbin/system/players/dvdplayer/avformat-54-@ARCH@.so"
-#define DLL_PATH_LIBAVUTIL     "special://xbmcbin/system/players/dvdplayer/avutil-52-@ARCH@.so"
-#define DLL_PATH_LIBPOSTPROC   "special://xbmcbin/system/players/dvdplayer/postproc-52-@ARCH@.so"
-#define DLL_PATH_LIBSWSCALE    "special://xbmcbin/system/players/dvdplayer/swscale-2-@ARCH@.so"
-#define DLL_PATH_LIBAVFILTER   "special://xbmcbin/system/players/dvdplayer/avfilter-3-@ARCH@.so"
-#define DLL_PATH_LIBSWRESAMPLE "special://xbmcbin/system/players/dvdplayer/swresample-0-@ARCH@.so"
-
 /* cdrip */
 #define DLL_PATH_LAME_ENC      "@LAMEENC_SONAME@"
 #define DLL_PATH_OGG           "@OGG_SONAME@"
@@ -103,4 +94,7 @@
 /* xkbcommon */
 #define DLL_PATH_XKBCOMMON "@XKBCOMMON_LIBRARY_SONAME@"
 
+/* sse4 */
+#define DLL_PATH_LIBSSE4      "special://xbmcbin/system/libsse4-@ARCH@.so"
+
 #endif
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/input/XBMC_keytable.cpp xbmc-13.2rc1-Gotham/xbmc/input/XBMC_keytable.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/input/XBMC_keytable.cpp	2014-08-13 18:26:06.624506610 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/input/XBMC_keytable.cpp	2014-08-13 18:27:01.656779496 +0800
@@ -182,6 +182,12 @@
 , { XBMCK_LAUNCH_APP2,            0,    0, XBMCVK_LAUNCH_APP2,         "launch_app2_pc_icon" }
 , { XBMCK_LAUNCH_FILE_BROWSER,    0,    0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser" }
 , { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
+, { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
+, { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
+, { XBMCK_REWIND,                 0,    0, XBMCVK_MEDIA_REWIND,        "rewind" }
+, { XBMCK_FASTFORWARD,            0,    0, XBMCVK_MEDIA_FASTFORWARD,   "fastforward" }
+, { XBMCK_RECORD,                 0,    0, XBMCVK_MEDIA_RECORD,        "record" }
+
 
 // Function keys
 , { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/input/XBMC_vkeys.h xbmc-13.2rc1-Gotham/xbmc/input/XBMC_vkeys.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/input/XBMC_vkeys.h	2014-08-13 18:26:06.636506664 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/input/XBMC_vkeys.h	2014-08-13 18:27:01.660779520 +0800
@@ -190,6 +190,7 @@
   XBMCVK_LAUNCH_MEDIA_CENTER = 0xC3,
   XBMCVK_MEDIA_REWIND        = 0xC4,
   XBMCVK_MEDIA_FASTFORWARD   = 0xC5,
+  XBMCVK_MEDIA_RECORD        = 0xC6,
 
   XBMCVK_LCONTROL       = 0xD0,
   XBMCVK_RCONTROL       = 0xD1,
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/linux/OMXCore.h xbmc-13.2rc1-Gotham/xbmc/linux/OMXCore.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/linux/OMXCore.h	2014-08-13 18:26:10.560526128 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/linux/OMXCore.h	2014-08-13 18:27:00.712774815 +0800
@@ -48,7 +48,7 @@
   (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
   (a).nVersion.s.nStep = OMX_VERSION_STEP
 
-#include "DllAvFormat.h"
+#include "libavformat/avformat.h"
 
 #define OMX_MAX_PORTS 10
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/CopyFrame.cpp xbmc-13.2rc1-Gotham/xbmc/linux/sse4/CopyFrame.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/CopyFrame.cpp	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/linux/sse4/CopyFrame.cpp	2014-08-13 18:27:01.700779715 +0800
@@ -0,0 +1,115 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "smmintrin.h"
+
+#define CACHED_BUFFER_SIZE 4096
+typedef unsigned int UINT;
+
+extern "C"
+{
+
+/*
+ * http://software.intel.com/en-us/articles/copying-accelerated-video-decode-frame-buffers
+ * COPIES VIDEO FRAMES FROM USWC MEMORY TO WB SYSTEM MEMORY VIA CACHED BUFFER
+ * ASSUMES PITCH IS A MULTIPLE OF 64B CACHE LINE SIZE, WIDTH MAY NOT BE
+ */
+void copy_frame( void * pSrc, void * pDest, void * pCacheBlock,
+    UINT width, UINT height, UINT pitch )
+{
+  __m128i         x0, x1, x2, x3;
+  __m128i         *pLoad;
+  __m128i         *pStore;
+  __m128i         *pCache;
+  UINT            x, y, yLoad, yStore;
+  UINT            rowsPerBlock;
+  UINT            width64;
+  UINT            extraPitch;
+
+
+  rowsPerBlock = CACHED_BUFFER_SIZE / pitch;
+  width64 = (width + 63) & ~0x03f;
+  extraPitch = (pitch - width64) / 16;
+
+  pLoad  = (__m128i *)pSrc;
+  pStore = (__m128i *)pDest;
+
+  //  COPY THROUGH 4KB CACHED BUFFER
+  for( y = 0; y < height; y += rowsPerBlock  )
+  {
+    //  ROWS LEFT TO COPY AT END
+    if( y + rowsPerBlock > height )
+      rowsPerBlock = height - y;
+
+    pCache = (__m128i *)pCacheBlock;
+
+    _mm_mfence();
+
+    // LOAD ROWS OF PITCH WIDTH INTO CACHED BLOCK
+    for( yLoad = 0; yLoad < rowsPerBlock; yLoad++ )
+    {
+      // COPY A ROW, CACHE LINE AT A TIME
+      for( x = 0; x < pitch; x +=64 )
+      {
+        x0 = _mm_stream_load_si128( pLoad +0 );
+        x1 = _mm_stream_load_si128( pLoad +1 );
+        x2 = _mm_stream_load_si128( pLoad +2 );
+        x3 = _mm_stream_load_si128( pLoad +3 );
+
+        _mm_store_si128( pCache +0,     x0 );
+        _mm_store_si128( pCache +1, x1 );
+        _mm_store_si128( pCache +2, x2 );
+        _mm_store_si128( pCache +3, x3 );
+
+        pCache += 4;
+        pLoad += 4;
+      }
+    }
+
+    _mm_mfence();
+
+    pCache = (__m128i *)pCacheBlock;
+
+    // STORE ROWS OF FRAME WIDTH FROM CACHED BLOCK
+    for( yStore = 0; yStore < rowsPerBlock; yStore++ )
+    {
+      // copy a row, cache line at a time
+      for( x = 0; x < width64; x +=64 )
+      {
+        x0 = _mm_load_si128( pCache );
+        x1 = _mm_load_si128( pCache +1 );
+        x2 = _mm_load_si128( pCache +2 );
+        x3 = _mm_load_si128( pCache +3 );
+
+        _mm_stream_si128( pStore,       x0 );
+        _mm_stream_si128( pStore +1, x1 );
+        _mm_stream_si128( pStore +2, x2 );
+        _mm_stream_si128( pStore +3, x3 );
+
+        pCache += 4;
+        pStore += 4;
+      }
+
+      pCache += extraPitch;
+      pStore += extraPitch;
+    }
+  }
+}
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/DllLibSSE4.h xbmc-13.2rc1-Gotham/xbmc/linux/sse4/DllLibSSE4.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/DllLibSSE4.h	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/linux/sse4/DllLibSSE4.h	2014-08-13 18:27:01.700779715 +0800
@@ -0,0 +1,43 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DynamicDll.h"
+
+extern "C" {
+
+}
+
+class DllLibSSE4Interface
+{
+public:
+  virtual ~DllLibSSE4Interface() {}
+  virtual void copy_frame(void * pSrc, void * pDest, void * pCacheBlock, UINT width, UINT height, UINT pitch) = 0;
+};
+
+class DllLibSSE4 : public DllDynamic, DllLibSSE4Interface
+{
+  DECLARE_DLL_WRAPPER(DllLibSSE4, DLL_PATH_LIBSSE4)
+  DEFINE_METHOD6(void, copy_frame, (void *p1, void *p2, void *p3, UINT p4, UINT p5, UINT p6))
+
+  BEGIN_METHOD_RESOLVE()
+    RESOLVE_METHOD(copy_frame)
+  END_METHOD_RESOLVE()
+};
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/Makefile.in xbmc-13.2rc1-Gotham/xbmc/linux/sse4/Makefile.in
--- xbmc-13.2rc1-Gotham.orig/xbmc/linux/sse4/Makefile.in	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/linux/sse4/Makefile.in	2014-08-13 18:27:01.700779715 +0800
@@ -0,0 +1,20 @@
+ARCH=@ARCH@
+DEFINES+=
+CXXFLAGS=-fPIC -msse4.1
+LIBNAME=libsse4
+OBJS=CopyFrame.o
+
+LIB_SHARED=@abs_top_srcdir@/system/$(LIBNAME)-$(ARCH).so
+
+all: $(LIB_SHARED)
+
+$(LIB_SHARED): $(OBJS)
+	$(CXX) $(CFLAGS) $(LDFLAGS) -shared -g -o $(LIB_SHARED) $(OBJS)
+
+CLEAN_FILES = \
+	$(LIB_SHARED) \
+
+DISTCLEAN_FILES= \
+	Makefile \
+
+include ../../../Makefile.include
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/music/karaoke/karaokevideobackground.cpp xbmc-13.2rc1-Gotham/xbmc/music/karaoke/karaokevideobackground.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/music/karaoke/karaokevideobackground.cpp	2014-08-13 18:26:10.024523465 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/music/karaoke/karaokevideobackground.cpp	2014-08-13 18:27:00.716774839 +0800
@@ -24,15 +24,19 @@
 #include "guilib/Texture.h"
 #include "guilib/GUITexture.h"
 #include "Application.h"
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
-#include "DllSwScale.h"
 #include "filesystem/SpecialProtocol.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/DisplaySettings.h"
 #include "video/FFmpegVideoDecoder.h"
 #include "system.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavformat/avformat.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+#include "libswscale/swscale.h"
+}
 
 KaraokeVideoBackground::KaraokeVideoBackground()
 {
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/pictures/Picture.cpp xbmc-13.2rc1-Gotham/xbmc/pictures/Picture.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/pictures/Picture.cpp	2014-08-13 18:26:09.380520271 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/pictures/Picture.cpp	2014-08-13 18:27:00.732774918 +0800
@@ -30,13 +30,17 @@
 #include "filesystem/File.h"
 #include "utils/log.h"
 #include "utils/URIUtils.h"
-#include "DllSwScale.h"
 #include "guilib/Texture.h"
 #include "guilib/imagefactory.h"
+#include "cores/FFmpeg.h"
 #if defined(HAS_OMXPLAYER)
 #include "cores/omxplayer/OMXImage.h"
 #endif
 
+extern "C" {
+#include "libswscale/swscale.h"
+}
+
 using namespace XFILE;
 
 bool CPicture::CreateThumbnailFromSurface(const unsigned char *buffer, int width, int height, int stride, const CStdString &thumbFile)
@@ -230,9 +234,7 @@
 bool CPicture::ScaleImage(uint8_t *in_pixels, unsigned int in_width, unsigned int in_height, unsigned int in_pitch,
                           uint8_t *out_pixels, unsigned int out_width, unsigned int out_height, unsigned int out_pitch)
 {
-  DllSwScale dllSwScale;
-  dllSwScale.Load();
-  struct SwsContext *context = dllSwScale.sws_getContext(in_width, in_height, PIX_FMT_BGRA,
+  struct SwsContext *context = sws_getContext(in_width, in_height, PIX_FMT_BGRA,
                                                          out_width, out_height, PIX_FMT_BGRA,
                                                          SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
 
@@ -243,8 +245,8 @@
 
   if (context)
   {
-    dllSwScale.sws_scale(context, src, srcStride, 0, in_height, dst, dstStride);
-    dllSwScale.sws_freeContext(context);
+    sws_scale(context, src, srcStride, 0, in_height, dst, dstStride);
+    sws_freeContext(context);
     return true;
   }
   return false;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/powermanagement/PowerManager.cpp xbmc-13.2rc1-Gotham/xbmc/powermanagement/PowerManager.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/powermanagement/PowerManager.cpp	2014-08-13 18:26:06.656506768 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/powermanagement/PowerManager.cpp	2014-08-13 18:27:01.532778882 +0800
@@ -268,11 +268,6 @@
 #if defined(TARGET_WINDOWS)
     ShowWindow(g_hWnd,SW_RESTORE);
     SetForegroundWindow(g_hWnd);
-#elif !defined(TARGET_DARWIN_OSX)
-    // Hack to reclaim focus, thus rehiding system mouse pointer.
-    // Surely there's a better way?
-    g_graphicsContext.ToggleFullScreenRoot();
-    g_graphicsContext.ToggleFullScreenRoot();
 #endif
   }
   g_application.ResetScreenSaver();
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/pvr/addons/PVRClients.cpp xbmc-13.2rc1-Gotham/xbmc/pvr/addons/PVRClients.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/pvr/addons/PVRClients.cpp	2014-08-13 18:26:06.616506570 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/pvr/addons/PVRClients.cpp	2014-08-13 18:27:01.540778925 +0800
@@ -733,6 +733,7 @@
   {
     hooks = client->GetMenuHooks();
     std::vector<int> hookIDs;
+    int selection = 0;
 
     CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
     pDialog->Reset();
@@ -743,9 +744,11 @@
         pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
         hookIDs.push_back(i);
       }
-    pDialog->DoModal();
-
-    int selection = pDialog->GetSelectedLabel();
+    if (hookIDs.size() > 1)
+    {
+      pDialog->DoModal();
+      selection = pDialog->GetSelectedLabel();
+    }
     if (selection >= 0)
       client->CallMenuHook(hooks->at(hookIDs.at(selection)), item);
   }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/rendering/gl/RenderSystemGL.h xbmc-13.2rc1-Gotham/xbmc/rendering/gl/RenderSystemGL.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/rendering/gl/RenderSystemGL.h	2014-08-13 18:26:11.104528820 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/rendering/gl/RenderSystemGL.h	2014-08-13 18:27:01.332777889 +0800
@@ -44,6 +44,7 @@
   virtual bool IsExtSupported(const char* extension);
 
   virtual void SetVSync(bool vsync);
+  virtual void ResetVSync() { m_bVsyncInit = false; }
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/settings/AdvancedSettings.cpp xbmc-13.2rc1-Gotham/xbmc/settings/AdvancedSettings.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/settings/AdvancedSettings.cpp	2014-08-13 18:26:07.780512337 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/settings/AdvancedSettings.cpp	2014-08-13 18:27:01.712779774 +0800
@@ -163,6 +163,8 @@
   m_videoAutoScaleMaxFps = 30.0f;
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -180,7 +182,7 @@
   m_stagefrightConfig.useInputDTS = false;
 
   m_videoDefaultLatency = 0.0;
-  m_videoDisableHi10pMultithreading = false;
+  m_videoDisableSWMultithreading = false;
 
   m_musicUseTimeSeeking = true;
   m_musicTimeSeekForward = 10;
@@ -597,9 +599,11 @@
     XMLUtils::GetFloat(pElement, "nonlinearstretchratio", m_videoNonLinStretchRatio, 0.01f, 1.0f);
     XMLUtils::GetBoolean(pElement,"enablehighqualityhwscalers", m_videoEnableHighQualityHwScalers);
     XMLUtils::GetFloat(pElement,"autoscalemaxfps",m_videoAutoScaleMaxFps, 0.0f, 1000.0f);
-    XMLUtils::GetBoolean(pElement,"disablehi10pmultithreading",m_videoDisableHi10pMultithreading);
+    XMLUtils::GetBoolean(pElement,"disableswmultithreading",m_videoDisableSWMultithreading);
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/settings/AdvancedSettings.h xbmc-13.2rc1-Gotham/xbmc/settings/AdvancedSettings.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/settings/AdvancedSettings.h	2014-08-13 18:26:07.780512337 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/settings/AdvancedSettings.h	2014-08-13 18:27:01.712779774 +0800
@@ -160,6 +160,8 @@
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
@@ -192,7 +194,7 @@
     bool m_DXVANoDeintProcForProgressive;
     int  m_videoFpsDetect;
     int  m_videoBusyDialogDelay_ms;
-    bool m_videoDisableHi10pMultithreading;
+    bool m_videoDisableSWMultithreading;
     StagefrightConfig m_stagefrightConfig;
 
     CStdString m_videoDefaultPlayer;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/settings/DisplaySettings.cpp xbmc-13.2rc1-Gotham/xbmc/settings/DisplaySettings.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/settings/DisplaySettings.cpp	2014-08-13 18:26:07.784512362 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/settings/DisplaySettings.cpp	2014-08-13 18:27:01.664779536 +0800
@@ -264,6 +264,32 @@
         m_resolutionChangeAborted = false;
     }
   }
+  else if (settingId == "videoscreen.monitor")
+  {
+    g_Windowing.UpdateResolutions();
+    RESOLUTION newRes = GetResolutionForScreen();
+
+    SetCurrentResolution(newRes, false);
+    g_graphicsContext.SetVideoResolution(newRes, true);
+
+    if (!m_resolutionChangeAborted)
+    {
+      bool cancelled = false;
+      if (!CGUIDialogYesNo::ShowAndGetInput(13110, 13111, 20022, 20022, -1, -1, cancelled, 10000))
+      {
+        m_resolutionChangeAborted = true;
+        return false;
+      }
+    }
+    else
+      m_resolutionChangeAborted = false;
+
+    return true;
+  }
+  else if (settingId == "videoscreen.monitorsingle")
+  {
+    g_Windowing.UpdateResolutions();
+  }
 
   return true;
 }
@@ -641,6 +667,10 @@
   if (g_advancedSettings.m_canWindowed)
     list.push_back(make_pair(g_localizeStrings.Get(242), DM_WINDOWED));
 
+#if defined(HAS_GLX)
+  list.push_back(make_pair(g_localizeStrings.Get(244), 0));
+#else
+
   for (int idx = 0; idx < g_Windowing.GetNumScreens(); idx++)
   {
     int screen = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP + idx).iScreen;
@@ -655,6 +685,7 @@
     RESOLUTION_INFO resInfo = CDisplaySettings::Get().GetResolutionInfo(res);
     current = resInfo.iScreen;
   }
+#endif
 }
 
 void CDisplaySettings::SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
@@ -683,3 +714,30 @@
   SettingOptionsStereoscopicModesFiller(setting, list, current);
   list.push_back(make_pair(g_localizeStrings.Get(36525), RENDER_STEREO_MODE_AUTO)); // option for autodetect
 }
+
+void CDisplaySettings::SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current)
+{
+#if defined(HAS_GLX)
+  std::vector<CStdString> monitors;
+  g_Windowing.GetConnectedOutputs(&monitors);
+  std::string currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+  for (unsigned int i=0; i<monitors.size(); ++i)
+  {
+    if(currentMonitor.compare("Default") != 0 &&
+       CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
+    {
+      current = monitors[i];
+    }
+    list.push_back(make_pair(monitors[i], monitors[i]));
+  }
+#endif
+}
+
+void CDisplaySettings::ClearCustomResolutions()
+{
+  if (m_resolutions.size() > RES_CUSTOM)
+  {
+    std::vector<RESOLUTION_INFO>::iterator firstCustom = m_resolutions.begin()+RES_CUSTOM;
+    m_resolutions.erase(firstCustom, m_resolutions.end());
+  }
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/settings/DisplaySettings.h xbmc-13.2rc1-Gotham/xbmc/settings/DisplaySettings.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/settings/DisplaySettings.h	2014-08-13 18:26:07.784512362 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/settings/DisplaySettings.h	2014-08-13 18:27:01.348777973 +0800
@@ -78,6 +78,7 @@
 
   void ApplyCalibrations();
   void UpdateCalibrations();
+  void ClearCustomResolutions();
 
   float GetZoomAmount() const { return m_zoomAmount; }
   void SetZoomAmount(float zoomAmount) { m_zoomAmount = zoomAmount; }
@@ -95,6 +96,7 @@
   static void SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsStereoscopicModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsPreferredStereoscopicViewModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static void SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
 
 protected:
   CDisplaySettings();
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/settings/Settings.cpp xbmc-13.2rc1-Gotham/xbmc/settings/Settings.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/settings/Settings.cpp	2014-08-13 18:26:07.784512362 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/settings/Settings.cpp	2014-08-13 18:27:01.388778167 +0800
@@ -410,6 +410,7 @@
   m_settingsManager->UnregisterSettingOptionsFiller("screens");
   m_settingsManager->UnregisterSettingOptionsFiller("stereoscopicmodes");
   m_settingsManager->UnregisterSettingOptionsFiller("preferedstereoscopicviewmodes");
+  m_settingsManager->UnregisterSettingOptionsFiller("monitors");
   m_settingsManager->UnregisterSettingOptionsFiller("shutdownstates");
   m_settingsManager->UnregisterSettingOptionsFiller("startupwindows");
   m_settingsManager->UnregisterSettingOptionsFiller("streamlanguages");
@@ -839,6 +840,7 @@
   m_settingsManager->RegisterSettingOptionsFiller("screens", CDisplaySettings::SettingOptionsScreensFiller);
   m_settingsManager->RegisterSettingOptionsFiller("stereoscopicmodes", CDisplaySettings::SettingOptionsStereoscopicModesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("preferedstereoscopicviewmodes", CDisplaySettings::SettingOptionsPreferredStereoscopicViewModesFiller);
+  m_settingsManager->RegisterSettingOptionsFiller("monitors", CDisplaySettings::SettingOptionsMonitorsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("shutdownstates", CPowerManager::SettingOptionsShutdownStatesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("startupwindows", ADDON::CSkinInfo::SettingOptionsStartupWindowsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("streamlanguages", CLangInfo::SettingOptionsStreamLanguagesFiller);
@@ -872,6 +874,9 @@
 #ifdef HAS_GL
   m_settingsManager->AddCondition("has_gl");
 #endif
+#ifdef HAS_GLX
+  m_settingsManager->AddCondition("has_glx");
+#endif
 #ifdef HAS_GLES
   m_settingsManager->AddCondition("has_gles");
 #endif
@@ -1030,6 +1035,7 @@
   settingSet.insert("videoscreen.resolution");
   settingSet.insert("videoscreen.screenmode");
   settingSet.insert("videoscreen.vsync");
+  settingSet.insert("videoscreen.monitor");
   m_settingsManager->RegisterCallback(&CDisplaySettings::Get(), settingSet);
 
   settingSet.clear();
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/system.h xbmc-13.2rc1-Gotham/xbmc/system.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/system.h	2014-08-13 18:26:11.276529674 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/system.h	2014-08-13 18:27:01.196777215 +0800
@@ -171,16 +171,21 @@
 #define HAS_GL
 #ifdef HAVE_X11
 #define HAS_GLX
+#define HAS_X11_WIN_EVENTS
 #endif
 #ifdef HAVE_SDL
 #define HAS_SDL
 #ifndef HAS_SDL_OPENGL
 #define HAS_SDL_OPENGL
 #endif
+#ifndef HAVE_X11
 #define HAS_SDL_WIN_EVENTS
+#endif
 #else
+#ifndef HAVE_X11
 #define HAS_LINUX_EVENTS
 #endif
+#endif
 #define HAS_LINUX_NETWORK
 #define HAS_LIRC
 #ifdef HAVE_LIBPULSE
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/threads/SystemClock.cpp xbmc-13.2rc1-Gotham/xbmc/threads/SystemClock.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/threads/SystemClock.cpp	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/threads/SystemClock.cpp	2014-08-13 18:27:01.584779139 +0800
@@ -43,7 +43,7 @@
     now_time = (uint64_t)timeGetTime();
 #else
     struct timespec ts = {};
-    clock_gettime(CLOCK_MONOTONIC, &ts);
+    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
     now_time = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
 #endif
     if (!start_time_set)
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/utils/BitstreamConverter.cpp xbmc-13.2rc1-Gotham/xbmc/utils/BitstreamConverter.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/utils/BitstreamConverter.cpp	2014-08-13 18:26:11.928532910 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/utils/BitstreamConverter.cpp	2014-08-13 18:27:00.740774958 +0800
@@ -18,6 +18,9 @@
  *
  */
 
+#include "utils/log.h"
+#include "assert.h"
+
 #ifndef UINT16_MAX
 #define UINT16_MAX             (65535U)
 #endif
@@ -285,8 +288,6 @@
   m_extradata         = NULL;
   m_extrasize         = 0;
   m_convert_3byteTo4byteNALSize = false;
-  m_dllAvUtil         = NULL;
-  m_dllAvFormat       = NULL;
   m_convert_bytestream = false;
   m_sps_pps_context.sps_pps_data = NULL;
 }
@@ -315,12 +316,8 @@
         if ( in_extradata[0] == 1 )
         {
           CLog::Log(LOGINFO, "CBitstreamConverter::Open bitstream to annexb init");
-          m_dllAvUtil = new DllAvUtil;
-          if (!m_dllAvUtil->Load())
-              return false;
-
           m_extrasize = in_extrasize;
-          m_extradata = (uint8_t*)m_dllAvUtil->av_malloc(in_extrasize);
+          m_extradata = (uint8_t*)av_malloc(in_extrasize);
           memcpy(m_extradata, in_extradata, in_extrasize);
           m_convert_bitstream = BitstreamConvertInit(m_extradata, m_extrasize);
           return true;
@@ -328,10 +325,6 @@
       }
       else
       {
-        m_dllAvUtil = new DllAvUtil;
-        if (!m_dllAvUtil->Load())
-            return false;
-
         // valid avcC atom data always starts with the value 1 (version)
         if ( in_extradata[0] != 1 )
         {
@@ -341,12 +334,8 @@
             CLog::Log(LOGINFO, "CBitstreamConverter::Open annexb to bitstream init");
             // video content is from x264 or from bytestream h264 (AnnexB format)
             // NAL reformating to bitstream format needed
-            m_dllAvFormat = new DllAvFormat;
-            if (!m_dllAvFormat->Load())
-              return false;
-
             AVIOContext *pb;
-            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+            if (avio_open_dyn_buf(&pb) < 0)
               return false;
             m_convert_bytestream = true;
             // create a valid avcC atom data from ffmpeg's extradata
@@ -354,13 +343,13 @@
             // unhook from ffmpeg's extradata
             in_extradata = NULL;
             // extract the avcC atom data into extradata then write it into avcCData for VDADecoder
-            in_extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &in_extradata);
+            in_extrasize = avio_close_dyn_buf(pb, &in_extradata);
             // make a copy of extradata contents
-            m_extradata = (uint8_t *)m_dllAvUtil->av_malloc(in_extrasize);
+            m_extradata = (uint8_t *)av_malloc(in_extrasize);
             memcpy(m_extradata, in_extradata, in_extrasize);
             m_extrasize = in_extrasize;
             // done with the converted extradata, we MUST free using av_free
-            m_dllAvUtil->av_free(in_extradata);
+            av_free(in_extradata);
             return true;
           }
           else
@@ -376,21 +365,17 @@
             CLog::Log(LOGINFO, "CBitstreamConverter::Open annexb to bitstream init 3 byte to 4 byte nal");
             // video content is from so silly encoder that think 3 byte NAL sizes
             // are valid, setup to convert 3 byte NAL sizes to 4 byte.
-            m_dllAvFormat = new DllAvFormat;
-            if (!m_dllAvFormat->Load())
-              return false;
-
             in_extradata[4] = 0xFF;
             m_convert_3byteTo4byteNALSize = true;
            
-            m_extradata = (uint8_t *)m_dllAvUtil->av_malloc(in_extrasize);
+            m_extradata = (uint8_t *)av_malloc(in_extrasize);
             memcpy(m_extradata, in_extradata, in_extrasize);
             m_extrasize = in_extrasize;
             return true;
           }
         }
         // valid avcC atom 
-        m_extradata = (uint8_t*)m_dllAvUtil->av_malloc(in_extrasize);
+        m_extradata = (uint8_t*)av_malloc(in_extrasize);
         memcpy(m_extradata, in_extradata, in_extrasize);
         m_extrasize = in_extrasize;
         return true;
@@ -407,14 +392,14 @@
 void CBitstreamConverter::Close(void)
 {
   if (m_sps_pps_context.sps_pps_data)
-    m_dllAvUtil->av_free(m_sps_pps_context.sps_pps_data), m_sps_pps_context.sps_pps_data = NULL;
+    av_free(m_sps_pps_context.sps_pps_data), m_sps_pps_context.sps_pps_data = NULL;
 
   if (m_convertBuffer)
-    m_dllAvUtil->av_free(m_convertBuffer), m_convertBuffer = NULL;
+    av_free(m_convertBuffer), m_convertBuffer = NULL;
   m_convertSize = 0;
 
   if (m_extradata)
-    m_dllAvUtil->av_free(m_extradata), m_extradata = NULL;
+    av_free(m_extradata), m_extradata = NULL;
   m_extrasize = 0;
 
   m_inputSize = 0;
@@ -423,18 +408,13 @@
   m_convert_bitstream = false;
   m_convert_bytestream = false;
   m_convert_3byteTo4byteNALSize = false;
-
-  if (m_dllAvUtil)
-    delete m_dllAvUtil, m_dllAvUtil = NULL;
-  if (m_dllAvFormat)
-    delete m_dllAvFormat, m_dllAvFormat = NULL;
 }
 
 bool CBitstreamConverter::Convert(uint8_t *pData, int iSize)
 {
   if (m_convertBuffer)
   {  
-    m_dllAvUtil->av_free(m_convertBuffer);
+    av_free(m_convertBuffer);
     m_convertBuffer = NULL;
   }
   m_inputSize = 0;
@@ -487,7 +467,7 @@
         {
           if(m_convertBuffer)
           {
-            m_dllAvUtil->av_free(m_convertBuffer);
+            av_free(m_convertBuffer);
             m_convertBuffer = NULL;
           }
           m_convertSize = 0;
@@ -495,25 +475,25 @@
           // convert demuxer packet from bytestream (AnnexB) to bitstream
           AVIOContext *pb;
 
-          if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+          if(avio_open_dyn_buf(&pb) < 0)
           {
             return false;
           }
           m_convertSize = avc_parse_nal_units(pb, pData, iSize);
-          m_convertSize = m_dllAvFormat->avio_close_dyn_buf(pb, &m_convertBuffer);
+          m_convertSize = avio_close_dyn_buf(pb, &m_convertBuffer);
         }
         else if (m_convert_3byteTo4byteNALSize)
         {
           if(m_convertBuffer)
           {
-            m_dllAvUtil->av_free(m_convertBuffer);
+            av_free(m_convertBuffer);
             m_convertBuffer = NULL;
           }
           m_convertSize = 0;
 
           // convert demuxer packet from 3 byte NAL sizes to 4 byte
           AVIOContext *pb;
-          if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
+          if (avio_open_dyn_buf(&pb) < 0)
             return false;
 
           uint32_t nal_size;
@@ -522,13 +502,13 @@
           while (nal_start < end)
           {
             nal_size = BS_RB24(nal_start);
-            m_dllAvFormat->avio_wb16(pb, nal_size);
+            avio_wb16(pb, nal_size);
             nal_start += 3;
-            m_dllAvFormat->avio_write(pb, nal_start, nal_size);
+            avio_write(pb, nal_start, nal_size);
             nal_start += nal_size;
           }
 
-          m_convertSize = m_dllAvFormat->avio_close_dyn_buf(pb, &m_convertBuffer);
+          m_convertSize = avio_close_dyn_buf(pb, &m_convertBuffer);
         }
         return true;
       }
@@ -611,14 +591,16 @@
     total_size += unit_size + 4;
 
     if (total_size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ||
-      (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize)) {
-      m_dllAvUtil->av_free(out);
+      (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize))
+    {
+      av_free(out);
       return false;
     }
-    tmp = m_dllAvUtil->av_realloc(out, total_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    if (!tmp) {
-        m_dllAvUtil->av_free(out);
-        return false;
+    tmp = av_realloc(out, total_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    if (!tmp)
+    {
+      av_free(out);
+      return false;
     }
     out = (uint8_t*)tmp;
     memcpy(out + total_size - unit_size - 4, nalu_header, 4);
@@ -706,7 +688,7 @@
   return true;
 
 fail:
-  m_dllAvUtil->av_free(*poutbuf), *poutbuf = NULL;
+  av_free(*poutbuf), *poutbuf = NULL;
   *poutbuf_size = 0;
   return false;
 }
@@ -723,7 +705,7 @@
   void *tmp;
 
   *poutbuf_size += sps_pps_size + in_size + nal_header_size;
-  tmp = m_dllAvUtil->av_realloc(*poutbuf, *poutbuf_size);
+  tmp = av_realloc(*poutbuf, *poutbuf_size);
   if (!tmp)
     return;
   *poutbuf = (uint8_t*)tmp;
@@ -758,8 +740,8 @@
       break;
 
     nal_end = avc_find_startcode(nal_start, end);
-    m_dllAvFormat->avio_wb32(pb, nal_end - nal_start);
-    m_dllAvFormat->avio_write(pb, nal_start, nal_end - nal_start);
+    avio_wb32(pb, nal_end - nal_start);
+    avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
@@ -769,14 +751,14 @@
 const int CBitstreamConverter::avc_parse_nal_units_buf(const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   AVIOContext *pb;
-  int ret = m_dllAvFormat->avio_open_dyn_buf(&pb);
+  int ret = avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
   avc_parse_nal_units(pb, buf_in, *size);
 
-  m_dllAvUtil->av_freep(buf);
-  *size = m_dllAvFormat->avio_close_dyn_buf(pb, buf);
+  av_freep(buf);
+  *size = avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -821,26 +803,26 @@
       if (!sps || !pps || sps_size < 4 || sps_size > UINT16_MAX || pps_size > UINT16_MAX)
         assert(0);
 
-      m_dllAvFormat->avio_w8(pb, 1); /* version */
-      m_dllAvFormat->avio_w8(pb, sps[1]); /* profile */
-      m_dllAvFormat->avio_w8(pb, sps[2]); /* profile compat */
-      m_dllAvFormat->avio_w8(pb, sps[3]); /* level */
-      m_dllAvFormat->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      m_dllAvFormat->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      avio_w8(pb, 1); /* version */
+      avio_w8(pb, sps[1]); /* profile */
+      avio_w8(pb, sps[2]); /* profile compat */
+      avio_w8(pb, sps[3]); /* level */
+      avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      m_dllAvFormat->avio_wb16(pb, sps_size);
-      m_dllAvFormat->avio_write(pb, sps, sps_size);
+      avio_wb16(pb, sps_size);
+      avio_write(pb, sps, sps_size);
       if (pps)
       {
-        m_dllAvFormat->avio_w8(pb, 1); /* number of pps */
-        m_dllAvFormat->avio_wb16(pb, pps_size);
-        m_dllAvFormat->avio_write(pb, pps, pps_size);
+        avio_w8(pb, 1); /* number of pps */
+        avio_wb16(pb, pps_size);
+        avio_write(pb, pps, pps_size);
       }
-      m_dllAvUtil->av_free(start);
+      av_free(start);
     }
     else
     {
-      m_dllAvFormat->avio_write(pb, data, len);
+      avio_write(pb, data, len);
     }
   }
   return 0;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/utils/BitstreamConverter.h xbmc-13.2rc1-Gotham/xbmc/utils/BitstreamConverter.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/utils/BitstreamConverter.h	2014-08-13 18:26:11.876532648 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/utils/BitstreamConverter.h	2014-08-13 18:27:00.744774973 +0800
@@ -22,10 +22,13 @@
 #define _BITSTREAMCONVERTER_H_
 
 #include <stdint.h>
-#include "DllAvUtil.h"
-#include "DllAvFormat.h"
-#include "DllAvFilter.h"
-#include "DllAvCodec.h"
+
+extern "C" {
+#include "libavutil/avutil.h"
+#include "libavformat/avformat.h"
+#include "libavfilter/avfilter.h"
+#include "libavcodec/avcodec.h"
+}
 
 typedef struct {
   int       writer_le;
@@ -201,8 +204,6 @@
   int               m_extrasize;
   bool              m_convert_3byteTo4byteNALSize;
   bool              m_convert_bytestream;
-  DllAvUtil        *m_dllAvUtil;
-  DllAvFormat      *m_dllAvFormat;
   AVCodecID         m_codec;
 };
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/utils/TimeUtils.cpp xbmc-13.2rc1-Gotham/xbmc/utils/TimeUtils.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/utils/TimeUtils.cpp	2014-08-13 18:26:11.816532356 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/utils/TimeUtils.cpp	2014-08-13 18:27:01.596779198 +0800
@@ -43,7 +43,7 @@
   return( (int64_t)PerformanceCount.QuadPart );
 #else
   struct timespec now;
-  clock_gettime(CLOCK_MONOTONIC, &now);
+  clock_gettime(CLOCK_MONOTONIC_RAW, &now);
   return( ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec );
 #endif
 }
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/utils/URIUtils.cpp xbmc-13.2rc1-Gotham/xbmc/utils/URIUtils.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/utils/URIUtils.cpp	2014-08-13 18:26:11.904532790 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/utils/URIUtils.cpp	2014-08-13 18:27:01.696779699 +0800
@@ -788,6 +788,36 @@
          StringUtils::StartsWithNoCase(strFile2, "ftps:");
 }
 
+bool URIUtils::IsUDP(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "udp:");
+}
+
+bool URIUtils::IsTCP(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "tcp:");
+}
+
+bool URIUtils::IsPVRChannel(const CStdString& strFile)
+{
+  CStdString strFile2(strFile);
+
+  if (IsStack(strFile))
+    strFile2 = CStackDirectory::GetFirstStackedFile(strFile);
+
+  return StringUtils::StartsWithNoCase(strFile2, "pvr://channels");
+}
+
 bool URIUtils::IsDAV(const CStdString& strFile)
 {
   CStdString strFile2(strFile);
@@ -1284,3 +1314,8 @@
   strFilename = newFilename;
   return true;
 }
+
+bool URIUtils::IsUsingFastSwitch(const CStdString& strFile)
+{
+  return IsUDP(strFile) || IsTCP(strFile) || IsPVRChannel(strFile);
+}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/utils/URIUtils.h xbmc-13.2rc1-Gotham/xbmc/utils/URIUtils.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/utils/URIUtils.h	2014-08-13 18:26:11.944532991 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/utils/URIUtils.h	2014-08-13 18:27:01.696779699 +0800
@@ -88,6 +88,8 @@
   static bool IsDOSPath(const CStdString &path);
   static bool IsDVD(const CStdString& strFile);
   static bool IsFTP(const CStdString& strFile);
+  static bool IsUDP(const CStdString& strFile);
+  static bool IsTCP(const CStdString& strFile);
   static bool IsHD(const CStdString& strFileName);
   static bool IsHDHomeRun(const CStdString& strFile);
   static bool IsSlingbox(const CStdString& strFile);
@@ -127,6 +129,8 @@
   static bool IsAndroidApp(const CStdString& strFile);
   static bool IsLibraryFolder(const CStdString& strFile);
   static bool IsLibraryContent(const std::string& strFile);
+  static bool IsPVRChannel(const CStdString& strFile);
+  static bool IsUsingFastSwitch(const CStdString& strFile);
 
   static void AddSlashAtEnd(std::string& strFolder);
   static bool HasSlashAtEnd(const std::string& strFile, bool checkURL = false);
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/video/FFmpegVideoDecoder.cpp xbmc-13.2rc1-Gotham/xbmc/video/FFmpegVideoDecoder.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/video/FFmpegVideoDecoder.cpp	2014-08-13 18:26:10.976528190 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/video/FFmpegVideoDecoder.cpp	2014-08-13 18:27:00.984776164 +0800
@@ -19,14 +19,16 @@
  */
 
 #include "system.h"
-#include "DllAvFormat.h"
-#include "DllAvCodec.h"
-#include "DllAvUtil.h"
-#include "DllSwScale.h"
 #include "guilib/Texture.h"
 
 #include "FFmpegVideoDecoder.h"
 
+extern "C" {
+#include "libavformat/avformat.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+#include "libswscale/swscale.h"
+}
 
 FFmpegVideoDecoder::FFmpegVideoDecoder()
 {
@@ -35,61 +37,39 @@
   m_pCodec = 0;
   m_pFrame = 0;
   m_pFrameRGB = 0;
-  
-  m_dllAvFormat = new DllAvFormat();
-  m_dllAvCodec = new DllAvCodec();
-  m_dllAvUtil = new DllAvUtil();
-  m_dllSwScale = new DllSwScale();
 }
 
 FFmpegVideoDecoder::~FFmpegVideoDecoder()
 {
   close();
-  
-  delete m_dllAvFormat;
-  delete m_dllAvCodec;
-  delete m_dllAvUtil;
-  delete m_dllSwScale;
 }
 
 void FFmpegVideoDecoder::close()
 {
   // Free the YUV frame
   if ( m_pFrame )
-	m_dllAvUtil->av_free( m_pFrame );
+	av_free( m_pFrame );
 
   // Free the RGB frame
   if ( m_pFrameRGB )
   {
-	m_dllAvCodec->avpicture_free( m_pFrameRGB );
-	m_dllAvUtil->av_free( m_pFrameRGB );
+	avpicture_free( m_pFrameRGB );
+	av_free( m_pFrameRGB );
   }
 
   // Close the codec
   if ( m_pCodecCtx )
-	m_dllAvCodec->avcodec_close( m_pCodecCtx );
+	avcodec_close( m_pCodecCtx );
 
   // Close the video file
   if ( m_pFormatCtx )
-	m_dllAvFormat->avformat_close_input( &m_pFormatCtx );
+	avformat_close_input( &m_pFormatCtx );
 
   m_pFormatCtx = 0;
   m_pCodecCtx = 0;
   m_pCodec = 0;
   m_pFrame = 0;
   m_pFrameRGB = 0;
-  
-  if ( m_dllAvCodec->IsLoaded() )
-    m_dllAvCodec->Unload();
-  
-  if ( m_dllAvUtil->IsLoaded() )
-    m_dllAvUtil->Unload();
-  
-  if ( m_dllSwScale->IsLoaded() )
-    m_dllSwScale->Unload();
-  
-  if ( m_dllAvFormat->IsLoaded() )
-    m_dllAvFormat->Unload();
 }
 
 bool FFmpegVideoDecoder::isOpened() const
@@ -108,7 +88,7 @@
 double FFmpegVideoDecoder::getFramesPerSecond() const
 {
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
-  return m_pFormatCtx ? av_q2d( m_dllAvFormat->av_stream_get_r_frame_rate( m_pFormatCtx->streams[ m_videoStream ] ) ) : 0.0;
+  return m_pFormatCtx ? av_q2d( av_stream_get_r_frame_rate( m_pFormatCtx->streams[ m_videoStream ] ) ) : 0.0;
 #else
   return m_pFormatCtx ? av_q2d( m_pFormatCtx->streams[ m_videoStream ]->r_frame_rate ) : 0.0;
 #endif
@@ -161,17 +141,8 @@
   // See http://dranger.com/ffmpeg/tutorial01.html
   close();
   
-  if ( !m_dllAvUtil->Load() || !m_dllAvCodec->Load() || !m_dllSwScale->Load() || !m_dllAvFormat->Load() )
-  {
-    m_errorMsg = "Failed to load FFMpeg libraries";
-    return false;
-  }
-
-  m_dllAvCodec->avcodec_register_all();
-  m_dllAvFormat->av_register_all();
-
   // Open the video file
-  if ( m_dllAvFormat->avformat_open_input( &m_pFormatCtx, filename.c_str(), NULL, NULL ) < 0 )
+  if ( avformat_open_input( &m_pFormatCtx, filename.c_str(), NULL, NULL ) < 0 )
   {
     m_errorMsg = "Could not open the video file";
    close();
@@ -179,7 +150,7 @@
   }
 
   // Retrieve the stream information
-  if ( m_dllAvFormat->avformat_find_stream_info( m_pFormatCtx, 0 ) < 0 )
+  if ( avformat_find_stream_info( m_pFormatCtx, 0 ) < 0 )
   {
     m_errorMsg = "Could not find the stream information";
     close();
@@ -209,7 +180,7 @@
   m_pCodecCtx = m_pFormatCtx->streams[ m_videoStream ]->codec;
 
   // Find the decoder for the video stream
-  m_pCodec = m_dllAvCodec->avcodec_find_decoder( m_pCodecCtx->codec_id );
+  m_pCodec = avcodec_find_decoder( m_pCodecCtx->codec_id );
 
   if ( m_pCodec == NULL )
   {
@@ -219,7 +190,7 @@
   }
     
   // Open the codec
-  if ( m_dllAvCodec->avcodec_open2( m_pCodecCtx, m_pCodec, 0 ) < 0 )
+  if ( avcodec_open2( m_pCodecCtx, m_pCodec, 0 ) < 0 )
   {
     m_errorMsg = "Could not open the video decoder";
     close();
@@ -227,7 +198,7 @@
   }
   
   // Allocate video frames
-  m_pFrame = m_dllAvCodec->avcodec_alloc_frame();
+  m_pFrame = av_frame_alloc();
 
   if ( !m_pFrame )
   {
@@ -245,10 +216,10 @@
   // Convert the frame number into time stamp
   int64_t timestamp = (int64_t) (time * AV_TIME_BASE * av_q2d( m_pFormatCtx->streams[ m_videoStream ]->time_base ));
 
-  if ( m_dllAvFormat->av_seek_frame( m_pFormatCtx, m_videoStream, timestamp, AVSEEK_FLAG_ANY ) < 0 )
+  if ( av_seek_frame( m_pFormatCtx, m_videoStream, timestamp, AVSEEK_FLAG_ANY ) < 0 )
 	return false;
 
-  m_dllAvCodec->avcodec_flush_buffers( m_pCodecCtx );
+  avcodec_flush_buffers( m_pCodecCtx );
   return true;
 }
 
@@ -263,21 +234,21 @@
   {
     if ( m_pFrameRGB )
     {
-      m_dllAvCodec->avpicture_free( m_pFrameRGB );
-      m_dllAvUtil->av_free( m_pFrameRGB );
+      avpicture_free( m_pFrameRGB );
+      av_free( m_pFrameRGB );
     }
 
     m_frameRGBwidth = texture->GetWidth();
     m_frameRGBheight = texture->GetHeight();
 
     // Allocate the conversion frame and relevant picture
-    m_pFrameRGB = (AVPicture*)m_dllAvUtil->av_mallocz(sizeof(AVPicture));
+    m_pFrameRGB = (AVPicture*)av_mallocz(sizeof(AVPicture));
 
     if ( !m_pFrameRGB )
       return false;
 
     // Due to a bug in swsscale we need to allocate one extra line of data
-    if ( m_dllAvCodec->avpicture_alloc( m_pFrameRGB, PIX_FMT_RGB32, m_frameRGBwidth, m_frameRGBheight + 1 ) < 0 )
+    if ( avpicture_alloc( m_pFrameRGB, PIX_FMT_RGB32, m_frameRGBwidth, m_frameRGBheight + 1 ) < 0 )
       return false;
   }
 
@@ -287,13 +258,13 @@
   while ( true )
   {
     // Read a frame
-    if ( m_dllAvFormat->av_read_frame( m_pFormatCtx, &packet ) < 0 )
+    if ( av_read_frame( m_pFormatCtx, &packet ) < 0 )
       return false;  // Frame read failed (e.g. end of stream)
 
     if ( packet.stream_index == m_videoStream )
     {
       // Is this a packet from the video stream -> decode video frame
-      m_dllAvCodec->avcodec_decode_video2( m_pCodecCtx, m_pFrame, &frameFinished, &packet );
+      avcodec_decode_video2( m_pCodecCtx, m_pFrame, &frameFinished, &packet );
 
       // Did we get a video frame?
       if ( frameFinished )
@@ -307,17 +278,17 @@
       }
     }
 
-    m_dllAvCodec->av_free_packet( &packet );
+    av_free_packet( &packet );
   }
 
   // We got the video frame, render it into the picture buffer
-  struct SwsContext * context = m_dllSwScale->sws_getContext( m_pCodecCtx->width, m_pCodecCtx->height, m_pCodecCtx->pix_fmt,
+  struct SwsContext * context = sws_getContext( m_pCodecCtx->width, m_pCodecCtx->height, m_pCodecCtx->pix_fmt,
                            m_frameRGBwidth, m_frameRGBheight, PIX_FMT_RGB32, SWS_FAST_BILINEAR, NULL, NULL, NULL );
 
-  m_dllSwScale->sws_scale( context, m_pFrame->data, m_pFrame->linesize, 0, m_pCodecCtx->height, 
+  sws_scale( context, m_pFrame->data, m_pFrame->linesize, 0, m_pCodecCtx->height,
                                                                      m_pFrameRGB->data, m_pFrameRGB->linesize );
-  m_dllSwScale->sws_freeContext( context );
-  m_dllAvCodec->av_free_packet( &packet );
+  sws_freeContext( context );
+  av_free_packet( &packet );
 
   // And into the texture
   texture->Update( m_frameRGBwidth, m_frameRGBheight, m_frameRGBwidth * 4, XB_FMT_A8R8G8B8, m_pFrameRGB->data[0], false );
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/video/FFmpegVideoDecoder.h xbmc-13.2rc1-Gotham/xbmc/video/FFmpegVideoDecoder.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/video/FFmpegVideoDecoder.h	2014-08-13 18:26:10.888527754 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/video/FFmpegVideoDecoder.h	2014-08-13 18:27:00.744774973 +0800
@@ -24,15 +24,14 @@
 #include "utils/StdString.h"
 
 class CBaseTexture;
-class m_dllAvFormat;
-class m_dllAvCodec;
-class m_dllAvUtil;
-class m_dllSwScale;
 
+extern "C" {
 struct AVFormatContext;
 struct AVCodecContext;
 struct AVCodec;
 struct AVFrame;
+struct AVPicture;
+}
 
 /**
  * A simple FFMpeg-based background video decoder.
@@ -141,10 +140,6 @@
 private:
   bool readFrame( int frame );
   
-  DllAvFormat     *m_dllAvFormat;
-  DllAvCodec      *m_dllAvCodec;
-  DllAvUtil       *m_dllAvUtil;
-  DllSwScale      *m_dllSwScale;
   AVFormatContext *m_pFormatCtx;
   AVCodecContext  *m_pCodecCtx;
   AVCodec         *m_pCodec;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/video/VideoReferenceClock.cpp xbmc-13.2rc1-Gotham/xbmc/video/VideoReferenceClock.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/video/VideoReferenceClock.cpp	2014-08-13 18:26:10.920527910 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/video/VideoReferenceClock.cpp	2014-08-13 18:27:01.472778584 +0800
@@ -31,6 +31,7 @@
   #include <sstream>
   #include <X11/extensions/Xrandr.h>
   #include "windowing/WindowingFactory.h"
+  #include "guilib/GraphicContext.h"
   #define NVSETTINGSCMD "nvidia-settings -nt -q RefreshRate3"
 #elif defined(TARGET_DARWIN_OSX)
   #include <QuartzCore/CVDisplayLink.h>
@@ -136,12 +137,23 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_RREventBase = 0;
-  m_UseNvSettings = true;
+  m_UseNvSettings = false;
   m_bIsATI = false;
 #endif
 }
 
+CVideoReferenceClock::~CVideoReferenceClock()
+{
+#if defined(HAS_GLX)
+  // some ATI voodoo, if we don't close the display, we crash on exit
+  if (m_Dpy)
+  {
+    XCloseDisplay(m_Dpy);
+    m_Dpy = NULL;
+  }
+#endif
+}
+
 void CVideoReferenceClock::Process()
 {
   bool SetupSuccess = false;
@@ -152,6 +164,10 @@
   m_D3dCallback.Reset();
   g_Windowing.Register(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+  g_Windowing.Register(this);
+  m_xrrEvent = false;
+#endif
 
   while(!m_bStop)
   {
@@ -212,6 +228,16 @@
     //clean up the vblank clock
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
     CleanupGLX();
+    if (m_xrrEvent)
+    {
+      m_releaseEvent.Set();
+      while (!m_bStop)
+      {
+        if (m_resetEvent.WaitMSec(100))
+          break;
+      }
+      m_xrrEvent = false;
+    }
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
     CleanupD3D();
 #elif defined(TARGET_DARWIN)
@@ -223,6 +249,9 @@
 #if defined(TARGET_WINDOWS) && defined(HAS_DX)
   g_Windowing.Unregister(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX)
+  g_Windowing.Unregister(this);
+#endif
 }
 
 bool CVideoReferenceClock::WaitStarted(int MSecs)
@@ -232,6 +261,24 @@
 }
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
+
+void CVideoReferenceClock::OnLostDevice()
+{
+  if (!m_xrrEvent)
+  {
+    m_releaseEvent.Reset();
+    m_resetEvent.Reset();
+    m_xrrEvent = true;
+    m_releaseEvent.Wait();
+  }
+}
+
+void CVideoReferenceClock::OnResetDevice()
+{
+  m_xrrEvent = false;
+  m_resetEvent.Set();
+}
+
 bool CVideoReferenceClock::SetupGLX()
 {
   int singleBufferAttributes[] = {
@@ -271,7 +318,7 @@
   }
 
   bool          ExtensionFound = false;
-  istringstream Extensions(glXQueryExtensionsString(m_Dpy, DefaultScreen(m_Dpy)));
+  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
   string        ExtensionStr;
 
   while (!ExtensionFound)
@@ -297,7 +344,7 @@
     m_bIsATI = true;
   }
 
-  m_vInfo = glXChooseVisual(m_Dpy, DefaultScreen(m_Dpy), singleBufferAttributes);
+  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
   if (!m_vInfo)
   {
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
@@ -308,15 +355,16 @@
   {
     Swa.border_pixel = 0;
     Swa.event_mask = StructureNotifyMask;
-    Swa.colormap = XCreateColormap(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), m_vInfo->visual, AllocNone );
+    Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
     SwaMask = CWBorderPixel | CWColormap | CWEventMask;
 
-    m_Window = XCreateWindow(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), 0, 0, 256, 256, 0,
+    m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
                            m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
   }
   else
   {
-    m_pixmap = XCreatePixmap(m_Dpy, DefaultRootWindow(m_Dpy), 256, 256, m_vInfo->depth);
+    Window window = g_Windowing.GetWindow();
+    m_pixmap = XCreatePixmap(m_Dpy, window, 256, 256, m_vInfo->depth);
     if (!m_pixmap)
     {
       CLog::Log(LOGDEBUG, "CVideoReferenceClock: unable to create pixmap");
@@ -381,10 +429,6 @@
     return false;
   }
 
-  //set up receiving of RandR events, we'll get one when the refreshrate changes
-  XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), RRScreenChangeNotifyMask);
-
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
 
@@ -518,7 +562,7 @@
   int RefreshRate;
   XRRScreenConfiguration *CurrInfo;
 
-  CurrInfo = XRRGetScreenInfo(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen));
+  CurrInfo = XRRGetScreenInfo(m_Dpy, g_Windowing.GetWindow());
   RefreshRate = XRRConfigCurrentRate(CurrInfo);
   XRRFreeScreenConfigInfo(CurrInfo);
 
@@ -585,6 +629,9 @@
 
   while(!m_bStop)
   {
+    if (m_xrrEvent)
+      return;
+
     //wait for the next vblank
     if (!m_bIsATI)
     {
@@ -648,7 +695,6 @@
       UpdateClock((int)(VblankCount - PrevVblankCount), true);
       SingleLock.Leave();
       SendVblankSignal();
-      UpdateRefreshrate();
       IsReset = false;
     }
     else if (!m_bStop)
@@ -1185,23 +1231,10 @@
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
 
-  //check for RandR events
-  bool   GotEvent = Forced || m_RefreshChanged == 2;
-  XEvent Event;
-  while (XCheckTypedEvent(m_Dpy, m_RREventBase + RRScreenChangeNotify, &Event))
-  {
-    if (Event.type == m_RREventBase + RRScreenChangeNotify)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Received RandR event %i", Event.type);
-      GotEvent = true;
-    }
-    XRRUpdateConfiguration(&Event);
-  }
-
   if (!Forced)
     m_RefreshChanged = 0;
 
-  if (!GotEvent) //refreshrate did not change
+  if (!Forced) //refreshrate did not change
     return false;
 
   //the refreshrate can be wrong on nvidia drivers, so read it from nvidia-settings when it's available
@@ -1222,7 +1255,7 @@
   }
 
   CSingleLock SingleLock(m_CritSection);
-  m_RefreshRate = GetRandRRate();
+  m_RefreshRate = MathUtils::round_int(g_graphicsContext.GetFPS());
 
   CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %i hertz", (int)m_RefreshRate);
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/video/VideoReferenceClock.h xbmc-13.2rc1-Gotham/xbmc/video/VideoReferenceClock.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/video/VideoReferenceClock.h	2014-08-13 18:26:11.012528364 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/video/VideoReferenceClock.h	2014-08-13 18:27:01.412778286 +0800
@@ -30,6 +30,7 @@
   #include <X11/X.h>
   #include <X11/Xlib.h>
   #include <GL/glx.h>
+  #include "guilib/DispResource.h"
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
   #include <d3d9.h>
   #include "guilib/D3DResource.h"
@@ -56,9 +57,13 @@
 #endif
 
 class CVideoReferenceClock : public CThread
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+                            ,public IDispResource
+#endif
 {
   public:
     CVideoReferenceClock();
+    virtual ~CVideoReferenceClock();
 
     int64_t GetTime(bool interpolated = true);
     int64_t GetFrequency();
@@ -75,6 +80,11 @@
     void VblankHandler(int64_t nowtime, double fps);
 #endif
 
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+    virtual void OnLostDevice();
+    virtual void OnResetDevice();
+#endif
+
   private:
     void    Process();
     bool    UpdateRefreshrate(bool Forced = false);
@@ -121,7 +131,8 @@
     GLXContext   m_Context;
     Pixmap       m_pixmap;
     GLXPixmap    m_glPixmap;
-    int          m_RREventBase;
+    bool         m_xrrEvent;
+    CEvent       m_releaseEvent, m_resetEvent;
 
     bool         m_UseNvSettings;
     bool         m_bIsATI;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/win32/Win32DelayedDllLoad.cpp xbmc-13.2rc1-Gotham/xbmc/win32/Win32DelayedDllLoad.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/win32/Win32DelayedDllLoad.cpp	2014-08-13 18:26:09.576521248 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/win32/Win32DelayedDllLoad.cpp	2014-08-13 18:27:00.940775950 +0800
@@ -66,6 +66,48 @@
         HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
         return (FARPROC)hMod;
       }
+      if (stricmp(pdli->szDll, "avcodec-55.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/avcodec-55.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "avfilter-4.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/avfilter-4.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "avformat-55.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/avformat-55.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "avutil-52.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/avutil-52.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "postproc-52.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/postproc-52.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "swresample-0.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/swresample-0.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
+      if (stricmp(pdli->szDll, "swscale-2.dll") == 0)
+      {
+        CStdString strDll = CSpecialProtocol::TranslatePath("special://xbmcbin/system/players/dvdplayer/swscale-2.dll");
+        HMODULE hMod = LoadLibraryEx(strDll.c_str(), 0, LOAD_WITH_ALTERED_SEARCH_PATH);
+        return (FARPROC)hMod;
+      }
       break;
   }
   return NULL;
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/Makefile.in xbmc-13.2rc1-Gotham/xbmc/windowing/Makefile.in
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/Makefile.in	2014-08-13 18:26:07.720512045 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/Makefile.in	2014-08-13 18:27:01.228777378 +0800
@@ -1,6 +1,7 @@
 SRCS=WinEventsSDL.cpp \
      WinEventsLinux.cpp \
      WinEventsWayland.cpp \
+     WinEventsX11.cpp \
      WinSystem.cpp \
      WinEvents.cpp
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEvents.cpp xbmc-13.2rc1-Gotham/xbmc/windowing/WinEvents.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEvents.cpp	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/WinEvents.cpp	2014-08-13 18:27:01.228777378 +0800
@@ -42,6 +42,10 @@
 #include "WinEventsSDL.h"
 #define WinEventsType CWinEventsSDL
 
+#elif (defined(TARGET_FREEBSD) || defined(TARGET_LINUX)) && defined(HAS_X11_WIN_EVENTS)
+#include "WinEventsX11.h"
+#define WinEventsType CWinEventsX11
+
 #elif defined(HAVE_WAYLAND)
 #include "WinEventsWayland.h"
 #define WinEventsType CWinEventsWayland
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEventsX11.cpp xbmc-13.2rc1-Gotham/xbmc/windowing/WinEventsX11.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEventsX11.cpp	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/WinEventsX11.cpp	2014-08-13 18:27:01.668779556 +0800
@@ -0,0 +1,738 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "system.h"
+
+#ifdef HAS_X11_WIN_EVENTS
+
+#include "WinEvents.h"
+#include "WinEventsX11.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include <X11/Xlib.h>
+#include "X11/WinSystemX11GL.h"
+#include "X11/keysymdef.h"
+#include "X11/XF86keysym.h"
+#include "utils/log.h"
+#include "utils/CharsetConverter.h"
+#include "guilib/GUIWindowManager.h"
+#include "input/MouseStat.h"
+
+#if defined(HAS_XRANDR)
+#include <X11/extensions/Xrandr.h>
+#endif
+
+#ifdef HAS_SDL_JOYSTICK
+#include "input/SDLJoystick.h"
+#endif
+
+CWinEventsX11Imp* CWinEventsX11Imp::WinEvents = 0;
+
+static uint32_t SymMappingsX11[][2] =
+{
+  {XK_BackSpace, XBMCK_BACKSPACE}
+, {XK_Tab, XBMCK_TAB}
+, {XK_Clear, XBMCK_CLEAR}
+, {XK_Return, XBMCK_RETURN}
+, {XK_Pause, XBMCK_PAUSE}
+, {XK_Escape, XBMCK_ESCAPE}
+, {XK_Delete, XBMCK_DELETE}
+// multi-media keys
+, {XF86XK_Back, XBMCK_BROWSER_BACK}
+, {XF86XK_Forward, XBMCK_BROWSER_FORWARD}
+, {XF86XK_Refresh, XBMCK_BROWSER_REFRESH}
+, {XF86XK_Stop, XBMCK_BROWSER_STOP}
+, {XF86XK_Search, XBMCK_BROWSER_SEARCH}
+, {XF86XK_Favorites, XBMCK_BROWSER_FAVORITES}
+, {XF86XK_HomePage, XBMCK_BROWSER_HOME}
+, {XF86XK_AudioMute, XBMCK_VOLUME_MUTE}
+, {XF86XK_AudioLowerVolume, XBMCK_VOLUME_DOWN}
+, {XF86XK_AudioRaiseVolume, XBMCK_VOLUME_UP}
+, {XF86XK_AudioNext, XBMCK_MEDIA_NEXT_TRACK}
+, {XF86XK_AudioPrev, XBMCK_MEDIA_PREV_TRACK}
+, {XF86XK_AudioStop, XBMCK_MEDIA_STOP}
+, {XF86XK_AudioPause, XBMCK_MEDIA_PLAY_PAUSE}
+, {XF86XK_Mail, XBMCK_LAUNCH_MAIL}
+, {XF86XK_Select, XBMCK_LAUNCH_MEDIA_SELECT}
+, {XF86XK_Launch0, XBMCK_LAUNCH_APP1}
+, {XF86XK_Launch1, XBMCK_LAUNCH_APP2}
+, {XF86XK_WWW, XBMCK_LAUNCH_FILE_BROWSER}
+, {XF86XK_AudioMedia, XBMCK_LAUNCH_MEDIA_CENTER }
+  // Numeric keypad
+, {XK_KP_0, XBMCK_KP0}
+, {XK_KP_1, XBMCK_KP1}
+, {XK_KP_2, XBMCK_KP2}
+, {XK_KP_3, XBMCK_KP3}
+, {XK_KP_4, XBMCK_KP4}
+, {XK_KP_5, XBMCK_KP5}
+, {XK_KP_6, XBMCK_KP6}
+, {XK_KP_7, XBMCK_KP7}
+, {XK_KP_8, XBMCK_KP8}
+, {XK_KP_9, XBMCK_KP9}
+, {XK_KP_Separator, XBMCK_KP_PERIOD}
+, {XK_KP_Divide, XBMCK_KP_DIVIDE}
+, {XK_KP_Multiply, XBMCK_KP_MULTIPLY}
+, {XK_KP_Subtract, XBMCK_KP_MINUS}
+, {XK_KP_Add, XBMCK_KP_PLUS}
+, {XK_KP_Enter, XBMCK_KP_ENTER}
+, {XK_KP_Equal, XBMCK_KP_EQUALS}
+  // Arrows + Home/End pad
+, {XK_Up, XBMCK_UP}
+, {XK_Down, XBMCK_DOWN}
+, {XK_Right, XBMCK_RIGHT}
+, {XK_Left, XBMCK_LEFT}
+, {XK_Insert, XBMCK_INSERT}
+, {XK_Home, XBMCK_HOME}
+, {XK_End, XBMCK_END}
+, {XK_Page_Up, XBMCK_PAGEUP}
+, {XK_Page_Down, XBMCK_PAGEDOWN}
+  // Function keys
+, {XK_F1, XBMCK_F1}
+, {XK_F2, XBMCK_F2}
+, {XK_F3, XBMCK_F3}
+, {XK_F4, XBMCK_F4}
+, {XK_F5, XBMCK_F5}
+, {XK_F6, XBMCK_F6}
+, {XK_F7, XBMCK_F7}
+, {XK_F8, XBMCK_F8}
+, {XK_F9, XBMCK_F9}
+, {XK_F10, XBMCK_F10}
+, {XK_F11, XBMCK_F11}
+, {XK_F12, XBMCK_F12}
+, {XK_F13, XBMCK_F13}
+, {XK_F14, XBMCK_F14}
+, {XK_F15, XBMCK_F15}
+  // Key state modifier keys
+, {XK_Num_Lock, XBMCK_NUMLOCK}
+, {XK_Caps_Lock, XBMCK_CAPSLOCK}
+, {XK_Scroll_Lock, XBMCK_SCROLLOCK}
+, {XK_Shift_R, XBMCK_RSHIFT}
+, {XK_Shift_L, XBMCK_LSHIFT}
+, {XK_Control_R, XBMCK_RCTRL}
+, {XK_Control_L, XBMCK_LCTRL}
+, {XK_Alt_R, XBMCK_RALT}
+, {XK_Alt_L, XBMCK_LALT}
+, {XK_Meta_R, XBMCK_RMETA}
+, {XK_Meta_L, XBMCK_LMETA}
+, {XK_Super_L, XBMCK_LSUPER}
+, {XK_Super_R, XBMCK_RSUPER}
+, {XK_Mode_switch, XBMCK_MODE}
+, {XK_Multi_key, XBMCK_COMPOSE}
+  // Miscellaneous function keys
+, {XK_Help, XBMCK_HELP}
+, {XK_Print, XBMCK_PRINT}
+//, {0, XBMCK_SYSREQ}
+, {XK_Break, XBMCK_BREAK}
+, {XK_Menu, XBMCK_MENU}
+, {XF86XK_PowerOff, XBMCK_POWER}
+, {XF86XK_Sleep, XBMCK_SLEEP}
+, {XK_EcuSign, XBMCK_EURO}
+, {XK_Undo, XBMCK_UNDO}
+  /* Media keys */
+, {XF86XK_Eject, XBMCK_EJECT}
+, {XF86XK_Stop, XBMCK_STOP}
+, {XF86XK_AudioRecord, XBMCK_RECORD}
+, {XF86XK_AudioRewind, XBMCK_REWIND}
+, {XF86XK_Phone, XBMCK_PHONE}
+, {XF86XK_AudioPlay, XBMCK_PLAY}
+, {XF86XK_AudioRandomPlay, XBMCK_SHUFFLE}
+, {XF86XK_AudioForward, XBMCK_FASTFORWARD}
+};
+
+bool CWinEventsX11::MessagePump()
+{
+  return CWinEventsX11Imp::MessagePump();
+}
+
+size_t CWinEventsX11::GetQueueSize()
+{
+  return CWinEventsX11Imp::GetQueueSize();
+}
+
+CWinEventsX11Imp::CWinEventsX11Imp()
+{
+  m_display = 0;
+  m_window = 0;
+  m_keybuf = 0;
+  m_keybuf_len = 0;
+}
+
+CWinEventsX11Imp::~CWinEventsX11Imp()
+{
+  if (m_keybuf);
+  {
+    free(m_keybuf);
+    m_keybuf = 0;
+  }
+
+  if (m_xic)
+  {
+    XUnsetICFocus(m_xic);
+    XDestroyIC(m_xic);
+    m_xic = 0;
+  }
+
+  if (m_xim)
+  {
+    XCloseIM(m_xim);
+    m_xim = 0;
+  }
+
+  m_symLookupTable.clear();
+}
+
+bool CWinEventsX11Imp::Init(Display *dpy, Window win)
+{
+  if (WinEvents)
+    return true;
+
+  WinEvents = new CWinEventsX11Imp();
+  WinEvents->m_display = dpy;
+  WinEvents->m_window = win;
+  WinEvents->m_keybuf_len = 32*sizeof(char);
+  WinEvents->m_keybuf = (char*)malloc(WinEvents->m_keybuf_len);
+  WinEvents->m_keymodState = 0;
+  WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+  WinEvents->m_structureChanged = false;
+  WinEvents->m_xrrEventPending = false;
+
+  // open input method
+  char *old_locale = NULL, *old_modifiers = NULL;
+  char res_name[8];
+  const char *p;
+  size_t n;
+
+  // set resource name to xbmc, not used
+  strcpy(res_name, "xbmc");
+
+  // save current locale, this should be "C"
+  p = setlocale(LC_ALL, NULL);
+  if (p)
+  {
+    old_locale = (char*)malloc(strlen(p) +1);
+    strcpy(old_locale, p);
+  }
+  p = XSetLocaleModifiers(NULL);
+  if (p)
+  {
+    old_modifiers = (char*)malloc(strlen(p) +1);
+    strcpy(old_modifiers, p);
+  }
+
+  // set users preferences and open input method
+  p = setlocale(LC_ALL, "");
+  XSetLocaleModifiers("");
+  WinEvents->m_xim = XOpenIM(WinEvents->m_display, NULL, res_name, res_name);
+
+  // restore old locale
+  if (old_locale)
+  {
+    setlocale(LC_ALL, old_locale);
+    free(old_locale);
+  }
+  if (old_modifiers)
+  {
+    XSetLocaleModifiers(old_modifiers);
+    free(old_modifiers);
+  }
+
+  WinEvents->m_xic = NULL;
+  if (WinEvents->m_xim)
+  {
+    WinEvents->m_xic = XCreateIC(WinEvents->m_xim,
+                                 XNClientWindow, WinEvents->m_window,
+                                 XNFocusWindow, WinEvents->m_window,
+                                 XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+                                 XNResourceName, res_name,
+                                 XNResourceClass, res_name,
+                                 NULL);
+  }
+
+  if (!WinEvents->m_xic)
+    CLog::Log(LOGWARNING,"CWinEventsX11::Init - no input method found");
+
+  // build Keysym lookup table
+  for (unsigned int i = 0; i < sizeof(SymMappingsX11)/(2*sizeof(uint32_t)); ++i)
+  {
+    WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
+  }
+
+  // register for xrandr events
+#if defined(HAS_XRANDR)
+  int iReturn;
+  XRRQueryExtension(WinEvents->m_display, &WinEvents->m_RREventBase, &iReturn);
+  int numScreens = XScreenCount(WinEvents->m_display);
+  for (int i = 0; i < numScreens; i++)
+  {
+    XRRSelectInput(WinEvents->m_display, RootWindow(WinEvents->m_display, i), RRScreenChangeNotifyMask | RRCrtcChangeNotifyMask | RROutputChangeNotifyMask | RROutputPropertyNotifyMask);
+  }
+#endif
+
+  return true;
+}
+
+void CWinEventsX11Imp::Quit()
+{
+  if (!WinEvents)
+    return;
+
+  delete WinEvents;
+  WinEvents = 0;
+}
+
+bool CWinEventsX11Imp::HasStructureChanged()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = WinEvents->m_structureChanged;
+  WinEvents->m_structureChanged = false;
+  return ret;
+}
+
+void CWinEventsX11Imp::SetXRRFailSafeTimer(int millis)
+{
+  if (!WinEvents)
+    return;
+
+  WinEvents->m_xrrFailSafeTimer.Set(millis);
+  WinEvents->m_xrrEventPending = true;
+}
+
+bool CWinEventsX11Imp::MessagePump()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = false;
+  XEvent xevent;
+  unsigned long serial = 0;
+
+  while (WinEvents && XPending(WinEvents->m_display))
+  {
+    memset(&xevent, 0, sizeof (XEvent));
+    XNextEvent(WinEvents->m_display, &xevent);
+
+#if defined(HAS_XRANDR)
+    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
+    {
+      XRRUpdateConfiguration(&xevent);
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+    else if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRNotify))
+    {
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+#endif
+
+    if (XFilterEvent(&xevent, WinEvents->m_window))
+      continue;
+
+    switch (xevent.type)
+    {
+      case MapNotify:
+      {
+        g_application.SetRenderGUI(true);
+        break;
+      }
+
+      case UnmapNotify:
+      {
+        g_application.SetRenderGUI(false);
+        break;
+      }
+
+      case FocusIn:
+      {
+        if (WinEvents->m_xic)
+          XSetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = true;
+        WinEvents->m_keymodState = 0;
+        if (serial == xevent.xfocus.serial)
+          break;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        break;
+      }
+
+      case FocusOut:
+      {
+        if (WinEvents->m_xic)
+          XUnsetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = false;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        serial = xevent.xfocus.serial;
+        break;
+      }
+
+      case Expose:
+      {
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ConfigureNotify:
+      {
+        if (xevent.xconfigure.window != WinEvents->m_window)
+          break;
+
+        WinEvents->m_structureChanged = true;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_VIDEORESIZE;
+        newEvent.resize.w = xevent.xconfigure.width;
+        newEvent.resize.h = xevent.xconfigure.height;
+        ret |= g_application.OnEvent(newEvent);
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ClientMessage:
+      {
+        if (xevent.xclient.data.l[0] == WinEvents->m_wmDeleteMessage)
+          if (!g_application.m_bStop) CApplicationMessenger::Get().Quit();
+        break;
+      }
+
+      case KeyPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYDOWN;
+        KeySym xkeysym;
+
+        // fallback if we have no IM
+        if (!WinEvents->m_xic)
+        {
+          static XComposeStatus state;
+          char keybuf[32];
+          XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
+          newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+          newEvent.key.keysym.scancode = xevent.xkey.keycode;
+          newEvent.key.state = xevent.xkey.state;
+          newEvent.key.type = xevent.xkey.type;
+          if (XLookupString(&xevent.xkey, keybuf, sizeof(keybuf), NULL, &state))
+          {
+            newEvent.key.keysym.unicode = keybuf[0];
+          }
+          ret |= ProcessKey(newEvent);
+          break;
+        }
+
+        Status status;
+        int len;
+        len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                WinEvents->m_keybuf, WinEvents->m_keybuf_len,
+                                &xkeysym, &status);
+        if (status == XBufferOverflow)
+        {
+          WinEvents->m_keybuf_len = len;
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, WinEvents->m_keybuf_len);
+          len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                  WinEvents->m_keybuf, WinEvents->m_keybuf_len,
+                                  &xkeysym, &status);
+        }
+        switch (status)
+        {
+          case XLookupNone:
+            break;
+          case XLookupChars:
+          case XLookupBoth:
+          {
+            CStdString   data(WinEvents->m_keybuf, len);
+            CStdStringW keys;
+            g_charsetConverter.utf8ToW(data, keys, false);
+
+            if (keys.length() == 0)
+            {
+              break;
+            }
+
+            for (unsigned int i = 0; i < keys.length() - 1; i++)
+            {
+              newEvent.key.keysym.sym = XBMCK_UNKNOWN;
+              newEvent.key.keysym.unicode = keys[i];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+              ret |= ProcessKey(newEvent);
+            }
+            if (keys.length() > 0)
+            {
+              newEvent.key.keysym.scancode = xevent.xkey.keycode;
+              XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
+              newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+              newEvent.key.keysym.unicode = keys[keys.length() - 1];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+
+              ret |= ProcessKey(newEvent);
+            }
+            break;
+          }
+
+          case XLookupKeySym:
+          {
+            newEvent.key.keysym.scancode = xevent.xkey.keycode;
+            newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+            newEvent.key.state = xevent.xkey.state;
+            newEvent.key.type = xevent.xkey.type;
+            ret |= ProcessKey(newEvent);
+            break;
+          }
+
+        }// switch status
+        break;
+      } //KeyPress
+
+      case KeyRelease:
+      {
+        // if we have a queued press directly after, this is a repeat
+        if( XEventsQueued( WinEvents->m_display, QueuedAfterReading ) )
+        {
+          XEvent next_event;
+          XPeekEvent( WinEvents->m_display, &next_event );
+          if(next_event.type == KeyPress
+            && next_event.xkey.window == xevent.xkey.window
+            && next_event.xkey.keycode == xevent.xkey.keycode
+            && (next_event.xkey.time - xevent.xkey.time < 2) )
+            continue;
+        }
+
+        XBMC_Event newEvent;
+        KeySym xkeysym;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYUP;
+        xkeysym = XLookupKeysym(&xevent.xkey, 0);
+        newEvent.key.keysym.scancode = xevent.xkey.keycode;
+        newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+        newEvent.key.state = xevent.xkey.state;
+        newEvent.key.type = xevent.xkey.type;
+        ret |= ProcessKey(newEvent);
+        break;
+      }
+
+      case EnterNotify:
+      {
+        break;
+      }
+
+      // lose mouse coverage
+      case LeaveNotify:
+      {
+        g_Mouse.SetActive(false);
+        break;
+      }
+
+      case MotionNotify:
+      {
+        if (xevent.xmotion.window != WinEvents->m_window)
+          break;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEMOTION;
+        newEvent.motion.xrel = (int16_t)xevent.xmotion.x_root;
+        newEvent.motion.yrel = (int16_t)xevent.xmotion.y_root;
+        newEvent.motion.x = (int16_t)xevent.xmotion.x;
+        newEvent.motion.y = (int16_t)xevent.xmotion.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONDOWN;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_PRESSED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonRelease:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONUP;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_RELEASED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      default:
+      {
+        break;
+      }
+    }// switch event.type
+  }// while
+
+#if defined(HAS_XRANDR)
+  if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
+  {
+    CLog::Log(LOGERROR,"CWinEventsX11::MessagePump - missed XRR Events");
+    g_Windowing.NotifyXRREvent();
+    WinEvents->m_xrrEventPending = false;
+  }
+#endif
+
+#ifdef HAS_SDL_JOYSTICK
+  SDL_Event event;
+  while (SDL_PollEvent(&event))
+  {
+    switch(event.type)
+    {
+      case SDL_JOYBUTTONUP:
+      case SDL_JOYBUTTONDOWN:
+      case SDL_JOYAXISMOTION:
+      case SDL_JOYBALLMOTION:
+      case SDL_JOYHATMOTION:
+        g_Joystick.Update(event);
+        ret = true;
+        break;
+
+      default:
+        break;
+    }
+    memset(&event, 0, sizeof(SDL_Event));
+  }
+#endif
+
+  return ret;
+}
+
+size_t CWinEventsX11Imp::GetQueueSize()
+{
+  int ret = 0;
+
+  if (WinEvents)
+    ret = XPending(WinEvents->m_display);
+
+  return ret;
+}
+
+bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event)
+{
+  if (event.type == XBMC_KEYDOWN)
+  {
+    // check key modifiers
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState |= XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState |= XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+  }
+  else if (event.type == XBMC_KEYUP)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState &= ~XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+  }
+
+  return g_application.OnEvent(event);
+}
+
+XBMCKey CWinEventsX11Imp::LookupXbmcKeySym(KeySym keysym)
+{
+  // try direct mapping first
+  std::map<uint32_t, uint32_t>::iterator it;
+  it = WinEvents->m_symLookupTable.find(keysym);
+  if (it != WinEvents->m_symLookupTable.end())
+  {
+    return (XBMCKey)(it->second);
+  }
+
+  // try ascii mappings
+  if (keysym>>8 == 0x00)
+    return (XBMCKey)(keysym & 0xFF);
+
+  return (XBMCKey)keysym;
+}
+#endif
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEventsX11.h xbmc-13.2rc1-Gotham/xbmc/windowing/WinEventsX11.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinEventsX11.h	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/WinEventsX11.h	2014-08-13 18:27:01.684779639 +0800
@@ -0,0 +1,65 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#pragma once
+
+#include "WinEvents.h"
+#include <X11/Xlib.h>
+#include "threads/SystemClock.h"
+#include <map>
+
+class CWinEventsX11 : public IWinEvents
+{
+public:
+  virtual bool MessagePump();
+  virtual size_t GetQueueSize();
+};
+
+class CWinEventsX11Imp
+{
+public:
+  CWinEventsX11Imp();
+  virtual ~CWinEventsX11Imp();
+  static bool Init(Display *dpy, Window win);
+  static void Quit();
+  static bool HasStructureChanged();
+  static void PendingResize(int width, int height);
+  static void SetXRRFailSafeTimer(int millis);
+  static bool MessagePump();
+  static size_t GetQueueSize();
+
+protected:
+  static XBMCKey LookupXbmcKeySym(KeySym keysym);
+  static bool ProcessKey(XBMC_Event &event);
+  static CWinEventsX11Imp *WinEvents;
+  Display *m_display;
+  Window m_window;
+  Atom m_wmDeleteMessage;
+  char *m_keybuf;
+  size_t m_keybuf_len;
+  XIM m_xim;
+  XIC m_xic;
+  std::map<uint32_t,uint32_t> m_symLookupTable;
+  int m_keymodState;
+  bool m_structureChanged;
+  int m_RREventBase;
+  XbmcThreads::EndTime m_xrrFailSafeTimer;
+  bool m_xrrEventPending;
+};
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinSystem.h xbmc-13.2rc1-Gotham/xbmc/windowing/WinSystem.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/WinSystem.h	2014-08-13 18:26:07.720512045 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/WinSystem.h	2014-08-13 18:27:01.416778306 +0800
@@ -103,6 +103,7 @@
   std::vector<RESOLUTION_WHR> ScreenResolutions(int screen, float refreshrate);
   std::vector<REFRESHRATE> RefreshRates(int screen, int width, int height, uint32_t dwFlags);
   REFRESHRATE DefaultRefreshRate(int screen, std::vector<REFRESHRATE> rates);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo) { return true; };
 
   // text input interface
   virtual void EnableTextInput(bool bEnable) {}
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11.cpp xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11.cpp	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11.cpp	2014-08-13 18:27:01.716779793 +0800
@@ -22,7 +22,6 @@
 
 #ifdef HAS_GLX
 
-#include <SDL/SDL_syswm.h>
 #include "WinSystemX11.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
@@ -34,28 +33,35 @@
 #include "XRandR.h"
 #include <vector>
 #include "threads/SingleLock.h"
-#include <X11/Xlib.h>
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
 #include "utils/StringUtils.h"
+#include "settings/Settings.h"
+#include "windowing/WindowingFactory.h"
+#include <X11/Xatom.h>
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
 #endif
 
+#include "../WinEventsX11.h"
+#include "input/MouseStat.h"
+
 using namespace std;
 
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
   m_glContext = NULL;
-  m_SDLSurface = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
-  m_wmWindow = 0;
+  m_mainWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
+  m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
+  m_invisibleCursor = 0;
+  m_bIsInternalXrr = false;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -68,19 +74,8 @@
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-
-    SDL_EnableUNICODE(1);
-    // set repeat to 10ms to ensure repeat time < frame time
-    // so that hold times can be reliably detected
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, 10);
-
-    SDL_GL_SetAttribute(SDL_GL_RED_SIZE,   8);
-    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE,  8);
-    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-
-    return CWinSystemBase::InitWindowSystem();
+    bool ret = CWinSystemBase::InitWindowSystem();
+    return ret;
   }
   else
     CLog::Log(LOGERROR, "GLX Error: No Display found");
@@ -91,9 +86,18 @@
 bool CWinSystemX11::DestroyWindowSystem()
 {
 #if defined(HAS_XRANDR)
-  //restore videomode on exit
+  //restore desktop resolution on exit
   if (m_bFullScreen)
-    g_xrandr.RestoreState();
+  {
+    XOutput out;
+    XMode mode;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
+    g_xrandr.SetMode(out, mode);
+  }
 #endif
 
   if (m_dpy)
@@ -108,6 +112,9 @@
 
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
+    // i have seen core dumps on ATI if the display is not closed here
+    // crashes when shutting down via cec
+//    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
@@ -117,177 +124,268 @@
 
 bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
 {
-  RESOLUTION_INFO& desktop = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP);
-
-  if (fullScreen &&
-      (res.iWidth != desktop.iWidth || res.iHeight != desktop.iHeight ||
-       res.fRefreshRate != desktop.fRefreshRate || res.iScreen != desktop.iScreen))
-  {
-    //on the first call to SDL_SetVideoMode, SDL stores the current displaymode
-    //SDL restores the displaymode on SDL_QUIT(), if we change the displaymode
-    //before the first call to SDL_SetVideoMode, SDL changes the displaymode back
-    //to the wrong mode on exit
-
-    CLog::Log(LOGINFO, "CWinSystemX11::CreateNewWindow initializing to desktop resolution first");
-    if (!SetFullScreen(true, desktop, false))
-      return false;
-  }
-
   if(!SetFullScreen(fullScreen, res, false))
     return false;
 
-  CBaseTexture* iconTexture = CTexture::LoadFromFile("special://xbmc/media/icon256x256.png");
-
-  if (iconTexture)
-    SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture->GetPixels(), iconTexture->GetWidth(), iconTexture->GetHeight(), 32, iconTexture->GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
-  SDL_WM_SetCaption("XBMC Media Center", NULL);
-  delete iconTexture;
-
-  // register XRandR Events
-#if defined(HAS_XRANDR)
-  int iReturn;
-  XRRQueryExtension(m_dpy, &m_RREventBase, &iReturn);
-  XRRSelectInput(m_dpy, m_wmWindow, RRScreenChangeNotifyMask);
-#endif
-
   m_bWindowCreated = true;
   return true;
 }
 
 bool CWinSystemX11::DestroyWindow()
 {
+  if (!m_mainWindow)
+    return true;
+
+  if (m_glContext)
+  {
+    glFinish();
+    glXMakeCurrent(m_dpy, None, NULL);
+  }
+
+  if (m_invisibleCursor)
+  {
+    XUndefineCursor(m_dpy, m_mainWindow);
+    XFreeCursor(m_dpy, m_invisibleCursor);
+    m_invisibleCursor = 0;
+  }
+
+  CWinEventsX11Imp::Quit();
+
+  XUnmapWindow(m_dpy, m_mainWindow);
+  XSync(m_dpy,TRUE);
+  XDestroyWindow(m_dpy, m_glWindow);
+  XDestroyWindow(m_dpy, m_mainWindow);
+  m_glWindow = 0;
+  m_mainWindow = 0;
+
+  if (m_icon)
+    XFreePixmap(m_dpy, m_icon);
+
   return true;
 }
 
 bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  XOutput *out = NULL;
+  if (m_userOutput.compare("Default") != 0)
+  {
+    out = g_xrandr.GetOutput(m_userOutput);
+    if (out)
+    {
+      XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+      if (!mode.isCurrent)
+      {
+        out = NULL;
+      }
+    }
+  }
+  if (!out)
+  {
+    std::vector<XOutput> outputs = g_xrandr.GetModes();
+    if (outputs.size() > 0)
+    {
+      m_userOutput = outputs[0].name;
+    }
+  }
+
   if(m_nWidth  == newWidth
-  && m_nHeight == newHeight)
+  && m_nHeight == newHeight
+  && m_userOutput.compare(m_currentOutput) == 0)
     return true;
 
-  m_nWidth  = newWidth;
-  m_nHeight = newHeight;
-
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
-
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
+  if (!SetWindow(newWidth, newHeight, false, m_userOutput))
   {
-    SetGrabMode();
-    RefreshGlxContext();
-    return true;
+    return false;
   }
 
+  m_nWidth  = newWidth;
+  m_nHeight = newHeight;
+  m_bFullScreen = false;
+  m_currentOutput = m_userOutput;
+
   return false;
 }
 
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  m_nWidth      = res.iWidth;
-  m_nHeight     = res.iHeight;
-  m_bFullScreen = fullScreen;
 
 #if defined(HAS_XRANDR)
   XOutput out;
   XMode mode;
-  out.name = res.strOutput;
-  mode.w   = res.iWidth;
-  mode.h   = res.iHeight;
-  mode.hz  = res.fRefreshRate;
-  mode.id  = res.strId;
- 
-  if(m_bFullScreen)
+
+  if (fullScreen)
   {
-    OnLostDevice();
-    g_xrandr.SetMode(out, mode);
+    out.name = res.strOutput;
+    mode.w   = res.iWidth;
+    mode.h   = res.iHeight;
+    mode.hz  = res.fRefreshRate;
+    mode.id  = res.strId;
   }
   else
-    g_xrandr.RestoreState();
-#endif
-
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
-
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
   {
-    if ((m_SDLSurface->flags & SDL_OPENGL) != SDL_OPENGL)
-      CLog::Log(LOGERROR, "CWinSystemX11::SetFullScreen SDL_OPENGL not set, SDL_GetError:%s", SDL_GetError());
-
-    SetGrabMode();
-    RefreshGlxContext();
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
+  }
+ 
+  XMode   currmode = g_xrandr.GetCurrentMode(out.name);
+  if (!currmode.name.empty())
+  {
+    // flip h/w when rotated
+    if (m_bIsRotated)
+    {
+      int w = mode.w;
+      mode.w = mode.h;
+      mode.h = w;
+    }
 
-    return true;
+    // only call xrandr if mode changes
+    if (m_mainWindow)
+    {
+      if (currmode.w != mode.w || currmode.h != mode.h ||
+          currmode.hz != mode.hz || currmode.id != mode.id)
+      {
+        CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
+        OnLostDevice();
+        m_bIsInternalXrr = true;
+        g_xrandr.SetMode(out, mode);
+        return true;
+      }
+    }
   }
+#endif
 
-  return false;
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, m_userOutput))
+    return false;
+
+  m_nWidth      = res.iWidth;
+  m_nHeight     = res.iHeight;
+  m_bFullScreen = fullScreen;
+  m_currentOutput = m_userOutput;
+
+  return true;
 }
 
 void CWinSystemX11::UpdateResolutions()
 {
   CWinSystemBase::UpdateResolutions();
 
-
 #if defined(HAS_XRANDR)
-  if(g_xrandr.Query())
+  int numScreens = XScreenCount(m_dpy);
+  g_xrandr.SetNumScreens(numScreens);
+
+  bool switchOnOff = CSettings::Get().GetBool("videoscreen.monitorsingle");
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.compare("Default") == 0)
+    switchOnOff = false;
+
+  if(g_xrandr.Query(true, !switchOnOff))
   {
-    XOutput out  = g_xrandr.GetCurrentOutput();
-    XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    XOutput *out = NULL;
+    if (m_userOutput.compare("Default") != 0)
+    {
+      out = g_xrandr.GetOutput(m_userOutput);
+      if (out)
+      {
+        XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+        if (!mode.isCurrent && !switchOnOff)
+        {
+          out = NULL;
+        }
+      }
+    }
+    if (!out)
+    {
+      m_userOutput = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(m_userOutput);
+    }
+
+    if (switchOnOff)
+    {
+      // switch on output
+      g_xrandr.TurnOnOutput(m_userOutput);
+
+      // switch off other outputs
+      std::vector<XOutput> outputs = g_xrandr.GetModes();
+      for (int i=0; i<outputs.size(); i++)
+      {
+        if (outputs[i].name.Equals(m_userOutput.c_str()))
+          continue;
+        g_xrandr.TurnOffOutput(outputs[i].name);
+      }
+    }
+
+    XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+    if (mode.id.empty())
+      mode = g_xrandr.GetPreferredMode(m_userOutput);
+    m_bIsRotated = out->isRotated;
+    if (!m_bIsRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = m_userOutput;
   }
   else
 #endif
   {
-    int x11screen = DefaultScreen(m_dpy);
-    int w = DisplayWidth(m_dpy, x11screen);
-    int h = DisplayHeight(m_dpy, x11screen);
+    m_userOutput = "No Output";
+    m_nScreen = DefaultScreen(m_dpy);
+    int w = DisplayWidth(m_dpy, m_nScreen);
+    int h = DisplayHeight(m_dpy, m_nScreen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
-
 #if defined(HAS_XRANDR)
 
+  // erase previous stored modes
+  CDisplaySettings::Get().ClearCustomResolutions();
+
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
-  vector<XOutput>::iterator outiter;
-  vector<XOutput> outs;
-  outs = g_xrandr.GetModes();
-  CLog::Log(LOGINFO, "Number of connected outputs: %"PRIdS"", outs.size());
+
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
   string modename = "";
 
-  for (outiter = outs.begin() ; outiter != outs.end() ; outiter++)
+  if (out != NULL)
   {
-    XOutput out = *outiter;
     vector<XMode>::iterator modeiter;
-    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out.name.c_str(), out.modes.size());
+    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out->name.c_str(), out->modes.size());
 
-    for (modeiter = out.modes.begin() ; modeiter!=out.modes.end() ; modeiter++)
+    for (modeiter = out->modes.begin() ; modeiter!=out->modes.end() ; modeiter++)
     {
       XMode mode = *modeiter;
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
                 mode.id.c_str(), mode.name.c_str(), mode.hz, mode.w, mode.h);
       RESOLUTION_INFO res;
+      res.iScreen = 0; // not used by X11
       res.iWidth  = mode.w;
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
       res.iScreenHeight = mode.h;
-      if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
-        res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
+      if (!m_bIsRotated)
+      {
+        res.iWidth  = mode.w;
+        res.iHeight = mode.h;
+      }
+      else
+      {
+        res.iWidth  = mode.h;
+        res.iHeight = mode.w;
+      }
+      if (mode.h>0 && mode.w>0 && out->hmm>0 && out->wmm>0)
+        res.fPixelRatio = ((float)out->wmm/(float)mode.w) / (((float)out->hmm/(float)mode.h));
       else
         res.fPixelRatio = 1.0f;
 
       CLog::Log(LOGINFO, "Pixel Ratio: %f", res.fPixelRatio);
 
-      res.strMode      = StringUtils::Format("%s: %s @ %.2fHz", out.name.c_str(), mode.name.c_str(), mode.hz);
-      res.strOutput    = out.name;
+      res.strMode      = StringUtils::Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
+      res.strOutput    = out->name;
       res.strId        = mode.id;
-      res.iSubtitles   = (int)(0.95*mode.h);
+      res.iSubtitles   = (int)(0.965*mode.h);
       res.fRefreshRate = mode.hz;
       res.bFullScreen  = true;
 
@@ -300,8 +398,59 @@
       CDisplaySettings::Get().AddResolutionInfo(res);
     }
   }
+  CDisplaySettings::Get().ApplyCalibrations();
 #endif
+}
+
+bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
+{
+  XOutput *out = g_xrandr.GetOutput(m_currentOutput);
+
+  // keep calibrations done on a not connected output
+  if (!out->name.Equals(resInfo.strOutput))
+    return true;
+
+  // keep calibrations not updated with resolution data
+  if (resInfo.iWidth == 0)
+    return true;
 
+  float fPixRatio;
+  if (resInfo.iHeight>0 && resInfo.iWidth>0 && out->hmm>0 && out->wmm>0)
+    fPixRatio = ((float)out->wmm/(float)resInfo.iWidth) / (((float)out->hmm/(float)resInfo.iHeight));
+  else
+    fPixRatio = 1.0f;
+
+  if (resInfo.Overscan.left != 0)
+    return true;
+  if (resInfo.Overscan.top != 0)
+    return true;
+  if (resInfo.Overscan.right != resInfo.iWidth)
+    return true;
+  if (resInfo.Overscan.bottom != resInfo.iHeight)
+    return true;
+  if (resInfo.fPixelRatio != fPixRatio)
+    return true;
+  if (resInfo.iSubtitles != (int)(0.965*resInfo.iHeight))
+    return true;
+
+  return false;
+}
+
+void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
+{
+  vector<XOutput> outs;
+  g_xrandr.Query(true);
+  outs = g_xrandr.GetModes();
+  outputs->push_back("Default");
+  for(unsigned int i=0; i<outs.size(); ++i)
+  {
+    outputs->push_back(outs[i].name);
+  }
+}
+
+bool CWinSystemX11::IsCurrentOutput(CStdString output)
+{
+  return (output.Equals("Default")) || (m_currentOutput.compare(output) == 0);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
@@ -324,20 +473,13 @@
   return true;
 }
 
-bool CWinSystemX11::RefreshGlxContext()
+bool CWinSystemX11::RefreshGlxContext(bool force)
 {
   bool retVal = false;
-  SDL_SysWMinfo info;
-  SDL_VERSION(&info.version);
-  if (SDL_GetWMInfo(&info) <= 0)
-  {
-    CLog::Log(LOGERROR, "Failed to get window manager info from SDL");
-    return false;
-  }
 
-  if(m_glWindow == info.info.x11.window && m_glContext)
+  if (m_glContext && !force)
   {
-    CLog::Log(LOGERROR, "GLX: Same window as before, refreshing context");
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
     return true;
@@ -347,10 +489,8 @@
   XVisualInfo *visuals;
   XVisualInfo *vInfo      = NULL;
   int availableVisuals    = 0;
-  vMask.screen = DefaultScreen(m_dpy);
+  vMask.screen = m_nScreen;
   XWindowAttributes winAttr;
-  m_glWindow = info.info.x11.window;
-  m_wmWindow = info.info.x11.wmwindow;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
      or XGetVisualInfo() fail. That shouldn't happen unless something is
@@ -401,6 +541,8 @@
     {
       glXMakeCurrent(m_dpy, None, NULL);
       glXDestroyContext(m_dpy, m_glContext);
+      XSync(m_dpy, FALSE);
+      m_newGlContext = true;
     }
 
     if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
@@ -421,7 +563,10 @@
 
 void CWinSystemX11::ShowOSMouse(bool show)
 {
-  SDL_ShowCursor(show ? 1 : 0);
+  if (show)
+    XUndefineCursor(m_dpy,m_mainWindow);
+  else if (m_invisibleCursor)
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -435,8 +580,6 @@
     {
       m_screensaverReset.StartZero();
       XResetScreenSaver(m_dpy);
-      //need to flush the output buffer, since we don't check for events on m_dpy
-      XFlush(m_dpy);
     }
   }
   else
@@ -445,20 +588,68 @@
   }
 }
 
+void CWinSystemX11::EnableSystemScreenSaver(bool bEnable)
+{
+  if (!m_dpy)
+    return;
+
+  if (bEnable)
+    XForceScreenSaver(m_dpy, ScreenSaverActive);
+  else
+  {
+    Window root_return, child_return;
+    int root_x_return, root_y_return;
+    int win_x_return, win_y_return;
+    unsigned int mask_return;
+    bool isInWin = XQueryPointer(m_dpy, RootWindow(m_dpy, m_nScreen), &root_return, &child_return,
+                                 &root_x_return, &root_y_return,
+                                 &win_x_return, &win_y_return,
+                                 &mask_return);
+
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return+300, root_y_return+300);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, 0, 0);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return, root_y_return);
+    XSync(m_dpy, FALSE);
+  }
+}
+
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
-  if (bActivated && m_bWasFullScreenBeforeMinimize && !g_graphicsContext.IsFullScreenRoot())
+  if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
+  {
     g_graphicsContext.ToggleFullScreenRoot();
 
+    m_bWasFullScreenBeforeMinimize = false;
+  }
   m_minimized = !bActivated;
 }
+
+void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
+{
+  if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
+      !m_bFullScreen)
+  {
+    m_bWasFullScreenBeforeMinimize = false;
+    g_graphicsContext.ToggleFullScreenRoot();
+    m_minimized = false;
+  }
+  if (!bGaining)
+    m_bIgnoreNextFocusMessage = false;
+}
+
 bool CWinSystemX11::Minimize()
 {
-  m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
+  m_bWasFullScreenBeforeMinimize = m_bFullScreen;
   if (m_bWasFullScreenBeforeMinimize)
+  {
+    m_bIgnoreNextFocusMessage = true;
     g_graphicsContext.ToggleFullScreenRoot();
+  }
+
+  XIconifyWindow(m_dpy, m_mainWindow, m_nScreen);
 
-  SDL_WM_IconifyWindow();
   m_minimized = true;
   return true;
 }
@@ -468,13 +659,13 @@
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_wmWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_wmWindow);
+  XMapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -482,7 +673,7 @@
 
 void CWinSystemX11::CheckDisplayEvents()
 {
-#if defined(HAS_XRANDR)
+#if defined(HAS_XRANDR) && defined(HAS_SDL_VIDEO_X11)
   bool bGotEvent(false);
   bool bTimeout(false);
   XEvent Event;
@@ -505,13 +696,7 @@
 
   if (bGotEvent || bTimeout)
   {
-    CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-
-    CSingleLock lock(m_resourceSection);
-
-    // tell any shared resources
-    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-      (*i)->OnResetDevice();
+    NotifyXRREvent();
 
     // reset fail safe timer
     m_dpyLostTime = 0;
@@ -519,6 +704,61 @@
 #endif
 }
 
+void CWinSystemX11::NotifyXRREvent()
+{
+  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  m_windowDirty = true;
+
+  CSingleLock lock(g_graphicsContext);
+
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+
+  // if external event update resolutions
+  if (!m_bIsInternalXrr)
+  {
+    UpdateResolutions();
+  }
+  m_bIsInternalXrr = false;
+
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(m_userOutput);
+
+  if (out)
+    CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
+             , out->name.c_str(), mode.id.c_str(), mode.hz);
+  else
+    CLog::Log(LOGWARNING, "%s - output name not set", __FUNCTION__);
+
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    res = CDisplaySettings::Get().GetResolutionInfo(i);
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId.Equals(mode.id))
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    i = RES_DESKTOP;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
+
+}
+
 void CWinSystemX11::OnLostDevice()
 {
   CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
@@ -531,8 +771,12 @@
       (*i)->OnLostDevice();
   }
 
+#if defined(HAS_SDL_VIDEO_X11)
   // fail safe timer
   m_dpyLostTime = CurrentHostCounter();
+#else
+  CWinEventsX11Imp::SetXRRFailSafeTimer(3000);
+#endif
 }
 
 void CWinSystemX11::Register(IDispResource *resource)
@@ -564,37 +808,396 @@
   return m_minimized;
 }
 
-void CWinSystemX11::SetGrabMode(const CSetting *setting /*= NULL*/)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output)
 {
-  bool enabled;
-  if (setting)
-    enabled = ((CSettingBool*)setting)->GetValue();
-  else
-    enabled = CSettings::Get().GetBool("input.enablesystemkeys");
-    
-  if (m_SDLSurface && m_SDLSurface->flags & SDL_FULLSCREEN)
-  {
-    if (enabled)
-    {
-      //SDL will always call XGrabPointer and XGrabKeyboard when in fullscreen
-      //so temporarily zero the SDL_FULLSCREEN flag, then turn off SDL grab mode
-      //this will make SDL call XUnGrabPointer and XUnGrabKeyboard
-      m_SDLSurface->flags &= ~SDL_FULLSCREEN;
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
-      m_SDLSurface->flags |= SDL_FULLSCREEN;
+  bool changeWindow = false;
+  bool changeSize = false;
+  bool mouseActive = false;
+  float mouseX, mouseY;
+
+  if (m_mainWindow && ((m_bFullScreen != fullscreen) || m_currentOutput.compare(output) != 0 || m_windowDirty))
+  {
+    mouseActive = g_Mouse.IsActive();
+    if (mouseActive)
+    {
+      Window root_return, child_return;
+      int root_x_return, root_y_return;
+      int win_x_return, win_y_return;
+      unsigned int mask_return;
+      bool isInWin = XQueryPointer(m_dpy, m_mainWindow, &root_return, &child_return,
+                                   &root_x_return, &root_y_return,
+                                   &win_x_return, &win_y_return,
+                                   &mask_return);
+      if (isInWin)
+      {
+        mouseX = (float)win_x_return/m_nWidth;
+        mouseY = (float)win_y_return/m_nHeight;
+        g_Mouse.SetActive(false);
+      }
+      else
+        mouseActive = false;
     }
-    else
+    OnLostDevice();
+    DestroyWindow();
+    m_windowDirty = true;
+  }
+
+  // create main window
+  if (!m_mainWindow)
+  {
+    EnableSystemScreenSaver(false);
+
+    GLint att[] =
+    {
+      GLX_RGBA,
+      GLX_RED_SIZE, 8,
+      GLX_GREEN_SIZE, 8,
+      GLX_BLUE_SIZE, 8,
+      GLX_ALPHA_SIZE, 8,
+      GLX_DEPTH_SIZE, 24,
+      GLX_DOUBLEBUFFER,
+      None
+    };
+    Colormap cmap;
+    XSetWindowAttributes swa;
+    XVisualInfo *vi;
+    int x0 = 0;
+    int y0 = 0;
+
+    XOutput *out = g_xrandr.GetOutput(output);
+    if (!out)
+      out = g_xrandr.GetOutput(m_currentOutput);
+    if (out)
+    {
+      m_nScreen = out->screen;
+      x0 = out->x;
+      y0 = out->y;
+    }
+
+    vi = glXChooseVisual(m_dpy, m_nScreen, att);
+    cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
+
+    bool hasWM = HasWindowManager();
+
+    int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
+    swa.override_redirect = hasWM ? False : True;
+    swa.border_pixel = fullscreen ? 0 : 5;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.colormap = cmap;
+    swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
+                     ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
+                     PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
+                     EnterWindowMask | LeaveWindowMask | ExposureMask;
+    unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
+
+    m_mainWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+                    x0, y0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    swa.override_redirect = False;
+    swa.border_pixel = 0;
+    swa.event_mask = ExposureMask;
+    mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWColormap | CWEventMask;
+
+    m_glWindow = XCreateWindow(m_dpy, m_mainWindow,
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    if (fullscreen && hasWM)
+    {
+      Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
+      XChangeProperty(m_dpy, m_mainWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+    }
+
+    // define invisible cursor
+    Pixmap bitmapNoData;
+    XColor black;
+    static char noData[] = { 0,0,0,0,0,0,0,0 };
+    black.red = black.green = black.blue = 0;
+
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_mainWindow, noData, 8, 8);
+    m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
+                                            &black, &black, 0, 0);
+    XFreePixmap(m_dpy, bitmapNoData);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
+
+    //init X11 events
+    CWinEventsX11Imp::Init(m_dpy, m_mainWindow);
+
+    changeWindow = true;
+    changeSize = true;
+  }
+
+  if (!CWinEventsX11Imp::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
+  {
+    changeSize = true;
+  }
+
+  if (changeSize || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_mainWindow, width, height);
+  }
+
+  if ((width != m_nWidth) || (height != m_nHeight) || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_glWindow, width, height);
+  }
+
+  if (changeWindow)
+  {
+    m_icon = None;
+    {
+      CreateIconPixmap();
+      XWMHints *wm_hints;
+      XClassHint *class_hints;
+      XTextProperty windowName, iconName;
+      std::string titleString = "XBMC Media Center";
+      std::string classString = "xbmc.bin";
+      char *title = (char*)titleString.c_str();
+
+      XStringListToTextProperty(&title, 1, &windowName);
+      XStringListToTextProperty(&title, 1, &iconName);
+
+      wm_hints = XAllocWMHints();
+      wm_hints->initial_state = NormalState;
+      wm_hints->icon_pixmap = m_icon;
+      wm_hints->flags = StateHint | IconPixmapHint;
+
+      class_hints = XAllocClassHint();
+      class_hints->res_class = (char*)classString.c_str();
+      class_hints->res_name = (char*)classString.c_str();
+
+      XSync(m_dpy,False);
+      XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
+                            NULL, 0, NULL, wm_hints,
+                            class_hints);
+      XFree(class_hints);
+      XFree(wm_hints);
+
+      // register interest in the delete window message
+      Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
+      XSetWMProtocols(m_dpy, m_mainWindow, &wmDeleteMessage, 1);
+    }
+    XMapRaised(m_dpy, m_glWindow);
+    XMapRaised(m_dpy, m_mainWindow);
+    XSync(m_dpy,TRUE);
+
+    if (changeWindow && mouseActive)
+    {
+      XWarpPointer(m_dpy, None, m_mainWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+    }
+
+    CDirtyRegionList dr;
+    RefreshGlxContext(m_currentOutput.compare(output) != 0);
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    g_Windowing.ResetVSync();
+    m_windowDirty = false;
+
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnResetDevice();
+  }
+
+  return true;
+}
+
+bool CWinSystemX11::CreateIconPixmap()
+{
+  int depth;
+  XImage *img = NULL;
+  Visual *vis;
+  XWindowAttributes wndattribs;
+  XVisualInfo visInfo;
+  double rRatio;
+  double gRatio;
+  double bRatio;
+  int outIndex = 0;
+  int i,j;
+  int numBufBytes;
+  unsigned char *buf;
+  uint32_t *newBuf = 0;
+  size_t numNewBufBytes;
+
+  // Get visual Info
+  XGetWindowAttributes(m_dpy, m_glWindow, &wndattribs);
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_dpy, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  depth = visInfo.depth;
+  vis = visInfo.visual;
+
+  if (depth < 15)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - no suitable depth");
+    return false;
+  }
+
+  rRatio = vis->red_mask / 255.0;
+  gRatio = vis->green_mask / 255.0;
+  bRatio = vis->blue_mask / 255.0;
+
+  CBaseTexture *iconTexture = CBaseTexture::LoadFromFile("special://xbmc/media/icon.png");
+
+  if (!iconTexture)
+    return false;
+
+  buf = iconTexture->GetPixels();
+
+  numBufBytes = iconTexture->GetWidth() * iconTexture->GetHeight() * 4;
+  int wid = iconTexture->GetWidth();
+  int hi = iconTexture->GetHeight();
+
+  if (depth>=24)
+    numNewBufBytes = (4 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
+  else
+    numNewBufBytes = (2 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
+
+  newBuf = (uint32_t*)malloc(numNewBufBytes);
+  if (!newBuf)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - malloc failed");
+    return false;
+  }
+
+  for (i=0; i<iconTexture->GetHeight();++i)
+  {
+    for (j=0; j<iconTexture->GetWidth();++j)
     {
-      //turn off key grabbing, which will actually make SDL turn it on when in fullscreen
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
+      unsigned int pos = i*iconTexture->GetPitch()+j*4;
+      unsigned int r, g, b;
+      r = (buf[pos+2] * rRatio);
+      g = (buf[pos+1] * gRatio);
+      b = (buf[pos+0] * bRatio);
+      r &= vis->red_mask;
+      g &= vis->green_mask;
+      b &= vis->blue_mask;
+      newBuf[outIndex] = r | g | b;
+      ++outIndex;
     }
   }
+  img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
+                     iconTexture->GetWidth(), iconTexture->GetHeight(),
+                     (depth>=24)?32:16, 0);
+  if (!img)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not create image");
+    free(newBuf);
+    return false;
+  }
+  if (!XInitImage(img))
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - init image failed");
+    XDestroyImage(img);
+    return false;
+  }
+
+  // set byte order
+  union
+  {
+    char c[sizeof(short)];
+    short s;
+  } order;
+  order.s = 1;
+  if ((1 == order.c[0]))
+  {
+    img->byte_order = LSBFirst;
+  }
+  else
+  {
+    img->byte_order = MSBFirst;
+  }
+
+  // create icon pixmap from image
+  m_icon = XCreatePixmap(m_dpy, m_glWindow, img->width, img->height, depth);
+  GC gc = XCreateGC(m_dpy, m_glWindow, 0, NULL);
+  XPutImage(m_dpy, m_icon, gc, img, 0, 0, 0, 0, img->width, img->height);
+  XFreeGC(m_dpy, gc);
+  XDestroyImage(img); // this also frees newBuf
+
+  delete iconTexture;
+
+  return true;
 }
 
-void CWinSystemX11::OnSettingChanged(const CSetting *setting)
+bool CWinSystemX11::HasWindowManager()
 {
-  if (setting->GetId() == "input.enablesystemkeys")
-    SetGrabMode(setting);
+  Window wm_check;
+  unsigned char *data;
+  int status, real_format;
+  Atom real_type, prop;
+  unsigned long items_read, items_left, i;
+  char req = 0;
+
+  prop = XInternAtom(m_dpy, "_NET_SUPPORTING_WM_CHECK", True);
+  if (prop == None)
+    return false;
+  status = XGetWindowProperty(m_dpy, DefaultRootWindow(m_dpy), prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+  if(status != Success || ! items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  wm_check = ((Window*)data)[0];
+  XFree(data);
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+
+  if(status != Success || !items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  if(wm_check != ((Window*)data)[0])
+  {
+    XFree(data);
+    return false;
+  }
+
+  XFree(data);
+
+  prop = XInternAtom(m_dpy, "_NET_WM_NAME", True);
+  if (prop == None)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+    return true;
+  }
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                        0L, (~0L), False, AnyPropertyType, &real_type, &real_format,
+                        &items_read, &items_left, &data);
+
+  if(status == Success && items_read)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: %s", data);
+  }
+  else
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+
+  if(status == Success)
+    XFree(data);
+
+  return true;
 }
 
 #endif
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11GL.cpp xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11GL.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11GL.cpp	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11GL.cpp	2014-08-13 18:27:01.412778286 +0800
@@ -24,6 +24,7 @@
 #include "WinSystemX11GL.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
+#include "Application.h"
 
 CWinSystemX11GL::CWinSystemX11GL()
 {
@@ -167,7 +168,7 @@
     return false;
 
   m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, DefaultScreen(m_dpy));
+  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
   m_glxext += " ";
 
   CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
@@ -197,17 +198,25 @@
 
 bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_newGlContext = false;
   CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
   CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
 bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
+  m_newGlContext = false;
   CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
   CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11.h xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/WinSystemX11.h	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/X11/WinSystemX11.h	2014-08-13 18:27:01.716779793 +0800
@@ -25,7 +25,6 @@
 
 #include "system_gl.h"
 #include <GL/glx.h>
-#include <SDL/SDL.h>
 
 #include "windowing/WinSystem.h"
 #include "utils/Stopwatch.h"
@@ -49,11 +48,14 @@
   virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
   virtual void UpdateResolutions();
   virtual int  GetNumScreens() { return 1; }
+  virtual int  GetCurrentScreen() { return m_nScreen; }
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
+  virtual void EnableSystemScreenSaver(bool bEnable);
 
   virtual void NotifyAppActiveChange(bool bActivated);
+  virtual void NotifyAppFocusChange(bool bGaining);
 
   virtual bool Minimize();
   virtual bool Restore() ;
@@ -61,34 +63,46 @@
   virtual bool Show(bool raise = true);
   virtual void Register(IDispResource *resource);
   virtual void Unregister(IDispResource *resource);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo);
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  virtual void OnSettingChanged(const CSetting *setting);
+  void NotifyXRREvent();
+  void GetConnectedOutputs(std::vector<CStdString> *outputs);
+  bool IsCurrentOutput(CStdString output);
 
 protected:
-  bool RefreshGlxContext();
+  bool RefreshGlxContext(bool force);
   void CheckDisplayEvents();
   void OnLostDevice();
+  bool SetWindow(int width, int height, bool fullscreen, const std::string &output);
 
-  SDL_Surface* m_SDLSurface;
+  Window       m_glWindow, m_mainWindow;
   GLXContext   m_glContext;
-  GLXWindow    m_glWindow;
-  Window       m_wmWindow;
   Display*     m_dpy;
+  Cursor       m_invisibleCursor;
+  Pixmap       m_icon;
+  bool         m_bIsRotated;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
+  bool         m_bIgnoreNextFocusMessage;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
+  std::string                  m_currentOutput;
+  std::string                  m_userOutput;
+  bool                         m_windowDirty;
+  bool                         m_bIsInternalXrr;
+  bool                         m_newGlContext;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
-  void SetGrabMode(const CSetting *setting = NULL);
+  bool CreateIconPixmap();
+  bool HasWindowManager();
 
   CStopWatch m_screensaverReset;
 };
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/XRandR.cpp xbmc-13.2rc1-Gotham/xbmc/windowing/X11/XRandR.cpp
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/XRandR.cpp	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/X11/XRandR.cpp	2014-08-13 18:27:01.688779655 +0800
@@ -29,6 +29,7 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/StringUtils.h"
 #include "../xbmc/utils/log.h"
+#include "threads/SystemClock.h"
 
 #if defined(TARGET_FREEBSD)
 #include <sys/types.h>
@@ -40,11 +41,12 @@
 CXRandR::CXRandR(bool query)
 {
   m_bInit = false;
+  m_numScreens = 1;
   if (query)
     Query();
 }
 
-bool CXRandR::Query(bool force)
+bool CXRandR::Query(bool force, bool ignoreoff)
 {
   if (!force)
     if (m_bInit)
@@ -56,11 +58,23 @@
     return false;
 
   m_outputs.clear();
-  m_current.clear();
+  // query all screens
+  // we are happy if at least one screen returns results
+  bool success = false;
+  for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
+  {
+    if(Query(force, screennum, ignoreoff))
+      success = true;
+  }
+  return success;
+}
 
+bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
+{
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
+  cmd = StringUtils::Format("%s -q --screen %d", cmd.c_str(), screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
@@ -80,7 +94,7 @@
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != 0)
+  if (atoi(pRootElement->Attribute("id")) != screennum)
   {
     // TODO ERROR
     return false;
@@ -92,12 +106,20 @@
     xoutput.name = output->Attribute("name");
     StringUtils::Trim(xoutput.name);
     xoutput.isConnected = (strcasecmp(output->Attribute("connected"), "true") == 0);
+    xoutput.screen = screennum;
     xoutput.w = (output->Attribute("w") != NULL ? atoi(output->Attribute("w")) : 0);
     xoutput.h = (output->Attribute("h") != NULL ? atoi(output->Attribute("h")) : 0);
     xoutput.x = (output->Attribute("x") != NULL ? atoi(output->Attribute("x")) : 0);
     xoutput.y = (output->Attribute("y") != NULL ? atoi(output->Attribute("y")) : 0);
     xoutput.wmm = (output->Attribute("wmm") != NULL ? atoi(output->Attribute("wmm")) : 0);
     xoutput.hmm = (output->Attribute("hmm") != NULL ? atoi(output->Attribute("hmm")) : 0);
+    if (output->Attribute("rotation") != NULL
+        && (strcasecmp(output->Attribute("rotation"), "left") == 0 || strcasecmp(output->Attribute("rotation"), "right") == 0))
+    {
+      xoutput.isRotated = true;
+    }
+    else
+      xoutput.isRotated = false;
 
     if (!xoutput.isConnected)
        continue;
@@ -115,12 +137,9 @@
       xmode.isCurrent = (strcasecmp(mode->Attribute("current"), "true") == 0);
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
-      {
-        m_current.push_back(xoutput);
         hascurrent = true;
-      }
     }
-    if (hascurrent)
+    if (hascurrent || !ignoreoff)
       m_outputs.push_back(xoutput);
     else
       CLog::Log(LOGWARNING, "CXRandR::Query - output %s has no current mode, assuming disconnected", xoutput.name.c_str());
@@ -128,39 +147,89 @@
   return m_outputs.size() > 0;
 }
 
-std::vector<XOutput> CXRandR::GetModes(void)
+bool CXRandR::TurnOffOutput(CStdString name)
 {
-  Query();
-  return m_outputs;
-}
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
 
-void CXRandR::SaveState()
-{
-  Query(true);
+  CStdString cmd;
+  cmd  = getenv("XBMC_BIN_HOME");
+  cmd += "/xbmc-xrandr";
+  cmd = StringUtils::Format("%s --screen %d --output %s --off", cmd.c_str(), output->screen, name.c_str());
+
+  int status = system(cmd.c_str());
+  if (status == -1)
+    return false;
+
+  if (WEXITSTATUS(status) != 0)
+    return false;
+
+  return true;
 }
 
-void CXRandR::RestoreState()
+bool CXRandR::TurnOnOutput(CStdString name)
 {
-  vector<XOutput>::iterator outiter;
-  for (outiter=m_current.begin() ; outiter!=m_current.end() ; outiter++)
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
+  XMode mode = GetCurrentMode(output->name);
+  if (mode.isCurrent)
+    return true;
+
+  // get preferred mode
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
   {
-    vector<XMode> modes = (*outiter).modes;
-    vector<XMode>::iterator modeiter;
-    for (modeiter=modes.begin() ; modeiter!=modes.end() ; modeiter++)
+    if (m_outputs[j].name == output->name)
     {
-      XMode mode = *modeiter;
-      if (mode.isCurrent)
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
       {
-        SetMode(*outiter, mode);
-        return;
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          mode = m_outputs[j].modes[i];
+          break;
+        }
       }
     }
   }
+
+  if (!mode.isPreferred)
+    return false;
+
+  if (!SetMode(*output, mode))
+    return false;
+
+  XbmcThreads::EndTime timeout(5000);
+  while (!timeout.IsTimePast())
+  {
+    if (!Query(true))
+      return false;
+
+    output = GetOutput(name);
+    if (output && output->h > 0)
+      return true;
+
+    Sleep(200);
+  }
+
+  return false;
+}
+
+std::vector<XOutput> CXRandR::GetModes(void)
+{
+  Query();
+  return m_outputs;
+}
+
+void CXRandR::SaveState()
+{
+  Query(true);
 }
 
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
-  if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
+  if ((output.name == "" && mode.id == ""))
     return true;
 
   Query();
@@ -245,7 +314,7 @@
   m_currentMode = modeFound.id;
   char cmd[255];
   if (getenv("XBMC_BIN_HOME"))
-    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.name.c_str(), modeFound.id.c_str());
+    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --screen %d --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.screen, outputFound.name.c_str(), modeFound.id.c_str());
   else
     return false;
   CLog::Log(LOGINFO, "XRANDR: %s", cmd);
@@ -259,18 +328,30 @@
   return true;
 }
 
-XOutput CXRandR::GetCurrentOutput()
+XMode CXRandR::GetCurrentMode(CStdString outputName)
 {
   Query();
+  XMode result;
+
   for (unsigned int j = 0; j < m_outputs.size(); j++)
   {
-    if(m_outputs[j].isConnected)
-      return m_outputs[j];
+    if (m_outputs[j].name == outputName || outputName == "")
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isCurrent)
+        {
+          result = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
   }
-  XOutput empty;
-  return empty;
+
+  return result;
 }
-XMode CXRandR::GetCurrentMode(CStdString outputName)
+
+XMode CXRandR::GetPreferredMode(CStdString outputName)
 {
   Query();
   XMode result;
@@ -281,7 +362,7 @@
     {
       for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
       {
-        if (m_outputs[j].modes[i].isCurrent)
+        if (m_outputs[j].modes[i].isPreferred)
         {
           result = m_outputs[j].modes[i];
           break;
@@ -341,6 +422,43 @@
   }
 }
 
+void CXRandR::SetNumScreens(unsigned int num)
+{
+  m_numScreens = num;
+  m_bInit = false;
+}
+
+bool CXRandR::IsOutputConnected(CStdString name)
+{
+  bool result = false;
+  Query();
+
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == name)
+    {
+      result = true;
+      break;
+    }
+  }
+  return result;
+}
+
+XOutput* CXRandR::GetOutput(CStdString outputName)
+{
+  XOutput *result = 0;
+  Query();
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == outputName)
+    {
+      result = &m_outputs[i];
+      break;
+    }
+  }
+  return result;
+}
+
 CXRandR g_xrandr;
 
 #endif // HAS_XRANDR
diff -uNr xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/XRandR.h xbmc-13.2rc1-Gotham/xbmc/windowing/X11/XRandR.h
--- xbmc-13.2rc1-Gotham.orig/xbmc/windowing/X11/XRandR.h	2014-08-13 18:26:07.712512005 +0800
+++ xbmc-13.2rc1-Gotham/xbmc/windowing/X11/XRandR.h	2014-08-13 18:27:01.616779298 +0800
@@ -79,6 +79,7 @@
     }
   CStdString name;
   bool isConnected;
+  int screen;
   int w;
   int h;
   int x;
@@ -86,20 +87,26 @@
   int wmm;
   int hmm;
   std::vector<XMode> modes;
+  bool isRotated;
 };
 
 class CXRandR
 {
 public:
   CXRandR(bool query=false);
-  bool Query(bool force=false);
+  bool Query(bool force=false, bool ignoreoff=true);
+  bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
-  XOutput GetCurrentOutput();
   XMode   GetCurrentMode(CStdString outputName);
+  XMode   GetPreferredMode(CStdString outputName);
+  XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
-  void RestoreState();
+  void SetNumScreens(unsigned int num);
+  bool IsOutputConnected(CStdString name);
+  bool TurnOffOutput(CStdString name);
+  bool TurnOnOutput(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
@@ -107,10 +114,10 @@
 
 private:
   bool m_bInit;
-  std::vector<XOutput> m_current;
   std::vector<XOutput> m_outputs;
   CStdString m_currentOutput;
   CStdString m_currentMode;
+  unsigned int m_numScreens;
 };
 
 extern CXRandR g_xrandr;
diff -uNr xbmc-13.2rc1-Gotham.orig/XBMC.xcodeproj/project.pbxproj xbmc-13.2rc1-Gotham/XBMC.xcodeproj/project.pbxproj
--- xbmc-13.2rc1-Gotham.orig/XBMC.xcodeproj/project.pbxproj	2014-08-13 18:26:12.892537686 +0800
+++ xbmc-13.2rc1-Gotham/XBMC.xcodeproj/project.pbxproj	2014-08-13 18:27:01.088776680 +0800
@@ -359,6 +359,9 @@
 		7CDAEA8D1001EBA70040B25F /* PltIconsData.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CDAEA8B1001EBA70040B25F /* PltIconsData.cpp */; settings = {COMPILER_FLAGS = "-I$SRCROOT/lib/libUPnP/Platinum/Source/Core -I$SRCROOT/lib/libUPnP/Platinum/Source/Platinum -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaConnect -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaRenderer -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaServer -I$SRCROOT/lib/libUPnP/Platinum/Source/Extras -I$SRCROOT/lib/libUPnP/Neptune/Source/System/Posix -I$SRCROOT/lib/libUPnP/Neptune/Source/Core"; }; };
 		7CEBD8A80F33A0D800CAF6AD /* SpecialProtocolDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CEBD8A60F33A0D800CAF6AD /* SpecialProtocolDirectory.cpp */; };
 		7CEE2E5B13D6B71E000ABF2A /* TimeSmoother.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CEE2E5913D6B71E000ABF2A /* TimeSmoother.cpp */; };
+		7CF0504B190A1D7200222135 /* FFmpeg.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CF05049190A1D7200222135 /* FFmpeg.cpp */; };
+		7CF0504C190A1D7200222135 /* FFmpeg.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CF05049190A1D7200222135 /* FFmpeg.cpp */; };
+		7CF0504D190A1D7200222135 /* FFmpeg.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CF05049190A1D7200222135 /* FFmpeg.cpp */; };
 		7CF1FB0C123B1AF000B2CBCB /* Variant.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7CF1FB09123B1AF000B2CBCB /* Variant.cpp */; };
 		810C9F630D67BD2F0095F5DD /* PltMediaConnect.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 810C9F600D67BD2F0095F5DD /* PltMediaConnect.cpp */; settings = {COMPILER_FLAGS = "-I$SRCROOT/lib/libUPnP/Platinum/Source/Core -I$SRCROOT/lib/libUPnP/Platinum/Source/Platinum -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaConnect -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaRenderer -I$SRCROOT/lib/libUPnP/Platinum/Source/Devices/MediaServer -I$SRCROOT/lib/libUPnP/Platinum/Source/Extras -I$SRCROOT/lib/libUPnP/Neptune/Source/System/Posix -I$SRCROOT/lib/libUPnP/Neptune/Source/Core"; }; };
 		810C9FA90D67D1FB0095F5DD /* MythDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 810C9FA50D67D1FB0095F5DD /* MythDirectory.cpp */; };
@@ -3888,6 +3891,8 @@
 		7CEBD8A70F33A0D800CAF6AD /* SpecialProtocolDirectory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SpecialProtocolDirectory.h; sourceTree = "<group>"; };
 		7CEE2E5913D6B71E000ABF2A /* TimeSmoother.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TimeSmoother.cpp; sourceTree = "<group>"; };
 		7CEE2E5A13D6B71E000ABF2A /* TimeSmoother.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TimeSmoother.h; sourceTree = "<group>"; };
+		7CF05049190A1D7200222135 /* FFmpeg.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FFmpeg.cpp; sourceTree = "<group>"; };
+		7CF0504A190A1D7200222135 /* FFmpeg.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FFmpeg.h; sourceTree = "<group>"; };
 		7CF1FB09123B1AF000B2CBCB /* Variant.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Variant.cpp; sourceTree = "<group>"; };
 		7CF1FB0A123B1AF000B2CBCB /* Variant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Variant.h; sourceTree = "<group>"; };
 		810C9F600D67BD2F0095F5DD /* PltMediaConnect.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PltMediaConnect.cpp; path = MediaConnect/PltMediaConnect.cpp; sourceTree = "<group>"; };
@@ -7609,6 +7614,8 @@
 				E38E16580D25F9FA00618676 /* VideoRenderers */,
 				E38E14F60D25F9F900618676 /* DummyVideoPlayer.cpp */,
 				E38E14F70D25F9F900618676 /* DummyVideoPlayer.h */,
+				7CF05049190A1D7200222135 /* FFmpeg.cpp */,
+				7CF0504A190A1D7200222135 /* FFmpeg.h */,
 				E38E15B50D25F9FA00618676 /* IAudioCallback.h */,
 				E38E15B60D25F9FA00618676 /* IPlayer.h */,
 			);
@@ -10930,6 +10937,7 @@
 				7C8AE850189DE3CD00C33786 /* CoreAudioHardware.cpp in Sources */,
 				7C8AE851189DE3CD00C33786 /* CoreAudioStream.cpp in Sources */,
 				7C8AE854189DE47F00C33786 /* CoreAudioHelpers.cpp in Sources */,
+				7CF0504B190A1D7200222135 /* FFmpeg.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -11978,6 +11986,7 @@
 				F5CC234818150277006B5E91 /* AESinkNULL.cpp in Sources */,
 				F5CC238918150768006B5E91 /* AESinkProfiler.cpp in Sources */,
 				DF374B2518AC2BA20076B514 /* CoreAudioHelpers.cpp in Sources */,
+				7CF0504D190A1D7200222135 /* FFmpeg.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -13028,6 +13037,7 @@
 				F5CC234718150277006B5E91 /* AESinkNULL.cpp in Sources */,
 				F5CC238818150768006B5E91 /* AESinkProfiler.cpp in Sources */,
 				DF374B2418AC2BA20076B514 /* CoreAudioHelpers.cpp in Sources */,
+				7CF0504C190A1D7200222135 /* FFmpeg.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -13124,14 +13134,6 @@
 					"$(SRCROOT)/lib/libsquish",
 					"$(SRCROOT)/lib/SlingboxLib",
 					"$(SRCROOT)/xbmc/interfaces/json-rpc",
-					"\"$(SRCROOT)/lib/ffmpeg/libavcodec\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavutil\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavformat\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavfilter\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavdevice\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswresample\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libpostproc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswscale\"",
 					"\"$(SRCROOT)/xbmc/interfaces/python\"",
 					"\"$(SRCROOT)/xbmc/interfaces/legacy\"",
 				);
@@ -13259,14 +13261,6 @@
 					"$(SRCROOT)/lib/libsquish",
 					"$(SRCROOT)/lib/SlingboxLib",
 					"$(SRCROOT)/xbmc/interfaces/json-rpc",
-					"\"$(SRCROOT)/lib/ffmpeg/libavcodec\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavutil\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavformat\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavfilter\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavdevice\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswresample\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libpostproc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswscale\"",
 					"\"$(SRCROOT)/xbmc/interfaces/python\"",
 					"\"$(SRCROOT)/xbmc/interfaces/legacy\"",
 				);
@@ -13409,7 +13403,6 @@
 					xbmc/cores/AudioEngine,
 					xbmc/cores/AudioEngine/Utils,
 					lib,
-					lib/ffmpeg,
 					addons/library.xbmc.addon,
 					$XBMC_DEPENDS/include,
 					$XBMC_DEPENDS/include/mysql,
@@ -13429,15 +13422,6 @@
 					"\"$(SRCROOT)/lib/libsquish\"",
 					"\"$(SRCROOT)/lib/SlingboxLib\"",
 					"\"$(SRCROOT)/xbmc/interfaces/json-rpc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavcodec\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavutil\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavformat\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavfilter\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavdevice\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswresample\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libpostproc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswscale\"",
-					"\"$(SRCROOT)/xbmc/interfaces\"",
 					"\"$(SRCROOT)/xbmc/interfaces/legacy\"",
 					"\"$(SRCROOT)/xbmc/interfaces/python\"",
 				);
@@ -13525,7 +13509,6 @@
 					xbmc/cores/AudioEngine,
 					xbmc/cores/AudioEngine/Utils,
 					lib,
-					lib/ffmpeg,
 					addons/library.xbmc.addon,
 					$XBMC_DEPENDS/include,
 					$XBMC_DEPENDS/include/mysql,
@@ -13545,15 +13528,6 @@
 					"\"$(SRCROOT)/lib/libsquish\"",
 					"\"$(SRCROOT)/lib/SlingboxLib\"",
 					"\"$(SRCROOT)/xbmc/interfaces/json-rpc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavcodec\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavutil\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavformat\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavfilter\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libavdevice\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswresample\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libpostproc\"",
-					"\"$(SRCROOT)/lib/ffmpeg/libswscale\"",
-					"\"$(SRCROOT)/xbmc/interfaces\"",
 					"\"$(SRCROOT)/xbmc/interfaces/legacy\"",
 					"\"$(SRCROOT)/xbmc/interfaces/python\"",
 				);
@@ -13640,7 +13614,6 @@
 					xbmc/osx,
 					xbmc/cores/dvdplayer,
 					lib,
-					lib/ffmpeg,
 					addons/library.xbmc.addon,
 					$XBMC_DEPENDS/include,
 					$XBMC_DEPENDS/include/libcec,
@@ -13681,7 +13654,6 @@
 					xbmc/osx,
 					xbmc/cores/dvdplayer,
 					lib,
-					lib/ffmpeg,
 					addons/library.xbmc.addon,
 					$XBMC_DEPENDS/include,
 					$XBMC_DEPENDS/include/libcec,
