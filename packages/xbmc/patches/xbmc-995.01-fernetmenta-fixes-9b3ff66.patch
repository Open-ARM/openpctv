diff -uNr xbmc-13.0-r9b3ff66.orig/language/English/strings.po xbmc-13.0-r9b3ff66/language/English/strings.po
--- xbmc-13.0-r9b3ff66.orig/language/English/strings.po	2013-11-18 01:12:17.480950374 +0800
+++ xbmc-13.0-r9b3ff66/language/English/strings.po	2013-11-18 01:14:00.720953050 +0800
@@ -1019,7 +1019,9 @@
 msgid "Sizing: (%i,%i)->(%i,%i) (Zoom x%2.2f) AR:%2.2f:1 (Pixels: %2.2f:1) (VShift: %2.2f)"
 msgstr ""
 
-#empty string with id 246
+msgctxt "#246"
+msgid "Monitor"
+msgstr ""
 
 msgctxt "#247"
 msgid "Scripts"
@@ -6462,7 +6464,7 @@
 msgid "Allow file renaming and deletion"
 msgstr ""
 
-#empty strings from id 14072 to 14073
+#empty strings from id 14073 to 14073
 
 msgctxt "#14074"
 msgid "Set timezone"
@@ -6594,7 +6596,12 @@
 msgid "Stop ripping CD"
 msgstr ""
 
-#empty strings from id 14101 to 15014
+#: xbmc/settings/settings.xml
+msgctxt "#14101"
+msgid "Switch off other Monitor"
+msgstr ""
+
+#empty strings from id 14102 to 15014
 
 #: xbmc/dialogs/GUIDialogFavourites.cpp
 msgctxt "#15015"
diff -uNr xbmc-13.0-r9b3ff66.orig/lib/DllAvFormat.h xbmc-13.0-r9b3ff66/lib/DllAvFormat.h
--- xbmc-13.0-r9b3ff66.orig/lib/DllAvFormat.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/lib/DllAvFormat.h	2013-11-18 01:14:00.652953048 +0800
@@ -106,6 +106,7 @@
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   virtual AVRational av_stream_get_r_frame_rate(const AVStream *s)=0;
 #endif
+  virtual int av_find_default_stream_index(AVFormatContext *s)=0;
 };
 
 #if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
@@ -166,6 +167,7 @@
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   virtual AVRational av_stream_get_r_frame_rate(const AVStream *s) { return ::av_stream_get_r_frame_rate(s); }
 #endif
+  virtual int av_find_default_stream_index(AVFormatContext *s) { return ::av_find_default_stream_index(s); }
 
   // DLL faking.
   virtual bool ResolveExports() { return true; }
@@ -237,6 +239,7 @@
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
   DEFINE_METHOD1(AVRational, av_stream_get_r_frame_rate, (const AVStream *p1))
 #endif
+  DEFINE_METHOD1(int, av_find_default_stream_index, (AVFormatContext *p1))
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD_RENAME(av_register_all, av_register_all_dont_call)
     RESOLVE_METHOD_RENAME(avformat_network_init,   avformat_network_init_dont_call)
@@ -276,6 +279,7 @@
 #if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
     RESOLVE_METHOD(av_stream_get_r_frame_rate)
 #endif
+    RESOLVE_METHOD(av_find_default_stream_index)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavformat */
diff -uNr xbmc-13.0-r9b3ff66.orig/system/keymaps/keyboard.xml xbmc-13.0-r9b3ff66/system/keymaps/keyboard.xml
--- xbmc-13.0-r9b3ff66.orig/system/keymaps/keyboard.xml	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/system/keymaps/keyboard.xml	2013-11-18 01:14:00.748953051 +0800
@@ -119,6 +119,9 @@
       <prev_track>SkipPrevious</prev_track>
       <stop>Stop</stop>
       <play_pause>Pause</play_pause>
+      <fastforward>FastForward</fastforward>
+      <rewind>Rewind</rewind>
+      <record/>
       <launch_mail></launch_mail>
       <launch_media_select>XBMC.ActivateWindow(MyMusic)</launch_media_select>
       <launch_app1_pc_icon>ActivateWindow(MyPrograms)</launch_app1_pc_icon>
diff -uNr xbmc-13.0-r9b3ff66.orig/system/Lircmap.xml.orig xbmc-13.0-r9b3ff66/system/Lircmap.xml.orig
--- xbmc-13.0-r9b3ff66.orig/system/Lircmap.xml.orig	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/system/Lircmap.xml.orig	1970-01-01 08:00:00.000000000 +0800
@@ -1,538 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!-- This file contains the mapping of LIRC keys to XBMC keys used in Keymap.xml  -->
-<!--                                                                              -->
-<!-- How to add remotes                                                           -->
-<!-- <remote device="name_Lirc_calls_the_remote">                                 -->
-<!--                                                                              -->
-<!-- For the commands the layout following layout is used                         -->
-<!-- <XBMC_COMMAND>LircButtonName</XBMC_COMMAND>                                  -->
-<!--                                                                              -->
-<!-- For a list of XBMC_COMMAND's check out the <remote> sections of keymap.xml   -->
-
-<lircmap>
-	<remote device="mceusb">
-		<play>Play</play>
-		<pause>Pause</pause>
-		<stop>Stop</stop>
-		<forward>Forward</forward>
-		<reverse>Rewind</reverse>
-		<left>Left</left>
-		<right>Right</right>
-		<up>Up</up>
-		<down>Down</down>
-		<select>OK</select>
-		<pageplus>ChanUp</pageplus>
-		<pageminus>ChanDown</pageminus>
-		<back>Back</back>
-		<menu>DVD</menu>
-		<title>Guide</title>
-		<info>More</info>
-		<skipplus>Skip</skipplus>
-		<skipminus>Replay</skipminus>
-		<display>Aspect</display>
-		<start>Home</start>
-		<record>Record</record>
-		<volumeplus>VolUp</volumeplus>
-		<volumeminus>VolDown</volumeminus>
-		<mute>Mute</mute>
-		<power>Power</power>
-		<myvideo>Videos</myvideo>
-		<mymusic>Music</mymusic>
-		<mypictures>Pictures</mypictures>
-		<mytv>TV</mytv>
-		<one>One</one>
-		<two>Two</two>
-		<three>Three</three>
-		<four>Four</four>
-		<five>Five</five>
-		<six>Six</six>
-		<seven>Seven</seven>
-		<eight>Eight</eight>
-		<nine>Nine</nine>
-		<zero>Zero</zero>
-		<star>Star</star>
-		<hash>Hash</hash>
-		<clear>Clear</clear>
-		<enter>Enter</enter>
-		<red>Red</red>
-		<green>Green</green>
-		<yellow>Yellow</yellow>
-		<blue>Blue</blue>
-		<teletext>Teletext</teletext>
-
-		<!-- new kernel-based lirc button names -->
-		<left>KEY_LEFT</left>
-		<right>KEY_RIGHT</right>
-		<up>KEY_UP</up>
-		<down>KEY_DOWN</down>
-		<select>KEY_OK</select>
-		<start>KEY_HOME</start>
-		<back>KEY_BACK</back>
-		<record>KEY_RECORD</record>
-		<play>KEY_PLAY</play>
-		<pause>KEY_PAUSE</pause>
-		<stop>KEY_STOP</stop>
-		<forward>KEY_FORWARD</forward>
-		<reverse>KEY_REWIND</reverse>
-		<volumeplus>KEY_VOLUMEUP</volumeplus>
-		<volumeminus>KEY_VOLUMEDOWN</volumeminus>
-		<pageplus>KEY_CHANNELUP</pageplus>
-		<pageminus>KEY_CHANNELDOWN</pageminus>
-		<skipplus>KEY_NEXT</skipplus>
-		<skipminus>KEY_AGAIN</skipminus>
-		<mute>KEY_MUTE</mute>
-		<power>KEY_POWER</power>
-		<myvideo>KEY_VIDEO</myvideo>
-		<mymusic>KEY_AUDIO</mymusic>
-		<mytv>LiveTV</mytv>
-		<one>KEY_1</one>
-		<two>KEY_2</two>
-		<three>KEY_3</three>
-		<four>KEY_4</four>
-		<five>KEY_5</five>
-		<six>KEY_6</six>
-		<seven>KEY_7</seven>
-		<eight>KEY_8</eight>
-		<nine>KEY_9</nine>
-		<zero>KEY_0</zero>
-		<red>KEY_RED</red>
-		<green>KEY_GREEN</green>
-		<yellow>KEY_YELLOW</yellow>
-		<blue>KEY_BLUE</blue>
-		<menu>KEY_DVD</menu>
-		<clear>KEY_CLEAR</clear>
-		<enter>KEY_ENTER</enter>
-	</remote>
-	
-	<remote device="XboxDVDDongle">
-		<play>PLAY</play>
-		<pause>PAUSE</pause>
-		<stop>STOP</stop>
-		<forward>FORWARD</forward>
-		<reverse>REVERSE</reverse>
-		<left>LEFT</left>
-		<right>RIGHT</right>
-		<up>UP</up>
-		<down>DOWN</down>
-		<select>SELECT</select>
-		<back>BACK</back>
-		<menu>MENU</menu>
-		<title>TITLE</title>
-		<info>INFO</info>
-		<skipplus>SKIP+</skipplus>
-		<skipminus>SKIP-</skipminus>
-		<display>DISPLAY</display>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-	</remote>
-
-	<remote device="Microsoft_Xbox">
-		<play>PLAY</play>
-		<pause>PAUSE</pause>
-		<stop>STOP</stop>
-		<forward>FORWARD</forward>
-		<reverse>REVERSE</reverse>
-		<left>LEFT</left>
-		<right>RIGHT</right>
-		<up>UP</up>
-		<down>DOWN</down>
-		<select>SELECT</select>
-		<back>BACK</back>
-		<menu>MENU</menu>
-		<title>TITLE</title>
-		<info>INFO</info>
-		<skipplus>SKIP+</skipplus>
-		<skipminus>SKIP-</skipminus>
-		<display>DISPLAY</display>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-	</remote>
-
-	<remote device="PinnacleSysPCTVRemote">
-		<play>Play</play>
-		<pause>pause</pause>
-		<stop>Stop</stop>
-		<forward>FForward</forward>
-		<reverse>Rewind</reverse>
-		<left>Vol-Rew</left>
-		<right>Vol+FF</right>
-		<up>Chan+Play</up>
-		<down>Chan-Stop</down>
-		<pageplus>channel+</pageplus>
-		<pageminus>channel-</pageminus>
-		<select>middle</select>
-		<back>undo</back>
-		<menu>Menu</menu>
-		<title>L</title>
-		<info>Info</info>
-		<skipplus>next</skipplus>
-		<display>Fullscreen</display>
-		<record>Record</record>
-		<volumeplus>vol+</volumeplus>
-		<volumeminus>vol-</volumeminus>
-		<mute>Mute</mute>
-		<power>Power</power>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-	</remote>
-
-	<remote device="anysee">
-		<pause>pause</pause>
-		<stop>stop</stop>
-		<forward>f1</forward>
-		<reverse>f2</reverse>
-		<left>left</left>
-		<right>right</right>
-		<up>chan-up</up>
-		<down>chan-down</down>
-		<select>ok</select>
-		<back>exit</back>
-		<menu>menu</menu>
-		<title>play</title>
-		<info>info</info>
-		<skipplus>jump-fwd</skipplus>
-		<skipminus>jump-back</skipminus>
-		<display>size</display>
-		<start>star</start>
-		<record>rec</record>
-		<volumeplus></volumeplus>
-		<volumeminus></volumeminus>
-		<mute>mute</mute>
-		<power>power</power>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-		<red>red</red>
-		<green>green</green>
-		<yellow>yellow</yellow>
-		<blue>blue</blue>
-		<subtitle>subtitle</subtitle>
-		<language>audio</language>
-	</remote>
-	<remote device="iMON-PAD">
-		<power>Power</power>
-		<record>Record</record>
-		<play>Play</play>
-		<reverse>Rewind</reverse>
-		<pause>Pause</pause>
-		<stop>Stop</stop>
-		<forward>FastForward</forward>
-		<left>Left</left>
-		<right>Right</right>
-		<up>Up</up>
-		<down>Down</down>
-		<select>Enter</select>
-		<pageplus>Ch+</pageplus>
-		<pageminus>Ch-</pageminus>
-		<back>Esc</back>
-		<back>Backspace</back>
-		<menu>Multimon</menu>
-		<title>MouseMenu</title>
-		<info>SelectSpace</info>
-		<skipplus>NextChapter</skipplus>
-		<skipminus>PrevChapter</skipminus>
-		<display>FullScreen</display>
-		<start>MultiMon</start>
-		<volumeplus>Vol+</volumeplus>
-		<volumeminus>Vol-</volumeminus>
-		<mute>Mute</mute>
-		<myvideo>MyMovie</myvideo>
-		<mymusic>MyMusic</mymusic>
-		<mypictures>MyPhoto</mypictures>
-		<mytv>MyTV</mytv>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-		<subtitle>Language</subtitle>
-	</remote>
-	<remote device="Antec_Veris_RM200">
-		<stop>KEY_STOP</stop>
-		<pause>KEY_PAUSE</pause>
-		<forward>KEY_FASTFORWARD</forward>
-		<reverse>KEY_REWIND</reverse>
-		<left>KEY_LEFT</left>
-		<right>KEY_RIGHT</right>
-		<up>KEY_UP</up>
-		<down>KEY_DOWN</down>
-		<select>KEY_ENTER</select>
-		<pageplus>KEY_CHANNELUP</pageplus>
-		<pageminus>KEY_CHANNELDOWN</pageminus>
-		<back>KEY_BACKSPACE</back>
-		<menu>KEY_MENU</menu>
-		<play>KEY_PLAY</play>
-		<info>Go</info>
-		<skipplus>next</skipplus>
-		<skipminus>prev</skipminus>
-		<display>FullScreen</display>
-		<start>applauncher</start>
-		<record>KEY_RECORD</record>
-		<volumeplus>KEY_VOLUMEUP</volumeplus>
-		<volumeminus>KEY_VOLUMEDOWN</volumeminus>
-		<mute>KEY_MUTE</mute>
-		<power>KEY_POWER</power>
-		<myvideo>KEY_VIDEO</myvideo>
-		<mymusic>KEY_AUDIO</mymusic>
-		<mypictures>KEY_PHOTO</mypictures>
-		<mytv>KEY_TV</mytv>
-		<one>KEY_1</one>
-		<two>KEY_2</two>
-		<three>KEY_3</three>
-		<four>KEY_4</four>
-		<five>KEY_5</five>
-		<six>KEY_6</six>
-		<seven>KEY_7</seven>
-		<eight>KEY_8</eight>
-		<nine>KEY_9</nine>
-		<zero>KEY_0</zero>
-		<star>Star</star>
-		<hash>Hash</hash>
-		<playlist>KEY_BOOKMARKS</playlist>
-		<teletext>Thumbnail</teletext>
-		<title>TaskSwitcher</title>		
-	</remote>
-	<remote	device="MCE_via_iMON">
-		<play>KEY_PLAY</play>
-		<pause>KEY_PAUSE</pause>
-		<stop>KEY_STOP</stop>
-		<forward>KEY_FASTFORWARD</forward>
-		<reverse>KEY_REWIND</reverse>
-		<left>KEY_LEFT</left>
-		<right>KEY_RIGHT</right>
-		<up>KEY_UP</up>
-		<down>KEY_DOWN</down>
-		<select>KEY_OK</select>
-		<pageplus>KEY_CHANNELUP</pageplus>
-		<pageminus>KEY_CHANNELDOWN</pageminus>
-		<back>KEY_BACKSPACE</back>
-		<menu>PreviousMenu</menu>
-		<title>Guide</title>
-		<info>KEY_INFO</info>
-		<skipplus>KEY_SKIP</skipplus>
-		<skipminus>KEY_REPLAY</skipminus>
-		<display>Teletext</display>
-		<start>WindowsMCE</start>
-		<record>KEY_RECORD</record>
-		<volumeplus>KEY_VOLUMEUP</volumeplus>
-		<volumeminus>KEY_VOLUMEDOWN</volumeminus>
-		<mute>KEY_MUTE</mute>
-		<power>KEY_POWER</power>
-		<myvideo>KEY_VIDEO</myvideo>
-		<mymusic>KEY_AUDIO</mymusic>
-		<mypictures>KEY_PHOTO</mypictures>
-		<mytv>KEY_TV</mytv>
-		<one>KEY_ONE</one>
-		<two>KEY_TWO</two>
-		<three>KEY_THREE</three>
-		<four>KEY_FOUR</four>
-		<five>KEY_FIVE</five>
-		<six>KEY_SIX</six>
-		<seven>KEY_SEVEN</seven>
-		<eight>KEY_EIGHT</eight>
-		<nine>KEY_NINE</nine>
-		<zero>KEY_ZERO</zero>
-		<star>Star</star>
-		<hash>Hash</hash>
-		<clear>KEY_DELETE</clear>
-		<enter>KEY_ENTER</enter>
-		<red>Red</red>
-		<green>Green</green>
-		<yellow>Yellow</yellow>
-		<blue>Blue</blue>
-	</remote>
-	<remote device="TwinHanRemote">
-		<display>fullscreen</display>
-		<power>power</power>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<record>rec</record>
-		<zero>0</zero>
-		<myvideo>favorite</myvideo>
-		<volumeminus>rewind</volumeminus>
-		<volumeplus>forward</volumeplus>
-		<up>ch+</up>
-		<left>vol-</left>
-		<select>play</select>
-		<right>vol+</right>
-		<down>ch-</down>
-		<menu>recall</menu>
-		<stop>stop</stop>
-		<pause>pause</pause>
-		<mute>mute</mute>
-		<info>epg</info>
-		<recordedtv>recordlist</recordedtv>
-		<title>teletext</title>
-	</remote>
-
-	<remote device="linux-input-layer">
-	<altname>cx23885_remote</altname>
-	<altname>devinput</altname>
-		<left>KEY_LEFT</left>
-		<right>KEY_RIGHT</right>
-		<up>KEY_UP</up>
-		<down>KEY_DOWN</down>
-		<select>KEY_OK</select>
-		<select>KEY_ENTER</select>
-		<enter>KEY_ENTER</enter>
-		<clear>KEY_DELETE</clear>
-		<start>KEY_SELECT</start>
-		<start>KEY_PROG1</start>
-		<start>KEY_HOME</start>
-		<back>KEY_ESC</back>
-		<back>KEY_EXIT</back>
-		<back>KEY_BACK</back>
-		<back>KEY_CLOSE</back>
-		<record>KEY_RECORD</record>
-		<play>KEY_PLAY</play>
-		<play>KEY_PLAYPAUSE</play>
-		<pause>KEY_PAUSE</pause>
-		<stop>KEY_STOP</stop>
-		<stop>KEY_STOPCD</stop>
-		<forward>KEY_FASTFORWARD</forward>
-		<reverse>KEY_REWIND</reverse>
-		<volumeplus>KEY_VOLUMEUP</volumeplus>
-		<volumeminus>KEY_VOLUMEDOWN</volumeminus>
-		<channelplus>KEY_CHANNELUP</channelplus>
-		<channelminus>KEY_CHANNELDOWN</channelminus>
-		<skipplus>KEY_NEXTSONG</skipplus>
-		<skipplus>KEY_NEXT</skipplus>
-		<skipminus>KEY_PREVIOUSSONG</skipminus>
-		<skipminus>KEY_PREVIOUS</skipminus>
-		<title>KEY_TITLE</title>
-		<title>KEY_EPG</title>
-		<subtitle>KEY_SUBTITLE</subtitle>
-		<language>KEY_LANGUAGE</language>
-		<mute>KEY_MUTE</mute>
-		<power>KEY_POWER</power>
-		<myvideo>KEY_VIDEO</myvideo>
-		<mymusic>KEY_AUDIO</mymusic>
-		<mypictures>KEY_MHP</mypictures>
-		<mypictures>KEY_CAMERA</mypictures>
-		<mytv>KEY_TV</mytv>
-		<liveradio>KEY_RADIO</liveradio>
-		<mytv>KEY_TUNER</mytv>
-		<one>KEY_1</one>
-		<two>KEY_2</two>
-		<three>KEY_3</three>
-		<four>KEY_4</four>
-		<five>KEY_5</five>
-		<six>KEY_6</six>
-		<seven>KEY_7</seven>
-		<eight>KEY_8</eight>
-		<nine>KEY_9</nine>
-		<zero>KEY_0</zero>
-		<one>KEY_NUMERIC_1</one>
-		<two>KEY_NUMERIC_2</two>
-		<three>KEY_NUMERIC_3</three>
-		<four>KEY_NUMERIC_4</four>
-		<five>KEY_NUMERIC_5</five>
-		<six>KEY_NUMERIC_6</six>
-		<seven>KEY_NUMERIC_7</seven>
-		<eight>KEY_NUMERIC_8</eight>
-		<nine>KEY_NUMERIC_9</nine>
-		<zero>KEY_NUMERIC_0</zero>
-		<star>KEY_NUMERIC_STAR</star>
-		<hash>KEY_NUMERIC_POUND</hash>
-		<red>KEY_RED</red>
-		<green>KEY_GREEN</green>
-		<yellow>KEY_YELLOW</yellow>
-		<blue>KEY_BLUE</blue>
-		<menu>KEY_DVD</menu>
-		<menu>KEY_MENU</menu>
-		<info>KEY_INFO</info>
-		<info>KEY_PROPS</info>
-		<display>KEY_ANGLE</display>
-		<display>KEY_ZOOM</display>
-		<recordedtv>KEY_PVR</recordedtv>
-		<teletext>KEY_TEXT</teletext>
-		<clear>KEY_DELETE</clear>
-	</remote>
-	<remote device="mediacenter">
-		<pause>pause</pause>
-		<stop>stop</stop>
-		<forward>fwd</forward>
-		<reverse>rew</reverse>
-		<left>left</left>
-		<right>right</right>
-		<up>up</up>
-		<down>down</down>
-		<select>ok</select>
-		<pageplus>ch+</pageplus>
-		<pageminus>ch-</pageminus>
-		<back>back</back>
-		<menu>clear</menu>
-		<title>play</title>
-		<info>info</info>
-		<skipplus>next</skipplus>
-		<skipminus>prev</skipminus>
-		<display>teletext</display>
-		<start>ehome</start>
-		<record>rec</record>
-		<volumeplus>vol+</volumeplus>
-		<volumeminus>vol-</volumeminus>
-		<mute>mute</mute>
-		<power>power</power>
-		<myvideo>video</myvideo>
-		<mymusic>music</mymusic>
-		<mypictures>pictures</mypictures>
-		<mytv>tv</mytv>
-		<one>1</one>
-		<two>2</two>
-		<three>3</three>
-		<four>4</four>
-		<five>5</five>
-		<six>6</six>
-		<seven>7</seven>
-		<eight>8</eight>
-		<nine>9</nine>
-		<zero>0</zero>
-		<mytv>red</mytv>
-		<mymusic>green</mymusic>
-		<mypictures>yellow</mypictures>
-		<myvideo>blue</myvideo>
-	</remote>
-</lircmap>
diff -uNr xbmc-13.0-r9b3ff66.orig/system/settings/settings.xml xbmc-13.0-r9b3ff66/system/settings/settings.xml
--- xbmc-13.0-r9b3ff66.orig/system/settings/settings.xml	2013-11-18 01:12:17.588950375 +0800
+++ xbmc-13.0-r9b3ff66/system/settings/settings.xml	2013-11-18 01:14:00.760953052 +0800
@@ -2021,6 +2021,21 @@
   <section id="system" label="13000" help="36349">
     <category id="videoscreen" label="21373" help="36350">
       <group id="1">
+        <setting id="videoscreen.monitor" type="string" label="246" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>Default</default>
+          <constraints>
+            <options>monitors</options>
+          </constraints>
+          <control type="spinner" format="string" delayed="true" />
+        </setting>
+        <setting id="videoscreen.monitorsingle" type="boolean" label="14101" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -2042,6 +2057,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.screenmode" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="list" format="string" />
         </setting>
@@ -2071,6 +2087,7 @@
           <control type="toggle" />
         </setting>
         <setting id="videoscreen.blankdisplays" type="boolean" label="13130" help="36355">
+          <visible>!HAS_GLX</visible>
           <level>1</level>
           <default>false</default>
           <dependencies>
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/Application.cpp xbmc-13.0-r9b3ff66/xbmc/Application.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/Application.cpp	2013-11-18 01:12:17.592950376 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/Application.cpp	2013-11-18 01:14:00.668953048 +0800
@@ -857,7 +857,7 @@
 
   uint32_t sdlFlags = 0;
 
-#if defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)
+#if (defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)) && !defined(HAS_GLX)
   sdlFlags |= SDL_INIT_VIDEO;
 #endif
 
@@ -2257,10 +2257,11 @@
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp xbmc-13.0-r9b3ff66/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp	2013-11-18 01:12:17.612950377 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp	2013-11-18 01:14:00.720953050 +0800
@@ -30,8 +30,8 @@
 #include "settings/AdvancedSettings.h"
 #include "windowing/WindowingFactory.h"
 
-#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
-#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+#define MAX_CACHE_LEVEL 0.4   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.2   // buffered time after stream stages in seconds
 
 void CEngineStats::Reset(unsigned int sampleRate)
 {
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/DllLoader/exports/wrapper.c.orig xbmc-13.0-r9b3ff66/xbmc/cores/DllLoader/exports/wrapper.c.orig
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/DllLoader/exports/wrapper.c.orig	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/DllLoader/exports/wrapper.c.orig	1970-01-01 08:00:00.000000000 +0800
@@ -1,507 +0,0 @@
-/*
- *      Copyright (C) 2005-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-//
-// To recreate wrapper.def:
-//
-// bash# (echo -n "-Wl"; grep __wrap wrapper.c | grep -v bash | sed "s/.*__wrap_//g" | sed "s/(.*//g" | awk '{printf(",-wrap,%s",$0);}') > wrapper.def
-//
-#include <sys/types.h>
-#include <sys/stat.h>
-#if !defined(TARGET_ANDROID)
-#include <sys/statvfs.h>
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <stdarg.h>
-#ifdef TARGET_WINDOWS
-#include "win32-dirent.h"
-#else
-#include <dirent.h>
-#endif
-#include <dlfcn.h>
-
-#if defined(TARGET_DARWIN) || defined(TARGET_FREEBSD) || defined(TARGET_ANDROID)
-typedef off_t     __off_t;
-typedef int64_t   off64_t;
-typedef off64_t   __off64_t;
-typedef fpos_t    fpos64_t;
-#define stat64    stat
-#if defined(TARGET_DARWIN) || defined(TARGET_ANDROID)
-#define _G_va_list va_list
-#endif
-#endif
-
-#ifdef TARGET_POSIX
-#define _stat stat
-#endif
-
-struct mntent;
-
-void* dllmalloc(size_t );
-void* dllcalloc( size_t , size_t );
-void* dllrealloc(void*, size_t);
-void dllfree(void*);
-
-int dll_open(const char* szFileName, int iMode);
-int dll_write(int fd, const void* buffer, unsigned int uiSize);
-int dll_read(int fd, void* buffer, unsigned int uiSize);
-off_t dll_lseek(int fd, __off_t lPos, int iWhence);
-__off64_t dll_lseeki64(int fd, __off64_t lPos, int iWhence);
-int dll_close(int fd);
-
-FILE * dll_fopen (const char * filename, const char * mode);
-FILE* dll_freopen(const char *path, const char *mode, FILE *stream);
-FILE* dll_fdopen(int i, const char* file);
-int dll_fclose (FILE * stream);
-int dll_ferror (FILE * stream);
-int dll_feof (FILE * stream);
-int dll_fileno(FILE* stream);
-void dll_clearerr(FILE* stream);
-int dll_fread (void * buffer, size_t size, size_t count, FILE * stream);
-size_t dll_fwrite ( const void * buffer, size_t size, size_t count, FILE * stream );
-int dll_fflush (FILE * stream);
-int dll_fputc (int character, FILE * stream);
-int dll_fputs (const char * szLine , FILE* stream);
-int dll_putc(int c, FILE *stream);
-int dll_fseek ( FILE * stream , long offset , int origin );
-int dll_fseek64(FILE *stream, off64_t offset, int origin);
-long dll_ftell(FILE *stream);
-off64_t dll_ftell64(FILE *stream);
-void dll_rewind(FILE* stream);
-int dll_fgetpos(FILE* stream, fpos_t* pos);
-int dll_fgetpos64(FILE *stream, fpos64_t *pos);
-int dll_fsetpos(FILE* stream, const fpos_t* pos);
-int dll_fsetpos64(FILE* stream, const fpos64_t* pos);
-DIR* dll_opendir(const char* name);
-struct dirent* dll_readdir(DIR* dirp);
-int dll_closedir(DIR* dirp);
-void dll_rewinddir(DIR* dirp);
-int dll_fprintf(FILE* stream , const char * format, ...);
-int dllprintf(const char *format, ...);
-int dll_vfprintf(FILE *stream, const char *format, va_list va);
-int dll_fgetc (FILE* stream);
-char * dll_fgets (char* pszString, int num , FILE * stream);
-int dll_getc (FILE * stream);
-int dll_ungetc (int c, FILE * stream);
-int dll_ioctl(int d, unsigned long int request, va_list va);
-int dll_stat(const char *path, struct _stat *buffer);
-int dll_stat64(const char *path, struct stat64 *buffer);
-void dll_flockfile(FILE *file);
-int dll_ftrylockfile(FILE *file);
-void dll_funlockfile(FILE *file);
-int dll_fstat64(int fd, struct stat64 *buf);
-int dll_fstat(int fd, struct _stat *buf);
-FILE* dll_popen(const char *command, const char *mode);
-void* dll_dlopen(const char *filename, int flag);
-int dll_setvbuf(FILE *stream, char *buf, int type, size_t size);
-struct mntent *dll_getmntent(FILE *fp);
-
-void *__wrap_dlopen(const char *filename, int flag)
-{
-#if defined(TARGET_ANDROID)
-  return dll_dlopen(filename, flag);
-#else
-  return dlopen(filename, flag);
-#endif
-}
-
-FILE *__wrap_popen(const char *command, const char *mode)
-{
-  return dll_popen(command, mode);
-}
-
-void* __wrap_calloc( size_t num, size_t size )
-{
-  return dllcalloc(num, size);
-}
-
-void* __wrap_malloc(size_t size)
-{
-  return dllmalloc(size);
-}
-
-void* __wrap_realloc( void *memblock, size_t size )
-{
-  return dllrealloc(memblock, size);
-}
-
-void __wrap_free( void* pPtr )
-{
-  dllfree(pPtr);
-}
-
-int __wrap_open(const char *file, int oflag, ...)
-{
-  return dll_open(file, oflag);
-}
-
-int __wrap_open64(const char *file, int oflag, ...)
-{
-  return dll_open(file, oflag);
-}
-
-int __wrap_close(int fd)
-{
-   return dll_close(fd);
-}
-
-ssize_t __wrap_write(int fd, const void *buf, size_t count)
-{
-  return dll_write(fd, buf, count);
-}
-
-ssize_t __wrap_read(int fd, void *buf, size_t count)
-{
-  return dll_read(fd, buf, count);
-}
-
-__off_t __wrap_lseek(int fildes, __off_t offset, int whence)
-{
-  return dll_lseek(fildes, offset, whence);
-}
-
-__off64_t __wrap_lseek64(int fildes, __off64_t offset, int whence)
-{
-  __off64_t seekRes = dll_lseeki64(fildes, offset, whence);
-  return seekRes;
-}
-
-int __wrap_fclose(FILE *fp)
-{
-  return dll_fclose(fp);
-}
-
-int __wrap_ferror(FILE *stream)
-{
-  return dll_ferror(stream);
-}
-
-void __wrap_clearerr(FILE *stream)
-{
-  return dll_clearerr(stream);
-}
-
-int __wrap_feof(FILE *stream)
-{
-  return dll_feof(stream);
-}
-
-int __wrap_fileno(FILE *stream)
-{
-  return dll_fileno(stream);
-}
-
-FILE *__wrap_fopen(const char *path, const char *mode)
-{
-  return dll_fopen(path, mode);
-}
-
-FILE *__wrap_fopen64(const char *path, const char *mode)
-{
-  return dll_fopen(path, mode);
-}
-
-FILE *__wrap_fdopen(int fildes, const char *mode)
-{
-  return dll_fdopen(fildes, mode);
-}
-
-FILE *__wrap_freopen(const char *path, const char *mode, FILE *stream)
-{
-  return dll_freopen(path, mode, stream);
-}
-
-size_t __wrap_fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
-{
-  return dll_fread(ptr, size, nmemb, stream);
-}
-
-size_t __wrap_fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
-{
-  return dll_fwrite(ptr, size, nmemb, stream);
-}
-
-int __wrap_fflush(FILE *stream)
-{
-  return dll_fflush(stream);
-}
-
-int __wrap_fputc(int c, FILE *stream)
-{
-  return dll_fputc(c, stream);
-}
-
-int __wrap_fputs(const char *s, FILE *stream)
-{
-  return dll_fputs(s, stream);
-}
-
-int __wrap__IO_putc(int c, FILE *stream)
-{
-  return dll_putc(c, stream);
-}
-
-int __wrap_fseek(FILE *stream, long offset, int whence)
-{
-  return dll_fseek(stream, offset, whence);
-}
-
-int __wrap_fseeko64(FILE *stream, off64_t offset, int whence)
-{
-  return dll_fseek64(stream, offset, whence);
-}
-
-long __wrap_ftell(FILE *stream)
-{
-  return dll_ftell(stream);
-}
-
-off64_t __wrap_ftello64(FILE *stream)
-{
-  return dll_ftell64(stream);
-}
-
-void __wrap_rewind(FILE *stream)
-{
-  dll_rewind(stream);
-}
-
-int __wrap_fgetpos(FILE *stream, fpos_t *pos)
-{
-  return dll_fgetpos(stream, pos);
-}
-
-int __wrap_fgetpos64(FILE *stream, fpos64_t *pos)
-{
-  return dll_fgetpos64(stream, pos);
-}
-
-int __wrap_fsetpos(FILE *stream, fpos_t *pos)
-{
-  return dll_fsetpos(stream, pos);
-}
-
-int __wrap_fsetpos64(FILE *stream, fpos64_t *pos)
-{
-  return dll_fsetpos64(stream, pos);
-}
-
-DIR * __wrap_opendir(const char *name)
-{
-  return dll_opendir(name);
-}
-
-struct dirent * __wrap_readdir(DIR* dirp)
-{
-  return dll_readdir(dirp);
-}
-
-struct dirent * __wrap_readdir64(DIR* dirp)
-{
-  return dll_readdir(dirp);
-}
-
-int __wrap_closedir(DIR* dirp)
-{
-  return dll_closedir(dirp);
-}
-
-void __wrap_rewinddir(DIR* dirp)
-{
-  dll_rewinddir(dirp);
-}
-
-int __wrap_fprintf(FILE *stream, const char *format, ...)
-{
-    int res;
-    va_list va;
-    va_start(va, format);
-    res = dll_vfprintf(stream, format, va);
-    va_end(va);
-    return res;
-}
-
-int __wrap_vfprintf(FILE *stream, const char *format, va_list ap)
-{
-  return dll_vfprintf(stream, format, ap);
-}
-
-int __wrap_printf(const char *format, ...)
-{
-    int res;
-    va_list va;
-    va_start(va, format);
-    res = dll_vfprintf(stdout, format, va);
-    va_end(va);
-    return res;
-}
-
-int __wrap_fgetc(FILE *stream)
-{
-  return dll_fgetc(stream);
-}
-
-char *__wrap_fgets(char *s, int size, FILE *stream)
-{
-  return dll_fgets(s, size, stream);
-}
-
-int __wrap__IO_getc(FILE *stream)
-{
-  return dll_getc(stream);
-}
-
-int __wrap__IO_getc_unlocked(FILE *stream)
-{
-  return dll_getc(stream);
-}
-
-int __wrap_getc_unlocked(FILE *stream)
-{
-  return dll_getc(stream);
-}
-
-int __wrap_ungetc(int c, FILE *stream)
-{
-  return dll_ungetc(c, stream);
-}
-
-int __wrap_getc(FILE *stream)
-{
-  return dll_getc(stream);
-}
-
-int __wrap_ioctl(int d, unsigned long int request, ...)
-{
-    int res;
-    va_list va;
-    va_start(va, request);
-    res = dll_ioctl(d, request, va);
-    va_end(va);
-    return res;
-} 
-
-int __wrap__stat(const char *path, struct _stat *buffer)
-{
-  return dll_stat(path, buffer);
-}
-
-int __wrap_stat(const char *path, struct _stat *buffer)
-{
-  return dll_stat(path, buffer);
-}
-
-int __wrap___xstat64(int __ver, const char *__filename, struct stat64 *__stat_buf)
-{
-  return dll_stat64(__filename, __stat_buf);
-}
-
-int __wrap___lxstat64(int __ver, const char *__filename, struct stat64 *__stat_buf)
-{
-  return dll_stat64(__filename, __stat_buf);
-}
-
-void __wrap_flockfile(FILE *file)
-{
-    dll_flockfile(file);
-}
-
-int __wrap_ftrylockfile(FILE *file)
-{
-    return dll_ftrylockfile(file);
-}
-
-void __wrap_funlockfile(FILE *file)
-{
-    dll_funlockfile(file);
-}
-
-int __wrap___fxstat64(int ver, int fd, struct stat64 *buf)
-{
-  return dll_fstat64(fd, buf);
-}
-
-int __wrap_fstat(int fd, struct _stat *buf)
-{
-  return dll_fstat(fd, buf);
-}
-
-int __wrap_setvbuf(FILE *stream, char *buf, int type, size_t size)
-{
-   return dll_setvbuf(stream, buf, type, size);
-}
-
-struct mntent *__wrap_getmntent(FILE *fp)
-{
-#ifdef TARGET_POSIX
-  return dll_getmntent(fp);
-#endif
-  return NULL;
-}
-
-// GCC 4.3 in Ubuntu 8.10 defines _FORTIFY_SOURCE=2 which means, that fread, read etc 
-// are actually #defines which are inlined when compiled with -O. Those defines
-// actally call __*chk (for example, __fread_chk). We need to bypass this whole
-// thing to actually call our wrapped functions. 
-#if _FORTIFY_SOURCE > 1
-
-size_t __wrap___fread_chk(void * ptr, size_t ptrlen, size_t size, size_t n, FILE * stream)
-{
-  return dll_fread(ptr, size, n, stream);
-}
-
-int __wrap___printf_chk(int flag, const char *format, ...)
-{
-  int res;
-  va_list va;
-  va_start(va, format);
-  res = dll_vfprintf(stdout, format, va);
-  va_end(va);
-  return res;
-}
-
-int __wrap___vfprintf_chk(FILE* stream, int flag, const char *format, _G_va_list ap)
-{
-  return dll_vfprintf(stream, format, ap);
-}
-
-int __wrap___fprintf_chk(FILE * stream, int flag, const char *format, ...)
-{
-  int res;
-  va_list va;
-  va_start(va, format);
-  res = dll_vfprintf(stream, format, va);
-  va_end(va);
-  return res;
-}
-
-char *__wrap___fgets_chk(char *s, size_t size, int n, FILE *stream)
-{
-  return dll_fgets(s, n, stream);
-}
-
-size_t __wrap___read_chk(int fd, void *buf, size_t nbytes, size_t buflen)
-{
-  return dll_read(fd, buf, nbytes);
-}
-
-#endif
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2013-11-18 01:12:17.624950376 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	2013-11-18 01:14:00.620953047 +0800
@@ -168,6 +168,7 @@
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -359,6 +360,14 @@
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -560,6 +569,7 @@
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
   m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
 
@@ -669,6 +679,22 @@
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -928,3 +954,19 @@
   else
     return 0;
 }
+
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+{
+  pts = m_decoderPts;
+  skippedDeint = m_skippedDeint;
+  if (m_pFrame)
+    interlaced = m_pFrame->interlaced_frame;
+  else
+    interlaced = 0;
+  return true;
+}
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	2013-11-18 01:14:00.620953047 +0800
@@ -45,6 +45,7 @@
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
   };
@@ -62,6 +63,8 @@
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced);
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -127,4 +130,8 @@
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
 };
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2013-11-18 01:12:17.624950376 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2013-11-18 01:14:00.620953047 +0800
@@ -123,6 +123,10 @@
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100
+#define DVP_FLAG_DRAIN              0x00000200
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -140,6 +144,8 @@
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+
 class CDVDVideoCodec
 {
 public:
@@ -257,10 +263,42 @@
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
    */
   virtual unsigned GetAllowedReferences() { return 0; }
+
+  /**
+   * For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - skippedDeint : indicates if decoder has just skipped a deinterlacing cycle
+   *   instead of dropping a full frame
+   * - interlaced : when detecting gaps in pts, player needs to know whether
+   *   it's interlaced or not
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case coded does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+  {
+    return false;
+  }
+
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
+  virtual void SetCodecControl(int flags) {}
 };
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2013-11-18 01:12:17.628950377 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2013-11-18 01:14:00.764953051 +0800
@@ -1084,8 +1084,7 @@
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    //TODO
-    // m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
   }
 
   int retval = 0;
@@ -1682,11 +1681,6 @@
                                 &m_videoMixer);
   CheckStatus(vdp_st, __LINE__);
 
-  // create 3 pitches of black lines needed for clipping top
-  // and bottom lines when de-interlacing
-  m_BlackBar = new uint32_t[3*m_config.outWidth];
-  memset(m_BlackBar, 0, 3*m_config.outWidth*sizeof(uint32_t));
-
 }
 
 void CMixer::InitCSCMatrix(int Width)
@@ -1959,10 +1953,10 @@
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
@@ -2223,6 +2217,8 @@
   m_Sharpness = 0.0;
   m_DeintMode = 0;
   m_Deint = 0;
+  m_Upscale = 0;
+  m_SeenInterlaceFlag = false;
   m_ColorMatrix = 0;
   m_PostProc = false;
   m_vdpError = false;
@@ -2241,8 +2237,6 @@
     m_outputSurfaces.pop();
   }
   m_config.context->GetProcs().vdp_video_mixer_destroy(m_videoMixer);
-
-  delete [] m_BlackBar;
 }
 
 void CMixer::Flush()
@@ -2283,8 +2277,7 @@
   int flags;
   uint64_t latency;
   m_config.stats->GetParams(latency, flags);
-  // TODO
-  if (0) //flags & DVP_FLAG_NO_POSTPROC)
+  if (flags & DVP_FLAG_NO_POSTPROC)
     SetPostProcFeatures(false);
   else
     SetPostProcFeatures(true);
@@ -2294,9 +2287,9 @@
   EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
   EINTERLACEMETHOD method = GetDeinterlacingMethod();
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
+  m_SeenInterlaceFlag |= interlaced;
 
-  // TODO
-  if (//!(flags & DVP_FLAG_NO_POSTPROC) &&
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
       (mode == VS_DEINTERLACEMODE_FORCE ||
       (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
@@ -2318,8 +2311,7 @@
         m_config.stats->SetCanSkipDeint(true);
       }
 
-      // TODO
-      if (0) //m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
       {
         m_mixersteps = 1;
       }
@@ -2377,6 +2369,11 @@
     m_processPicture.outputSurface = m_outputSurfaces.front();
     m_mixerInput[1].DVDPic.iWidth = m_config.outWidth;
     m_mixerInput[1].DVDPic.iHeight = m_config.outHeight;
+    if (m_SeenInterlaceFlag)
+    {
+      m_mixerInput[1].DVDPic.iHeight -= 6;
+      m_mixerInput[1].DVDPic.iDisplayHeight -= 6;
+    }
   }
   else
   {
@@ -2511,32 +2508,6 @@
                                 0,
                                 NULL);
   CheckStatus(vdp_st, __LINE__);
-
-  if (m_mixerfield != VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
-  {
-    // in order to clip top and bottom lines when de-interlacing
-    // we black those lines as a work around for not working
-    // background colour using the mixer
-    // pixel perfect is preferred over overscanning or zooming
-
-    VdpRect clipRect = destRect;
-    clipRect.y1 = clipRect.y0 + 2;
-    uint32_t *data[] = {m_BlackBar};
-    uint32_t pitches[] = {destRect.x1};
-    vdp_st = m_config.context->GetProcs().vdp_output_surface_put_bits_native(m_processPicture.outputSurface,
-                                            (void**)data,
-                                            pitches,
-                                            &clipRect);
-    CheckStatus(vdp_st, __LINE__);
-
-    clipRect = destRect;
-    clipRect.y0 = clipRect.y1 - 2;
-    vdp_st = m_config.context->GetProcs().vdp_output_surface_put_bits_native(m_processPicture.outputSurface,
-                                            (void**)data,
-                                            pitches,
-                                            &clipRect);
-    CheckStatus(vdp_st, __LINE__);
-  }
 }
 
 
@@ -3067,7 +3038,12 @@
       GLMapSurfaces();
       retPic->sourceIdx = procPic.outputSurface;
       retPic->texture[0] = m_bufferPool.glOutputSurfaceMap[procPic.outputSurface].texture[0];
-      retPic->crop = CRect(0,0,0,0);
+      retPic->texWidth = m_config.outWidth;
+      retPic->texHeight = m_config.outHeight;
+      retPic->crop.x1 = 0;
+      retPic->crop.y1 = (m_config.outHeight - retPic->DVDPic.iHeight) / 2;
+      retPic->crop.x2 = m_config.outWidth;
+      retPic->crop.y2 = m_config.outHeight - retPic->crop.y1;
     }
     else
     {
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2013-11-18 01:14:00.764953051 +0800
@@ -330,8 +330,8 @@
   int m_DeintMode;
   int m_Deint;
   int m_Upscale;
+  bool m_SeenInterlaceFlag;
   unsigned int m_ColorMatrix       : 4;
-  uint32_t *m_BlackBar;
   VdpVideoMixerPictureStructure m_mixerfield;
   int m_mixerstep;
   int m_mixersteps;
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2013-11-18 01:12:17.632950378 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2013-11-18 01:14:00.652953048 +0800
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -489,6 +489,9 @@
 
   CreateStreams();
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -634,6 +637,12 @@
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -773,6 +782,24 @@
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -902,10 +929,20 @@
   int ret;
   {
     CSingleLock lock(m_critSection);
+
     ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -924,6 +961,165 @@
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = m_dllAvUtil.av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = m_dllAvUtil.av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h	2013-11-18 01:14:00.652953048 +0800
@@ -100,6 +100,7 @@
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -158,5 +159,8 @@
     AVPacket pkt;       // packet ffmpeg returned
     int      result;    // result from av_read_packet
   }m_pkt;
+
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp	2013-11-18 01:14:00.664953049 +0800
@@ -339,9 +339,7 @@
       if (stm)
       {
         st = dynamic_cast<CDemuxStreamAudioPVRClient*>(stm);
-        if (!st
-            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
-            || (st->iChannels != props.stream[i].iChannels))
+        if (!st || (st->codec != (AVCodecID)props.stream[i].iCodecId))
           DisposeStream(i);
       }
       if (!m_streams[i])
@@ -358,6 +356,7 @@
       st->iBitsPerSample  = props.stream[i].iBitsPerSample;
       m_streams[i] = st;
       st->m_parser_split = true;
+      st->changes++;
     }
     else if (props.stream[i].iCodecType == XBMC_CODEC_TYPE_VIDEO)
     {
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDMessage.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDMessage.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDMessage.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDMessage.h	2013-11-18 01:14:00.656953048 +0800
@@ -220,7 +220,7 @@
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -228,6 +228,7 @@
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -235,6 +236,7 @@
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -242,6 +244,7 @@
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayer.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayer.cpp	2013-11-18 01:12:17.632950378 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayer.cpp	2013-11-18 01:14:00.656953048 +0800
@@ -1658,12 +1658,14 @@
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo.GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1682,7 +1684,7 @@
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2168,7 +2170,7 @@
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2308,9 +2310,10 @@
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2323,6 +2326,13 @@
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet
@@ -3311,7 +3321,7 @@
   return true;
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate)
@@ -3323,19 +3333,23 @@
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3379,7 +3393,7 @@
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayer.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayer.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayer.h	2013-11-18 01:12:17.632950378 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayer.h	2013-11-18 01:14:00.660953049 +0800
@@ -317,7 +317,7 @@
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -366,8 +366,9 @@
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2013-11-18 01:12:17.636950378 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2013-11-18 01:14:00.660953049 +0800
@@ -38,6 +38,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
@@ -319,8 +320,10 @@
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -430,6 +433,7 @@
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -442,6 +446,7 @@
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -459,8 +464,10 @@
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -506,6 +513,28 @@
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -558,15 +587,7 @@
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
       // reset the request, the following while loop may break before
       // setting the flag to a new value
       bRequestDrop = false;
@@ -686,6 +707,8 @@
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();
@@ -1036,7 +1059,7 @@
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 )
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
@@ -1092,7 +1115,7 @@
     m_output.height          = pPicture->iHeight;
     m_output.dwidth          = pPicture->iDisplayWidth;
     m_output.dheight         = pPicture->iDisplayHeight;
-    m_output.framerate       = config_framerate;
+    m_output.framerate       = config_framerate == 0.0 ? g_graphicsContext.GetFPS() : config_framerate;
     m_output.color_format    = pPicture->format;
     m_output.extended_format = pPicture->extended_format;
     m_output.color_matrix    = pPicture->color_matrix;
@@ -1177,33 +1200,12 @@
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimeStamp += iFrameDuration;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
-  {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1236,7 +1238,7 @@
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1456,6 +1458,22 @@
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
@@ -1480,7 +1498,7 @@
   double frameduration = m_pullupCorrection.GetFrameDuration();
 
   if (frameduration == DVD_NOPTS_VALUE ||
-      (g_advancedSettings.m_videoFpsDetect == 1 && m_pullupCorrection.GetPatternLength() > 1))
+      (g_advancedSettings.m_videoFpsDetect == 1 && (m_pullupCorrection.GetPatternLength() > 1 && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;
@@ -1536,3 +1554,138 @@
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  int    interlaced;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iSkippedDeint = 0;
+  int    iBufferLevel;
+
+  m_droppingStats.m_lastPts = pts;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  if (interlaced)
+    iInterval = 2/m_fFrameRate*(double)DVD_TIME_BASE;
+  else
+    iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+
+  m_FlipTimeStamp = m_pClock->GetAbsoluteClock() + max(0.0, iSleepTime) + iInterval;
+
+  if( m_stalled )
+    m_iCurrentPts = DVD_NOPTS_VALUE;
+  else
+    m_iCurrentPts = iRenderPts - max(0.0, iSleepTime);
+
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop
+      && m_droppingStats.m_dropRequests > 0)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iSkippedDeint)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped de-interlacing cycle, Sleeptime: %f, Bufferlevel: %d", iSleepTime, iBufferLevel);
+    }
+    else if (iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        result |= EOS_VERYLATE;
+        if (bNewFrame)
+          m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.h xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayerVideo.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/dvdplayer/DVDPlayerVideo.h	2013-11-18 01:14:00.660953049 +0800
@@ -36,6 +36,26 @@
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  double m_lastPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
+
 class CDVDPlayerVideo : public CThread
 {
 public:
@@ -81,7 +101,7 @@
 
   bool InitializedOutputDevice();
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
   int    GetPullupCorrection()                     { return m_pullupCorrection.GetPatternLength(); }
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
@@ -104,6 +124,7 @@
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -129,6 +150,7 @@
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -182,5 +204,7 @@
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/omxplayer/OMXPlayer.cpp xbmc-13.0-r9b3ff66/xbmc/cores/omxplayer/OMXPlayer.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/omxplayer/OMXPlayer.cpp	2013-11-18 01:12:17.636950378 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/omxplayer/OMXPlayer.cpp	2013-11-18 01:14:00.668953048 +0800
@@ -2565,7 +2565,8 @@
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), (speed < 0), true, false, false, true));
 
         m_playSpeed = speed;
-        m_caching = CACHESTATE_DONE;
+        if (m_caching != CACHESTATE_PVR && m_playSpeed != DVD_PLAYSPEED_NORMAL)
+          m_caching = CACHESTATE_DONE;
         m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
         m_av_clock.OMXPause();
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/BaseRenderer.h xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/BaseRenderer.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/BaseRenderer.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/BaseRenderer.h	2013-11-18 01:14:00.620953047 +0800
@@ -29,7 +29,7 @@
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 class CSetting;
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2013-11-18 01:12:17.616950377 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	2013-11-18 01:14:00.760953052 +0800
@@ -1611,7 +1611,6 @@
 
   // make sure we know the correct texture size
   GetPlaneTextureSize(plane);
-  CalculateTextureSourceRects(index, 1);
 
   // Try some clamping or wrapping
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
@@ -1658,10 +1657,10 @@
   }
   else
   {
-    glTexCoord2f(m_rotatedDestCoords[0].x, m_rotatedDestCoords[0].y); glVertex4f(m_rotatedDestCoords[0].x, m_rotatedDestCoords[0].y, 0.0f, 0.0f);
-    glTexCoord2f(m_rotatedDestCoords[1].x, m_rotatedDestCoords[1].y); glVertex4f(m_rotatedDestCoords[1].x, m_rotatedDestCoords[1].y, 1.0f, 0.0f);
-    glTexCoord2f(m_rotatedDestCoords[2].x, m_rotatedDestCoords[2].y); glVertex4f(m_rotatedDestCoords[2].x, m_rotatedDestCoords[2].y, 1.0f, 1.0f);
-    glTexCoord2f(m_rotatedDestCoords[3].x, m_rotatedDestCoords[3].y); glVertex4f(m_rotatedDestCoords[3].x, m_rotatedDestCoords[3].y, 0.0f, 1.0f);
+    glTexCoord2f(plane.rect.x1, plane.rect.y1); glVertex4f(m_rotatedDestCoords[0].x, m_rotatedDestCoords[0].y, 0.0f, 0.0f);
+    glTexCoord2f(plane.rect.x2, plane.rect.y1); glVertex4f(m_rotatedDestCoords[1].x, m_rotatedDestCoords[1].y, 1.0f, 0.0f);
+    glTexCoord2f(plane.rect.x2, plane.rect.y2); glVertex4f(m_rotatedDestCoords[2].x, m_rotatedDestCoords[2].y, 1.0f, 1.0f);
+    glTexCoord2f(plane.rect.x1, plane.rect.y2); glVertex4f(m_rotatedDestCoords[3].x, m_rotatedDestCoords[3].y, 0.0f, 1.0f);
   }
   glEnd();
   VerifyGLState();
@@ -2399,23 +2398,27 @@
 
   plane.id = vdpau->texture[0];
 
+  // in stereoscopic mode sourceRect may only
+  // be a part of the source video surface
   plane.rect = m_sourceRect;
-  plane.width  = im.width;
-  plane.height = im.height;
 
-  plane.height  /= plane.pixpertex_y;
-  plane.rect.y1 /= plane.pixpertex_y;
-  plane.rect.y2 /= plane.pixpertex_y;
-  plane.width   /= plane.pixpertex_x;
-  plane.rect.x1 /= plane.pixpertex_x;
-  plane.rect.x2 /= plane.pixpertex_x;
+  // clip rect
+  if (vdpau->crop.x1 > plane.rect.x1)
+    plane.rect.x1 = vdpau->crop.x1;
+  if (vdpau->crop.x2 < plane.rect.x2)
+    plane.rect.x2 = vdpau->crop.x2;
+  if (vdpau->crop.y1 > plane.rect.y1)
+    plane.rect.y1 = vdpau->crop.y1;
+  if (vdpau->crop.y2 < plane.rect.y2)
+    plane.rect.y2 = vdpau->crop.y2;
+
+  plane.texheight = vdpau->texHeight;
+  plane.texwidth  = vdpau->texWidth;
 
   if (m_textureTarget == GL_TEXTURE_2D)
   {
-    plane.height  /= plane.texheight;
     plane.rect.y1 /= plane.texheight;
     plane.rect.y2 /= plane.texheight;
-    plane.width   /= plane.texwidth;
     plane.rect.x1 /= plane.texwidth;
     plane.rect.x2 /= plane.texwidth;
   }
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/RenderManager.cpp	2013-11-18 01:12:17.620950376 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/RenderManager.cpp	2013-11-18 01:14:00.716953050 +0800
@@ -284,6 +284,8 @@
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -376,6 +378,8 @@
   if(g_graphicsContext.IsFullScreenVideo())
     WaitPresentTime(m.timestamp);
 
+  m_clock_framefinish = GetPresentTime();
+
   { CSingleLock lock(m_presentlock);
 
     if(m_presentstep == PRESENT_FRAME)
@@ -627,7 +631,7 @@
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -695,6 +699,7 @@
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -1027,6 +1032,12 @@
 
   double clocktime = GetPresentTime();
   double frametime = 1.0 / GetMaximumFPS();
+  double correction = 0.0;
+  int fps = g_VideoReferenceClock.GetRefreshRate();
+  if((fps > 0) && g_graphicsContext.IsFullScreenVideo() && (clocktime != m_clock_framefinish))
+  {
+    correction = frametime;
+  }
 
   /* see if any future queued frames are already due */
   std::deque<int>::reverse_iterator curr, prev;
@@ -1035,8 +1046,8 @@
   ++prev;
   while (prev != m_queued.rend())
   {
-    if(clocktime > m_Queue[*prev].timestamp                 /* previous frame is late */
-    && clocktime > m_Queue[*curr].timestamp - frametime)    /* selected frame is close to it's display time */
+    if(clocktime > m_Queue[*prev].timestamp + correction                 /* previous frame is late */
+    && clocktime > m_Queue[*curr].timestamp - frametime + correction)    /* selected frame is close to it's display time */
       break;
     ++curr;
     ++prev;
@@ -1063,6 +1074,8 @@
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1079,3 +1092,12 @@
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/RenderManager.h xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/RenderManager.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/cores/VideoRenderers/RenderManager.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/cores/VideoRenderers/RenderManager.h	2013-11-18 01:14:00.716953050 +0800
@@ -98,10 +98,11 @@
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -176,6 +177,12 @@
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -222,6 +229,7 @@
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -233,6 +241,8 @@
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
@@ -242,6 +252,7 @@
   XbmcThreads::ConditionVariable  m_presentevent;
   CCriticalSection m_presentlock;
   CEvent     m_flushEvent;
+  double     m_clock_framefinish;
 
 
   OVERLAY::CRenderer m_overlays;
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/input/XBMC_keytable.cpp xbmc-13.0-r9b3ff66/xbmc/input/XBMC_keytable.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/input/XBMC_keytable.cpp	2013-11-18 01:12:17.676950379 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/input/XBMC_keytable.cpp	2013-11-18 01:14:00.748953051 +0800
@@ -180,6 +180,12 @@
 , { XBMCK_LAUNCH_APP2,            0,    0, XBMCVK_LAUNCH_APP2,         "launch_app2_pc_icon" }
 , { XBMCK_LAUNCH_FILE_BROWSER,    0,    0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser" }
 , { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
+, { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
+, { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
+, { XBMCK_REWIND,                 0,    0, XBMCVK_MEDIA_REWIND,        "rewind" }
+, { XBMCK_FASTFORWARD,            0,    0, XBMCVK_MEDIA_FASTFORWARD,   "fastforward" }
+, { XBMCK_RECORD,                 0,    0, XBMCVK_MEDIA_RECORD,        "record" }
+
 
 // Function keys
 , { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/input/XBMC_vkeys.h xbmc-13.0-r9b3ff66/xbmc/input/XBMC_vkeys.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/input/XBMC_vkeys.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/input/XBMC_vkeys.h	2013-11-18 01:14:00.748953051 +0800
@@ -188,6 +188,9 @@
   XBMCVK_LAUNCH_APP2         = 0xC1,
   XBMCVK_LAUNCH_FILE_BROWSER = 0xC2,
   XBMCVK_LAUNCH_MEDIA_CENTER = 0xC3,
+  XBMCVK_MEDIA_RECORD        = 0xC4,
+  XBMCVK_MEDIA_REWIND        = 0xC5,
+  XBMCVK_MEDIA_FASTFORWARD   = 0xC6,
 
   XBMCVK_LCONTROL       = 0xD0,
   XBMCVK_RCONTROL       = 0xD1,
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/powermanagement/PowerManager.cpp xbmc-13.0-r9b3ff66/xbmc/powermanagement/PowerManager.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/powermanagement/PowerManager.cpp	2013-11-18 01:12:17.712950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/powermanagement/PowerManager.cpp	2013-11-18 01:14:00.664953049 +0800
@@ -268,11 +268,6 @@
 #if defined(TARGET_WINDOWS)
     ShowWindow(g_hWnd,SW_RESTORE);
     SetForegroundWindow(g_hWnd);
-#elif !defined(TARGET_DARWIN_OSX)
-    // Hack to reclaim focus, thus rehiding system mouse pointer.
-    // Surely there's a better way?
-    g_graphicsContext.ToggleFullScreenRoot();
-    g_graphicsContext.ToggleFullScreenRoot();
 #endif
   }
   g_application.ResetScreenSaver();
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/pvr/addons/PVRClients.cpp xbmc-13.0-r9b3ff66/xbmc/pvr/addons/PVRClients.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/pvr/addons/PVRClients.cpp	2013-11-18 01:12:17.716950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/pvr/addons/PVRClients.cpp	2013-11-18 01:14:00.668953048 +0800
@@ -729,6 +729,7 @@
   {
     hooks = client->GetMenuHooks();
     std::vector<int> hookIDs;
+    int selection = 0;
 
     CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
     pDialog->Reset();
@@ -739,9 +740,11 @@
         pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
         hookIDs.push_back(i);
       }
-    pDialog->DoModal();
-
-    int selection = pDialog->GetSelectedLabel();
+    if (hookIDs.size() > 1)
+    {
+      pDialog->DoModal();
+      selection = pDialog->GetSelectedLabel();
+    }
     if (selection >= 0)
       client->CallMenuHook(hooks->at(hookIDs.at(selection)), item);
   }
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/rendering/gl/RenderSystemGL.h xbmc-13.0-r9b3ff66/xbmc/rendering/gl/RenderSystemGL.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/rendering/gl/RenderSystemGL.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/rendering/gl/RenderSystemGL.h	2013-11-18 01:14:00.632953047 +0800
@@ -44,6 +44,7 @@
   virtual bool IsExtSupported(const char* extension);
 
   virtual void SetVSync(bool vsync);
+  virtual void ResetVSync() { m_bVsyncInit = false; }
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/settings/AdvancedSettings.cpp xbmc-13.0-r9b3ff66/xbmc/settings/AdvancedSettings.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/settings/AdvancedSettings.cpp	2013-11-18 01:12:17.720950379 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/settings/AdvancedSettings.cpp	2013-11-18 01:14:00.656953048 +0800
@@ -165,6 +165,8 @@
   m_videoAllowMpeg4VAAPI = false;  
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -603,6 +605,8 @@
     XMLUtils::GetBoolean(pElement,"allowmpeg4vaapi",m_videoAllowMpeg4VAAPI);    
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/settings/AdvancedSettings.h xbmc-13.0-r9b3ff66/xbmc/settings/AdvancedSettings.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/settings/AdvancedSettings.h	2013-11-18 01:12:17.720950379 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/settings/AdvancedSettings.h	2013-11-18 01:14:00.656953048 +0800
@@ -160,6 +160,8 @@
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/settings/DisplaySettings.cpp xbmc-13.0-r9b3ff66/xbmc/settings/DisplaySettings.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/settings/DisplaySettings.cpp	2013-11-18 01:12:17.720950379 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/settings/DisplaySettings.cpp	2013-11-18 01:14:00.752953052 +0800
@@ -255,6 +255,32 @@
         m_resolutionChangeAborted = false;
     }
   }
+  else if (settingId == "videoscreen.monitor")
+  {
+    g_Windowing.UpdateResolutions();
+    RESOLUTION newRes = GetResolutionForScreen();
+
+    SetCurrentResolution(newRes, false);
+    g_graphicsContext.SetVideoResolution(newRes, true);
+
+    if (!m_resolutionChangeAborted)
+    {
+      bool cancelled = false;
+      if (!CGUIDialogYesNo::ShowAndGetInput(13110, 13111, 20022, 20022, -1, -1, cancelled, 10000))
+      {
+        m_resolutionChangeAborted = true;
+        return false;
+      }
+    }
+    else
+      m_resolutionChangeAborted = false;
+
+    return true;
+  }
+  else if (settingId == "videoscreen.monitorsingle")
+  {
+    g_Windowing.UpdateResolutions();
+  }
 
   return true;
 }
@@ -622,6 +648,10 @@
   if (g_advancedSettings.m_canWindowed)
     list.push_back(make_pair(g_localizeStrings.Get(242), DM_WINDOWED));
 
+#if defined(HAS_GLX)
+  list.push_back(make_pair(g_localizeStrings.Get(244), 0));
+#else
+
   for (int idx = 0; idx < g_Windowing.GetNumScreens(); idx++)
   {
     int screen = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP + idx).iScreen;
@@ -636,6 +666,7 @@
     RESOLUTION_INFO resInfo = CDisplaySettings::Get().GetResolutionInfo(res);
     current = resInfo.iScreen;
   }
+#endif
 }
 
 void CDisplaySettings::SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
@@ -663,3 +694,30 @@
   SettingOptionsStereoscopicModesFiller(setting, list, current);
   list.push_back(make_pair(g_localizeStrings.Get(36525), RENDER_STEREO_MODE_AUTO)); // option for autodetect
 }
+
+void CDisplaySettings::SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current)
+{
+#if defined(HAS_GLX)
+  std::vector<CStdString> monitors;
+  g_Windowing.GetConnectedOutputs(&monitors);
+  std::string currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+  for (unsigned int i=0; i<monitors.size(); ++i)
+  {
+    if(currentMonitor.compare("Default") != 0 &&
+       CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
+    {
+      current = monitors[i];
+    }
+    list.push_back(make_pair(monitors[i], monitors[i]));
+  }
+#endif
+}
+
+void CDisplaySettings::ClearCustomResolutions()
+{
+  if (m_resolutions.size() > RES_CUSTOM)
+  {
+    std::vector<RESOLUTION_INFO>::iterator firstCustom = m_resolutions.begin()+RES_CUSTOM;
+    m_resolutions.erase(firstCustom, m_resolutions.end());
+  }
+}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/settings/DisplaySettings.h xbmc-13.0-r9b3ff66/xbmc/settings/DisplaySettings.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/settings/DisplaySettings.h	2013-11-18 01:12:17.724950379 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/settings/DisplaySettings.h	2013-11-18 01:14:00.636953047 +0800
@@ -78,6 +78,7 @@
 
   void ApplyCalibrations();
   void UpdateCalibrations();
+  void ClearCustomResolutions();
 
   float GetZoomAmount() const { return m_zoomAmount; }
   void SetZoomAmount(float zoomAmount) { m_zoomAmount = zoomAmount; }
@@ -95,6 +96,7 @@
   static void SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsStereoscopicModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsPreferredStereoscopicViewModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static void SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
 
 protected:
   CDisplaySettings();
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/settings/Settings.cpp xbmc-13.0-r9b3ff66/xbmc/settings/Settings.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/settings/Settings.cpp	2013-11-18 01:12:17.728950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/settings/Settings.cpp	2013-11-18 01:14:00.636953047 +0800
@@ -406,6 +406,7 @@
   m_settingsManager->UnregisterSettingOptionsFiller("screens");
   m_settingsManager->UnregisterSettingOptionsFiller("stereoscopicmodes");
   m_settingsManager->UnregisterSettingOptionsFiller("preferedstereoscopicviewmodes");
+  m_settingsManager->UnregisterSettingOptionsFiller("monitors");
   m_settingsManager->UnregisterSettingOptionsFiller("shutdownstates");
   m_settingsManager->UnregisterSettingOptionsFiller("startupwindows");
   m_settingsManager->UnregisterSettingOptionsFiller("streamlanguages");
@@ -839,6 +840,7 @@
   m_settingsManager->RegisterSettingOptionsFiller("screens", CDisplaySettings::SettingOptionsScreensFiller);
   m_settingsManager->RegisterSettingOptionsFiller("stereoscopicmodes", CDisplaySettings::SettingOptionsStereoscopicModesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("preferedstereoscopicviewmodes", CDisplaySettings::SettingOptionsPreferredStereoscopicViewModesFiller);
+  m_settingsManager->RegisterSettingOptionsFiller("monitors", CDisplaySettings::SettingOptionsMonitorsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("shutdownstates", CPowerManager::SettingOptionsShutdownStatesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("startupwindows", ADDON::CSkinInfo::SettingOptionsStartupWindowsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("streamlanguages", CLangInfo::SettingOptionsStreamLanguagesFiller);
@@ -869,6 +871,9 @@
 #ifdef HAS_GL
   m_settingsManager->AddCondition("has_gl");
 #endif
+#ifdef HAS_GLX
+  m_settingsManager->AddCondition("has_glx");
+#endif
 #ifdef HAS_GLES
   m_settingsManager->AddCondition("has_gles");
 #endif
@@ -1018,6 +1023,7 @@
   settingSet.insert("videoscreen.screen");
   settingSet.insert("videoscreen.resolution");
   settingSet.insert("videoscreen.screenmode");
+  settingSet.insert("videoscreen.monitor");
   m_settingsManager->RegisterCallback(&CDisplaySettings::Get(), settingSet);
 
   settingSet.clear();
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/system.h xbmc-13.0-r9b3ff66/xbmc/system.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/system.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/system.h	2013-11-18 01:14:00.624953048 +0800
@@ -171,16 +171,21 @@
 #define HAS_GL
 #ifdef HAVE_X11
 #define HAS_GLX
+#define HAS_X11_WIN_EVENTS
 #endif
 #ifdef HAVE_SDL
 #define HAS_SDL
 #ifndef HAS_SDL_OPENGL
 #define HAS_SDL_OPENGL
 #endif
+#ifndef HAVE_X11
 #define HAS_SDL_WIN_EVENTS
+#endif
 #else
+#ifndef HAVE_X11
 #define HAS_LINUX_EVENTS
 #endif
+#endif
 #define HAS_LINUX_NETWORK
 #define HAS_LIRC
 #ifdef HAVE_LIBPULSE
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/threads/SystemClock.cpp xbmc-13.0-r9b3ff66/xbmc/threads/SystemClock.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/threads/SystemClock.cpp	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/threads/SystemClock.cpp	2013-11-18 01:14:00.668953048 +0800
@@ -43,7 +43,7 @@
     now_time = (uint64_t)timeGetTime();
 #else
     struct timespec ts = {};
-    clock_gettime(CLOCK_MONOTONIC, &ts);
+    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
     now_time = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
 #endif
     if (!start_time_set)
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/utils/TimeUtils.cpp xbmc-13.0-r9b3ff66/xbmc/utils/TimeUtils.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/utils/TimeUtils.cpp	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/utils/TimeUtils.cpp	2013-11-18 01:14:00.668953048 +0800
@@ -43,7 +43,7 @@
   return( (int64_t)PerformanceCount.QuadPart );
 #else
   struct timespec now;
-  clock_gettime(CLOCK_MONOTONIC, &now);
+  clock_gettime(CLOCK_MONOTONIC_RAW, &now);
   return( ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec );
 #endif
 }
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/video/VideoReferenceClock.cpp xbmc-13.0-r9b3ff66/xbmc/video/VideoReferenceClock.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/video/VideoReferenceClock.cpp	2013-11-18 01:12:17.756950381 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/video/VideoReferenceClock.cpp	2013-11-18 01:14:00.648953049 +0800
@@ -31,6 +31,7 @@
   #include <sstream>
   #include <X11/extensions/Xrandr.h>
   #include "windowing/WindowingFactory.h"
+  #include "guilib/GraphicContext.h"
   #define NVSETTINGSCMD "nvidia-settings -nt -q RefreshRate3"
 #elif defined(TARGET_DARWIN_OSX)
   #include <QuartzCore/CVDisplayLink.h>
@@ -136,12 +137,23 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_RREventBase = 0;
-  m_UseNvSettings = true;
+  m_UseNvSettings = false;
   m_bIsATI = false;
 #endif
 }
 
+CVideoReferenceClock::~CVideoReferenceClock()
+{
+#if defined(HAS_GLX)
+  // some ATI voodoo, if we don't close the display, we crash on exit
+  if (m_Dpy)
+  {
+    XCloseDisplay(m_Dpy);
+    m_Dpy = NULL;
+  }
+#endif
+}
+
 void CVideoReferenceClock::Process()
 {
   bool SetupSuccess = false;
@@ -152,6 +164,10 @@
   m_D3dCallback.Reset();
   g_Windowing.Register(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+  g_Windowing.Register(this);
+  m_xrrEvent = false;
+#endif
 
   while(!m_bStop)
   {
@@ -212,6 +228,16 @@
     //clean up the vblank clock
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
     CleanupGLX();
+    if (m_xrrEvent)
+    {
+      m_releaseEvent.Set();
+      while (!m_bStop)
+      {
+        if (m_resetEvent.WaitMSec(100))
+          break;
+      }
+      m_xrrEvent = false;
+    }
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
     CleanupD3D();
 #elif defined(TARGET_DARWIN)
@@ -223,6 +249,9 @@
 #if defined(TARGET_WINDOWS) && defined(HAS_DX)
   g_Windowing.Unregister(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX)
+  g_Windowing.Unregister(this);
+#endif
 }
 
 bool CVideoReferenceClock::WaitStarted(int MSecs)
@@ -232,6 +261,24 @@
 }
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
+
+void CVideoReferenceClock::OnLostDevice()
+{
+  if (!m_xrrEvent)
+  {
+    m_releaseEvent.Reset();
+    m_resetEvent.Reset();
+    m_xrrEvent = true;
+    m_releaseEvent.Wait();
+  }
+}
+
+void CVideoReferenceClock::OnResetDevice()
+{
+  m_xrrEvent = false;
+  m_resetEvent.Set();
+}
+
 bool CVideoReferenceClock::SetupGLX()
 {
   int singleBufferAttributes[] = {
@@ -271,7 +318,7 @@
   }
 
   bool          ExtensionFound = false;
-  istringstream Extensions(glXQueryExtensionsString(m_Dpy, DefaultScreen(m_Dpy)));
+  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
   string        ExtensionStr;
 
   while (!ExtensionFound)
@@ -297,7 +344,7 @@
     m_bIsATI = true;
   }
 
-  m_vInfo = glXChooseVisual(m_Dpy, DefaultScreen(m_Dpy), singleBufferAttributes);
+  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
   if (!m_vInfo)
   {
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
@@ -308,15 +355,16 @@
   {
     Swa.border_pixel = 0;
     Swa.event_mask = StructureNotifyMask;
-    Swa.colormap = XCreateColormap(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), m_vInfo->visual, AllocNone );
+    Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
     SwaMask = CWBorderPixel | CWColormap | CWEventMask;
 
-    m_Window = XCreateWindow(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), 0, 0, 256, 256, 0,
+    m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
                            m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
   }
   else
   {
-    m_pixmap = XCreatePixmap(m_Dpy, DefaultRootWindow(m_Dpy), 256, 256, m_vInfo->depth);
+    Window window = g_Windowing.GetWindow();
+    m_pixmap = XCreatePixmap(m_Dpy, window, 256, 256, m_vInfo->depth);
     if (!m_pixmap)
     {
       CLog::Log(LOGDEBUG, "CVideoReferenceClock: unable to create pixmap");
@@ -381,10 +429,6 @@
     return false;
   }
 
-  //set up receiving of RandR events, we'll get one when the refreshrate changes
-  XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), RRScreenChangeNotifyMask);
-
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
 
@@ -518,7 +562,7 @@
   int RefreshRate;
   XRRScreenConfiguration *CurrInfo;
 
-  CurrInfo = XRRGetScreenInfo(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen));
+  CurrInfo = XRRGetScreenInfo(m_Dpy, g_Windowing.GetWindow());
   RefreshRate = XRRConfigCurrentRate(CurrInfo);
   XRRFreeScreenConfigInfo(CurrInfo);
 
@@ -585,6 +629,9 @@
 
   while(!m_bStop)
   {
+    if (m_xrrEvent)
+      return;
+
     //wait for the next vblank
     if (!m_bIsATI)
     {
@@ -648,7 +695,6 @@
       UpdateClock((int)(VblankCount - PrevVblankCount), true);
       SingleLock.Leave();
       SendVblankSignal();
-      UpdateRefreshrate();
       IsReset = false;
     }
     else if (!m_bStop)
@@ -1185,23 +1231,10 @@
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
 
-  //check for RandR events
-  bool   GotEvent = Forced || m_RefreshChanged == 2;
-  XEvent Event;
-  while (XCheckTypedEvent(m_Dpy, m_RREventBase + RRScreenChangeNotify, &Event))
-  {
-    if (Event.type == m_RREventBase + RRScreenChangeNotify)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Received RandR event %i", Event.type);
-      GotEvent = true;
-    }
-    XRRUpdateConfiguration(&Event);
-  }
-
   if (!Forced)
     m_RefreshChanged = 0;
 
-  if (!GotEvent) //refreshrate did not change
+  if (!Forced) //refreshrate did not change
     return false;
 
   //the refreshrate can be wrong on nvidia drivers, so read it from nvidia-settings when it's available
@@ -1222,7 +1255,7 @@
   }
 
   CSingleLock SingleLock(m_CritSection);
-  m_RefreshRate = GetRandRRate();
+  m_RefreshRate = MathUtils::round_int(g_graphicsContext.GetFPS());
 
   CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %i hertz", (int)m_RefreshRate);
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/video/VideoReferenceClock.h xbmc-13.0-r9b3ff66/xbmc/video/VideoReferenceClock.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/video/VideoReferenceClock.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/video/VideoReferenceClock.h	2013-11-18 01:14:00.644953049 +0800
@@ -30,6 +30,7 @@
   #include <X11/X.h>
   #include <X11/Xlib.h>
   #include <GL/glx.h>
+  #include "guilib/DispResource.h"
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
   #include <d3d9.h>
   #include "guilib/D3DResource.h"
@@ -56,9 +57,13 @@
 #endif
 
 class CVideoReferenceClock : public CThread
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+                            ,public IDispResource
+#endif
 {
   public:
     CVideoReferenceClock();
+    virtual ~CVideoReferenceClock();
 
     int64_t GetTime(bool interpolated = true);
     int64_t GetFrequency();
@@ -75,6 +80,11 @@
     void VblankHandler(int64_t nowtime, double fps);
 #endif
 
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+    virtual void OnLostDevice();
+    virtual void OnResetDevice();
+#endif
+
   private:
     void    Process();
     bool    UpdateRefreshrate(bool Forced = false);
@@ -121,7 +131,8 @@
     GLXContext   m_Context;
     Pixmap       m_pixmap;
     GLXPixmap    m_glPixmap;
-    int          m_RREventBase;
+    bool         m_xrrEvent;
+    CEvent       m_releaseEvent, m_resetEvent;
 
     bool         m_UseNvSettings;
     bool         m_bIsATI;
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/Makefile.in xbmc-13.0-r9b3ff66/xbmc/windowing/Makefile.in
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/Makefile.in	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/Makefile.in	2013-11-18 01:14:00.624953048 +0800
@@ -1,6 +1,7 @@
 SRCS=WinEventsSDL.cpp \
      WinEventsLinux.cpp \
      WinEventsWayland.cpp \
+     WinEventsX11.cpp \
      WinSystem.cpp \
      WinEvents.cpp
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEvents.cpp xbmc-13.0-r9b3ff66/xbmc/windowing/WinEvents.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEvents.cpp	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/WinEvents.cpp	2013-11-18 01:14:00.624953048 +0800
@@ -42,6 +42,10 @@
 #include "WinEventsSDL.h"
 #define WinEventsType CWinEventsSDL
 
+#elif (defined(TARGET_FREEBSD) || defined(TARGET_LINUX)) && defined(HAS_X11_WIN_EVENTS)
+#include "WinEventsX11.h"
+#define WinEventsType CWinEventsX11
+
 #elif defined(HAVE_WAYLAND)
 #include "WinEventsWayland.h"
 #define WinEventsType CWinEventsWayland
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEventsX11.cpp xbmc-13.0-r9b3ff66/xbmc/windowing/WinEventsX11.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEventsX11.cpp	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/WinEventsX11.cpp	2013-11-18 01:14:00.760953052 +0800
@@ -0,0 +1,738 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "system.h"
+
+#ifdef HAS_X11_WIN_EVENTS
+
+#include "WinEvents.h"
+#include "WinEventsX11.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include <X11/Xlib.h>
+#include "X11/WinSystemX11GL.h"
+#include "X11/keysymdef.h"
+#include "X11/XF86keysym.h"
+#include "utils/log.h"
+#include "utils/CharsetConverter.h"
+#include "guilib/GUIWindowManager.h"
+#include "input/MouseStat.h"
+
+#if defined(HAS_XRANDR)
+#include <X11/extensions/Xrandr.h>
+#endif
+
+#ifdef HAS_SDL_JOYSTICK
+#include "input/SDLJoystick.h"
+#endif
+
+CWinEventsX11Imp* CWinEventsX11Imp::WinEvents = 0;
+
+static uint32_t SymMappingsX11[][2] =
+{
+  {XK_BackSpace, XBMCK_BACKSPACE}
+, {XK_Tab, XBMCK_TAB}
+, {XK_Clear, XBMCK_CLEAR}
+, {XK_Return, XBMCK_RETURN}
+, {XK_Pause, XBMCK_PAUSE}
+, {XK_Escape, XBMCK_ESCAPE}
+, {XK_Delete, XBMCK_DELETE}
+// multi-media keys
+, {XF86XK_Back, XBMCK_BROWSER_BACK}
+, {XF86XK_Forward, XBMCK_BROWSER_FORWARD}
+, {XF86XK_Refresh, XBMCK_BROWSER_REFRESH}
+, {XF86XK_Stop, XBMCK_BROWSER_STOP}
+, {XF86XK_Search, XBMCK_BROWSER_SEARCH}
+, {XF86XK_Favorites, XBMCK_BROWSER_FAVORITES}
+, {XF86XK_HomePage, XBMCK_BROWSER_HOME}
+, {XF86XK_AudioMute, XBMCK_VOLUME_MUTE}
+, {XF86XK_AudioLowerVolume, XBMCK_VOLUME_DOWN}
+, {XF86XK_AudioRaiseVolume, XBMCK_VOLUME_UP}
+, {XF86XK_AudioNext, XBMCK_MEDIA_NEXT_TRACK}
+, {XF86XK_AudioPrev, XBMCK_MEDIA_PREV_TRACK}
+, {XF86XK_AudioStop, XBMCK_MEDIA_STOP}
+, {XF86XK_AudioPause, XBMCK_MEDIA_PLAY_PAUSE}
+, {XF86XK_Mail, XBMCK_LAUNCH_MAIL}
+, {XF86XK_Select, XBMCK_LAUNCH_MEDIA_SELECT}
+, {XF86XK_Launch0, XBMCK_LAUNCH_APP1}
+, {XF86XK_Launch1, XBMCK_LAUNCH_APP2}
+, {XF86XK_WWW, XBMCK_LAUNCH_FILE_BROWSER}
+, {XF86XK_AudioMedia, XBMCK_LAUNCH_MEDIA_CENTER }
+  // Numeric keypad
+, {XK_KP_0, XBMCK_KP0}
+, {XK_KP_1, XBMCK_KP1}
+, {XK_KP_2, XBMCK_KP2}
+, {XK_KP_3, XBMCK_KP3}
+, {XK_KP_4, XBMCK_KP4}
+, {XK_KP_5, XBMCK_KP5}
+, {XK_KP_6, XBMCK_KP6}
+, {XK_KP_7, XBMCK_KP7}
+, {XK_KP_8, XBMCK_KP8}
+, {XK_KP_9, XBMCK_KP9}
+, {XK_KP_Separator, XBMCK_KP_PERIOD}
+, {XK_KP_Divide, XBMCK_KP_DIVIDE}
+, {XK_KP_Multiply, XBMCK_KP_MULTIPLY}
+, {XK_KP_Subtract, XBMCK_KP_MINUS}
+, {XK_KP_Add, XBMCK_KP_PLUS}
+, {XK_KP_Enter, XBMCK_KP_ENTER}
+, {XK_KP_Equal, XBMCK_KP_EQUALS}
+  // Arrows + Home/End pad
+, {XK_Up, XBMCK_UP}
+, {XK_Down, XBMCK_DOWN}
+, {XK_Right, XBMCK_RIGHT}
+, {XK_Left, XBMCK_LEFT}
+, {XK_Insert, XBMCK_INSERT}
+, {XK_Home, XBMCK_HOME}
+, {XK_End, XBMCK_END}
+, {XK_Page_Up, XBMCK_PAGEUP}
+, {XK_Page_Down, XBMCK_PAGEDOWN}
+  // Function keys
+, {XK_F1, XBMCK_F1}
+, {XK_F2, XBMCK_F2}
+, {XK_F3, XBMCK_F3}
+, {XK_F4, XBMCK_F4}
+, {XK_F5, XBMCK_F5}
+, {XK_F6, XBMCK_F6}
+, {XK_F7, XBMCK_F7}
+, {XK_F8, XBMCK_F8}
+, {XK_F9, XBMCK_F9}
+, {XK_F10, XBMCK_F10}
+, {XK_F11, XBMCK_F11}
+, {XK_F12, XBMCK_F12}
+, {XK_F13, XBMCK_F13}
+, {XK_F14, XBMCK_F14}
+, {XK_F15, XBMCK_F15}
+  // Key state modifier keys
+, {XK_Num_Lock, XBMCK_NUMLOCK}
+, {XK_Caps_Lock, XBMCK_CAPSLOCK}
+, {XK_Scroll_Lock, XBMCK_SCROLLOCK}
+, {XK_Shift_R, XBMCK_RSHIFT}
+, {XK_Shift_L, XBMCK_LSHIFT}
+, {XK_Control_R, XBMCK_RCTRL}
+, {XK_Control_L, XBMCK_LCTRL}
+, {XK_Alt_R, XBMCK_RALT}
+, {XK_Alt_L, XBMCK_LALT}
+, {XK_Meta_R, XBMCK_RMETA}
+, {XK_Meta_L, XBMCK_LMETA}
+, {XK_Super_L, XBMCK_LSUPER}
+, {XK_Super_R, XBMCK_RSUPER}
+, {XK_Mode_switch, XBMCK_MODE}
+, {XK_Multi_key, XBMCK_COMPOSE}
+  // Miscellaneous function keys
+, {XK_Help, XBMCK_HELP}
+, {XK_Print, XBMCK_PRINT}
+//, {0, XBMCK_SYSREQ}
+, {XK_Break, XBMCK_BREAK}
+, {XK_Menu, XBMCK_MENU}
+, {XF86XK_PowerOff, XBMCK_POWER}
+, {XF86XK_Sleep, XBMCK_SLEEP}
+, {XK_EcuSign, XBMCK_EURO}
+, {XK_Undo, XBMCK_UNDO}
+  /* Media keys */
+, {XF86XK_Eject, XBMCK_EJECT}
+, {XF86XK_Stop, XBMCK_STOP}
+, {XF86XK_AudioRecord, XBMCK_RECORD}
+, {XF86XK_AudioRewind, XBMCK_REWIND}
+, {XF86XK_Phone, XBMCK_PHONE}
+, {XF86XK_AudioPlay, XBMCK_PLAY}
+, {XF86XK_AudioRandomPlay, XBMCK_SHUFFLE}
+, {XF86XK_AudioForward, XBMCK_FASTFORWARD}
+};
+
+bool CWinEventsX11::MessagePump()
+{
+  return CWinEventsX11Imp::MessagePump();
+}
+
+size_t CWinEventsX11::GetQueueSize()
+{
+  return CWinEventsX11Imp::GetQueueSize();
+}
+
+CWinEventsX11Imp::CWinEventsX11Imp()
+{
+  m_display = 0;
+  m_window = 0;
+  m_keybuf = 0;
+  m_keybuf_len = 0;
+}
+
+CWinEventsX11Imp::~CWinEventsX11Imp()
+{
+  if (m_keybuf);
+  {
+    free(m_keybuf);
+    m_keybuf = 0;
+  }
+
+  if (m_xic)
+  {
+    XUnsetICFocus(m_xic);
+    XDestroyIC(m_xic);
+    m_xic = 0;
+  }
+
+  if (m_xim)
+  {
+    XCloseIM(m_xim);
+    m_xim = 0;
+  }
+
+  m_symLookupTable.clear();
+}
+
+bool CWinEventsX11Imp::Init(Display *dpy, Window win)
+{
+  if (WinEvents)
+    return true;
+
+  WinEvents = new CWinEventsX11Imp();
+  WinEvents->m_display = dpy;
+  WinEvents->m_window = win;
+  WinEvents->m_keybuf_len = 32*sizeof(char);
+  WinEvents->m_keybuf = (char*)malloc(WinEvents->m_keybuf_len);
+  WinEvents->m_keymodState = 0;
+  WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+  WinEvents->m_structureChanged = false;
+  WinEvents->m_xrrEventPending = false;
+
+  // open input method
+  char *old_locale = NULL, *old_modifiers = NULL;
+  char res_name[8];
+  const char *p;
+  size_t n;
+
+  // set resource name to xbmc, not used
+  strcpy(res_name, "xbmc");
+
+  // save current locale, this should be "C"
+  p = setlocale(LC_ALL, NULL);
+  if (p)
+  {
+    old_locale = (char*)malloc(strlen(p) +1);
+    strcpy(old_locale, p);
+  }
+  p = XSetLocaleModifiers(NULL);
+  if (p)
+  {
+    old_modifiers = (char*)malloc(strlen(p) +1);
+    strcpy(old_modifiers, p);
+  }
+
+  // set users preferences and open input method
+  p = setlocale(LC_ALL, "");
+  XSetLocaleModifiers("");
+  WinEvents->m_xim = XOpenIM(WinEvents->m_display, NULL, res_name, res_name);
+
+  // restore old locale
+  if (old_locale)
+  {
+    setlocale(LC_ALL, old_locale);
+    free(old_locale);
+  }
+  if (old_modifiers)
+  {
+    XSetLocaleModifiers(old_modifiers);
+    free(old_modifiers);
+  }
+
+  WinEvents->m_xic = NULL;
+  if (WinEvents->m_xim)
+  {
+    WinEvents->m_xic = XCreateIC(WinEvents->m_xim,
+                                 XNClientWindow, WinEvents->m_window,
+                                 XNFocusWindow, WinEvents->m_window,
+                                 XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+                                 XNResourceName, res_name,
+                                 XNResourceClass, res_name,
+                                 NULL);
+  }
+
+  if (!WinEvents->m_xic)
+    CLog::Log(LOGWARNING,"CWinEventsX11::Init - no input method found");
+
+  // build Keysym lookup table
+  for (unsigned int i = 0; i < sizeof(SymMappingsX11)/(2*sizeof(uint32_t)); ++i)
+  {
+    WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
+  }
+
+  // register for xrandr events
+#if defined(HAS_XRANDR)
+  int iReturn;
+  XRRQueryExtension(WinEvents->m_display, &WinEvents->m_RREventBase, &iReturn);
+  int numScreens = XScreenCount(WinEvents->m_display);
+  for (int i = 0; i < numScreens; i++)
+  {
+    XRRSelectInput(WinEvents->m_display, RootWindow(WinEvents->m_display, i), RRScreenChangeNotifyMask | RRCrtcChangeNotifyMask | RROutputChangeNotifyMask | RROutputPropertyNotifyMask);
+  }
+#endif
+
+  return true;
+}
+
+void CWinEventsX11Imp::Quit()
+{
+  if (!WinEvents)
+    return;
+
+  delete WinEvents;
+  WinEvents = 0;
+}
+
+bool CWinEventsX11Imp::HasStructureChanged()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = WinEvents->m_structureChanged;
+  WinEvents->m_structureChanged = false;
+  return ret;
+}
+
+void CWinEventsX11Imp::SetXRRFailSafeTimer(int millis)
+{
+  if (!WinEvents)
+    return;
+
+  WinEvents->m_xrrFailSafeTimer.Set(millis);
+  WinEvents->m_xrrEventPending = true;
+}
+
+bool CWinEventsX11Imp::MessagePump()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = false;
+  XEvent xevent;
+  unsigned long serial = 0;
+
+  while (WinEvents && XPending(WinEvents->m_display))
+  {
+    memset(&xevent, 0, sizeof (XEvent));
+    XNextEvent(WinEvents->m_display, &xevent);
+
+#if defined(HAS_XRANDR)
+    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
+    {
+      XRRUpdateConfiguration(&xevent);
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+    else if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRNotify))
+    {
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+      continue;
+    }
+#endif
+
+    if (XFilterEvent(&xevent, WinEvents->m_window))
+      continue;
+
+    switch (xevent.type)
+    {
+      case MapNotify:
+      {
+        g_application.SetRenderGUI(true);
+        break;
+      }
+
+      case UnmapNotify:
+      {
+        g_application.SetRenderGUI(false);
+        break;
+      }
+
+      case FocusIn:
+      {
+        if (WinEvents->m_xic)
+          XSetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = true;
+        WinEvents->m_keymodState = 0;
+        if (serial == xevent.xfocus.serial)
+          break;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        break;
+      }
+
+      case FocusOut:
+      {
+        if (WinEvents->m_xic)
+          XUnsetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = false;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        serial = xevent.xfocus.serial;
+        break;
+      }
+
+      case Expose:
+      {
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ConfigureNotify:
+      {
+        if (xevent.xconfigure.window != WinEvents->m_window)
+          break;
+
+        WinEvents->m_structureChanged = true;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_VIDEORESIZE;
+        newEvent.resize.w = xevent.xconfigure.width;
+        newEvent.resize.h = xevent.xconfigure.height;
+        ret |= g_application.OnEvent(newEvent);
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ClientMessage:
+      {
+        if (xevent.xclient.data.l[0] == WinEvents->m_wmDeleteMessage)
+          if (!g_application.m_bStop) CApplicationMessenger::Get().Quit();
+        break;
+      }
+
+      case KeyPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYDOWN;
+        KeySym xkeysym;
+
+        // fallback if we have no IM
+        if (!WinEvents->m_xic)
+        {
+          static XComposeStatus state;
+          char keybuf[32];
+          XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
+          newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+          newEvent.key.keysym.scancode = xevent.xkey.keycode;
+          newEvent.key.state = xevent.xkey.state;
+          newEvent.key.type = xevent.xkey.type;
+          if (XLookupString(&xevent.xkey, keybuf, sizeof(keybuf), NULL, &state))
+          {
+            newEvent.key.keysym.unicode = keybuf[0];
+          }
+          ret |= ProcessKey(newEvent);
+          break;
+        }
+
+        Status status;
+        int len;
+        len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                WinEvents->m_keybuf, WinEvents->m_keybuf_len,
+                                &xkeysym, &status);
+        if (status == XBufferOverflow)
+        {
+          WinEvents->m_keybuf_len = len;
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, WinEvents->m_keybuf_len);
+          len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                  WinEvents->m_keybuf, WinEvents->m_keybuf_len,
+                                  &xkeysym, &status);
+        }
+        switch (status)
+        {
+          case XLookupNone:
+            break;
+          case XLookupChars:
+          case XLookupBoth:
+          {
+            CStdString   data(WinEvents->m_keybuf, len);
+            CStdStringW keys;
+            g_charsetConverter.utf8ToW(data, keys, false);
+
+            if (keys.length() == 0)
+            {
+              break;
+            }
+
+            for (unsigned int i = 0; i < keys.length() - 1; i++)
+            {
+              newEvent.key.keysym.sym = XBMCK_UNKNOWN;
+              newEvent.key.keysym.unicode = keys[i];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+              ret |= ProcessKey(newEvent);
+            }
+            if (keys.length() > 0)
+            {
+              newEvent.key.keysym.scancode = xevent.xkey.keycode;
+              XLookupString(&xevent.xkey, NULL, 0, &xkeysym, NULL);
+              newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+              newEvent.key.keysym.unicode = keys[keys.length() - 1];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+
+              ret |= ProcessKey(newEvent);
+            }
+            break;
+          }
+
+          case XLookupKeySym:
+          {
+            newEvent.key.keysym.scancode = xevent.xkey.keycode;
+            newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+            newEvent.key.state = xevent.xkey.state;
+            newEvent.key.type = xevent.xkey.type;
+            ret |= ProcessKey(newEvent);
+            break;
+          }
+
+        }// switch status
+        break;
+      } //KeyPress
+
+      case KeyRelease:
+      {
+        // if we have a queued press directly after, this is a repeat
+        if( XEventsQueued( WinEvents->m_display, QueuedAfterReading ) )
+        {
+          XEvent next_event;
+          XPeekEvent( WinEvents->m_display, &next_event );
+          if(next_event.type == KeyPress
+            && next_event.xkey.window == xevent.xkey.window
+            && next_event.xkey.keycode == xevent.xkey.keycode
+            && (next_event.xkey.time - xevent.xkey.time < 2) )
+            continue;
+        }
+
+        XBMC_Event newEvent;
+        KeySym xkeysym;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYUP;
+        xkeysym = XLookupKeysym(&xevent.xkey, 0);
+        newEvent.key.keysym.scancode = xevent.xkey.keycode;
+        newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+        newEvent.key.state = xevent.xkey.state;
+        newEvent.key.type = xevent.xkey.type;
+        ret |= ProcessKey(newEvent);
+        break;
+      }
+
+      case EnterNotify:
+      {
+        break;
+      }
+
+      // lose mouse coverage
+      case LeaveNotify:
+      {
+        g_Mouse.SetActive(false);
+        break;
+      }
+
+      case MotionNotify:
+      {
+        if (xevent.xmotion.window != WinEvents->m_window)
+          break;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEMOTION;
+        newEvent.motion.xrel = (int16_t)xevent.xmotion.x_root;
+        newEvent.motion.yrel = (int16_t)xevent.xmotion.y_root;
+        newEvent.motion.x = (int16_t)xevent.xmotion.x;
+        newEvent.motion.y = (int16_t)xevent.xmotion.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONDOWN;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_PRESSED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonRelease:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONUP;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_RELEASED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      default:
+      {
+        break;
+      }
+    }// switch event.type
+  }// while
+
+#if defined(HAS_XRANDR)
+  if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
+  {
+    CLog::Log(LOGERROR,"CWinEventsX11::MessagePump - missed XRR Events");
+    g_Windowing.NotifyXRREvent();
+    WinEvents->m_xrrEventPending = false;
+  }
+#endif
+
+#ifdef HAS_SDL_JOYSTICK
+  SDL_Event event;
+  while (SDL_PollEvent(&event))
+  {
+    switch(event.type)
+    {
+      case SDL_JOYBUTTONUP:
+      case SDL_JOYBUTTONDOWN:
+      case SDL_JOYAXISMOTION:
+      case SDL_JOYBALLMOTION:
+      case SDL_JOYHATMOTION:
+        g_Joystick.Update(event);
+        ret = true;
+        break;
+
+      default:
+        break;
+    }
+    memset(&event, 0, sizeof(SDL_Event));
+  }
+#endif
+
+  return ret;
+}
+
+size_t CWinEventsX11Imp::GetQueueSize()
+{
+  int ret = 0;
+
+  if (WinEvents)
+    ret = XPending(WinEvents->m_display);
+
+  return ret;
+}
+
+bool CWinEventsX11Imp::ProcessKey(XBMC_Event &event)
+{
+  if (event.type == XBMC_KEYDOWN)
+  {
+    // check key modifiers
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState |= XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState |= XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+  }
+  else if (event.type == XBMC_KEYUP)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState &= ~XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+  }
+
+  return g_application.OnEvent(event);
+}
+
+XBMCKey CWinEventsX11Imp::LookupXbmcKeySym(KeySym keysym)
+{
+  // try direct mapping first
+  std::map<uint32_t, uint32_t>::iterator it;
+  it = WinEvents->m_symLookupTable.find(keysym);
+  if (it != WinEvents->m_symLookupTable.end())
+  {
+    return (XBMCKey)(it->second);
+  }
+
+  // try ascii mappings
+  if (keysym>>8 == 0x00)
+    return (XBMCKey)(keysym & 0xFF);
+
+  return (XBMCKey)keysym;
+}
+#endif
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEventsX11.h xbmc-13.0-r9b3ff66/xbmc/windowing/WinEventsX11.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinEventsX11.h	1970-01-01 08:00:00.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/WinEventsX11.h	2013-11-18 01:14:00.760953052 +0800
@@ -0,0 +1,65 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#pragma once
+
+#include "WinEvents.h"
+#include <X11/Xlib.h>
+#include "threads/SystemClock.h"
+#include <map>
+
+class CWinEventsX11 : public IWinEvents
+{
+public:
+  virtual bool MessagePump();
+  virtual size_t GetQueueSize();
+};
+
+class CWinEventsX11Imp
+{
+public:
+  CWinEventsX11Imp();
+  virtual ~CWinEventsX11Imp();
+  static bool Init(Display *dpy, Window win);
+  static void Quit();
+  static bool HasStructureChanged();
+  static void PendingResize(int width, int height);
+  static void SetXRRFailSafeTimer(int millis);
+  static bool MessagePump();
+  static size_t GetQueueSize();
+
+protected:
+  static XBMCKey LookupXbmcKeySym(KeySym keysym);
+  static bool ProcessKey(XBMC_Event &event);
+  static CWinEventsX11Imp *WinEvents;
+  Display *m_display;
+  Window m_window;
+  Atom m_wmDeleteMessage;
+  char *m_keybuf;
+  size_t m_keybuf_len;
+  XIM m_xim;
+  XIC m_xic;
+  std::map<uint32_t,uint32_t> m_symLookupTable;
+  int m_keymodState;
+  bool m_structureChanged;
+  int m_RREventBase;
+  XbmcThreads::EndTime m_xrrFailSafeTimer;
+  bool m_xrrEventPending;
+};
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinSystem.h xbmc-13.0-r9b3ff66/xbmc/windowing/WinSystem.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/WinSystem.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/WinSystem.h	2013-11-18 01:14:00.644953049 +0800
@@ -103,6 +103,7 @@
   std::vector<RESOLUTION_WHR> ScreenResolutions(int screen, float refreshrate);
   std::vector<REFRESHRATE> RefreshRates(int screen, int width, int height, uint32_t dwFlags);
   REFRESHRATE DefaultRefreshRate(int screen, std::vector<REFRESHRATE> rates);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo) { return true; };
 
   // text input interface
   virtual void EnableTextInput(bool bEnable) {}
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11.cpp xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11.cpp	2013-11-18 01:12:17.764950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11.cpp	2013-11-18 01:14:03.220953116 +0800
@@ -22,7 +22,6 @@
 
 #ifdef HAS_GLX
 
-#include <SDL/SDL_syswm.h>
 #include "WinSystemX11.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
@@ -34,28 +33,35 @@
 #include "XRandR.h"
 #include <vector>
 #include "threads/SingleLock.h"
-#include <X11/Xlib.h>
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
 #include "utils/StringUtils.h"
+#include "settings/Settings.h"
+#include "windowing/WindowingFactory.h"
+#include <X11/Xatom.h>
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
 #endif
 
+#include "../WinEventsX11.h"
+#include "input/MouseStat.h"
+
 using namespace std;
 
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
   m_glContext = NULL;
-  m_SDLSurface = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
-  m_wmWindow = 0;
+  m_mainWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
+  m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
+  m_invisibleCursor = 0;
+  m_bIsInternalXrr = false;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -68,19 +74,8 @@
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-
-    SDL_EnableUNICODE(1);
-    // set repeat to 10ms to ensure repeat time < frame time
-    // so that hold times can be reliably detected
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, 10);
-
-    SDL_GL_SetAttribute(SDL_GL_RED_SIZE,   8);
-    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE,  8);
-    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-
-    return CWinSystemBase::InitWindowSystem();
+    bool ret = CWinSystemBase::InitWindowSystem();
+    return ret;
   }
   else
     CLog::Log(LOGERROR, "GLX Error: No Display found");
@@ -91,9 +86,18 @@
 bool CWinSystemX11::DestroyWindowSystem()
 {
 #if defined(HAS_XRANDR)
-  //restore videomode on exit
+  //restore desktop resolution on exit
   if (m_bFullScreen)
-    g_xrandr.RestoreState();
+  {
+    XOutput out;
+    XMode mode;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
+    g_xrandr.SetMode(out, mode);
+  }
 #endif
 
   if (m_dpy)
@@ -108,6 +112,9 @@
 
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
+    // i have seen core dumps on ATI if the display is not closed here
+    // crashes when shutting down via cec
+//    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
@@ -117,177 +124,255 @@
 
 bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
 {
-  RESOLUTION_INFO& desktop = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP);
-
-  if (fullScreen &&
-      (res.iWidth != desktop.iWidth || res.iHeight != desktop.iHeight ||
-       res.fRefreshRate != desktop.fRefreshRate || res.iScreen != desktop.iScreen))
-  {
-    //on the first call to SDL_SetVideoMode, SDL stores the current displaymode
-    //SDL restores the displaymode on SDL_QUIT(), if we change the displaymode
-    //before the first call to SDL_SetVideoMode, SDL changes the displaymode back
-    //to the wrong mode on exit
-
-    CLog::Log(LOGINFO, "CWinSystemX11::CreateNewWindow initializing to desktop resolution first");
-    if (!SetFullScreen(true, desktop, false))
-      return false;
-  }
-
   if(!SetFullScreen(fullScreen, res, false))
     return false;
 
-  CBaseTexture* iconTexture = CTexture::LoadFromFile("special://xbmc/media/icon.png");
-
-  if (iconTexture)
-    SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture->GetPixels(), iconTexture->GetWidth(), iconTexture->GetHeight(), 32, iconTexture->GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
-  SDL_WM_SetCaption("XBMC Media Center", NULL);
-  delete iconTexture;
-
-  // register XRandR Events
-#if defined(HAS_XRANDR)
-  int iReturn;
-  XRRQueryExtension(m_dpy, &m_RREventBase, &iReturn);
-  XRRSelectInput(m_dpy, m_wmWindow, RRScreenChangeNotifyMask);
-#endif
-
   m_bWindowCreated = true;
   return true;
 }
 
 bool CWinSystemX11::DestroyWindow()
 {
+  if (!m_mainWindow)
+    return true;
+
+  if (m_glContext)
+  {
+    glFinish();
+    glXMakeCurrent(m_dpy, None, NULL);
+  }
+
+  if (m_invisibleCursor)
+  {
+    XUndefineCursor(m_dpy, m_mainWindow);
+    XFreeCursor(m_dpy, m_invisibleCursor);
+    m_invisibleCursor = 0;
+  }
+
+  CWinEventsX11Imp::Quit();
+
+  XUnmapWindow(m_dpy, m_mainWindow);
+  XSync(m_dpy,TRUE);
+  XDestroyWindow(m_dpy, m_glWindow);
+  XDestroyWindow(m_dpy, m_mainWindow);
+  m_glWindow = 0;
+  m_mainWindow = 0;
+
+  if (m_icon)
+    XFreePixmap(m_dpy, m_icon);
+
   return true;
 }
 
 bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
-  if(m_nWidth  == newWidth
-  && m_nHeight == newHeight)
-    return true;
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.compare("Default") == 0)
+  {
+    std::vector<XOutput> outputs = g_xrandr.GetModes();
+    if (outputs.size() > 0)
+    {
+      m_userOutput = outputs[0].name;
+    }
+  }
 
-  m_nWidth  = newWidth;
-  m_nHeight = newHeight;
+  m_userOutput = g_xrandr.GetModes()[0].name;
 
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
+  if(m_nWidth  == newWidth
+  && m_nHeight == newHeight
+  && m_userOutput.compare(m_currentOutput) == 0)
+    return true;
 
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
+  if (!SetWindow(newWidth, newHeight, false, m_userOutput))
   {
-    SetGrabMode();
-    RefreshGlxContext();
-    return true;
+    return false;
   }
 
+  m_nWidth  = newWidth;
+  m_nHeight = newHeight;
+  m_bFullScreen = false;
+  m_currentOutput = m_userOutput;
+
   return false;
 }
 
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  m_nWidth      = res.iWidth;
-  m_nHeight     = res.iHeight;
-  m_bFullScreen = fullScreen;
 
 #if defined(HAS_XRANDR)
   XOutput out;
   XMode mode;
-  out.name = res.strOutput;
-  mode.w   = res.iWidth;
-  mode.h   = res.iHeight;
-  mode.hz  = res.fRefreshRate;
-  mode.id  = res.strId;
- 
-  if(m_bFullScreen)
+
+  if (fullScreen)
   {
-    OnLostDevice();
-    g_xrandr.SetMode(out, mode);
+    out.name = res.strOutput;
+    mode.w   = res.iWidth;
+    mode.h   = res.iHeight;
+    mode.hz  = res.fRefreshRate;
+    mode.id  = res.strId;
   }
   else
-    g_xrandr.RestoreState();
-#endif
-
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
-
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
   {
-    if ((m_SDLSurface->flags & SDL_OPENGL) != SDL_OPENGL)
-      CLog::Log(LOGERROR, "CWinSystemX11::SetFullScreen SDL_OPENGL not set, SDL_GetError:%s", SDL_GetError());
-
-    SetGrabMode();
-    RefreshGlxContext();
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
+  }
+ 
+  XMode   currmode = g_xrandr.GetCurrentMode(out.name);
+  if (!currmode.name.empty())
+  {
+    // flip h/w when rotated
+    if (m_bIsRotated)
+    {
+      int w = mode.w;
+      mode.w = mode.h;
+      mode.h = w;
+    }
 
-    return true;
+    // only call xrandr if mode changes
+    if (currmode.w != mode.w || currmode.h != mode.h ||
+        currmode.hz != mode.hz || currmode.id != mode.id)
+    {
+      CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
+      OnLostDevice();
+      m_bIsInternalXrr = true;
+      g_xrandr.SetMode(out, mode);
+      if (m_mainWindow)
+        return true;
+    }
   }
+#endif
 
-  return false;
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, m_userOutput))
+    return false;
+
+  m_nWidth      = res.iWidth;
+  m_nHeight     = res.iHeight;
+  m_bFullScreen = fullScreen;
+  m_currentOutput = m_userOutput;
+
+  return true;
 }
 
 void CWinSystemX11::UpdateResolutions()
 {
   CWinSystemBase::UpdateResolutions();
 
-
 #if defined(HAS_XRANDR)
-  if(g_xrandr.Query())
+  int numScreens = XScreenCount(m_dpy);
+  g_xrandr.SetNumScreens(numScreens);
+
+  bool switchOnOff = CSettings::Get().GetBool("videoscreen.monitorsingle");
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.compare("Default") == 0)
+    switchOnOff = false;
+
+  if(g_xrandr.Query(true, !switchOnOff))
   {
-    XOutput out  = g_xrandr.GetCurrentOutput();
-    XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    XOutput *out = NULL;
+    if (m_userOutput.compare("Default") != 0)
+    {
+      out = g_xrandr.GetOutput(m_userOutput);
+      if (out)
+      {
+        XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+        if (!mode.isCurrent && !switchOnOff)
+        {
+          out = NULL;
+        }
+      }
+    }
+    if (!out)
+    {
+      m_userOutput = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(m_userOutput);
+    }
+
+    if (switchOnOff)
+    {
+      // switch on output
+      g_xrandr.TurnOnOutput(m_userOutput);
+
+      // switch off other outputs
+      std::vector<XOutput> outputs = g_xrandr.GetModes();
+      for (int i=0; i<outputs.size(); i++)
+      {
+        if (outputs[i].name.Equals(m_userOutput.c_str()))
+          continue;
+        g_xrandr.TurnOffOutput(outputs[i].name);
+      }
+    }
+
+    XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+    if (mode.id.empty())
+      mode = g_xrandr.GetPreferredMode(m_userOutput);
+    m_bIsRotated = out->isRotated;
+    if (!m_bIsRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = m_userOutput;
   }
   else
 #endif
   {
-    int x11screen = DefaultScreen(m_dpy);
-    int w = DisplayWidth(m_dpy, x11screen);
-    int h = DisplayHeight(m_dpy, x11screen);
+    m_userOutput = "No Output";
+    m_nScreen = DefaultScreen(m_dpy);
+    int w = DisplayWidth(m_dpy, m_nScreen);
+    int h = DisplayHeight(m_dpy, m_nScreen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
-
 #if defined(HAS_XRANDR)
 
+  // erase previous stored modes
+  CDisplaySettings::Get().ClearCustomResolutions();
+
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
-  vector<XOutput>::iterator outiter;
-  vector<XOutput> outs;
-  outs = g_xrandr.GetModes();
-  CLog::Log(LOGINFO, "Number of connected outputs: %"PRIdS"", outs.size());
+
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
   string modename = "";
 
-  for (outiter = outs.begin() ; outiter != outs.end() ; outiter++)
+  if (out != NULL)
   {
-    XOutput out = *outiter;
     vector<XMode>::iterator modeiter;
-    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out.name.c_str(), out.modes.size());
+    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out->name.c_str(), out->modes.size());
 
-    for (modeiter = out.modes.begin() ; modeiter!=out.modes.end() ; modeiter++)
+    for (modeiter = out->modes.begin() ; modeiter!=out->modes.end() ; modeiter++)
     {
       XMode mode = *modeiter;
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
                 mode.id.c_str(), mode.name.c_str(), mode.hz, mode.w, mode.h);
       RESOLUTION_INFO res;
+      res.iScreen = 0; // not used by X11
       res.iWidth  = mode.w;
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
       res.iScreenHeight = mode.h;
-      if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
-        res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
+      if (!m_bIsRotated)
+      {
+        res.iWidth  = mode.w;
+        res.iHeight = mode.h;
+      }
+      else
+      {
+        res.iWidth  = mode.h;
+        res.iHeight = mode.w;
+      }
+      if (mode.h>0 && mode.w>0 && out->hmm>0 && out->wmm>0)
+        res.fPixelRatio = ((float)out->wmm/(float)mode.w) / (((float)out->hmm/(float)mode.h));
       else
         res.fPixelRatio = 1.0f;
 
       CLog::Log(LOGINFO, "Pixel Ratio: %f", res.fPixelRatio);
 
-      res.strMode      = StringUtils::Format("%s: %s @ %.2fHz", out.name.c_str(), mode.name.c_str(), mode.hz);
-      res.strOutput    = out.name;
+      res.strMode      = StringUtils::Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
+      res.strOutput    = out->name;
       res.strId        = mode.id;
-      res.iSubtitles   = (int)(0.95*mode.h);
+      res.iSubtitles   = (int)(0.965*mode.h);
       res.fRefreshRate = mode.hz;
       res.bFullScreen  = true;
 
@@ -300,8 +385,59 @@
       CDisplaySettings::Get().AddResolutionInfo(res);
     }
   }
+  CDisplaySettings::Get().ApplyCalibrations();
 #endif
+}
+
+bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
+{
+  XOutput *out = g_xrandr.GetOutput(m_currentOutput);
+
+  // keep calibrations done on a not connected output
+  if (!out->name.Equals(resInfo.strOutput))
+    return true;
+
+  // keep calibrations not updated with resolution data
+  if (resInfo.iWidth == 0)
+    return true;
+
+  float fPixRatio;
+  if (resInfo.iHeight>0 && resInfo.iWidth>0 && out->hmm>0 && out->wmm>0)
+    fPixRatio = ((float)out->wmm/(float)resInfo.iWidth) / (((float)out->hmm/(float)resInfo.iHeight));
+  else
+    fPixRatio = 1.0f;
+
+  if (resInfo.Overscan.left != 0)
+    return true;
+  if (resInfo.Overscan.top != 0)
+    return true;
+  if (resInfo.Overscan.right != resInfo.iWidth)
+    return true;
+  if (resInfo.Overscan.bottom != resInfo.iHeight)
+    return true;
+  if (resInfo.fPixelRatio != fPixRatio)
+    return true;
+  if (resInfo.iSubtitles != (int)(0.965*resInfo.iHeight))
+    return true;
 
+  return false;
+}
+
+void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
+{
+  vector<XOutput> outs;
+  g_xrandr.Query(true);
+  outs = g_xrandr.GetModes();
+  outputs->push_back("Default");
+  for(unsigned int i=0; i<outs.size(); ++i)
+  {
+    outputs->push_back(outs[i].name);
+  }
+}
+
+bool CWinSystemX11::IsCurrentOutput(CStdString output)
+{
+  return (output.Equals("Default")) || (m_currentOutput.compare(output) == 0);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
@@ -324,20 +460,13 @@
   return true;
 }
 
-bool CWinSystemX11::RefreshGlxContext()
+bool CWinSystemX11::RefreshGlxContext(bool force)
 {
   bool retVal = false;
-  SDL_SysWMinfo info;
-  SDL_VERSION(&info.version);
-  if (SDL_GetWMInfo(&info) <= 0)
-  {
-    CLog::Log(LOGERROR, "Failed to get window manager info from SDL");
-    return false;
-  }
 
-  if(m_glWindow == info.info.x11.window && m_glContext)
+  if (m_glContext && !force)
   {
-    CLog::Log(LOGERROR, "GLX: Same window as before, refreshing context");
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
     return true;
@@ -347,10 +476,8 @@
   XVisualInfo *visuals;
   XVisualInfo *vInfo      = NULL;
   int availableVisuals    = 0;
-  vMask.screen = DefaultScreen(m_dpy);
+  vMask.screen = m_nScreen;
   XWindowAttributes winAttr;
-  m_glWindow = info.info.x11.window;
-  m_wmWindow = info.info.x11.wmwindow;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
      or XGetVisualInfo() fail. That shouldn't happen unless something is
@@ -401,6 +528,8 @@
     {
       glXMakeCurrent(m_dpy, None, NULL);
       glXDestroyContext(m_dpy, m_glContext);
+      XSync(m_dpy, FALSE);
+      m_newGlContext = true;
     }
 
     if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
@@ -421,7 +550,10 @@
 
 void CWinSystemX11::ShowOSMouse(bool show)
 {
-  SDL_ShowCursor(show ? 1 : 0);
+  if (show)
+    XUndefineCursor(m_dpy,m_mainWindow);
+  else if (m_invisibleCursor)
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -435,8 +567,6 @@
     {
       m_screensaverReset.StartZero();
       XResetScreenSaver(m_dpy);
-      //need to flush the output buffer, since we don't check for events on m_dpy
-      XFlush(m_dpy);
     }
   }
   else
@@ -445,20 +575,68 @@
   }
 }
 
+void CWinSystemX11::EnableSystemScreenSaver(bool bEnable)
+{
+  if (!m_dpy)
+    return;
+
+  if (bEnable)
+    XForceScreenSaver(m_dpy, ScreenSaverActive);
+  else
+  {
+    Window root_return, child_return;
+    int root_x_return, root_y_return;
+    int win_x_return, win_y_return;
+    unsigned int mask_return;
+    bool isInWin = XQueryPointer(m_dpy, RootWindow(m_dpy, m_nScreen), &root_return, &child_return,
+                                 &root_x_return, &root_y_return,
+                                 &win_x_return, &win_y_return,
+                                 &mask_return);
+
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return+300, root_y_return+300);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, 0, 0);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return, root_y_return);
+    XSync(m_dpy, FALSE);
+  }
+}
+
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
-  if (bActivated && m_bWasFullScreenBeforeMinimize && !g_graphicsContext.IsFullScreenRoot())
+  if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
+  {
     g_graphicsContext.ToggleFullScreenRoot();
 
+    m_bWasFullScreenBeforeMinimize = false;
+  }
   m_minimized = !bActivated;
 }
+
+void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
+{
+  if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
+      !m_bFullScreen)
+  {
+    m_bWasFullScreenBeforeMinimize = false;
+    g_graphicsContext.ToggleFullScreenRoot();
+    m_minimized = false;
+  }
+  if (!bGaining)
+    m_bIgnoreNextFocusMessage = false;
+}
+
 bool CWinSystemX11::Minimize()
 {
-  m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
+  m_bWasFullScreenBeforeMinimize = m_bFullScreen;
   if (m_bWasFullScreenBeforeMinimize)
+  {
+    m_bIgnoreNextFocusMessage = true;
     g_graphicsContext.ToggleFullScreenRoot();
+  }
+
+  XIconifyWindow(m_dpy, m_mainWindow, m_nScreen);
 
-  SDL_WM_IconifyWindow();
   m_minimized = true;
   return true;
 }
@@ -468,13 +646,13 @@
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_wmWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_wmWindow);
+  XMapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -482,7 +660,7 @@
 
 void CWinSystemX11::CheckDisplayEvents()
 {
-#if defined(HAS_XRANDR)
+#if defined(HAS_XRANDR) && defined(HAS_SDL_VIDEO_X11)
   bool bGotEvent(false);
   bool bTimeout(false);
   XEvent Event;
@@ -505,13 +683,7 @@
 
   if (bGotEvent || bTimeout)
   {
-    CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-
-    CSingleLock lock(m_resourceSection);
-
-    // tell any shared resources
-    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-      (*i)->OnResetDevice();
+    NotifyXRREvent();
 
     // reset fail safe timer
     m_dpyLostTime = 0;
@@ -519,6 +691,61 @@
 #endif
 }
 
+void CWinSystemX11::NotifyXRREvent()
+{
+  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  m_windowDirty = true;
+
+  CSingleLock lock(g_graphicsContext);
+
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+
+  // if external event update resolutions
+  if (!m_bIsInternalXrr)
+  {
+    UpdateResolutions();
+  }
+  m_bIsInternalXrr = false;
+
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(m_userOutput);
+
+  if (out)
+    CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
+             , out->name.c_str(), mode.id.c_str(), mode.hz);
+  else
+    CLog::Log(LOGWARNING, "%s - output name not set", __FUNCTION__);
+
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    res = CDisplaySettings::Get().GetResolutionInfo(i);
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId.Equals(mode.id))
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    i = RES_DESKTOP;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
+
+}
+
 void CWinSystemX11::OnLostDevice()
 {
   CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
@@ -531,8 +758,12 @@
       (*i)->OnLostDevice();
   }
 
+#if defined(HAS_SDL_VIDEO_X11)
   // fail safe timer
   m_dpyLostTime = CurrentHostCounter();
+#else
+  CWinEventsX11Imp::SetXRRFailSafeTimer(3000);
+#endif
 }
 
 void CWinSystemX11::Register(IDispResource *resource)
@@ -564,37 +795,396 @@
   return m_minimized;
 }
 
-void CWinSystemX11::SetGrabMode(const CSetting *setting /*= NULL*/)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const std::string &output)
 {
-  bool enabled;
-  if (setting)
-    enabled = ((CSettingBool*)setting)->GetValue();
-  else
-    enabled = CSettings::Get().GetBool("input.enablesystemkeys");
-    
-  if (m_SDLSurface && m_SDLSurface->flags & SDL_FULLSCREEN)
-  {
-    if (enabled)
-    {
-      //SDL will always call XGrabPointer and XGrabKeyboard when in fullscreen
-      //so temporarily zero the SDL_FULLSCREEN flag, then turn off SDL grab mode
-      //this will make SDL call XUnGrabPointer and XUnGrabKeyboard
-      m_SDLSurface->flags &= ~SDL_FULLSCREEN;
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
-      m_SDLSurface->flags |= SDL_FULLSCREEN;
+  bool changeWindow = false;
+  bool changeSize = false;
+  bool mouseActive = false;
+  float mouseX, mouseY;
+
+  if (m_mainWindow && ((m_bFullScreen != fullscreen) || m_currentOutput.compare(output) != 0 || m_windowDirty))
+  {
+    mouseActive = g_Mouse.IsActive();
+    if (mouseActive)
+    {
+      Window root_return, child_return;
+      int root_x_return, root_y_return;
+      int win_x_return, win_y_return;
+      unsigned int mask_return;
+      bool isInWin = XQueryPointer(m_dpy, m_mainWindow, &root_return, &child_return,
+                                   &root_x_return, &root_y_return,
+                                   &win_x_return, &win_y_return,
+                                   &mask_return);
+      if (isInWin)
+      {
+        mouseX = (float)win_x_return/m_nWidth;
+        mouseY = (float)win_y_return/m_nHeight;
+        g_Mouse.SetActive(false);
+      }
+      else
+        mouseActive = false;
     }
-    else
+    OnLostDevice();
+    DestroyWindow();
+    m_windowDirty = true;
+  }
+
+  // create main window
+  if (!m_mainWindow)
+  {
+    EnableSystemScreenSaver(false);
+
+    GLint att[] =
+    {
+      GLX_RGBA,
+      GLX_RED_SIZE, 8,
+      GLX_GREEN_SIZE, 8,
+      GLX_BLUE_SIZE, 8,
+      GLX_ALPHA_SIZE, 8,
+      GLX_DEPTH_SIZE, 24,
+      GLX_DOUBLEBUFFER,
+      None
+    };
+    Colormap cmap;
+    XSetWindowAttributes swa;
+    XVisualInfo *vi;
+    int x0 = 0;
+    int y0 = 0;
+
+    XOutput *out = g_xrandr.GetOutput(output);
+    if (!out)
+      out = g_xrandr.GetOutput(m_currentOutput);
+    if (out)
+    {
+      m_nScreen = out->screen;
+      x0 = out->x;
+      y0 = out->y;
+    }
+
+    vi = glXChooseVisual(m_dpy, m_nScreen, att);
+    cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
+
+    bool hasWM = HasWindowManager();
+
+    int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
+    swa.override_redirect = hasWM ? False : True;
+    swa.border_pixel = fullscreen ? 0 : 5;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.colormap = cmap;
+    swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
+                     ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
+                     PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
+                     EnterWindowMask | LeaveWindowMask | ExposureMask;
+    unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
+
+    m_mainWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+                    x0, y0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    swa.override_redirect = False;
+    swa.border_pixel = 0;
+    swa.event_mask = ExposureMask;
+    mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWColormap | CWEventMask;
+
+    m_glWindow = XCreateWindow(m_dpy, m_mainWindow,
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    if (fullscreen && hasWM)
+    {
+      Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
+      XChangeProperty(m_dpy, m_mainWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+    }
+
+    // define invisible cursor
+    Pixmap bitmapNoData;
+    XColor black;
+    static char noData[] = { 0,0,0,0,0,0,0,0 };
+    black.red = black.green = black.blue = 0;
+
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_mainWindow, noData, 8, 8);
+    m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
+                                            &black, &black, 0, 0);
+    XFreePixmap(m_dpy, bitmapNoData);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
+
+    //init X11 events
+    CWinEventsX11Imp::Init(m_dpy, m_mainWindow);
+
+    changeWindow = true;
+    changeSize = true;
+  }
+
+  if (!CWinEventsX11Imp::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
+  {
+    changeSize = true;
+  }
+
+  if (changeSize || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_mainWindow, width, height);
+  }
+
+  if ((width != m_nWidth) || (height != m_nHeight) || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_glWindow, width, height);
+  }
+
+  if (changeWindow)
+  {
+    m_icon = None;
+    {
+      CreateIconPixmap();
+      XWMHints *wm_hints;
+      XClassHint *class_hints;
+      XTextProperty windowName, iconName;
+      std::string titleString = "XBMC Media Center";
+      std::string classString = "xbmc.bin";
+      char *title = (char*)titleString.c_str();
+
+      XStringListToTextProperty(&title, 1, &windowName);
+      XStringListToTextProperty(&title, 1, &iconName);
+
+      wm_hints = XAllocWMHints();
+      wm_hints->initial_state = NormalState;
+      wm_hints->icon_pixmap = m_icon;
+      wm_hints->flags = StateHint | IconPixmapHint;
+
+      class_hints = XAllocClassHint();
+      class_hints->res_class = (char*)classString.c_str();
+      class_hints->res_name = (char*)classString.c_str();
+
+      XSync(m_dpy,False);
+      XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
+                            NULL, 0, NULL, wm_hints,
+                            class_hints);
+      XFree(class_hints);
+      XFree(wm_hints);
+
+      // register interest in the delete window message
+      Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
+      XSetWMProtocols(m_dpy, m_mainWindow, &wmDeleteMessage, 1);
+    }
+    XMapRaised(m_dpy, m_glWindow);
+    XMapRaised(m_dpy, m_mainWindow);
+    XSync(m_dpy,TRUE);
+
+    if (changeWindow && mouseActive)
+    {
+      XWarpPointer(m_dpy, None, m_mainWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+    }
+
+    CDirtyRegionList dr;
+    RefreshGlxContext(m_currentOutput.compare(output) != 0);
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    g_Windowing.ResetVSync();
+    m_windowDirty = false;
+
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnResetDevice();
+  }
+
+  return true;
+}
+
+bool CWinSystemX11::CreateIconPixmap()
+{
+  int depth;
+  XImage *img = NULL;
+  Visual *vis;
+  XWindowAttributes wndattribs;
+  XVisualInfo visInfo;
+  double rRatio;
+  double gRatio;
+  double bRatio;
+  int outIndex = 0;
+  int i,j;
+  int numBufBytes;
+  unsigned char *buf;
+  uint32_t *newBuf = 0;
+  size_t numNewBufBytes;
+
+  // Get visual Info
+  XGetWindowAttributes(m_dpy, m_glWindow, &wndattribs);
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_dpy, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  depth = visInfo.depth;
+  vis = visInfo.visual;
+
+  if (depth < 15)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - no suitable depth");
+    return false;
+  }
+
+  rRatio = vis->red_mask / 255.0;
+  gRatio = vis->green_mask / 255.0;
+  bRatio = vis->blue_mask / 255.0;
+
+  CBaseTexture *iconTexture = CBaseTexture::LoadFromFile("special://xbmc/media/icon.png");
+
+  if (!iconTexture)
+    return false;
+
+  buf = iconTexture->GetPixels();
+
+  numBufBytes = iconTexture->GetWidth() * iconTexture->GetHeight() * 4;
+  int wid = iconTexture->GetWidth();
+  int hi = iconTexture->GetHeight();
+
+  if (depth>=24)
+    numNewBufBytes = (4 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
+  else
+    numNewBufBytes = (2 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
+
+  newBuf = (uint32_t*)malloc(numNewBufBytes);
+  if (!newBuf)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - malloc failed");
+    return false;
+  }
+
+  for (i=0; i<iconTexture->GetHeight();++i)
+  {
+    for (j=0; j<iconTexture->GetWidth();++j)
     {
-      //turn off key grabbing, which will actually make SDL turn it on when in fullscreen
-      SDL_WM_GrabInput(SDL_GRAB_OFF);
+      unsigned int pos = i*iconTexture->GetPitch()+j*4;
+      unsigned int r, g, b;
+      r = (buf[pos+2] * rRatio);
+      g = (buf[pos+1] * gRatio);
+      b = (buf[pos+0] * bRatio);
+      r &= vis->red_mask;
+      g &= vis->green_mask;
+      b &= vis->blue_mask;
+      newBuf[outIndex] = r | g | b;
+      ++outIndex;
     }
   }
+  img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
+                     iconTexture->GetWidth(), iconTexture->GetHeight(),
+                     (depth>=24)?32:16, 0);
+  if (!img)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not create image");
+    free(newBuf);
+    return false;
+  }
+  if (!XInitImage(img))
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - init image failed");
+    XDestroyImage(img);
+    return false;
+  }
+
+  // set byte order
+  union
+  {
+    char c[sizeof(short)];
+    short s;
+  } order;
+  order.s = 1;
+  if ((1 == order.c[0]))
+  {
+    img->byte_order = LSBFirst;
+  }
+  else
+  {
+    img->byte_order = MSBFirst;
+  }
+
+  // create icon pixmap from image
+  m_icon = XCreatePixmap(m_dpy, m_glWindow, img->width, img->height, depth);
+  GC gc = XCreateGC(m_dpy, m_glWindow, 0, NULL);
+  XPutImage(m_dpy, m_icon, gc, img, 0, 0, 0, 0, img->width, img->height);
+  XFreeGC(m_dpy, gc);
+  XDestroyImage(img); // this also frees newBuf
+
+  delete iconTexture;
+
+  return true;
 }
 
-void CWinSystemX11::OnSettingChanged(const CSetting *setting)
+bool CWinSystemX11::HasWindowManager()
 {
-  if (setting->GetId() == "input.enablesystemkeys")
-    SetGrabMode(setting);
+  Window wm_check;
+  unsigned char *data;
+  int status, real_format;
+  Atom real_type, prop;
+  unsigned long items_read, items_left, i;
+  char req = 0;
+
+  prop = XInternAtom(m_dpy, "_NET_SUPPORTING_WM_CHECK", True);
+  if (prop == None)
+    return false;
+  status = XGetWindowProperty(m_dpy, DefaultRootWindow(m_dpy), prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+  if(status != Success || ! items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  wm_check = ((Window*)data)[0];
+  XFree(data);
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+
+  if(status != Success || !items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  if(wm_check != ((Window*)data)[0])
+  {
+    XFree(data);
+    return false;
+  }
+
+  XFree(data);
+
+  prop = XInternAtom(m_dpy, "_NET_WM_NAME", True);
+  if (prop == None)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+    return true;
+  }
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                        0L, (~0L), False, AnyPropertyType, &real_type, &real_format,
+                        &items_read, &items_left, &data);
+
+  if(status == Success && items_read)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: %s", data);
+  }
+  else
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+
+  if(status == Success)
+    XFree(data);
+
+  return true;
 }
 
 #endif
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11GL.cpp xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11GL.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11GL.cpp	2013-11-18 01:12:17.764950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11GL.cpp	2013-11-18 01:14:00.768953051 +0800
@@ -24,6 +24,7 @@
 #include "WinSystemX11GL.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
+#include "Application.h"
 
 CWinSystemX11GL::CWinSystemX11GL()
 {
@@ -31,8 +32,7 @@
   m_glXWaitVideoSyncSGI  = NULL;
   m_glXSwapIntervalSGI   = NULL;
   m_glXSwapIntervalMESA  = NULL;
-  m_glXGetSyncValuesOML  = NULL;
-  m_glXSwapBuffersMscOML = NULL;
+  m_glXSwapIntervalEXT   = NULL;
 
   m_iVSyncErrors = 0;
 }
@@ -108,14 +108,6 @@
       m_iVSyncErrors = 0;
     }
   }
-  else if (m_iVSyncMode == 5)
-  {
-    int64_t ust, msc, sbc;
-    if(m_glXGetSyncValuesOML(m_dpy, m_glWindow, &ust, &msc, &sbc))
-      m_glXSwapBuffersMscOML(m_dpy, m_glWindow, msc, 0, 0);
-    else
-      CLog::Log(LOGERROR, "%s - glXSwapBuffersMscOML - Failed to get current retrace count", __FUNCTION__);
-  }
   else
     glXSwapBuffers(m_dpy, m_glWindow);
 
@@ -125,41 +117,31 @@
 void CWinSystemX11GL::SetVSyncImpl(bool enable)
 {
   /* turn of current setting first */
-  if(m_glXSwapIntervalSGI)
-    m_glXSwapIntervalSGI(0);
-  if(m_glXSwapIntervalMESA)
+  if(m_glXSwapIntervalEXT)
+    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 0);
+  else if(m_glXSwapIntervalMESA)
     m_glXSwapIntervalMESA(0);
+  else if(m_glXSwapIntervalSGI)
+    m_glXSwapIntervalSGI(0);
 
   m_iVSyncErrors = 0;
 
-  CStdString strVendor(m_RenderVendor);
-  StringUtils::ToLower(strVendor);
-
   if(!enable)
     return;
 
-  bool vendor_nvidia = strVendor.find("nvidia") != std::string::npos;
-  bool vendor_ati    = StringUtils::StartsWith(strVendor, "ati");
-
-  if (m_glXSwapIntervalMESA && !m_iVSyncMode && vendor_ati)
+  if (m_glXSwapIntervalEXT && !m_iVSyncMode)
+  {
+    m_glXSwapIntervalEXT(m_dpy, m_glWindow, 1);
+    m_iVSyncMode = 6;
+  }
+  if (m_glXSwapIntervalMESA && !m_iVSyncMode)
   {
     if(m_glXSwapIntervalMESA(1) == 0)
       m_iVSyncMode = 2;
     else
       CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
   }
-
-  if(m_glXGetSyncValuesOML && m_glXSwapBuffersMscOML && m_glXSwapIntervalMESA && !m_iVSyncMode)
-  {
-    m_glXSwapIntervalMESA(1);
-
-    int64_t ust, msc, sbc;
-    if(m_glXGetSyncValuesOML(m_dpy, m_glWindow, &ust, &msc, &sbc))
-      m_iVSyncMode = 5;
-    else
-      CLog::Log(LOGWARNING, "%s - glXGetSyncValuesOML failed", __FUNCTION__);
-  }
-  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !m_iVSyncMode && !vendor_nvidia)
+  if (m_glXWaitVideoSyncSGI && m_glXGetVideoSyncSGI && !m_iVSyncMode)
   {
     unsigned int count;
     if(m_glXGetVideoSyncSGI(&count) == 0)
@@ -174,14 +156,6 @@
     else
       CLog::Log(LOGWARNING, "%s - glXSwapIntervalSGI failed", __FUNCTION__);
   }
-  if (m_glXSwapIntervalMESA && !m_iVSyncMode && !vendor_ati)
-  {
-    if(m_glXSwapIntervalMESA(1) == 0)
-      m_iVSyncMode = 2;
-    else
-      CLog::Log(LOGWARNING, "%s - glXSwapIntervalMESA failed", __FUNCTION__);
-  }
-
 }
 
 bool CWinSystemX11GL::IsExtSupported(const char* extension)
@@ -204,22 +178,11 @@
     return false;
 
   m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, DefaultScreen(m_dpy));
+  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
   m_glxext += " ";
 
   CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
 
-  /* any time window is recreated we need new pointers */
-  if (IsExtSupported("GLX_OML_sync_control"))
-    m_glXGetSyncValuesOML = (Bool (*)(Display*, GLXDrawable, int64_t*, int64_t*, int64_t*))glXGetProcAddress((const GLubyte*)"glXGetSyncValuesOML");
-  else
-    m_glXGetSyncValuesOML = NULL;
-
-  if (IsExtSupported("GLX_OML_sync_control"))
-    m_glXSwapBuffersMscOML = (int64_t (*)(Display*, GLXDrawable, int64_t, int64_t, int64_t))glXGetProcAddress((const GLubyte*)"glXSwapBuffersMscOML");
-  else
-    m_glXSwapBuffersMscOML = NULL;
-
   if (IsExtSupported("GLX_SGI_video_sync"))
     m_glXWaitVideoSyncSGI = (int (*)(int, int, unsigned int*))glXGetProcAddress((const GLubyte*)"glXWaitVideoSyncSGI");
   else
@@ -240,23 +203,35 @@
   else
     m_glXSwapIntervalMESA = NULL;
 
+  if (IsExtSupported("GLX_EXT_swap_control"))
+    m_glXSwapIntervalEXT = (PFNGLXSWAPINTERVALEXTPROC)glXGetProcAddress((const GLubyte*)"glXSwapIntervalEXT");
+  else
+    m_glXSwapIntervalEXT = NULL;
 
   return true;
 }
 
 bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_newGlContext = false;
   CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
   CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
 bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
+  m_newGlContext = false;
   CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
   CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11GL.h xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11GL.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11GL.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11GL.h	2013-11-18 01:14:00.768953051 +0800
@@ -47,9 +47,7 @@
   int (*m_glXWaitVideoSyncSGI)(int, int, unsigned int*);
   int (*m_glXSwapIntervalSGI)(int);
   int (*m_glXSwapIntervalMESA)(int);
-
-  Bool    (*m_glXGetSyncValuesOML)(Display* dpy, GLXDrawable drawable, int64_t* ust, int64_t* msc, int64_t* sbc);
-  int64_t (*m_glXSwapBuffersMscOML)(Display* dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor,int64_t remainder);
+  PFNGLXSWAPINTERVALEXTPROC m_glXSwapIntervalEXT;
 
   int m_iVSyncErrors;
 };
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11.h xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/WinSystemX11.h	2013-11-18 01:12:17.764950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/WinSystemX11.h	2013-11-18 01:14:00.760953052 +0800
@@ -49,11 +49,14 @@
   virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
   virtual void UpdateResolutions();
   virtual int  GetNumScreens() { return 1; }
+  virtual int  GetCurrentScreen() { return m_nScreen; }
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
+  virtual void EnableSystemScreenSaver(bool bEnable);
 
   virtual void NotifyAppActiveChange(bool bActivated);
+  virtual void NotifyAppFocusChange(bool bGaining);
 
   virtual bool Minimize();
   virtual bool Restore() ;
@@ -61,34 +64,46 @@
   virtual bool Show(bool raise = true);
   virtual void Register(IDispResource *resource);
   virtual void Unregister(IDispResource *resource);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo);
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  virtual void OnSettingChanged(const CSetting *setting);
+  void NotifyXRREvent();
+  void GetConnectedOutputs(std::vector<CStdString> *outputs);
+  bool IsCurrentOutput(CStdString output);
 
 protected:
-  bool RefreshGlxContext();
+  bool RefreshGlxContext(bool force);
   void CheckDisplayEvents();
   void OnLostDevice();
+  bool SetWindow(int width, int height, bool fullscreen, const std::string &output);
 
-  SDL_Surface* m_SDLSurface;
+  Window       m_glWindow, m_mainWindow;
   GLXContext   m_glContext;
-  GLXWindow    m_glWindow;
-  Window       m_wmWindow;
   Display*     m_dpy;
+  Cursor       m_invisibleCursor;
+  Pixmap       m_icon;
+  bool         m_bIsRotated;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
+  bool         m_bIgnoreNextFocusMessage;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
+  std::string                  m_currentOutput;
+  std::string                  m_userOutput;
+  bool                         m_windowDirty;
+  bool                         m_bIsInternalXrr;
+  bool                         m_newGlContext;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
-  void SetGrabMode(const CSetting *setting = NULL);
+  bool CreateIconPixmap();
+  bool HasWindowManager();
 
   CStopWatch m_screensaverReset;
 };
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/XRandR.cpp xbmc-13.0-r9b3ff66/xbmc/windowing/X11/XRandR.cpp
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/XRandR.cpp	2013-11-18 01:12:17.764950380 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/XRandR.cpp	2013-11-18 01:14:03.220953116 +0800
@@ -29,6 +29,7 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/StringUtils.h"
 #include "../xbmc/utils/log.h"
+#include "threads/SystemClock.h"
 
 #if defined(TARGET_FREEBSD)
 #include <sys/types.h>
@@ -40,11 +41,12 @@
 CXRandR::CXRandR(bool query)
 {
   m_bInit = false;
+  m_numScreens = 1;
   if (query)
     Query();
 }
 
-bool CXRandR::Query(bool force)
+bool CXRandR::Query(bool force, bool ignoreoff)
 {
   if (!force)
     if (m_bInit)
@@ -56,11 +58,23 @@
     return false;
 
   m_outputs.clear();
-  m_current.clear();
+  // query all screens
+  // we are happy if at least one screen returns results
+  bool success = false;
+  for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
+  {
+    if(Query(force, screennum, ignoreoff))
+      success = true;
+  }
+  return success;
+}
 
+bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
+{
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
+  cmd = StringUtils::Format("%s -q --screen %d", cmd.c_str(), screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
@@ -80,7 +94,7 @@
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != 0)
+  if (atoi(pRootElement->Attribute("id")) != screennum)
   {
     // TODO ERROR
     return false;
@@ -92,12 +106,20 @@
     xoutput.name = output->Attribute("name");
     StringUtils::Trim(xoutput.name);
     xoutput.isConnected = (strcasecmp(output->Attribute("connected"), "true") == 0);
+    xoutput.screen = screennum;
     xoutput.w = (output->Attribute("w") != NULL ? atoi(output->Attribute("w")) : 0);
     xoutput.h = (output->Attribute("h") != NULL ? atoi(output->Attribute("h")) : 0);
     xoutput.x = (output->Attribute("x") != NULL ? atoi(output->Attribute("x")) : 0);
     xoutput.y = (output->Attribute("y") != NULL ? atoi(output->Attribute("y")) : 0);
     xoutput.wmm = (output->Attribute("wmm") != NULL ? atoi(output->Attribute("wmm")) : 0);
     xoutput.hmm = (output->Attribute("hmm") != NULL ? atoi(output->Attribute("hmm")) : 0);
+    if (output->Attribute("rotation") != NULL
+        && (strcasecmp(output->Attribute("rotation"), "left") == 0 || strcasecmp(output->Attribute("rotation"), "right") == 0))
+    {
+      xoutput.isRotated = true;
+    }
+    else
+      xoutput.isRotated = false;
 
     if (!xoutput.isConnected)
        continue;
@@ -115,12 +137,9 @@
       xmode.isCurrent = (strcasecmp(mode->Attribute("current"), "true") == 0);
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
-      {
-        m_current.push_back(xoutput);
         hascurrent = true;
-      }
     }
-    if (hascurrent)
+    if (hascurrent || !ignoreoff)
       m_outputs.push_back(xoutput);
     else
       CLog::Log(LOGWARNING, "CXRandR::Query - output %s has no current mode, assuming disconnected", xoutput.name.c_str());
@@ -128,39 +147,89 @@
   return m_outputs.size() > 0;
 }
 
-std::vector<XOutput> CXRandR::GetModes(void)
+bool CXRandR::TurnOffOutput(CStdString name)
 {
-  Query();
-  return m_outputs;
-}
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
 
-void CXRandR::SaveState()
-{
-  Query(true);
+  CStdString cmd;
+  cmd  = getenv("XBMC_BIN_HOME");
+  cmd += "/xbmc-xrandr";
+  cmd = StringUtils::Format("%s --screen %d --output %s --off", cmd.c_str(), output->screen, name.c_str());
+
+  int status = system(cmd.c_str());
+  if (status == -1)
+    return false;
+
+  if (WEXITSTATUS(status) != 0)
+    return false;
+
+  return true;
 }
 
-void CXRandR::RestoreState()
+bool CXRandR::TurnOnOutput(CStdString name)
 {
-  vector<XOutput>::iterator outiter;
-  for (outiter=m_current.begin() ; outiter!=m_current.end() ; outiter++)
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
+  XMode mode = GetCurrentMode(output->name);
+  if (mode.isCurrent)
+    return true;
+
+  // get preferred mode
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
   {
-    vector<XMode> modes = (*outiter).modes;
-    vector<XMode>::iterator modeiter;
-    for (modeiter=modes.begin() ; modeiter!=modes.end() ; modeiter++)
+    if (m_outputs[j].name == output->name)
     {
-      XMode mode = *modeiter;
-      if (mode.isCurrent)
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
       {
-        SetMode(*outiter, mode);
-        return;
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          mode = m_outputs[j].modes[i];
+          break;
+        }
       }
     }
   }
+
+  if (!mode.isPreferred)
+    return false;
+
+  if (!SetMode(*output, mode))
+    return false;
+
+  XbmcThreads::EndTime timeout(5000);
+  while (!timeout.IsTimePast())
+  {
+    if (!Query(true))
+      return false;
+
+    output = GetOutput(name);
+    if (output && output->h > 0)
+      return true;
+
+    Sleep(200);
+  }
+
+  return false;
+}
+
+std::vector<XOutput> CXRandR::GetModes(void)
+{
+  Query();
+  return m_outputs;
+}
+
+void CXRandR::SaveState()
+{
+  Query(true);
 }
 
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
-  if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
+  if ((output.name == "" && mode.id == ""))
     return true;
 
   Query();
@@ -245,7 +314,7 @@
   m_currentMode = modeFound.id;
   char cmd[255];
   if (getenv("XBMC_BIN_HOME"))
-    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.name.c_str(), modeFound.id.c_str());
+    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --screen %d --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.screen, outputFound.name.c_str(), modeFound.id.c_str());
   else
     return false;
   CLog::Log(LOGINFO, "XRANDR: %s", cmd);
@@ -259,18 +328,30 @@
   return true;
 }
 
-XOutput CXRandR::GetCurrentOutput()
+XMode CXRandR::GetCurrentMode(CStdString outputName)
 {
   Query();
+  XMode result;
+
   for (unsigned int j = 0; j < m_outputs.size(); j++)
   {
-    if(m_outputs[j].isConnected)
-      return m_outputs[j];
+    if (m_outputs[j].name == outputName || outputName == "")
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isCurrent)
+        {
+          result = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
   }
-  XOutput empty;
-  return empty;
+
+  return result;
 }
-XMode CXRandR::GetCurrentMode(CStdString outputName)
+
+XMode CXRandR::GetPreferredMode(CStdString outputName)
 {
   Query();
   XMode result;
@@ -281,7 +362,7 @@
     {
       for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
       {
-        if (m_outputs[j].modes[i].isCurrent)
+        if (m_outputs[j].modes[i].isPreferred)
         {
           result = m_outputs[j].modes[i];
           break;
@@ -341,6 +422,43 @@
   }
 }
 
+void CXRandR::SetNumScreens(unsigned int num)
+{
+  m_numScreens = num;
+  m_bInit = false;
+}
+
+bool CXRandR::IsOutputConnected(CStdString name)
+{
+  bool result = false;
+  Query();
+
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == name)
+    {
+      result = true;
+      break;
+    }
+  }
+  return result;
+}
+
+XOutput* CXRandR::GetOutput(CStdString outputName)
+{
+  XOutput *result = 0;
+  Query();
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == outputName)
+    {
+      result = &m_outputs[i];
+      break;
+    }
+  }
+  return result;
+}
+
 CXRandR g_xrandr;
 
 #endif // HAS_XRANDR
diff -uNr xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/XRandR.h xbmc-13.0-r9b3ff66/xbmc/windowing/X11/XRandR.h
--- xbmc-13.0-r9b3ff66.orig/xbmc/windowing/X11/XRandR.h	2013-11-02 15:21:34.000000000 +0800
+++ xbmc-13.0-r9b3ff66/xbmc/windowing/X11/XRandR.h	2013-11-18 01:14:00.684953050 +0800
@@ -79,6 +79,7 @@
     }
   CStdString name;
   bool isConnected;
+  int screen;
   int w;
   int h;
   int x;
@@ -86,20 +87,26 @@
   int wmm;
   int hmm;
   std::vector<XMode> modes;
+  bool isRotated;
 };
 
 class CXRandR
 {
 public:
   CXRandR(bool query=false);
-  bool Query(bool force=false);
+  bool Query(bool force=false, bool ignoreoff=true);
+  bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
-  XOutput GetCurrentOutput();
   XMode   GetCurrentMode(CStdString outputName);
+  XMode   GetPreferredMode(CStdString outputName);
+  XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
-  void RestoreState();
+  void SetNumScreens(unsigned int num);
+  bool IsOutputConnected(CStdString name);
+  bool TurnOffOutput(CStdString name);
+  bool TurnOnOutput(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
@@ -107,10 +114,10 @@
 
 private:
   bool m_bInit;
-  std::vector<XOutput> m_current;
   std::vector<XOutput> m_outputs;
   CStdString m_currentOutput;
   CStdString m_currentMode;
+  unsigned int m_numScreens;
 };
 
 extern CXRandR g_xrandr;
