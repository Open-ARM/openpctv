diff -uNr vdr-2.1.1.orig/device.c vdr-2.1.1/device.c
--- vdr-2.1.1.orig/device.c	2013-08-27 09:01:07.038908453 +0800
+++ vdr-2.1.1/device.c	2013-08-27 09:01:27.686907589 +0800
@@ -729,6 +729,7 @@
      cChannel *channel;
      while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
            // try only channels which are currently available
+           if (!cStatus::MsgChannelProtected(0, channel))      // PIN PATCH
            if (GetDevice(channel, LIVEPRIORITY, true, true))
               break;
            n = channel->Number() + Direction;
@@ -750,6 +751,12 @@
 
 eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
 {
+  // I hope 'LiveView = false' indicates a channel switch for recording, // PIN PATCH
+  // I really don't know, but it works ...                               // PIN PATCH
+
+  if (LiveView && cStatus::MsgChannelProtected(this, Channel))           // PIN PATCH
+     return scrNotAvailable;                                             // PIN PATCH
+
   cStatus::MsgChannelSwitch(this, 0, LiveView);
 
   if (LiveView) {
diff -uNr vdr-2.1.1.orig/device.c.orig vdr-2.1.1/device.c.orig
--- vdr-2.1.1.orig/device.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ vdr-2.1.1/device.c.orig	2013-08-27 09:01:07.038908453 +0800
@@ -0,0 +1,1811 @@
+/*
+ * device.c: The basic device interface
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: device.c 3.3 2013/08/22 10:28:55 kls Exp $
+ */
+
+#include "device.h"
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include "audio.h"
+#include "channels.h"
+#include "i18n.h"
+#include "player.h"
+#include "receiver.h"
+#include "status.h"
+#include "transfer.h"
+#include "vdrttxtsubshooks.h"
+
+// --- cLiveSubtitle ---------------------------------------------------------
+
+class cLiveSubtitle : public cReceiver {
+protected:
+  virtual void Receive(uchar *Data, int Length);
+public:
+  cLiveSubtitle(int SPid);
+  virtual ~cLiveSubtitle();
+  };
+
+cLiveSubtitle::cLiveSubtitle(int SPid)
+{
+  AddPid(SPid);
+}
+
+cLiveSubtitle::~cLiveSubtitle()
+{
+  cReceiver::Detach();
+}
+
+void cLiveSubtitle::Receive(uchar *Data, int Length)
+{
+  if (cDevice::PrimaryDevice())
+     cDevice::PrimaryDevice()->PlayTs(Data, Length);
+}
+
+// --- cDeviceHook -----------------------------------------------------------
+
+cDeviceHook::cDeviceHook(void)
+{
+  cDevice::deviceHooks.Add(this);
+}
+
+bool cDeviceHook::DeviceProvidesTransponder(const cDevice *Device, const cChannel *Channel) const
+{
+  return true;
+}
+
+// --- cDevice ---------------------------------------------------------------
+
+// The minimum number of unknown PS1 packets to consider this a "pre 1.3.19 private stream":
+#define MIN_PRE_1_3_19_PRIVATESTREAM 10
+
+int cDevice::numDevices = 0;
+int cDevice::useDevice = 0;
+int cDevice::nextCardIndex = 0;
+int cDevice::currentChannel = 1;
+cDevice *cDevice::device[MAXDEVICES] = { NULL };
+cDevice *cDevice::primaryDevice = NULL;
+cList<cDeviceHook> cDevice::deviceHooks;
+
+cDevice::cDevice(void)
+:patPmtParser(true)
+{
+  cardIndex = nextCardIndex++;
+  dsyslog("new device number %d", CardIndex() + 1);
+
+  SetDescription("receiver on device %d", CardIndex() + 1);
+
+  mute = false;
+  volume = Setup.CurrentVolume;
+
+  sectionHandler = NULL;
+  eitFilter = NULL;
+  patFilter = NULL;
+  sdtFilter = NULL;
+  nitFilter = NULL;
+
+  camSlot = NULL;
+  startScrambleDetection = 0;
+
+  occupiedTimeout = 0;
+
+  player = NULL;
+  isPlayingVideo = false;
+  keepTracks = false; // used in ClrAvailableTracks()!
+  ClrAvailableTracks();
+  currentAudioTrack = ttNone;
+  currentAudioTrackMissingCount = 0;
+  currentSubtitleTrack = ttNone;
+  liveSubtitle = NULL;
+  dvbSubtitleConverter = NULL;
+  autoSelectPreferredSubtitleLanguage = true;
+
+  for (int i = 0; i < MAXRECEIVERS; i++)
+      receiver[i] = NULL;
+
+  if (numDevices < MAXDEVICES)
+     device[numDevices++] = this;
+  else
+     esyslog("ERROR: too many devices!");
+}
+
+cDevice::~cDevice()
+{
+  Detach(player);
+  DetachAllReceivers();
+  delete liveSubtitle;
+  delete dvbSubtitleConverter;
+  if (this == primaryDevice)
+     primaryDevice = NULL;
+}
+
+bool cDevice::WaitForAllDevicesReady(int Timeout)
+{
+  for (time_t t0 = time(NULL); time(NULL) - t0 < Timeout; ) {
+      bool ready = true;
+      for (int i = 0; i < numDevices; i++) {
+          if (device[i] && !device[i]->Ready()) {
+             ready = false;
+             cCondWait::SleepMs(100);
+             }
+          }
+      if (ready)
+         return true;
+      }
+  return false;
+}
+
+void cDevice::SetUseDevice(int n)
+{
+  if (n < MAXDEVICES)
+     useDevice |= (1 << n);
+}
+
+int cDevice::NextCardIndex(int n)
+{
+  if (n > 0) {
+     nextCardIndex += n;
+     if (nextCardIndex >= MAXDEVICES)
+        esyslog("ERROR: nextCardIndex too big (%d)", nextCardIndex);
+     }
+  else if (n < 0)
+     esyslog("ERROR: invalid value in nextCardIndex(%d)", n);
+  return nextCardIndex;
+}
+
+int cDevice::DeviceNumber(void) const
+{
+  for (int i = 0; i < numDevices; i++) {
+      if (device[i] == this)
+         return i;
+      }
+  return -1;
+}
+
+cString cDevice::DeviceType(void) const
+{
+  return "";
+}
+
+cString cDevice::DeviceName(void) const
+{
+  return "";
+}
+
+void cDevice::MakePrimaryDevice(bool On)
+{
+  if (!On) {
+     DELETENULL(liveSubtitle);
+     DELETENULL(dvbSubtitleConverter);
+     }
+}
+
+bool cDevice::SetPrimaryDevice(int n)
+{
+  n--;
+  if (0 <= n && n < numDevices && device[n]) {
+     isyslog("setting primary device to %d", n + 1);
+     if (primaryDevice)
+        primaryDevice->MakePrimaryDevice(false);
+     primaryDevice = device[n];
+     primaryDevice->MakePrimaryDevice(true);
+     primaryDevice->SetVideoFormat(Setup.VideoFormat);
+     primaryDevice->SetVolumeDevice(Setup.CurrentVolume);
+     return true;
+     }
+  esyslog("ERROR: invalid primary device number: %d", n + 1);
+  return false;
+}
+
+bool cDevice::HasDecoder(void) const
+{
+  return false;
+}
+
+cSpuDecoder *cDevice::GetSpuDecoder(void)
+{
+  return NULL;
+}
+
+cDevice *cDevice::ActualDevice(void)
+{
+  cDevice *d = cTransferControl::ReceiverDevice();
+  if (!d)
+     d = PrimaryDevice();
+  return d;
+}
+
+cDevice *cDevice::GetDevice(int Index)
+{
+  return (0 <= Index && Index < numDevices) ? device[Index] : NULL;
+}
+
+static int GetClippedNumProvidedSystems(int AvailableBits, cDevice *Device)
+{
+  int MaxNumProvidedSystems = (1 << AvailableBits) - 1;
+  int NumProvidedSystems = Device->NumProvidedSystems();
+  if (NumProvidedSystems > MaxNumProvidedSystems) {
+     esyslog("ERROR: device %d supports %d modulation systems but cDevice::GetDevice() currently only supports %d delivery systems which should be fixed", Device->CardIndex() + 1, NumProvidedSystems, MaxNumProvidedSystems);
+     NumProvidedSystems = MaxNumProvidedSystems;
+     }
+  else if (NumProvidedSystems <= 0) {
+     esyslog("ERROR: device %d reported an invalid number (%d) of supported delivery systems - assuming 1", Device->CardIndex() + 1, NumProvidedSystems);
+     NumProvidedSystems = 1;
+     }
+  return NumProvidedSystems;
+}
+
+cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView, bool Query)
+{
+  // Collect the current priorities of all CAM slots that can decrypt the channel:
+  int NumCamSlots = CamSlots.Count();
+  int SlotPriority[NumCamSlots];
+  int NumUsableSlots = 0;
+  bool InternalCamNeeded = false;
+  if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
+     for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
+         SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
+         if (CamSlot->ModuleStatus() == msReady) {
+            if (CamSlot->ProvidesCa(Channel->Caids())) {
+               if (!ChannelCamRelations.CamChecked(Channel->GetChannelID(), CamSlot->SlotNumber())) {
+                  SlotPriority[CamSlot->Index()] = CamSlot->Priority();
+                  NumUsableSlots++;
+                  }
+               }
+            }
+         }
+     if (!NumUsableSlots)
+        InternalCamNeeded = true; // no CAM is able to decrypt this channel
+     }
+
+  bool NeedsDetachReceivers = false;
+  cDevice *d = NULL;
+  cCamSlot *s = NULL;
+
+  uint32_t Impact = 0xFFFFFFFF; // we're looking for a device with the least impact
+  for (int j = 0; j < NumCamSlots || !NumUsableSlots; j++) {
+      if (NumUsableSlots && SlotPriority[j] > MAXPRIORITY)
+         continue; // there is no CAM available in this slot
+      for (int i = 0; i < numDevices; i++) {
+          if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
+             continue; // a specific card was requested, but not this one
+          bool HasInternalCam = device[i]->HasInternalCam();
+          if (InternalCamNeeded && !HasInternalCam)
+             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
+          if (NumUsableSlots && !HasInternalCam && !CamSlots.Get(j)->Assign(device[i], true))
+             continue; // CAM slot can't be used with this device
+          bool ndr;
+          if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
+             if (NumUsableSlots && !HasInternalCam && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
+                ndr = true; // using a different CAM slot requires detaching receivers
+             // Put together an integer number that reflects the "impact" using
+             // this device would have on the overall system. Each condition is represented
+             // by one bit in the number (or several bits, if the condition is actually
+             // a numeric value). The sequence in which the conditions are listed corresponds
+             // to their individual severity, where the one listed first will make the most
+             // difference, because it results in the most significant bit of the result.
+             uint32_t imp = 0;
+             imp <<= 1; imp |= LiveView ? !device[i]->IsPrimaryDevice() || ndr : 0;                                  // prefer the primary device for live viewing if we don't need to detach existing receivers
+             imp <<= 1; imp |= !device[i]->Receiving() && (device[i] != cTransferControl::ReceiverDevice() || device[i]->IsPrimaryDevice()) || ndr; // use receiving devices if we don't need to detach existing receivers, but avoid primary device in local transfer mode
+             imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
+             imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
+             imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
+             imp <<= 8; imp |= device[i]->Priority() - IDLEPRIORITY;                                                 // use the device with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+             imp <<= 8; imp |= ((NumUsableSlots && !HasInternalCam) ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;// use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
+             imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
+             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
+             imp <<= 1; imp |= device[i]->AvoidRecording();                                                          // avoid SD full featured cards
+             imp <<= 1; imp |= (NumUsableSlots && !HasInternalCam) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
+             imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
+             if (imp < Impact) {
+                // This device has less impact than any previous one, so we take it.
+                Impact = imp;
+                d = device[i];
+                NeedsDetachReceivers = ndr;
+                if (NumUsableSlots && !HasInternalCam)
+                   s = CamSlots.Get(j);
+                }
+             }
+          }
+      if (!NumUsableSlots)
+         break; // no CAM necessary, so just one loop over the devices
+      }
+  if (d && !Query) {
+     if (NeedsDetachReceivers)
+        d->DetachAllReceivers();
+     if (s) {
+        if (s->Device() != d) {
+           if (s->Device())
+              s->Device()->DetachAllReceivers();
+           if (d->CamSlot())
+              d->CamSlot()->Assign(NULL);
+           s->Assign(d);
+           }
+        }
+     else if (d->CamSlot() && !d->CamSlot()->IsDecrypting())
+        d->CamSlot()->Assign(NULL);
+     }
+  return d;
+}
+
+cDevice *cDevice::GetDeviceForTransponder(const cChannel *Channel, int Priority)
+{
+  cDevice *Device = NULL;
+  for (int i = 0; i < cDevice::NumDevices(); i++) {
+      if (cDevice *d = cDevice::GetDevice(i)) {
+         if (d->IsTunedToTransponder(Channel))
+            return d; // if any device is tuned to the transponder, we're done
+         if (d->ProvidesTransponder(Channel)) {
+            if (d->MaySwitchTransponder(Channel))
+               Device = d; // this device may switch to the transponder without disturbing any receiver or live view
+            else if (!d->Occupied() && d->MaySwitchTransponder(Channel)) { // MaySwitchTransponder() implicitly calls Occupied()
+               if (d->Priority() < Priority && (!Device || d->Priority() < Device->Priority()))
+                  Device = d; // use this one only if no other with less impact can be found
+               }
+            }
+         }
+      }
+  return Device;
+}
+
+bool cDevice::HasCi(void)
+{
+  return false;
+}
+
+void cDevice::SetCamSlot(cCamSlot *CamSlot)
+{
+  camSlot = CamSlot;
+}
+
+void cDevice::Shutdown(void)
+{
+  deviceHooks.Clear();
+  for (int i = 0; i < numDevices; i++) {
+      delete device[i];
+      device[i] = NULL;
+      }
+}
+
+uchar *cDevice::GrabImage(int &Size, bool Jpeg, int Quality, int SizeX, int SizeY)
+{
+  return NULL;
+}
+
+bool cDevice::GrabImageFile(const char *FileName, bool Jpeg, int Quality, int SizeX, int SizeY)
+{
+  int result = 0;
+  int fd = open(FileName, O_WRONLY | O_CREAT | O_NOFOLLOW | O_TRUNC, DEFFILEMODE);
+  if (fd >= 0) {
+     int ImageSize;
+     uchar *Image = GrabImage(ImageSize, Jpeg, Quality, SizeX, SizeY);
+     if (Image) {
+        if (safe_write(fd, Image, ImageSize) == ImageSize)
+           isyslog("grabbed image to %s", FileName);
+        else {
+           LOG_ERROR_STR(FileName);
+           result |= 1;
+           }
+        free(Image);
+        }
+     else
+        result |= 1;
+     close(fd);
+     }
+  else {
+     LOG_ERROR_STR(FileName);
+     result |= 1;
+     }
+  return result == 0;
+}
+
+void cDevice::SetVideoDisplayFormat(eVideoDisplayFormat VideoDisplayFormat)
+{
+  cSpuDecoder *spuDecoder = GetSpuDecoder();
+  if (spuDecoder) {
+     if (Setup.VideoFormat)
+        spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
+     else {
+        switch (VideoDisplayFormat) {
+               case vdfPanAndScan:
+                    spuDecoder->setScaleMode(cSpuDecoder::eSpuPanAndScan);
+                    break;
+               case vdfLetterBox:
+                    spuDecoder->setScaleMode(cSpuDecoder::eSpuLetterBox);
+                    break;
+               case vdfCenterCutOut:
+                    spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
+                    break;
+               default: esyslog("ERROR: invalid value for VideoDisplayFormat '%d'", VideoDisplayFormat);
+               }
+        }
+     }
+}
+
+void cDevice::SetVideoFormat(bool VideoFormat16_9)
+{
+}
+
+eVideoSystem cDevice::GetVideoSystem(void)
+{
+  return vsPAL;
+}
+
+void cDevice::GetVideoSize(int &Width, int &Height, double &VideoAspect)
+{
+  Width = 0;
+  Height = 0;
+  VideoAspect = 1.0;
+}
+
+void cDevice::GetOsdSize(int &Width, int &Height, double &PixelAspect)
+{
+  Width = 720;
+  Height = 480;
+  PixelAspect = 1.0;
+}
+
+//#define PRINTPIDS(s) { char b[500]; char *q = b; q += sprintf(q, "%d %s ", CardIndex(), s); for (int i = 0; i < MAXPIDHANDLES; i++) q += sprintf(q, " %s%4d %d", i == ptOther ? "* " : "", pidHandles[i].pid, pidHandles[i].used); dsyslog("%s", b); }
+#define PRINTPIDS(s)
+
+bool cDevice::HasPid(int Pid) const
+{
+  for (int i = 0; i < MAXPIDHANDLES; i++) {
+      if (pidHandles[i].pid == Pid)
+         return true;
+      }
+  return false;
+}
+
+bool cDevice::AddPid(int Pid, ePidType PidType, int StreamType)
+{
+  if (Pid || PidType == ptPcr) {
+     int n = -1;
+     int a = -1;
+     if (PidType != ptPcr) { // PPID always has to be explicit
+        for (int i = 0; i < MAXPIDHANDLES; i++) {
+            if (i != ptPcr) {
+               if (pidHandles[i].pid == Pid)
+                  n = i;
+               else if (a < 0 && i >= ptOther && !pidHandles[i].used)
+                  a = i;
+               }
+            }
+        }
+     if (n >= 0) {
+        // The Pid is already in use
+        if (++pidHandles[n].used == 2 && n <= ptTeletext) {
+           // It's a special PID that may have to be switched into "tap" mode
+           PRINTPIDS("A");
+           if (!SetPid(&pidHandles[n], n, true)) {
+              esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
+              if (PidType <= ptTeletext)
+                 DetachAll(Pid);
+              DelPid(Pid, PidType);
+              return false;
+              }
+           if (camSlot)
+              camSlot->SetPid(Pid, true);
+           }
+        PRINTPIDS("a");
+        return true;
+        }
+     else if (PidType < ptOther) {
+        // The Pid is not yet in use and it is a special one
+        n = PidType;
+        }
+     else if (a >= 0) {
+        // The Pid is not yet in use and we have a free slot
+        n = a;
+        }
+     else {
+        esyslog("ERROR: no free slot for PID %d on device %d", Pid, CardIndex() + 1);
+        return false;
+        }
+     if (n >= 0) {
+        pidHandles[n].pid = Pid;
+        pidHandles[n].streamType = StreamType;
+        pidHandles[n].used = 1;
+        PRINTPIDS("C");
+        if (!SetPid(&pidHandles[n], n, true)) {
+           esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
+           if (PidType <= ptTeletext)
+              DetachAll(Pid);
+           DelPid(Pid, PidType);
+           return false;
+           }
+        if (camSlot)
+           camSlot->SetPid(Pid, true);
+        }
+     }
+  return true;
+}
+
+void cDevice::DelPid(int Pid, ePidType PidType)
+{
+  if (Pid || PidType == ptPcr) {
+     int n = -1;
+     if (PidType == ptPcr)
+        n = PidType; // PPID always has to be explicit
+     else {
+        for (int i = 0; i < MAXPIDHANDLES; i++) {
+            if (pidHandles[i].pid == Pid) {
+               n = i;
+               break;
+               }
+            }
+        }
+     if (n >= 0 && pidHandles[n].used) {
+        PRINTPIDS("D");
+        if (--pidHandles[n].used < 2) {
+           SetPid(&pidHandles[n], n, false);
+           if (pidHandles[n].used == 0) {
+              pidHandles[n].handle = -1;
+              pidHandles[n].pid = 0;
+              if (camSlot)
+                 camSlot->SetPid(Pid, false);
+              }
+           }
+        PRINTPIDS("E");
+        }
+     }
+}
+
+bool cDevice::SetPid(cPidHandle *Handle, int Type, bool On)
+{
+  return false;
+}
+
+void cDevice::DelLivePids(void)
+{
+  for (int i = ptAudio; i < ptOther; i++) {
+      if (pidHandles[i].pid)
+         DelPid(pidHandles[i].pid, ePidType(i));
+      }
+}
+
+void cDevice::StartSectionHandler(void)
+{
+  if (!sectionHandler) {
+     sectionHandler = new cSectionHandler(this);
+     AttachFilter(eitFilter = new cEitFilter);
+     AttachFilter(patFilter = new cPatFilter);
+     AttachFilter(sdtFilter = new cSdtFilter(patFilter));
+     AttachFilter(nitFilter = new cNitFilter);
+     }
+}
+
+void cDevice::StopSectionHandler(void)
+{
+  if (sectionHandler) {
+     delete nitFilter;
+     delete sdtFilter;
+     delete patFilter;
+     delete eitFilter;
+     delete sectionHandler;
+     nitFilter = NULL;
+     sdtFilter = NULL;
+     patFilter = NULL;
+     eitFilter = NULL;
+     sectionHandler = NULL;
+     }
+}
+
+int cDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
+{
+  return -1;
+}
+
+int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
+{
+  return safe_read(Handle, Buffer, Length);
+}
+
+void cDevice::CloseFilter(int Handle)
+{
+  close(Handle);
+}
+
+void cDevice::AttachFilter(cFilter *Filter)
+{
+  if (sectionHandler)
+     sectionHandler->Attach(Filter);
+}
+
+void cDevice::Detach(cFilter *Filter)
+{
+  if (sectionHandler)
+     sectionHandler->Detach(Filter);
+}
+
+bool cDevice::ProvidesSource(int Source) const
+{
+  return false;
+}
+
+bool cDevice::DeviceHooksProvidesTransponder(const cChannel *Channel) const
+{
+  cDeviceHook *Hook = deviceHooks.First();
+  while (Hook) {
+        if (!Hook->DeviceProvidesTransponder(this, Channel))
+           return false;
+        Hook = deviceHooks.Next(Hook);
+        }
+  return true;
+}
+
+bool cDevice::ProvidesTransponder(const cChannel *Channel) const
+{
+  return false;
+}
+
+bool cDevice::ProvidesTransponderExclusively(const cChannel *Channel) const
+{
+  for (int i = 0; i < numDevices; i++) {
+      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel))
+         return false;
+      }
+  return true;
+}
+
+bool cDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
+{
+  return false;
+}
+
+bool cDevice::ProvidesEIT(void) const
+{
+  return false;
+}
+
+int cDevice::NumProvidedSystems(void) const
+{
+  return 0;
+}
+
+const cPositioner *cDevice::Positioner(void) const
+{
+  return NULL;
+}
+
+int cDevice::SignalStrength(void) const
+{
+  return -1;
+}
+
+int cDevice::SignalQuality(void) const
+{
+  return -1;
+}
+
+const cChannel *cDevice::GetCurrentlyTunedTransponder(void) const
+{
+  return NULL;
+}
+
+bool cDevice::IsTunedToTransponder(const cChannel *Channel) const
+{
+  return false;
+}
+
+bool cDevice::MaySwitchTransponder(const cChannel *Channel) const
+{
+  return time(NULL) > occupiedTimeout && !Receiving() && !(pidHandles[ptAudio].pid || pidHandles[ptVideo].pid || pidHandles[ptDolby].pid);
+}
+
+bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
+{
+  if (LiveView) {
+     isyslog("switching to channel %d", Channel->Number());
+     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
+     }
+  for (int i = 3; i--;) {
+      switch (SetChannel(Channel, LiveView)) {
+        case scrOk:           return true;
+        case scrNotAvailable: Skins.Message(mtInfo, tr("Channel not available!"));
+                              return false;
+        case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
+                              return false;
+        case scrFailed:       break; // loop will retry
+        default:              esyslog("ERROR: invalid return value from SetChannel");
+        }
+      esyslog("retrying");
+      }
+  return false;
+}
+
+bool cDevice::SwitchChannel(int Direction)
+{
+  bool result = false;
+  Direction = sgn(Direction);
+  if (Direction) {
+     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
+     int n = CurrentChannel() + Direction;
+     int first = n;
+     cChannel *channel;
+     while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
+           // try only channels which are currently available
+           if (GetDevice(channel, LIVEPRIORITY, true, true))
+              break;
+           n = channel->Number() + Direction;
+           }
+     if (channel) {
+        int d = n - first;
+        if (abs(d) == 1)
+           dsyslog("skipped channel %d", first);
+        else if (d)
+           dsyslog("skipped channels %d..%d", first, n - sgn(d));
+        if (PrimaryDevice()->SwitchChannel(channel, true))
+           result = true;
+        }
+     else if (n != first)
+        Skins.Message(mtError, tr("Channel not available!"));
+     }
+  return result;
+}
+
+eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
+{
+  cStatus::MsgChannelSwitch(this, 0, LiveView);
+
+  if (LiveView) {
+     StopReplay();
+     DELETENULL(liveSubtitle);
+     DELETENULL(dvbSubtitleConverter);
+     }
+
+  cDevice *Device = (LiveView && IsPrimaryDevice()) ? GetDevice(Channel, LIVEPRIORITY, true) : this;
+
+  bool NeedsTransferMode = Device != this;
+
+  eSetChannelResult Result = scrOk;
+
+  // If this DVB card can't receive this channel, let's see if we can
+  // use the card that actually can receive it and transfer data from there:
+
+  if (NeedsTransferMode) {
+     if (Device && CanReplay()) {
+        if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
+           cControl::Launch(new cTransferControl(Device, Channel));
+        else
+           Result = scrNoTransfer;
+        }
+     else
+        Result = scrNotAvailable;
+     }
+  else {
+     Channels.Lock(false);
+     // Stop section handling:
+     if (sectionHandler) {
+        sectionHandler->SetStatus(false);
+        sectionHandler->SetChannel(NULL);
+        }
+     // Tell the camSlot about the channel switch and add all PIDs of this
+     // channel to it, for possible later decryption:
+     if (camSlot)
+        camSlot->AddChannel(Channel);
+     if (SetChannelDevice(Channel, LiveView)) {
+        // Start section handling:
+        if (sectionHandler) {
+           sectionHandler->SetChannel(Channel);
+           sectionHandler->SetStatus(true);
+           }
+        // Start decrypting any PIDs that might have been set in SetChannelDevice():
+        if (camSlot)
+           camSlot->StartDecrypting();
+        }
+     else
+        Result = scrFailed;
+     Channels.Unlock();
+     }
+
+  if (Result == scrOk) {
+     if (LiveView && IsPrimaryDevice()) {
+        currentChannel = Channel->Number();
+        // Set the available audio tracks:
+        ClrAvailableTracks();
+        for (int i = 0; i < MAXAPIDS; i++)
+            SetAvailableTrack(ttAudio, i, Channel->Apid(i), Channel->Alang(i));
+        if (Setup.UseDolbyDigital) {
+           for (int i = 0; i < MAXDPIDS; i++)
+               SetAvailableTrack(ttDolby, i, Channel->Dpid(i), Channel->Dlang(i));
+           }
+        for (int i = 0; i < MAXSPIDS; i++)
+            SetAvailableTrack(ttSubtitle, i, Channel->Spid(i), Channel->Slang(i));
+        if (!NeedsTransferMode)
+           EnsureAudioTrack(true);
+        EnsureSubtitleTrack();
+        }
+     cStatus::MsgChannelSwitch(this, Channel->Number(), LiveView); // only report status if channel switch successful
+     }
+
+  return Result;
+}
+
+void cDevice::ForceTransferMode(void)
+{
+  if (!cTransferControl::ReceiverDevice()) {
+     cChannel *Channel = Channels.GetByNumber(CurrentChannel());
+     if (Channel)
+        SetChannelDevice(Channel, false); // this implicitly starts Transfer Mode
+     }
+}
+
+int cDevice::Occupied(void) const
+{
+  int Seconds = occupiedTimeout - time(NULL);
+  return Seconds > 0 ? Seconds : 0;
+}
+
+void cDevice::SetOccupied(int Seconds)
+{
+  if (Seconds >= 0)
+     occupiedTimeout = time(NULL) + min(Seconds, MAXOCCUPIEDTIMEOUT);
+}
+
+bool cDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
+{
+  return false;
+}
+
+bool cDevice::HasLock(int TimeoutMs) const
+{
+  return true;
+}
+
+bool cDevice::HasProgramme(void) const
+{
+  return Replaying() || pidHandles[ptAudio].pid || pidHandles[ptVideo].pid;
+}
+
+int cDevice::GetAudioChannelDevice(void)
+{
+  return 0;
+}
+
+void cDevice::SetAudioChannelDevice(int AudioChannel)
+{
+}
+
+void cDevice::SetVolumeDevice(int Volume)
+{
+}
+
+void cDevice::SetDigitalAudioDevice(bool On)
+{
+}
+
+void cDevice::SetAudioTrackDevice(eTrackType Type)
+{
+}
+
+void cDevice::SetSubtitleTrackDevice(eTrackType Type)
+{
+}
+
+bool cDevice::ToggleMute(void)
+{
+  int OldVolume = volume;
+  mute = !mute;
+  //XXX why is it necessary to use different sequences???
+  if (mute) {
+     SetVolume(0, true);
+     Audios.MuteAudio(mute); // Mute external audio after analog audio
+     }
+  else {
+     Audios.MuteAudio(mute); // Enable external audio before analog audio
+     SetVolume(OldVolume, true);
+     }
+  volume = OldVolume;
+  return mute;
+}
+
+int cDevice::GetAudioChannel(void)
+{
+  int c = GetAudioChannelDevice();
+  return (0 <= c && c <= 2) ? c : 0;
+}
+
+void cDevice::SetAudioChannel(int AudioChannel)
+{
+  if (0 <= AudioChannel && AudioChannel <= 2)
+     SetAudioChannelDevice(AudioChannel);
+}
+
+void cDevice::SetVolume(int Volume, bool Absolute)
+{
+  int OldVolume = volume;
+  volume = constrain(Absolute ? Volume : volume + Volume, 0, MAXVOLUME);
+  SetVolumeDevice(volume);
+  Absolute |= mute;
+  cStatus::MsgSetVolume(Absolute ? volume : volume - OldVolume, Absolute);
+  if (volume > 0) {
+     mute = false;
+     Audios.MuteAudio(mute);
+     }
+}
+
+void cDevice::ClrAvailableTracks(bool DescriptionsOnly, bool IdsOnly)
+{
+  if (keepTracks)
+     return;
+  if (DescriptionsOnly) {
+     for (int i = ttNone; i < ttMaxTrackTypes; i++)
+         *availableTracks[i].description = 0;
+     }
+  else {
+     if (IdsOnly) {
+        for (int i = ttNone; i < ttMaxTrackTypes; i++)
+            availableTracks[i].id = 0;
+        }
+     else
+        memset(availableTracks, 0, sizeof(availableTracks));
+     pre_1_3_19_PrivateStream = 0;
+     SetAudioChannel(0); // fall back to stereo
+     currentAudioTrackMissingCount = 0;
+     currentAudioTrack = ttNone;
+     currentSubtitleTrack = ttNone;
+     }
+}
+
+bool cDevice::SetAvailableTrack(eTrackType Type, int Index, uint16_t Id, const char *Language, const char *Description)
+{
+  eTrackType t = eTrackType(Type + Index);
+  if (Type == ttAudio && IS_AUDIO_TRACK(t) ||
+      Type == ttDolby && IS_DOLBY_TRACK(t) ||
+      Type == ttSubtitle && IS_SUBTITLE_TRACK(t)) {
+     if (Language)
+        strn0cpy(availableTracks[t].language, Language, sizeof(availableTracks[t].language));
+     if (Description)
+        Utf8Strn0Cpy(availableTracks[t].description, Description, sizeof(availableTracks[t].description));
+     if (Id) {
+        availableTracks[t].id = Id; // setting 'id' last to avoid the need for extensive locking
+        if (Type == ttAudio || Type == ttDolby) {
+           int numAudioTracks = NumAudioTracks();
+           if (!availableTracks[currentAudioTrack].id && numAudioTracks && currentAudioTrackMissingCount++ > numAudioTracks * 10)
+              EnsureAudioTrack();
+           else if (t == currentAudioTrack)
+              currentAudioTrackMissingCount = 0;
+           }
+        else if (Type == ttSubtitle && autoSelectPreferredSubtitleLanguage)
+           EnsureSubtitleTrack();
+        }
+     return true;
+     }
+  else
+     esyslog("ERROR: SetAvailableTrack called with invalid Type/Index (%d/%d)", Type, Index);
+  return false;
+}
+
+const tTrackId *cDevice::GetTrack(eTrackType Type)
+{
+  return (ttNone < Type && Type < ttMaxTrackTypes) ? &availableTracks[Type] : NULL;
+}
+
+int cDevice::NumTracks(eTrackType FirstTrack, eTrackType LastTrack) const
+{
+  int n = 0;
+  for (int i = FirstTrack; i <= LastTrack; i++) {
+      if (availableTracks[i].id)
+         n++;
+      }
+  return n;
+}
+
+int cDevice::NumAudioTracks(void) const
+{
+  return NumTracks(ttAudioFirst, ttDolbyLast);
+}
+
+int cDevice::NumSubtitleTracks(void) const
+{
+  return NumTracks(ttSubtitleFirst, ttSubtitleLast);
+}
+
+bool cDevice::SetCurrentAudioTrack(eTrackType Type)
+{
+  if (ttNone < Type && Type <= ttDolbyLast) {
+     cMutexLock MutexLock(&mutexCurrentAudioTrack);
+     if (IS_DOLBY_TRACK(Type))
+        SetDigitalAudioDevice(true);
+     currentAudioTrack = Type;
+     if (player)
+        player->SetAudioTrack(currentAudioTrack, GetTrack(currentAudioTrack));
+     else
+        SetAudioTrackDevice(currentAudioTrack);
+     if (IS_AUDIO_TRACK(Type))
+        SetDigitalAudioDevice(false);
+     return true;
+     }
+  return false;
+}
+
+bool cDevice::SetCurrentSubtitleTrack(eTrackType Type, bool Manual)
+{
+  if (Type == ttNone || IS_SUBTITLE_TRACK(Type)) {
+     currentSubtitleTrack = Type;
+     autoSelectPreferredSubtitleLanguage = !Manual;
+     if (dvbSubtitleConverter)
+        dvbSubtitleConverter->Reset();
+     if (Type == ttNone && dvbSubtitleConverter) {
+        cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
+        DELETENULL(dvbSubtitleConverter);
+        }
+     DELETENULL(liveSubtitle);
+     if (player)
+        player->SetSubtitleTrack(currentSubtitleTrack, GetTrack(currentSubtitleTrack));
+     else
+        SetSubtitleTrackDevice(currentSubtitleTrack);
+     if (currentSubtitleTrack != ttNone && !Replaying() && !Transferring()) {
+        const tTrackId *TrackId = GetTrack(currentSubtitleTrack);
+        if (TrackId && TrackId->id) {
+           liveSubtitle = new cLiveSubtitle(TrackId->id);
+           AttachReceiver(liveSubtitle);
+           }
+        }
+     return true;
+     }
+  return false;
+}
+
+void cDevice::EnsureAudioTrack(bool Force)
+{
+  if (keepTracks)
+     return;
+  if (Force || !availableTracks[currentAudioTrack].id) {
+     eTrackType PreferredTrack = ttAudioFirst;
+     int PreferredAudioChannel = 0;
+     int LanguagePreference = -1;
+     int StartCheck = Setup.CurrentDolby ? ttDolbyFirst : ttAudioFirst;
+     int EndCheck = ttDolbyLast;
+     for (int i = StartCheck; i <= EndCheck; i++) {
+         const tTrackId *TrackId = GetTrack(eTrackType(i));
+         int pos = 0;
+         if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.AudioLanguages, TrackId->language, LanguagePreference, &pos)) {
+            PreferredTrack = eTrackType(i);
+            PreferredAudioChannel = pos;
+            }
+         if (Setup.CurrentDolby && i == ttDolbyLast) {
+            i = ttAudioFirst - 1;
+            EndCheck = ttAudioLast;
+            }
+         }
+     // Make sure we're set to an available audio track:
+     const tTrackId *Track = GetTrack(GetCurrentAudioTrack());
+     if (Force || !Track || !Track->id || PreferredTrack != GetCurrentAudioTrack()) {
+        if (!Force) // only log this for automatic changes
+           dsyslog("setting audio track to %d (%d)", PreferredTrack, PreferredAudioChannel);
+        SetCurrentAudioTrack(PreferredTrack);
+        SetAudioChannel(PreferredAudioChannel);
+        }
+     }
+}
+
+void cDevice::EnsureSubtitleTrack(void)
+{
+  if (keepTracks)
+     return;
+  if (Setup.DisplaySubtitles) {
+     eTrackType PreferredTrack = ttNone;
+     int LanguagePreference = INT_MAX; // higher than the maximum possible value
+     for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
+         const tTrackId *TrackId = GetTrack(eTrackType(i));
+         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
+            (i == ttSubtitleFirst + 8 && !*TrackId->language && LanguagePreference == INT_MAX))) // compatibility mode for old subtitles plugin
+            PreferredTrack = eTrackType(i);
+         }
+     // Make sure we're set to an available subtitle track:
+     const tTrackId *Track = GetTrack(GetCurrentSubtitleTrack());
+     if (!Track || !Track->id || PreferredTrack != GetCurrentSubtitleTrack())
+        SetCurrentSubtitleTrack(PreferredTrack);
+     }
+  else
+     SetCurrentSubtitleTrack(ttNone);
+}
+
+bool cDevice::CanReplay(void) const
+{
+  return HasDecoder();
+}
+
+bool cDevice::SetPlayMode(ePlayMode PlayMode)
+{
+  return false;
+}
+
+int64_t cDevice::GetSTC(void)
+{
+  return -1;
+}
+
+void cDevice::TrickSpeed(int Speed)
+{
+}
+
+void cDevice::Clear(void)
+{
+  Audios.ClearAudio();
+  if (dvbSubtitleConverter)
+     dvbSubtitleConverter->Reset();
+}
+
+void cDevice::Play(void)
+{
+  Audios.MuteAudio(mute);
+  if (dvbSubtitleConverter)
+     dvbSubtitleConverter->Freeze(false);
+}
+
+void cDevice::Freeze(void)
+{
+  Audios.MuteAudio(true);
+  if (dvbSubtitleConverter)
+     dvbSubtitleConverter->Freeze(true);
+}
+
+void cDevice::Mute(void)
+{
+  Audios.MuteAudio(true);
+}
+
+void cDevice::StillPicture(const uchar *Data, int Length)
+{
+  if (Data[0] == 0x47) {
+     // TS data
+     cTsToPes TsToPes;
+     uchar *buf = NULL;
+     int Size = 0;
+     while (Length >= TS_SIZE) {
+           int Pid = TsPid(Data);
+           if (Pid == PATPID)
+              patPmtParser.ParsePat(Data, TS_SIZE);
+           else if (patPmtParser.IsPmtPid(Pid))
+              patPmtParser.ParsePmt(Data, TS_SIZE);
+           else if (Pid == patPmtParser.Vpid()) {
+              if (TsPayloadStart(Data)) {
+                 int l;
+                 while (const uchar *p = TsToPes.GetPes(l)) {
+                       int Offset = Size;
+                       int NewSize = Size + l;
+                       if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
+                          Size = NewSize;
+                          buf = NewBuffer;
+                          memcpy(buf + Offset, p, l);
+                          }
+                       else {
+                          LOG_ERROR_STR("out of memory");
+                          free(buf);
+                          return;
+                          }
+                       }
+                 TsToPes.Reset();
+                 }
+              TsToPes.PutTs(Data, TS_SIZE);
+              }
+           Length -= TS_SIZE;
+           Data += TS_SIZE;
+           }
+     int l;
+     while (const uchar *p = TsToPes.GetPes(l)) {
+           int Offset = Size;
+           int NewSize = Size + l;
+           if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
+              Size = NewSize;
+              buf = NewBuffer;
+              memcpy(buf + Offset, p, l);
+              }
+           else {
+              esyslog("ERROR: out of memory");
+              free(buf);
+              return;
+              }
+           }
+     if (buf) {
+        StillPicture(buf, Size);
+        free(buf);
+        }
+     }
+}
+
+bool cDevice::Replaying(void) const
+{
+  return player != NULL;
+}
+
+bool cDevice::Transferring(void) const
+{
+  return cTransferControl::ReceiverDevice() != NULL;
+}
+
+bool cDevice::AttachPlayer(cPlayer *Player)
+{
+  if (CanReplay()) {
+     if (player)
+        Detach(player);
+     DELETENULL(liveSubtitle);
+     DELETENULL(dvbSubtitleConverter);
+     patPmtParser.Reset();
+     player = Player;
+     if (!Transferring())
+        ClrAvailableTracks(false, true);
+     SetPlayMode(player->playMode);
+     player->device = this;
+     player->Activate(true);
+     return true;
+     }
+  return false;
+}
+
+void cDevice::Detach(cPlayer *Player)
+{
+  if (Player && player == Player) {
+     cPlayer *p = player;
+     player = NULL; // avoids recursive calls to Detach()
+     p->Activate(false);
+     p->device = NULL;
+     cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
+     delete dvbSubtitleConverter;
+     dvbSubtitleConverter = NULL;
+     SetPlayMode(pmNone);
+     SetVideoDisplayFormat(eVideoDisplayFormat(Setup.VideoDisplayFormat));
+     PlayTs(NULL, 0);
+     patPmtParser.Reset();
+     Audios.ClearAudio();
+     isPlayingVideo = false;
+     }
+}
+
+void cDevice::StopReplay(void)
+{
+  if (player) {
+     Detach(player);
+     if (IsPrimaryDevice())
+        cControl::Shutdown();
+     }
+}
+
+bool cDevice::Poll(cPoller &Poller, int TimeoutMs)
+{
+  return false;
+}
+
+bool cDevice::Flush(int TimeoutMs)
+{
+  return true;
+}
+
+int cDevice::PlayVideo(const uchar *Data, int Length)
+{
+  return -1;
+}
+
+int cDevice::PlayAudio(const uchar *Data, int Length, uchar Id)
+{
+  return -1;
+}
+
+int cDevice::PlaySubtitle(const uchar *Data, int Length)
+{
+  if (!dvbSubtitleConverter)
+     dvbSubtitleConverter = new cDvbSubtitleConverter;
+  return dvbSubtitleConverter->ConvertFragments(Data, Length);
+}
+
+int cDevice::PlayPesPacket(const uchar *Data, int Length, bool VideoOnly)
+{
+  bool FirstLoop = true;
+  uchar c = Data[3];
+  const uchar *Start = Data;
+  const uchar *End = Start + Length;
+  while (Start < End) {
+        int d = End - Start;
+        int w = d;
+        switch (c) {
+          case 0xBE:          // padding stream, needed for MPEG1
+          case 0xE0 ... 0xEF: // video
+               isPlayingVideo = true;
+               w = PlayVideo(Start, d);
+               break;
+          case 0xC0 ... 0xDF: // audio
+               SetAvailableTrack(ttAudio, c - 0xC0, c);
+               if ((!VideoOnly || HasIBPTrickSpeed()) && c == availableTracks[currentAudioTrack].id) {
+                  w = PlayAudio(Start, d, c);
+                  if (FirstLoop)
+                     Audios.PlayAudio(Data, Length, c);
+                  }
+               break;
+          case 0xBD: { // private stream 1
+               // EBU Teletext data, ETSI EN 300 472
+               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
+               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
+                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
+                  break;
+                  }
+
+               int PayloadOffset = Data[8] + 9;
+
+               // Compatibility mode for old subtitles plugin:
+               if ((Data[7] & 0x01) && (Data[PayloadOffset - 3] & 0x81) == 0x01 && Data[PayloadOffset - 2] == 0x81)
+                  PayloadOffset--;
+
+               uchar SubStreamId = Data[PayloadOffset];
+               uchar SubStreamType = SubStreamId & 0xF0;
+               uchar SubStreamIndex = SubStreamId & 0x1F;
+
+               // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
+pre_1_3_19_PrivateStreamDetected:
+               if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
+                  SubStreamId = c;
+                  SubStreamType = 0x80;
+                  SubStreamIndex = 0;
+                  }
+               else if (pre_1_3_19_PrivateStream)
+                  pre_1_3_19_PrivateStream--; // every known PS1 packet counts down towards 0 to recover from glitches...
+               switch (SubStreamType) {
+                 case 0x20: // SPU
+                 case 0x30: // SPU
+                      SetAvailableTrack(ttSubtitle, SubStreamIndex, SubStreamId);
+                      if ((!VideoOnly || HasIBPTrickSpeed()) && currentSubtitleTrack != ttNone && SubStreamId == availableTracks[currentSubtitleTrack].id)
+                         w = PlaySubtitle(Start, d);
+                      break;
+                 case 0x80: // AC3 & DTS
+                      if (Setup.UseDolbyDigital) {
+                         SetAvailableTrack(ttDolby, SubStreamIndex, SubStreamId);
+                         if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
+                            w = PlayAudio(Start, d, SubStreamId);
+                            if (FirstLoop)
+                               Audios.PlayAudio(Data, Length, SubStreamId);
+                            }
+                         }
+                      break;
+                 case 0xA0: // LPCM
+                      SetAvailableTrack(ttAudio, SubStreamIndex, SubStreamId);
+                      if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
+                         w = PlayAudio(Start, d, SubStreamId);
+                         if (FirstLoop)
+                            Audios.PlayAudio(Data, Length, SubStreamId);
+                         }
+                      break;
+                 default:
+                      // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
+                      if (pre_1_3_19_PrivateStream <= MIN_PRE_1_3_19_PRIVATESTREAM) {
+                         dsyslog("unknown PS1 packet, substream id = %02X (counter is at %d)", SubStreamId, pre_1_3_19_PrivateStream);
+                         pre_1_3_19_PrivateStream += 2; // ...and every unknown PS1 packet counts up (the very first one counts twice, but that's ok)
+                         if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
+                            dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode - substream id = %02X", SubStreamId);
+                            ClrAvailableTracks();
+                            pre_1_3_19_PrivateStream = MIN_PRE_1_3_19_PRIVATESTREAM + 1;
+                            goto pre_1_3_19_PrivateStreamDetected;
+                            }
+                         }
+                 }
+               }
+               break;
+          default:
+               ;//esyslog("ERROR: unexpected packet id %02X", c);
+          }
+        if (w > 0)
+           Start += w;
+        else {
+           if (Start != Data)
+              esyslog("ERROR: incomplete PES packet write!");
+           return Start == Data ? w : Start - Data;
+           }
+        FirstLoop = false;
+        }
+  return Length;
+}
+
+int cDevice::PlayPes(const uchar *Data, int Length, bool VideoOnly)
+{
+  if (!Data) {
+     if (dvbSubtitleConverter)
+        dvbSubtitleConverter->Reset();
+     return 0;
+     }
+  int i = 0;
+  while (i <= Length - 6) {
+        if (Data[i] == 0x00 && Data[i + 1] == 0x00 && Data[i + 2] == 0x01) {
+           int l = PesLength(Data + i);
+           if (i + l > Length) {
+              esyslog("ERROR: incomplete PES packet!");
+              return Length;
+              }
+           int w = PlayPesPacket(Data + i, l, VideoOnly);
+           if (w > 0)
+              i += l;
+           else
+              return i == 0 ? w : i;
+           }
+        else
+           i++;
+        }
+  if (i < Length)
+     esyslog("ERROR: leftover PES data!");
+  return Length;
+}
+
+int cDevice::PlayTsVideo(const uchar *Data, int Length)
+{
+  // Video PES has no explicit length, so we can only determine the end of
+  // a PES packet when the next TS packet that starts a payload comes in:
+  if (TsPayloadStart(Data)) {
+     int l;
+     while (const uchar *p = tsToPesVideo.GetPes(l)) {
+           int w = PlayVideo(p, l);
+           if (w <= 0) {
+              tsToPesVideo.SetRepeatLast();
+              return w;
+              }
+           }
+     tsToPesVideo.Reset();
+     }
+  tsToPesVideo.PutTs(Data, Length);
+  return Length;
+}
+
+int cDevice::PlayTsAudio(const uchar *Data, int Length)
+{
+  // Audio PES always has an explicit length and consists of single packets:
+  int l;
+  if (const uchar *p = tsToPesAudio.GetPes(l)) {
+     int w = PlayAudio(p, l, p[3]);
+     if (w <= 0) {
+        tsToPesAudio.SetRepeatLast();
+        return w;
+        }
+     tsToPesAudio.Reset();
+     }
+  tsToPesAudio.PutTs(Data, Length);
+  return Length;
+}
+
+int cDevice::PlayTsSubtitle(const uchar *Data, int Length)
+{
+  if (!dvbSubtitleConverter)
+     dvbSubtitleConverter = new cDvbSubtitleConverter;
+  tsToPesSubtitle.PutTs(Data, Length);
+  int l;
+  if (const uchar *p = tsToPesSubtitle.GetPes(l)) {
+     dvbSubtitleConverter->Convert(p, l);
+     tsToPesSubtitle.Reset();
+     }
+  return Length;
+}
+
+//TODO detect and report continuity errors?
+int cDevice::PlayTs(const uchar *Data, int Length, bool VideoOnly)
+{
+  int Played = 0;
+  if (!Data) {
+     tsToPesVideo.Reset();
+     tsToPesAudio.Reset();
+     tsToPesSubtitle.Reset();
+     tsToPesTeletext.Reset();
+     }
+  else if (Length < TS_SIZE) {
+     esyslog("ERROR: skipped %d bytes of TS fragment", Length);
+     return Length;
+     }
+  else {
+     while (Length >= TS_SIZE) {
+           if (Data[0] != TS_SYNC_BYTE) {
+              int Skipped = 1;
+              while (Skipped < Length && (Data[Skipped] != TS_SYNC_BYTE || Length - Skipped > TS_SIZE && Data[Skipped + TS_SIZE] != TS_SYNC_BYTE))
+                    Skipped++;
+              esyslog("ERROR: skipped %d bytes to sync on start of TS packet", Skipped);
+              return Played + Skipped;
+              }
+           int Pid = TsPid(Data);
+           if (TsHasPayload(Data)) { // silently ignore TS packets w/o payload
+              int PayloadOffset = TsPayloadOffset(Data);
+              if (PayloadOffset < TS_SIZE) {
+                 if (Pid == PATPID)
+                    patPmtParser.ParsePat(Data, TS_SIZE);
+                 else if (patPmtParser.IsPmtPid(Pid))
+                    patPmtParser.ParsePmt(Data, TS_SIZE);
+                 else if (Pid == patPmtParser.Vpid()) {
+                    isPlayingVideo = true;
+                    int w = PlayTsVideo(Data, TS_SIZE);
+                    if (w < 0)
+                       return Played ? Played : w;
+                    if (w == 0)
+                       break;
+                    }
+                 else if (Pid == availableTracks[currentAudioTrack].id) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int w = PlayTsAudio(Data, TS_SIZE);
+                       if (w < 0)
+                          return Played ? Played : w;
+                       if (w == 0)
+                          break;
+                       Audios.PlayTsAudio(Data, TS_SIZE);
+                       }
+                    }
+                 else if (Pid == availableTracks[currentSubtitleTrack].id) {
+                    if (!VideoOnly || HasIBPTrickSpeed())
+                       PlayTsSubtitle(Data, TS_SIZE);
+                    }
+                 else if (Pid == patPmtParser.Tpid()) {
+                    if (!VideoOnly || HasIBPTrickSpeed()) {
+                       int l;
+                       tsToPesTeletext.PutTs(Data, Length);
+                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
+                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
+                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
+                          tsToPesTeletext.Reset();
+                          }
+                       }
+                    }
+                 }
+              }
+           else if (Pid == patPmtParser.Ppid()) {
+              int w = PlayTsVideo(Data, TS_SIZE);
+              if (w < 0)
+                 return Played ? Played : w;
+              if (w == 0)
+                 break;
+              }
+           Played += TS_SIZE;
+           Length -= TS_SIZE;
+           Data += TS_SIZE;
+           }
+     }
+  return Played;
+}
+
+int cDevice::Priority(void) const
+{
+  int priority = IDLEPRIORITY;
+  if (IsPrimaryDevice() && !Replaying() && HasProgramme())
+     priority = TRANSFERPRIORITY; // we use the same value here, no matter whether it's actual Transfer Mode or real live viewing
+  cMutexLock MutexLock(&mutexReceiver);
+  for (int i = 0; i < MAXRECEIVERS; i++) {
+      if (receiver[i])
+         priority = max(receiver[i]->priority, priority);
+      }
+  return priority;
+}
+
+bool cDevice::Ready(void)
+{
+  return true;
+}
+
+bool cDevice::Receiving(bool Dummy) const
+{
+  cMutexLock MutexLock(&mutexReceiver);
+  for (int i = 0; i < MAXRECEIVERS; i++) {
+      if (receiver[i])
+         return true;
+      }
+  return false;
+}
+
+#define TS_SCRAMBLING_TIMEOUT     3 // seconds to wait until a TS becomes unscrambled
+#define TS_SCRAMBLING_TIME_OK    10 // seconds before a Channel/CAM combination is marked as known to decrypt
+
+void cDevice::Action(void)
+{
+  if (Running() && OpenDvr()) {
+     while (Running()) {
+           // Read data from the DVR device:
+           uchar *b = NULL;
+           if (GetTSPacket(b)) {
+              if (b) {
+                 int Pid = TsPid(b);
+                 // Check whether the TS packets are scrambled:
+                 bool DetachReceivers = false;
+                 bool DescramblingOk = false;
+                 int CamSlotNumber = 0;
+                 if (startScrambleDetection) {
+                    cCamSlot *cs = CamSlot();
+                    CamSlotNumber = cs ? cs->SlotNumber() : 0;
+                    if (CamSlotNumber) {
+                       bool Scrambled = b[3] & TS_SCRAMBLING_CONTROL;
+                       int t = time(NULL) - startScrambleDetection;
+                       if (Scrambled) {
+                          if (t > TS_SCRAMBLING_TIMEOUT)
+                             DetachReceivers = true;
+                          }
+                       else if (t > TS_SCRAMBLING_TIME_OK) {
+                          DescramblingOk = true;
+                          startScrambleDetection = 0;
+                          }
+                       }
+                    }
+                 // Distribute the packet to all attached receivers:
+                 Lock();
+                 for (int i = 0; i < MAXRECEIVERS; i++) {
+                     if (receiver[i] && receiver[i]->WantsPid(Pid)) {
+                        if (DetachReceivers) {
+                           ChannelCamRelations.SetChecked(receiver[i]->ChannelID(), CamSlotNumber);
+                           Detach(receiver[i]);
+                           }
+                        else
+                           receiver[i]->Receive(b, TS_SIZE);
+                        if (DescramblingOk)
+                           ChannelCamRelations.SetDecrypt(receiver[i]->ChannelID(), CamSlotNumber);
+                        }
+                     }
+                 Unlock();
+                 }
+              }
+           else
+              break;
+           }
+     CloseDvr();
+     }
+}
+
+bool cDevice::OpenDvr(void)
+{
+  return false;
+}
+
+void cDevice::CloseDvr(void)
+{
+}
+
+bool cDevice::GetTSPacket(uchar *&Data)
+{
+  return false;
+}
+
+bool cDevice::AttachReceiver(cReceiver *Receiver)
+{
+  if (!Receiver)
+     return false;
+  if (Receiver->device == this)
+     return true;
+// activate the following line if you need it - actually the driver should be fixed!
+//#define WAIT_FOR_TUNER_LOCK
+#ifdef WAIT_FOR_TUNER_LOCK
+#define TUNER_LOCK_TIMEOUT 5000 // ms
+  if (!HasLock(TUNER_LOCK_TIMEOUT)) {
+     esyslog("ERROR: device %d has no lock, can't attach receiver!", CardIndex() + 1);
+     return false;
+     }
+#endif
+  cMutexLock MutexLock(&mutexReceiver);
+  for (int i = 0; i < MAXRECEIVERS; i++) {
+      if (!receiver[i]) {
+         for (int n = 0; n < Receiver->numPids; n++) {
+             if (!AddPid(Receiver->pids[n])) {
+                for ( ; n-- > 0; )
+                    DelPid(Receiver->pids[n]);
+                return false;
+                }
+             }
+         Receiver->Activate(true);
+         Lock();
+         Receiver->device = this;
+         receiver[i] = Receiver;
+         Unlock();
+         if (camSlot) {
+            camSlot->StartDecrypting();
+            startScrambleDetection = time(NULL);
+            }
+         Start();
+         return true;
+         }
+      }
+  esyslog("ERROR: no free receiver slot!");
+  return false;
+}
+
+void cDevice::Detach(cReceiver *Receiver)
+{
+  if (!Receiver || Receiver->device != this)
+     return;
+  bool receiversLeft = false;
+  cMutexLock MutexLock(&mutexReceiver);
+  for (int i = 0; i < MAXRECEIVERS; i++) {
+      if (receiver[i] == Receiver) {
+         Lock();
+         receiver[i] = NULL;
+         Receiver->device = NULL;
+         Unlock();
+         Receiver->Activate(false);
+         for (int n = 0; n < Receiver->numPids; n++)
+             DelPid(Receiver->pids[n]);
+         }
+      else if (receiver[i])
+         receiversLeft = true;
+      }
+  if (camSlot)
+     camSlot->StartDecrypting();
+  if (!receiversLeft)
+     Cancel(-1);
+}
+
+void cDevice::DetachAll(int Pid)
+{
+  if (Pid) {
+     cMutexLock MutexLock(&mutexReceiver);
+     for (int i = 0; i < MAXRECEIVERS; i++) {
+         cReceiver *Receiver = receiver[i];
+         if (Receiver && Receiver->WantsPid(Pid))
+            Detach(Receiver);
+         }
+     }
+}
+
+void cDevice::DetachAllReceivers(void)
+{
+  cMutexLock MutexLock(&mutexReceiver);
+  for (int i = 0; i < MAXRECEIVERS; i++)
+      Detach(receiver[i]);
+}
+
+// --- cTSBuffer -------------------------------------------------------------
+
+cTSBuffer::cTSBuffer(int File, int Size, int CardIndex)
+{
+  SetDescription("TS buffer on device %d", CardIndex);
+  f = File;
+  cardIndex = CardIndex;
+  delivered = false;
+  ringBuffer = new cRingBufferLinear(Size, TS_SIZE, true, "TS");
+  ringBuffer->SetTimeouts(100, 100);
+  ringBuffer->SetIoThrottle();
+  Start();
+}
+
+cTSBuffer::~cTSBuffer()
+{
+  Cancel(3);
+  delete ringBuffer;
+}
+
+void cTSBuffer::Action(void)
+{
+  if (ringBuffer) {
+     bool firstRead = true;
+     cPoller Poller(f);
+     while (Running()) {
+           if (firstRead || Poller.Poll(100)) {
+              firstRead = false;
+              int r = ringBuffer->Read(f);
+              if (r < 0 && FATALERRNO) {
+                 if (errno == EOVERFLOW)
+                    esyslog("ERROR: driver buffer overflow on device %d", cardIndex);
+                 else {
+                    LOG_ERROR;
+                    break;
+                    }
+                 }
+              }
+           }
+     }
+}
+
+uchar *cTSBuffer::Get(void)
+{
+  int Count = 0;
+  if (delivered) {
+     ringBuffer->Del(TS_SIZE);
+     delivered = false;
+     }
+  uchar *p = ringBuffer->Get(Count);
+  if (p && Count >= TS_SIZE) {
+     if (*p != TS_SYNC_BYTE) {
+        for (int i = 1; i < Count; i++) {
+            if (p[i] == TS_SYNC_BYTE) {
+               Count = i;
+               break;
+               }
+            }
+        ringBuffer->Del(Count);
+        esyslog("ERROR: skipped %d bytes to sync on TS packet on device %d", Count, cardIndex);
+        return NULL;
+        }
+     delivered = true;
+     return p;
+     }
+  return NULL;
+}
diff -uNr vdr-2.1.1.orig/menu.c vdr-2.1.1/menu.c
--- vdr-2.1.1.orig/menu.c	2013-08-27 09:01:07.154908447 +0800
+++ vdr-2.1.1/menu.c	2013-08-27 09:05:56.130896361 +0800
@@ -910,6 +910,18 @@
      Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
      Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
      Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
+
+     // PIN PATCH
+     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
+     else {
+        char* buf = 0;
+        int res = 0;
+        res = asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no"));
+        if (res < 0) ; // memory problems :o
+        Add(new cOsdItem(buf));
+        free(buf);
+        }
+
      Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
      SetFirstDayItem();
      }
@@ -2507,7 +2519,8 @@
                    }
                 }
             }
-         if (*Item->Text() && !LastDir) {
+         if (*Item->Text() && !LastDir
+            && (!cStatus::MsgReplayProtected(Item->Recording(), Item->Name(), base, Item->IsDirectory(), true))) { // PIN PATCH
             Add(Item);
             LastItem = Item;
             if (Item->IsDirectory())
@@ -2558,6 +2571,9 @@
 {
   cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
   if (ri) {
+     if (cStatus::MsgReplayProtected(ri->Recording(), ri->Name(), base,
+                                     ri->IsDirectory()) == true)    // PIN PATCH
+        return osContinue;                                          // PIN PATCH
      if (ri->IsDirectory())
         Open();
      else {
@@ -3664,28 +3680,32 @@
 
   // Basic menu items:
 
-  Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
+  // PIN PATCH
+  if (!cStatus::MsgMenuItemProtected("Schedule", true))   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+  if (!cStatus::MsgMenuItemProtected("Channels", true))   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
+  if (!cStatus::MsgMenuItemProtected("Timers", true))     Add(new cOsdItem(hk(tr("Timers")),     osTimers));
+  if (!cStatus::MsgMenuItemProtected("Recordings", true)) Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
 
   // Plugins:
 
   for (int i = 0; ; i++) {
       cPlugin *p = cPluginManager::GetPlugin(i);
       if (p) {
+         if (!cStatus::MsgPluginProtected(p, true)) {          // PIN PATCH
          const char *item = p->MainMenuEntry();
          if (item)
             Add(new cMenuPluginItem(hk(item), i));
          }
+         }
       else
          break;
       }
 
   // More basic menu items:
 
-  Add(new cOsdItem(hk(tr("Setup")),      osSetup));
+  if (!cStatus::MsgMenuItemProtected("Setup", true)) Add(new cOsdItem(hk(tr("Setup")), osSetup));  // PIN PATCH
   if (Commands.Count())
+     if (!cStatus::MsgMenuItemProtected("Commands", true))     // PIN PATCH
      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
 
   Update(true);
@@ -3766,6 +3786,13 @@
   int osdLanguage = I18nCurrentLanguage();
   eOSState state = cOsdMenu::ProcessKey(Key);
   HadSubMenu |= HasSubMenu();
+  // > PIN PATCH
+  cOsdItem* item = Get(Current());
+
+  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
+     if (cStatus::MsgMenuItemProtected(item->Text()))
+        return osContinue;
+  // PIN PATCH <
 
   cOsdObject *menu = NULL;
   switch (state) {
@@ -3819,6 +3846,7 @@
                          if (item) {
                             cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
                             if (p) {
+                               if (!cStatus::MsgPluginProtected(p)) {  // PIN PATCH
                                cOsdObject *menu = p->MainMenuAction();
                                if (menu) {
                                   if (menu->IsMenu())
@@ -3830,6 +3858,7 @@
                                   }
                                }
                             }
+                         }
                          state = osEnd;
                        }
                        break;
@@ -4008,6 +4037,7 @@
            Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
            if (!Channel && Setup.ChannelsWrap)
               Channel = Direction > 0 ? Channels.First() : Channels.Last();
+           if (!cStatus::MsgChannelProtected(0, Channel))                   // PIN PATCH
            if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
               return Channel;
            }
@@ -4719,6 +4749,7 @@
            for (int i = 0; i < MAXRECORDCONTROLS; i++) {
                if (!RecordControls[i]) {
                   RecordControls[i] = new cRecordControl(device, Timer, Pause);
+                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());  // PIN PATCH
                   return RecordControls[i]->Process(time(NULL));
                   }
                }
diff -uNr vdr-2.1.1.orig/osd.c vdr-2.1.1/osd.c
--- vdr-2.1.1.orig/osd.c	2013-05-18 20:33:16.000000000 +0800
+++ vdr-2.1.1/osd.c	2013-08-27 09:01:27.694907588 +0800
@@ -1623,6 +1623,7 @@
 int cOsd::osdHeight = 0;
 cVector<cOsd *> cOsd::Osds;
 cMutex cOsd::mutex;
+bool cOsd::pinValid = false;   // PIN PATCH
 
 cOsd::cOsd(int Left, int Top, uint Level)
 {
diff -uNr vdr-2.1.1.orig/osd.h vdr-2.1.1/osd.h
--- vdr-2.1.1.orig/osd.h	2013-02-12 21:39:08.000000000 +0800
+++ vdr-2.1.1/osd.h	2013-08-27 09:01:27.698907588 +0800
@@ -926,6 +926,7 @@
        ///<        MyOsdDrawPixmap(Left() + pm->ViewPort().X(), Top() + pm->ViewPort().Y(), pm->Data(), w, h, h * d);
        ///<        delete pm;
        ///<        }
+  static bool pinValid;   // PIN PATCH
   };
 
 #define MAXOSDIMAGES 64
diff -uNr vdr-2.1.1.orig/status.c vdr-2.1.1/status.c
--- vdr-2.1.1.orig/status.c	2013-08-27 09:01:07.134908448 +0800
+++ vdr-2.1.1/status.c	2013-08-27 09:01:27.698907588 +0800
@@ -153,3 +153,55 @@
   for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
      sm->OsdEventItem(Event, Text, Index, Count);
 }
+
+bool cStatus::MsgChannelProtected(const cDevice* Device, const cChannel* Channel)     // PIN PATCH
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      if (sm->ChannelProtected(Device, Channel) == true)
+ 	 return true;
+
+  return false;
+}
+
+bool cStatus::MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView)    // PIN PATCH
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->ReplayProtected(Recording, Name, Base, isDirectory, menuView) == true)
+         return true;
+      return false;
+}
+
+void cStatus::MsgRecordingFile(const char* FileName)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))   // PIN PATCH
+      sm->RecordingFile(FileName);
+}
+
+void cStatus::MsgTimerCreation(cTimer* Timer, const cEvent *Event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))   // PIN PATCH
+     sm->TimerCreation(Timer, Event);
+}
+
+bool cStatus::MsgPluginProtected(cPlugin* Plugin, int menuView)                  // PIN PATCH
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->PluginProtected(Plugin, menuView) == true)
+         return true;
+      return false;
+}
+
+void cStatus::MsgUserAction(const eKeys key, const cOsdObject* Interact)         // PIN PATCH
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->UserAction(key, Interact);
+}
+
+bool cStatus::MsgMenuItemProtected(const char* Name, int menuView)               // PIN PATCH
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     if (sm->MenuItemProtected(Name, menuView) == true)
+         return true;
+      return false;
+}
diff -uNr vdr-2.1.1.orig/status.c.orig vdr-2.1.1/status.c.orig
--- vdr-2.1.1.orig/status.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ vdr-2.1.1/status.c.orig	2013-08-27 09:01:07.134908448 +0800
@@ -0,0 +1,155 @@
+/*
+ * status.c: Status monitoring
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: status.c 3.0 2012/03/07 14:17:24 kls Exp $
+ */
+
+#include "status.h"
+
+// --- cStatus ---------------------------------------------------------------
+
+cList<cStatus> cStatus::statusMonitors;
+
+cStatus::cStatus(void)
+{
+  statusMonitors.Add(this);
+}
+
+cStatus::~cStatus()
+{
+  statusMonitors.Del(this, false);
+}
+
+void cStatus::MsgTimerChange(const cTimer *Timer, eTimerChange Change)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->TimerChange(Timer, Change);
+}
+
+void cStatus::MsgChannelSwitch(const cDevice *Device, int ChannelNumber, bool LiveView)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->ChannelSwitch(Device, ChannelNumber, LiveView);
+}
+
+void cStatus::MsgRecording(const cDevice *Device, const char *Name, const char *FileName, bool On)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->Recording(Device, Name, FileName, On);
+}
+
+void cStatus::MsgReplaying(const cControl *Control, const char *Name, const char *FileName, bool On)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->Replaying(Control, Name, FileName, On);
+}
+
+void cStatus::MsgSetVolume(int Volume, bool Absolute)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->SetVolume(Volume, Absolute);
+}
+
+void cStatus::MsgSetAudioTrack(int Index, const char * const *Tracks)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->SetAudioTrack(Index, Tracks);
+}
+
+void cStatus::MsgSetAudioChannel(int AudioChannel)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->SetAudioChannel(AudioChannel);
+}
+
+void cStatus::MsgSetSubtitleTrack(int Index, const char * const *Tracks)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->SetSubtitleTrack(Index, Tracks);
+}
+
+void cStatus::MsgOsdClear(void)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdClear();
+}
+
+void cStatus::MsgOsdTitle(const char *Title)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdTitle(Title);
+}
+
+void cStatus::MsgOsdStatusMessage(const char *Message)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdStatusMessage(Message);
+}
+
+void cStatus::MsgOsdHelpKeys(const char *Red, const char *Green, const char *Yellow, const char *Blue)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdHelpKeys(Red, Green, Yellow, Blue);
+}
+
+void cStatus::MsgOsdItem(const char *Text, int Index)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdItem(Text, Index);
+}
+
+void cStatus::MsgOsdCurrentItem(const char *Text)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdCurrentItem(Text);
+}
+
+void cStatus::MsgOsdTextItem(const char *Text, bool Scroll)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdTextItem(Text, Scroll);
+}
+
+void cStatus::MsgOsdChannel(const char *Text)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdChannel(Text);
+}
+
+void cStatus::MsgOsdProgramme(time_t PresentTime, const char *PresentTitle, const char *PresentSubtitle, time_t FollowingTime, const char *FollowingTitle, const char *FollowingSubtitle)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdProgramme(PresentTime, PresentTitle, PresentSubtitle, FollowingTime, FollowingTitle, FollowingSubtitle);
+}
+
+void cStatus::MsgOsdSetEvent(const cEvent* event)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetEvent(event);
+}
+
+void cStatus::MsgOsdSetRecording(const cRecording* recording)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdSetRecording(recording);
+}
+
+void cStatus::MsgOsdMenuDisplay(const char* kind)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDisplay(kind);
+}
+
+void cStatus::MsgOsdMenuDestroy()
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+      sm->OsdMenuDestroy();
+}
+void cStatus::MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count)
+{
+  for (cStatus *sm = statusMonitors.First(); sm; sm = statusMonitors.Next(sm))
+     sm->OsdEventItem(Event, Text, Index, Count);
+}
diff -uNr vdr-2.1.1.orig/status.h vdr-2.1.1/status.h
--- vdr-2.1.1.orig/status.h	2013-08-27 09:01:07.134908448 +0800
+++ vdr-2.1.1/status.h	2013-08-27 09:08:28.070890006 +0800
@@ -14,6 +14,7 @@
 #include "device.h"
 #include "player.h"
 #include "tools.h"
+#include "plugin.h"
 
 enum eTimerChange { tcMod, tcAdd, tcDel };
 
@@ -91,6 +92,22 @@
                // report menu destruvtion
   virtual void OsdEventItem(const cEvent* Event, const char *Text, int Index, int Count) {}
                // The OSD displays the given single line Event as menu item at Index.
+  virtual bool ChannelProtected(const cDevice *Device, const cChannel* Channel)  { return false; }         // PIN PATCH
+               // Checks if a channel is protected.
+  virtual bool ReplayProtected(const cRecording* Recording, const char* Name,
+                               const char* Base, bool isDirectory, int menuView = false) { return false; } // PIN PATCH
+               // Checks if a recording is protected.
+  virtual void RecordingFile(const char* FileName) {}                                                      // PIN PATCH
+               // The given DVB device has started recording to FileName. FileName is the name of the
+               // recording directory
+  virtual void TimerCreation(cTimer* Timer, const cEvent *Event) {}                                        // PIN PATCH
+               // The given timer is created
+  virtual bool PluginProtected(cPlugin* Plugin, int menuView = false)  { return false; }                   // PIN PATCH
+               // Checks if a plugin is protected.
+  virtual void UserAction(const eKeys key, const cOsdObject* Interact) {}                                  // PIN PATCH
+               // report user action
+  virtual bool MenuItemProtected(const char* Name, int menuView = false)  { return false; }                // PIN PATCH
+               // Checks if a menu entry is protected.
 
 public:
   cStatus(void);
@@ -118,6 +135,14 @@
   static void MsgOsdMenuDisplay(const char* kind);
   static void MsgOsdMenuDestroy();
   static void MsgOsdEventItem(const cEvent* Event, const char *Text, int Index, int Count);
+  static bool MsgChannelProtected(const cDevice* Device, const cChannel* Channel);                 // PIN PATCH
+  static bool MsgReplayProtected(const cRecording* Recording, const char* Name,
+                                 const char* Base, bool isDirectory, int menuView = false);        // PIN PATCH
+  static void MsgRecordingFile(const char* FileName);                                              // PIN PATCH
+  static void MsgTimerCreation(cTimer* Timer, const cEvent *Event);                                // PIN PATCH
+  static bool MsgPluginProtected(cPlugin* Plugin, int menuView = false);                           // PIN PATCH
+  static void MsgUserAction(const eKeys key, const cOsdObject* Interact);
+  static bool MsgMenuItemProtected(const char* Name, int menuView = false);                        // PIN PATCH
   };
 
 #endif //__STATUS_H
diff -uNr vdr-2.1.1.orig/timers.c vdr-2.1.1/timers.c
--- vdr-2.1.1.orig/timers.c	2013-08-27 09:01:07.014908453 +0800
+++ vdr-2.1.1/timers.c	2013-08-27 09:01:27.698907588 +0800
@@ -76,6 +76,7 @@
      stop -= 2400;
   priority = Pause ? Setup.PausePriority : Setup.DefaultPriority;
   lifetime = Pause ? Setup.PauseLifetime : Setup.DefaultLifetime;
+  fskProtection = 0;                                        // PIN PATCH
   if (Instant && channel)
      snprintf(file, sizeof(file), "%s%s", Setup.MarkInstantRecord ? "@" : "", *Setup.NameInstantRecord ? Setup.NameInstantRecord : channel->Name());
 }
@@ -110,10 +111,12 @@
      stop -= 2400;
   priority = Setup.DefaultPriority;
   lifetime = Setup.DefaultLifetime;
+  fskProtection = 0;                                        // PIN PATCH
   const char *Title = Event->Title();
   if (!isempty(Title))
      Utf8Strn0Cpy(file, Event->Title(), sizeof(file));
   SetEvent(Event);
+  cStatus::MsgTimerCreation(this, Event);                    // PIN PATCH
 }
 
 cTimer::cTimer(const cTimer &Timer)
@@ -149,6 +152,7 @@
      stop         = Timer.stop;
      priority     = Timer.priority;
      lifetime     = Timer.lifetime;
+     fskProtection = Timer.fskProtection;    // PIN PATCH
      strncpy(file, Timer.file, sizeof(file));
      free(aux);
      aux = Timer.aux ? strdup(Timer.aux) : NULL;
@@ -331,6 +335,7 @@
         result = false;
         }
      }
+  fskProtection = aux && strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>");  // PIN PATCH
   free(channelbuffer);
   free(daybuffer);
   free(filebuffer);
@@ -689,6 +694,36 @@
   Matches(); // refresh start and end time
 }
 
+void cTimer::SetFskProtection(int aFlag)      // PIN PATCH
+{
+   char* p;
+   char* tmp = 0;
+   int res = 0;
+
+   fskProtection = aFlag;
+
+   if (fskProtection && (!aux || !strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // add protection info to aux
+
+      if (aux) { tmp = strdup(aux); free(aux); }
+      res = asprintf(&aux, "%s<pin-plugin><protected>yes</protected></pin-plugin>", tmp ? tmp : "");
+   }
+   else if (!fskProtection && aux && (p = strstr(aux, "<pin-plugin><protected>yes</protected></pin-plugin>")))
+   {
+      // remove protection info from aux
+
+      res = asprintf(&tmp, "%.*s%s", (int)(p-aux), aux, p+strlen("<pin-plugin><protected>yes</protected></pin-plugin>"));
+      free(aux);
+      aux = strdup(tmp);
+   }
+
+   if (res < 0) ; // memory problems :o
+
+   if (tmp)
+      free(tmp);
+}
+
 // --- cTimers ---------------------------------------------------------------
 
 cTimers Timers;
diff -uNr vdr-2.1.1.orig/timers.h vdr-2.1.1/timers.h
--- vdr-2.1.1.orig/timers.h	2013-08-27 09:01:07.014908453 +0800
+++ vdr-2.1.1/timers.h	2013-08-27 09:01:27.698907588 +0800
@@ -38,6 +38,7 @@
   int start;
   int stop;
   int priority;
+  int fskProtection;                                               // PIN PATCH
   int lifetime;
   mutable char file[NAME_MAX * 2 + 1]; // *2 to be able to hold 'title' and 'episode', which can each be up to 255 characters long
   char *aux;
@@ -59,6 +60,7 @@
   int Start(void) const { return start; }
   int Stop(void) const { return stop; }
   int Priority(void) const { return priority; }
+  int FskProtection(void) const { return fskProtection; }          // PIN PATCH
   int Lifetime(void) const { return lifetime; }
   const char *File(void) const { return file; }
   time_t FirstDay(void) const { return weekdays ? day : 0; }
@@ -95,6 +97,7 @@
   void SetAux(const char *Aux);
   void SetDeferred(int Seconds);
   void SetFlags(uint Flags);
+  void SetFskProtection(int aFlag);                                // PIN PATCH
   void ClrFlags(uint Flags);
   void InvFlags(uint Flags);
   bool HasFlags(uint Flags) const;
diff -uNr vdr-2.1.1.orig/vdr.c vdr-2.1.1/vdr.c
--- vdr-2.1.1.orig/vdr.c	2013-08-27 09:01:07.010908454 +0800
+++ vdr-2.1.1/vdr.c	2013-08-27 09:01:27.698907588 +0800
@@ -66,6 +66,7 @@
 #include "tools.h"
 #include "transfer.h"
 #include "videodir.h"
+#include "status.h"     // PIN PATCH
 
 #define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
 #define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
@@ -1021,6 +1022,7 @@
         cOsdObject *Interact = Menu ? Menu : cControl::Control();
         eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
         if (ISREALKEY(key)) {
+           cStatus::MsgUserAction(key, Interact);          // PIN PATCH
            EITScanner.Activity();
            // Cancel shutdown countdown:
            if (ShutdownHandler.countdown)
@@ -1093,10 +1095,12 @@
                      cControl::Control()->Hide();
                   cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
                   if (plugin) {
+                     if (!cStatus::MsgPluginProtected(plugin)) {  // PIN PATCH
                      Menu = plugin->MainMenuAction();
                      if (Menu)
                         Menu->Show();
                      }
+                     }
                   else
                      esyslog("ERROR: unknown plugin '%s'", PluginName);
                   }
@@ -1309,9 +1313,11 @@
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
+                     if (cStatus::MsgReplayProtected(0, cReplayControl::LastReplayed(), 0, false) == false) {  // PIN PATCH
                      cControl::Shutdown();
                      cControl::Launch(new cReplayControl);
                      }
+                     }
                   else
                      DirectMainFunction(osRecordings); // no last viewed recording, so enter the Recordings menu
                   break;
diff -uNr vdr-2.1.1.orig/vdr.c.orig vdr-2.1.1/vdr.c.orig
--- vdr-2.1.1.orig/vdr.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ vdr-2.1.1/vdr.c.orig	2013-08-27 09:01:07.010908454 +0800
@@ -0,0 +1,1433 @@
+/*
+ * vdr.c: Video Disk Recorder main program
+ *
+ * Copyright (C) 2000, 2003, 2006, 2008, 2013 Klaus Schmidinger
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ * The author can be reached at vdr@tvdr.de
+ *
+ * The project's page is at http://www.tvdr.de
+ *
+ * $Id: vdr.c 3.1 2013/06/10 14:28:43 kls Exp $
+ */
+
+#include <getopt.h>
+#include <grp.h>
+#include <langinfo.h>
+#include <locale.h>
+#include <pwd.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <sys/capability.h>
+#include <sys/prctl.h>
+#include <termios.h>
+#include <unistd.h>
+#include "audio.h"
+#include "channels.h"
+#include "config.h"
+#include "cutter.h"
+#include "device.h"
+#include "diseqc.h"
+#include "dvbdevice.h"
+#include "eitscan.h"
+#include "epg.h"
+#include "filetransfer.h"
+#include "i18n.h"
+#include "interface.h"
+#include "keys.h"
+#include "libsi/si.h"
+#include "lirc.h"
+#include "menu.h"
+#include "osdbase.h"
+#include "plugin.h"
+#include "recording.h"
+#include "shutdown.h"
+#include "skinclassic.h"
+#include "skinlcars.h"
+#include "skinsttng.h"
+#include "sourceparams.h"
+#include "sources.h"
+#include "themes.h"
+#include "timers.h"
+#include "tools.h"
+#include "transfer.h"
+#include "videodir.h"
+
+#define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
+#define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
+#define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
+#define SHUTDOWNRETRY        360 // seconds before trying again to shut down
+#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
+#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
+#define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
+#define MANUALSTART          600 // seconds the next timer must be in the future to assume manual start
+#define CHANNELSAVEDELTA     600 // seconds before saving channels.conf after automatic modifications
+#define DEVICEREADYTIMEOUT    30 // seconds to wait until all devices are ready
+#define MENUTIMEOUT          120 // seconds of user inactivity after which an OSD display is closed
+#define TIMERCHECKDELTA       10 // seconds between checks for timers that need to see their channel
+#define TIMERDEVICETIMEOUT     8 // seconds before a device used for timer check may be reused
+#define TIMERLOOKAHEADTIME    60 // seconds before a non-VPS timer starts and the channel is switched if possible
+#define VPSLOOKAHEADTIME      24 // hours within which VPS timers will make sure their events are up to date
+#define VPSUPTODATETIME     3600 // seconds before the event or schedule of a VPS timer needs to be refreshed
+
+#define EXIT(v) { ShutdownHandler.Exit(v); goto Exit; }
+
+static int LastSignal = 0;
+
+static bool SetUser(const char *UserName, bool UserDump)
+{
+  if (UserName) {
+     struct passwd *user = getpwnam(UserName);
+     if (!user) {
+        fprintf(stderr, "vdr: unknown user: '%s'\n", UserName);
+        return false;
+        }
+     if (setgid(user->pw_gid) < 0) {
+        fprintf(stderr, "vdr: cannot set group id %u: %s\n", (unsigned int)user->pw_gid, strerror(errno));
+        return false;
+        }
+     if (initgroups(user->pw_name, user->pw_gid) < 0) {
+        fprintf(stderr, "vdr: cannot set supplemental group ids for user %s: %s\n", user->pw_name, strerror(errno));
+        return false;
+        }
+     if (setuid(user->pw_uid) < 0) {
+        fprintf(stderr, "vdr: cannot set user id %u: %s\n", (unsigned int)user->pw_uid, strerror(errno));
+        return false;
+        }
+     if (UserDump && prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)
+        fprintf(stderr, "vdr: warning - cannot set dumpable: %s\n", strerror(errno));
+     setenv("HOME", user->pw_dir, 1);
+     setenv("USER", user->pw_name, 1);
+     setenv("LOGNAME", user->pw_name, 1);
+     setenv("SHELL", user->pw_shell, 1);
+     }
+  return true;
+}
+
+static bool DropCaps(void)
+{
+  // drop all capabilities except selected ones
+  cap_t caps = cap_from_text("= cap_sys_nice,cap_sys_time,cap_net_raw=ep");
+  if (!caps) {
+     fprintf(stderr, "vdr: cap_from_text failed: %s\n", strerror(errno));
+     return false;
+     }
+  if (cap_set_proc(caps) == -1) {
+     fprintf(stderr, "vdr: cap_set_proc failed: %s\n", strerror(errno));
+     cap_free(caps);
+     return false;
+     }
+  cap_free(caps);
+  return true;
+}
+
+static bool SetKeepCaps(bool On)
+{
+  // set keeping capabilities during setuid() on/off
+  if (prctl(PR_SET_KEEPCAPS, On ? 1 : 0, 0, 0, 0) != 0) {
+     fprintf(stderr, "vdr: prctl failed\n");
+     return false;
+     }
+  return true;
+}
+
+static void SignalHandler(int signum)
+{
+  switch (signum) {
+    case SIGPIPE:
+         break;
+    case SIGHUP:
+         LastSignal = signum;
+         break;
+    default:
+         LastSignal = signum;
+         Interface->Interrupt();
+         ShutdownHandler.Exit(0);
+    }
+  signal(signum, SignalHandler);
+}
+
+static void Watchdog(int signum)
+{
+  // Something terrible must have happened that prevented the 'alarm()' from
+  // being called in time, so let's get out of here:
+  esyslog("PANIC: watchdog timer expired - exiting!");
+  exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+  // Save terminal settings:
+
+  struct termios savedTm;
+  bool HasStdin = (tcgetpgrp(STDIN_FILENO) == getpid() || getppid() != (pid_t)1) && tcgetattr(STDIN_FILENO, &savedTm) == 0;
+
+  // Initiate locale:
+
+  setlocale(LC_ALL, "");
+
+  // Command line options:
+
+#define dd(a, b) (*a ? a : b)
+#define DEFAULTSVDRPPORT 6419
+#define DEFAULTWATCHDOG     0 // seconds
+#define DEFAULTVIDEODIR VIDEODIR
+#define DEFAULTCONFDIR dd(CONFDIR, VideoDirectory)
+#define DEFAULTCACHEDIR dd(CACHEDIR, VideoDirectory)
+#define DEFAULTRESDIR dd(RESDIR, ConfigDirectory)
+#define DEFAULTPLUGINDIR PLUGINDIR
+#define DEFAULTLOCDIR LOCDIR
+#define DEFAULTEPGDATAFILENAME "epg.data"
+
+  bool StartedAsRoot = false;
+  const char *VdrUser = NULL;
+  bool UserDump = false;
+  int SVDRPport = DEFAULTSVDRPPORT;
+  const char *AudioCommand = NULL;
+  const char *VideoDirectory = DEFAULTVIDEODIR;
+  const char *ConfigDirectory = NULL;
+  const char *CacheDirectory = NULL;
+  const char *ResourceDirectory = NULL;
+  const char *LocaleDirectory = DEFAULTLOCDIR;
+  const char *EpgDataFileName = DEFAULTEPGDATAFILENAME;
+  bool DisplayHelp = false;
+  bool DisplayVersion = false;
+  bool DaemonMode = false;
+  int SysLogTarget = LOG_USER;
+  bool MuteAudio = false;
+  int WatchdogTimeout = DEFAULTWATCHDOG;
+  const char *Terminal = NULL;
+
+  bool UseKbd = true;
+  const char *LircDevice = NULL;
+#if !defined(REMOTE_KBD)
+  UseKbd = false;
+#endif
+#if defined(REMOTE_LIRC)
+  LircDevice = LIRC_DEVICE;
+#endif
+#if defined(VDR_USER)
+  VdrUser = VDR_USER;
+#endif
+
+  cPluginManager PluginManager(DEFAULTPLUGINDIR);
+
+  static struct option long_options[] = {
+      { "audio",    required_argument, NULL, 'a' },
+      { "cachedir", required_argument, NULL, 'c' | 0x100 },
+      { "config",   required_argument, NULL, 'c' },
+      { "daemon",   no_argument,       NULL, 'd' },
+      { "device",   required_argument, NULL, 'D' },
+      { "dirnames", required_argument, NULL, 'd' | 0x100 },
+      { "edit",     required_argument, NULL, 'e' | 0x100 },
+      { "epgfile",  required_argument, NULL, 'E' },
+      { "filesize", required_argument, NULL, 'f' | 0x100 },
+      { "genindex", required_argument, NULL, 'g' | 0x100 },
+      { "grab",     required_argument, NULL, 'g' },
+      { "help",     no_argument,       NULL, 'h' },
+      { "instance", required_argument, NULL, 'i' },
+      { "lib",      required_argument, NULL, 'L' },
+      { "lirc",     optional_argument, NULL, 'l' | 0x100 },
+      { "localedir",required_argument, NULL, 'l' | 0x200 },
+      { "log",      required_argument, NULL, 'l' },
+      { "mute",     no_argument,       NULL, 'm' },
+      { "no-kbd",   no_argument,       NULL, 'n' | 0x100 },
+      { "plugin",   required_argument, NULL, 'P' },
+      { "port",     required_argument, NULL, 'p' },
+      { "record",   required_argument, NULL, 'r' },
+      { "resdir",   required_argument, NULL, 'r' | 0x100 },
+      { "shutdown", required_argument, NULL, 's' },
+      { "split",    no_argument,       NULL, 's' | 0x100 },
+      { "terminal", required_argument, NULL, 't' },
+      { "user",     required_argument, NULL, 'u' },
+      { "userdump", no_argument,       NULL, 'u' | 0x100 },
+      { "version",  no_argument,       NULL, 'V' },
+      { "vfat",     no_argument,       NULL, 'v' | 0x100 },
+      { "video",    required_argument, NULL, 'v' },
+      { "watchdog", required_argument, NULL, 'w' },
+      { NULL,       no_argument,       NULL,  0  }
+    };
+
+  int c;
+  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:l:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
+        switch (c) {
+          case 'a': AudioCommand = optarg;
+                    break;
+          case 'c' | 0x100:
+                    CacheDirectory = optarg;
+                    break;
+          case 'c': ConfigDirectory = optarg;
+                    break;
+          case 'd': DaemonMode = true;
+                    break;
+          case 'D': if (isnumber(optarg)) {
+                       int n = atoi(optarg);
+                       if (0 <= n && n < MAXDEVICES) {
+                          cDevice::SetUseDevice(n);
+                          break;
+                          }
+                       }
+                    fprintf(stderr, "vdr: invalid DVB device number: %s\n", optarg);
+                    return 2;
+          case 'd' | 0x100: {
+                    char *s = optarg;
+                    if (*s != ',') {
+                       int n = strtol(s, &s, 10);
+                       if (n <= 0 || n >= PATH_MAX) { // PATH_MAX includes the terminating 0
+                          fprintf(stderr, "vdr: invalid directory path length: %s\n", optarg);
+                          return 2;
+                          }
+                       DirectoryPathMax = n;
+                       if (!*s)
+                          break;
+                       if (*s != ',') {
+                          fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
+                          return 2;
+                          }
+                       }
+                    s++;
+                    if (!*s)
+                       break;
+                    if (*s != ',') {
+                       int n = strtol(s, &s, 10);
+                       if (n <= 0 || n > NAME_MAX) { // NAME_MAX excludes the terminating 0
+                          fprintf(stderr, "vdr: invalid directory name length: %s\n", optarg);
+                          return 2;
+                          }
+                       DirectoryNameMax = n;
+                       if (!*s)
+                          break;
+                       if (*s != ',') {
+                          fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
+                          return 2;
+                          }
+                       }
+                    s++;
+                    if (!*s)
+                       break;
+                    int n = strtol(s, &s, 10);
+                    if (n != 0 && n != 1) {
+                       fprintf(stderr, "vdr: invalid directory encoding: %s\n", optarg);
+                       return 2;
+                       }
+                    DirectoryEncoding = n;
+                    if (*s) {
+                       fprintf(stderr, "vdr: unexpected data: %s\n", optarg);
+                       return 2;
+                       }
+                    }
+                    break;
+          case 'e' | 0x100:
+                    return CutRecording(optarg) ? 0 : 2;
+          case 'E': EpgDataFileName = (*optarg != '-' ? optarg : NULL);
+                    break;
+          case 'f' | 0x100:
+                    Setup.MaxVideoFileSize = StrToNum(optarg) / MEGABYTE(1);
+                    if (Setup.MaxVideoFileSize < MINVIDEOFILESIZE)
+                       Setup.MaxVideoFileSize = MINVIDEOFILESIZE;
+                    if (Setup.MaxVideoFileSize > MAXVIDEOFILESIZETS)
+                       Setup.MaxVideoFileSize = MAXVIDEOFILESIZETS;
+                    break;
+          case 'g' | 0x100:
+                    return GenerateIndex(optarg) ? 0 : 2;
+          case 'g': cSVDRP::SetGrabImageDir(*optarg != '-' ? optarg : NULL);
+                    break;
+          case 'h': DisplayHelp = true;
+                    break;
+          case 'i': if (isnumber(optarg)) {
+                       InstanceId = atoi(optarg);
+                       if (InstanceId >= 0)
+                          break;
+                       }
+                    fprintf(stderr, "vdr: invalid instance id: %s\n", optarg);
+                    return 2;
+          case 'l': {
+                    char *p = strchr(optarg, '.');
+                    if (p)
+                       *p = 0;
+                    if (isnumber(optarg)) {
+                       int l = atoi(optarg);
+                       if (0 <= l && l <= 3) {
+                          SysLogLevel = l;
+                          if (!p)
+                             break;
+                          if (isnumber(p + 1)) {
+                             int l = atoi(p + 1);
+                             if (0 <= l && l <= 7) {
+                                int targets[] = { LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7 };
+                                SysLogTarget = targets[l];
+                                break;
+                                }
+                             }
+                          }
+                       }
+                    if (p)
+                       *p = '.';
+                    fprintf(stderr, "vdr: invalid log level: %s\n", optarg);
+                    return 2;
+                    }
+          case 'L': if (access(optarg, R_OK | X_OK) == 0)
+                       PluginManager.SetDirectory(optarg);
+                    else {
+                       fprintf(stderr, "vdr: can't access plugin directory: %s\n", optarg);
+                       return 2;
+                       }
+                    break;
+          case 'l' | 0x100:
+                    LircDevice = optarg ? optarg : LIRC_DEVICE;
+                    break;
+          case 'l' | 0x200:
+                    if (access(optarg, R_OK | X_OK) == 0)
+                       LocaleDirectory = optarg;
+                    else {
+                       fprintf(stderr, "vdr: can't access locale directory: %s\n", optarg);
+                       return 2;
+                       }
+                    break;
+          case 'm': MuteAudio = true;
+                    break;
+          case 'n' | 0x100:
+                    UseKbd = false;
+                    break;
+          case 'p': if (isnumber(optarg))
+                       SVDRPport = atoi(optarg);
+                    else {
+                       fprintf(stderr, "vdr: invalid port number: %s\n", optarg);
+                       return 2;
+                       }
+                    break;
+          case 'P': PluginManager.AddPlugin(optarg);
+                    break;
+          case 'r': cRecordingUserCommand::SetCommand(optarg);
+                    break;
+          case 'r' | 0x100:
+                    ResourceDirectory = optarg;
+                    break;
+          case 's': ShutdownHandler.SetShutdownCommand(optarg);
+                    break;
+          case 's' | 0x100:
+                    Setup.SplitEditedFiles = 1;
+                    break;
+          case 't': Terminal = optarg;
+                    if (access(Terminal, R_OK | W_OK) < 0) {
+                       fprintf(stderr, "vdr: can't access terminal: %s\n", Terminal);
+                       return 2;
+                       }
+                    break;
+          case 'u': if (*optarg)
+                       VdrUser = optarg;
+                    break;
+          case 'u' | 0x100:
+                    UserDump = true;
+                    break;
+          case 'V': DisplayVersion = true;
+                    break;
+          case 'v' | 0x100:
+                    DirectoryPathMax = 250;
+                    DirectoryNameMax = 40;
+                    DirectoryEncoding = true;
+                    break;
+          case 'v': VideoDirectory = optarg;
+                    while (optarg && *optarg && optarg[strlen(optarg) - 1] == '/')
+                          optarg[strlen(optarg) - 1] = 0;
+                    break;
+          case 'w': if (isnumber(optarg)) {
+                       int t = atoi(optarg);
+                       if (t >= 0) {
+                          WatchdogTimeout = t;
+                          break;
+                          }
+                       }
+                    fprintf(stderr, "vdr: invalid watchdog timeout: %s\n", optarg);
+                    return 2;
+          default:  return 2;
+          }
+        }
+
+  // Set user id in case we were started as root:
+
+  if (VdrUser && geteuid() == 0) {
+     StartedAsRoot = true;
+     if (strcmp(VdrUser, "root")) {
+        if (!SetKeepCaps(true))
+           return 2;
+        if (!SetUser(VdrUser, UserDump))
+           return 2;
+        if (!SetKeepCaps(false))
+           return 2;
+        if (!DropCaps())
+           return 2;
+        }
+     }
+
+  // Help and version info:
+
+  if (DisplayHelp || DisplayVersion) {
+     if (!PluginManager.HasPlugins())
+        PluginManager.AddPlugin("*"); // adds all available plugins
+     PluginManager.LoadPlugins();
+     if (DisplayHelp) {
+        printf("Usage: vdr [OPTIONS]\n\n"          // for easier orientation, this is column 80|
+               "  -a CMD,   --audio=CMD    send Dolby Digital audio to stdin of command CMD\n"
+               "            --cachedir=DIR save cache files in DIR (default: %s)\n"
+               "  -c DIR,   --config=DIR   read config files from DIR (default: %s)\n"
+               "  -d,       --daemon       run in daemon mode\n"
+               "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
+               "                           there may be several -D options (default: all DVB\n"
+               "                           devices will be used)\n"
+               "            --dirnames=PATH[,NAME[,ENC]]\n"
+               "                           set the maximum directory path length to PATH\n"
+               "                           (default: %d); if NAME is also given, it defines\n"
+               "                           the maximum directory name length (default: %d);\n"
+               "                           the optional ENC can be 0 or 1, and controls whether\n"
+               "                           special characters in directory names are encoded as\n"
+               "                           hex values (default: 0); if PATH or NAME are left\n"
+               "                           empty (as in \",,1\" to only set ENC), the defaults\n"
+               "                           apply\n"
+               "            --edit=REC     cut recording REC and exit\n"
+               "  -E FILE,  --epgfile=FILE write the EPG data into the given FILE (default is\n"
+               "                           '%s' in the cache directory)\n"
+               "                           '-E-' disables this\n"
+               "                           if FILE is a directory, the default EPG file will be\n"
+               "                           created in that directory\n"
+               "            --filesize=SIZE limit video files to SIZE bytes (default is %dM)\n"
+               "                           only useful in conjunction with --edit\n"
+               "            --genindex=REC generate index for recording REC and exit\n"
+               "  -g DIR,   --grab=DIR     write images from the SVDRP command GRAB into the\n"
+               "                           given DIR; DIR must be the full path name of an\n"
+               "                           existing directory, without any \"..\", double '/'\n"
+               "                           or symlinks (default: none, same as -g-)\n"
+               "  -h,       --help         print this help and exit\n"
+               "  -i ID,    --instance=ID  use ID as the id of this VDR instance (default: 0)\n"
+               "  -l LEVEL, --log=LEVEL    set log level (default: 3)\n"
+               "                           0 = no logging, 1 = errors only,\n"
+               "                           2 = errors and info, 3 = errors, info and debug\n"
+               "                           if logging should be done to LOG_LOCALn instead of\n"
+               "                           LOG_USER, add '.n' to LEVEL, as in 3.7 (n=0..7)\n"
+               "  -L DIR,   --lib=DIR      search for plugins in DIR (default is %s)\n"
+               "            --lirc[=PATH]  use a LIRC remote control device, attached to PATH\n"
+               "                           (default: %s)\n"
+               "            --localedir=DIR search for locale files in DIR (default is\n"
+               "                           %s)\n"
+               "  -m,       --mute         mute audio of the primary DVB device at startup\n"
+               "            --no-kbd       don't use the keyboard as an input device\n"
+               "  -p PORT,  --port=PORT    use PORT for SVDRP (default: %d)\n"
+               "                           0 turns off SVDRP\n"
+               "  -P OPT,   --plugin=OPT   load a plugin defined by the given options\n"
+               "  -r CMD,   --record=CMD   call CMD before and after a recording, and after\n"
+               "                           a recording has been edited or deleted\n"
+               "            --resdir=DIR   read resource files from DIR (default: %s)\n"
+               "  -s CMD,   --shutdown=CMD call CMD to shutdown the computer\n"
+               "            --split        split edited files at the editing marks (only\n"
+               "                           useful in conjunction with --edit)\n"
+               "  -t TTY,   --terminal=TTY controlling tty\n"
+               "  -u USER,  --user=USER    run as user USER; only applicable if started as\n"
+               "                           root\n"
+               "            --userdump     allow coredumps if -u is given (debugging)\n"
+               "  -v DIR,   --video=DIR    use DIR as video directory (default: %s)\n"
+               "  -V,       --version      print version information and exit\n"
+               "            --vfat         for backwards compatibility (same as\n"
+               "                           --dirnames=250,40,1\n"
+               "  -w SEC,   --watchdog=SEC activate the watchdog timer with a timeout of SEC\n"
+               "                           seconds (default: %d); '0' disables the watchdog\n"
+               "\n",
+               DEFAULTCACHEDIR,
+               DEFAULTCONFDIR,
+               PATH_MAX - 1,
+               NAME_MAX,
+               DEFAULTEPGDATAFILENAME,
+               MAXVIDEOFILESIZEDEFAULT,
+               DEFAULTPLUGINDIR,
+               LIRC_DEVICE,
+               DEFAULTLOCDIR,
+               DEFAULTSVDRPPORT,
+               DEFAULTRESDIR,
+               DEFAULTVIDEODIR,
+               DEFAULTWATCHDOG
+               );
+        }
+     if (DisplayVersion)
+        printf("vdr (%s/%s) - The Video Disk Recorder\n", VDRVERSION, APIVERSION);
+     if (PluginManager.HasPlugins()) {
+        if (DisplayHelp)
+           printf("Plugins: vdr -P\"name [OPTIONS]\"\n\n");
+        for (int i = 0; ; i++) {
+            cPlugin *p = PluginManager.GetPlugin(i);
+            if (p) {
+               const char *help = p->CommandLineHelp();
+               printf("%s (%s) - %s\n", p->Name(), p->Version(), p->Description());
+               if (DisplayHelp && help) {
+                  printf("\n");
+                  puts(help);
+                  }
+               }
+            else
+               break;
+            }
+        }
+     return 0;
+     }
+
+  // Log file:
+
+  if (SysLogLevel > 0)
+     openlog("vdr", LOG_CONS, SysLogTarget); // LOG_PID doesn't work as expected under NPTL
+
+  // Check the video directory:
+
+  if (!DirectoryOk(VideoDirectory, true)) {
+     fprintf(stderr, "vdr: can't access video directory %s\n", VideoDirectory);
+     return 2;
+     }
+
+  // Daemon mode:
+
+  if (DaemonMode) {
+     if (daemon(1, 0) == -1) {
+        fprintf(stderr, "vdr: %m\n");
+        esyslog("ERROR: %m");
+        return 2;
+        }
+     }
+  else if (Terminal) {
+     // Claim new controlling terminal
+     stdin  = freopen(Terminal, "r", stdin);
+     stdout = freopen(Terminal, "w", stdout);
+     stderr = freopen(Terminal, "w", stderr);
+     HasStdin = true;
+     tcgetattr(STDIN_FILENO, &savedTm);
+     }
+
+  isyslog("VDR version %s started", VDRVERSION);
+  if (StartedAsRoot && VdrUser)
+     isyslog("switched to user '%s'", VdrUser);
+  if (DaemonMode)
+     dsyslog("running as daemon (tid=%d)", cThread::ThreadId());
+  cThread::SetMainThreadId();
+
+  // Set the system character table:
+
+  char *CodeSet = NULL;
+  if (setlocale(LC_CTYPE, ""))
+     CodeSet = nl_langinfo(CODESET);
+  else {
+     char *LangEnv = getenv("LANG"); // last resort in case locale stuff isn't installed
+     if (LangEnv) {
+        CodeSet = strchr(LangEnv, '.');
+        if (CodeSet)
+           CodeSet++; // skip the dot
+        }
+     }
+  if (CodeSet) {
+     bool known = SI::SetSystemCharacterTable(CodeSet);
+     isyslog("codeset is '%s' - %s", CodeSet, known ? "known" : "unknown");
+     cCharSetConv::SetSystemCharacterTable(CodeSet);
+     }
+
+  // Initialize internationalization:
+
+  I18nInitialize(LocaleDirectory);
+
+  // Main program loop variables - need to be here to have them initialized before any EXIT():
+
+  cEpgDataReader EpgDataReader;
+  cOsdObject *Menu = NULL;
+  int LastChannel = 0;
+  int LastTimerChannel = -1;
+  int PreviousChannel[2] = { 1, 1 };
+  int PreviousChannelIndex = 0;
+  time_t LastChannelChanged = time(NULL);
+  time_t LastInteract = 0;
+  int MaxLatencyTime = 0;
+  bool InhibitEpgScan = false;
+  bool IsInfoMenu = false;
+  cSkin *CurrentSkin = NULL;
+
+  // Load plugins:
+
+  if (!PluginManager.LoadPlugins(true))
+     EXIT(2);
+
+  // Directories:
+
+  SetVideoDirectory(VideoDirectory);
+  if (!ConfigDirectory)
+     ConfigDirectory = DEFAULTCONFDIR;
+  cPlugin::SetConfigDirectory(ConfigDirectory);
+  if (!CacheDirectory)
+     CacheDirectory = DEFAULTCACHEDIR;
+  cPlugin::SetCacheDirectory(CacheDirectory);
+  if (!ResourceDirectory)
+     ResourceDirectory = DEFAULTRESDIR;
+  cPlugin::SetResourceDirectory(ResourceDirectory);
+  cThemes::SetThemesDirectory(AddDirectory(ConfigDirectory, "themes"));
+
+  // Configuration data:
+
+  Setup.Load(AddDirectory(ConfigDirectory, "setup.conf"));
+  Sources.Load(AddDirectory(ConfigDirectory, "sources.conf"), true, true);
+  Diseqcs.Load(AddDirectory(ConfigDirectory, "diseqc.conf"), true, Setup.DiSEqC);
+  Scrs.Load(AddDirectory(ConfigDirectory, "scr.conf"), true);
+  Channels.Load(AddDirectory(ConfigDirectory, "channels.conf"), false, true);
+  Timers.Load(AddDirectory(ConfigDirectory, "timers.conf"));
+  Commands.Load(AddDirectory(ConfigDirectory, "commands.conf"));
+  RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
+  SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
+  Keys.Load(AddDirectory(ConfigDirectory, "remote.conf"));
+  KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
+  Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
+
+  if (!*cFont::GetFontFileName(Setup.FontOsd)) {
+     const char *msg = "no fonts available - OSD will not show any text!";
+     fprintf(stderr, "vdr: %s\n", msg);
+     esyslog("ERROR: %s", msg);
+     }
+
+  // Recordings:
+
+  Recordings.Update();
+  DeletedRecordings.Update();
+
+  // EPG data:
+
+  if (EpgDataFileName) {
+     const char *EpgDirectory = NULL;
+     if (DirectoryOk(EpgDataFileName)) {
+        EpgDirectory = EpgDataFileName;
+        EpgDataFileName = DEFAULTEPGDATAFILENAME;
+        }
+     else if (*EpgDataFileName != '/' && *EpgDataFileName != '.')
+        EpgDirectory = CacheDirectory;
+     if (EpgDirectory)
+        cSchedules::SetEpgDataFileName(AddDirectory(EpgDirectory, EpgDataFileName));
+     else
+        cSchedules::SetEpgDataFileName(EpgDataFileName);
+     EpgDataReader.Start();
+     }
+
+  // DVB interfaces:
+
+  cDvbDevice::Initialize();
+  cDvbDevice::BondDevices(Setup.DeviceBondings);
+
+  // Initialize plugins:
+
+  if (!PluginManager.InitializePlugins())
+     EXIT(2);
+
+  // Primary device:
+
+  cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
+  if (!cDevice::PrimaryDevice() || !cDevice::PrimaryDevice()->HasDecoder()) {
+     if (cDevice::PrimaryDevice() && !cDevice::PrimaryDevice()->HasDecoder())
+        isyslog("device %d has no MPEG decoder", cDevice::PrimaryDevice()->DeviceNumber() + 1);
+     for (int i = 0; i < cDevice::NumDevices(); i++) {
+         cDevice *d = cDevice::GetDevice(i);
+         if (d && d->HasDecoder()) {
+            isyslog("trying device number %d instead", i + 1);
+            if (cDevice::SetPrimaryDevice(i + 1)) {
+               Setup.PrimaryDVB = i + 1;
+               break;
+               }
+            }
+         }
+     if (!cDevice::PrimaryDevice()) {
+        const char *msg = "no primary device found - using first device!";
+        fprintf(stderr, "vdr: %s\n", msg);
+        esyslog("ERROR: %s", msg);
+        if (!cDevice::SetPrimaryDevice(1))
+           EXIT(2);
+        if (!cDevice::PrimaryDevice()) {
+           const char *msg = "no primary device found - giving up!";
+           fprintf(stderr, "vdr: %s\n", msg);
+           esyslog("ERROR: %s", msg);
+           EXIT(2);
+           }
+        }
+     }
+
+  // Check for timers in automatic start time window:
+
+  ShutdownHandler.CheckManualStart(MANUALSTART);
+
+  // User interface:
+
+  Interface = new cInterface(SVDRPport);
+
+  // Default skins:
+
+  new cSkinLCARS;
+  new cSkinSTTNG;
+  new cSkinClassic;
+  Skins.SetCurrent(Setup.OSDSkin);
+  cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
+  CurrentSkin = Skins.Current();
+
+  // Start plugins:
+
+  if (!PluginManager.StartPlugins())
+     EXIT(2);
+
+  // Set skin and theme in case they're implemented by a plugin:
+
+  if (!CurrentSkin || CurrentSkin == Skins.Current() && strcmp(Skins.Current()->Name(), Setup.OSDSkin) != 0) {
+     Skins.SetCurrent(Setup.OSDSkin);
+     cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
+     }
+
+  // Remote Controls:
+  if (LircDevice)
+     new cLircRemote(LircDevice);
+  if (!DaemonMode && HasStdin && UseKbd)
+     new cKbdRemote;
+  Interface->LearnKeys();
+
+  // External audio:
+
+  if (AudioCommand)
+     new cExternalAudio(AudioCommand);
+
+  // Positioner:
+
+  if (!cPositioner::GetPositioner()) // no plugin has created a positioner
+     new cDiseqcPositioner;
+
+  // Channel:
+
+  if (!cDevice::WaitForAllDevicesReady(DEVICEREADYTIMEOUT))
+     dsyslog("not all devices ready after %d seconds", DEVICEREADYTIMEOUT);
+  if (*Setup.InitialChannel) {
+     if (isnumber(Setup.InitialChannel)) { // for compatibility with old setup.conf files
+        if (cChannel *Channel = Channels.GetByNumber(atoi(Setup.InitialChannel)))
+           Setup.InitialChannel = Channel->GetChannelID().ToString();
+        }
+     if (cChannel *Channel = Channels.GetByChannelID(tChannelID::FromString(Setup.InitialChannel)))
+        Setup.CurrentChannel = Channel->Number();
+     }
+  if (Setup.InitialVolume >= 0)
+     Setup.CurrentVolume = Setup.InitialVolume;
+  Channels.SwitchTo(Setup.CurrentChannel);
+  if (MuteAudio)
+     cDevice::PrimaryDevice()->ToggleMute();
+  else
+     cDevice::PrimaryDevice()->SetVolume(Setup.CurrentVolume, true);
+
+  // Signal handlers:
+
+  if (signal(SIGHUP,  SignalHandler) == SIG_IGN) signal(SIGHUP,  SIG_IGN);
+  if (signal(SIGINT,  SignalHandler) == SIG_IGN) signal(SIGINT,  SIG_IGN);
+  if (signal(SIGTERM, SignalHandler) == SIG_IGN) signal(SIGTERM, SIG_IGN);
+  if (signal(SIGPIPE, SignalHandler) == SIG_IGN) signal(SIGPIPE, SIG_IGN);
+  if (WatchdogTimeout > 0)
+     if (signal(SIGALRM, Watchdog)   == SIG_IGN) signal(SIGALRM, SIG_IGN);
+
+  // Watchdog:
+
+  if (WatchdogTimeout > 0) {
+     dsyslog("setting watchdog timer to %d seconds", WatchdogTimeout);
+     alarm(WatchdogTimeout); // Initial watchdog timer start
+     }
+
+  // Main program loop:
+
+#define DELETE_MENU ((IsInfoMenu &= (Menu == NULL)), delete Menu, Menu = NULL)
+
+  while (!ShutdownHandler.DoExit()) {
+#ifdef DEBUGRINGBUFFERS
+        cRingBufferLinear::PrintDebugRBL();
+#endif
+        // Attach launched player control:
+        cControl::Attach();
+
+        time_t Now = time(NULL);
+
+        // Make sure we have a visible programme in case device usage has changed:
+        if (!EITScanner.Active() && cDevice::PrimaryDevice()->HasDecoder()) {
+           static time_t lastTime = 0;
+           if (!cDevice::PrimaryDevice()->HasProgramme()) {
+              if (!CamMenuActive() && Now - lastTime > MINCHANNELWAIT) { // !CamMenuActive() to avoid interfering with the CAM if a CAM menu is open
+                 cChannel *Channel = Channels.GetByNumber(cDevice::CurrentChannel());
+                 if (Channel && (Channel->Vpid() || Channel->Apid(0) || Channel->Dpid(0))) {
+                    if (cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(Channel->Number())) // try to switch to the original channel...
+                       ;
+                    else if (LastTimerChannel > 0) {
+                       Channel = Channels.GetByNumber(LastTimerChannel);
+                       if (Channel && cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(LastTimerChannel)) // ...or the one used by the last timer
+                          ;
+                       }
+                    }
+                 lastTime = Now; // don't do this too often
+                 LastTimerChannel = -1;
+                 }
+              }
+           else
+              lastTime = 0; // makes sure we immediately try again next time
+           }
+        // Update the OSD size:
+        {
+          static time_t lastOsdSizeUpdate = 0;
+          if (Now != lastOsdSizeUpdate) { // once per second
+             cOsdProvider::UpdateOsdSize();
+             lastOsdSizeUpdate = Now;
+             }
+        }
+        // Restart the Watchdog timer:
+        if (WatchdogTimeout > 0) {
+           int LatencyTime = WatchdogTimeout - alarm(WatchdogTimeout);
+           if (LatencyTime > MaxLatencyTime) {
+              MaxLatencyTime = LatencyTime;
+              dsyslog("max. latency time %d seconds", MaxLatencyTime);
+              }
+           }
+        // Handle channel and timer modifications:
+        if (!Channels.BeingEdited() && !Timers.BeingEdited()) {
+           int modified = Channels.Modified();
+           static time_t ChannelSaveTimeout = 0;
+           static int TimerState = 0;
+           // Channels and timers need to be stored in a consistent manner,
+           // therefore if one of them is changed, we save both.
+           if (modified == CHANNELSMOD_USER || Timers.Modified(TimerState))
+              ChannelSaveTimeout = 1; // triggers an immediate save
+           else if (modified && !ChannelSaveTimeout)
+              ChannelSaveTimeout = Now + CHANNELSAVEDELTA;
+           bool timeout = ChannelSaveTimeout == 1 || ChannelSaveTimeout && Now > ChannelSaveTimeout && !cRecordControls::Active();
+           if ((modified || timeout) && Channels.Lock(false, 100)) {
+              if (timeout) {
+                 Channels.Save();
+                 Timers.Save();
+                 ChannelSaveTimeout = 0;
+                 }
+              for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
+                  if (Channel->Modification(CHANNELMOD_RETUNE)) {
+                     cRecordControls::ChannelDataModified(Channel);
+                     if (Channel->Number() == cDevice::CurrentChannel()) {
+                        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring()) {
+                           if (cDevice::ActualDevice()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
+                              isyslog("retuning due to modification of channel %d", Channel->Number());
+                              Channels.SwitchTo(Channel->Number());
+                              }
+                           }
+                        }
+                     }
+                  }
+              Channels.Unlock();
+              }
+           }
+        // Channel display:
+        if (!EITScanner.Active() && cDevice::CurrentChannel() != LastChannel) {
+           if (!Menu)
+              Menu = new cDisplayChannel(cDevice::CurrentChannel(), LastChannel >= 0);
+           LastChannel = cDevice::CurrentChannel();
+           LastChannelChanged = Now;
+           }
+        if (Now - LastChannelChanged >= Setup.ZapTimeout && LastChannel != PreviousChannel[PreviousChannelIndex])
+           PreviousChannel[PreviousChannelIndex ^= 1] = LastChannel;
+        // Timers and Recordings:
+        if (!Timers.BeingEdited()) {
+           // Assign events to timers:
+           Timers.SetEvents();
+           // Must do all following calls with the exact same time!
+           // Process ongoing recordings:
+           cRecordControls::Process(Now);
+           // Start new recordings:
+           cTimer *Timer = Timers.GetMatch(Now);
+           if (Timer) {
+              if (!cRecordControls::Start(Timer))
+                 Timer->SetPending(true);
+              else
+                 LastTimerChannel = Timer->Channel()->Number();
+              }
+           // Make sure timers "see" their channel early enough:
+           static time_t LastTimerCheck = 0;
+           if (Now - LastTimerCheck > TIMERCHECKDELTA) { // don't do this too often
+              InhibitEpgScan = false;
+              for (cTimer *Timer = Timers.First(); Timer; Timer = Timers.Next(Timer)) {
+                  bool InVpsMargin = false;
+                  bool NeedsTransponder = false;
+                  if (Timer->HasFlags(tfActive) && !Timer->Recording()) {
+                     if (Timer->HasFlags(tfVps)) {
+                        if (Timer->Matches(Now, true, Setup.VpsMargin)) {
+                           InVpsMargin = true;
+                           Timer->SetInVpsMargin(InVpsMargin);
+                           }
+                        else if (Timer->Event()) {
+                           InVpsMargin = Timer->Event()->StartTime() <= Now && Now < Timer->Event()->EndTime();
+                           NeedsTransponder = Timer->Event()->StartTime() - Now < VPSLOOKAHEADTIME * 3600 && !Timer->Event()->SeenWithin(VPSUPTODATETIME);
+                           }
+                        else {
+                           cSchedulesLock SchedulesLock;
+                           const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
+                           if (Schedules) {
+                              const cSchedule *Schedule = Schedules->GetSchedule(Timer->Channel());
+                              InVpsMargin = !Schedule; // we must make sure we have the schedule
+                              NeedsTransponder = Schedule && !Schedule->PresentSeenWithin(VPSUPTODATETIME);
+                              }
+                           }
+                        InhibitEpgScan |= InVpsMargin | NeedsTransponder;
+                        }
+                     else
+                        NeedsTransponder = Timer->Matches(Now, true, TIMERLOOKAHEADTIME);
+                     }
+                  if (NeedsTransponder || InVpsMargin) {
+                     // Find a device that provides the required transponder:
+                     cDevice *Device = cDevice::GetDeviceForTransponder(Timer->Channel(), MINPRIORITY);
+                     if (!Device && InVpsMargin)
+                        Device = cDevice::GetDeviceForTransponder(Timer->Channel(), LIVEPRIORITY);
+                     // Switch the device to the transponder:
+                     if (Device) {
+                        bool HadProgramme = cDevice::PrimaryDevice()->HasProgramme();
+                        if (!Device->IsTunedToTransponder(Timer->Channel())) {
+                           if (Device == cDevice::ActualDevice() && !Device->IsPrimaryDevice())
+                              cDevice::PrimaryDevice()->StopReplay(); // stop transfer mode
+                           dsyslog("switching device %d to channel %d", Device->DeviceNumber() + 1, Timer->Channel()->Number());
+                           if (Device->SwitchChannel(Timer->Channel(), false))
+                              Device->SetOccupied(TIMERDEVICETIMEOUT);
+                           }
+                        if (cDevice::PrimaryDevice()->HasDecoder() && HadProgramme && !cDevice::PrimaryDevice()->HasProgramme())
+                           Skins.QueueMessage(mtInfo, tr("Upcoming recording!")); // the previous SwitchChannel() has switched away the current live channel
+                        }
+                     }
+                  }
+              LastTimerCheck = Now;
+              }
+           // Delete expired timers:
+           Timers.DeleteExpired();
+           }
+        if (!Menu && Recordings.NeedsUpdate()) {
+           Recordings.Update();
+           DeletedRecordings.Update();
+           }
+        // CAM control:
+        if (!Menu && !cOsd::IsOpen())
+           Menu = CamControl();
+        // Queued messages:
+        if (!Skins.IsOpen())
+           Skins.ProcessQueuedMessages();
+        // User Input:
+        cOsdObject *Interact = Menu ? Menu : cControl::Control();
+        eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
+        if (ISREALKEY(key)) {
+           EITScanner.Activity();
+           // Cancel shutdown countdown:
+           if (ShutdownHandler.countdown)
+              ShutdownHandler.countdown.Cancel();
+           // Set user active for MinUserInactivity time in the future:
+           ShutdownHandler.SetUserInactiveTimeout();
+           }
+        // Keys that must work independent of any interactive mode:
+        switch (int(key)) {
+          // Menu control:
+          case kMenu: {
+               key = kNone; // nobody else needs to see this key
+               bool WasOpen = Interact != NULL;
+               bool WasMenu = Interact && Interact->IsMenu();
+               if (Menu)
+                  DELETE_MENU;
+               else if (cControl::Control()) {
+                  if (cOsd::IsOpen())
+                     cControl::Control()->Hide();
+                  else
+                     WasOpen = false;
+                  }
+               if (!WasOpen || !WasMenu && !Setup.MenuKeyCloses)
+                  Menu = new cMenuMain;
+               }
+               break;
+          // Info:
+          case kInfo: {
+               if (IsInfoMenu) {
+                  key = kNone; // nobody else needs to see this key
+                  DELETE_MENU;
+                  }
+               else if (!Menu) {
+                  IsInfoMenu = true;
+                  if (cControl::Control()) {
+                     cControl::Control()->Hide();
+                     Menu = cControl::Control()->GetInfo();
+                     if (Menu)
+                        Menu->Show();
+                     else
+                        IsInfoMenu = false;
+                     }
+                  else {
+                     cRemote::Put(kOk, true);
+                     cRemote::Put(kSchedule, true);
+                     }
+                  key = kNone; // nobody else needs to see this key
+                  }
+               }
+               break;
+          // Direct main menu functions:
+          #define DirectMainFunction(function)\
+            { DELETE_MENU;\
+            if (cControl::Control())\
+               cControl::Control()->Hide();\
+            Menu = new cMenuMain(function);\
+            key = kNone; } // nobody else needs to see this key
+          case kSchedule:   DirectMainFunction(osSchedule); break;
+          case kChannels:   DirectMainFunction(osChannels); break;
+          case kTimers:     DirectMainFunction(osTimers); break;
+          case kRecordings: DirectMainFunction(osRecordings); break;
+          case kSetup:      DirectMainFunction(osSetup); break;
+          case kCommands:   DirectMainFunction(osCommands); break;
+          case kUser0 ... kUser9: cRemote::PutMacro(key); key = kNone; break;
+          case k_Plugin: {
+               const char *PluginName = cRemote::GetPlugin();
+               if (PluginName) {
+                  DELETE_MENU;
+                  if (cControl::Control())
+                     cControl::Control()->Hide();
+                  cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
+                  if (plugin) {
+                     Menu = plugin->MainMenuAction();
+                     if (Menu)
+                        Menu->Show();
+                     }
+                  else
+                     esyslog("ERROR: unknown plugin '%s'", PluginName);
+                  }
+               key = kNone; // nobody else needs to see these keys
+               }
+               break;
+          // Channel up/down:
+          case kChanUp|k_Repeat:
+          case kChanUp:
+          case kChanDn|k_Repeat:
+          case kChanDn:
+               if (!Interact)
+                  Menu = new cDisplayChannel(NORMALKEY(key));
+               else if (cDisplayChannel::IsOpen() || cControl::Control()) {
+                  Interact->ProcessKey(key);
+                  continue;
+                  }
+               else
+                  cDevice::SwitchChannel(NORMALKEY(key) == kChanUp ? 1 : -1);
+               key = kNone; // nobody else needs to see these keys
+               break;
+          // Volume control:
+          case kVolUp|k_Repeat:
+          case kVolUp:
+          case kVolDn|k_Repeat:
+          case kVolDn:
+          case kMute:
+               if (key == kMute) {
+                  if (!cDevice::PrimaryDevice()->ToggleMute() && !Menu) {
+                     key = kNone; // nobody else needs to see these keys
+                     break; // no need to display "mute off"
+                     }
+                  }
+               else
+                  cDevice::PrimaryDevice()->SetVolume(NORMALKEY(key) == kVolDn ? -VOLUMEDELTA : VOLUMEDELTA);
+               if (!Menu && !cOsd::IsOpen())
+                  Menu = cDisplayVolume::Create();
+               cDisplayVolume::Process(key);
+               key = kNone; // nobody else needs to see these keys
+               break;
+          // Audio track control:
+          case kAudio:
+               if (cControl::Control())
+                  cControl::Control()->Hide();
+               if (!cDisplayTracks::IsOpen()) {
+                  DELETE_MENU;
+                  Menu = cDisplayTracks::Create();
+                  }
+               else
+                  cDisplayTracks::Process(key);
+               key = kNone;
+               break;
+          // Subtitle track control:
+          case kSubtitles:
+               if (cControl::Control())
+                  cControl::Control()->Hide();
+               if (!cDisplaySubtitleTracks::IsOpen()) {
+                  DELETE_MENU;
+                  Menu = cDisplaySubtitleTracks::Create();
+                  }
+               else
+                  cDisplaySubtitleTracks::Process(key);
+               key = kNone;
+               break;
+          // Pausing live video:
+          case kPlayPause:
+          case kPause:
+               if (!cControl::Control()) {
+                  DELETE_MENU;
+                  if (Setup.PauseKeyHandling) {
+                     if (Setup.PauseKeyHandling > 1 || Interface->Confirm(tr("Pause live video?"))) {
+                        if (!cRecordControls::PauseLiveVideo())
+                           Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
+                        }
+                     }
+                  key = kNone; // nobody else needs to see this key
+                  }
+               break;
+          // Instant recording:
+          case kRecord:
+               if (!cControl::Control()) {
+                  if (cRecordControls::Start())
+                     Skins.QueueMessage(mtInfo, tr("Recording started"));
+                  key = kNone; // nobody else needs to see this key
+                  }
+               break;
+          // Power off:
+          case kPower:
+               isyslog("Power button pressed");
+               DELETE_MENU;
+               // Check for activity, request power button again if active:
+               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
+                  // Not pressed power - set VDR to be non-interactive and power down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // No activity or power button pressed twice - ask for confirmation:
+               if (!ShutdownHandler.ConfirmShutdown(true)) {
+                  // Non-confirmed background activity - set VDR to be non-interactive and power down later:
+                  ShutdownHandler.SetUserInactive();
+                  break;
+                  }
+               // Ask the final question:
+               if (!Interface->Confirm(tr("Press any key to cancel shutdown"), SHUTDOWNCANCELPROMPT, true))
+                  // If final question was canceled, continue to be active:
+                  break;
+               // Ok, now call the shutdown script:
+               ShutdownHandler.DoShutdown(true);
+               // Set VDR to be non-interactive and power down again later:
+               ShutdownHandler.SetUserInactive();
+               // Do not attempt to automatically shut down for a while:
+               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+               break;
+          default: break;
+          }
+        Interact = Menu ? Menu : cControl::Control(); // might have been closed in the mean time
+        if (Interact) {
+           LastInteract = Now;
+           eOSState state = Interact->ProcessKey(key);
+           if (state == osUnknown && Interact != cControl::Control()) {
+              if (ISMODELESSKEY(key) && cControl::Control()) {
+                 state = cControl::Control()->ProcessKey(key);
+                 if (state == osEnd) {
+                    // let's not close a menu when replay ends:
+                    cControl::Shutdown();
+                    continue;
+                    }
+                 }
+              else if (Now - cRemote::LastActivity() > MENUTIMEOUT)
+                 state = osEnd;
+              }
+           switch (state) {
+             case osPause:  DELETE_MENU;
+                            if (!cRecordControls::PauseLiveVideo())
+                               Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
+                            break;
+             case osRecord: DELETE_MENU;
+                            if (cRecordControls::Start())
+                               Skins.QueueMessage(mtInfo, tr("Recording started"));
+                            break;
+             case osRecordings:
+                            DELETE_MENU;
+                            cControl::Shutdown();
+                            Menu = new cMenuMain(osRecordings);
+                            break;
+             case osReplay: DELETE_MENU;
+                            cControl::Shutdown();
+                            cControl::Launch(new cReplayControl);
+                            break;
+             case osStopReplay:
+                            DELETE_MENU;
+                            cControl::Shutdown();
+                            break;
+             case osSwitchDvb:
+                            DELETE_MENU;
+                            cControl::Shutdown();
+                            Skins.QueueMessage(mtInfo, tr("Switching primary DVB..."));
+                            cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
+                            break;
+             case osPlugin: DELETE_MENU;
+                            Menu = cMenuMain::PluginOsdObject();
+                            if (Menu)
+                               Menu->Show();
+                            break;
+             case osBack:
+             case osEnd:    if (Interact == Menu)
+                               DELETE_MENU;
+                            else
+                               cControl::Shutdown();
+                            break;
+             default:       ;
+             }
+           }
+        else {
+           // Key functions in "normal" viewing mode:
+           if (key != kNone && KeyMacros.Get(key)) {
+              cRemote::PutMacro(key);
+              key = kNone;
+              }
+           switch (int(key)) {
+             // Toggle channels:
+             case kChanPrev:
+             case k0: {
+                  if (PreviousChannel[PreviousChannelIndex ^ 1] == LastChannel || LastChannel != PreviousChannel[0] && LastChannel != PreviousChannel[1])
+                     PreviousChannelIndex ^= 1;
+                  Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
+                  break;
+                  }
+             // Direct Channel Select:
+             case k1 ... k9:
+             // Left/Right rotates through channel groups:
+             case kLeft|k_Repeat:
+             case kLeft:
+             case kRight|k_Repeat:
+             case kRight:
+             // Previous/Next rotates through channel groups:
+             case kPrev|k_Repeat:
+             case kPrev:
+             case kNext|k_Repeat:
+             case kNext:
+             // Up/Down Channel Select:
+             case kUp|k_Repeat:
+             case kUp:
+             case kDown|k_Repeat:
+             case kDown:
+                  Menu = new cDisplayChannel(NORMALKEY(key));
+                  break;
+             // Viewing Control:
+             case kOk:   LastChannel = -1; break; // forces channel display
+             // Instant resume of the last viewed recording:
+             case kPlay:
+                  if (cReplayControl::LastReplayed()) {
+                     cControl::Shutdown();
+                     cControl::Launch(new cReplayControl);
+                     }
+                  else
+                     DirectMainFunction(osRecordings); // no last viewed recording, so enter the Recordings menu
+                  break;
+             default:    break;
+             }
+           }
+        if (!Menu) {
+           if (!InhibitEpgScan)
+              EITScanner.Process();
+           if (!cCutter::Active() && cCutter::Ended()) {
+              if (cCutter::Error())
+                 Skins.Message(mtError, tr("Editing process failed!"));
+              else
+                 Skins.Message(mtInfo, tr("Editing process finished"));
+              }
+           if (!cFileTransfer::Active() && cFileTransfer::Ended()) {
+              if (cFileTransfer::Error())
+                 Skins.Message(mtError, tr("File transfer failed!"));
+              else
+                 Skins.Message(mtInfo, tr("File transfer finished"));
+              }
+           }
+
+        // SIGHUP shall cause a restart:
+        if (LastSignal == SIGHUP) {
+           if (ShutdownHandler.ConfirmRestart(true) && Interface->Confirm(tr("Press any key to cancel restart"), RESTARTCANCELPROMPT, true))
+              EXIT(1);
+           LastSignal = 0;
+           }
+
+        // Update the shutdown countdown:
+        if (ShutdownHandler.countdown && ShutdownHandler.countdown.Update()) {
+           if (!ShutdownHandler.ConfirmShutdown(false))
+              ShutdownHandler.countdown.Cancel();
+           }
+
+        if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !cFileTransfer::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
+           // Handle housekeeping tasks
+
+           // Shutdown:
+           // Check whether VDR will be ready for shutdown in SHUTDOWNWAIT seconds:
+           time_t Soon = Now + SHUTDOWNWAIT;
+           if (ShutdownHandler.IsUserInactive(Soon) && ShutdownHandler.Retry(Soon) && !ShutdownHandler.countdown) {
+              if (ShutdownHandler.ConfirmShutdown(false))
+                 // Time to shut down - start final countdown:
+                 ShutdownHandler.countdown.Start(tr("VDR will shut down in %s minutes"), SHUTDOWNWAIT); // the placeholder is really %s!
+              // Dont try to shut down again for a while:
+              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+              }
+           // Countdown run down to 0?
+           if (ShutdownHandler.countdown.Done()) {
+              // Timed out, now do a final check:
+              if (ShutdownHandler.IsUserInactive() && ShutdownHandler.ConfirmShutdown(false))
+                 ShutdownHandler.DoShutdown(false);
+              // Do this again a bit later:
+              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
+              }
+
+           // Disk housekeeping:
+           RemoveDeletedRecordings();
+           cSchedules::Cleanup();
+           // Plugins housekeeping:
+           PluginManager.Housekeeping();
+           }
+
+        ReportEpgBugFixStats();
+
+        // Main thread hooks of plugins:
+        PluginManager.MainThreadHook();
+        }
+
+  if (ShutdownHandler.EmergencyExitRequested())
+     esyslog("emergency exit requested - shutting down");
+
+Exit:
+
+  // Reset all signal handlers to default before Interface gets deleted:
+  signal(SIGHUP,  SIG_DFL);
+  signal(SIGINT,  SIG_DFL);
+  signal(SIGTERM, SIG_DFL);
+  signal(SIGPIPE, SIG_DFL);
+  signal(SIGALRM, SIG_DFL);
+
+  PluginManager.StopPlugins();
+  cRecordControls::Shutdown();
+  cFileTransfer::Stop();
+  cCutter::Stop();
+  delete Menu;
+  cControl::Shutdown();
+  delete Interface;
+  cOsdProvider::Shutdown();
+  Remotes.Clear();
+  Audios.Clear();
+  Skins.Clear();
+  SourceParams.Clear();
+  if (ShutdownHandler.GetExitCode() != 2) {
+     Setup.CurrentChannel = cDevice::CurrentChannel();
+     Setup.CurrentVolume  = cDevice::CurrentVolume();
+     Setup.Save();
+     }
+  cDevice::Shutdown();
+  cPositioner::DestroyPositioner();
+  EpgHandlers.Clear();
+  PluginManager.Shutdown(true);
+  cSchedules::Cleanup(true);
+  ReportEpgBugFixStats(true);
+  if (WatchdogTimeout > 0)
+     dsyslog("max. latency time %d seconds", MaxLatencyTime);
+  if (LastSignal)
+     isyslog("caught signal %d", LastSignal);
+  if (ShutdownHandler.EmergencyExitRequested())
+     esyslog("emergency exit!");
+  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
+  if (SysLogLevel > 0)
+     closelog();
+  if (HasStdin)
+     tcsetattr(STDIN_FILENO, TCSANOW, &savedTm);
+  return ShutdownHandler.GetExitCode();
+}
