Index: src/VBox/Additions/x11/vboxvideo/Makefile.kmk
===================================================================
--- src/VBox/Additions/x11/vboxvideo/Makefile.kmk	(Revision 52145)
+++ src/VBox/Additions/x11/vboxvideo/Makefile.kmk	(Revision 52146)
@@ -360,6 +360,20 @@
 vboxvideo_drv_115_SOURCES := $(vboxvideo_drv_17_SOURCES)
 
 
+#
+# vboxvideo_drv_116
+#
+DLLS += vboxvideo_drv_116
+vboxvideo_drv_116_TEMPLATE = VBOXGUESTR3XORGMOD
+vboxvideo_drv_116_CFLAGS := $(vboxvideo_drv_70_CFLAGS)
+vboxvideo_drv_116_DEFS := $(vboxvideo_15_DEFS) XORG_VERSION_CURRENT=101600000
+vboxvideo_drv_116_INCS = \
+	$(vboxvideo_xorg_INCS) \
+	$(VBOX_PATH_X11_ROOT)/xorg-server-1.16.0
+vboxvideo_drv_116_INCS += $(PATH_ROOT)/src/VBox/Runtime/include
+vboxvideo_drv_116_SOURCES := $(vboxvideo_drv_17_SOURCES)
+
+
 ifdef VBOX_USE_SYSTEM_XORG_HEADERS
  # Build using local X.Org headers.  We assume X.Org Server 1.7 or later.
  DLLS    := $(filter-out vboxvideo_drv_%,$(DLLS)) vboxvideo_drv_system
@@ -413,7 +427,7 @@
 	$$(QUIET)$$(APPEND) -t "$$@" "done"
     endef
 
-    $(foreach ver, _70 _71 _13 _14 _15 _16 _17 _18 _19 _110 _111 _112 _113 _114 _115, $(eval $(def_vboxvideo_test)))
+    $(foreach ver, _70 _71 _13 _14 _15 _16 _17 _18 _19 _110 _111 _112 _113 _114 _115 _116, $(eval $(def_vboxvideo_test)))
 
     endif # ! VBOX_ONLY_SDK
    endif # eq ($(KBUILD_HOST_ARCH),$(KBUILD_TARGET_ARCH))
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/set.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/set.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/set.h	(Revision 52145)
@@ -0,0 +1,135 @@
+/*
+
+Copyright 1995, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/*
+	  A Set Abstract Data Type (ADT) for the RECORD Extension
+			   David P. Wiggins
+			       7/25/95
+
+    The RECORD extension server code needs to maintain sets of numbers
+    that designate protocol message types.  In most cases the interval of
+    numbers starts at 0 and does not exceed 255, but in a few cases (minor
+    opcodes of extension requests) the maximum is 65535.  This disparity
+    suggests that a single set representation may not be suitable for all
+    sets, especially given that server memory is precious.  We introduce a
+    set ADT to hide implementation differences so that multiple
+    simultaneous set representations can exist.  A single interface is
+    presented to the set user regardless of the implementation in use for
+    a particular set.
+
+    The existing RECORD SI appears to require only four set operations:
+    create (given a list of members), destroy, see if a particular number
+    is a member of the set, and iterate over the members of a set.  Though
+    many more set operations are imaginable, to keep the code space down,
+    we won't provide any more operations than are needed.
+
+    The following types and functions/macros define the ADT.
+*/
+
+/* an interval of set members */
+typedef struct {
+    CARD16 first;
+    CARD16 last;
+} RecordSetInterval;
+
+typedef struct _RecordSetRec *RecordSetPtr;     /* primary set type */
+
+typedef void *RecordSetIteratePtr;
+
+/* table of function pointers for set operations.
+   set users should never declare a variable of this type.
+*/
+typedef struct {
+    void (*DestroySet) (RecordSetPtr pSet);
+    unsigned long (*IsMemberOfSet) (RecordSetPtr pSet, int possible_member);
+     RecordSetIteratePtr(*IterateSet) (RecordSetPtr pSet,
+                                       RecordSetIteratePtr pIter,
+                                       RecordSetInterval * interval);
+} RecordSetOperations;
+
+/* "base class" for sets.
+   set users should never declare a variable of this type.
+ */
+typedef struct _RecordSetRec {
+    RecordSetOperations *ops;
+} RecordSetRec;
+
+RecordSetPtr RecordCreateSet(RecordSetInterval * intervals,
+                             int nintervals, void *pMem, int memsize);
+/*
+    RecordCreateSet creates and returns a new set having members specified
+    by intervals and nintervals.  nintervals is the number of RecordSetInterval
+    structures pointed to by intervals.  The elements belonging to the new
+    set are determined as follows.  For each RecordSetInterval structure, the
+    elements between first and last inclusive are members of the new set.
+    If a RecordSetInterval's first field is greater than its last field, the
+    results are undefined.  It is valid to create an empty set (nintervals ==
+    0).  If RecordCreateSet returns NULL, the set could not be created due
+    to resource constraints.
+*/
+
+int RecordSetMemoryRequirements(RecordSetInterval * /*pIntervals */ ,
+                                int /*nintervals */ ,
+                                int *   /*alignment */
+    );
+
+#define RecordDestroySet(_pSet) \
+	/* void */ (*_pSet->ops->DestroySet)(/* RecordSetPtr */ _pSet)
+/*
+    RecordDestroySet frees all resources used by _pSet.  _pSet should not be
+    used after it is destroyed.
+*/
+
+#define RecordIsMemberOfSet(_pSet, _m) \
+  /* unsigned long */ (*_pSet->ops->IsMemberOfSet)(/* RecordSetPtr */ _pSet, \
+						   /* int */ _m)
+/*
+    RecordIsMemberOfSet returns a non-zero value if _m is a member of
+    _pSet, else it returns zero.
+*/
+
+#define RecordIterateSet(_pSet, _pIter, _interval) \
+ /* RecordSetIteratePtr */ (*_pSet->ops->IterateSet)(/* RecordSetPtr */ _pSet,\
+	/* RecordSetIteratePtr */ _pIter, /* RecordSetInterval */ _interval)
+/*
+    RecordIterateSet returns successive intervals of members of _pSet.  If
+    _pIter is NULL, the first interval of set members is copied into _interval.
+    The return value should be passed as _pIter in the next call to
+    RecordIterateSet to obtain the next interval.  When the return value is
+    NULL, there were no more intervals in the set, and nothing is copied into
+    the _interval parameter.  Intervals appear in increasing numerical order
+    with no overlap between intervals.  As such, the list of intervals produced
+    by RecordIterateSet may not match the list of intervals that were passed
+    in RecordCreateSet.  Typical usage:
+
+	pIter = NULL;
+	while (pIter = RecordIterateSet(pSet, pIter, &interval))
+	{
+	    process interval;
+	}
+*/

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/set.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_util.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_util.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_util.h	(Revision 52145)
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __GLX_INDIRECT_UTIL_H__
+#define __GLX_INDIRECT_UTIL_H__
+
+extern GLint __glGetBooleanv_variable_size(GLenum e);
+
+extern void *__glXGetAnswerBuffer(__GLXclientState * cl,
+                                  size_t required_size, void *local_buffer,
+                                  size_t local_size, unsigned alignment);
+
+extern void __glXSendReply(ClientPtr client, const void *data,
+                           size_t elements, size_t element_size,
+                           GLboolean always_array, CARD32 retval);
+
+extern void __glXSendReplySwap(ClientPtr client, const void *data,
+                               size_t elements, size_t element_size,
+                               GLboolean always_array, CARD32 retval);
+
+struct __glXDispatchInfo;
+
+extern void *__glXGetProtocolDecodeFunction(const struct __glXDispatchInfo
+                                            *dispatch_info, int opcode,
+                                            int swapped_version);
+
+extern int __glXGetProtocolSizeData(const struct __glXDispatchInfo
+                                    *dispatch_info, int opcode,
+                                    __GLXrenderSizeData * data);
+
+#endif                          /* __GLX_INDIRECT_UTIL_H__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_util.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmode.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmode.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmode.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETMODE_H
+#define SETMODE_H 1
+
+int SProcXSetDeviceMode(ClientPtr       /* client */
+    );
+
+int ProcXSetDeviceMode(ClientPtr        /* client */
+    );
+
+void SRepXSetDeviceMode(ClientPtr /* client */ ,
+                        int /* size */ ,
+                        xSetDeviceModeReply *   /* rep */
+    );
+
+#endif                          /* SETMODE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmode.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pseudoramiX.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pseudoramiX.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pseudoramiX.h	(Revision 52145)
@@ -0,0 +1,10 @@
+/*
+ * Minimal implementation of PanoramiX/Xinerama
+ */
+
+extern int noPseudoramiXExtension;
+
+void
+PseudoramiXAddScreen(int x, int y, int w, int h);
+void
+PseudoramiXResetScreens(void);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pseudoramiX.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdummy.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdummy.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdummy.h	(Revision 52145)
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to dummy input device support.  \see dmxdummy.c */
+
+#ifndef _DMXDUMMY_H_
+#define _DMXDUMMY_H_
+
+extern void dmxDummyMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxDummyKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdummy.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstr.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXFONTSTRUCT_H
+#define DIXFONTSTRUCT_H
+
+#include "servermd.h"
+#include "dixfont.h"
+#include <X11/fonts/fontstruct.h>
+#include "closure.h"
+#include <X11/Xproto.h>         /* for xQueryFontReply */
+
+#define FONTCHARSET(font)	  (font)
+#define FONTMAXBOUNDS(font,field) (font)->info.maxbounds.field
+#define FONTMINBOUNDS(font,field) (font)->info.minbounds.field
+#define TERMINALFONT(font)	  (font)->info.terminalFont
+#define FONTASCENT(font)	  (font)->info.fontAscent
+#define FONTDESCENT(font)	  (font)->info.fontDescent
+#define FONTGLYPHS(font)	  0
+#define FONTCONSTMETRICS(font)	  (font)->info.constantMetrics
+#define FONTCONSTWIDTH(font)	  (font)->info.constantWidth
+#define FONTALLEXIST(font)	  (font)->info.allExist
+#define FONTFIRSTCOL(font)	  (font)->info.firstCol
+#define FONTLASTCOL(font)	  (font)->info.lastCol
+#define FONTFIRSTROW(font)	  (font)->info.firstRow
+#define FONTLASTROW(font)	  (font)->info.lastRow
+#define FONTDEFAULTCH(font)	  (font)->info.defaultCh
+#define FONTINKMIN(font)	  (&((font)->info.ink_minbounds))
+#define FONTINKMAX(font)	  (&((font)->info.ink_maxbounds))
+#define FONTPROPS(font)		  (font)->info.props
+#define FONTGLYPHBITS(base,pci)	  ((unsigned char *) (pci)->bits)
+#define FONTINFONPROPS(font)	  (font)->info.nprops
+
+/* some things haven't changed names, but we'll be careful anyway */
+
+#define FONTREFCNT(font)	  (font)->refcnt
+
+/*
+ * for linear char sets
+ */
+#define N1dChars(pfont)	(FONTLASTCOL(pfont) - FONTFIRSTCOL(pfont) + 1)
+
+/*
+ * for 2D char sets
+ */
+#define N2dChars(pfont)	(N1dChars(pfont) * \
+			 (FONTLASTROW(pfont) - FONTFIRSTROW(pfont) + 1))
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES -1
+#endif
+
+#if GLYPHPADBYTES == 0 || GLYPHPADBYTES == 1
+#define	GLYPHWIDTHBYTESPADDED(pci)	(GLYPHWIDTHBYTES(pci))
+#define	PADGLYPHWIDTHBYTES(w)		(((w)+7)>>3)
+#endif
+
+#if GLYPHPADBYTES == 2
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+1) & ~0x1)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+1) & ~0x1)
+#endif
+
+#if GLYPHPADBYTES == 4
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+3) & ~0x3)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+3) & ~0x3)
+#endif
+
+#if GLYPHPADBYTES == 8          /* for a cray? */
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+7) & ~0x7)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+7) & ~0x7)
+#endif
+
+#endif                          /* DIXFONTSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/allowev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/allowev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/allowev.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef ALLOWEV_H
+#define ALLOWEV_H 1
+
+int SProcXAllowDeviceEvents(ClientPtr   /* client */
+    );
+
+int ProcXAllowDeviceEvents(ClientPtr    /* client */
+    );
+
+#endif                          /* ALLOWEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/allowev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glyphstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glyphstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glyphstr.h	(Revision 52145)
@@ -0,0 +1,142 @@
+/*
+ *
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _GLYPHSTR_H_
+#define _GLYPHSTR_H_
+
+#include <X11/extensions/renderproto.h>
+#include "picture.h"
+#include "screenint.h"
+#include "regionstr.h"
+#include "miscstruct.h"
+#include "privates.h"
+
+#define GlyphFormat1	0
+#define GlyphFormat4	1
+#define GlyphFormat8	2
+#define GlyphFormat16	3
+#define GlyphFormat32	4
+#define GlyphFormatNum	5
+
+typedef struct _Glyph {
+    CARD32 refcnt;
+    PrivateRec *devPrivates;
+    unsigned char sha1[20];
+    CARD32 size;                /* info + bitmap */
+    xGlyphInfo info;
+    /* per-screen pixmaps follow */
+} GlyphRec, *GlyphPtr;
+
+#define GlyphPicture(glyph) ((PicturePtr *) ((glyph) + 1))
+
+typedef struct _GlyphRef {
+    CARD32 signature;
+    GlyphPtr glyph;
+} GlyphRefRec, *GlyphRefPtr;
+
+#define DeletedGlyph	((GlyphPtr) 1)
+
+typedef struct _GlyphHashSet {
+    CARD32 entries;
+    CARD32 size;
+    CARD32 rehash;
+} GlyphHashSetRec, *GlyphHashSetPtr;
+
+typedef struct _GlyphHash {
+    GlyphRefPtr table;
+    GlyphHashSetPtr hashSet;
+    CARD32 tableEntries;
+} GlyphHashRec, *GlyphHashPtr;
+
+typedef struct _GlyphSet {
+    CARD32 refcnt;
+    int fdepth;
+    PictFormatPtr format;
+    GlyphHashRec hash;
+    PrivateRec *devPrivates;
+} GlyphSetRec, *GlyphSetPtr;
+
+#define GlyphSetGetPrivate(pGlyphSet,k)					\
+    dixLookupPrivate(&(pGlyphSet)->devPrivates, k)
+
+#define GlyphSetSetPrivate(pGlyphSet,k,ptr)				\
+    dixSetPrivate(&(pGlyphSet)->devPrivates, k, ptr)
+
+typedef struct _GlyphList {
+    INT16 xOff;
+    INT16 yOff;
+    CARD8 len;
+    PictFormatPtr format;
+} GlyphListRec, *GlyphListPtr;
+
+extern _X_EXPORT void
+ GlyphUninit(ScreenPtr pScreen);
+
+extern _X_EXPORT GlyphHashSetPtr FindGlyphHashSet(CARD32 filled);
+
+extern _X_EXPORT GlyphRefPtr
+FindGlyphRef(GlyphHashPtr hash,
+             CARD32 signature, Bool match, unsigned char sha1[20]);
+
+extern _X_EXPORT GlyphPtr FindGlyphByHash(unsigned char sha1[20], int format);
+
+extern _X_EXPORT int
+
+HashGlyph(xGlyphInfo * gi,
+          CARD8 *bits, unsigned long size, unsigned char sha1[20]);
+
+extern _X_EXPORT void
+ FreeGlyph(GlyphPtr glyph, int format);
+
+extern _X_EXPORT void
+ AddGlyph(GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id);
+
+extern _X_EXPORT Bool
+ DeleteGlyph(GlyphSetPtr glyphSet, Glyph id);
+
+extern _X_EXPORT GlyphPtr FindGlyph(GlyphSetPtr glyphSet, Glyph id);
+
+extern _X_EXPORT GlyphPtr AllocateGlyph(xGlyphInfo * gi, int format);
+
+extern _X_EXPORT Bool
+ AllocateGlyphHash(GlyphHashPtr hash, GlyphHashSetPtr hashSet);
+
+extern _X_EXPORT Bool
+ ResizeGlyphHash(GlyphHashPtr hash, CARD32 change, Bool global);
+
+extern _X_EXPORT Bool
+ ResizeGlyphSet(GlyphSetPtr glyphSet, CARD32 change);
+
+extern _X_EXPORT GlyphSetPtr AllocateGlyphSet(int fdepth, PictFormatPtr format);
+
+extern _X_EXPORT int
+ FreeGlyphSet(void *value, XID gid);
+
+#define GLYPH_HAS_GLYPH_PICTURE_ACCESSOR 1 /* used for api compat */
+extern _X_EXPORT PicturePtr
+ GetGlyphPicture(GlyphPtr glyph, ScreenPtr pScreen);
+extern _X_EXPORT void
+ SetGlyphPicture(GlyphPtr glyph, ScreenPtr pScreen, PicturePtr picture);
+
+#endif                          /* _GLYPHSTR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glyphstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfocus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfocus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfocus.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETFOCUS_H
+#define GETFOCUS_H 1
+
+int SProcXGetDeviceFocus(ClientPtr      /* client */
+    );
+
+int ProcXGetDeviceFocus(ClientPtr       /* client */
+    );
+
+void SRepXGetDeviceFocus(ClientPtr /* client */ ,
+                         int /* size */ ,
+                         xGetDeviceFocusReply * /* rep */
+    );
+
+#endif                          /* GETFOCUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfocus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/unpack.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/unpack.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/unpack.h	(Revision 52145)
@@ -0,0 +1,227 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef __GLX_unpack_h__
+#define __GLX_unpack_h__
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#define __GLX_PAD(s) (((s)+3) & (GLuint)~3)
+
+/*
+** Fetch the context-id out of a SingleReq request pointed to by pc.
+*/
+#define __GLX_GET_SINGLE_CONTEXT_TAG(pc) (((xGLXSingleReq*)pc)->contextTag)
+#define __GLX_GET_VENDPRIV_CONTEXT_TAG(pc) (((xGLXVendorPrivateReq*)pc)->contextTag)
+
+/*
+** Fetch a double from potentially unaligned memory.
+*/
+#ifdef __GLX_ALIGN64
+#define __GLX_MEM_COPY(dst,src,n)	memmove(dst,src,n)
+#define __GLX_GET_DOUBLE(dst,src)	__GLX_MEM_COPY(&dst,src,8)
+#else
+#define __GLX_GET_DOUBLE(dst,src)	(dst) = *((GLdouble*)(src))
+#endif
+
+extern void __glXMemInit(void);
+
+extern xGLXSingleReply __glXReply;
+
+#define __GLX_BEGIN_REPLY(size) \
+  	__glXReply.length = __GLX_PAD(size) >> 2;	\
+  	__glXReply.type = X_Reply; 			\
+  	__glXReply.sequenceNumber = client->sequence;
+
+#define __GLX_SEND_HEADER() \
+	WriteToClient (client, sz_xGLXSingleReply, &__glXReply);
+
+#define __GLX_PUT_RETVAL(a) \
+  	__glXReply.retval = (a);
+
+#define __GLX_PUT_SIZE(a) \
+  	__glXReply.size = (a);
+
+#define __GLX_PUT_RENDERMODE(m) \
+        __glXReply.pad3 = (m)
+
+/*
+** Get a buffer to hold returned data, with the given alignment.  If we have
+** to realloc, allocate size+align, in case the pointer has to be bumped for
+** alignment.  The answerBuffer should already be aligned.
+**
+** NOTE: the cast (long)res below assumes a long is large enough to hold a
+** pointer.
+*/
+#define __GLX_GET_ANSWER_BUFFER(res,cl,size,align)			 \
+    if ((size) > sizeof(answerBuffer)) {				 \
+	int bump;							 \
+	if ((cl)->returnBufSize < (size)+(align)) {			 \
+	    (cl)->returnBuf = (GLbyte*)realloc((cl)->returnBuf,	 	 \
+						(size)+(align));         \
+	    if (!(cl)->returnBuf) {					 \
+		return BadAlloc;					 \
+	    }								 \
+	    (cl)->returnBufSize = (size)+(align);			 \
+	}								 \
+	res = (char*)cl->returnBuf;					 \
+	bump = (long)(res) % (align);					 \
+	if (bump) res += (align) - (bump);				 \
+    } else {								 \
+	res = (char *)answerBuffer;					 \
+    }
+
+#define __GLX_PUT_BYTE() \
+  	*(GLbyte *)&__glXReply.pad3 = *(GLbyte *)answer
+
+#define __GLX_PUT_SHORT() \
+  	*(GLshort *)&__glXReply.pad3 = *(GLshort *)answer
+
+#define __GLX_PUT_INT() \
+  	*(GLint *)&__glXReply.pad3 = *(GLint *)answer
+
+#define __GLX_PUT_FLOAT() \
+  	*(GLfloat *)&__glXReply.pad3 = *(GLfloat *)answer
+
+#define __GLX_PUT_DOUBLE() \
+  	*(GLdouble *)&__glXReply.pad3 = *(GLdouble *)answer
+
+#define __GLX_SEND_BYTE_ARRAY(len) \
+	WriteToClient(client, __GLX_PAD((len)*__GLX_SIZE_INT8), answer)
+
+#define __GLX_SEND_SHORT_ARRAY(len) \
+	WriteToClient(client, __GLX_PAD((len)*__GLX_SIZE_INT16), answer)
+
+#define __GLX_SEND_INT_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_INT32, answer)
+
+#define __GLX_SEND_FLOAT_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_FLOAT32, answer)
+
+#define __GLX_SEND_DOUBLE_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_FLOAT64, answer)
+
+#define __GLX_SEND_VOID_ARRAY(len)  __GLX_SEND_BYTE_ARRAY(len)
+#define __GLX_SEND_UBYTE_ARRAY(len)  __GLX_SEND_BYTE_ARRAY(len)
+#define __GLX_SEND_USHORT_ARRAY(len) __GLX_SEND_SHORT_ARRAY(len)
+#define __GLX_SEND_UINT_ARRAY(len)  __GLX_SEND_INT_ARRAY(len)
+
+/*
+** PERFORMANCE NOTE:
+** Machine dependent optimizations abound here; these swapping macros can
+** conceivably be replaced with routines that do the job faster.
+*/
+#define __GLX_DECLARE_SWAP_VARIABLES \
+	GLbyte sw
+
+#define __GLX_DECLARE_SWAP_ARRAY_VARIABLES \
+  	GLbyte *swapPC;		\
+  	GLbyte *swapEnd
+
+#define __GLX_SWAP_INT(pc) 			\
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[3]; 	\
+  	((GLbyte *)(pc))[3] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[2]; 	\
+  	((GLbyte *)(pc))[2] = sw;
+
+#define __GLX_SWAP_SHORT(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[1]; 	\
+  	((GLbyte *)(pc))[1] = sw;
+
+#define __GLX_SWAP_DOUBLE(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[7]; 	\
+  	((GLbyte *)(pc))[7] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[6]; 	\
+  	((GLbyte *)(pc))[6] = sw;			\
+  	sw = ((GLbyte *)(pc))[2]; 		\
+  	((GLbyte *)(pc))[2] = ((GLbyte *)(pc))[5]; 	\
+  	((GLbyte *)(pc))[5] = sw;			\
+  	sw = ((GLbyte *)(pc))[3]; 		\
+  	((GLbyte *)(pc))[3] = ((GLbyte *)(pc))[4]; 	\
+  	((GLbyte *)(pc))[4] = sw;
+
+#define __GLX_SWAP_FLOAT(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[3]; 	\
+  	((GLbyte *)(pc))[3] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[2]; 	\
+  	((GLbyte *)(pc))[2] = sw;
+
+#define __GLX_SWAP_INT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_INT32;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_INT(swapPC);		\
+	    swapPC += __GLX_SIZE_INT32;		\
+	}
+
+#define __GLX_SWAP_SHORT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_INT16;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_SHORT(swapPC);		\
+	    swapPC += __GLX_SIZE_INT16;		\
+	}
+
+#define __GLX_SWAP_DOUBLE_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_FLOAT64;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_DOUBLE(swapPC);		\
+	    swapPC += __GLX_SIZE_FLOAT64;	\
+	}
+
+#define __GLX_SWAP_FLOAT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_FLOAT32;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_FLOAT(swapPC);		\
+	    swapPC += __GLX_SIZE_FLOAT32;	\
+	}
+
+#define __GLX_SWAP_REPLY_HEADER() \
+  	__GLX_SWAP_SHORT(&__glXReply.sequenceNumber); \
+  	__GLX_SWAP_INT(&__glXReply.length);
+
+#define __GLX_SWAP_REPLY_RETVAL() \
+  	__GLX_SWAP_INT(&__glXReply.retval)
+
+#define __GLX_SWAP_REPLY_SIZE() \
+  	__GLX_SWAP_INT(&__glXReply.size)
+
+#endif                          /* !__GLX_unpack_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/unpack.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swaprep.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swaprep.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swaprep.h	(Revision 52145)
@@ -0,0 +1,260 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREP_H
+#define SWAPREP_H 1
+
+extern _X_EXPORT void Swap32Write(ClientPtr /* pClient */ ,
+                                  int /* size */ ,
+                                  CARD32 * /* pbuf */ );
+
+extern _X_EXPORT void CopySwap32Write(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      CARD32 * /* pbuf */ );
+
+extern _X_EXPORT void CopySwap16Write(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      short * /* pbuf */ );
+
+extern _X_EXPORT void SGenericReply(ClientPtr /* pClient */ ,
+                                    int /* size */ ,
+                                    xGenericReply * /* pRep */ );
+
+extern _X_EXPORT void SGetWindowAttributesReply(ClientPtr /* pClient */ ,
+                                                int /* size */ ,
+                                                xGetWindowAttributesReply *
+                                                /* pRep */ );
+
+extern _X_EXPORT void SGetGeometryReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xGetGeometryReply * /* pRep */ );
+
+extern _X_EXPORT void SQueryTreeReply(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      xQueryTreeReply * /* pRep */ );
+
+extern _X_EXPORT void SInternAtomReply(ClientPtr /* pClient */ ,
+                                       int /* size */ ,
+                                       xInternAtomReply * /* pRep */ );
+
+extern _X_EXPORT void SGetAtomNameReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xGetAtomNameReply * /* pRep */ );
+
+extern _X_EXPORT void SGetPropertyReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xGetPropertyReply * /* pRep */ );
+
+extern _X_EXPORT void SListPropertiesReply(ClientPtr /* pClient */ ,
+                                           int /* size */ ,
+                                           xListPropertiesReply * /* pRep */ );
+
+extern _X_EXPORT void SGetSelectionOwnerReply(ClientPtr /* pClient */ ,
+                                              int /* size */ ,
+                                              xGetSelectionOwnerReply *
+                                              /* pRep */ );
+
+extern _X_EXPORT void SQueryPointerReply(ClientPtr /* pClient */ ,
+                                         int /* size */ ,
+                                         xQueryPointerReply * /* pRep */ );
+
+extern _X_EXPORT void SwapTimeCoordWrite(ClientPtr /* pClient */ ,
+                                         int /* size */ ,
+                                         xTimecoord * /* pRep */ );
+
+extern _X_EXPORT void SGetMotionEventsReply(ClientPtr /* pClient */ ,
+                                            int /* size */ ,
+                                            xGetMotionEventsReply * /* pRep */
+                                            );
+
+extern _X_EXPORT void STranslateCoordsReply(ClientPtr /* pClient */ ,
+                                            int /* size */ ,
+                                            xTranslateCoordsReply * /* pRep */
+                                            );
+
+extern _X_EXPORT void SGetInputFocusReply(ClientPtr /* pClient */ ,
+                                          int /* size */ ,
+                                          xGetInputFocusReply * /* pRep */ );
+
+extern _X_EXPORT void SQueryKeymapReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xQueryKeymapReply * /* pRep */ );
+
+extern _X_EXPORT void SQueryFontReply(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      xQueryFontReply * /* pRep */ );
+
+extern _X_EXPORT void SQueryTextExtentsReply(ClientPtr /* pClient */ ,
+                                             int /* size */ ,
+                                             xQueryTextExtentsReply * /* pRep */
+                                             );
+
+extern _X_EXPORT void SListFontsReply(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      xListFontsReply * /* pRep */ );
+
+extern _X_EXPORT void SListFontsWithInfoReply(ClientPtr /* pClient */ ,
+                                              int /* size */ ,
+                                              xListFontsWithInfoReply *
+                                              /* pRep */ );
+
+extern _X_EXPORT void SGetFontPathReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xGetFontPathReply * /* pRep */ );
+
+extern _X_EXPORT void SGetImageReply(ClientPtr /* pClient */ ,
+                                     int /* size */ ,
+                                     xGetImageReply * /* pRep */ );
+
+extern _X_EXPORT void SListInstalledColormapsReply(ClientPtr /* pClient */ ,
+                                                   int /* size */ ,
+                                                   xListInstalledColormapsReply
+                                                   * /* pRep */ );
+
+extern _X_EXPORT void SAllocColorReply(ClientPtr /* pClient */ ,
+                                       int /* size */ ,
+                                       xAllocColorReply * /* pRep */ );
+
+extern _X_EXPORT void SAllocNamedColorReply(ClientPtr /* pClient */ ,
+                                            int /* size */ ,
+                                            xAllocNamedColorReply * /* pRep */
+                                            );
+
+extern _X_EXPORT void SAllocColorCellsReply(ClientPtr /* pClient */ ,
+                                            int /* size */ ,
+                                            xAllocColorCellsReply * /* pRep */
+                                            );
+
+extern _X_EXPORT void SAllocColorPlanesReply(ClientPtr /* pClient */ ,
+                                             int /* size */ ,
+                                             xAllocColorPlanesReply * /* pRep */
+                                             );
+
+extern _X_EXPORT void SQColorsExtend(ClientPtr /* pClient */ ,
+                                     int /* size */ ,
+                                     xrgb * /* prgb */ );
+
+extern _X_EXPORT void SQueryColorsReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xQueryColorsReply * /* pRep */ );
+
+extern _X_EXPORT void SLookupColorReply(ClientPtr /* pClient */ ,
+                                        int /* size */ ,
+                                        xLookupColorReply * /* pRep */ );
+
+extern _X_EXPORT void SQueryBestSizeReply(ClientPtr /* pClient */ ,
+                                          int /* size */ ,
+                                          xQueryBestSizeReply * /* pRep */ );
+
+extern _X_EXPORT void SListExtensionsReply(ClientPtr /* pClient */ ,
+                                           int /* size */ ,
+                                           xListExtensionsReply * /* pRep */ );
+
+extern _X_EXPORT void SGetKeyboardMappingReply(ClientPtr /* pClient */ ,
+                                               int /* size */ ,
+                                               xGetKeyboardMappingReply *
+                                               /* pRep */ );
+
+extern _X_EXPORT void SGetPointerMappingReply(ClientPtr /* pClient */ ,
+                                              int /* size */ ,
+                                              xGetPointerMappingReply *
+                                              /* pRep */ );
+
+extern _X_EXPORT void SGetModifierMappingReply(ClientPtr /* pClient */ ,
+                                               int /* size */ ,
+                                               xGetModifierMappingReply *
+                                               /* pRep */ );
+
+extern _X_EXPORT void SGetKeyboardControlReply(ClientPtr /* pClient */ ,
+                                               int /* size */ ,
+                                               xGetKeyboardControlReply *
+                                               /* pRep */ );
+
+extern _X_EXPORT void SGetPointerControlReply(ClientPtr /* pClient */ ,
+                                              int /* size */ ,
+                                              xGetPointerControlReply *
+                                              /* pRep */ );
+
+extern _X_EXPORT void SGetScreenSaverReply(ClientPtr /* pClient */ ,
+                                           int /* size */ ,
+                                           xGetScreenSaverReply * /* pRep */ );
+
+extern _X_EXPORT void SLHostsExtend(ClientPtr /* pClient */ ,
+                                    int /* size */ ,
+                                    char * /* buf */ );
+
+extern _X_EXPORT void SListHostsReply(ClientPtr /* pClient */ ,
+                                      int /* size */ ,
+                                      xListHostsReply * /* pRep */ );
+
+extern _X_EXPORT void SErrorEvent(xError * /* from */ ,
+                                  xError * /* to */ );
+
+extern _X_EXPORT void SwapConnSetupInfo(char * /* pInfo */ ,
+                                        char * /* pInfoTBase */ );
+
+extern _X_EXPORT void WriteSConnectionInfo(ClientPtr /* pClient */ ,
+                                           unsigned long /* size */ ,
+                                           char * /* pInfo */ );
+
+extern _X_EXPORT void SwapConnSetupPrefix(xConnSetupPrefix * /* pcspFrom */ ,
+                                          xConnSetupPrefix * /* pcspTo */ );
+
+extern _X_EXPORT void WriteSConnSetupPrefix(ClientPtr /* pClient */ ,
+                                            xConnSetupPrefix * /* pcsp */ );
+
+#undef SWAPREP_PROC
+#define SWAPREP_PROC(func) extern _X_EXPORT void func(xEvent * /* from */, xEvent * /* to */)
+
+SWAPREP_PROC(SCirculateEvent);
+SWAPREP_PROC(SClientMessageEvent);
+SWAPREP_PROC(SColormapEvent);
+SWAPREP_PROC(SConfigureNotifyEvent);
+SWAPREP_PROC(SConfigureRequestEvent);
+SWAPREP_PROC(SCreateNotifyEvent);
+SWAPREP_PROC(SDestroyNotifyEvent);
+SWAPREP_PROC(SEnterLeaveEvent);
+SWAPREP_PROC(SExposeEvent);
+SWAPREP_PROC(SFocusEvent);
+SWAPREP_PROC(SGraphicsExposureEvent);
+SWAPREP_PROC(SGravityEvent);
+SWAPREP_PROC(SKeyButtonPtrEvent);
+SWAPREP_PROC(SKeymapNotifyEvent);
+SWAPREP_PROC(SMapNotifyEvent);
+SWAPREP_PROC(SMapRequestEvent);
+SWAPREP_PROC(SMappingEvent);
+SWAPREP_PROC(SNoExposureEvent);
+SWAPREP_PROC(SPropertyEvent);
+SWAPREP_PROC(SReparentEvent);
+SWAPREP_PROC(SResizeRequestEvent);
+SWAPREP_PROC(SSelectionClearEvent);
+SWAPREP_PROC(SSelectionNotifyEvent);
+SWAPREP_PROC(SSelectionRequestEvent);
+SWAPREP_PROC(SUnmapNotifyEvent);
+SWAPREP_PROC(SVisibilityEvent);
+
+#undef SWAPREP_PROC
+
+#endif                          /* SWAPREP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swaprep.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventconvert.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventconvert.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventconvert.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _EVENTCONVERT_H_
+#include <X11/X.h>
+#include <X11/extensions/XIproto.h>
+#include "input.h"
+#include "events.h"
+#include "eventstr.h"
+
+_X_EXPORT int EventToCore(InternalEvent *event, xEvent **core, int *count);
+_X_EXPORT int EventToXI(InternalEvent *ev, xEvent **xi, int *count);
+_X_EXPORT int EventToXI2(InternalEvent *ev, xEvent **xi);
+_X_INTERNAL int GetCoreType(enum EventType type);
+_X_INTERNAL int GetXIType(enum EventType type);
+_X_INTERNAL int GetXI2Type(enum EventType type);
+
+#endif                          /* _EVENTCONVERT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventconvert.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxarg.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxarg.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxarg.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to argument handling functions.  \see dmxarg.c */
+
+#ifndef _DMXARG_H_
+#define _DMXARG_H_
+
+typedef struct _dmxArg *dmxArg;
+
+extern dmxArg dmxArgCreate(void);
+extern void dmxArgFree(dmxArg a);
+extern void dmxArgAdd(dmxArg a, const char *string);
+extern const char *dmxArgV(dmxArg a, int item);
+extern int dmxArgC(dmxArg a);
+extern dmxArg dmxArgParse(const char *string);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxarg.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/decode.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/decode.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/decode.h	(Revision 52145)
@@ -0,0 +1,87 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for instruction decoding logic.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_DECODE_H
+#define __X86EMU_DECODE_H
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+/* Instruction Decoding Stuff */
+
+#define FETCH_DECODE_MODRM(mod,rh,rl) 	fetch_decode_modrm(&mod,&rh,&rl)
+#define DECODE_RM_BYTE_REGISTER(r)    	decode_rm_byte_register(r)
+#define DECODE_RM_WORD_REGISTER(r)    	decode_rm_word_register(r)
+#define DECODE_RM_LONG_REGISTER(r)    	decode_rm_long_register(r)
+#define DECODE_CLEAR_SEGOVR()         	M.x86.mode &= ~SYSMODE_CLRMASK
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+    void x86emu_intr_raise(u8 type);
+    void fetch_decode_modrm(int *mod, int *regh, int *regl);
+    u8 fetch_byte_imm(void);
+    u16 fetch_word_imm(void);
+    u32 fetch_long_imm(void);
+    u8 fetch_data_byte(uint offset);
+    u8 fetch_data_byte_abs(uint segment, uint offset);
+    u16 fetch_data_word(uint offset);
+    u16 fetch_data_word_abs(uint segment, uint offset);
+    u32 fetch_data_long(uint offset);
+    u32 fetch_data_long_abs(uint segment, uint offset);
+    void store_data_byte(uint offset, u8 val);
+    void store_data_byte_abs(uint segment, uint offset, u8 val);
+    void store_data_word(uint offset, u16 val);
+    void store_data_word_abs(uint segment, uint offset, u16 val);
+    void store_data_long(uint offset, u32 val);
+    void store_data_long_abs(uint segment, uint offset, u32 val);
+    u8 *decode_rm_byte_register(int reg);
+    u16 *decode_rm_word_register(int reg);
+    u32 *decode_rm_long_register(int reg);
+    u16 *decode_rm_seg_register(int reg);
+    u32 decode_rm00_address(int rm);
+    u32 decode_rm01_address(int rm);
+    u32 decode_rm10_address(int rm);
+    u32 decode_sib_address(int sib, int mod);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_DECODE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/decode.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxextension.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxextension.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxextension.h	(Revision 52145)
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Author:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DMX extension support.  These routines are called by
+ * function in Xserver/Xext/dmx.c.  \see dmxextension.c */
+
+#ifndef _DMXEXTENSION_H_
+#define _DMXEXTENSION_H_
+
+/** Screen attributes.  Used by #ProcDMXGetScreenAttributes and
+ * \a ProcDMXChangeScreensAttributes. */
+typedef struct {
+    const char *displayName;
+    int logicalScreen;
+
+    unsigned int screenWindowWidth;     /* displayName's coordinate system */
+    unsigned int screenWindowHeight;    /* displayName's coordinate system */
+    int screenWindowXoffset;    /* displayName's coordinate system */
+    int screenWindowYoffset;    /* displayName's coordinate system */
+
+    unsigned int rootWindowWidth;       /* screenWindow's coordinate system */
+    unsigned int rootWindowHeight;      /* screenWindow's coordinate system */
+    int rootWindowXoffset;      /* screenWindow's coordinate system */
+    int rootWindowYoffset;      /* screenWindow's coordinate system */
+
+    int rootWindowXorigin;      /* global coordinate system */
+    int rootWindowYorigin;      /* global coordinate system */
+} DMXScreenAttributesRec, *DMXScreenAttributesPtr;
+
+/** Window attributes.  Used by #ProcDMXGetWindowAttributes. */
+typedef struct {
+    int screen;
+    Window window;
+    xRectangle pos;
+    xRectangle vis;
+} DMXWindowAttributesRec, *DMXWindowAttributesPtr;
+
+/** Desktop attributes.  Used by #ProcDMXGetDesktopAttributes and
+ * #ProcDMXChangeDesktopAttributes. */
+typedef struct {
+    int width;
+    int height;
+    int shiftX;
+    int shiftY;
+} DMXDesktopAttributesRec, *DMXDesktopAttributesPtr;
+
+/** Input attributes.  Used by #ProcDMXGetInputAttributes. */
+typedef struct {
+    const char *name;
+    int inputType;
+    int physicalScreen;
+    int physicalId;
+    int isCore;
+    int sendsCore;
+    int detached;
+} DMXInputAttributesRec, *DMXInputAttributesPtr;
+
+extern unsigned long dmxGetNumScreens(void);
+extern void dmxForceWindowCreation(WindowPtr pWindow);
+extern void dmxFlushPendingSyncs(void);
+extern Bool dmxGetScreenAttributes(int physical, DMXScreenAttributesPtr attr);
+extern Bool dmxGetWindowAttributes(WindowPtr pWindow,
+                                   DMXWindowAttributesPtr attr);
+extern void dmxGetDesktopAttributes(DMXDesktopAttributesPtr attr);
+extern int dmxGetInputCount(void);
+extern int dmxGetInputAttributes(int deviceId, DMXInputAttributesPtr attr);
+extern int dmxAddInput(DMXInputAttributesPtr attr, int *deviceId);
+extern int dmxRemoveInput(int deviceId);
+
+extern int dmxConfigureScreenWindows(int nscreens,
+                                     CARD32 *screens,
+                                     DMXScreenAttributesPtr attribs,
+                                     int *errorScreen);
+
+extern int dmxConfigureDesktop(DMXDesktopAttributesPtr attribs);
+
+/* dmxUpdateScreenResources exposed for dmxCreateWindow in dmxwindow.c */
+extern void dmxUpdateScreenResources(ScreenPtr pScreen,
+                                     int x, int y, int w, int h);
+
+extern int dmxAttachScreen(int idx, DMXScreenAttributesPtr attr);
+extern int dmxDetachScreen(int idx);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxextension.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getdctl.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getdctl.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getdctl.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETDCTL_H
+#define GETDCTL_H 1
+
+int SProcXGetDeviceControl(ClientPtr    /* client */
+    );
+
+int ProcXGetDeviceControl(ClientPtr     /* client */
+    );
+
+void SRepXGetDeviceControl(ClientPtr /* client */ ,
+                           int /* size */ ,
+                           xGetDeviceControlReply *     /* rep */
+    );
+
+#endif                          /* GETDCTL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getdctl.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86.h	(Revision 52145)
@@ -0,0 +1,453 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains declarations for public XFree86 functions and variables,
+ * and definitions of public macros.
+ *
+ * "public" means available to video drivers.
+ */
+
+#ifndef _XF86_H
+#define _XF86_H
+
+#if HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#elif HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "xf86str.h"
+#include "xf86Opt.h"
+#include <X11/Xfuncproto.h>
+#include <stdarg.h>
+#ifdef RANDR
+#include <X11/extensions/randr.h>
+#endif
+
+#include "propertyst.h"
+
+/* General parameters */
+extern _X_EXPORT int xf86DoConfigure;
+extern _X_EXPORT int xf86DoShowOptions;
+extern _X_EXPORT Bool xf86DoConfigurePass1;
+extern _X_EXPORT Bool xorgHWAccess;
+
+extern _X_EXPORT DevPrivateKeyRec xf86ScreenKeyRec;
+
+#define xf86ScreenKey (&xf86ScreenKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec xf86CreateRootWindowKeyRec;
+
+#define xf86CreateRootWindowKey (&xf86CreateRootWindowKeyRec)
+
+extern _X_EXPORT ScrnInfoPtr *xf86Screens;      /* List of pointers to ScrnInfoRecs */
+extern _X_EXPORT const unsigned char byte_reversed[256];
+extern _X_EXPORT Bool fbSlotClaimed;
+
+#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
+extern _X_EXPORT Bool sbusSlotClaimed;
+#endif
+
+#if defined(XSERVER_PLATFORM_BUS)
+extern _X_EXPORT int platformSlotClaimed;
+#endif
+
+extern _X_EXPORT confDRIRec xf86ConfigDRI;
+extern _X_EXPORT Bool xf86DRI2Enabled(void);
+
+extern _X_EXPORT Bool VTSwitchEnabled;  /* kbd driver */
+
+#define XF86SCRNINFO(p) xf86ScreenToScrn(p)
+
+#define XF86FLIP_PIXELS() \
+	do { \
+	    if (xf86GetFlipPixels()) { \
+		pScreen->whitePixel = (pScreen->whitePixel) ? 0 : 1; \
+		pScreen->blackPixel = (pScreen->blackPixel) ? 0 : 1; \
+	   } \
+	while (0)
+
+#define BOOLTOSTRING(b) ((b) ? "TRUE" : "FALSE")
+
+#define PIX24TOBPP(p) (((p) == Pix24Use24) ? 24 : \
+			(((p) == Pix24Use32) ? 32 : 0))
+
+/* Function Prototypes */
+#ifndef _NO_XF86_PROTOTYPES
+
+/* PCI related */
+#ifdef XSERVER_LIBPCIACCESS
+#include <pciaccess.h>
+extern _X_EXPORT int pciSlotClaimed;
+
+extern _X_EXPORT Bool xf86CheckPciSlot(const struct pci_device *);
+extern _X_EXPORT int xf86ClaimPciSlot(struct pci_device *, DriverPtr drvp,
+                                      int chipset, GDevPtr dev, Bool active);
+extern _X_EXPORT void xf86UnclaimPciSlot(struct pci_device *, GDevPtr dev);
+extern _X_EXPORT Bool xf86ParsePciBusString(const char *busID, int *bus,
+                                            int *device, int *func);
+extern _X_EXPORT Bool xf86ComparePciBusString(const char *busID, int bus,
+                                              int device, int func);
+extern _X_EXPORT Bool xf86IsPrimaryPci(struct pci_device *pPci);
+extern _X_EXPORT Bool xf86CheckPciMemBase(struct pci_device *pPci,
+                                          memType base);
+extern _X_EXPORT struct pci_device *xf86GetPciInfoForEntity(int entityIndex);
+extern _X_EXPORT int xf86MatchPciInstances(const char *driverName,
+                                           int vendorID, SymTabPtr chipsets,
+                                           PciChipsets * PCIchipsets,
+                                           GDevPtr * devList, int numDevs,
+                                           DriverPtr drvp, int **foundEntities);
+extern _X_EXPORT ScrnInfoPtr xf86ConfigPciEntity(ScrnInfoPtr pScrn,
+                                                 int scrnFlag, int entityIndex,
+                                                 PciChipsets * p_chip,
+                                                 void *dummy, EntityProc init,
+                                                 EntityProc enter,
+                                                 EntityProc leave,
+                                                 void *private);
+/* Obsolete! don't use */
+extern _X_EXPORT Bool xf86ConfigActivePciEntity(ScrnInfoPtr pScrn,
+                                                int entityIndex,
+                                                PciChipsets * p_chip,
+                                                void *dummy, EntityProc init,
+                                                EntityProc enter,
+                                                EntityProc leave,
+                                                void *private);
+#else
+#define xf86VGAarbiterInit() do {} while (0)
+#define xf86VGAarbiterFini() do {} while (0)
+#define xf86VGAarbiterLock(x) do {} while (0)
+#define xf86VGAarbiterUnlock(x) do {} while (0)
+#define xf86VGAarbiterScrnInit(x) do {} while (0)
+#define xf86VGAarbiterDeviceDecodes() do {} while (0)
+#define xf86VGAarbiterWrapFunctions() do {} while (0)
+#endif
+
+/* xf86Bus.c */
+
+extern _X_EXPORT int xf86GetFbInfoForScreen(int scrnIndex);
+extern _X_EXPORT int xf86ClaimFbSlot(DriverPtr drvp, int chipset, GDevPtr dev,
+                                     Bool active);
+extern _X_EXPORT int xf86ClaimNoSlot(DriverPtr drvp, int chipset, GDevPtr dev,
+                                     Bool active);
+extern _X_EXPORT Bool xf86DriverHasEntities(DriverPtr drvp);
+extern _X_EXPORT void xf86AddEntityToScreen(ScrnInfoPtr pScrn, int entityIndex);
+extern _X_EXPORT void xf86SetEntityInstanceForScreen(ScrnInfoPtr pScrn,
+                                                     int entityIndex,
+                                                     int instance);
+extern _X_EXPORT int xf86GetNumEntityInstances(int entityIndex);
+extern _X_EXPORT GDevPtr xf86GetDevFromEntity(int entityIndex, int instance);
+extern _X_EXPORT void xf86RemoveEntityFromScreen(ScrnInfoPtr pScrn,
+                                                 int entityIndex);
+extern _X_EXPORT EntityInfoPtr xf86GetEntityInfo(int entityIndex);
+extern _X_EXPORT Bool xf86SetEntityFuncs(int entityIndex, EntityProc init,
+                                         EntityProc enter, EntityProc leave,
+                                         void *);
+extern _X_EXPORT Bool xf86IsEntityPrimary(int entityIndex);
+extern _X_EXPORT ScrnInfoPtr xf86FindScreenForEntity(int entityIndex);
+
+extern _X_EXPORT int xf86GetLastScrnFlag(int entityIndex);
+extern _X_EXPORT void xf86SetLastScrnFlag(int entityIndex, int scrnIndex);
+extern _X_EXPORT Bool xf86IsEntityShared(int entityIndex);
+extern _X_EXPORT void xf86SetEntityShared(int entityIndex);
+extern _X_EXPORT Bool xf86IsEntitySharable(int entityIndex);
+extern _X_EXPORT void xf86SetEntitySharable(int entityIndex);
+extern _X_EXPORT Bool xf86IsPrimInitDone(int entityIndex);
+extern _X_EXPORT void xf86SetPrimInitDone(int entityIndex);
+extern _X_EXPORT void xf86ClearPrimInitDone(int entityIndex);
+extern _X_EXPORT int xf86AllocateEntityPrivateIndex(void);
+extern _X_EXPORT DevUnion *xf86GetEntityPrivate(int entityIndex, int privIndex);
+
+/* xf86Configure.c */
+extern _X_EXPORT GDevPtr xf86AddBusDeviceToConfigure(const char *driver,
+                                                     BusType bus, void *busData,
+                                                     int chipset);
+
+/* xf86Cursor.c */
+
+extern _X_EXPORT void xf86LockZoom(ScreenPtr pScreen, int lock);
+extern _X_EXPORT void xf86InitViewport(ScrnInfoPtr pScr);
+extern _X_EXPORT void xf86SetViewport(ScreenPtr pScreen, int x, int y);
+extern _X_EXPORT void xf86ZoomViewport(ScreenPtr pScreen, int zoom);
+extern _X_EXPORT Bool xf86SwitchMode(ScreenPtr pScreen, DisplayModePtr mode);
+extern _X_EXPORT void *xf86GetPointerScreenFuncs(void);
+extern _X_EXPORT void xf86InitOrigins(void);
+extern _X_EXPORT void xf86ReconfigureLayout(void);
+
+/* xf86DPMS.c */
+
+extern _X_EXPORT Bool xf86DPMSInit(ScreenPtr pScreen, DPMSSetProcPtr set,
+                                   int flags);
+
+/* xf86DGA.c */
+
+#ifdef XFreeXDGA
+extern _X_EXPORT Bool DGAInit(ScreenPtr pScreen, DGAFunctionPtr funcs,
+                              DGAModePtr modes, int num);
+extern _X_EXPORT Bool DGAReInitModes(ScreenPtr pScreen, DGAModePtr modes,
+                                     int num);
+extern _X_EXPORT xf86SetDGAModeProc xf86SetDGAMode;
+#endif
+
+/* xf86Events.c */
+
+typedef struct _InputInfoRec *InputInfoPtr;
+
+extern _X_EXPORT void SetTimeSinceLastInputEvent(void);
+extern _X_EXPORT void *xf86AddInputHandler(int fd, InputHandlerProc proc,
+                                             void *data);
+extern _X_EXPORT int xf86RemoveInputHandler(void *handler);
+extern _X_EXPORT void xf86DisableInputHandler(void *handler);
+extern _X_EXPORT void xf86EnableInputHandler(void *handler);
+extern _X_EXPORT void *xf86AddGeneralHandler(int fd, InputHandlerProc proc,
+                                               void *data);
+extern _X_EXPORT int xf86RemoveGeneralHandler(void *handler);
+extern _X_EXPORT void xf86DisableGeneralHandler(void *handler);
+extern _X_EXPORT void xf86EnableGeneralHandler(void *handler);
+extern _X_EXPORT InputHandlerProc xf86SetConsoleHandler(InputHandlerProc
+                                                        handler, void *data);
+extern _X_EXPORT void xf86InterceptSignals(int *signo);
+extern _X_EXPORT void xf86InterceptSigIll(void (*sigillhandler) (void));
+extern _X_EXPORT Bool xf86EnableVTSwitch(Bool new);
+extern _X_EXPORT void xf86ProcessActionEvent(ActionEvent action, void *arg);
+extern _X_EXPORT void xf86PrintBacktrace(void);
+extern _X_EXPORT Bool xf86VTOwner(void);
+extern _X_EXPORT void xf86VTLeave(void);
+extern _X_EXPORT void xf86VTEnter(void);
+extern _X_EXPORT void xf86EnableInputDeviceForVTSwitch(InputInfoPtr pInfo);
+extern _X_EXPORT void xf86DisableInputDeviceForVTSwitch(InputInfoPtr pInfo);
+
+/* xf86Helper.c */
+
+extern _X_EXPORT void xf86AddDriver(DriverPtr driver, void *module,
+                                    int flags);
+extern _X_EXPORT void xf86DeleteDriver(int drvIndex);
+extern _X_EXPORT ScrnInfoPtr xf86AllocateScreen(DriverPtr drv, int flags);
+extern _X_EXPORT void xf86DeleteScreen(ScrnInfoPtr pScrn);
+extern _X_EXPORT int xf86AllocateScrnInfoPrivateIndex(void);
+extern _X_EXPORT Bool xf86AddPixFormat(ScrnInfoPtr pScrn, int depth, int bpp,
+                                       int pad);
+extern _X_EXPORT Bool xf86SetDepthBpp(ScrnInfoPtr scrp, int depth, int bpp,
+                                      int fbbpp, int depth24flags);
+extern _X_EXPORT void xf86PrintDepthBpp(ScrnInfoPtr scrp);
+extern _X_EXPORT Bool xf86SetWeight(ScrnInfoPtr scrp, rgb weight, rgb mask);
+extern _X_EXPORT Bool xf86SetDefaultVisual(ScrnInfoPtr scrp, int visual);
+extern _X_EXPORT Bool xf86SetGamma(ScrnInfoPtr scrp, Gamma newGamma);
+extern _X_EXPORT void xf86SetDpi(ScrnInfoPtr pScrn, int x, int y);
+extern _X_EXPORT void xf86SetBlackWhitePixels(ScreenPtr pScreen);
+extern _X_EXPORT void xf86EnableDisableFBAccess(ScrnInfoPtr pScrn, Bool enable);
+extern _X_EXPORT void
+xf86VDrvMsgVerb(int scrnIndex, MessageType type, int verb,
+                const char *format, va_list args)
+_X_ATTRIBUTE_PRINTF(4, 0);
+extern _X_EXPORT void
+xf86DrvMsgVerb(int scrnIndex, MessageType type, int verb,
+               const char *format, ...)
+_X_ATTRIBUTE_PRINTF(4, 5);
+extern _X_EXPORT void
+xf86DrvMsg(int scrnIndex, MessageType type, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(3, 4);
+extern _X_EXPORT void
+xf86MsgVerb(MessageType type, int verb, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(3, 4);
+extern _X_EXPORT void
+xf86Msg(MessageType type, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT void
+xf86ErrorFVerb(int verb, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT void
+xf86ErrorF(const char *format, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+extern _X_EXPORT const char *
+xf86TokenToString(SymTabPtr table, int token);
+extern _X_EXPORT int
+xf86StringToToken(SymTabPtr table, const char *string);
+extern _X_EXPORT void
+xf86ShowClocks(ScrnInfoPtr scrp, MessageType from);
+extern _X_EXPORT void
+xf86PrintChipsets(const char *drvname, const char *drvmsg, SymTabPtr chips);
+extern _X_EXPORT int
+xf86MatchDevice(const char *drivername, GDevPtr ** driversectlist);
+extern _X_EXPORT const char *
+xf86GetVisualName(int visual);
+extern _X_EXPORT int
+xf86GetVerbosity(void);
+extern _X_EXPORT Pix24Flags
+xf86GetPix24(void);
+extern _X_EXPORT int
+xf86GetDepth(void);
+extern _X_EXPORT rgb
+xf86GetWeight(void);
+extern _X_EXPORT Gamma
+xf86GetGamma(void);
+extern _X_EXPORT Bool
+xf86GetFlipPixels(void);
+extern _X_EXPORT const char *
+xf86GetServerName(void);
+extern _X_EXPORT Bool
+xf86ServerIsExiting(void);
+extern _X_EXPORT Bool
+xf86ServerIsResetting(void);
+extern _X_EXPORT Bool
+xf86ServerIsInitialising(void);
+extern _X_EXPORT Bool
+xf86ServerIsOnlyDetecting(void);
+extern _X_EXPORT Bool
+xf86CaughtSignal(void);
+extern _X_EXPORT Bool
+xf86GetVidModeAllowNonLocal(void);
+extern _X_EXPORT Bool
+xf86GetVidModeEnabled(void);
+extern _X_EXPORT Bool
+xf86GetModInDevAllowNonLocal(void);
+extern _X_EXPORT Bool
+xf86GetModInDevEnabled(void);
+extern _X_EXPORT Bool
+xf86GetAllowMouseOpenFail(void);
+extern _X_EXPORT void
+xf86DisableRandR(void);
+extern _X_EXPORT CARD32
+xorgGetVersion(void);
+extern _X_EXPORT CARD32
+xf86GetModuleVersion(void *module);
+extern _X_EXPORT void *
+xf86LoadDrvSubModule(DriverPtr drv, const char *name);
+extern _X_EXPORT void *
+xf86LoadSubModule(ScrnInfoPtr pScrn, const char *name);
+extern _X_EXPORT void *
+xf86LoadOneModule(const char *name, void *optlist);
+extern _X_EXPORT void
+xf86UnloadSubModule(void *mod);
+extern _X_EXPORT Bool
+xf86LoaderCheckSymbol(const char *name);
+extern _X_EXPORT void
+xf86SetBackingStore(ScreenPtr pScreen);
+extern _X_EXPORT void
+xf86SetSilkenMouse(ScreenPtr pScreen);
+extern _X_EXPORT void *
+xf86FindXvOptions(ScrnInfoPtr pScrn, int adapt_index, const char *port_name,
+                  const char **adaptor_name, void **adaptor_options);
+extern _X_EXPORT void
+xf86GetOS(const char **name, int *major, int *minor, int *teeny);
+extern _X_EXPORT ScrnInfoPtr
+xf86ConfigFbEntity(ScrnInfoPtr pScrn, int scrnFlag,
+                   int entityIndex, EntityProc init,
+                   EntityProc enter, EntityProc leave, void *private);
+
+extern _X_EXPORT Bool
+xf86IsScreenPrimary(ScrnInfoPtr pScrn);
+extern _X_EXPORT int
+xf86RegisterRootWindowProperty(int ScrnIndex, Atom property, Atom type,
+                               int format, unsigned long len, void *value);
+extern _X_EXPORT Bool
+xf86IsUnblank(int mode);
+
+/* xf86Init.c */
+
+extern _X_EXPORT PixmapFormatPtr
+xf86GetPixFormat(ScrnInfoPtr pScrn, int depth);
+extern _X_EXPORT int
+xf86GetBppFromDepth(ScrnInfoPtr pScrn, int depth);
+
+/* xf86Mode.c */
+
+extern _X_EXPORT int
+xf86GetNearestClock(ScrnInfoPtr scrp, int freq, Bool allowDiv2,
+                    int DivFactor, int MulFactor, int *divider);
+extern _X_EXPORT const char *
+xf86ModeStatusToString(ModeStatus status);
+extern _X_EXPORT ModeStatus
+xf86LookupMode(ScrnInfoPtr scrp, DisplayModePtr modep,
+               ClockRangePtr clockRanges, LookupModeFlags strategy);
+extern _X_EXPORT ModeStatus
+xf86CheckModeForMonitor(DisplayModePtr mode, MonPtr monitor);
+extern _X_EXPORT ModeStatus
+xf86InitialCheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode,
+                              ClockRangePtr clockRanges,
+                              LookupModeFlags strategy,
+                              int maxPitch, int virtualX, int virtualY);
+extern _X_EXPORT ModeStatus
+xf86CheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode, int flags);
+extern _X_EXPORT int
+xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
+                  const char **modeNames, ClockRangePtr clockRanges,
+                  int *linePitches, int minPitch, int maxPitch,
+                  int minHeight, int maxHeight, int pitchInc,
+                  int virtualX, int virtualY, int apertureSize,
+                  LookupModeFlags strategy);
+extern _X_EXPORT void
+xf86DeleteMode(DisplayModePtr * modeList, DisplayModePtr mode);
+extern _X_EXPORT void
+xf86PruneDriverModes(ScrnInfoPtr scrp);
+extern _X_EXPORT void
+xf86SetCrtcForModes(ScrnInfoPtr scrp, int adjustFlags);
+extern _X_EXPORT void
+xf86PrintModes(ScrnInfoPtr scrp);
+extern _X_EXPORT void
+xf86ShowClockRanges(ScrnInfoPtr scrp, ClockRangePtr clockRanges);
+
+/* xf86Option.c */
+
+extern _X_EXPORT void
+xf86CollectOptions(ScrnInfoPtr pScrn, XF86OptionPtr extraOpts);
+
+/* xf86RandR.c */
+#ifdef RANDR
+extern _X_EXPORT Bool
+xf86RandRInit(ScreenPtr pScreen);
+extern _X_EXPORT Rotation
+xf86GetRotation(ScreenPtr pScreen);
+extern _X_EXPORT Bool
+xf86RandRSetNewVirtualAndDimensions(ScreenPtr pScreen,
+                                    int newvirtX, int newvirtY,
+                                    int newmmWidth, int newmmHeight,
+                                    Bool resetMode);
+#endif
+
+/* xf86Extensions.c */
+extern void xf86ExtensionInit(void);
+
+/* convert ScreenPtr to ScrnInfoPtr */
+extern _X_EXPORT ScrnInfoPtr xf86ScreenToScrn(ScreenPtr pScreen);
+/* convert ScrnInfoPtr to ScreenPtr */
+extern _X_EXPORT ScreenPtr xf86ScrnToScreen(ScrnInfoPtr pScrn);
+
+#endif                          /* _NO_XF86_PROTOTYPES */
+
+#define XF86_HAS_SCRN_CONV 1 /* define for drivers to use in api compat */
+
+#define XF86_SCRN_INTERFACE 1 /* define for drivers to use in api compat */
+
+/* flags passed to xf86 allocate screen */
+#define XF86_ALLOCATE_GPU_SCREEN 1
+
+/* Update the internal total dimensions of all ScreenRecs together */
+extern _X_EXPORT void
+xf86UpdateDesktopDimensions(void);
+
+#endif                          /* _XF86_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbgeom.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbgeom.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbgeom.h	(Revision 52145)
@@ -0,0 +1,563 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBGEOM_H_
+#define	_XKBGEOM_H_
+
+#include "xkbstr.h"
+
+#define XkbAddGeomKeyAlias 		SrvXkbAddGeomKeyAlias
+#define XkbAddGeomColor 		SrvXkbAddGeomColor
+#define XkbAddGeomDoodad		SrvXkbAddGeomDoodad
+#define XkbAddGeomKey			SrvXkbAddGeomKey
+#define XkbAddGeomOutline		SrvXkbAddGeomOutline
+#define XkbAddGeomOverlay		SrvXkbAddGeomOverlay
+#define XkbAddGeomOverlayRow		SrvXkbAddGeomOverlayRow
+#define	XkbAddGeomOverlayKey		SrvXkbAddGeomOverlayKey
+#define XkbAddGeomProperty		SrvXkbAddGeomProperty
+#define XkbAddGeomRow			SrvXkbAddGeomRow
+#define XkbAddGeomSection		SrvXkbAddGeomSection
+#define XkbAddGeomShape			SrvXkbAddGeomShape
+#define XkbAllocGeometry		SrvXkbAllocGeometry
+#define XkbFreeGeomKeyAliases		SrvXkbFreeGeomKeyAliases
+#define XkbFreeGeomColors		SrvXkbFreeGeomColors
+#define XkbFreeGeomDoodads		SrvXkbFreeGeomDoodads
+#define XkbFreeGeomProperties		SrvXkbFreeGeomProperties
+#define	XkbFreeGeomKeys			SrvXkbFreeGeomKeys
+#define	XkbFreeGeomRows			SrvXkbFreeGeomRows
+#define XkbFreeGeomSections		SrvXkbFreeGeomSections
+#define	XkbFreeGeomPoints		SrvXkbFreeGeomPoints
+#define	XkbFreeGeomOutlines		SrvXkbFreeGeomOutlines
+#define XkbFreeGeomShapes		SrvXkbFreeGeomShapes
+#define XkbFreeGeometry			SrvXkbFreeGeometry
+
+typedef struct _XkbProperty {
+    char *name;
+    char *value;
+} XkbPropertyRec, *XkbPropertyPtr;
+
+typedef struct _XkbColor {
+    unsigned int pixel;
+    char *spec;
+} XkbColorRec, *XkbColorPtr;
+
+typedef struct _XkbPoint {
+    short x;
+    short y;
+} XkbPointRec, *XkbPointPtr;
+
+typedef struct _XkbBounds {
+    short x1, y1;
+    short x2, y2;
+} XkbBoundsRec, *XkbBoundsPtr;
+
+#define	XkbBoundsWidth(b)	(((b)->x2)-((b)->x1))
+#define	XkbBoundsHeight(b)	(((b)->y2)-((b)->y1))
+
+typedef struct _XkbOutline {
+    unsigned short num_points;
+    unsigned short sz_points;
+    unsigned short corner_radius;
+    XkbPointPtr points;
+} XkbOutlineRec, *XkbOutlinePtr;
+
+typedef struct _XkbShape {
+    Atom name;
+    unsigned short num_outlines;
+    unsigned short sz_outlines;
+    XkbOutlinePtr outlines;
+    XkbOutlinePtr approx;
+    XkbOutlinePtr primary;
+    XkbBoundsRec bounds;
+} XkbShapeRec, *XkbShapePtr;
+
+#define	XkbOutlineIndex(s,o)	((int)((o)-&(s)->outlines[0]))
+
+typedef struct _XkbShapeDoodad {
+    Atom name;
+    unsigned char type;
+    unsigned char priority;
+    short top;
+    short left;
+    short angle;
+    unsigned short color_ndx;
+    unsigned short shape_ndx;
+} XkbShapeDoodadRec, *XkbShapeDoodadPtr;
+
+#define	XkbShapeDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
+#define	XkbShapeDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
+#define	XkbSetShapeDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetShapeDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbTextDoodad {
+    Atom name;
+    unsigned char type;
+    unsigned char priority;
+    short top;
+    short left;
+    short angle;
+    short width;
+    short height;
+    unsigned short color_ndx;
+    char *text;
+    char *font;
+} XkbTextDoodadRec, *XkbTextDoodadPtr;
+
+#define	XkbTextDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
+#define	XkbSetTextDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+
+typedef struct _XkbIndicatorDoodad {
+    Atom name;
+    unsigned char type;
+    unsigned char priority;
+    short top;
+    short left;
+    short angle;
+    unsigned short shape_ndx;
+    unsigned short on_color_ndx;
+    unsigned short off_color_ndx;
+} XkbIndicatorDoodadRec, *XkbIndicatorDoodadPtr;
+
+#define	XkbIndicatorDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
+#define	XkbIndicatorDoodadOnColor(g,d)	(&(g)->colors[(d)->on_color_ndx])
+#define	XkbIndicatorDoodadOffColor(g,d)	(&(g)->colors[(d)->off_color_ndx])
+#define	XkbSetIndicatorDoodadOnColor(g,d,c) \
+				((d)->on_color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetIndicatorDoodadOffColor(g,d,c) \
+				((d)->off_color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetIndicatorDoodadShape(g,d,s) \
+				((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbLogoDoodad {
+    Atom name;
+    unsigned char type;
+    unsigned char priority;
+    short top;
+    short left;
+    short angle;
+    unsigned short color_ndx;
+    unsigned short shape_ndx;
+    char *logo_name;
+} XkbLogoDoodadRec, *XkbLogoDoodadPtr;
+
+#define	XkbLogoDoodadColor(g,d)		(&(g)->colors[(d)->color_ndx])
+#define	XkbLogoDoodadShape(g,d)		(&(g)->shapes[(d)->shape_ndx])
+#define	XkbSetLogoDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetLogoDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbAnyDoodad {
+    Atom name;
+    unsigned char type;
+    unsigned char priority;
+    short top;
+    short left;
+    short angle;
+} XkbAnyDoodadRec, *XkbAnyDoodadPtr;
+
+typedef union _XkbDoodad {
+    XkbAnyDoodadRec any;
+    XkbShapeDoodadRec shape;
+    XkbTextDoodadRec text;
+    XkbIndicatorDoodadRec indicator;
+    XkbLogoDoodadRec logo;
+} XkbDoodadRec, *XkbDoodadPtr;
+
+#define	XkbUnknownDoodad	0
+#define	XkbOutlineDoodad	1
+#define	XkbSolidDoodad		2
+#define	XkbTextDoodad		3
+#define	XkbIndicatorDoodad	4
+#define	XkbLogoDoodad		5
+
+typedef struct _XkbKey {
+    XkbKeyNameRec name;
+    short gap;
+    unsigned char shape_ndx;
+    unsigned char color_ndx;
+} XkbKeyRec, *XkbKeyPtr;
+
+#define	XkbKeyShape(g,k)	(&(g)->shapes[(k)->shape_ndx])
+#define	XkbKeyColor(g,k)	(&(g)->colors[(k)->color_ndx])
+#define	XkbSetKeyShape(g,k,s)	((k)->shape_ndx= (s)-&(g)->shapes[0])
+#define	XkbSetKeyColor(g,k,c)	((k)->color_ndx= (c)-&(g)->colors[0])
+
+typedef struct _XkbRow {
+    short top;
+    short left;
+    unsigned short num_keys;
+    unsigned short sz_keys;
+    int vertical;
+    XkbKeyPtr keys;
+    XkbBoundsRec bounds;
+} XkbRowRec, *XkbRowPtr;
+
+typedef struct _XkbSection {
+    Atom name;
+    unsigned char priority;
+    short top;
+    short left;
+    unsigned short width;
+    unsigned short height;
+    short angle;
+    unsigned short num_rows;
+    unsigned short num_doodads;
+    unsigned short num_overlays;
+    unsigned short sz_rows;
+    unsigned short sz_doodads;
+    unsigned short sz_overlays;
+    XkbRowPtr rows;
+    XkbDoodadPtr doodads;
+    XkbBoundsRec bounds;
+    struct _XkbOverlay *overlays;
+} XkbSectionRec, *XkbSectionPtr;
+
+typedef struct _XkbOverlayKey {
+    XkbKeyNameRec over;
+    XkbKeyNameRec under;
+} XkbOverlayKeyRec, *XkbOverlayKeyPtr;
+
+typedef struct _XkbOverlayRow {
+    unsigned short row_under;
+    unsigned short num_keys;
+    unsigned short sz_keys;
+    XkbOverlayKeyPtr keys;
+} XkbOverlayRowRec, *XkbOverlayRowPtr;
+
+typedef struct _XkbOverlay {
+    Atom name;
+    XkbSectionPtr section_under;
+    unsigned short num_rows;
+    unsigned short sz_rows;
+    XkbOverlayRowPtr rows;
+    XkbBoundsPtr bounds;
+} XkbOverlayRec, *XkbOverlayPtr;
+
+typedef struct _XkbGeometry {
+    Atom name;
+    unsigned short width_mm;
+    unsigned short height_mm;
+    char *label_font;
+    XkbColorPtr label_color;
+    XkbColorPtr base_color;
+    unsigned short sz_properties;
+    unsigned short sz_colors;
+    unsigned short sz_shapes;
+    unsigned short sz_sections;
+    unsigned short sz_doodads;
+    unsigned short sz_key_aliases;
+    unsigned short num_properties;
+    unsigned short num_colors;
+    unsigned short num_shapes;
+    unsigned short num_sections;
+    unsigned short num_doodads;
+    unsigned short num_key_aliases;
+    XkbPropertyPtr properties;
+    XkbColorPtr colors;
+    XkbShapePtr shapes;
+    XkbSectionPtr sections;
+    XkbDoodadPtr doodads;
+    XkbKeyAliasPtr key_aliases;
+} XkbGeometryRec;
+
+#define	XkbGeomColorIndex(g,c)	((int)((c)-&(g)->colors[0]))
+
+#define	XkbGeomPropertiesMask	(1<<0)
+#define	XkbGeomColorsMask	(1<<1)
+#define	XkbGeomShapesMask	(1<<2)
+#define	XkbGeomSectionsMask	(1<<3)
+#define	XkbGeomDoodadsMask	(1<<4)
+#define	XkbGeomKeyAliasesMask	(1<<5)
+#define	XkbGeomAllMask		(0x3f)
+
+typedef struct _XkbGeometrySizes {
+    unsigned int which;
+    unsigned short num_properties;
+    unsigned short num_colors;
+    unsigned short num_shapes;
+    unsigned short num_sections;
+    unsigned short num_doodads;
+    unsigned short num_key_aliases;
+} XkbGeometrySizesRec, *XkbGeometrySizesPtr;
+
+/**
+ * Specifies which items should be cleared in an XKB geometry array
+ * when the array is reallocated.
+ */
+typedef enum {
+    XKB_GEOM_CLEAR_NONE,        /* Don't clear any items, just reallocate.   */
+    XKB_GEOM_CLEAR_EXCESS,      /* Clear new extra items after reallocation. */
+    XKB_GEOM_CLEAR_ALL          /* Clear all items after reallocation.       */
+} XkbGeomClearance;
+
+extern XkbPropertyPtr XkbAddGeomProperty(XkbGeometryPtr /* geom */ ,
+                                         char * /* name */ ,
+                                         char * /* value */
+    );
+
+extern XkbKeyAliasPtr XkbAddGeomKeyAlias(XkbGeometryPtr /* geom */ ,
+                                         char * /* alias */ ,
+                                         char * /* real */
+    );
+
+extern XkbColorPtr XkbAddGeomColor(XkbGeometryPtr /* geom */ ,
+                                   char * /* spec */ ,
+                                   unsigned int /* pixel */
+    );
+
+extern XkbOutlinePtr XkbAddGeomOutline(XkbShapePtr /* shape */ ,
+                                       int      /* sz_points */
+    );
+
+extern XkbShapePtr XkbAddGeomShape(XkbGeometryPtr /* geom */ ,
+                                   Atom /* name */ ,
+                                   int  /* sz_outlines */
+    );
+
+extern XkbKeyPtr XkbAddGeomKey(XkbRowPtr        /* row */
+    );
+
+extern XkbRowPtr XkbAddGeomRow(XkbSectionPtr /* section */ ,
+                               int      /* sz_keys */
+    );
+
+extern XkbSectionPtr XkbAddGeomSection(XkbGeometryPtr /* geom */ ,
+                                       Atom /* name */ ,
+                                       int /* sz_rows */ ,
+                                       int /* sz_doodads */ ,
+                                       int      /* sz_overlays */
+    );
+
+extern XkbOverlayPtr XkbAddGeomOverlay(XkbSectionPtr /* section */ ,
+                                       Atom /* name */ ,
+                                       int      /* sz_rows */
+    );
+
+extern XkbOverlayRowPtr XkbAddGeomOverlayRow(XkbOverlayPtr /* overlay */ ,
+                                             int /* row_under */ ,
+                                             int        /* sz_keys */
+    );
+
+extern XkbOverlayKeyPtr XkbAddGeomOverlayKey(XkbOverlayPtr /* overlay */ ,
+                                             XkbOverlayRowPtr /* row */ ,
+                                             char * /* over */ ,
+                                             char *     /* under */
+    );
+
+extern XkbDoodadPtr XkbAddGeomDoodad(XkbGeometryPtr /* geom */ ,
+                                     XkbSectionPtr /* section */ ,
+                                     Atom       /* name */
+    );
+
+extern void
+ XkbFreeGeomKeyAliases(XkbGeometryPtr /* geom */ ,
+                       int /* first */ ,
+                       int /* count */ ,
+                       Bool     /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomColors(XkbGeometryPtr /* geom */ ,
+                   int /* first */ ,
+                   int /* count */ ,
+                   Bool         /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomDoodads(XkbDoodadPtr /* doodads */ ,
+                    int /* nDoodads */ ,
+                    Bool        /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomProperties(XkbGeometryPtr /* geom */ ,
+                       int /* first */ ,
+                       int /* count */ ,
+                       Bool     /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomOverlayKeys(XkbOverlayRowPtr /* row */ ,
+                        int /* first */ ,
+                        int /* count */ ,
+                        Bool    /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomOverlayRows(XkbOverlayPtr /* overlay */ ,
+                        int /* first */ ,
+                        int /* count */ ,
+                        Bool    /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomOverlays(XkbSectionPtr /* section */ ,
+                     int /* first */ ,
+                     int /* count */ ,
+                     Bool       /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomKeys(XkbRowPtr /* row */ ,
+                 int /* first */ ,
+                 int /* count */ ,
+                 Bool           /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomRows(XkbSectionPtr /* section */ ,
+                 int /* first */ ,
+                 int /* count */ ,
+                 Bool           /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomSections(XkbGeometryPtr /* geom */ ,
+                     int /* first */ ,
+                     int /* count */ ,
+                     Bool       /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomPoints(XkbOutlinePtr /* outline */ ,
+                   int /* first */ ,
+                   int /* count */ ,
+                   Bool         /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomOutlines(XkbShapePtr /* shape */ ,
+                     int /* first */ ,
+                     int /* count */ ,
+                     Bool       /* freeAll */
+    );
+
+extern void
+ XkbFreeGeomShapes(XkbGeometryPtr /* geom */ ,
+                   int /* first */ ,
+                   int /* count */ ,
+                   Bool         /* freeAll */
+    );
+
+extern void
+ XkbFreeGeometry(XkbGeometryPtr /* geom */ ,
+                 unsigned int /* which */ ,
+                 Bool           /* freeMap */
+    );
+
+extern Bool
+ XkbGeomRealloc(void ** /* buffer */ ,
+                int /* szItems */ ,
+                int /* nrItems */ ,
+                int /* itemSize */ ,
+                XkbGeomClearance        /* clearance */
+    );
+
+extern Status XkbAllocGeomProps(XkbGeometryPtr /* geom */ ,
+                                int     /* nProps */
+    );
+
+extern Status XkbAllocGeomKeyAliases(XkbGeometryPtr /* geom */ ,
+                                     int        /* nAliases */
+    );
+
+extern Status XkbAllocGeomColors(XkbGeometryPtr /* geom */ ,
+                                 int    /* nColors */
+    );
+
+extern Status XkbAllocGeomShapes(XkbGeometryPtr /* geom */ ,
+                                 int    /* nShapes */
+    );
+
+extern Status XkbAllocGeomSections(XkbGeometryPtr /* geom */ ,
+                                   int  /* nSections */
+    );
+
+extern Status XkbAllocGeomOverlays(XkbSectionPtr /* section */ ,
+                                   int  /* num_needed */
+    );
+
+extern Status XkbAllocGeomOverlayRows(XkbOverlayPtr /* overlay */ ,
+                                      int       /* num_needed */
+    );
+
+extern Status XkbAllocGeomOverlayKeys(XkbOverlayRowPtr /* row */ ,
+                                      int       /* num_needed */
+    );
+
+extern Status XkbAllocGeomDoodads(XkbGeometryPtr /* geom */ ,
+                                  int   /* nDoodads */
+    );
+
+extern Status XkbAllocGeomSectionDoodads(XkbSectionPtr /* section */ ,
+                                         int    /* nDoodads */
+    );
+
+extern Status XkbAllocGeomOutlines(XkbShapePtr /* shape */ ,
+                                   int  /* nOL */
+    );
+
+extern Status XkbAllocGeomRows(XkbSectionPtr /* section */ ,
+                               int      /* nRows */
+    );
+
+extern Status XkbAllocGeomPoints(XkbOutlinePtr /* ol */ ,
+                                 int    /* nPts */
+    );
+
+extern Status XkbAllocGeomKeys(XkbRowPtr /* row */ ,
+                               int      /* nKeys */
+    );
+
+extern Status XkbAllocGeometry(XkbDescPtr /* xkb */ ,
+                               XkbGeometrySizesPtr      /* sizes */
+    );
+
+extern Bool
+ XkbComputeShapeTop(XkbShapePtr /* shape */ ,
+                    XkbBoundsPtr        /* bounds */
+    );
+
+extern Bool
+ XkbComputeShapeBounds(XkbShapePtr      /* shape */
+    );
+
+extern Bool
+ XkbComputeRowBounds(XkbGeometryPtr /* geom */ ,
+                     XkbSectionPtr /* section */ ,
+                     XkbRowPtr  /* row */
+    );
+
+extern Bool
+ XkbComputeSectionBounds(XkbGeometryPtr /* geom */ ,
+                         XkbSectionPtr  /* section */
+    );
+
+extern char *XkbFindOverlayForKey(XkbGeometryPtr /* geom */ ,
+                                  XkbSectionPtr /* wanted */ ,
+                                  char *        /* under */
+    );
+
+#endif                          /* _XKBGEOM_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbgeom.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ChkNotMaskEv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ChkNotMaskEv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ChkNotMaskEv.h	(Revision 52145)
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for #XCheckNotMaskEvent function.  \see ChkNotMaskEv.c */
+
+#ifndef _CHKNOTMASKEV_H_
+#define _CHKNOTMASKEV_H_
+extern Bool XCheckNotMaskEvent(Display * dpy, long mask, XEvent * event);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ChkNotMaskEv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gcstruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gcstruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gcstruct.h	(Revision 52145)
@@ -0,0 +1,292 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef GCSTRUCT_H
+#define GCSTRUCT_H
+
+#include "gc.h"
+
+#include "regionstr.h"
+#include "region.h"
+#include "pixmap.h"
+#include "screenint.h"
+#include "privates.h"
+#include <X11/Xprotostr.h>
+
+#define GCAllBits ((1 << (GCLastBit + 1)) - 1)
+
+/*
+ * functions which modify the state of the GC
+ */
+
+typedef struct _GCFuncs {
+    void (*ValidateGC) (GCPtr /*pGC */ ,
+                        unsigned long /*stateChanges */ ,
+                        DrawablePtr /*pDrawable */ );
+
+    void (*ChangeGC) (GCPtr /*pGC */ ,
+                      unsigned long /*mask */ );
+
+    void (*CopyGC) (GCPtr /*pGCSrc */ ,
+                    unsigned long /*mask */ ,
+                    GCPtr /*pGCDst */ );
+
+    void (*DestroyGC) (GCPtr /*pGC */ );
+
+    void (*ChangeClip) (GCPtr /*pGC */ ,
+                        int /*type */ ,
+                        void */*pvalue */ ,
+                        int /*nrects */ );
+
+    void (*DestroyClip) (GCPtr /*pGC */ );
+
+    void (*CopyClip) (GCPtr /*pgcDst */ ,
+                      GCPtr /*pgcSrc */ );
+} GCFuncs;
+
+/*
+ * graphics operations invoked through a GC
+ */
+
+typedef struct _GCOps {
+    void (*FillSpans) (DrawablePtr /*pDrawable */ ,
+                       GCPtr /*pGC */ ,
+                       int /*nInit */ ,
+                       DDXPointPtr /*pptInit */ ,
+                       int * /*pwidthInit */ ,
+                       int /*fSorted */ );
+
+    void (*SetSpans) (DrawablePtr /*pDrawable */ ,
+                      GCPtr /*pGC */ ,
+                      char * /*psrc */ ,
+                      DDXPointPtr /*ppt */ ,
+                      int * /*pwidth */ ,
+                      int /*nspans */ ,
+                      int /*fSorted */ );
+
+    void (*PutImage) (DrawablePtr /*pDrawable */ ,
+                      GCPtr /*pGC */ ,
+                      int /*depth */ ,
+                      int /*x */ ,
+                      int /*y */ ,
+                      int /*w */ ,
+                      int /*h */ ,
+                      int /*leftPad */ ,
+                      int /*format */ ,
+                      char * /*pBits */ );
+
+    RegionPtr (*CopyArea) (DrawablePtr /*pSrc */ ,
+                           DrawablePtr /*pDst */ ,
+                           GCPtr /*pGC */ ,
+                           int /*srcx */ ,
+                           int /*srcy */ ,
+                           int /*w */ ,
+                           int /*h */ ,
+                           int /*dstx */ ,
+                           int /*dsty */ );
+
+    RegionPtr (*CopyPlane) (DrawablePtr /*pSrcDrawable */ ,
+                            DrawablePtr /*pDstDrawable */ ,
+                            GCPtr /*pGC */ ,
+                            int /*srcx */ ,
+                            int /*srcy */ ,
+                            int /*width */ ,
+                            int /*height */ ,
+                            int /*dstx */ ,
+                            int /*dsty */ ,
+                            unsigned long /*bitPlane */ );
+    void (*PolyPoint) (DrawablePtr /*pDrawable */ ,
+                       GCPtr /*pGC */ ,
+                       int /*mode */ ,
+                       int /*npt */ ,
+                       DDXPointPtr /*pptInit */ );
+
+    void (*Polylines) (DrawablePtr /*pDrawable */ ,
+                       GCPtr /*pGC */ ,
+                       int /*mode */ ,
+                       int /*npt */ ,
+                       DDXPointPtr /*pptInit */ );
+
+    void (*PolySegment) (DrawablePtr /*pDrawable */ ,
+                         GCPtr /*pGC */ ,
+                         int /*nseg */ ,
+                         xSegment * /*pSegs */ );
+
+    void (*PolyRectangle) (DrawablePtr /*pDrawable */ ,
+                           GCPtr /*pGC */ ,
+                           int /*nrects */ ,
+                           xRectangle * /*pRects */ );
+
+    void (*PolyArc) (DrawablePtr /*pDrawable */ ,
+                     GCPtr /*pGC */ ,
+                     int /*narcs */ ,
+                     xArc * /*parcs */ );
+
+    void (*FillPolygon) (DrawablePtr /*pDrawable */ ,
+                         GCPtr /*pGC */ ,
+                         int /*shape */ ,
+                         int /*mode */ ,
+                         int /*count */ ,
+                         DDXPointPtr /*pPts */ );
+
+    void (*PolyFillRect) (DrawablePtr /*pDrawable */ ,
+                          GCPtr /*pGC */ ,
+                          int /*nrectFill */ ,
+                          xRectangle * /*prectInit */ );
+
+    void (*PolyFillArc) (DrawablePtr /*pDrawable */ ,
+                         GCPtr /*pGC */ ,
+                         int /*narcs */ ,
+                         xArc * /*parcs */ );
+
+    int (*PolyText8) (DrawablePtr /*pDrawable */ ,
+                      GCPtr /*pGC */ ,
+                      int /*x */ ,
+                      int /*y */ ,
+                      int /*count */ ,
+                      char * /*chars */ );
+
+    int (*PolyText16) (DrawablePtr /*pDrawable */ ,
+                       GCPtr /*pGC */ ,
+                       int /*x */ ,
+                       int /*y */ ,
+                       int /*count */ ,
+                       unsigned short * /*chars */ );
+
+    void (*ImageText8) (DrawablePtr /*pDrawable */ ,
+                        GCPtr /*pGC */ ,
+                        int /*x */ ,
+                        int /*y */ ,
+                        int /*count */ ,
+                        char * /*chars */ );
+
+    void (*ImageText16) (DrawablePtr /*pDrawable */ ,
+                         GCPtr /*pGC */ ,
+                         int /*x */ ,
+                         int /*y */ ,
+                         int /*count */ ,
+                         unsigned short * /*chars */ );
+
+    void (*ImageGlyphBlt) (DrawablePtr /*pDrawable */ ,
+                           GCPtr /*pGC */ ,
+                           int /*x */ ,
+                           int /*y */ ,
+                           unsigned int /*nglyph */ ,
+                           CharInfoPtr * /*ppci */ ,
+                           void */*pglyphBase */ );
+
+    void (*PolyGlyphBlt) (DrawablePtr /*pDrawable */ ,
+                          GCPtr /*pGC */ ,
+                          int /*x */ ,
+                          int /*y */ ,
+                          unsigned int /*nglyph */ ,
+                          CharInfoPtr * /*ppci */ ,
+                          void */*pglyphBase */ );
+
+    void (*PushPixels) (GCPtr /*pGC */ ,
+                        PixmapPtr /*pBitMap */ ,
+                        DrawablePtr /*pDst */ ,
+                        int /*w */ ,
+                        int /*h */ ,
+                        int /*x */ ,
+                        int /*y */ );
+} GCOps;
+
+/* there is padding in the bit fields because the Sun compiler doesn't
+ * force alignment to 32-bit boundaries.  losers.
+ */
+typedef struct _GC {
+    ScreenPtr pScreen;
+    unsigned char depth;
+    unsigned char alu;
+    unsigned short lineWidth;
+    unsigned short dashOffset;
+    unsigned short numInDashList;
+    unsigned char *dash;
+    unsigned int lineStyle:2;
+    unsigned int capStyle:2;
+    unsigned int joinStyle:2;
+    unsigned int fillStyle:2;
+    unsigned int fillRule:1;
+    unsigned int arcMode:1;
+    unsigned int subWindowMode:1;
+    unsigned int graphicsExposures:1;
+    unsigned int clientClipType:2;      /* CT_<kind> */
+    unsigned int miTranslate:1; /* should mi things translate? */
+    unsigned int tileIsPixel:1; /* tile is solid pixel */
+    unsigned int fExpose:1;     /* Call exposure handling */
+    unsigned int freeCompClip:1;        /* Free composite clip */
+    unsigned int scratch_inuse:1;       /* is this GC in a pool for reuse? */
+    unsigned int unused:13;     /* see comment above */
+    unsigned long planemask;
+    unsigned long fgPixel;
+    unsigned long bgPixel;
+    /*
+     * alas -- both tile and stipple must be here as they
+     * are independently specifiable
+     */
+    PixUnion tile;
+    PixmapPtr stipple;
+    DDXPointRec patOrg;         /* origin for (tile, stipple) */
+    struct _Font *font;
+    DDXPointRec clipOrg;
+    void *clientClip;
+    unsigned long stateChanges; /* masked with GC_<kind> */
+    unsigned long serialNumber;
+    const GCFuncs *funcs;
+    const GCOps *ops;
+    PrivateRec *devPrivates;
+    /*
+     * The following were moved here from private storage to allow device-
+     * independent access to them from screen wrappers.
+     * --- 1997.11.03  Marc Aurele La France (tsi@xfree86.org)
+     */
+    PixmapPtr pRotatedPixmap;   /* tile/stipple rotated for alignment */
+    RegionPtr pCompositeClip;
+    /* fExpose & freeCompClip defined above */
+} GC;
+
+#endif                          /* GCSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gcstruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9850.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9850.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9850.h	(Revision 52145)
@@ -0,0 +1,43 @@
+#ifndef __TDA9850_H__
+#define __TDA9850_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    I2CDevRec d;
+
+    int mux;
+    int stereo;
+    int sap;
+    Bool mute;
+    Bool sap_mute;
+} TDA9850Rec, *TDA9850Ptr;
+
+#define TDA9850_ADDR_1   0xB4
+
+#define xf86_Detect_tda9850	Detect_tda9850
+extern _X_EXPORT TDA9850Ptr Detect_tda9850(I2CBusPtr b, I2CSlaveAddr addr);
+
+#define xf86_tda9850_init	tda9850_init
+extern _X_EXPORT Bool tda9850_init(TDA9850Ptr t);
+
+#define xf86_tda9850_setaudio	tda9850_setaudio
+extern _X_EXPORT void tda9850_setaudio(TDA9850Ptr t);
+
+#define xf86_tda9850_mute	tda9850_mute
+extern _X_EXPORT void tda9850_mute(TDA9850Ptr t, Bool mute);
+
+#define xf86_tda9850_sap_mute	tda9850_sap_mute
+extern _X_EXPORT void tda9850_sap_mute(TDA9850Ptr t, Bool sap_mute);
+
+#define xf86_tda9850_getstatus	tda9850_getstatus
+extern _X_EXPORT CARD16 tda9850_getstatus(TDA9850Ptr t);
+
+#define TDA9850SymbolsList  \
+		"Detect_tda9850", \
+		"tda9850_init", \
+		"tda9850_setaudio", \
+		"tda9850_mute", \
+		"tda9850_sap_mute"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9850.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opendev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opendev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opendev.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef OPENDEV_H
+#define OPENDEV_H 1
+
+int SProcXOpenDevice(ClientPtr  /* client */
+    );
+
+int ProcXOpenDevice(ClientPtr   /* client */
+    );
+
+void SRepXOpenDevice(ClientPtr /* client */ ,
+                     int /* size */ ,
+                     xOpenDeviceReply * /* rep */
+    );
+
+#endif                          /* OPENDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opendev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/securitysrv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/securitysrv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/securitysrv.h	(Revision 52145)
@@ -0,0 +1,82 @@
+/*
+Copyright 1996, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+*/
+
+/* Xserver internals for Security extension - moved here from
+   _SECURITY_SERVER section of <X11/extensions/security.h> */
+
+#ifndef _SECURITY_SRV_H
+#define _SECURITY_SRV_H
+
+/* Allow client side portions of <X11/extensions/security.h> to compile */
+#ifndef Status
+#define Status int
+#define NEED_UNDEF_Status
+#endif
+#ifndef Display
+#define Display void
+#define NEED_UNDEF_Display
+#endif
+
+#include <X11/extensions/secur.h>
+
+#ifdef NEED_UNDEF_Status
+#undef Status
+#undef NEED_UNDEF_Status
+#endif
+#ifdef NEED_UNDEF_Display
+#undef Display
+#undef NEED_UNDEF_Display
+#endif
+
+#include "input.h"              /* for DeviceIntPtr */
+#include "property.h"           /* for PropertyPtr */
+#include "pixmap.h"             /* for DrawablePtr */
+#include "resource.h"           /* for RESTYPE */
+
+/* resource type to pass in LookupIDByType for authorizations */
+extern RESTYPE SecurityAuthorizationResType;
+
+/* this is what we store for an authorization */
+typedef struct {
+    XID id;                     /* resource ID */
+    CARD32 timeout;             /* how long to live in seconds after refcnt == 0 */
+    unsigned int trustLevel;    /* trusted/untrusted */
+    XID group;                  /* see embedding extension */
+    unsigned int refcnt;        /* how many clients connected with this auth */
+    unsigned int secondsRemaining;      /* overflow time amount for >49 days */
+    OsTimerPtr timer;           /* timer for this auth */
+    struct _OtherClients *eventClients; /* clients wanting events */
+} SecurityAuthorizationRec, *SecurityAuthorizationPtr;
+
+typedef struct {
+    XID group;                  /* the group that was sent in GenerateAuthorization */
+    Bool valid;                 /* did anyone recognize it? if so, set to TRUE */
+} SecurityValidateGroupInfoRec;
+
+/* Give this value or higher to the -audit option to get security messages */
+#define SECURITY_AUDIT_LEVEL 4
+
+#endif                          /* _SECURITY_SRV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/securitysrv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/events.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/events.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/events.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef EVENTS_H
+#define EVENTS_H
+typedef struct _DeviceEvent DeviceEvent;
+typedef struct _DeviceChangedEvent DeviceChangedEvent;
+typedef struct _TouchOwnershipEvent TouchOwnershipEvent;
+typedef struct _BarrierEvent BarrierEvent;
+
+#if XFreeXDGA
+typedef struct _DGAEvent DGAEvent;
+#endif
+typedef struct _RawDeviceEvent RawDeviceEvent;
+
+#ifdef XQUARTZ
+typedef struct _XQuartzEvent XQuartzEvent;
+#endif
+typedef union _InternalEvent InternalEvent;
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/events.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emui.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emui.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emui.h	(Revision 52145)
@@ -0,0 +1,110 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for system specific functions. These functions
+*				are always compiled and linked in the OS depedent libraries,
+*				and never in a binary portable driver.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_X86EMUI_H
+#define __X86EMU_X86EMUI_H
+
+/* If we are compiling in C++ mode, we can compile some functions as
+ * inline to increase performance (however the code size increases quite
+ * dramatically in this case).
+ */
+
+#if	defined(__cplusplus) && !defined(_NO_INLINE)
+#define	_INLINE	inline
+#else
+#define	_INLINE static
+#endif
+
+/* Get rid of unused parameters in C++ compilation mode */
+
+#ifdef __cplusplus
+#define	X86EMU_UNUSED(v)
+#else
+#define	X86EMU_UNUSED(v)	v
+#endif
+
+#include "x86emu.h"
+#include "x86emu/regs.h"
+#include "x86emu/debug.h"
+#include "x86emu/decode.h"
+#include "x86emu/ops.h"
+#include "x86emu/prim_ops.h"
+#include "x86emu/fpu.h"
+#include "x86emu/fpu_regs.h"
+
+#ifndef NO_SYS_HEADERS
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+/* avoid conflicts with Solaris sys/regset.h */
+# if defined(__sun) && defined(CS)
+#  undef CS
+#  undef DS
+#  undef SS
+#  undef ES
+#  undef FS
+#  undef GS
+# endif
+#endif /* NO_SYS_HEADERS */
+
+/*--------------------------- Inline Functions ----------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+    extern u8(X86APIP sys_rdb) (u32 addr);
+    extern u16(X86APIP sys_rdw) (u32 addr);
+    extern u32(X86APIP sys_rdl) (u32 addr);
+    extern void (X86APIP sys_wrb) (u32 addr, u8 val);
+    extern void (X86APIP sys_wrw) (u32 addr, u16 val);
+    extern void (X86APIP sys_wrl) (u32 addr, u32 val);
+
+    extern u8(X86APIP sys_inb) (X86EMU_pioAddr addr);
+    extern u16(X86APIP sys_inw) (X86EMU_pioAddr addr);
+    extern u32(X86APIP sys_inl) (X86EMU_pioAddr addr);
+    extern void (X86APIP sys_outb) (X86EMU_pioAddr addr, u8 val);
+    extern void (X86APIP sys_outw) (X86EMU_pioAddr addr, u16 val);
+    extern void (X86APIP sys_outl) (X86EMU_pioAddr addr, u32 val);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_X86EMUI_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emui.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpict.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpict.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpict.h	(Revision 52145)
@@ -0,0 +1,88 @@
+/*
+ *
+ * Copyright ¬© 2000 Keith Packard, member of The XFree86 Project, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _FBPICT_H_
+#define _FBPICT_H_
+
+/* fbpict.c */
+extern _X_EXPORT void
+
+fbComposite(CARD8 op,
+            PicturePtr pSrc,
+            PicturePtr pMask,
+            PicturePtr pDst,
+            INT16 xSrc,
+            INT16 ySrc,
+            INT16 xMask,
+            INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+/* fbtrap.c */
+
+extern _X_EXPORT void
+
+fbAddTraps(PicturePtr pPicture,
+           INT16 xOff, INT16 yOff, int ntrap, xTrap * traps);
+
+extern _X_EXPORT void
+
+fbRasterizeTrapezoid(PicturePtr alpha, xTrapezoid * trap, int x_off, int y_off);
+
+extern _X_EXPORT void
+
+fbAddTriangles(PicturePtr pPicture,
+               INT16 xOff, INT16 yOff, int ntri, xTriangle * tris);
+
+extern _X_EXPORT void
+
+fbTrapezoids(CARD8 op,
+             PicturePtr pSrc,
+             PicturePtr pDst,
+             PictFormatPtr maskFormat,
+             INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid * traps);
+
+extern _X_EXPORT void
+fbTriangles(CARD8 op,
+            PicturePtr pSrc,
+            PicturePtr pDst,
+            PictFormatPtr maskFormat,
+            INT16 xSrc, INT16 ySrc, int ntris, xTriangle * tris);
+
+extern _X_EXPORT void
+fbUnrealizeGlyph(ScreenPtr pScreen,
+		 GlyphPtr pGlyph);
+
+extern _X_EXPORT void
+fbGlyphs(CARD8 op,
+	 PicturePtr pSrc,
+	 PicturePtr pDst,
+	 PictFormatPtr maskFormat,
+	 INT16 xSrc,
+	 INT16 ySrc, int nlist,
+	 GlyphListPtr list,
+	 GlyphPtr *glyphs);
+
+#endif                          /* _FBPICT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpict.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgfctl.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgfctl.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgfctl.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGFCTL_H
+#define CHGFCTL_H 1
+
+int SProcXChangeFeedbackControl(ClientPtr       /* client */
+    );
+
+int ProcXChangeFeedbackControl(ClientPtr        /* client */
+    );
+
+#endif                          /* CHGFCTL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgfctl.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkmap.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGKMAP_H
+#define CHGKMAP_H 1
+
+int SProcXChangeDeviceKeyMapping(ClientPtr      /* client */
+    );
+
+int ProcXChangeDeviceKeyMapping(ClientPtr       /* client */
+    );
+
+#endif                          /* CHGKMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fi1236.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fi1236.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fi1236.h	(Revision 52145)
@@ -0,0 +1,113 @@
+#ifndef __FI1236_H__
+#define __FI1236_H__
+
+#include "xf86i2c.h"
+
+/* why someone has defined NUM someplace else is beyoung me.. */
+#undef NUM
+
+typedef struct {
+    CARD32 fcar;                /* 16 * fcar_Mhz */
+    CARD32 min_freq;            /* 16 * min_freq_Mhz */
+    CARD32 max_freq;            /* 16 * max_freq_Mhz */
+
+    CARD32 threshold1;          /* 16 * Value_Mhz */
+    CARD32 threshold2;          /* 16 * Value_Mhz */
+
+    CARD8 band_low;
+    CARD8 band_mid;
+    CARD8 band_high;
+    CARD8 control;
+} FI1236_parameters;
+
+typedef struct {
+    /* what we want */
+    /* all frequencies are in Mhz */
+    double f_rf;                /* frequency to tune to */
+    double f_if1;               /* first intermediate frequency */
+    double f_if2;               /* second intermediate frequency */
+    double f_ref;               /* reference frequency */
+    double f_ifbw;              /* bandwidth */
+    double f_step;              /* step */
+
+    /* what we compute */
+    double f_lo1;
+    double f_lo2;
+    int LO1I;
+    int LO2I;
+    int SEL;
+    int STEP;
+    int NUM;
+} MT2032_parameters;
+
+typedef struct {
+    I2CDevRec d;
+    int type;
+
+    void *afc_source;           /* The AFC source may be another chip like TDA988x */
+
+    int afc_delta;
+    CARD32 original_frequency;
+    Bool afc_timer_installed;
+    int afc_count;
+    int last_afc_hint;
+
+    double video_if;
+    FI1236_parameters parm;
+    int xogc;                   /* for MT2032 */
+
+    struct {
+        CARD8 div1;
+        CARD8 div2;
+        CARD8 control;
+        CARD8 band;
+        CARD8 aux;              /* this is for MK3 tuners */
+    } tuner_data;
+} FI1236Rec, *FI1236Ptr;
+
+#define TUNER_TYPE_FI1236              0
+#define TUNER_TYPE_FI1216              1
+#define TUNER_TYPE_TEMIC_FN5AL         2
+#define TUNER_TYPE_MT2032	       3
+#define TUNER_TYPE_FI1246              4
+#define TUNER_TYPE_FI1256              5
+#define TUNER_TYPE_FI1236W             6
+#define TUNER_TYPE_FM1216ME            7
+
+#define FI1236_ADDR(a)        ((a)->d.SlaveAddr)
+
+#define FI1236_ADDR_1	     0xC6
+#define FI1236_ADDR_2        0xC0
+
+#define TUNER_TUNED   0
+#define TUNER_JUST_BELOW 1
+#define TUNER_JUST_ABOVE -1
+#define TUNER_OFF      4
+#define TUNER_STILL_TUNING      5
+
+void FI1236_tune(FI1236Ptr f, CARD32 frequency);
+
+#define FI1236SymbolsList  \
+		"Detect_FI1236", \
+		"FI1236_set_tuner_type", \
+		"TUNER_set_frequency"
+
+#define xf86_Detect_FI1236		Detect_FI1236
+extern _X_EXPORT FI1236Ptr Detect_FI1236(I2CBusPtr b, I2CSlaveAddr addr);
+
+#define xf86_FI1236_set_tuner_type	FI1236_set_tuner_type
+extern _X_EXPORT void FI1236_set_tuner_type(FI1236Ptr f, int type);
+
+#define xf86_TUNER_set_frequency	TUNER_set_frequency
+extern _X_EXPORT void TUNER_set_frequency(FI1236Ptr f, CARD32 frequency);
+
+#define xf86_FI1236_AFC			FI1236_AFC
+extern _X_EXPORT int FI1236_AFC(FI1236Ptr f);
+
+#define xf86_TUNER_get_afc_hint		TUNER_get_afc_hint
+extern _X_EXPORT int TUNER_get_afc_hint(FI1236Ptr f);
+
+#define xf86_fi1236_dump_status		fi1236_dump_status
+extern _X_EXPORT void fi1236_dump_status(FI1236Ptr f);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fi1236.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/list.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/list.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/list.h	(Revision 52145)
@@ -0,0 +1,492 @@
+/*
+ * Copyright ¬© 2010 Intel Corporation
+ * Copyright ¬© 2010 Francisco Jerez <currojerez@riseup.net>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _XORG_LIST_H_
+#define _XORG_LIST_H_
+
+#include <stddef.h> /* offsetof() */
+
+/**
+ * @file Classic doubly-link circular list implementation.
+ * For real usage examples of the linked list, see the file test/list.c
+ *
+ * Example:
+ * We need to keep a list of struct foo in the parent struct bar, i.e. what
+ * we want is something like this.
+ *
+ *     struct bar {
+ *          ...
+ *          struct foo *list_of_foos; -----> struct foo {}, struct foo {}, struct foo{}
+ *          ...
+ *     }
+ *
+ * We need one list head in bar and a list element in all list_of_foos (both are of
+ * data type 'struct xorg_list').
+ *
+ *     struct bar {
+ *          ...
+ *          struct xorg_list list_of_foos;
+ *          ...
+ *     }
+ *
+ *     struct foo {
+ *          ...
+ *          struct xorg_list entry;
+ *          ...
+ *     }
+ *
+ * Now we initialize the list head:
+ *
+ *     struct bar bar;
+ *     ...
+ *     xorg_list_init(&bar.list_of_foos);
+ *
+ * Then we create the first element and add it to this list:
+ *
+ *     struct foo *foo = malloc(...);
+ *     ....
+ *     xorg_list_add(&foo->entry, &bar.list_of_foos);
+ *
+ * Repeat the above for each element you want to add to the list. Deleting
+ * works with the element itself.
+ *      xorg_list_del(&foo->entry);
+ *      free(foo);
+ *
+ * Note: calling xorg_list_del(&bar.list_of_foos) will set bar.list_of_foos to an empty
+ * list again.
+ *
+ * Looping through the list requires a 'struct foo' as iterator and the
+ * name of the field the subnodes use.
+ *
+ * struct foo *iterator;
+ * xorg_list_for_each_entry(iterator, &bar.list_of_foos, entry) {
+ *      if (iterator->something == ...)
+ *             ...
+ * }
+ *
+ * Note: You must not call xorg_list_del() on the iterator if you continue the
+ * loop. You need to run the safe for-each loop instead:
+ *
+ * struct foo *iterator, *next;
+ * xorg_list_for_each_entry_safe(iterator, next, &bar.list_of_foos, entry) {
+ *      if (...)
+ *              xorg_list_del(&iterator->entry);
+ * }
+ *
+ */
+
+/**
+ * The linkage struct for list nodes. This struct must be part of your
+ * to-be-linked struct. struct xorg_list is required for both the head of the
+ * list and for each list node.
+ *
+ * Position and name of the struct xorg_list field is irrelevant.
+ * There are no requirements that elements of a list are of the same type.
+ * There are no requirements for a list head, any struct xorg_list can be a list
+ * head.
+ */
+struct xorg_list {
+    struct xorg_list *next, *prev;
+};
+
+/**
+ * Initialize the list as an empty list.
+ *
+ * Example:
+ * xorg_list_init(&bar->list_of_foos);
+ *
+ * @param The list to initialized.
+ */
+static inline void
+xorg_list_init(struct xorg_list *list)
+{
+    list->next = list->prev = list;
+}
+
+static inline void
+__xorg_list_add(struct xorg_list *entry,
+                struct xorg_list *prev, struct xorg_list *next)
+{
+    next->prev = entry;
+    entry->next = next;
+    entry->prev = prev;
+    prev->next = entry;
+}
+
+/**
+ * Insert a new element after the given list head. The new element does not
+ * need to be initialised as empty list.
+ * The list changes from:
+ *      head ‚Üí some element ‚Üí ...
+ * to
+ *      head ‚Üí new element ‚Üí older element ‚Üí ...
+ *
+ * Example:
+ * struct foo *newfoo = malloc(...);
+ * xorg_list_add(&newfoo->entry, &bar->list_of_foos);
+ *
+ * @param entry The new element to prepend to the list.
+ * @param head The existing list.
+ */
+static inline void
+xorg_list_add(struct xorg_list *entry, struct xorg_list *head)
+{
+    __xorg_list_add(entry, head, head->next);
+}
+
+/**
+ * Append a new element to the end of the list given with this list head.
+ *
+ * The list changes from:
+ *      head ‚Üí some element ‚Üí ... ‚Üí lastelement
+ * to
+ *      head ‚Üí some element ‚Üí ... ‚Üí lastelement ‚Üí new element
+ *
+ * Example:
+ * struct foo *newfoo = malloc(...);
+ * xorg_list_append(&newfoo->entry, &bar->list_of_foos);
+ *
+ * @param entry The new element to prepend to the list.
+ * @param head The existing list.
+ */
+static inline void
+xorg_list_append(struct xorg_list *entry, struct xorg_list *head)
+{
+    __xorg_list_add(entry, head->prev, head);
+}
+
+static inline void
+__xorg_list_del(struct xorg_list *prev, struct xorg_list *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+
+/**
+ * Remove the element from the list it is in. Using this function will reset
+ * the pointers to/from this element so it is removed from the list. It does
+ * NOT free the element itself or manipulate it otherwise.
+ *
+ * Using xorg_list_del on a pure list head (like in the example at the top of
+ * this file) will NOT remove the first element from
+ * the list but rather reset the list as empty list.
+ *
+ * Example:
+ * xorg_list_del(&foo->entry);
+ *
+ * @param entry The element to remove.
+ */
+static inline void
+xorg_list_del(struct xorg_list *entry)
+{
+    __xorg_list_del(entry->prev, entry->next);
+    xorg_list_init(entry);
+}
+
+/**
+ * Check if the list is empty.
+ *
+ * Example:
+ * xorg_list_is_empty(&bar->list_of_foos);
+ *
+ * @return True if the list contains one or more elements or False otherwise.
+ */
+static inline int
+xorg_list_is_empty(struct xorg_list *head)
+{
+    return head->next == head;
+}
+
+/**
+ * Returns a pointer to the container of this list element.
+ *
+ * Example:
+ * struct foo* f;
+ * f = container_of(&foo->entry, struct foo, entry);
+ * assert(f == foo);
+ *
+ * @param ptr Pointer to the struct xorg_list.
+ * @param type Data type of the list element.
+ * @param member Member name of the struct xorg_list field in the list element.
+ * @return A pointer to the data struct containing the list head.
+ */
+#ifndef container_of
+#define container_of(ptr, type, member) \
+    (type *)((char *)(ptr) - offsetof(type, member))
+#endif
+
+/**
+ * Alias of container_of
+ */
+#define xorg_list_entry(ptr, type, member) \
+    container_of(ptr, type, member)
+
+/**
+ * Retrieve the first list entry for the given list pointer.
+ *
+ * Example:
+ * struct foo *first;
+ * first = xorg_list_first_entry(&bar->list_of_foos, struct foo, list_of_foos);
+ *
+ * @param ptr The list head
+ * @param type Data type of the list element to retrieve
+ * @param member Member name of the struct xorg_list field in the list element.
+ * @return A pointer to the first list element.
+ */
+#define xorg_list_first_entry(ptr, type, member) \
+    xorg_list_entry((ptr)->next, type, member)
+
+/**
+ * Retrieve the last list entry for the given listpointer.
+ *
+ * Example:
+ * struct foo *first;
+ * first = xorg_list_last_entry(&bar->list_of_foos, struct foo, list_of_foos);
+ *
+ * @param ptr The list head
+ * @param type Data type of the list element to retrieve
+ * @param member Member name of the struct xorg_list field in the list element.
+ * @return A pointer to the last list element.
+ */
+#define xorg_list_last_entry(ptr, type, member) \
+    xorg_list_entry((ptr)->prev, type, member)
+
+#ifdef HAVE_TYPEOF
+#define __container_of(ptr, sample, member)			\
+    container_of(ptr, typeof(*sample), member)
+#else
+/* This implementation of __container_of has undefined behavior according
+ * to the C standard, but it works in many cases.  If your compiler doesn't
+ * support typeof() and fails with this implementation, please try a newer
+ * compiler.
+ */
+#define __container_of(ptr, sample, member)                            \
+    (void *)((char *)(ptr)                                             \
+            - ((char *)&(sample)->member - (char *)(sample)))
+#endif
+
+/**
+ * Loop through the list given by head and set pos to struct in the list.
+ *
+ * Example:
+ * struct foo *iterator;
+ * xorg_list_for_each_entry(iterator, &bar->list_of_foos, entry) {
+ *      [modify iterator]
+ * }
+ *
+ * This macro is not safe for node deletion. Use xorg_list_for_each_entry_safe
+ * instead.
+ *
+ * @param pos Iterator variable of the type of the list elements.
+ * @param head List head
+ * @param member Member name of the struct xorg_list in the list elements.
+ *
+ */
+#define xorg_list_for_each_entry(pos, head, member)				\
+    for (pos = __container_of((head)->next, pos, member);		\
+	 &pos->member != (head);					\
+	 pos = __container_of(pos->member.next, pos, member))
+
+/**
+ * Loop through the list, keeping a backup pointer to the element. This
+ * macro allows for the deletion of a list element while looping through the
+ * list.
+ *
+ * See xorg_list_for_each_entry for more details.
+ */
+#define xorg_list_for_each_entry_safe(pos, tmp, head, member)		\
+    for (pos = __container_of((head)->next, pos, member),		\
+	 tmp = __container_of(pos->member.next, pos, member);		\
+	 &pos->member != (head);					\
+	 pos = tmp, tmp = __container_of(pos->member.next, tmp, member))
+
+/* NULL-Terminated List Interface
+ *
+ * The interface below does _not_ use the struct xorg_list as described above.
+ * It is mainly for legacy structures that cannot easily be switched to
+ * struct xorg_list.
+ *
+ * This interface is for structs like
+ *      struct foo {
+ *          [...]
+ *          struct foo *next;
+ *           [...]
+ *      };
+ *
+ * The position and field name of "next" are arbitrary.
+ */
+
+/**
+ * Init the element as null-terminated list.
+ *
+ * Example:
+ * struct foo *list = malloc();
+ * nt_list_init(list, next);
+ *
+ * @param list The list element that will be the start of the list
+ * @param member Member name of the field pointing to next struct
+ */
+#define nt_list_init(_list, _member) \
+	(_list)->_member = NULL
+
+/**
+ * Returns the next element in the list or NULL on termination.
+ *
+ * Example:
+ * struct foo *element = list;
+ * while ((element = nt_list_next(element, next)) { }
+ *
+ * This macro is not safe for node deletion. Use nt_list_for_each_entry_safe
+ * instead.
+ *
+ * @param list The list or current element.
+ * @param member Member name of the field pointing to next struct.
+ */
+#define nt_list_next(_list, _member) \
+	(_list)->_member
+
+/**
+ * Iterate through each element in the list.
+ *
+ * Example:
+ * struct foo *iterator;
+ * nt_list_for_each_entry(iterator, list, next) {
+ *      [modify iterator]
+ * }
+ *
+ * @param entry Assigned to the current list element
+ * @param list The list to iterate through.
+ * @param member Member name of the field pointing to next struct.
+ */
+#define nt_list_for_each_entry(_entry, _list, _member)			\
+	for (_entry = _list; _entry; _entry = (_entry)->_member)
+
+/**
+ * Iterate through each element in the list, keeping a backup pointer to the
+ * element. This macro allows for the deletion of a list element while
+ * looping through the list.
+ *
+ * See nt_list_for_each_entry for more details.
+ *
+ * @param entry Assigned to the current list element
+ * @param tmp The pointer to the next element
+ * @param list The list to iterate through.
+ * @param member Member name of the field pointing to next struct.
+ */
+#define nt_list_for_each_entry_safe(_entry, _tmp, _list, _member)	\
+	for (_entry = _list, _tmp = (_entry) ? (_entry)->_member : NULL;\
+		_entry;							\
+		_entry = _tmp, _tmp = (_tmp) ? (_tmp)->_member: NULL)
+
+/**
+ * Append the element to the end of the list. This macro may be used to
+ * merge two lists.
+ *
+ * Example:
+ * struct foo *elem = malloc(...);
+ * nt_list_init(elem, next)
+ * nt_list_append(elem, list, struct foo, next);
+ *
+ * Resulting list order:
+ * list_item_0 -> list_item_1 -> ... -> elem_item_0 -> elem_item_1 ...
+ *
+ * @param entry An entry (or list) to append to the list
+ * @param list The list to append to. This list must be a valid list, not
+ * NULL.
+ * @param type The list type
+ * @param member Member name of the field pointing to next struct
+ */
+#define nt_list_append(_entry, _list, _type, _member)		        \
+    do {								\
+	_type *__iterator = _list;					\
+	while (__iterator->_member) { __iterator = __iterator->_member;}\
+	__iterator->_member = _entry;					\
+    } while (0)
+
+/**
+ * Insert the element at the next position in the list. This macro may be
+ * used to insert a list into a list.
+ *
+ * struct foo *elem = malloc(...);
+ * nt_list_init(elem, next)
+ * nt_list_insert(elem, list, struct foo, next);
+ *
+ * Resulting list order:
+ * list_item_0 -> elem_item_0 -> elem_item_1 ... -> list_item_1 -> ...
+ *
+ * @param entry An entry (or list) to append to the list
+ * @param list The list to insert to. This list must be a valid list, not
+ * NULL.
+ * @param type The list type
+ * @param member Member name of the field pointing to next struct
+ */
+#define nt_list_insert(_entry, _list, _type, _member)			\
+    do {								\
+	nt_list_append((_list)->_member, _entry, _type, _member);	\
+	(_list)->_member = _entry;					\
+    } while (0)
+
+/**
+ * Delete the entry from the list by iterating through the list and
+ * removing any reference from the list to the entry.
+ *
+ * Example:
+ * struct foo *elem = <assign to right element>
+ * nt_list_del(elem, list, struct foo, next);
+ *
+ * @param entry The entry to delete from the list. entry is always
+ * re-initialized as a null-terminated list.
+ * @param list The list containing the entry, set to the new list without
+ * the removed entry.
+ * @param type The list type
+ * @param member Member name of the field pointing to the next entry
+ */
+#define nt_list_del(_entry, _list, _type, _member)		\
+	do {							\
+		_type *__e = _entry;				\
+		if (__e == NULL || _list == NULL) break;        \
+		if ((_list) == __e) {				\
+		    _list = __e->_member;			\
+		} else {					\
+		    _type *__prev = _list;			\
+		    while (__prev->_member && __prev->_member != __e)	\
+			__prev = nt_list_next(__prev, _member);	\
+		    if (__prev->_member)			\
+			__prev->_member = __e->_member;		\
+		}						\
+		nt_list_init(__e, _member);			\
+	} while(0)
+
+/**
+ * DO NOT USE THIS.
+ * This is a remainder of the xfree86 DDX attempt of having a set of generic
+ * list functions. Unfortunately, the xf86OptionRec uses it and we can't
+ * easily get rid of it. Do not use for new code.
+ */
+typedef struct generic_list_rec {
+    void *next;
+} GenericListRec, *GenericListPtr, *glp;
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/list.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncfd.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncfd.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncfd.h	(Revision 52145)
@@ -0,0 +1,45 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _MISYNCFD_H_
+#define _MISYNCFD_H_
+
+typedef int (*SyncScreenCreateFenceFromFdFunc) (ScreenPtr screen,
+                                                SyncFence *fence,
+                                                int fd,
+                                                Bool initially_triggered);
+
+typedef int (*SyncScreenGetFenceFdFunc) (ScreenPtr screen,
+                                      SyncFence *fence);
+
+#define SYNC_FD_SCREEN_FUNCS_VERSION    1
+
+typedef struct _syncFdScreenFuncs {
+    int                                 version;
+    SyncScreenCreateFenceFromFdFunc     CreateFenceFromFd;
+    SyncScreenGetFenceFdFunc            GetFenceFd;
+} SyncFdScreenFuncsRec, *SyncFdScreenFuncsPtr;
+
+extern _X_EXPORT Bool miSyncFdScreenInit(ScreenPtr pScreen,
+                                         const SyncFdScreenFuncsRec *funcs);
+
+#endif /* _MISYNCFD_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncfd.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursor.h	(Revision 52145)
@@ -0,0 +1,136 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CURSOR_H
+#define CURSOR_H
+
+#include "misc.h"
+#include "screenint.h"
+#include "window.h"
+#include "privates.h"
+
+#define NullCursor ((CursorPtr)NULL)
+
+/* Provide support for alpha composited cursors */
+#define ARGB_CURSOR
+
+struct _DeviceIntRec;
+
+typedef struct _Cursor *CursorPtr;
+typedef struct _CursorMetric *CursorMetricPtr;
+
+extern _X_EXPORT DevScreenPrivateKeyRec cursorScreenDevPriv;
+
+#define CursorScreenKey (&cursorScreenDevPriv)
+
+extern _X_EXPORT CursorPtr rootCursor;
+
+extern _X_EXPORT int FreeCursor(void */*pCurs */ ,
+                                XID /*cid */ );
+
+extern _X_EXPORT CursorPtr RefCursor(CursorPtr /* cursor */);
+extern _X_EXPORT CursorPtr UnrefCursor(CursorPtr /* cursor */);
+extern _X_EXPORT int CursorRefCount(const CursorPtr /* cursor */);
+
+extern _X_EXPORT int AllocARGBCursor(unsigned char * /*psrcbits */ ,
+                                     unsigned char * /*pmaskbits */ ,
+                                     CARD32 * /*argb */ ,
+                                     CursorMetricPtr /*cm */ ,
+                                     unsigned /*foreRed */ ,
+                                     unsigned /*foreGreen */ ,
+                                     unsigned /*foreBlue */ ,
+                                     unsigned /*backRed */ ,
+                                     unsigned /*backGreen */ ,
+                                     unsigned /*backBlue */ ,
+                                     CursorPtr * /*ppCurs */ ,
+                                     ClientPtr /*client */ ,
+                                     XID /*cid */ );
+
+extern _X_EXPORT int AllocGlyphCursor(Font /*source */ ,
+                                      unsigned int /*sourceChar */ ,
+                                      Font /*mask */ ,
+                                      unsigned int /*maskChar */ ,
+                                      unsigned /*foreRed */ ,
+                                      unsigned /*foreGreen */ ,
+                                      unsigned /*foreBlue */ ,
+                                      unsigned /*backRed */ ,
+                                      unsigned /*backGreen */ ,
+                                      unsigned /*backBlue */ ,
+                                      CursorPtr * /*ppCurs */ ,
+                                      ClientPtr /*client */ ,
+                                      XID /*cid */ );
+
+extern _X_EXPORT CursorPtr CreateRootCursor(char * /*pfilename */ ,
+                                            unsigned int /*glyph */ );
+
+extern _X_EXPORT int ServerBitsFromGlyph(FontPtr /*pfont */ ,
+                                         unsigned int /*ch */ ,
+                                         CursorMetricPtr /*cm */ ,
+                                         unsigned char ** /*ppbits */ );
+
+extern _X_EXPORT Bool CursorMetricsFromGlyph(FontPtr /*pfont */ ,
+                                             unsigned /*ch */ ,
+                                             CursorMetricPtr /*cm */ );
+
+extern _X_EXPORT void CheckCursorConfinement(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void NewCurrentScreen(struct _DeviceIntRec * /*pDev */ ,
+                                       ScreenPtr /*newScreen */ ,
+                                       int /*x */ ,
+                                       int /*y */ );
+
+extern _X_EXPORT Bool PointerConfinedToScreen(struct _DeviceIntRec * /* pDev */
+                                              );
+
+extern _X_EXPORT void GetSpritePosition(struct _DeviceIntRec * /* pDev */ ,
+                                        int * /*px */ ,
+                                        int * /*py */ );
+
+#ifdef PANORAMIX
+extern _X_EXPORT int XineramaGetCursorScreen(struct _DeviceIntRec *pDev);
+#endif                          /* PANORAMIX */
+
+#endif                          /* CURSOR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxfont.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxfont.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxfont.h	(Revision 52145)
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for font-related functions.  \see dmxfont.c */
+
+#ifndef DMXFONT_H
+#define DMXFONT_H
+
+#include <X11/fonts/fontstruct.h>
+
+/** Font private area. */
+typedef struct _dmxFontPriv {
+    int refcnt;
+    XFontStruct **font;
+} dmxFontPrivRec, *dmxFontPrivPtr;
+
+extern void dmxInitFonts(void);
+extern void dmxResetFonts(void);
+
+extern Bool dmxRealizeFont(ScreenPtr pScreen, FontPtr pFont);
+extern Bool dmxUnrealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern Bool dmxBELoadFont(ScreenPtr pScreen, FontPtr pFont);
+extern Bool dmxBEFreeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern int dmxFontPrivateIndex;
+
+#endif                          /* DMXFONT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxfont.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Config.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Config.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Config.h	(Revision 52145)
@@ -0,0 +1,72 @@
+
+/*
+ * Copyright (c) 1997-2000 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86_config_h
+#define _xf86_config_h
+
+#include "xf86Optrec.h"
+#include "xf86Parser.h"
+#include "xf86str.h"
+
+#ifdef HAVE_PARSER_DECLS
+/*
+ * global structure that holds the result of parsing the config file
+ */
+extern _X_EXPORT XF86ConfigPtr xf86configptr;
+#endif
+
+typedef enum _ConfigStatus {
+    CONFIG_OK = 0,
+    CONFIG_PARSE_ERROR,
+    CONFIG_NOFILE
+} ConfigStatus;
+
+typedef struct _ModuleDefault {
+    const char *name;
+    Bool toLoad;
+    XF86OptionPtr load_opt;
+} ModuleDefault;
+
+/*
+ * prototypes
+ */
+const char **xf86ModulelistFromConfig(void ***);
+const char **xf86DriverlistFromConfig(void);
+const char **xf86DriverlistFromCompile(void);
+const char **xf86InputDriverlistFromConfig(void);
+Bool xf86BuiltinInputDriver(const char *);
+ConfigStatus xf86HandleConfigFile(Bool);
+
+Bool xf86AutoConfig(void);
+GDevPtr autoConfigDevice(GDevPtr preconf_device);
+
+#endif                          /* _xf86_config_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Config.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxparse.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxparse.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxparse.h	(Revision 52145)
@@ -0,0 +1,292 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to DMX configuration file parser.  \see dmxparse.c */
+
+#ifndef _DMXPARSE_H_
+#define _DMXPARSE_H_
+
+#include <stdio.h>              /* For FILE */
+
+/** Stores tokens not stored in other structures (e.g., keywords and ;) */
+typedef struct _DMXConfigToken {
+    int token;
+    int line;
+    const char *comment;
+} DMXConfigToken, *DMXConfigTokenPtr;
+
+/** Stores parsed strings. */
+typedef struct _DMXConfigString {
+    int token;
+    int line;
+    const char *comment;
+    const char *string;
+    struct _DMXConfigString *next;
+} DMXConfigString, *DMXConfigStringPtr;
+
+/** Stores parsed numbers. */
+typedef struct _DMXConfigNumber {
+    int token;
+    int line;
+    const char *comment;
+    int number;
+} DMXConfigNumber, *DMXConfigNumberPtr;
+
+/** Stores parsed pairs (e.g., x y) */
+typedef struct _DMXConfigPair {
+    int token;
+    int line;
+    const char *comment;
+    int x;
+    int y;
+    int xsign;
+    int ysign;
+} DMXConfigPair, *DMXConfigPairPtr;
+
+/** Stores parsed comments not stored with a token. */
+typedef struct _DMXConfigComment {
+    int token;
+    int line;
+    const char *comment;
+} DMXConfigComment, *DMXConfigCommentPtr;
+
+typedef enum {
+    dmxConfigComment,
+    dmxConfigVirtual,
+    dmxConfigDisplay,
+    dmxConfigWall,
+    dmxConfigOption,
+    dmxConfigParam
+} DMXConfigType;
+
+/** Stores a geometry specification. */
+typedef struct _DMXConfigPartDim {
+    DMXConfigPairPtr dim;
+    DMXConfigPairPtr offset;
+} DMXConfigPartDim, *DMXConfigPartDimPtr;
+
+/** Stores a pair of geometry specifications. */
+typedef struct _DMXConfigFullDim {
+    DMXConfigPartDimPtr scrn;
+    DMXConfigPartDimPtr root;
+} DMXConfigFullDim, *DMXConfigFullDimPtr;
+
+/** Stores parsed display information. */
+typedef struct _DMXConfigDisplay {
+    /* Summary information */
+    const char *name;
+    /* Screen Window Geometry */
+    int scrnWidth, scrnHeight;
+    int scrnX, scrnY;
+    int scrnXSign, scrnYSign;
+    /* Root Window Geometry */
+    int rootWidth, rootHeight;
+    int rootX, rootY;
+    int rootXSign, rootYSign;
+    /* Origin in global space */
+    int rootXOrigin, rootYOrigin;
+
+    /* Raw configuration information */
+    DMXConfigTokenPtr start;
+    DMXConfigStringPtr dname;
+    DMXConfigFullDimPtr dim;
+    DMXConfigPairPtr origin;
+    DMXConfigTokenPtr end;
+} DMXConfigDisplay, *DMXConfigDisplayPtr;
+
+/** Stores parsed wall information. */
+typedef struct _DMXConfigWall {
+    /* Summary information */
+    int width, height;          /* dimensions of displays */
+    int xwall, ywall;           /* dimensions of wall, in tiles */
+
+    /* Raw configuration informaiton */
+    DMXConfigTokenPtr start;
+    DMXConfigPairPtr wallDim;
+    DMXConfigPairPtr displayDim;
+    DMXConfigStringPtr nameList;
+    DMXConfigTokenPtr end;
+} DMXConfigWall, *DMXConfigWallPtr;
+
+/** Stores parsed option information. */
+typedef struct _DMXConfigOption {
+    /* Summary information */
+    char *string;
+
+    /* Raw configuration informaiton */
+    DMXConfigTokenPtr start;
+    DMXConfigStringPtr option;
+    DMXConfigTokenPtr end;
+} DMXConfigOption, *DMXConfigOptionPtr;
+
+/** Stores parsed param information. */
+typedef struct _DMXConfigParam {
+    int argc;
+    const char **argv;
+
+    DMXConfigTokenPtr start;
+    DMXConfigTokenPtr open;
+    DMXConfigStringPtr param;
+    DMXConfigTokenPtr close;
+    DMXConfigTokenPtr end;      /* Either open/close OR end */
+    struct _DMXConfigParam *next;
+} DMXConfigParam, *DMXConfigParamPtr;
+
+/** Stores options under an entry (subentry). */
+typedef struct _DMXConfigSub {
+    DMXConfigType type;
+    DMXConfigCommentPtr comment;
+    DMXConfigDisplayPtr display;
+    DMXConfigWallPtr wall;
+    DMXConfigOptionPtr option;
+    DMXConfigParamPtr param;
+    struct _DMXConfigSub *next;
+} DMXConfigSub, *DMXConfigSubPtr;
+
+/** Stores parsed virtual information. */
+typedef struct _DMXConfigVirtual {
+    /* Summary information */
+    const char *name;
+    int width, height;
+
+    /* Raw configuration information */
+    DMXConfigTokenPtr start;
+    DMXConfigStringPtr vname;
+    DMXConfigPairPtr dim;
+    DMXConfigTokenPtr open;
+    DMXConfigSubPtr subentry;
+    DMXConfigTokenPtr close;
+} DMXConfigVirtual, *DMXConfigVirtualPtr;
+
+/** Heads entry storage. */
+typedef struct _DMXConfigEntry {
+    DMXConfigType type;
+    DMXConfigCommentPtr comment;
+    DMXConfigVirtualPtr virtual;
+    struct _DMXConfigEntry *next;
+} DMXConfigEntry, *DMXConfigEntryPtr;
+
+extern DMXConfigEntryPtr dmxConfigEntry;
+
+extern int yylex(void);
+extern int yydebug;
+extern void yyerror(const char *message);
+
+extern void dmxConfigLog(const char *format, ...);
+extern void *dmxConfigAlloc(unsigned long bytes);
+extern void *dmxConfigRealloc(void *orig,
+                              unsigned long orig_bytes, unsigned long bytes);
+extern const char *dmxConfigCopyString(const char *string, int length);
+extern void dmxConfigFree(void *area);
+extern DMXConfigTokenPtr dmxConfigCreateToken(int token, int line,
+                                              const char *comment);
+extern void dmxConfigFreeToken(DMXConfigTokenPtr p);
+extern DMXConfigStringPtr dmxConfigCreateString(int token, int line,
+                                                const char *comment,
+                                                const char *string);
+extern void dmxConfigFreeString(DMXConfigStringPtr p);
+extern DMXConfigNumberPtr dmxConfigCreateNumber(int token, int line,
+                                                const char *comment,
+                                                int number);
+extern void dmxConfigFreeNumber(DMXConfigNumberPtr p);
+extern DMXConfigPairPtr dmxConfigCreatePair(int token, int line,
+                                            const char *comment,
+                                            int x, int y, int xsign, int ysign);
+extern void dmxConfigFreePair(DMXConfigPairPtr p);
+extern DMXConfigCommentPtr dmxConfigCreateComment(int token, int line,
+                                                  const char *comment);
+extern void dmxConfigFreeComment(DMXConfigCommentPtr p);
+extern DMXConfigPartDimPtr dmxConfigCreatePartDim(DMXConfigPairPtr pDim,
+                                                  DMXConfigPairPtr pOffset);
+extern void dmxConfigFreePartDim(DMXConfigPartDimPtr p);
+extern DMXConfigFullDimPtr dmxConfigCreateFullDim(DMXConfigPartDimPtr pScrn,
+                                                  DMXConfigPartDimPtr pRoot);
+extern void dmxConfigFreeFullDim(DMXConfigFullDimPtr p);
+extern DMXConfigDisplayPtr dmxConfigCreateDisplay(DMXConfigTokenPtr pStart,
+                                                  DMXConfigStringPtr pName,
+                                                  DMXConfigFullDimPtr pDim,
+                                                  DMXConfigPairPtr pOrigin,
+                                                  DMXConfigTokenPtr pEnd);
+extern void dmxConfigFreeDisplay(DMXConfigDisplayPtr p);
+extern DMXConfigWallPtr dmxConfigCreateWall(DMXConfigTokenPtr pStart,
+                                            DMXConfigPairPtr pWallDim,
+                                            DMXConfigPairPtr pDisplayDim,
+                                            DMXConfigStringPtr pNameList,
+                                            DMXConfigTokenPtr pEnd);
+extern void dmxConfigFreeWall(DMXConfigWallPtr p);
+extern DMXConfigOptionPtr dmxConfigCreateOption(DMXConfigTokenPtr pStart,
+                                                DMXConfigStringPtr pOption,
+                                                DMXConfigTokenPtr pEnd);
+extern void dmxConfigFreeOption(DMXConfigOptionPtr p);
+extern DMXConfigParamPtr dmxConfigCreateParam(DMXConfigTokenPtr pStart,
+                                              DMXConfigTokenPtr pOpen,
+                                              DMXConfigStringPtr pParam,
+                                              DMXConfigTokenPtr pClose,
+                                              DMXConfigTokenPtr pEnd);
+extern void dmxConfigFreeParam(DMXConfigParamPtr p);
+extern const char **dmxConfigLookupParam(DMXConfigParamPtr p,
+                                         const char *key, int *argc);
+extern DMXConfigSubPtr dmxConfigCreateSub(DMXConfigType type,
+                                          DMXConfigCommentPtr comment,
+                                          DMXConfigDisplayPtr display,
+                                          DMXConfigWallPtr wall,
+                                          DMXConfigOptionPtr option,
+                                          DMXConfigParamPtr param);
+extern void dmxConfigFreeSub(DMXConfigSubPtr sub);
+extern DMXConfigSubPtr dmxConfigSubComment(DMXConfigCommentPtr comment);
+extern DMXConfigSubPtr dmxConfigSubDisplay(DMXConfigDisplayPtr display);
+extern DMXConfigSubPtr dmxConfigSubWall(DMXConfigWallPtr wall);
+extern DMXConfigSubPtr dmxConfigSubOption(DMXConfigOptionPtr option);
+extern DMXConfigSubPtr dmxConfigSubParam(DMXConfigParamPtr param);
+extern DMXConfigSubPtr dmxConfigAddSub(DMXConfigSubPtr head,
+                                       DMXConfigSubPtr sub);
+extern DMXConfigVirtualPtr dmxConfigCreateVirtual(DMXConfigTokenPtr pStart,
+                                                  DMXConfigStringPtr pName,
+                                                  DMXConfigPairPtr pDim,
+                                                  DMXConfigTokenPtr pOpen,
+                                                  DMXConfigSubPtr pSubentry,
+                                                  DMXConfigTokenPtr pClose);
+extern void dmxConfigFreeVirtual(DMXConfigVirtualPtr virtual);
+extern DMXConfigEntryPtr dmxConfigCreateEntry(DMXConfigType type,
+                                              DMXConfigCommentPtr comment,
+                                              DMXConfigVirtualPtr virtual);
+extern void dmxConfigFreeEntry(DMXConfigEntryPtr entry);
+extern DMXConfigEntryPtr dmxConfigAddEntry(DMXConfigEntryPtr head,
+                                           DMXConfigType type,
+                                           DMXConfigCommentPtr comment,
+                                           DMXConfigVirtualPtr virtual);
+extern DMXConfigEntryPtr dmxConfigEntryComment(DMXConfigCommentPtr comment);
+extern DMXConfigEntryPtr dmxConfigEntryVirtual(DMXConfigVirtualPtr virtual);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxparse.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormapst.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormapst.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormapst.h	(Revision 52145)
@@ -0,0 +1,111 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+*/
+
+#ifndef CMAPSTRUCT_H
+#define CMAPSTRUCT_H 1
+
+#include "colormap.h"
+#include "screenint.h"
+#include "privates.h"
+
+/* Shared color -- the color is used by AllocColorPlanes */
+typedef struct {
+    unsigned short color;
+    short refcnt;
+} SHAREDCOLOR;
+
+/* LOCO -- a local color for a PseudoColor cell. DirectColor maps always
+ * use the first value (called red) in the structure.  What channel they
+ * are really talking about depends on which map they are in. */
+typedef struct {
+    unsigned short red, green, blue;
+} LOCO;
+
+/* SHCO -- a shared color for a PseudoColor cell. Used with AllocColorPlanes.
+ * DirectColor maps always use the first value (called red) in the structure.
+ * What channel they are really talking about depends on which map they
+ * are in. */
+typedef struct {
+    SHAREDCOLOR *red, *green, *blue;
+} SHCO;
+
+/* color map entry */
+typedef struct _CMEntry {
+    union {
+        LOCO local;
+        SHCO shco;
+    } co;
+    short refcnt;
+    Bool fShared;
+} Entry;
+
+/* COLORMAPs can be used for either Direct or Pseudo color.  PseudoColor
+ * only needs one cell table, we arbitrarily pick red.  We keep track
+ * of that table with freeRed, numPixelsRed, and clientPixelsRed */
+
+typedef struct _ColormapRec {
+    VisualPtr pVisual;
+    short class;                /* PseudoColor or DirectColor */
+    XID mid;                    /* client's name for colormap */
+    ScreenPtr pScreen;          /* screen map is associated with */
+    short flags;                /* 1 = IsDefault
+                                 * 2 = AllAllocated */
+    int freeRed;
+    int freeGreen;
+    int freeBlue;
+    int *numPixelsRed;
+    int *numPixelsGreen;
+    int *numPixelsBlue;
+    Pixel **clientPixelsRed;
+    Pixel **clientPixelsGreen;
+    Pixel **clientPixelsBlue;
+    Entry *red;
+    Entry *green;
+    Entry *blue;
+    PrivateRec *devPrivates;
+} ColormapRec;
+
+#endif                          /* COLORMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormapst.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkb.h	(Revision 52145)
@@ -0,0 +1,30 @@
+#ifndef _XKB_H
+#define _XKB_H
+
+extern int ProcXkbUseExtension(ClientPtr client);
+extern int ProcXkbSelectEvents(ClientPtr client);
+extern int ProcXkbBell(ClientPtr client);
+extern int ProcXkbGetState(ClientPtr client);
+extern int ProcXkbLatchLockState(ClientPtr client);
+extern int ProcXkbGetControls(ClientPtr client);
+extern int ProcXkbSetControls(ClientPtr client);
+extern int ProcXkbGetMap(ClientPtr client);
+extern int ProcXkbSetMap(ClientPtr client);
+extern int ProcXkbGetCompatMap(ClientPtr client);
+extern int ProcXkbSetCompatMap(ClientPtr client);
+extern int ProcXkbGetIndicatorState(ClientPtr client);
+extern int ProcXkbGetIndicatorMap(ClientPtr client);
+extern int ProcXkbSetIndicatorMap(ClientPtr client);
+extern int ProcXkbGetNamedIndicator(ClientPtr client);
+extern int ProcXkbSetNamedIndicator(ClientPtr client);
+extern int ProcXkbGetNames(ClientPtr client);
+extern int ProcXkbSetNames(ClientPtr client);
+extern int ProcXkbGetGeometry(ClientPtr client);
+extern int ProcXkbSetGeometry(ClientPtr client);
+extern int ProcXkbPerClientFlags(ClientPtr client);
+extern int ProcXkbListComponents(ClientPtr client);
+extern int ProcXkbGetKbdByName(ClientPtr client);
+extern int ProcXkbGetDeviceInfo(ClientPtr client);
+extern int ProcXkbSetDeviceInfo(ClientPtr client);
+extern int ProcXkbSetDebuggingFlags(ClientPtr client);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selection.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selection.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selection.h	(Revision 52145)
@@ -0,0 +1,100 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SELECTION_H
+#define SELECTION_H 1
+
+#include "dixstruct.h"
+#include "privates.h"
+
+/*
+ *  Selection data structures 
+ */
+
+typedef struct _Selection {
+    Atom selection;
+    TimeStamp lastTimeChanged;
+    Window window;
+    WindowPtr pWin;
+    ClientPtr client;
+    struct _Selection *next;
+    PrivateRec *devPrivates;
+} Selection;
+
+/*
+ *  Selection API
+ */
+
+extern _X_EXPORT int dixLookupSelection(Selection ** result, Atom name,
+                                        ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT Selection *CurrentSelections;
+
+extern _X_EXPORT CallbackListPtr SelectionCallback;
+
+typedef enum {
+    SelectionSetOwner,
+    SelectionWindowDestroy,
+    SelectionClientClose
+} SelectionCallbackKind;
+
+typedef struct {
+    struct _Selection *selection;
+    ClientPtr client;
+    SelectionCallbackKind kind;
+} SelectionInfoRec;
+
+/*
+ *  Selection server internals
+ */
+
+extern _X_EXPORT void InitSelections(void);
+
+extern _X_EXPORT void DeleteWindowFromAnySelections(WindowPtr pWin);
+
+extern _X_EXPORT void DeleteClientFromAnySelections(ClientPtr client);
+
+#endif                          /* SELECTION_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selection.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerydevice.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerydevice.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerydevice.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYDEV_H
+#define QUERYDEV_H 1
+
+#include <X11/extensions/XI2proto.h>
+
+int SProcXIQueryDevice(ClientPtr client);
+int ProcXIQueryDevice(ClientPtr client);
+void SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply * rep);
+int SizeDeviceClasses(DeviceIntPtr dev);
+int ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
+                      char *any, uint16_t * nclasses);
+int GetDeviceUse(DeviceIntPtr dev, uint16_t * attachment);
+int ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo * info, Bool reportState);
+int ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo * info);
+int ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo * info,
+                     int axisnumber, Bool reportState);
+int ListScrollInfo(DeviceIntPtr dev, xXIScrollInfo * info, int axisnumber);
+int ListTouchInfo(DeviceIntPtr dev, xXITouchInfo * info);
+#endif                          /* QUERYDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerydevice.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miwideline.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miwideline.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miwideline.h	(Revision 52145)
@@ -0,0 +1,119 @@
+/*
+
+Copyright 1988, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/* Author:  Keith Packard, MIT X Consortium */
+
+#include "mispans.h"
+#include "mifpoly.h"            /* for ICEIL */
+
+/*
+ * Polygon edge description for integer wide-line routines
+ */
+
+typedef struct _PolyEdge {
+    int height;                 /* number of scanlines to process */
+    int x;                      /* starting x coordinate */
+    int stepx;                  /* fixed integral dx */
+    int signdx;                 /* variable dx sign */
+    int e;                      /* initial error term */
+    int dy;
+    int dx;
+} PolyEdgeRec, *PolyEdgePtr;
+
+#define SQSECANT 108.856472512142       /* 1/sin^2(11/2) - miter limit constant */
+
+/*
+ * types for general polygon routines
+ */
+
+typedef struct _PolyVertex {
+    double x, y;
+} PolyVertexRec, *PolyVertexPtr;
+
+typedef struct _PolySlope {
+    int dx, dy;
+    double k;                   /* x0 * dy - y0 * dx */
+} PolySlopeRec, *PolySlopePtr;
+
+/*
+ * Line face description for caps/joins
+ */
+
+typedef struct _LineFace {
+    double xa, ya;
+    int dx, dy;
+    int x, y;
+    double k;
+} LineFaceRec, *LineFacePtr;
+
+/*
+ * macros for polygon fillers
+ */
+
+#define MILINESETPIXEL(pDrawable, pGC, pixel, oldPixel) { \
+    oldPixel = pGC->fgPixel; \
+    if (pixel != oldPixel) { \
+	ChangeGCVal gcval; \
+	gcval.val = pixel; \
+	ChangeGC (NullClient, pGC, GCForeground, &gcval); \
+	ValidateGC (pDrawable, pGC); \
+    } \
+}
+#define MILINERESETPIXEL(pDrawable, pGC, pixel, oldPixel) { \
+    if (pixel != oldPixel) { \
+	ChangeGCVal gcval; \
+	gcval.val = oldPixel; \
+	ChangeGC (NullClient, pGC, GCForeground, &gcval); \
+	ValidateGC (pDrawable, pGC); \
+    } \
+}
+
+extern _X_EXPORT void miRoundJoinClip(LineFacePtr /*pLeft */ ,
+                                      LineFacePtr /*pRight */ ,
+                                      PolyEdgePtr /*edge1 */ ,
+                                      PolyEdgePtr /*edge2 */ ,
+                                      int * /*y1 */ ,
+                                      int * /*y2 */ ,
+                                      Bool * /*left1 */ ,
+                                      Bool *    /*left2 */
+    );
+
+extern _X_EXPORT int miRoundCapClip(LineFacePtr /*face */ ,
+                                    Bool /*isInt */ ,
+                                    PolyEdgePtr /*edge */ ,
+                                    Bool *      /*leftEdge */
+    );
+
+extern _X_EXPORT int miPolyBuildEdge(double x0, double y0, double k, int dx,
+                                     int dy, int xi, int yi, int left,
+                                     PolyEdgePtr edge);
+extern _X_EXPORT int miPolyBuildPoly(PolyVertexPtr vertices,
+                                     PolySlopePtr slopes, int count, int xi,
+                                     int yi, PolyEdgePtr left,
+                                     PolyEdgePtr right, int *pnleft,
+                                     int *pnright, int *h);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miwideline.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/enterleave.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/enterleave.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/enterleave.h	(Revision 52145)
@@ -0,0 +1,71 @@
+/*
+ * Copyright ¬© 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef ENTERLEAVE_H
+#define ENTERLEAVE_H
+
+#include <dix.h> /* DoFocusEvents() */
+
+extern void DoEnterLeaveEvents(DeviceIntPtr pDev,
+                               int sourceid,
+                               WindowPtr fromWin, WindowPtr toWin, int mode);
+
+extern void EnterLeaveEvent(DeviceIntPtr mouse,
+                            int type,
+                            int mode, int detail, WindowPtr pWin, Window child);
+
+extern WindowPtr CommonAncestor(WindowPtr a, WindowPtr b);
+
+extern void CoreEnterLeaveEvent(DeviceIntPtr mouse,
+                                int type,
+                                int mode,
+                                int detail, WindowPtr pWin, Window child);
+extern void DeviceEnterLeaveEvent(DeviceIntPtr mouse,
+                                  int sourceid,
+                                  int type,
+                                  int mode,
+                                  int detail, WindowPtr pWin, Window child);
+extern void DeviceFocusEvent(DeviceIntPtr dev,
+                             int type,
+                             int mode,
+                             int detail ,
+                             WindowPtr pWin);
+
+extern void EnterWindow(DeviceIntPtr dev, WindowPtr win, int mode);
+
+extern void LeaveWindow(DeviceIntPtr dev);
+
+extern void CoreFocusEvent(DeviceIntPtr kbd,
+                           int type, int mode, int detail, WindowPtr pWin);
+
+extern void SetFocusIn(DeviceIntPtr kbd, WindowPtr win);
+
+extern void SetFocusOut(DeviceIntPtr dev);
+#endif                          /* _ENTERLEAVE_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/enterleave.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opaque.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opaque.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opaque.h	(Revision 52145)
@@ -0,0 +1,81 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifndef OPAQUE_H
+#define OPAQUE_H
+
+#include <X11/Xmd.h>
+
+#include "globals.h"
+
+extern _X_EXPORT const char *defaultTextFont;
+extern _X_EXPORT const char *defaultCursorFont;
+extern _X_EXPORT int MaxClients;
+extern _X_EXPORT volatile char isItTimeToYield;
+extern _X_EXPORT volatile char dispatchException;
+
+/* bit values for dispatchException */
+#define DE_RESET     1
+#define DE_TERMINATE 2
+#define DE_PRIORITYCHANGE 4     /* set when a client's priority changes */
+
+extern _X_EXPORT CARD32 TimeOutValue;
+extern _X_EXPORT int ScreenSaverBlanking;
+extern _X_EXPORT int ScreenSaverAllowExposures;
+extern _X_EXPORT int defaultScreenSaverBlanking;
+extern _X_EXPORT int defaultScreenSaverAllowExposures;
+extern _X_EXPORT const char *display;
+extern _X_EXPORT int displayfd;
+extern _X_EXPORT Bool explicit_display;
+
+extern _X_EXPORT int defaultBackingStore;
+extern _X_EXPORT Bool disableBackingStore;
+extern _X_EXPORT Bool enableBackingStore;
+extern _X_EXPORT Bool enableIndirectGLX;
+extern _X_EXPORT Bool PartialNetwork;
+extern _X_EXPORT Bool RunFromSigStopParent;
+
+#ifdef RLIMIT_DATA
+extern _X_EXPORT int limitDataSpace;
+#endif
+#ifdef RLIMIT_STACK
+extern _X_EXPORT int limitStackSpace;
+#endif
+#ifdef RLIMIT_NOFILE
+extern _X_EXPORT int limitNoFile;
+#endif
+extern _X_EXPORT Bool defeatAccessControl;
+extern _X_EXPORT long maxBigRequestSize;
+extern _X_EXPORT Bool party_like_its_1989;
+extern _X_EXPORT Bool whiteRoot;
+extern _X_EXPORT Bool bgNoneRoot;
+
+extern _X_EXPORT Bool CoreDump;
+extern _X_EXPORT Bool NoListenAll;
+
+#endif                          /* OPAQUE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/opaque.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiX.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiX.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiX.h	(Revision 52145)
@@ -0,0 +1,79 @@
+/*****************************************************************
+
+Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
+BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of Digital Equipment Corporation
+shall not be used in advertising or otherwise to promote the sale, use or other
+dealings in this Software without prior written authorization from Digital
+Equipment Corporation.
+
+******************************************************************/
+
+/* THIS IS NOT AN X PROJECT TEAM SPECIFICATION */
+
+/*  
+ *	PanoramiX definitions
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _PANORAMIX_H_
+#define _PANORAMIX_H_
+
+#define _PANORAMIX_SERVER
+#include <X11/extensions/panoramiXproto.h>
+#undef _PANORAMIX_SERVER
+#include "gcstruct.h"
+#include "dixstruct.h"
+
+typedef struct _PanoramiXInfo {
+    XID id;
+} PanoramiXInfo;
+
+typedef struct {
+    PanoramiXInfo info[MAXSCREENS];
+    RESTYPE type;
+    union {
+        struct {
+            char visibility;
+            char class;
+            char root;
+        } win;
+        struct {
+            Bool shared;
+        } pix;
+        struct {
+            Bool root;
+        } pict;
+        char raw_data[4];
+    } u;
+} PanoramiXRes;
+
+#define FOR_NSCREENS_FORWARD(j) for(j = 0; j < PanoramiXNumScreens; j++)
+#define FOR_NSCREENS_FORWARD_SKIP(j) for(j = 1; j < PanoramiXNumScreens; j++)
+#define FOR_NSCREENS_BACKWARD(j) for(j = PanoramiXNumScreens - 1; j >= 0; j--)
+#define FOR_NSCREENS(j) FOR_NSCREENS_FORWARD(j)
+
+#define IS_SHARED_PIXMAP(r) (((r)->type == XRT_PIXMAP) && (r)->u.pix.shared)
+
+#define IS_ROOT_DRAWABLE(d) (((d)->type == XRT_WINDOW) && (d)->u.win.root)
+#endif                          /* _PANORAMIX_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiX.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/atKeynames.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/atKeynames.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/atKeynames.h	(Revision 52145)
@@ -0,0 +1,292 @@
+/*
+ * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Thomas Roell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Thomas Roell makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _ATKEYNAMES_H
+#define _ATKEYNAMES_H
+
+#define XK_TECHNICAL
+#define	XK_KATAKANA
+#include <X11/keysym.h>
+#include <X11/XF86keysym.h>
+
+#define GLYPHS_PER_KEY	4
+#define NUM_KEYCODES	248
+#define MIN_KEYCODE     8
+#define MAX_KEYCODE     (NUM_KEYCODES + MIN_KEYCODE - 1)
+
+#define AltMask		Mod1Mask
+#define NumLockMask	Mod2Mask
+#define AltLangMask	Mod3Mask
+#define KanaMask	Mod4Mask
+#define ScrollLockMask	Mod5Mask
+
+/*
+ * NOTE: The AT/MF keyboards can generate (via the 8042) two (MF: three)
+ *       sets of scancodes. Set3 can only be generated by a MF keyboard.
+ *       Set2 sends a makecode for keypress, and the same code prefixed by a
+ *       F0 for keyrelease. This is a little bit ugly to handle. Thus we use
+ *       here for X386 the PC/XT compatible Set1. This set uses 8bit scancodes.
+ *       Bit 7 ist set if the key is released. The code E0 switches to a
+ *       different meaning to add the new MF cursorkeys, while not breaking old
+ *       applications. E1 is another special prefix. Since I assume that there
+ *       will be further versions of PC/XT scancode compatible keyboards, we
+ *       may be in trouble one day.
+ *
+ * IDEA: 1) Use Set2 on AT84 keyboards and translate it to MF Set3.
+ *       2) Use the keyboards native set and translate it to common keysyms.
+ */
+
+/*
+ * definition of the AT84/MF101/MF102 Keyboard:
+ * ============================================================
+ *       Defined             Key Cap Glyphs       Pressed value
+ *      Key Name            Main       Also       (hex)    (dec)
+ *      ----------------   ---------- -------    ------    ------
+ */
+
+#define KEY_Escape       /* Escape                0x01  */    1
+#define KEY_1            /* 1           !         0x02  */    2
+#define KEY_2            /* 2           @         0x03  */    3
+#define KEY_3            /* 3           #         0x04  */    4
+#define KEY_4            /* 4           $         0x05  */    5
+#define KEY_5            /* 5           %         0x06  */    6
+#define KEY_6            /* 6           ^         0x07  */    7
+#define KEY_7            /* 7           &         0x08  */    8
+#define KEY_8            /* 8           *         0x09  */    9
+#define KEY_9            /* 9           (         0x0a  */   10
+#define KEY_0            /* 0           )         0x0b  */   11
+#define KEY_Minus        /* - (Minus)   _ (Under) 0x0c  */   12
+#define KEY_Equal        /* = (Equal)   +         0x0d  */   13
+#define KEY_BackSpace    /* Back Space            0x0e  */   14
+#define KEY_Tab          /* Tab                   0x0f  */   15
+#define KEY_Q            /* Q                     0x10  */   16
+#define KEY_W            /* W                     0x11  */   17
+#define KEY_E            /* E                     0x12  */   18
+#define KEY_R            /* R                     0x13  */   19
+#define KEY_T            /* T                     0x14  */   20
+#define KEY_Y            /* Y                     0x15  */   21
+#define KEY_U            /* U                     0x16  */   22
+#define KEY_I            /* I                     0x17  */   23
+#define KEY_O            /* O                     0x18  */   24
+#define KEY_P            /* P                     0x19  */   25
+#define KEY_LBrace       /* [           {         0x1a  */   26
+#define KEY_RBrace       /* ]           }         0x1b  */   27
+#define KEY_Enter        /* Enter                 0x1c  */   28
+#define KEY_LCtrl        /* Ctrl(left)            0x1d  */   29
+#define KEY_A            /* A                     0x1e  */   30
+#define KEY_S            /* S                     0x1f  */   31
+#define KEY_D            /* D                     0x20  */   32
+#define KEY_F            /* F                     0x21  */   33
+#define KEY_G            /* G                     0x22  */   34
+#define KEY_H            /* H                     0x23  */   35
+#define KEY_J            /* J                     0x24  */   36
+#define KEY_K            /* K                     0x25  */   37
+#define KEY_L            /* L                     0x26  */   38
+#define KEY_SemiColon    /* ;(SemiColon) :(Colon) 0x27  */   39
+#define KEY_Quote        /* ' (Apostr)  " (Quote) 0x28  */   40
+#define KEY_Tilde        /* ` (Accent)  ~ (Tilde) 0x29  */   41
+#define KEY_ShiftL       /* Shift(left)           0x2a  */   42
+#define KEY_BSlash       /* \(BckSlash) |(VertBar)0x2b  */   43
+#define KEY_Z            /* Z                     0x2c  */   44
+#define KEY_X            /* X                     0x2d  */   45
+#define KEY_C            /* C                     0x2e  */   46
+#define KEY_V            /* V                     0x2f  */   47
+#define KEY_B            /* B                     0x30  */   48
+#define KEY_N            /* N                     0x31  */   49
+#define KEY_M            /* M                     0x32  */   50
+#define KEY_Comma        /* , (Comma)   < (Less)  0x33  */   51
+#define KEY_Period       /* . (Period)  >(Greater)0x34  */   52
+#define KEY_Slash        /* / (Slash)   ?         0x35  */   53
+#define KEY_ShiftR       /* Shift(right)          0x36  */   54
+#define KEY_KP_Multiply  /* *                     0x37  */   55
+#define KEY_Alt          /* Alt(left)             0x38  */   56
+#define KEY_Space        /*   (SpaceBar)          0x39  */   57
+#define KEY_CapsLock     /* CapsLock              0x3a  */   58
+#define KEY_F1           /* F1                    0x3b  */   59
+#define KEY_F2           /* F2                    0x3c  */   60
+#define KEY_F3           /* F3                    0x3d  */   61
+#define KEY_F4           /* F4                    0x3e  */   62
+#define KEY_F5           /* F5                    0x3f  */   63
+#define KEY_F6           /* F6                    0x40  */   64
+#define KEY_F7           /* F7                    0x41  */   65
+#define KEY_F8           /* F8                    0x42  */   66
+#define KEY_F9           /* F9                    0x43  */   67
+#define KEY_F10          /* F10                   0x44  */   68
+#define KEY_NumLock      /* NumLock               0x45  */   69
+#define KEY_ScrollLock   /* ScrollLock            0x46  */   70
+#define KEY_KP_7         /* 7           Home      0x47  */   71
+#define KEY_KP_8         /* 8           Up        0x48  */   72
+#define KEY_KP_9         /* 9           PgUp      0x49  */   73
+#define KEY_KP_Minus     /* - (Minus)             0x4a  */   74
+#define KEY_KP_4         /* 4           Left      0x4b  */   75
+#define KEY_KP_5         /* 5                     0x4c  */   76
+#define KEY_KP_6         /* 6           Right     0x4d  */   77
+#define KEY_KP_Plus      /* + (Plus)              0x4e  */   78
+#define KEY_KP_1         /* 1           End       0x4f  */   79
+#define KEY_KP_2         /* 2           Down      0x50  */   80
+#define KEY_KP_3         /* 3           PgDown    0x51  */   81
+#define KEY_KP_0         /* 0           Insert    0x52  */   82
+#define KEY_KP_Decimal   /* . (Decimal) Delete    0x53  */   83
+#define KEY_SysReqest    /* SysReqest             0x54  */   84
+                         /* NOTUSED               0x55  */
+#define KEY_Less         /* < (Less)   >(Greater) 0x56  */   86
+#define KEY_F11          /* F11                   0x57  */   87
+#define KEY_F12          /* F12                   0x58  */   88
+
+#define KEY_Prefix0      /* special               0x60  */   96
+#define KEY_Prefix1      /* specail               0x61  */   97
+
+/*
+ * The 'scancodes' below are generated by the server, because the MF101/102
+ * keyboard sends them as sequence of other scancodes
+ */
+#define KEY_Home         /* Home                  0x59  */   89
+#define KEY_Up           /* Up                    0x5a  */   90
+#define KEY_PgUp         /* PgUp                  0x5b  */   91
+#define KEY_Left         /* Left                  0x5c  */   92
+#define KEY_Begin        /* Begin                 0x5d  */   93
+#define KEY_Right        /* Right                 0x5e  */   94
+#define KEY_End          /* End                   0x5f  */   95
+#define KEY_Down         /* Down                  0x60  */   96
+#define KEY_PgDown       /* PgDown                0x61  */   97
+#define KEY_Insert       /* Insert                0x62  */   98
+#define KEY_Delete       /* Delete                0x63  */   99
+#define KEY_KP_Enter     /* Enter                 0x64  */  100
+#define KEY_RCtrl        /* Ctrl(right)           0x65  */  101
+#define KEY_Pause        /* Pause                 0x66  */  102
+#define KEY_Print        /* Print                 0x67  */  103
+#define KEY_KP_Divide    /* Divide                0x68  */  104
+#define KEY_AltLang      /* AtlLang(right)        0x69  */  105
+#define KEY_Break        /* Break                 0x6a  */  106
+#define KEY_LMeta        /* Left Meta             0x6b  */  107
+#define KEY_RMeta        /* Right Meta            0x6c  */  108
+#define KEY_Menu         /* Menu                  0x6d  */  109
+#define KEY_F13          /* F13                   0x6e  */  110
+#define KEY_F14          /* F14                   0x6f  */  111
+#define KEY_F15          /* F15                   0x70  */  112
+#define KEY_HKTG         /* Hirugana/Katakana tog 0x70  */  112
+#define KEY_F16          /* F16                   0x71  */  113
+#define KEY_F17          /* F17                   0x72  */  114
+#define KEY_KP_DEC       /* KP_DEC                0x73  */  115
+#define KEY_BSlash2      /* \           _         0x73  */  115
+#define KEY_KP_Equal	 /* Equal (Keypad)        0x76  */  118
+#define KEY_XFER         /* Kanji Transfer        0x79  */  121
+#define KEY_NFER         /* No Kanji Transfer     0x7b  */  123
+#define KEY_Yen          /* Yen                   0x7d  */  125
+
+#define KEY_Power        /* Power Key             0x84  */  132
+#define KEY_Mute         /* Audio Mute            0x85  */  133
+#define KEY_AudioLower   /* Audio Lower           0x86  */  134
+#define KEY_AudioRaise   /* Audio Raise           0x87  */  135
+#define KEY_Help         /* Help                  0x88  */  136
+#define KEY_L1           /* Stop                  0x89  */  137
+#define KEY_L2           /* Again                 0x8a  */  138
+#define KEY_L3           /* Props                 0x8b  */  139
+#define KEY_L4           /* Undo                  0x8c  */  140
+#define KEY_L5           /* Front                 0x8d  */  141
+#define KEY_L6           /* Copy                  0x8e  */  142
+#define KEY_L7           /* Open                  0x8f  */  143
+#define KEY_L8           /* Paste                 0x90  */  144
+#define KEY_L9           /* Find                  0x91  */  145
+#define KEY_L10          /* Cut                   0x92  */  146
+
+/*
+ * Fake 'scancodes' in the following ranges are generated for 2-byte
+ * codes not handled elsewhere.  These correspond to most extended keys
+ * on so-called "Internet" keyboards:
+ *
+ *	0x79-0x93
+ *	0x96-0xa1
+ *	0xa3-0xac
+ *	0xb1-0xb4
+ *	0xba-0xbd
+ *	0xc2
+ *	0xcc-0xd2
+ *	0xd6-0xf7
+ */
+
+/*
+ * Remapped 'scancodes' are generated for single-byte codes in the range
+ * 0x59-0x5f,0x62-0x76.  These are used for some extra keys on some keyboards.
+ */
+
+#define KEY_0x59		0x95
+#define KEY_0x5A		0xA2
+#define KEY_0x5B		0xAD
+#define KEY_0x5C		KEY_KP_EQUAL
+#define KEY_0x5D		0xAE
+#define KEY_0x5E		0xAF
+#define KEY_0x5F		0xB0
+#define KEY_0x62		0xB5
+#define KEY_0x63		0xB6
+#define KEY_0x64		0xB7
+#define KEY_0x65		0xB8
+#define KEY_0x66		0xB9
+#define KEY_0x67		0xBE
+#define KEY_0x68		0xBF
+#define KEY_0x69		0xC0
+#define KEY_0x6A		0xC1
+#define KEY_0x6B		0xC3
+#define KEY_0x6C		0xC4
+#define KEY_0x6D		0xC5
+#define KEY_0x6E		0xC6
+#define KEY_0x6F		0xC7
+#define KEY_0x70		0xC8
+#define KEY_0x71		0xC9
+#define KEY_0x72		0xCA
+#define KEY_0x73		0xCB
+#define KEY_0x74		0xD3
+#define KEY_0x75		0xD4
+#define KEY_0x76		0xD5
+
+/* These are for "notused" and "unknown" entries in translation maps. */
+#define KEY_NOTUSED	  0
+#define KEY_UNKNOWN	255
+
+#endif                          /* _ATKEYNAMES_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/atKeynames.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiterPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiterPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiterPriv.h	(Revision 52145)
@@ -0,0 +1,268 @@
+/*
+ * Copyright (c) 2009 Tiago Vignatti
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+#include <X11/X.h>
+#include "colormapst.h"
+#include "scrnintstr.h"
+#include "screenint.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "pixmap.h"
+#include "windowstr.h"
+#include "window.h"
+#include "xf86str.h"
+#include "mipointer.h"
+#include "mipointrst.h"
+#include "picturestr.h"
+
+#define WRAP_SCREEN(x,y) {pScreenPriv->x = pScreen->x; pScreen->x = y;}
+
+#define UNWRAP_SCREEN(x) pScreen->x = pScreenPriv->x
+
+#define SCREEN_PROLOG(x) pScreen->x = ((VGAarbiterScreenPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, VGAarbiterScreenKey))->x
+
+#define SCREEN_EPILOG(x,y) pScreen->x = y;
+
+#define WRAP_PICT(x,y) if (ps) {pScreenPriv->x = ps->x;\
+    ps->x = y;}
+
+#define UNWRAP_PICT(x) if (ps) {ps->x = pScreenPriv->x;}
+
+#define PICTURE_PROLOGUE(field) ps->field = \
+    ((VGAarbiterScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, \
+    VGAarbiterScreenKey))->field
+
+#define PICTURE_EPILOGUE(field, wrap) ps->field = wrap
+
+#define WRAP_SCREEN_INFO(x,y) do {pScreenPriv->x = pScrn->x; pScrn->x = y;} while(0)
+
+#define UNWRAP_SCREEN_INFO(x) pScrn->x = pScreenPriv->x
+
+#define SPRITE_PROLOG miPointerScreenPtr PointPriv = \
+    (miPointerScreenPtr)dixLookupPrivate(&pScreen->devPrivates, \
+    miPointerScreenKey); VGAarbiterScreenPtr pScreenPriv = \
+    ((VGAarbiterScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, \
+    VGAarbiterScreenKey)); PointPriv->spriteFuncs = pScreenPriv->miSprite;
+
+#define SPRITE_EPILOG pScreenPriv->miSprite = PointPriv->spriteFuncs;\
+    PointPriv->spriteFuncs  = &VGAarbiterSpriteFuncs;
+
+#define WRAP_SPRITE do { pScreenPriv->miSprite = PointPriv->spriteFuncs;\
+    	PointPriv->spriteFuncs  = &VGAarbiterSpriteFuncs; 		\
+	} while (0)
+
+#define UNWRAP_SPRITE PointPriv->spriteFuncs = pScreenPriv->miSprite
+
+#define GC_WRAP(x) pGCPriv->wrapOps = (x)->ops;\
+    pGCPriv->wrapFuncs = (x)->funcs; (x)->ops = &VGAarbiterGCOps;\
+    (x)->funcs = &VGAarbiterGCFuncs;
+
+#define GC_UNWRAP(x) VGAarbiterGCPtr  pGCPriv = \
+    (VGAarbiterGCPtr)dixLookupPrivate(&(x)->devPrivates, VGAarbiterGCKey);\
+    (x)->ops = pGCPriv->wrapOps; (x)->funcs = pGCPriv->wrapFuncs;
+
+static inline void
+VGAGet(ScreenPtr pScreen)
+{
+    pci_device_vgaarb_set_target(xf86ScreenToScrn(pScreen)->vgaDev);
+    pci_device_vgaarb_lock();
+}
+
+static inline void
+VGAPut(void)
+{
+    pci_device_vgaarb_unlock();
+}
+
+typedef struct _VGAarbiterScreen {
+    CreateGCProcPtr CreateGC;
+    CloseScreenProcPtr CloseScreen;
+    ScreenBlockHandlerProcPtr BlockHandler;
+    ScreenWakeupHandlerProcPtr WakeupHandler;
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    SourceValidateProcPtr SourceValidate;
+    CopyWindowProcPtr CopyWindow;
+    ClearToBackgroundProcPtr ClearToBackground;
+    CreatePixmapProcPtr CreatePixmap;
+    SaveScreenProcPtr SaveScreen;
+    /* Colormap */
+    StoreColorsProcPtr StoreColors;
+    /* Cursor */
+    DisplayCursorProcPtr DisplayCursor;
+    RealizeCursorProcPtr RealizeCursor;
+    UnrealizeCursorProcPtr UnrealizeCursor;
+    RecolorCursorProcPtr RecolorCursor;
+    SetCursorPositionProcPtr SetCursorPosition;
+    void (*AdjustFrame) (ScrnInfoPtr, int, int);
+    Bool (*SwitchMode) (ScrnInfoPtr, DisplayModePtr);
+    Bool (*EnterVT) (ScrnInfoPtr);
+    void (*LeaveVT) (ScrnInfoPtr);
+    void (*FreeScreen) (ScrnInfoPtr);
+    miPointerSpriteFuncPtr miSprite;
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+    CompositeRectsProcPtr CompositeRects;
+} VGAarbiterScreenRec, *VGAarbiterScreenPtr;
+
+typedef struct _VGAarbiterGC {
+    const GCOps *wrapOps;
+    const GCFuncs *wrapFuncs;
+} VGAarbiterGCRec, *VGAarbiterGCPtr;
+
+/* Screen funcs */
+static void VGAarbiterBlockHandler(ScreenPtr pScreen, void *pTimeout,
+                                   void *pReadmask);
+static void VGAarbiterWakeupHandler(ScreenPtr pScreen,
+                                    unsigned long result, void *pReadmask);
+static Bool VGAarbiterCloseScreen(ScreenPtr pScreen);
+static void VGAarbiterGetImage(DrawablePtr pDrawable, int sx, int sy, int w,
+                               int h, unsigned int format,
+                               unsigned long planemask, char *pdstLine);
+static void VGAarbiterGetSpans(DrawablePtr pDrawable, int wMax, DDXPointPtr ppt,
+                               int *pwidth, int nspans, char *pdstStart);
+static void VGAarbiterSourceValidate(DrawablePtr pDrawable, int x, int y,
+                                     int width, int height,
+                                     unsigned int subWindowMode);
+static void VGAarbiterCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
+                                 RegionPtr prgnSrc);
+static void VGAarbiterClearToBackground(WindowPtr pWin, int x, int y, int w,
+                                        int h, Bool generateExposures);
+static PixmapPtr VGAarbiterCreatePixmap(ScreenPtr pScreen, int w, int h,
+                                        int depth, unsigned int usage_hint);
+static Bool VGAarbiterCreateGC(GCPtr pGC);
+static Bool VGAarbiterSaveScreen(ScreenPtr pScreen, Bool unblank);
+static void VGAarbiterStoreColors(ColormapPtr pmap, int ndef, xColorItem
+                                  * pdefs);
+static void VGAarbiterRecolorCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                    CursorPtr pCurs, Bool displayed);
+static Bool VGAarbiterRealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                    CursorPtr pCursor);
+static Bool VGAarbiterUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                      CursorPtr pCursor);
+static Bool VGAarbiterDisplayCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                    CursorPtr pCursor);
+static Bool VGAarbiterSetCursorPosition(DeviceIntPtr pDev, ScreenPtr
+                                        pScreen, int x, int y,
+                                        Bool generateEvent);
+static void VGAarbiterAdjustFrame(ScrnInfoPtr pScrn, int x, int y);
+static Bool VGAarbiterSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode);
+static Bool VGAarbiterEnterVT(ScrnInfoPtr pScrn);
+static void VGAarbiterLeaveVT(ScrnInfoPtr pScrn);
+static void VGAarbiterFreeScreen(ScrnInfoPtr pScrn);
+
+/* GC funcs */
+static void VGAarbiterValidateGC(GCPtr pGC, unsigned long changes,
+                                 DrawablePtr pDraw);
+static void VGAarbiterChangeGC(GCPtr pGC, unsigned long mask);
+static void VGAarbiterCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
+static void VGAarbiterDestroyGC(GCPtr pGC);
+static void VGAarbiterChangeClip(GCPtr pGC, int type, void *pvalue,
+                                 int nrects);
+static void VGAarbiterDestroyClip(GCPtr pGC);
+static void VGAarbiterCopyClip(GCPtr pgcDst, GCPtr pgcSrc);
+
+/* GC ops */
+static void VGAarbiterFillSpans(DrawablePtr pDraw, GC * pGC, int nInit,
+                                DDXPointPtr pptInit, int *pwidthInit,
+                                int fSorted);
+static void VGAarbiterSetSpans(DrawablePtr pDraw, GCPtr pGC, char *pcharsrc,
+                               register DDXPointPtr ppt, int *pwidth,
+                               int nspans, int fSorted);
+static void VGAarbiterPutImage(DrawablePtr pDraw, GCPtr pGC, int depth, int x,
+                               int y, int w, int h, int leftPad, int format,
+                               char *pImage);
+static RegionPtr VGAarbiterCopyArea(DrawablePtr pSrc, DrawablePtr pDst,
+                                    GC * pGC, int srcx, int srcy, int width,
+                                    int height, int dstx, int dsty);
+static RegionPtr VGAarbiterCopyPlane(DrawablePtr pSrc, DrawablePtr pDst,
+                                     GCPtr pGC, int srcx, int srcy, int width,
+                                     int height, int dstx, int dsty,
+                                     unsigned long bitPlane);
+static void VGAarbiterPolyPoint(DrawablePtr pDraw, GCPtr pGC, int mode, int npt,
+                                xPoint * pptInit);
+static void VGAarbiterPolylines(DrawablePtr pDraw, GCPtr pGC, int mode, int npt,
+                                DDXPointPtr pptInit);
+static void VGAarbiterPolySegment(DrawablePtr pDraw, GCPtr pGC, int nseg,
+                                  xSegment * pSeg);
+static void VGAarbiterPolyRectangle(DrawablePtr pDraw, GCPtr pGC,
+                                    int nRectsInit, xRectangle *pRectsInit);
+static void VGAarbiterPolyArc(DrawablePtr pDraw, GCPtr pGC, int narcs,
+                              xArc * parcs);
+static void VGAarbiterFillPolygon(DrawablePtr pDraw, GCPtr pGC, int shape,
+                                  int mode, int count, DDXPointPtr ptsIn);
+static void VGAarbiterPolyFillRect(DrawablePtr pDraw, GCPtr pGC, int nrectFill,
+                                   xRectangle *prectInit);
+static void VGAarbiterPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs,
+                                  xArc * parcs);
+static int VGAarbiterPolyText8(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                               int count, char *chars);
+static int VGAarbiterPolyText16(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                                int count, unsigned short *chars);
+static void VGAarbiterImageText8(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                                 int count, char *chars);
+static void VGAarbiterImageText16(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+                                  int count, unsigned short *chars);
+static void VGAarbiterImageGlyphBlt(DrawablePtr pDraw, GCPtr pGC, int xInit,
+                                    int yInit, unsigned int nglyph,
+                                    CharInfoPtr * ppci, void *pglyphBase);
+static void VGAarbiterPolyGlyphBlt(DrawablePtr pDraw, GCPtr pGC, int xInit,
+                                   int yInit, unsigned int nglyph,
+                                   CharInfoPtr * ppci, void *pglyphBase);
+static void VGAarbiterPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr
+                                 pDraw, int dx, int dy, int xOrg, int yOrg);
+
+/* miSpriteFuncs */
+static Bool VGAarbiterSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr
+                                          pScreen, CursorPtr pCur);
+static Bool VGAarbiterSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr
+                                            pScreen, CursorPtr pCur);
+static void VGAarbiterSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                      CursorPtr pCur, int x, int y);
+static void VGAarbiterSpriteMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                       int x, int y);
+static Bool VGAarbiterDeviceCursorInitialize(DeviceIntPtr pDev,
+                                             ScreenPtr pScreen);
+static void VGAarbiterDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);
+
+static void VGAarbiterComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask,
+                                PicturePtr pDst, INT16 xSrc, INT16 ySrc,
+                                INT16 xMask, INT16 yMask, INT16 xDst,
+                                INT16 yDst, CARD16 width, CARD16 height);
+static void VGAarbiterGlyphs(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+                             PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
+                             int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+static void VGAarbiterCompositeRects(CARD8 op, PicturePtr pDst,
+                                     xRenderColor * color, int nRect,
+                                     xRectangle *rects);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiterPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprint.h	(Revision 52145)
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to DMX configuration file pretty-printer.  \see dmxprint.c */
+
+#ifndef _DMXPRINT_H_
+#define _DMXPRINT_H_
+
+void dmxConfigPrint(FILE * str, DMXConfigEntryPtr entry);
+void dmxConfigVirtualPrint(FILE * str, DMXConfigVirtualPtr p);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mi.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mi.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mi.h	(Revision 52145)
@@ -0,0 +1,544 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MI_H
+#define MI_H
+#include <X11/X.h>
+#include "region.h"
+#include "validate.h"
+#include "window.h"
+#include "gc.h"
+#include <X11/fonts/font.h>
+#include "input.h"
+#include "cursor.h"
+#include "privates.h"
+#include "colormap.h"
+#include "events.h"
+
+#define MiBits	CARD32
+
+typedef struct _miDash *miDashPtr;
+
+#define EVEN_DASH	0
+#define ODD_DASH	~0
+
+/* miarc.c */
+
+extern _X_EXPORT void miPolyArc(DrawablePtr /*pDraw */ ,
+                                GCPtr /*pGC */ ,
+                                int /*narcs */ ,
+                                xArc *  /*parcs */
+    );
+
+/* mibitblt.c */
+
+extern _X_EXPORT RegionPtr miCopyArea(DrawablePtr /*pSrcDrawable */ ,
+                                      DrawablePtr /*pDstDrawable */ ,
+                                      GCPtr /*pGC */ ,
+                                      int /*xIn */ ,
+                                      int /*yIn */ ,
+                                      int /*widthSrc */ ,
+                                      int /*heightSrc */ ,
+                                      int /*xOut */ ,
+                                      int       /*yOut */
+    );
+
+extern _X_EXPORT RegionPtr miCopyPlane(DrawablePtr /*pSrcDrawable */ ,
+                                       DrawablePtr /*pDstDrawable */ ,
+                                       GCPtr /*pGC */ ,
+                                       int /*srcx */ ,
+                                       int /*srcy */ ,
+                                       int /*width */ ,
+                                       int /*height */ ,
+                                       int /*dstx */ ,
+                                       int /*dsty */ ,
+                                       unsigned long    /*bitPlane */
+    );
+
+extern _X_EXPORT void miGetImage(DrawablePtr /*pDraw */ ,
+                                 int /*sx */ ,
+                                 int /*sy */ ,
+                                 int /*w */ ,
+                                 int /*h */ ,
+                                 unsigned int /*format */ ,
+                                 unsigned long /*planeMask */ ,
+                                 char * /*pdstLine */
+    );
+
+extern _X_EXPORT void miPutImage(DrawablePtr /*pDraw */ ,
+                                 GCPtr /*pGC */ ,
+                                 int /*depth */ ,
+                                 int /*x */ ,
+                                 int /*y */ ,
+                                 int /*w */ ,
+                                 int /*h */ ,
+                                 int /*leftPad */ ,
+                                 int /*format */ ,
+                                 char * /*pImage */
+    );
+
+/* micopy.c  */
+
+#define miGetCompositeClip(pGC) ((pGC)->pCompositeClip)
+
+typedef void (*miCopyProc) (DrawablePtr pSrcDrawable,
+                            DrawablePtr pDstDrawable,
+                            GCPtr pGC,
+                            BoxPtr pDstBox,
+                            int nbox,
+                            int dx,
+                            int dy,
+                            Bool reverse,
+                            Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT void
+
+miCopyRegion(DrawablePtr pSrcDrawable,
+             DrawablePtr pDstDrawable,
+             GCPtr pGC,
+             RegionPtr pDstRegion,
+             int dx,
+             int dy, miCopyProc copyProc, Pixel bitPlane, void *closure);
+
+extern _X_EXPORT RegionPtr
+
+miDoCopy(DrawablePtr pSrcDrawable,
+         DrawablePtr pDstDrawable,
+         GCPtr pGC,
+         int xIn,
+         int yIn,
+         int widthSrc,
+         int heightSrc,
+         int xOut,
+         int yOut, miCopyProc copyProc, Pixel bitplane, void *closure);
+
+/* micursor.c */
+
+extern _X_EXPORT void miRecolorCursor(DeviceIntPtr /* pDev */ ,
+                                      ScreenPtr /*pScr */ ,
+                                      CursorPtr /*pCurs */ ,
+                                      Bool      /*displayed */
+    );
+
+/* midash.c */
+
+extern _X_EXPORT void miStepDash(int /*dist */ ,
+                                 int * /*pDashIndex */ ,
+                                 unsigned char * /*pDash */ ,
+                                 int /*numInDashList */ ,
+                                 int *  /*pDashOffset */
+    );
+
+/* mieq.c */
+
+#ifndef INPUT_H
+typedef struct _DeviceRec *DevicePtr;
+#endif
+
+extern _X_EXPORT Bool mieqInit(void
+    );
+
+extern _X_EXPORT void mieqFini(void);
+
+extern _X_EXPORT void mieqEnqueue(DeviceIntPtr /*pDev */ ,
+                                  InternalEvent *       /*e */
+    );
+
+extern _X_EXPORT void mieqSwitchScreen(DeviceIntPtr /* pDev */ ,
+                                       ScreenPtr /*pScreen */ ,
+                                       Bool     /*set_dequeue_screen */
+    );
+
+extern _X_EXPORT void mieqProcessDeviceEvent(DeviceIntPtr /* dev */ ,
+                                             InternalEvent * /* event */ ,
+                                             ScreenPtr  /* screen */
+    );
+
+extern _X_EXPORT void mieqProcessInputEvents(void
+    );
+
+extern DeviceIntPtr CopyGetMasterEvent(DeviceIntPtr /* sdev */ ,
+                                       InternalEvent * /* original */ ,
+                                       InternalEvent *  /* copy */
+    );
+
+/**
+ * Custom input event handler. If you need to process input events in some
+ * other way than the default path, register an input event handler for the
+ * given internal event type.
+ */
+typedef void (*mieqHandler) (int screen, InternalEvent *event,
+                             DeviceIntPtr dev);
+void _X_EXPORT mieqSetHandler(int event, mieqHandler handler);
+
+/* miexpose.c */
+
+extern _X_EXPORT RegionPtr miHandleExposures(DrawablePtr /*pSrcDrawable */ ,
+                                             DrawablePtr /*pDstDrawable */ ,
+                                             GCPtr /*pGC */ ,
+                                             int /*srcx */ ,
+                                             int /*srcy */ ,
+                                             int /*width */ ,
+                                             int /*height */ ,
+                                             int /*dstx */ ,
+                                             int /*dsty */ ,
+                                             unsigned long      /*plane */
+    );
+
+extern _X_EXPORT void miSendGraphicsExpose(ClientPtr /*client */ ,
+                                           RegionPtr /*pRgn */ ,
+                                           XID /*drawable */ ,
+                                           int /*major */ ,
+                                           int  /*minor */
+    );
+
+extern _X_EXPORT void miSendExposures(WindowPtr /*pWin */ ,
+                                      RegionPtr /*pRgn */ ,
+                                      int /*dx */ ,
+                                      int       /*dy */
+    );
+
+extern _X_EXPORT void miWindowExposures(WindowPtr /*pWin */ ,
+                                        RegionPtr /*prgn */ ,
+                                        RegionPtr       /*other_exposed */
+    );
+
+extern _X_EXPORT void miPaintWindow(WindowPtr /*pWin */ ,
+                                    RegionPtr /*prgn */ ,
+                                    int /*what */
+    );
+
+extern _X_EXPORT void miClearDrawable(DrawablePtr /*pDraw */ ,
+                                      GCPtr     /*pGC */
+    );
+
+/* mifillrct.c */
+
+extern _X_EXPORT void miPolyFillRect(DrawablePtr /*pDrawable */ ,
+                                     GCPtr /*pGC */ ,
+                                     int /*nrectFill */ ,
+                                     xRectangle *       /*prectInit */
+    );
+
+/* miglblt.c */
+
+extern _X_EXPORT void miPolyGlyphBlt(DrawablePtr /*pDrawable */ ,
+                                     GCPtr /*pGC */ ,
+                                     int /*x */ ,
+                                     int /*y */ ,
+                                     unsigned int /*nglyph */ ,
+                                     CharInfoPtr * /*ppci */ ,
+                                     void */*pglyphBase */
+    );
+
+extern _X_EXPORT void miImageGlyphBlt(DrawablePtr /*pDrawable */ ,
+                                      GCPtr /*pGC */ ,
+                                      int /*x */ ,
+                                      int /*y */ ,
+                                      unsigned int /*nglyph */ ,
+                                      CharInfoPtr * /*ppci */ ,
+                                      void */*pglyphBase */
+    );
+
+/* mipoly.c */
+
+extern _X_EXPORT void miFillPolygon(DrawablePtr /*dst */ ,
+                                    GCPtr /*pgc */ ,
+                                    int /*shape */ ,
+                                    int /*mode */ ,
+                                    int /*count */ ,
+                                    DDXPointPtr /*pPts */
+    );
+
+/* mipolycon.c */
+
+extern _X_EXPORT Bool miFillConvexPoly(DrawablePtr /*dst */ ,
+                                       GCPtr /*pgc */ ,
+                                       int /*count */ ,
+                                       DDXPointPtr      /*ptsIn */
+    );
+
+/* mipolygen.c */
+
+extern _X_EXPORT Bool miFillGeneralPoly(DrawablePtr /*dst */ ,
+                                        GCPtr /*pgc */ ,
+                                        int /*count */ ,
+                                        DDXPointPtr     /*ptsIn */
+    );
+
+/* mipolypnt.c */
+
+extern _X_EXPORT void miPolyPoint(DrawablePtr /*pDrawable */ ,
+                                  GCPtr /*pGC */ ,
+                                  int /*mode */ ,
+                                  int /*npt */ ,
+                                  xPoint *      /*pptInit */
+    );
+
+/* mipolyrect.c */
+
+extern _X_EXPORT void miPolyRectangle(DrawablePtr /*pDraw */ ,
+                                      GCPtr /*pGC */ ,
+                                      int /*nrects */ ,
+                                      xRectangle *      /*pRects */
+    );
+
+/* mipolyseg.c */
+
+extern _X_EXPORT void miPolySegment(DrawablePtr /*pDraw */ ,
+                                    GCPtr /*pGC */ ,
+                                    int /*nseg */ ,
+                                    xSegment *  /*pSegs */
+    );
+
+/* mipolytext.c */
+
+extern _X_EXPORT int miPolyText8(DrawablePtr /*pDraw */ ,
+                                 GCPtr /*pGC */ ,
+                                 int /*x */ ,
+                                 int /*y */ ,
+                                 int /*count */ ,
+                                 char * /*chars */
+    );
+
+extern _X_EXPORT int miPolyText16(DrawablePtr /*pDraw */ ,
+                                  GCPtr /*pGC */ ,
+                                  int /*x */ ,
+                                  int /*y */ ,
+                                  int /*count */ ,
+                                  unsigned short *      /*chars */
+    );
+
+extern _X_EXPORT void miImageText8(DrawablePtr /*pDraw */ ,
+                                   GCPtr /*pGC */ ,
+                                   int /*x */ ,
+                                   int /*y */ ,
+                                   int /*count */ ,
+                                   char *       /*chars */
+    );
+
+extern _X_EXPORT void miImageText16(DrawablePtr /*pDraw */ ,
+                                    GCPtr /*pGC */ ,
+                                    int /*x */ ,
+                                    int /*y */ ,
+                                    int /*count */ ,
+                                    unsigned short *    /*chars */
+    );
+
+/* mipushpxl.c */
+
+extern _X_EXPORT void miPushPixels(GCPtr /*pGC */ ,
+                                   PixmapPtr /*pBitMap */ ,
+                                   DrawablePtr /*pDrawable */ ,
+                                   int /*dx */ ,
+                                   int /*dy */ ,
+                                   int /*xOrg */ ,
+                                   int  /*yOrg */
+    );
+
+/* miscrinit.c */
+
+extern _X_EXPORT Bool miModifyPixmapHeader(PixmapPtr /*pPixmap */ ,
+                                           int /*width */ ,
+                                           int /*height */ ,
+                                           int /*depth */ ,
+                                           int /*bitsPerPixel */ ,
+                                           int /*devKind */ ,
+                                           void */*pPixData */
+    );
+
+extern _X_EXPORT Bool miCreateScreenResources(ScreenPtr /*pScreen */
+    );
+
+extern _X_EXPORT Bool miScreenDevPrivateInit(ScreenPtr /*pScreen */ ,
+                                             int /*width */ ,
+                                             void */*pbits */
+    );
+
+extern _X_EXPORT Bool miScreenInit(ScreenPtr /*pScreen */ ,
+                                   void */*pbits */ ,
+                                   int /*xsize */ ,
+                                   int /*ysize */ ,
+                                   int /*dpix */ ,
+                                   int /*dpiy */ ,
+                                   int /*width */ ,
+                                   int /*rootDepth */ ,
+                                   int /*numDepths */ ,
+                                   DepthPtr /*depths */ ,
+                                   VisualID /*rootVisual */ ,
+                                   int /*numVisuals */ ,
+                                   VisualPtr    /*visuals */
+    );
+
+/* mivaltree.c */
+
+extern _X_EXPORT int miShapedWindowIn(RegionPtr /*universe */ ,
+                                      RegionPtr /*bounding */ ,
+                                      BoxPtr /*rect */ ,
+                                      int /*x */ ,
+                                      int       /*y */
+    );
+
+typedef void
+ (*SetRedirectBorderClipProcPtr) (WindowPtr pWindow, RegionPtr pRegion);
+
+typedef RegionPtr
+ (*GetRedirectBorderClipProcPtr) (WindowPtr pWindow);
+
+extern _X_EXPORT void
+
+miRegisterRedirectBorderClipProc(SetRedirectBorderClipProcPtr setBorderClip,
+                                 GetRedirectBorderClipProcPtr getBorderClip);
+
+extern _X_EXPORT int miValidateTree(WindowPtr /*pParent */ ,
+                                    WindowPtr /*pChild */ ,
+                                    VTKind      /*kind */
+    );
+
+extern _X_EXPORT void miWideLine(DrawablePtr /*pDrawable */ ,
+                                 GCPtr /*pGC */ ,
+                                 int /*mode */ ,
+                                 int /*npt */ ,
+                                 DDXPointPtr    /*pPts */
+    );
+
+extern _X_EXPORT void miWideDash(DrawablePtr /*pDrawable */ ,
+                                 GCPtr /*pGC */ ,
+                                 int /*mode */ ,
+                                 int /*npt */ ,
+                                 DDXPointPtr    /*pPts */
+    );
+
+/* miwindow.c */
+
+extern _X_EXPORT void miClearToBackground(WindowPtr /*pWin */ ,
+                                          int /*x */ ,
+                                          int /*y */ ,
+                                          int /*w */ ,
+                                          int /*h */ ,
+                                          Bool  /*generateExposures */
+    );
+
+extern _X_EXPORT void miMarkWindow(WindowPtr    /*pWin */
+    );
+
+extern _X_EXPORT Bool miMarkOverlappedWindows(WindowPtr /*pWin */ ,
+                                              WindowPtr /*pFirst */ ,
+                                              WindowPtr *       /*ppLayerWin */
+    );
+
+extern _X_EXPORT void miHandleValidateExposures(WindowPtr       /*pWin */
+    );
+
+extern _X_EXPORT void miMoveWindow(WindowPtr /*pWin */ ,
+                                   int /*x */ ,
+                                   int /*y */ ,
+                                   WindowPtr /*pNextSib */ ,
+                                   VTKind       /*kind */
+    );
+
+extern _X_EXPORT void miSlideAndSizeWindow(WindowPtr /*pWin */ ,
+                                           int /*x */ ,
+                                           int /*y */ ,
+                                           unsigned int /*w */ ,
+                                           unsigned int /*h */ ,
+                                           WindowPtr    /*pSib */
+    );
+
+extern _X_EXPORT WindowPtr miGetLayerWindow(WindowPtr   /*pWin */
+    );
+
+extern _X_EXPORT void miSetShape(WindowPtr /*pWin */ ,
+                                 int    /*kind */
+    );
+
+extern _X_EXPORT void miChangeBorderWidth(WindowPtr /*pWin */ ,
+                                          unsigned int  /*width */
+    );
+
+extern _X_EXPORT void miMarkUnrealizedWindow(WindowPtr /*pChild */ ,
+                                             WindowPtr /*pWin */ ,
+                                             Bool       /*fromConfigure */
+    );
+
+extern _X_EXPORT void miSegregateChildren(WindowPtr pWin, RegionPtr pReg,
+                                          int depth);
+
+extern _X_EXPORT WindowPtr miSpriteTrace(SpritePtr pSprite, int x, int y);
+
+extern _X_EXPORT WindowPtr miXYToWindow(ScreenPtr pScreen, SpritePtr pSprite, int x, int y);
+
+/* mizerarc.c */
+
+extern _X_EXPORT void miZeroPolyArc(DrawablePtr /*pDraw */ ,
+                                    GCPtr /*pGC */ ,
+                                    int /*narcs */ ,
+                                    xArc *      /*parcs */
+    );
+
+/* mizerline.c */
+
+extern _X_EXPORT void miZeroLine(DrawablePtr /*dst */ ,
+                                 GCPtr /*pgc */ ,
+                                 int /*mode */ ,
+                                 int /*nptInit */ ,
+                                 DDXPointRec *  /*pptInit */
+    );
+
+extern _X_EXPORT void miZeroDashLine(DrawablePtr /*dst */ ,
+                                     GCPtr /*pgc */ ,
+                                     int /*mode */ ,
+                                     int /*nptInit */ ,
+                                     DDXPointRec *      /*pptInit */
+    );
+
+extern _X_EXPORT void miPolyFillArc(DrawablePtr /*pDraw */ ,
+                                    GCPtr /*pGC */ ,
+                                    int /*narcs */ ,
+                                    xArc *      /*parcs */
+    );
+
+#endif                          /* MI_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mi.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursorstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursorstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursorstr.h	(Revision 52145)
@@ -0,0 +1,96 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CURSORSTRUCT_H
+#define CURSORSTRUCT_H
+
+#include "cursor.h"
+#include "privates.h"
+/* 
+ * device-independent cursor storage
+ */
+
+/*
+ * source and mask point directly to the bits, which are in the server-defined
+ * bitmap format.
+ */
+typedef struct _CursorBits {
+    unsigned char *source;      /* points to bits */
+    unsigned char *mask;        /* points to bits */
+    Bool emptyMask;             /* all zeros mask */
+    unsigned short width, height, xhot, yhot;   /* metrics */
+    int refcnt;                 /* can be shared */
+    PrivateRec *devPrivates;    /* set by pScr->RealizeCursor */
+#ifdef ARGB_CURSOR
+    CARD32 *argb;               /* full-color alpha blended */
+#endif
+} CursorBits, *CursorBitsPtr;
+
+#define CURSOR_BITS_SIZE (sizeof(CursorBits) + dixPrivatesSize(PRIVATE_CURSOR_BITS))
+
+typedef struct _Cursor {
+    CursorBitsPtr bits;
+    unsigned short foreRed, foreGreen, foreBlue;        /* device-independent color */
+    unsigned short backRed, backGreen, backBlue;        /* device-independent color */
+    int refcnt;
+    PrivateRec *devPrivates;    /* set by pScr->RealizeCursor */
+    XID id;
+    CARD32 serialNumber;
+    Atom name;
+} CursorRec;
+
+#define CURSOR_REC_SIZE (sizeof(CursorRec) + dixPrivatesSize(PRIVATE_CURSOR))
+
+typedef struct _CursorMetric {
+    unsigned short width, height, xhot, yhot;
+} CursorMetricRec;
+
+typedef struct {
+    int x, y;
+    ScreenPtr pScreen;
+} HotSpot;
+
+#endif                          /* CURSORSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/cursorstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvendor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvendor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvendor.h	(Revision 52145)
@@ -0,0 +1,53 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef __GLXVENDOR_H
+#define __GLXVENDOR_H
+
+extern int __glXVForwardSingleReq(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardPipe0WithReply(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardAllWithReply(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXVForwardSingleReqSwap(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXVForwardPipe0WithReplySwap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardPipe0WithReplySwapsv(__GLXclientState * cl,
+                                             GLbyte * pc);
+extern int __glXVForwardPipe0WithReplySwapiv(__GLXclientState * cl,
+                                             GLbyte * pc);
+extern int __glXVForwardPipe0WithReplySwapdv(__GLXclientState * cl,
+                                             GLbyte * pc);
+
+extern int __glXVForwardAllWithReplySwap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardAllWithReplySwapsv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardAllWithReplySwapiv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXVForwardAllWithReplySwapdv(__GLXclientState * cl, GLbyte * pc);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvendor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventstr.h	(Revision 52145)
@@ -0,0 +1,289 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef EVENTSTR_H
+#define EVENTSTR_H
+
+#include <events.h>
+/**
+ * @file events.h
+ * This file describes the event structures used internally by the X
+ * server during event generation and event processing.
+ *
+ * When are internal events used?
+ * Events from input devices are stored as internal events in the EQ and
+ * processed as internal events until late in the processing cycle. Only then
+ * do they switch to their respective wire events.
+ */
+
+/**
+ * Event types. Used exclusively internal to the server, not visible on the
+ * protocol.
+ *
+ * Note: Keep KeyPress to Motion aligned with the core events.
+ *       Keep ET_Raw* in the same order as KeyPress - Motion
+ */
+enum EventType {
+    ET_KeyPress = 2,
+    ET_KeyRelease,
+    ET_ButtonPress,
+    ET_ButtonRelease,
+    ET_Motion,
+    ET_TouchBegin,
+    ET_TouchUpdate,
+    ET_TouchEnd,
+    ET_TouchOwnership,
+    ET_Enter,
+    ET_Leave,
+    ET_FocusIn,
+    ET_FocusOut,
+    ET_ProximityIn,
+    ET_ProximityOut,
+    ET_DeviceChanged,
+    ET_Hierarchy,
+    ET_DGAEvent,
+    ET_RawKeyPress,
+    ET_RawKeyRelease,
+    ET_RawButtonPress,
+    ET_RawButtonRelease,
+    ET_RawMotion,
+    ET_RawTouchBegin,
+    ET_RawTouchUpdate,
+    ET_RawTouchEnd,
+    ET_XQuartz,
+    ET_BarrierHit,
+    ET_BarrierLeave,
+    ET_Internal = 0xFF          /* First byte */
+};
+
+/**
+ * Used for ALL input device events internal in the server until
+ * copied into the matching protocol event.
+ *
+ * Note: We only use the device id because the DeviceIntPtr may become invalid while
+ * the event is in the EQ.
+ */
+struct _DeviceEvent {
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< One of EventType */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    union {
+        uint32_t button;  /**< Button number (also used in pointer emulating
+                               touch events) */
+        uint32_t key;     /**< Key code */
+    } detail;
+    uint32_t touchid;     /**< Touch ID (client_id) */
+    int16_t root_x;       /**< Pos relative to root window in integral data */
+    float root_x_frac;    /**< Pos relative to root window in frac part */
+    int16_t root_y;       /**< Pos relative to root window in integral part */
+    float root_y_frac;    /**< Pos relative to root window in frac part */
+    uint8_t buttons[(MAX_BUTTONS + 7) / 8];  /**< Button mask */
+    struct {
+        uint8_t mask[(MAX_VALUATORS + 7) / 8];/**< Valuator mask */
+        uint8_t mode[(MAX_VALUATORS + 7) / 8];/**< Valuator mode (Abs or Rel)*/
+        double data[MAX_VALUATORS];           /**< Valuator data */
+    } valuators;
+    struct {
+        uint32_t base;    /**< XKB base modifiers */
+        uint32_t latched; /**< XKB latched modifiers */
+        uint32_t locked;  /**< XKB locked modifiers */
+        uint32_t effective;/**< XKB effective modifiers */
+    } mods;
+    struct {
+        uint8_t base;    /**< XKB base group */
+        uint8_t latched; /**< XKB latched group */
+        uint8_t locked;  /**< XKB locked group */
+        uint8_t effective;/**< XKB effective group */
+    } group;
+    Window root;      /**< Root window of the event */
+    int corestate;    /**< Core key/button state BEFORE the event */
+    int key_repeat;   /**< Internally-generated key repeat event */
+    uint32_t flags;   /**< Flags to be copied into the generated event */
+    uint32_t resource; /**< Touch event resource, only for TOUCH_REPLAYING */
+};
+
+/**
+ * Generated internally whenever a touch ownership chain changes - an owner
+ * has accepted or rejected a touch, or a grab/event selection in the delivery
+ * chain has been removed.
+ */
+struct _TouchOwnershipEvent {
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< ET_TouchOwnership */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    uint32_t touchid;     /**< Touch ID (client_id) */
+    uint8_t reason;       /**< ::XIAcceptTouch, ::XIRejectTouch */
+    uint32_t resource;    /**< Provoking grab or event selection */
+    uint32_t flags;       /**< Flags to be copied into the generated event */
+};
+
+/* Flags used in DeviceChangedEvent to signal if the slave has changed */
+#define DEVCHANGE_SLAVE_SWITCH 0x2
+/* Flags used in DeviceChangedEvent to signal whether the event was a
+ * pointer event or a keyboard event */
+#define DEVCHANGE_POINTER_EVENT 0x4
+#define DEVCHANGE_KEYBOARD_EVENT 0x8
+/* device capabilities changed */
+#define DEVCHANGE_DEVICE_CHANGE 0x10
+
+/**
+ * Sent whenever a device's capabilities have changed.
+ */
+struct _DeviceChangedEvent {
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< ET_DeviceChanged */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms */
+    int deviceid;         /**< Device whose capabilities have changed */
+    int flags;            /**< Mask of ::HAS_NEW_SLAVE,
+                               ::POINTER_EVENT, ::KEYBOARD_EVENT */
+    int masterid;         /**< MD when event was generated */
+    int sourceid;         /**< The device that caused the change */
+
+    struct {
+        int num_buttons;        /**< Number of buttons */
+        Atom names[MAX_BUTTONS];/**< Button names */
+    } buttons;
+
+    int num_valuators;          /**< Number of axes */
+    struct {
+        uint32_t min;           /**< Minimum value */
+        uint32_t max;           /**< Maximum value */
+        double value;           /**< Current value */
+        /* FIXME: frac parts of min/max */
+        uint32_t resolution;    /**< Resolution counts/m */
+        uint8_t mode;           /**< Relative or Absolute */
+        Atom name;              /**< Axis name */
+        ScrollInfo scroll;      /**< Smooth scrolling info */
+    } valuators[MAX_VALUATORS];
+
+    struct {
+        int min_keycode;
+        int max_keycode;
+    } keys;
+};
+
+#if XFreeXDGA
+/**
+ * DGAEvent, used by DGA to intercept and emulate input events.
+ */
+struct _DGAEvent {
+    unsigned char header; /**<  Always ET_Internal */
+    enum EventType type;  /**<  ET_DGAEvent */
+    int length;           /**<  Length in bytes */
+    Time time;            /**<  Time in ms */
+    int subtype;          /**<  KeyPress, KeyRelease, ButtonPress,
+                                ButtonRelease, MotionNotify */
+    int detail;           /**<  Button number or key code */
+    int dx;               /**<  Relative x coordinate */
+    int dy;               /**<  Relative y coordinate */
+    int screen;           /**<  Screen number this event applies to */
+    uint16_t state;       /**<  Core modifier/button state */
+};
+#endif
+
+/**
+ * Raw event, contains the data as posted by the device.
+ */
+struct _RawDeviceEvent {
+    unsigned char header; /**<  Always ET_Internal */
+    enum EventType type;  /**<  ET_Raw */
+    int length;           /**<  Length in bytes */
+    Time time;            /**<  Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    union {
+        uint32_t button;  /**< Button number */
+        uint32_t key;     /**< Key code */
+    } detail;
+    struct {
+        uint8_t mask[(MAX_VALUATORS + 7) / 8];/**< Valuator mask */
+        double data[MAX_VALUATORS];           /**< Valuator data */
+        double data_raw[MAX_VALUATORS];       /**< Valuator data as posted */
+    } valuators;
+    uint32_t flags;       /**< Flags to be copied into the generated event */
+};
+
+struct _BarrierEvent {
+    unsigned char header; /**<  Always ET_Internal */
+    enum EventType type;  /**<  ET_BarrierHit, ET_BarrierLeave */
+    int length;           /**<  Length in bytes */
+    Time time;            /**<  Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    int barrierid;
+    Window window;
+    Window root;
+    double dx;
+    double dy;
+    double root_x;
+    double root_y;
+    int16_t dt;
+    int32_t event_id;
+    uint32_t flags;
+};
+
+#ifdef XQUARTZ
+#define XQUARTZ_EVENT_MAXARGS 5
+struct _XQuartzEvent {
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< Always ET_XQuartz */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms. */
+    int subtype;          /**< Subtype defined by XQuartz DDX */
+    uint32_t data[XQUARTZ_EVENT_MAXARGS]; /**< Up to 5 32bit values passed to handler */
+};
+#endif
+
+/**
+ * Event type used inside the X server for input event
+ * processing.
+ */
+union _InternalEvent {
+    struct {
+        unsigned char header;     /**< Always ET_Internal */
+        enum EventType type;      /**< One of ET_* */
+        int length;               /**< Length in bytes */
+        Time time;                /**< Time in ms. */
+    } any;
+    DeviceEvent device_event;
+    DeviceChangedEvent changed_event;
+    TouchOwnershipEvent touch_ownership_event;
+    BarrierEvent barrier_event;
+#if XFreeXDGA
+    DGAEvent dga_event;
+#endif
+    RawDeviceEvent raw_event;
+#ifdef XQUARTZ
+    XQuartzEvent xquartz_event;
+#endif
+};
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/eventstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigrabdev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigrabdev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigrabdev.h	(Revision 52145)
@@ -0,0 +1,41 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIGRABDEV_H
+#define XIGRABDEV_H 1
+
+int ProcXIGrabDevice(ClientPtr client);
+int SProcXIGrabDevice(ClientPtr client);
+
+int ProcXIUngrabDevice(ClientPtr client);
+int SProcXIUngrabDevice(ClientPtr client);
+
+void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep);
+
+#endif                          /* XIGRABDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigrabdev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vgaHW.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vgaHW.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vgaHW.h	(Revision 52145)
@@ -0,0 +1,237 @@
+
+/*
+ * Copyright (c) 1997,1998 The XFree86 Project, Inc.
+ *
+ * Loosely based on code bearing the following copyright:
+ *
+ *   Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Author: Dirk Hohndel
+ */
+
+#ifndef _VGAHW_H
+#define _VGAHW_H
+
+#include <X11/X.h>
+#include "misc.h"
+#include "input.h"
+#include "scrnintstr.h"
+#include "colormapst.h"
+
+#include "xf86str.h"
+#include "xf86Pci.h"
+
+#include "xf86DDC.h"
+
+#include "globals.h"
+#include <X11/extensions/dpmsconst.h>
+
+extern _X_EXPORT int vgaHWGetIndex(void);
+
+/*
+ * access macro
+ */
+#define VGAHWPTR(p) ((vgaHWPtr)((p)->privates[vgaHWGetIndex()].ptr))
+
+/* Standard VGA registers */
+#define VGA_ATTR_INDEX		0x3C0
+#define VGA_ATTR_DATA_W		0x3C0
+#define VGA_ATTR_DATA_R		0x3C1
+#define VGA_IN_STAT_0		0x3C2   /* read */
+#define VGA_MISC_OUT_W		0x3C2   /* write */
+#define VGA_ENABLE		0x3C3
+#define VGA_SEQ_INDEX		0x3C4
+#define VGA_SEQ_DATA		0x3C5
+#define VGA_DAC_MASK		0x3C6
+#define VGA_DAC_READ_ADDR	0x3C7
+#define VGA_DAC_WRITE_ADDR	0x3C8
+#define VGA_DAC_DATA		0x3C9
+#define VGA_FEATURE_R		0x3CA   /* read */
+#define VGA_MISC_OUT_R		0x3CC   /* read */
+#define VGA_GRAPH_INDEX		0x3CE
+#define VGA_GRAPH_DATA		0x3CF
+
+#define VGA_IOBASE_MONO		0x3B0
+#define VGA_IOBASE_COLOR	0x3D0
+
+#define VGA_CRTC_INDEX_OFFSET	0x04
+#define VGA_CRTC_DATA_OFFSET	0x05
+#define VGA_IN_STAT_1_OFFSET	0x0A    /* read */
+#define VGA_FEATURE_W_OFFSET	0x0A    /* write */
+
+/* default number of VGA registers stored internally */
+#define VGA_NUM_CRTC 25
+#define VGA_NUM_SEQ 5
+#define VGA_NUM_GFX 9
+#define VGA_NUM_ATTR 21
+
+/* Flags for vgaHWSave() and vgaHWRestore() */
+#define VGA_SR_MODE		0x01
+#define VGA_SR_FONTS		0x02
+#define VGA_SR_CMAP		0x04
+#define VGA_SR_ALL		(VGA_SR_MODE | VGA_SR_FONTS | VGA_SR_CMAP)
+
+/* Defaults for the VGA memory window */
+#define VGA_DEFAULT_PHYS_ADDR	0xA0000
+#define VGA_DEFAULT_MEM_SIZE	(64 * 1024)
+
+/*
+ * vgaRegRec contains settings of standard VGA registers.
+ */
+typedef struct {
+    unsigned char MiscOutReg;   /* */
+    unsigned char *CRTC;        /* Crtc Controller */
+    unsigned char *Sequencer;   /* Video Sequencer */
+    unsigned char *Graphics;    /* Video Graphics */
+    unsigned char *Attribute;   /* Video Atribute */
+    unsigned char DAC[768];     /* Internal Colorlookuptable */
+    unsigned char numCRTC;      /* number of CRTC registers, def=VGA_NUM_CRTC */
+    unsigned char numSequencer; /* number of seq registers, def=VGA_NUM_SEQ */
+    unsigned char numGraphics;  /* number of gfx registers, def=VGA_NUM_GFX */
+    unsigned char numAttribute; /* number of attr registers, def=VGA_NUM_ATTR */
+} vgaRegRec, *vgaRegPtr;
+
+typedef struct _vgaHWRec *vgaHWPtr;
+
+typedef void (*vgaHWWriteIndexProcPtr) (vgaHWPtr hwp, CARD8 indx, CARD8 value);
+typedef CARD8 (*vgaHWReadIndexProcPtr) (vgaHWPtr hwp, CARD8 indx);
+typedef void (*vgaHWWriteProcPtr) (vgaHWPtr hwp, CARD8 value);
+typedef CARD8 (*vgaHWReadProcPtr) (vgaHWPtr hwp);
+typedef void (*vgaHWMiscProcPtr) (vgaHWPtr hwp);
+
+/*
+ * vgaHWRec contains per-screen information required by the vgahw module.
+ *
+ * Note, the palette referred to by the paletteEnabled, enablePalette and
+ * disablePalette is the 16-entry (+overscan) EGA-compatible palette accessed
+ * via the first 17 attribute registers and not the main 8-bit palette.
+ */
+typedef struct _vgaHWRec {
+    void *Base;               /* Address of "VGA" memory */
+    int MapSize;                /* Size of "VGA" memory */
+    unsigned long MapPhys;      /* phys location of VGA mem */
+    int IOBase;                 /* I/O Base address */
+    CARD8 *MMIOBase;            /* Pointer to MMIO start */
+    int MMIOOffset;             /* base + offset + vgareg
+                                   = mmioreg */
+    void *FontInfo1;          /* save area for fonts in
+                                   plane 2 */
+    void *FontInfo2;          /* save area for fonts in       
+                                   plane 3 */
+    void *TextInfo;           /* save area for text */
+    vgaRegRec SavedReg;         /* saved registers */
+    vgaRegRec ModeReg;          /* register settings for
+                                   current mode */
+    Bool ShowOverscan;
+    Bool paletteEnabled;
+    Bool cmapSaved;
+    ScrnInfoPtr pScrn;
+    vgaHWWriteIndexProcPtr writeCrtc;
+    vgaHWReadIndexProcPtr readCrtc;
+    vgaHWWriteIndexProcPtr writeGr;
+    vgaHWReadIndexProcPtr readGr;
+    vgaHWReadProcPtr readST00;
+    vgaHWReadProcPtr readST01;
+    vgaHWReadProcPtr readFCR;
+    vgaHWWriteProcPtr writeFCR;
+    vgaHWWriteIndexProcPtr writeAttr;
+    vgaHWReadIndexProcPtr readAttr;
+    vgaHWWriteIndexProcPtr writeSeq;
+    vgaHWReadIndexProcPtr readSeq;
+    vgaHWWriteProcPtr writeMiscOut;
+    vgaHWReadProcPtr readMiscOut;
+    vgaHWMiscProcPtr enablePalette;
+    vgaHWMiscProcPtr disablePalette;
+    vgaHWWriteProcPtr writeDacMask;
+    vgaHWReadProcPtr readDacMask;
+    vgaHWWriteProcPtr writeDacWriteAddr;
+    vgaHWWriteProcPtr writeDacReadAddr;
+    vgaHWWriteProcPtr writeDacData;
+    vgaHWReadProcPtr readDacData;
+    void *ddc;
+    struct pci_io_handle *io;
+    vgaHWReadProcPtr readEnable;
+    vgaHWWriteProcPtr writeEnable;
+    struct pci_device *dev;
+} vgaHWRec;
+
+/* Some macros that VGA drivers can use in their ChipProbe() function */
+#define OVERSCAN 0x11           /* Index of OverScan register */
+
+/* Flags that define how overscan correction should take place */
+#define KGA_FIX_OVERSCAN  1     /* overcan correction required */
+#define KGA_ENABLE_ON_ZERO 2    /* if possible enable display at beginning */
+                              /* of next scanline/frame                  */
+#define KGA_BE_TOT_DEC 4        /* always fix problem by setting blank end */
+                              /* to total - 1                            */
+#define BIT_PLANE 3             /* Which plane we write to in mono mode */
+#define BITS_PER_GUN 6
+#define COLORMAP_SIZE 256
+
+#define DACDelay(hw) \
+	do { \
+	    (hw)->readST01((hw)); \
+	    (hw)->readST01((hw)); \
+	} while (0)
+
+/* Function Prototypes */
+
+/* vgaHW.c */
+
+typedef void vgaHWProtectProc(ScrnInfoPtr, Bool);
+typedef void vgaHWBlankScreenProc(ScrnInfoPtr, Bool);
+
+extern _X_EXPORT void vgaHWSetStdFuncs(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWSetMmioFuncs(vgaHWPtr hwp, CARD8 *base, int offset);
+extern _X_EXPORT void vgaHWProtect(ScrnInfoPtr pScrn, Bool on);
+extern _X_EXPORT vgaHWProtectProc *vgaHWProtectWeak(void);
+extern _X_EXPORT Bool vgaHWSaveScreen(ScreenPtr pScreen, int mode);
+extern _X_EXPORT void vgaHWBlankScreen(ScrnInfoPtr pScrn, Bool on);
+extern _X_EXPORT vgaHWBlankScreenProc *vgaHWBlankScreenWeak(void);
+extern _X_EXPORT void vgaHWSeqReset(vgaHWPtr hwp, Bool start);
+extern _X_EXPORT void vgaHWRestoreFonts(ScrnInfoPtr scrninfp,
+                                        vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestoreMode(ScrnInfoPtr scrninfp, vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestoreColormap(ScrnInfoPtr scrninfp,
+                                           vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestore(ScrnInfoPtr scrninfp, vgaRegPtr restore,
+                                   int flags);
+extern _X_EXPORT void vgaHWSaveFonts(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSaveMode(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSaveColormap(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSave(ScrnInfoPtr scrninfp, vgaRegPtr save,
+                                int flags);
+extern _X_EXPORT Bool vgaHWInit(ScrnInfoPtr scrnp, DisplayModePtr mode);
+extern _X_EXPORT Bool vgaHWSetRegCounts(ScrnInfoPtr scrp, int numCRTC,
+                                        int numSequencer, int numGraphics,
+                                        int numAttribute);
+extern _X_EXPORT Bool vgaHWCopyReg(vgaRegPtr dst, vgaRegPtr src);
+extern _X_EXPORT Bool vgaHWGetHWRec(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWFreeHWRec(ScrnInfoPtr scrp);
+extern _X_EXPORT Bool vgaHWMapMem(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWUnmapMem(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWGetIOBase(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWLock(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWUnlock(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWEnable(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWDisable(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWDPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode,
+                                   int flags);
+extern _X_EXPORT Bool vgaHWHandleColormaps(ScreenPtr pScreen);
+extern _X_EXPORT void vgaHWddc1SetSpeed(ScrnInfoPtr pScrn, xf86ddcSpeed speed);
+extern _X_EXPORT CARD32 vgaHWHBlankKGA(DisplayModePtr mode, vgaRegPtr regp,
+                                       int nBits, unsigned int Flags);
+extern _X_EXPORT CARD32 vgaHWVBlankKGA(DisplayModePtr mode, vgaRegPtr regp,
+                                       int nBits, unsigned int Flags);
+extern _X_EXPORT Bool vgaHWAllocDefaultRegs(vgaRegPtr regp);
+
+extern _X_EXPORT DDC1SetSpeedProc vgaHWddc1SetSpeedWeak(void);
+extern _X_EXPORT SaveScreenProcPtr vgaHWSaveScreenWeak(void);
+extern _X_EXPORT void xf86GetClocks(ScrnInfoPtr pScrn, int num,
+                                    Bool (*ClockFunc) (ScrnInfoPtr, int),
+                                    void (*ProtectRegs) (ScrnInfoPtr, Bool),
+                                    void (*BlankScreen) (ScrnInfoPtr, Bool),
+                                    unsigned long vertsyncreg, int maskval,
+                                    int knownclkindex, int knownclkvalue);
+
+#endif                          /* _VGAHW_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vgaHW.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/singlesize.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/singlesize.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/singlesize.h	(Revision 52145)
@@ -0,0 +1,54 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _singlesize_h_
+#define _singlesize_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#include "indirect_size.h"
+
+extern GLint __glReadPixels_size(GLenum format, GLenum type,
+                                 GLint width, GLint height);
+extern GLint __glGetMap_size(GLenum pname, GLenum query);
+extern GLint __glGetMapdv_size(GLenum target, GLenum query);
+extern GLint __glGetMapfv_size(GLenum target, GLenum query);
+extern GLint __glGetMapiv_size(GLenum target, GLenum query);
+extern GLint __glGetPixelMap_size(GLenum map);
+extern GLint __glGetPixelMapfv_size(GLenum map);
+extern GLint __glGetPixelMapuiv_size(GLenum map);
+extern GLint __glGetPixelMapusv_size(GLenum map);
+extern GLint __glGetTexImage_size(GLenum target, GLint level, GLenum format,
+                                  GLenum type, GLint width, GLint height,
+                                  GLint depth);
+
+#endif                          /* _singlesize_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/singlesize.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Opt.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Opt.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Opt.h	(Revision 52145)
@@ -0,0 +1,158 @@
+
+/*
+ * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* Option handling things that ModuleSetup procs can use */
+
+#ifndef _XF86_OPT_H_
+#define _XF86_OPT_H_
+#include "xf86Optionstr.h"
+
+typedef struct {
+    double freq;
+    int units;
+} OptFrequency;
+
+typedef union {
+    unsigned long num;
+    const char *str;
+    double realnum;
+    Bool bool;
+    OptFrequency freq;
+} ValueUnion;
+
+typedef enum {
+    OPTV_NONE = 0,
+    OPTV_INTEGER,
+    OPTV_STRING,                /* a non-empty string */
+    OPTV_ANYSTR,                /* Any string, including an empty one */
+    OPTV_REAL,
+    OPTV_BOOLEAN,
+    OPTV_PERCENT,
+    OPTV_FREQ
+} OptionValueType;
+
+typedef enum {
+    OPTUNITS_HZ = 1,
+    OPTUNITS_KHZ,
+    OPTUNITS_MHZ
+} OptFreqUnits;
+
+typedef struct {
+    int token;
+    const char *name;
+    OptionValueType type;
+    ValueUnion value;
+    Bool found;
+} OptionInfoRec, *OptionInfoPtr;
+
+extern _X_EXPORT int xf86SetIntOption(XF86OptionPtr optlist, const char *name,
+                                      int deflt);
+extern _X_EXPORT double xf86SetRealOption(XF86OptionPtr optlist,
+                                          const char *name, double deflt);
+extern _X_EXPORT char *xf86SetStrOption(XF86OptionPtr optlist, const char *name,
+                                        const char *deflt);
+extern _X_EXPORT int xf86SetBoolOption(XF86OptionPtr list, const char *name,
+                                       int deflt);
+extern _X_EXPORT double xf86SetPercentOption(XF86OptionPtr list,
+                                             const char *name, double deflt);
+extern _X_EXPORT int xf86CheckIntOption(XF86OptionPtr optlist, const char *name,
+                                        int deflt);
+extern _X_EXPORT double xf86CheckRealOption(XF86OptionPtr optlist,
+                                            const char *name, double deflt);
+extern _X_EXPORT char *xf86CheckStrOption(XF86OptionPtr optlist,
+                                          const char *name, const char *deflt);
+extern _X_EXPORT int xf86CheckBoolOption(XF86OptionPtr list, const char *name,
+                                         int deflt);
+extern _X_EXPORT double xf86CheckPercentOption(XF86OptionPtr list,
+                                               const char *name, double deflt);
+extern _X_EXPORT XF86OptionPtr xf86AddNewOption(XF86OptionPtr head,
+                                                const char *name,
+                                                const char *val);
+extern _X_EXPORT XF86OptionPtr xf86NewOption(char *name, char *value);
+extern _X_EXPORT XF86OptionPtr xf86NextOption(XF86OptionPtr list);
+extern _X_EXPORT XF86OptionPtr xf86OptionListCreate(const char **options,
+                                                    int count, int used);
+extern _X_EXPORT XF86OptionPtr xf86OptionListMerge(XF86OptionPtr head,
+                                                   XF86OptionPtr tail);
+extern _X_EXPORT XF86OptionPtr xf86OptionListDuplicate(XF86OptionPtr list);
+extern _X_EXPORT void xf86OptionListFree(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86OptionName(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86OptionValue(XF86OptionPtr opt);
+extern _X_EXPORT void xf86OptionListReport(XF86OptionPtr parm);
+extern _X_EXPORT XF86OptionPtr xf86FindOption(XF86OptionPtr options,
+                                              const char *name);
+extern _X_EXPORT const char *xf86FindOptionValue(XF86OptionPtr options,
+                                                 const char *name);
+extern _X_EXPORT void xf86MarkOptionUsed(XF86OptionPtr option);
+extern _X_EXPORT void xf86MarkOptionUsedByName(XF86OptionPtr options,
+                                               const char *name);
+extern _X_EXPORT Bool xf86CheckIfOptionUsed(XF86OptionPtr option);
+extern _X_EXPORT Bool xf86CheckIfOptionUsedByName(XF86OptionPtr options,
+                                                  const char *name);
+extern _X_EXPORT void xf86ShowUnusedOptions(int scrnIndex,
+                                            XF86OptionPtr options);
+extern _X_EXPORT void xf86ProcessOptions(int scrnIndex, XF86OptionPtr options,
+                                         OptionInfoPtr optinfo);
+extern _X_EXPORT OptionInfoPtr xf86TokenToOptinfo(const OptionInfoRec * table,
+                                                  int token);
+extern _X_EXPORT const char *xf86TokenToOptName(const OptionInfoRec * table,
+                                                int token);
+extern _X_EXPORT Bool xf86IsOptionSet(const OptionInfoRec * table, int token);
+extern _X_EXPORT const char *xf86GetOptValString(const OptionInfoRec * table,
+                                           int token);
+extern _X_EXPORT Bool xf86GetOptValInteger(const OptionInfoRec * table,
+                                           int token, int *value);
+extern _X_EXPORT Bool xf86GetOptValULong(const OptionInfoRec * table, int token,
+                                         unsigned long *value);
+extern _X_EXPORT Bool xf86GetOptValReal(const OptionInfoRec * table, int token,
+                                        double *value);
+extern _X_EXPORT Bool xf86GetOptValFreq(const OptionInfoRec * table, int token,
+                                        OptFreqUnits expectedUnits,
+                                        double *value);
+extern _X_EXPORT Bool xf86GetOptValBool(const OptionInfoRec * table, int token,
+                                        Bool *value);
+extern _X_EXPORT Bool xf86ReturnOptValBool(const OptionInfoRec * table,
+                                           int token, Bool def);
+extern _X_EXPORT int xf86NameCmp(const char *s1, const char *s2);
+extern _X_EXPORT char *xf86NormalizeName(const char *s);
+extern _X_EXPORT XF86OptionPtr xf86ReplaceIntOption(XF86OptionPtr optlist,
+                                                    const char *name,
+                                                    const int val);
+extern _X_EXPORT XF86OptionPtr xf86ReplaceRealOption(XF86OptionPtr optlist,
+                                                     const char *name,
+                                                     const double val);
+extern _X_EXPORT XF86OptionPtr xf86ReplaceBoolOption(XF86OptionPtr optlist,
+                                                     const char *name,
+                                                     const Bool val);
+extern _X_EXPORT XF86OptionPtr xf86ReplacePercentOption(XF86OptionPtr optlist,
+                                                        const char *name,
+                                                        const double val);
+extern _X_EXPORT XF86OptionPtr xf86ReplaceStrOption(XF86OptionPtr optlist,
+                                                    const char *name,
+                                                    const char *val);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Opt.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsdk.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsdk.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsdk.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * Copyright ¬© 2010 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _SYNCSDK_H_
+#define _SYNCSDK_H_
+
+#include "misync.h"
+
+extern _X_EXPORT int
+ SyncVerifyFence(SyncFence ** ppFence, XID fid, ClientPtr client, Mask mode);
+
+#define VERIFY_SYNC_FENCE(pFence, fid, client, mode)			\
+    do {								\
+	int rc;								\
+	rc = SyncVerifyFence(&(pFence), (fid), (client), (mode));	\
+	if (Success != rc) return rc;					\
+    } while (0)
+
+#define VERIFY_SYNC_FENCE_OR_NONE(pFence, fid, client, mode)		\
+    do {								\
+        pFence = 0;							\
+        if (None != fid)						\
+	    VERIFY_SYNC_FENCE((pFence), (fid), (client), (mode));	\
+    } while (0)
+
+#endif                          /* _SYNCSDK_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsdk.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mivalidate.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mivalidate.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mivalidate.h	(Revision 52145)
@@ -0,0 +1,51 @@
+/*
+
+Copyright 1993, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef MIVALIDATE_H
+#define MIVALIDATE_H
+
+#include "regionstr.h"
+
+typedef union _Validate {
+    struct BeforeValidate {
+        DDXPointRec oldAbsCorner;       /* old window position */
+        RegionPtr borderVisible;        /* visible region of border, */
+        /* non-null when size changes */
+        Bool resized;           /* unclipped winSize has changed */
+    } before;
+    struct AfterValidate {
+        RegionRec exposed;      /* exposed regions, absolute pos */
+        RegionRec borderExposed;
+    } after;
+} ValidateRec;
+
+#endif                          /* MIVALIDATE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mivalidate.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getprop.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getprop.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getprop.h	(Revision 52145)
@@ -0,0 +1,51 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETPROP_H
+#define GETPROP_H 1
+
+int SProcXGetDeviceDontPropagateList(ClientPtr  /* client */
+    );
+
+int ProcXGetDeviceDontPropagateList(ClientPtr   /* client */
+    );
+
+XEventClass *ClassFromMask(XEventClass * /* buf */ ,
+                           Mask /* mask */ ,
+                           int /* maskndx */ ,
+                           CARD16 * /* count */ ,
+                           int  /* mode */
+    );
+
+void SRepXGetDeviceDontPropagateList(ClientPtr /* client */ ,
+                                     int /* size */ ,
+                                     xGetDeviceDontPropagateListReply * /* rep */
+    );
+
+#endif                          /* GETPROP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getprop.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbDflts.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbDflts.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbDflts.h	(Revision 52145)
@@ -0,0 +1,471 @@
+/* This file generated automatically by xkbcomp */
+/* DO  NOT EDIT */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DEFAULT_H
+#define DEFAULT_H 1
+
+#define GET_ATOM(d,s)	MakeAtom(s,strlen(s),1)
+#define DPYTYPE	char *
+#define NUM_KEYS	1
+
+#define	vmod_NumLock	0
+#define	vmod_Alt	1
+#define	vmod_LevelThree	2
+#define	vmod_AltGr	3
+#define	vmod_ScrollLock	4
+
+#define	vmod_NumLockMask	(1<<0)
+#define	vmod_AltMask	(1<<1)
+#define	vmod_LevelThreeMask	(1<<2)
+#define	vmod_AltGrMask	(1<<3)
+#define	vmod_ScrollLockMask	(1<<4)
+
+/* types name is "default" */
+static Atom lnames_ONE_LEVEL[1];
+
+static XkbKTMapEntryRec map_TWO_LEVEL[1] = {
+    {1, 1, {ShiftMask, ShiftMask, 0}}
+};
+
+static Atom lnames_TWO_LEVEL[2];
+
+static XkbKTMapEntryRec map_ALPHABETIC[2] = {
+    {1, 1, {ShiftMask, ShiftMask, 0}},
+    {1, 0, {LockMask, LockMask, 0}}
+};
+
+static XkbModsRec preserve_ALPHABETIC[2] = {
+    {0, 0, 0},
+    {LockMask, LockMask, 0}
+};
+
+static Atom lnames_ALPHABETIC[2];
+
+static XkbKTMapEntryRec map_KEYPAD[2] = {
+    {1, 1, {ShiftMask, ShiftMask, 0}},
+    {0, 1, {0, 0, vmod_NumLockMask}}
+};
+
+static Atom lnames_KEYPAD[2];
+
+static XkbKTMapEntryRec map_PC_BREAK[1] = {
+    {1, 1, {ControlMask, ControlMask, 0}}
+};
+
+static Atom lnames_PC_BREAK[2];
+
+static XkbKTMapEntryRec map_PC_SYSRQ[1] = {
+    {0, 1, {0, 0, vmod_AltMask}}
+};
+
+static Atom lnames_PC_SYSRQ[2];
+
+static XkbKTMapEntryRec map_CTRL_ALT[1] = {
+    {0, 1, {ControlMask, ControlMask, vmod_AltMask}}
+};
+
+static Atom lnames_CTRL_ALT[2];
+
+static XkbKTMapEntryRec map_THREE_LEVEL[3] = {
+    {1, 1, {ShiftMask, ShiftMask, 0}},
+    {0, 2, {0, 0, vmod_LevelThreeMask}},
+    {0, 2, {ShiftMask, ShiftMask, vmod_LevelThreeMask}}
+};
+
+static Atom lnames_THREE_LEVEL[3];
+
+static XkbKTMapEntryRec map_SHIFT_ALT[1] = {
+    {0, 1, {ShiftMask, ShiftMask, vmod_AltMask}}
+};
+
+static Atom lnames_SHIFT_ALT[2];
+
+static XkbKeyTypeRec dflt_types[] = {
+    {
+     {0, 0, 0},
+     1,
+     0, NULL, NULL,
+     None, lnames_ONE_LEVEL},
+    {
+     {ShiftMask, ShiftMask, 0},
+     2,
+     1, map_TWO_LEVEL, NULL,
+     None, lnames_TWO_LEVEL},
+    {
+     {ShiftMask | LockMask, ShiftMask | LockMask, 0},
+     2,
+     2, map_ALPHABETIC, preserve_ALPHABETIC,
+     None, lnames_ALPHABETIC},
+    {
+     {ShiftMask, ShiftMask, vmod_NumLockMask},
+     2,
+     2, map_KEYPAD, NULL,
+     None, lnames_KEYPAD},
+    {
+     {ControlMask, ControlMask, 0},
+     2,
+     1, map_PC_BREAK, NULL,
+     None, lnames_PC_BREAK},
+    {
+     {0, 0, vmod_AltMask},
+     2,
+     1, map_PC_SYSRQ, NULL,
+     None, lnames_PC_SYSRQ},
+    {
+     {ControlMask, ControlMask, vmod_AltMask},
+     2,
+     1, map_CTRL_ALT, NULL,
+     None, lnames_CTRL_ALT},
+    {
+     {ShiftMask, ShiftMask, vmod_LevelThreeMask},
+     3,
+     3, map_THREE_LEVEL, NULL,
+     None, lnames_THREE_LEVEL},
+    {
+     {ShiftMask, ShiftMask, vmod_AltMask},
+     2,
+     1, map_SHIFT_ALT, NULL,
+     None, lnames_SHIFT_ALT}
+};
+
+#define num_dflt_types (sizeof(dflt_types)/sizeof(XkbKeyTypeRec))
+
+static void
+initTypeNames(DPYTYPE dpy)
+{
+    dflt_types[0].name = GET_ATOM(dpy, "ONE_LEVEL");
+    lnames_ONE_LEVEL[0] = GET_ATOM(dpy, "Any");
+    dflt_types[1].name = GET_ATOM(dpy, "TWO_LEVEL");
+    lnames_TWO_LEVEL[0] = GET_ATOM(dpy, "Base");
+    lnames_TWO_LEVEL[1] = GET_ATOM(dpy, "Shift");
+    dflt_types[2].name = GET_ATOM(dpy, "ALPHABETIC");
+    lnames_ALPHABETIC[0] = GET_ATOM(dpy, "Base");
+    lnames_ALPHABETIC[1] = GET_ATOM(dpy, "Caps");
+    dflt_types[3].name = GET_ATOM(dpy, "KEYPAD");
+    lnames_KEYPAD[0] = GET_ATOM(dpy, "Base");
+    lnames_KEYPAD[1] = GET_ATOM(dpy, "Number");
+    dflt_types[4].name = GET_ATOM(dpy, "PC_BREAK");
+    lnames_PC_BREAK[0] = GET_ATOM(dpy, "Base");
+    lnames_PC_BREAK[1] = GET_ATOM(dpy, "Control");
+    dflt_types[5].name = GET_ATOM(dpy, "PC_SYSRQ");
+    lnames_PC_SYSRQ[0] = GET_ATOM(dpy, "Base");
+    lnames_PC_SYSRQ[1] = GET_ATOM(dpy, "Alt");
+    dflt_types[6].name = GET_ATOM(dpy, "CTRL+ALT");
+    lnames_CTRL_ALT[0] = GET_ATOM(dpy, "Base");
+    lnames_CTRL_ALT[1] = GET_ATOM(dpy, "Ctrl+Alt");
+    dflt_types[7].name = GET_ATOM(dpy, "THREE_LEVEL");
+    lnames_THREE_LEVEL[0] = GET_ATOM(dpy, "Base");
+    lnames_THREE_LEVEL[1] = GET_ATOM(dpy, "Shift");
+    lnames_THREE_LEVEL[2] = GET_ATOM(dpy, "Level3");
+    dflt_types[8].name = GET_ATOM(dpy, "SHIFT+ALT");
+    lnames_SHIFT_ALT[0] = GET_ATOM(dpy, "Base");
+    lnames_SHIFT_ALT[1] = GET_ATOM(dpy, "Shift+Alt");
+}
+
+/* compat name is "default" */
+static XkbSymInterpretRec dfltSI[69] = {
+    {XK_ISO_Level2_Latch, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_Exactly, ShiftMask,
+     255,
+     {XkbSA_LatchMods, {0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Eisu_Shift, 0x0000,
+     XkbSI_Exactly, LockMask,
+     255,
+     {XkbSA_NoAction, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Eisu_toggle, 0x0000,
+     XkbSI_Exactly, LockMask,
+     255,
+     {XkbSA_NoAction, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Kana_Shift, 0x0000,
+     XkbSI_Exactly, LockMask,
+     255,
+     {XkbSA_NoAction, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Kana_Lock, 0x0000,
+     XkbSI_Exactly, LockMask,
+     255,
+     {XkbSA_NoAction, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Shift_Lock, 0x0000,
+     XkbSI_AnyOf, ShiftMask | LockMask,
+     255,
+     {XkbSA_LockMods, {0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Num_Lock, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     0,
+     {XkbSA_LockMods, {0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_Alt_L, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     1,
+     {XkbSA_SetMods, {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Alt_R, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     1,
+     {XkbSA_SetMods, {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Scroll_Lock, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     4,
+     {XkbSA_LockMods, {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Lock, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     255,
+     {XkbSA_ISOLock, {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Level3_Shift, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOf, 0xff,
+     2,
+     {XkbSA_SetMods, {0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00}}},
+    {XK_ISO_Level3_Latch, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOf, 0xff,
+     2,
+     {XkbSA_LatchMods, {0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00}}},
+    {XK_Mode_switch, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOfOrNone, 0xff,
+     3,
+     {XkbSA_SetGroup, {0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_1, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_End, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_2, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_Down, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_3, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_Next, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00}}},
+    {XK_KP_4, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Left, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_6, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Right, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_7, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_Home, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_8, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_Up, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_9, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_Prior, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_MovePtr, {0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00}}},
+    {XK_KP_5, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Begin, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_F1, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Divide, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_F2, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Multiply, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_F3, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Subtract, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Separator, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Add, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_0, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Insert, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Decimal, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_KP_Delete, 0x0001,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Button_Dflt, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Button1, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Button2, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Button3, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_DblClick_Dflt, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_DblClick1, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_DblClick2, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_DblClick3, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_PtrBtn, {0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Drag_Dflt, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Drag1, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Drag2, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_Drag3, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockPtrBtn, {0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_EnableKeys, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockControls, {0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00}}},
+    {XK_Pointer_Accelerate, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockControls, {0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00}}},
+    {XK_Pointer_DfltBtnNext, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_Pointer_DfltBtnPrev, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_SetPtrDflt, {0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_AccessX_Enable, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockControls, {0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00}}},
+    {XK_Terminate_Server, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_Terminate, {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Group_Latch, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOfOrNone, 0xff,
+     3,
+     {XkbSA_LatchGroup, {0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Next_Group, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOfOrNone, 0xff,
+     3,
+     {XkbSA_LockGroup, {0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Prev_Group, 0x0000,
+     XkbSI_LevelOneOnly | XkbSI_AnyOfOrNone, 0xff,
+     3,
+     {XkbSA_LockGroup, {0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_First_Group, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockGroup, {0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {XK_ISO_Last_Group, 0x0000,
+     XkbSI_AnyOfOrNone, 0xff,
+     255,
+     {XkbSA_LockGroup, {0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00}}},
+    {NoSymbol, 0x0000,
+     XkbSI_Exactly, LockMask,
+     255,
+     {XkbSA_LockMods, {0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00}}},
+    {NoSymbol, 0x0000,
+     XkbSI_AnyOf, 0xff,
+     255,
+     {XkbSA_SetMods, {0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}}
+};
+
+#define num_dfltSI (sizeof(dfltSI)/sizeof(XkbSymInterpretRec))
+
+static XkbCompatMapRec compatMap = {
+    dfltSI,
+    {                           /* group compatibility */
+     {0, 0, 0},
+     {0, 0, vmod_AltGrMask},
+     {0, 0, vmod_AltGrMask},
+     {0, 0, vmod_AltGrMask}
+     },
+    num_dfltSI, num_dfltSI
+};
+
+static void
+initIndicatorNames(DPYTYPE dpy, XkbDescPtr xkb)
+{
+    xkb->names->indicators[0] = GET_ATOM(dpy, "Caps Lock");
+    xkb->names->indicators[1] = GET_ATOM(dpy, "Num Lock");
+    xkb->names->indicators[2] = GET_ATOM(dpy, "Shift Lock");
+    xkb->names->indicators[3] = GET_ATOM(dpy, "Mouse Keys");
+    xkb->names->indicators[4] = GET_ATOM(dpy, "Scroll Lock");
+    xkb->names->indicators[5] = GET_ATOM(dpy, "Group 2");
+}
+#endif                          /* DEFAULT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbDflts.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swapreq.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swapreq.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swapreq.h	(Revision 52145)
@@ -0,0 +1,106 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREQ_H
+#define SWAPREQ_H 1
+
+extern _X_EXPORT void SwapColorItem(xColorItem * /* pItem */ );
+
+extern _X_EXPORT void SwapConnClientPrefix(xConnClientPrefix * /* pCCP */ );
+
+#undef SWAPREQ_PROC
+
+#define SWAPREQ_PROC(func) extern _X_EXPORT int func(ClientPtr /* client */)
+
+SWAPREQ_PROC(SProcAllocColor);
+SWAPREQ_PROC(SProcAllocColorCells);
+SWAPREQ_PROC(SProcAllocColorPlanes);
+SWAPREQ_PROC(SProcAllocNamedColor);
+SWAPREQ_PROC(SProcChangeActivePointerGrab);
+SWAPREQ_PROC(SProcChangeGC);
+SWAPREQ_PROC(SProcChangeHosts);
+SWAPREQ_PROC(SProcChangeKeyboardControl);
+SWAPREQ_PROC(SProcChangeKeyboardMapping);
+SWAPREQ_PROC(SProcChangePointerControl);
+SWAPREQ_PROC(SProcChangeProperty);
+SWAPREQ_PROC(SProcChangeWindowAttributes);
+SWAPREQ_PROC(SProcClearToBackground);
+SWAPREQ_PROC(SProcConfigureWindow);
+SWAPREQ_PROC(SProcConvertSelection);
+SWAPREQ_PROC(SProcCopyArea);
+SWAPREQ_PROC(SProcCopyColormapAndFree);
+SWAPREQ_PROC(SProcCopyGC);
+SWAPREQ_PROC(SProcCopyPlane);
+SWAPREQ_PROC(SProcCreateColormap);
+SWAPREQ_PROC(SProcCreateCursor);
+SWAPREQ_PROC(SProcCreateGC);
+SWAPREQ_PROC(SProcCreateGlyphCursor);
+SWAPREQ_PROC(SProcCreatePixmap);
+SWAPREQ_PROC(SProcCreateWindow);
+SWAPREQ_PROC(SProcDeleteProperty);
+SWAPREQ_PROC(SProcFillPoly);
+SWAPREQ_PROC(SProcFreeColors);
+SWAPREQ_PROC(SProcGetImage);
+SWAPREQ_PROC(SProcGetMotionEvents);
+SWAPREQ_PROC(SProcGetProperty);
+SWAPREQ_PROC(SProcGrabButton);
+SWAPREQ_PROC(SProcGrabKey);
+SWAPREQ_PROC(SProcGrabKeyboard);
+SWAPREQ_PROC(SProcGrabPointer);
+SWAPREQ_PROC(SProcImageText);
+SWAPREQ_PROC(SProcInternAtom);
+SWAPREQ_PROC(SProcListFonts);
+SWAPREQ_PROC(SProcListFontsWithInfo);
+SWAPREQ_PROC(SProcLookupColor);
+SWAPREQ_PROC(SProcNoOperation);
+SWAPREQ_PROC(SProcOpenFont);
+SWAPREQ_PROC(SProcPoly);
+SWAPREQ_PROC(SProcPolyText);
+SWAPREQ_PROC(SProcPutImage);
+SWAPREQ_PROC(SProcQueryBestSize);
+SWAPREQ_PROC(SProcQueryColors);
+SWAPREQ_PROC(SProcQueryExtension);
+SWAPREQ_PROC(SProcRecolorCursor);
+SWAPREQ_PROC(SProcReparentWindow);
+SWAPREQ_PROC(SProcResourceReq);
+SWAPREQ_PROC(SProcRotateProperties);
+SWAPREQ_PROC(SProcSendEvent);
+SWAPREQ_PROC(SProcSetClipRectangles);
+SWAPREQ_PROC(SProcSetDashes);
+SWAPREQ_PROC(SProcSetFontPath);
+SWAPREQ_PROC(SProcSetInputFocus);
+SWAPREQ_PROC(SProcSetScreenSaver);
+SWAPREQ_PROC(SProcSetSelectionOwner);
+SWAPREQ_PROC(SProcSimpleReq);
+SWAPREQ_PROC(SProcStoreColors);
+SWAPREQ_PROC(SProcStoreNamedColor);
+SWAPREQ_PROC(SProcTranslateCoords);
+SWAPREQ_PROC(SProcUngrabButton);
+SWAPREQ_PROC(SProcUngrabKey);
+SWAPREQ_PROC(SProcWarpPointer);
+
+#undef SWAPREQ_PROC
+
+#endif                          /* SWAPREQ_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/swapreq.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/region.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/region.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/region.h	(Revision 52145)
@@ -0,0 +1,52 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef REGION_H
+#define REGION_H
+
+#include "regionstr.h"
+
+#endif                          /* REGION_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/region.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbfile.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbfile.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbfile.h	(Revision 52145)
@@ -0,0 +1,276 @@
+/************************************************************
+ Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
+
+ Permission to use, copy, modify, and distribute this
+ software and its documentation for any purpose and without
+ fee is hereby granted, provided that the above copyright
+ notice appear in all copies and that both that copyright
+ notice and this permission notice appear in supporting
+ documentation, and that the name of Silicon Graphics not be 
+ used in advertising or publicity pertaining to distribution 
+ of the software without specific prior written permission.
+ Silicon Graphics makes no representation about the suitability 
+ of this software for any purpose. It is provided "as is"
+ without any express or implied warranty.
+ 
+ SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+ SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+ DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+ OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ ********************************************************/
+
+#ifndef _XKBFILE_H_
+#define	_XKBFILE_H_ 1
+
+#include "xkbstr.h"
+
+/***====================================================================***/
+
+#define	XkbXKMFile	0
+#define	XkbCFile	1
+#define	XkbXKBFile	2
+#define	XkbMessage	3
+
+#define	XkbMapDefined		(1<<0)
+#define	XkbStateDefined		(1<<1)
+
+typedef void (*XkbFileAddOnFunc) (FILE * /* file */ ,
+                                  XkbDescPtr /* result */ ,
+                                  Bool /* topLevel */ ,
+                                  Bool /* showImplicit */ ,
+                                  int /* fileSection */ ,
+                                  void *        /* priv */
+    );
+
+/***====================================================================***/
+
+#define	_XkbSuccess			0
+#define	_XkbErrMissingNames		1
+#define	_XkbErrMissingTypes		2
+#define	_XkbErrMissingReqTypes		3
+#define	_XkbErrMissingSymbols		4
+#define	_XkbErrMissingVMods		5
+#define	_XkbErrMissingIndicators	6
+#define	_XkbErrMissingCompatMap		7
+#define	_XkbErrMissingSymInterps	8
+#define	_XkbErrMissingGeometry		9
+#define	_XkbErrIllegalDoodad		10
+#define	_XkbErrIllegalTOCType		11
+#define	_XkbErrIllegalContents		12
+#define	_XkbErrEmptyFile		13
+#define	_XkbErrFileNotFound		14
+#define	_XkbErrFileCannotOpen		15
+#define	_XkbErrBadValue			16
+#define	_XkbErrBadMatch			17
+#define	_XkbErrBadTypeName		18
+#define	_XkbErrBadTypeWidth		19
+#define	_XkbErrBadFileType		20
+#define	_XkbErrBadFileVersion		21
+#define	_XkbErrBadFileFormat		22
+#define	_XkbErrBadAlloc			23
+#define	_XkbErrBadLength		24
+#define	_XkbErrXReqFailure		25
+#define	_XkbErrBadImplementation	26
+
+/***====================================================================***/
+
+_XFUNCPROTOBEGIN
+
+extern _X_EXPORT char *XkbIndentText(unsigned   /* size */
+    );
+
+extern _X_EXPORT char *XkbAtomText(Atom /* atm */ ,
+                                   unsigned     /* format */
+    );
+
+extern _X_EXPORT char *XkbKeysymText(KeySym /* sym */ ,
+                                     unsigned   /* format */
+    );
+
+extern _X_EXPORT char *XkbStringText(char * /* str */ ,
+                                     unsigned   /* format */
+    );
+
+extern _X_EXPORT char *XkbKeyNameText(char * /* name */ ,
+                                      unsigned  /* format */
+    );
+
+extern _X_EXPORT char *XkbModIndexText(unsigned /* ndx */ ,
+                                       unsigned /* format */
+    );
+
+extern _X_EXPORT char *XkbModMaskText(unsigned /* mask */ ,
+                                      unsigned  /* format */
+    );
+
+extern _X_EXPORT char *XkbVModIndexText(XkbDescPtr /* xkb */ ,
+                                        unsigned /* ndx */ ,
+                                        unsigned        /* format */
+    );
+
+extern _X_EXPORT char *XkbVModMaskText(XkbDescPtr /* xkb */ ,
+                                       unsigned /* modMask */ ,
+                                       unsigned /* mask */ ,
+                                       unsigned /* format */
+    );
+
+extern _X_EXPORT char *XkbConfigText(unsigned /* config */ ,
+                                     unsigned   /* format */
+    );
+
+extern _X_EXPORT const char *XkbSIMatchText(unsigned /* type */ ,
+                                            unsigned    /* format */
+    );
+
+extern _X_EXPORT char *XkbIMWhichStateMaskText(unsigned /* use_which */ ,
+                                               unsigned /* format */
+    );
+
+extern _X_EXPORT char *XkbControlsMaskText(unsigned /* ctrls */ ,
+                                           unsigned     /* format */
+    );
+
+extern _X_EXPORT char *XkbGeomFPText(int /* val */ ,
+                                     unsigned   /* format */
+    );
+
+extern _X_EXPORT char *XkbDoodadTypeText(unsigned /* type */ ,
+                                         unsigned       /* format */
+    );
+
+extern _X_EXPORT const char *XkbActionTypeText(unsigned /* type */ ,
+                                               unsigned /* format */
+    );
+
+extern _X_EXPORT char *XkbActionText(XkbDescPtr /* xkb */ ,
+                                     XkbAction * /* action */ ,
+                                     unsigned   /* format */
+    );
+
+extern _X_EXPORT char *XkbBehaviorText(XkbDescPtr /* xkb */ ,
+                                       XkbBehavior * /* behavior */ ,
+                                       unsigned /* format */
+    );
+
+/***====================================================================***/
+
+#define	_XkbKSLower	(1<<0)
+#define	_XkbKSUpper	(1<<1)
+
+#define	XkbKSIsLower(k)		(_XkbKSCheckCase(k)&_XkbKSLower)
+#define	XkbKSIsUpper(k)		(_XkbKSCheckCase(k)&_XkbKSUpper)
+#define XkbKSIsKeypad(k)	(((k)>=XK_KP_Space)&&((k)<=XK_KP_Equal))
+#define	XkbKSIsDeadKey(k)	\
+		(((k)>=XK_dead_grave)&&((k)<=XK_dead_semivoiced_sound))
+
+extern _X_EXPORT unsigned _XkbKSCheckCase(KeySym        /* sym */
+    );
+
+extern _X_EXPORT int XkbFindKeycodeByName(XkbDescPtr /* xkb */ ,
+                                          char * /* name */ ,
+                                          Bool  /* use_aliases */
+    );
+
+/***====================================================================***/
+
+extern _X_EXPORT Atom XkbInternAtom(char * /* name */ ,
+                                    Bool        /* onlyIfExists */
+    );
+
+/***====================================================================***/
+
+#ifdef _XKBGEOM_H_
+
+#define	XkbDW_Unknown	0
+#define	XkbDW_Doodad	1
+#define	XkbDW_Section	2
+typedef struct _XkbDrawable {
+    int type;
+    int priority;
+    union {
+        XkbDoodadPtr doodad;
+        XkbSectionPtr section;
+    } u;
+    struct _XkbDrawable *next;
+} XkbDrawableRec, *XkbDrawablePtr;
+
+#endif
+
+/***====================================================================***/
+
+extern _X_EXPORT unsigned XkbConvertGetByNameComponents(Bool /* toXkm */ ,
+                                                        unsigned        /* orig */
+    );
+
+extern _X_EXPORT Bool XkbNameMatchesPattern(char * /* name */ ,
+                                            char *      /* pattern */
+    );
+
+/***====================================================================***/
+
+extern _X_EXPORT Bool XkbWriteXKBKeycodes(FILE * /* file */ ,
+                                          XkbDescPtr /* result */ ,
+                                          Bool /* topLevel */ ,
+                                          Bool /* showImplicit */ ,
+                                          XkbFileAddOnFunc /* addOn */ ,
+                                          void *        /* priv */
+    );
+
+extern _X_EXPORT Bool XkbWriteXKBKeyTypes(FILE * /* file */ ,
+                                          XkbDescPtr /* result */ ,
+                                          Bool /* topLevel */ ,
+                                          Bool /* showImplicit */ ,
+                                          XkbFileAddOnFunc /* addOn */ ,
+                                          void *        /* priv */
+    );
+
+extern _X_EXPORT Bool XkbWriteXKBCompatMap(FILE * /* file */ ,
+                                           XkbDescPtr /* result */ ,
+                                           Bool /* topLevel */ ,
+                                           Bool /* showImplicit */ ,
+                                           XkbFileAddOnFunc /* addOn */ ,
+                                           void *       /* priv */
+    );
+
+extern _X_EXPORT Bool XkbWriteXKBSymbols(FILE * /* file */ ,
+                                         XkbDescPtr /* result */ ,
+                                         Bool /* topLevel */ ,
+                                         Bool /* showImplicit */ ,
+                                         XkbFileAddOnFunc /* addOn */ ,
+                                         void * /* priv */
+    );
+
+extern _X_EXPORT Bool XkbWriteXKBGeometry(FILE * /* file */ ,
+                                          XkbDescPtr /* result */ ,
+                                          Bool /* topLevel */ ,
+                                          Bool /* showImplicit */ ,
+                                          XkbFileAddOnFunc /* addOn */ ,
+                                          void *        /* priv */
+    );
+
+extern _X_EXPORT Bool XkbWriteXKBKeymapForNames(FILE * /* file */ ,
+                                                XkbComponentNamesPtr /* names */
+                                                ,
+                                                XkbDescPtr /* xkb */ ,
+                                                unsigned /* want */ ,
+                                                unsigned        /* need */
+    );
+
+/***====================================================================***/
+
+extern _X_EXPORT Bool XkmProbe(FILE *   /* file */
+    );
+
+extern _X_EXPORT unsigned XkmReadFile(FILE * /* file */ ,
+                                      unsigned /* need */ ,
+                                      unsigned /* want */ ,
+                                      XkbDescPtr *      /* result */
+    );
+
+_XFUNCPROTOEND
+#endif                          /* _XKBFILE_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbfile.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/servermd.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/servermd.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/servermd.h	(Revision 52145)
@@ -0,0 +1,397 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SERVERMD_H
+#define SERVERMD_H 1
+
+/*
+ * Note: much of this is vestigial from mfb/cfb times.  This should
+ * really be simplified even further.
+ */
+
+/*
+ * Machine dependent values:
+ * GLYPHPADBYTES should be chosen with consideration for the space-time
+ * trade-off.  Padding to 0 bytes means that there is no wasted space
+ * in the font bitmaps (both on disk and in memory), but that access of
+ * the bitmaps will cause odd-address memory references.  Padding to
+ * 2 bytes would ensure even address memory references and would
+ * be suitable for a 68010-class machine, but at the expense of wasted
+ * space in the font bitmaps.  Padding to 4 bytes would be good
+ * for real 32 bit machines, etc.  Be sure that you tell the font
+ * compiler what kind of padding you want because its defines are
+ * kept separate from this.  See server/include/font.h for how
+ * GLYPHPADBYTES is used.
+ */
+
+#ifdef __avr32__
+
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#define GLYPHPADBYTES           4
+
+#endif                          /* __avr32__ */
+
+#ifdef __arm32__
+
+#define IMAGE_BYTE_ORDER        LSBFirst
+#define BITMAP_BIT_ORDER        LSBFirst
+#define GLYPHPADBYTES           4
+
+#endif                          /* __arm32__ */
+
+#if defined(__nds32__)
+
+#define IMAGE_BYTE_ORDER	LSBFirst
+
+#if defined(XF86MONOVGA) || defined(XF86VGA16) || defined(XF86MONO)
+#define BITMAP_BIT_ORDER	MSBFirst
+#else
+#define BITMAP_BIT_ORDER	LSBFirst
+#endif
+
+#if defined(XF86MONOVGA) || defined(XF86VGA16)
+#define BITMAP_SCANLINE_UNIT	8
+#endif
+
+#define GLYPHPADBYTES		4
+#define GETLEFTBITS_ALIGNMENT	1
+#define LARGE_INSTRUCTION_CACHE
+#define AVOID_MEMORY_READ
+
+#endif                          /* __nds32__ */
+
+#if defined __hppa__
+
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4       /* to make fb work */
+                                        /* byte boundries */
+#endif                          /* hpux || __hppa__ */
+
+#if defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__)
+
+#if defined(__LITTLE_ENDIAN__)
+#define IMAGE_BYTE_ORDER      LSBFirst
+#define BITMAP_BIT_ORDER      LSBFirst
+#else
+#define IMAGE_BYTE_ORDER      MSBFirst
+#define BITMAP_BIT_ORDER      MSBFirst
+#endif
+#define GLYPHPADBYTES           4
+
+#endif                          /* PowerPC */
+
+#if defined(__sh__)
+
+#if defined(__BIG_ENDIAN__)
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#else
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#endif
+
+#endif                          /* SuperH */
+
+#if defined(__m32r__)
+
+#if defined(__BIG_ENDIAN__)
+#define IMAGE_BYTE_ORDER      MSBFirst
+#define BITMAP_BIT_ORDER      MSBFirst
+#define GLYPHPADBYTES         4
+#else
+#define IMAGE_BYTE_ORDER      LSBFirst
+#define BITMAP_BIT_ORDER      LSBFirst
+#define GLYPHPADBYTES         4
+#endif
+
+#endif                          /* __m32r__ */
+
+#if (defined(sun) && (defined(__sparc) || defined(sparc))) || \
+    (defined(__uxp__) && (defined(sparc) || defined(mc68000))) || \
+    defined(__sparc__) || defined(__mc68000__)
+
+#if defined(__sparc) || defined(__sparc__)
+#if !defined(sparc)
+#define sparc 1
+#endif
+#endif
+
+#if defined(sun386) || defined(sun5)
+#define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the SUN only */
+#define BITMAP_BIT_ORDER	LSBFirst
+#else
+#define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the SUN only */
+#define BITMAP_BIT_ORDER	MSBFirst
+#endif
+
+#define	GLYPHPADBYTES		4
+
+#endif                          /* sun && !(i386 && SVR4) */
+
+#if defined(ibm032) || defined (ibm)
+
+#ifdef __i386__
+#define IMAGE_BYTE_ORDER	LSBFirst        /* Value for PS/2 only */
+#else
+#define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the RT only */
+#endif
+#define BITMAP_BIT_ORDER	MSBFirst
+#define	GLYPHPADBYTES		1
+/* ibm pcc doesn't understand pragmas. */
+
+#ifdef __i386__
+#define BITMAP_SCANLINE_UNIT	8
+#endif
+
+#endif                          /* ibm */
+
+#if (defined(mips) || defined(__mips))
+
+#if defined(MIPSEL) || defined(__MIPSEL__)
+#define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the PMAX only */
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#else
+#define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the MIPS only */
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#endif
+
+#endif                          /* mips */
+
+#if defined(__alpha) || defined(__alpha__)
+#define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the Alpha only */
+#define BITMAP_BIT_ORDER       LSBFirst
+#define GLYPHPADBYTES		4
+
+#endif                          /* alpha */
+
+#if defined (linux) && defined (__s390__)
+
+#define IMAGE_BYTE_ORDER      	MSBFirst
+#define BITMAP_BIT_ORDER      	MSBFirst
+#define GLYPHPADBYTES         	4
+
+#define BITMAP_SCANLINE_UNIT	8
+#define FAST_UNALIGNED_READ
+
+#endif                          /* linux/s390 */
+
+#if defined (linux) && defined (__s390x__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define GLYPHPADBYTES          4
+
+#define BITMAP_SCANLINE_UNIT	8
+#define FAST_UNALIGNED_READ
+
+#endif                          /* linux/s390x */
+
+#if defined(__ia64__) || defined(ia64)
+
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER       LSBFirst
+#define GLYPHPADBYTES		4
+
+#endif                          /* ia64 */
+
+#if defined(__amd64__) || defined(amd64) || defined(__amd64)
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER       LSBFirst
+#define GLYPHPADBYTES		4
+/* ???? */
+#endif                          /* AMD64 */
+
+#if	defined(SVR4) && (defined(__i386__) || defined(__i386) ) ||	\
+	defined(__alpha__) || defined(__alpha) || \
+	defined(__i386__) || \
+	defined(__s390x__) || defined(__s390__)
+
+#ifndef IMAGE_BYTE_ORDER
+#define IMAGE_BYTE_ORDER	LSBFirst
+#endif
+
+#ifndef BITMAP_BIT_ORDER
+#define BITMAP_BIT_ORDER      LSBFirst
+#endif
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES           4
+#endif
+
+#endif                          /* SVR4 / BSD / i386 */
+
+#if defined (linux) && defined (__mc68000__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define GLYPHPADBYTES          4
+
+#endif                          /* linux/m68k */
+
+/* linux on ARM */
+#if defined(linux) && defined(__arm__)
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#endif
+
+/* linux on IBM S/390 */
+#if defined (linux) && defined (__s390__)
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#endif                          /* linux/s390 */
+
+#ifdef __aarch64__
+
+#ifdef __AARCH64EL__
+#define IMAGE_BYTE_ORDER        LSBFirst
+#define BITMAP_BIT_ORDER        LSBFirst
+#endif
+#ifdef __AARCH64EB__
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#endif
+#define GLYPHPADBYTES           4
+
+#endif                          /* __aarch64__ */
+
+#if defined(__arc__)
+
+#if defined(__BIG_ENDIAN__)
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#else
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#endif
+#define GLYPHPADBYTES		4
+
+#endif                          /* ARC */
+
+#ifdef __xtensa__
+
+#ifdef __XTENSA_EL__
+#define IMAGE_BYTE_ORDER        LSBFirst
+#define BITMAP_BIT_ORDER        LSBFirst
+#endif
+#ifdef __XTENSA_EB__
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#endif
+#define GLYPHPADBYTES           4
+
+#endif                          /* __xtensa__ */
+
+/* size of buffer to use with GetImage, measured in bytes. There's obviously
+ * a trade-off between the amount of heap used and the number of times the
+ * ddx routine has to be called.
+ */
+#ifndef IMAGE_BUFSIZE
+#define IMAGE_BUFSIZE		(64*1024)
+#endif
+
+/* pad scanline to a longword */
+#ifndef BITMAP_SCANLINE_UNIT
+#define BITMAP_SCANLINE_UNIT	32
+#endif
+
+#ifndef BITMAP_SCANLINE_PAD
+#define BITMAP_SCANLINE_PAD  32
+#define LOG2_BITMAP_PAD		5
+#define LOG2_BYTES_PER_SCANLINE_PAD	2
+#endif
+
+#include <X11/Xfuncproto.h>
+/* 
+ *   This returns the number of padding units, for depth d and width w.
+ * For bitmaps this can be calculated with the macros above.
+ * Other depths require either grovelling over the formats field of the
+ * screenInfo or hardwired constants.
+ */
+
+typedef struct _PaddingInfo {
+    int padRoundUp;             /* pixels per pad unit - 1 */
+    int padPixelsLog2;          /* log 2 (pixels per pad unit) */
+    int padBytesLog2;           /* log 2 (bytes per pad unit) */
+    int notPower2;              /* bitsPerPixel not a power of 2 */
+    int bytesPerPixel;          /* only set when notPower2 is TRUE */
+    int bitsPerPixel;           /* bits per pixel */
+} PaddingInfo;
+extern _X_EXPORT PaddingInfo PixmapWidthPaddingInfo[];
+
+/* The only portable way to get the bpp from the depth is to look it up */
+#define BitsPerPixel(d) (PixmapWidthPaddingInfo[d].bitsPerPixel)
+
+#define PixmapWidthInPadUnits(w, d) \
+    (PixmapWidthPaddingInfo[d].notPower2 ? \
+    (((int)(w) * PixmapWidthPaddingInfo[d].bytesPerPixel +  \
+	         PixmapWidthPaddingInfo[d].bytesPerPixel) >> \
+	PixmapWidthPaddingInfo[d].padBytesLog2) : \
+    ((int)((w) + PixmapWidthPaddingInfo[d].padRoundUp) >> \
+	PixmapWidthPaddingInfo[d].padPixelsLog2))
+
+/*
+ *	Return the number of bytes to which a scanline of the given
+ * depth and width will be padded.
+ */
+#define PixmapBytePad(w, d) \
+    (PixmapWidthInPadUnits(w, d) << PixmapWidthPaddingInfo[d].padBytesLog2)
+
+#define BitmapBytePad(w) \
+    (((int)((w) + BITMAP_SCANLINE_PAD - 1) >> LOG2_BITMAP_PAD) << LOG2_BYTES_PER_SCANLINE_PAD)
+
+#define PixmapWidthInPadUnitsProto(w, d) PixmapWidthInPadUnits(w, d)
+#define PixmapBytePadProto(w, d) PixmapBytePad(w, d)
+#define BitmapBytePadProto(w) BitmapBytePad(w)
+
+#endif                          /* SERVERMD_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/servermd.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxutil.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxutil.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxutil.h	(Revision 52145)
@@ -0,0 +1,51 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _glxcmds_h_
+#define _glxcmds_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+extern GLboolean __glXDrawableInit(__GLXdrawable * drawable,
+                                   __GLXscreen * screen,
+                                   DrawablePtr pDraw, int type, XID drawID,
+                                   __GLXconfig * config);
+extern void __glXDrawableRelease(__GLXdrawable * drawable);
+
+/* context helper routines */
+extern __GLXcontext *__glXLookupContextByTag(__GLXclientState *, GLXContextTag);
+
+/* init helper routines */
+extern void *__glXglDDXScreenInfo(void);
+extern void *__glXglDDXExtensionInfo(void);
+
+#endif                          /* _glxcmds_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxutil.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/validate.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/validate.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/validate.h	(Revision 52145)
@@ -0,0 +1,40 @@
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef VALIDATE_H
+#define VALIDATE_H
+
+#include "miscstruct.h"
+#include "regionstr.h"
+
+typedef enum { VTOther, VTStack, VTMove, VTUnmap, VTMap, VTBroken } VTKind;
+
+/* union _Validate is now device dependent; see mivalidate.h for an example */
+typedef union _Validate *ValidatePtr;
+
+#define UnmapValData ((ValidatePtr)1)
+
+#endif                          /* VALIDATE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/validate.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Xprintf.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Xprintf.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Xprintf.h	(Revision 52145)
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef XPRINTF_H
+#define XPRINTF_H
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <X11/Xfuncproto.h>
+
+#ifndef _X_RESTRICT_KYWD
+#if defined(restrict) /* assume autoconf set it correctly */ || \
+   (defined(__STDC__) && (__STDC_VERSION__ - 0 >= 199901L))     /* C99 */
+#define _X_RESTRICT_KYWD  restrict
+#elif defined(__GNUC__) && !defined(__STRICT_ANSI__)    /* gcc w/C89+extensions */
+#define _X_RESTRICT_KYWD __restrict__
+#else
+#define _X_RESTRICT_KYWD
+#endif
+#endif
+
+/*
+ * These functions provide a portable implementation of the common (but not
+ * yet universal) asprintf & vasprintf routines to allocate a buffer big
+ * enough to sprintf the arguments to.  The XNF variants terminate the server
+ * if the allocation fails.
+ * The buffer allocated is returned in the pointer provided in the first
+ * argument.   The return value is the size of the allocated buffer, or -1
+ * on failure.
+ */
+extern _X_EXPORT int
+Xasprintf(char **ret, const char *_X_RESTRICT_KYWD fmt, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT int
+Xvasprintf(char **ret, const char *_X_RESTRICT_KYWD fmt, va_list va)
+_X_ATTRIBUTE_PRINTF(2, 0);
+extern _X_EXPORT int
+XNFasprintf(char **ret, const char *_X_RESTRICT_KYWD fmt, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT int
+XNFvasprintf(char **ret, const char *_X_RESTRICT_KYWD fmt, va_list va)
+_X_ATTRIBUTE_PRINTF(2, 0);
+
+#if !defined(HAVE_ASPRINTF) && !defined(HAVE_VASPRINTF)
+#define asprintf  Xasprintf
+#define vasprintf Xvasprintf
+#endif
+
+/*
+ * These functions provide a portable implementation of the linux kernel
+ * scnprintf & vscnprintf routines that return the number of bytes actually
+ * copied during a snprintf, (excluding the final '\0').
+ */
+extern _X_EXPORT int
+Xscnprintf(char *s, int n, const char * _X_RESTRICT_KYWD fmt, ...)
+_X_ATTRIBUTE_PRINTF(3,4);
+extern _X_EXPORT int
+Xvscnprintf(char *s, int n, const char * _X_RESTRICT_KYWD fmt, va_list va)
+_X_ATTRIBUTE_PRINTF(3,0);
+
+#endif                          /* XPRINTF_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Xprintf.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sarea.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sarea.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sarea.h	(Revision 52145)
@@ -0,0 +1,96 @@
+/**
+ * \file sarea.h 
+ * SAREA definitions.
+ * 
+ * \author Kevin E. Martin <kevin@precisioninsight.com>
+ * \author Jens Owen <jens@tungstengraphics.com>
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+
+/*
+ * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _SAREA_H_
+#define _SAREA_H_
+
+#include "xf86drm.h"
+
+/* SAREA area needs to be at least a page */
+#if defined(__alpha__)
+#define SAREA_MAX 			0x2000
+#elif defined(__ia64__)
+#define SAREA_MAX			0x10000 /* 64kB */
+#else
+/* Intel 830M driver needs at least 8k SAREA */
+#define SAREA_MAX			0x2000
+#endif
+
+#define SAREA_MAX_DRAWABLES 		256
+
+#define SAREA_DRAWABLE_CLAIMED_ENTRY	0x80000000
+
+/**
+ * SAREA per drawable information.
+ *
+ * \sa _XF86DRISAREA.
+ */
+typedef struct _XF86DRISAREADrawable {
+    unsigned int stamp;
+    unsigned int flags;
+} XF86DRISAREADrawableRec, *XF86DRISAREADrawablePtr;
+
+/**
+ * SAREA frame information.
+ *
+ * \sa  _XF86DRISAREA.
+ */
+typedef struct _XF86DRISAREAFrame {
+    unsigned int x;
+    unsigned int y;
+    unsigned int width;
+    unsigned int height;
+    unsigned int fullscreen;
+} XF86DRISAREAFrameRec, *XF86DRISAREAFramePtr;
+
+/**
+ * SAREA definition.
+ */
+typedef struct _XF86DRISAREA {
+    /** first thing is always the DRM locking structure */
+    drmLock lock;
+    /** \todo Use readers/writer lock for drawable_lock */
+    drmLock drawable_lock;
+    XF86DRISAREADrawableRec drawableTable[SAREA_MAX_DRAWABLES];
+    XF86DRISAREAFrameRec frame;
+    drm_context_t dummy_context;
+} XF86DRISAREARec, *XF86DRISAREAPtr;
+
+typedef struct _XF86DRILSAREA {
+    drmLock lock;
+    drmLock otherLocks[31];
+} XF86DRILSAREARec, *XF86DRILSAREAPtr;
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sarea.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gtmotion.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gtmotion.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gtmotion.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GTMOTION_H
+#define GTMOTION_H 1
+
+int SProcXGetDeviceMotionEvents(ClientPtr       /* client */
+    );
+
+int ProcXGetDeviceMotionEvents(ClientPtr        /* client */
+    );
+
+void SRepXGetDeviceMotionEvents(ClientPtr /* client */ ,
+                                int /* size */ ,
+                                xGetDeviceMotionEventsReply *   /* rep */
+    );
+
+#endif                          /* GTMOTION_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gtmotion.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessConfig.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessConfig.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessConfig.h	(Revision 52145)
@@ -0,0 +1,62 @@
+/*
+ * Platform specific rootless configuration
+ */
+/*
+ * Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESSCONFIG_H
+#define _ROOTLESSCONFIG_H
+
+#ifdef __APPLE__
+
+#define ROOTLESS_PROTECT_ALPHA TRUE
+#define ROOTLESS_REDISPLAY_DELAY 10
+#define ROOTLESS_RESIZE_GRAVITY TRUE
+/*# define ROOTLESSDEBUG*/
+
+/* Bit mask for alpha channel with a particular number of bits per
+   pixel. Note that we only care for 32bpp data. Mac OS X uses planar
+   alpha for 16bpp. */
+#define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)
+
+#endif                          /* __APPLE__ */
+
+#if defined(__CYGWIN__) || defined(WIN32)
+
+#define ROOTLESS_PROTECT_ALPHA NO
+#define ROOTLESS_REDISPLAY_DELAY 10
+#undef  ROOTLESS_RESIZE_GRAVITY
+/*# define ROOTLESSDEBUG*/
+
+#define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)
+
+#endif                          /* __CYGWIN__ */
+
+#endif                          /* _ROOTLESSCONFIG_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessConfig.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/optionstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/optionstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/optionstr.h	(Revision 52145)
@@ -0,0 +1,13 @@
+#ifndef OPTIONSTR_H_
+#define OPTIONSTR_H_
+#include "list.h"
+
+struct _InputOption {
+    GenericListRec list;
+    char *opt_name;
+    char *opt_val;
+    int opt_used;
+    char *opt_comment;
+};
+
+#endif                          /* INPUTSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/optionstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_utils.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_utils.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_utils.h	(Revision 52145)
@@ -0,0 +1,1510 @@
+/*
+ * Copyright ¬© 2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhigang Gong <zhigang.gong@linux.intel.com>
+ *
+ */
+
+#ifndef GLAMOR_PRIV_H
+#error This file can only be included by glamor_priv.h
+#endif
+
+#ifndef __GLAMOR_UTILS_H__
+#define __GLAMOR_UTILS_H__
+
+#define v_from_x_coord_x(_xscale_, _x_)          ( 2 * (_x_) * (_xscale_) - 1.0)
+#define v_from_x_coord_y(_yscale_, _y_)          (-2 * (_y_) * (_yscale_) + 1.0)
+#define v_from_x_coord_y_inverted(_yscale_, _y_) (2 * (_y_) * (_yscale_) - 1.0)
+#define t_from_x_coord_x(_xscale_, _x_)          ((_x_) * (_xscale_))
+#define t_from_x_coord_y(_yscale_, _y_)          (1.0 - (_y_) * (_yscale_))
+#define t_from_x_coord_y_inverted(_yscale_, _y_) ((_y_) * (_yscale_))
+
+#define pixmap_priv_get_dest_scale(_pixmap_priv_, _pxscale_, _pyscale_)  \
+  do {                                                                   \
+    int _w_,_h_;                                                         \
+    PIXMAP_PRIV_GET_ACTUAL_SIZE(_pixmap_priv_, _w_, _h_);                \
+    *(_pxscale_) = 1.0 / _w_;                                            \
+    *(_pyscale_) = 1.0 / _h_;                                            \
+   } while(0)
+
+#define pixmap_priv_get_scale(_pixmap_priv_, _pxscale_, _pyscale_)	\
+   do {									\
+    *(_pxscale_) = 1.0 / (_pixmap_priv_)->base.fbo->width;			\
+    *(_pyscale_) = 1.0 / (_pixmap_priv_)->base.fbo->height;			\
+  } while(0)
+
+#define GLAMOR_PIXMAP_FBO_NOT_EXACT_SIZE(priv)			\
+   (priv->base.fbo->width != priv->base.pixmap->drawable.width 	\
+      || priv->base.fbo->height != priv->base.pixmap->drawable.height)	\
+
+#define PIXMAP_PRIV_GET_ACTUAL_SIZE(priv, w, h)			\
+  do {								\
+	if (_X_UNLIKELY(priv->type == GLAMOR_TEXTURE_LARGE)) {	\
+		w = priv->large.box.x2 - priv->large.box.x1;	\
+		h = priv->large.box.y2 - priv->large.box.y1;	\
+	} else {						\
+		w = priv->base.pixmap->drawable.width;		\
+		h = priv->base.pixmap->drawable.height;		\
+	}							\
+  } while(0)
+
+#define glamor_pixmap_fbo_fix_wh_ratio(wh, priv)  		\
+  do {								\
+	int actual_w, actual_h;					\
+	PIXMAP_PRIV_GET_ACTUAL_SIZE(priv, actual_w, actual_h);	\
+	wh[0] = (float)priv->base.fbo->width / actual_w;	\
+	wh[1] = (float)priv->base.fbo->height / actual_h;	\
+	wh[2] = 1.0 / priv->base.fbo->width;			\
+	wh[3] = 1.0 / priv->base.fbo->height;			\
+  } while(0)
+
+#define pixmap_priv_get_fbo_off(_priv_, _xoff_, _yoff_)		\
+   do {								\
+	if (_X_UNLIKELY(_priv_ && (_priv_)->type == GLAMOR_TEXTURE_LARGE)) {  \
+		*(_xoff_) = - (_priv_)->large.box.x1;	\
+		*(_yoff_) = - (_priv_)->large.box.y1;	\
+	} else {						\
+		*(_xoff_) = 0;					\
+		*(_yoff_) = 0;					\
+	}							\
+   } while(0)
+
+#define xFixedToFloat(_val_) ((float)xFixedToInt(_val_)			\
+			      + ((float)xFixedFrac(_val_) / 65536.0))
+
+#define glamor_picture_get_matrixf(_picture_, _matrix_)			\
+  do {									\
+    int _i_;								\
+    if ((_picture_)->transform)						\
+      {									\
+	for(_i_ = 0; _i_ < 3; _i_++)					\
+	  {								\
+	    (_matrix_)[_i_ * 3 + 0] =					\
+	      xFixedToFloat((_picture_)->transform->matrix[_i_][0]);	\
+	    (_matrix_)[_i_ * 3 + 1] =					\
+	      xFixedToFloat((_picture_)->transform->matrix[_i_][1]);	\
+	    (_matrix_)[_i_ * 3 + 2] = \
+	      xFixedToFloat((_picture_)->transform->matrix[_i_][2]);	\
+	  }								\
+      }									\
+  }  while(0)
+
+#define fmod(x, w)		(x - w * floor((float)x/w))
+
+#define fmodulus(x, w, c)	do {c = fmod(x, w);		\
+				    c = c >= 0 ? c : c + w;}	\
+				while(0)
+/* @x: is current coord
+ * @x2: is the right/bottom edge
+ * @w: is current width or height
+ * @odd: is output value, 0 means we are in an even region, 1 means we are in a
+ * odd region.
+ * @c: is output value, equal to x mod w. */
+#define fodd_repeat_mod(x, x2, w, odd, c)	\
+  do {						\
+	float shift;				\
+	fmodulus((x), w, c); 			\
+	shift = fabs((x) - (c));		\
+	shift = floor(fabs(round(shift)) / w);	\
+	odd = (int)shift & 1;			\
+	if (odd && (((x2 % w) == 0) &&		\
+	    round(fabs(x)) == x2))		\
+		odd = 0;			\
+  } while(0)
+
+/* @txy: output value, is the corrected coords.
+ * @xy: input coords to be fixed up.
+ * @cd: xy mod wh, is a input value.
+ * @wh: current width or height.
+ * @bxy1,bxy2: current box edge's x1/x2 or y1/y2
+ *
+ * case 1:
+ *  ----------
+ *  |  *     |
+ *  |        |
+ *  ----------
+ *  tx = (c - x1) mod w
+ *
+ *  case 2:
+ *     ---------
+ *  *  |       |
+ *     |       |
+ *     ---------
+ *   tx = - (c - (x1 mod w))
+ *
+ *   case 3:
+ *
+ *   ----------
+ *   |        |  *
+ *   |        |
+ *   ----------
+ *   tx = ((x2 mod x) - c) + (x2 - x1)
+ **/
+#define __glamor_repeat_reflect_fixup(txy, xy,		\
+				cd, wh, bxy1, bxy2)	\
+  do {							\
+	cd = wh - cd;					\
+	if ( xy >= bxy1 && xy < bxy2) {			\
+		cd = cd - bxy1;				\
+		fmodulus(cd, wh, txy);			\
+	} else	if (xy < bxy1) {			\
+		float bxy1_mod;				\
+		fmodulus(bxy1, wh, bxy1_mod);		\
+		txy = -(cd - bxy1_mod);			\
+	}						\
+	else if (xy >= bxy2)	{			\
+		float bxy2_mod;				\
+		fmodulus(bxy2, wh, bxy2_mod);		\
+		if (bxy2_mod == 0)			\
+			bxy2_mod = wh;			\
+		txy = (bxy2_mod - cd) + bxy2 - bxy1;	\
+	} else {assert(0); txy = 0;}			\
+  } while(0)
+
+#define _glamor_repeat_reflect_fixup(txy, xy, cd, odd,	\
+				     wh, bxy1, bxy2)	\
+  do {							\
+	if (odd) {					\
+		__glamor_repeat_reflect_fixup(txy, xy, 	\
+			cd, wh, bxy1, bxy2);		\
+	} else						\
+		txy = xy - bxy1;			\
+  } while(0)
+
+#define _glamor_get_reflect_transform_coords(priv, repeat_type,	\
+					    tx1, ty1, 		\
+				            _x1_, _y1_)		\
+  do {								\
+	int odd_x, odd_y;					\
+	float c, d;						\
+	fodd_repeat_mod(_x1_,priv->box.x2,			\
+		    priv->base.pixmap->drawable.width,		\
+		    odd_x, c);					\
+	fodd_repeat_mod(_y1_,	priv->box.y2,			\
+		    priv->base.pixmap->drawable.height,		\
+		    odd_y, d);					\
+	DEBUGF("c %f d %f oddx %d oddy %d \n",			\
+		c, d, odd_x, odd_y);				\
+	DEBUGF("x2 %d x1 %d fbo->width %d \n", priv->box.x2,	\
+		priv->box.x1, priv->base.fbo->width);		\
+	DEBUGF("y2 %d y1 %d fbo->height %d \n", priv->box.y2, 	\
+		priv->box.y1, priv->base.fbo->height);		\
+	_glamor_repeat_reflect_fixup(tx1, _x1_, c, odd_x,	\
+		priv->base.pixmap->drawable.width,		\
+		priv->box.x1, priv->box.x2);			\
+	_glamor_repeat_reflect_fixup(ty1, _y1_, d, odd_y,	\
+		priv->base.pixmap->drawable.height,		\
+		priv->box.y1, priv->box.y2);			\
+   } while(0)
+
+#define _glamor_get_repeat_coords(priv, repeat_type, tx1,	\
+				  ty1, tx2, ty2,		\
+				  _x1_, _y1_, _x2_,		\
+				  _y2_, c, d, odd_x, odd_y)	\
+  do {								\
+	if (repeat_type == RepeatReflect) {			\
+		DEBUGF("x1 y1 %d %d\n",				\
+			_x1_, _y1_ );				\
+		DEBUGF("width %d box.x1 %d \n",			\
+		       (priv)->base.pixmap->drawable.width,	\
+		       priv->box.x1);				\
+		if (odd_x) {					\
+			c = (priv)->base.pixmap->drawable.width	\
+				- c;				\
+			tx1 = c - priv->box.x1;			\
+			tx2 = tx1 - ((_x2_) - (_x1_));		\
+		} else {					\
+			tx1 = c - priv->box.x1;			\
+			tx2 = tx1 + ((_x2_) - (_x1_));		\
+		}						\
+		if (odd_y){					\
+			d = (priv)->base.pixmap->drawable.height\
+			    - d;				\
+			ty1 = d - priv->box.y1;			\
+			ty2 = ty1 - ((_y2_) - (_y1_));		\
+		} else {					\
+			ty1 = d - priv->box.y1;			\
+			ty2 = ty1 + ((_y2_) - (_y1_));		\
+		}						\
+	} else { /* RepeatNormal*/				\
+		tx1 = (c - priv->box.x1);  			\
+		ty1 = (d - priv->box.y1);			\
+		tx2 = tx1 + ((_x2_) - (_x1_));			\
+		ty2 = ty1 + ((_y2_) - (_y1_));			\
+	}							\
+   } while(0)
+
+/* _x1_ ... _y2_ may has fractional. */
+#define glamor_get_repeat_transform_coords(priv, repeat_type, tx1,	\
+					   ty1, _x1_, _y1_)		\
+  do {									\
+	DEBUGF("width %d box.x1 %d x2 %d y1 %d y2 %d\n",		\
+		(priv)->base.pixmap->drawable.width,			\
+		priv->box.x1, priv->box.x2, priv->box.y1,		\
+		priv->box.y2);						\
+	DEBUGF("x1 %f y1 %f \n", _x1_, _y1_);				\
+	if (repeat_type != RepeatReflect) {				\
+		tx1 = _x1_ - priv->box.x1;				\
+		ty1 = _y1_ - priv->box.y1;				\
+	} else			\
+		_glamor_get_reflect_transform_coords(priv, repeat_type, \
+				  tx1, ty1, 				\
+				  _x1_, _y1_);				\
+	DEBUGF("tx1 %f ty1 %f \n", tx1, ty1);				\
+   } while(0)
+
+/* _x1_ ... _y2_ must be integer. */
+#define glamor_get_repeat_coords(priv, repeat_type, tx1,		\
+				 ty1, tx2, ty2, _x1_, _y1_, _x2_,	\
+				 _y2_) 					\
+  do {									\
+	int c, d;							\
+	int odd_x = 0, odd_y = 0;					\
+	DEBUGF("width %d box.x1 %d x2 %d y1 %d y2 %d\n",		\
+		(priv)->base.pixmap->drawable.width,			\
+		priv->box.x1, priv->box.x2,				\
+		priv->box.y1, priv->box.y2);				\
+	modulus((_x1_), (priv)->base.pixmap->drawable.width, c); 	\
+	modulus((_y1_), (priv)->base.pixmap->drawable.height, d);	\
+	DEBUGF("c %d d %d \n", c, d);					\
+	if (repeat_type == RepeatReflect) {				\
+		odd_x = abs((_x1_ - c)					\
+			/ (priv->base.pixmap->drawable.width)) & 1;	\
+		odd_y = abs((_y1_ - d)					\
+			/ (priv->base.pixmap->drawable.height)) & 1;	\
+	}								\
+	_glamor_get_repeat_coords(priv, repeat_type, tx1, ty1, tx2, ty2,\
+				  _x1_, _y1_, _x2_, _y2_, c, d,		\
+				  odd_x, odd_y);			\
+   } while(0)
+
+#define glamor_transform_point(matrix, tx, ty, x, y)			\
+  do {									\
+    int _i_;								\
+    float _result_[4];							\
+    for (_i_ = 0; _i_ < 3; _i_++) {					\
+      _result_[_i_] = (matrix)[_i_ * 3] * (x) + (matrix)[_i_ * 3 + 1] * (y)	\
+	+ (matrix)[_i_ * 3 + 2];					\
+    }									\
+    tx = _result_[0] / _result_[2];					\
+    ty = _result_[1] / _result_[2];					\
+  } while(0)
+
+#define _glamor_set_normalize_tpoint(xscale, yscale, _tx_, _ty_,	\
+				     texcoord, yInverted)		\
+  do {									\
+	(texcoord)[0] = t_from_x_coord_x(xscale, _tx_);			\
+	if (_X_LIKELY(yInverted))					\
+		(texcoord)[1] = t_from_x_coord_y_inverted(yscale, _ty_);\
+	else								\
+		(texcoord)[1] = t_from_x_coord_y(yscale, _ty_);		\
+        DEBUGF("normalized point tx %f ty %f \n", (texcoord)[0],	\
+		(texcoord)[1]);						\
+  } while(0)
+
+#define glamor_set_transformed_point(priv, matrix, xscale,		\
+				     yscale, texcoord,			\
+                                     x, y, 				\
+				     yInverted)				\
+  do {									\
+    float tx, ty;							\
+    int fbo_x_off, fbo_y_off;						\
+    pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+    glamor_transform_point(matrix, tx, ty, x, y);			\
+    DEBUGF("tx %f ty %f fbooff %d %d \n",				\
+	    tx, ty, fbo_x_off, fbo_y_off);				\
+									\
+    tx += fbo_x_off;							\
+    ty += fbo_y_off;							\
+    (texcoord)[0] = t_from_x_coord_x(xscale, tx);			\
+    if (_X_LIKELY(yInverted))						\
+      (texcoord)[1] = t_from_x_coord_y_inverted(yscale, ty);		\
+    else								\
+      (texcoord)[1] = t_from_x_coord_y(yscale, ty);			\
+    DEBUGF("normalized tx %f ty %f \n", (texcoord)[0], (texcoord)[1]);	\
+  } while(0)
+
+#define glamor_set_transformed_normalize_tri_tcoords(priv,		\
+						     matrix,		\
+						     xscale,		\
+						     yscale,		\
+						     vtx,		\
+						     yInverted,		\
+						     texcoords)		\
+    do {								\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords, (vtx)[0], (vtx)[1],	\
+				     yInverted);			\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords+2, (vtx)[2], (vtx)[3],	\
+				     yInverted);			\
+	glamor_set_transformed_point(priv, matrix, xscale, yscale,	\
+				     texcoords+4, (vtx)[4], (vtx)[5],	\
+				     yInverted);			\
+    } while (0)
+
+#define glamor_set_transformed_normalize_tcoords_ext( priv,		\
+						  matrix,		\
+						  xscale,		\
+						  yscale,		\
+                                                  tx1, ty1, tx2, ty2,   \
+                                                  yInverted, texcoords,	\
+						  stride)		\
+  do {									\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords, tx1, ty1,			\
+				 yInverted);				\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 1 * stride, tx2, ty1,	\
+				 yInverted);				\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 2 * stride, tx2, ty2,	\
+				 yInverted);				\
+    glamor_set_transformed_point(priv, matrix, xscale, yscale,		\
+				 texcoords + 3 * stride, tx1, ty2,	\
+				 yInverted);				\
+  } while (0)
+
+#define glamor_set_transformed_normalize_tcoords( priv,			\
+						  matrix,		\
+						  xscale,		\
+						  yscale,		\
+                                                  tx1, ty1, tx2, ty2,   \
+                                                  yInverted, texcoords)	\
+  do {									\
+	glamor_set_transformed_normalize_tcoords_ext( priv,		\
+						  matrix,		\
+						  xscale,		\
+						  yscale,		\
+                                                  tx1, ty1, tx2, ty2,   \
+                                                  yInverted, texcoords,	\
+						  2);			\
+  } while (0)
+
+#define glamor_set_normalize_tri_tcoords(xscale,		\
+					 yscale,		\
+					 vtx,			\
+					 yInverted,		\
+					 texcoords)		\
+    do {							\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[0], (vtx)[1],		\
+				texcoords,			\
+				yInverted);			\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[2], (vtx)[3],		\
+				texcoords+2,			\
+				yInverted);			\
+	_glamor_set_normalize_tpoint(xscale, yscale,		\
+				(vtx)[4], (vtx)[5],		\
+				texcoords+4,			\
+				yInverted);			\
+    } while (0)
+
+#define glamor_set_repeat_transformed_normalize_tcoords_ext( priv,	\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords,	\
+							 stride)	\
+  do {									\
+    if (_X_LIKELY(priv->type != GLAMOR_TEXTURE_LARGE)) {		\
+	glamor_set_transformed_normalize_tcoords_ext(priv, matrix, xscale,	\
+						 yscale, _x1_, _y1_,	\
+						 _x2_, _y2_, yInverted,	\
+						 texcoords, stride);	\
+    } else {								\
+    float tx1, ty1, tx2, ty2, tx3, ty3, tx4, ty4;			\
+    float ttx1, tty1, ttx2, tty2, ttx3, tty3, ttx4, tty4;		\
+    DEBUGF("original coords %d %d %d %d\n", _x1_, _y1_, _x2_, _y2_);	\
+    glamor_transform_point(matrix, tx1, ty1, _x1_, _y1_);		\
+    glamor_transform_point(matrix, tx2, ty2, _x2_, _y1_);		\
+    glamor_transform_point(matrix, tx3, ty3, _x2_, _y2_);		\
+    glamor_transform_point(matrix, tx4, ty4, _x1_, _y2_);		\
+    DEBUGF("transformed %f %f %f %f %f %f %f %f\n",			\
+	   tx1, ty1, tx2, ty2, tx3, ty3, tx4, ty4);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx1, tty1, 			\
+				       tx1, ty1);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx2, tty2, 			\
+				       tx2, ty2);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx3, tty3, 			\
+				       tx3, ty3);			\
+    glamor_get_repeat_transform_coords((&priv->large), repeat_type, 	\
+				       ttx4, tty4, 			\
+				       tx4, ty4);			\
+    DEBUGF("repeat transformed %f %f %f %f %f %f %f %f\n", ttx1, tty1, 	\
+	    ttx2, tty2,	ttx3, tty3, ttx4, tty4);			\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx1, tty1,		\
+				 texcoords, yInverted);			\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx2, tty2,		\
+				 texcoords + 1 * stride, yInverted);	\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx3, tty3,		\
+				 texcoords + 2 * stride, yInverted);	\
+    _glamor_set_normalize_tpoint(xscale, yscale, ttx4, tty4,		\
+				 texcoords + 3 * stride, yInverted);	\
+   }									\
+  } while (0)
+
+#define glamor_set_repeat_transformed_normalize_tcoords( priv,		\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords)	\
+  do {									\
+	glamor_set_repeat_transformed_normalize_tcoords_ext( priv,	\
+							 repeat_type,	\
+							 matrix,	\
+							 xscale,	\
+							 yscale,	\
+							 _x1_, _y1_,	\
+							 _x2_, _y2_,   	\
+							 yInverted,	\
+							 texcoords,	\
+							 2);	\
+  } while (0)
+
+#define _glamor_set_normalize_tcoords(xscale, yscale, tx1,		\
+				      ty1, tx2, ty2,			\
+				      yInverted, vertices, stride)	\
+  do {									\
+    /* vertices may be write-only, so we use following			\
+     * temporary variable. */ 						\
+    float _t0_, _t1_, _t2_, _t5_;					\
+    (vertices)[0] = _t0_ = t_from_x_coord_x(xscale, tx1);		\
+    (vertices)[1 * stride] = _t2_ = t_from_x_coord_x(xscale, tx2);	\
+    (vertices)[2 * stride] = _t2_;					\
+    (vertices)[3 * stride] = _t0_;					\
+    if (_X_LIKELY(yInverted)) {						\
+      (vertices)[1] = _t1_ = t_from_x_coord_y_inverted(yscale, ty1);	\
+      (vertices)[2 * stride + 1] = _t5_ = t_from_x_coord_y_inverted(yscale, ty2);\
+    }									\
+    else {								\
+      (vertices)[1] = _t1_ = t_from_x_coord_y(yscale, ty1);		\
+      (vertices)[2 * stride + 1] = _t5_ = t_from_x_coord_y(yscale, ty2);\
+    }									\
+    (vertices)[1 * stride + 1] = _t1_;					\
+    (vertices)[3 * stride + 1] = _t5_;					\
+  } while(0)
+
+#define glamor_set_normalize_tcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, stride)	\
+  do {									\
+     if (_X_UNLIKELY(priv->type == GLAMOR_TEXTURE_LARGE)) {		\
+	float tx1, tx2, ty1, ty2;					\
+	int fbo_x_off, fbo_y_off;					\
+	pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+	tx1 = x1 + fbo_x_off; 						\
+	tx2 = x2 + fbo_x_off;						\
+	ty1 = y1 + fbo_y_off;						\
+	ty2 = y2 + fbo_y_off;						\
+	_glamor_set_normalize_tcoords(xscale, yscale, tx1, ty1,		\
+				   tx2, ty2, yInverted, vertices,	\
+				   stride);				\
+     } else								\
+	_glamor_set_normalize_tcoords(xscale, yscale, x1, y1,		\
+				   x2, y2, yInverted, vertices, stride);\
+ } while(0)
+
+#define glamor_set_normalize_tcoords(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices)		\
+  do {									\
+	glamor_set_normalize_tcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, 2);		\
+ } while(0)
+
+#define glamor_set_repeat_normalize_tcoords_ext(priv, repeat_type,	\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices, stride)\
+  do {									\
+     if (_X_UNLIKELY(priv->type == GLAMOR_TEXTURE_LARGE)) {		\
+	float tx1, tx2, ty1, ty2;					\
+	if (repeat_type == RepeatPad) {					\
+		tx1 = _x1_ - priv->large.box.x1;			\
+		ty1 = _y1_ - priv->large.box.y1;			\
+		tx2 = tx1 + ((_x2_) - (_x1_));				\
+		ty2 = ty1 + ((_y2_) - (_y1_));				\
+	} else {							\
+	glamor_get_repeat_coords((&priv->large), repeat_type,		\
+				 tx1, ty1, tx2, ty2,			\
+				 _x1_, _y1_, _x2_, _y2_);		\
+	}								\
+	_glamor_set_normalize_tcoords(xscale, yscale, tx1, ty1,		\
+				   tx2, ty2, yInverted, vertices,	\
+				   stride);				\
+     } else								\
+	_glamor_set_normalize_tcoords(xscale, yscale, _x1_, _y1_,	\
+				   _x2_, _y2_, yInverted, vertices,	\
+				   stride);				\
+ } while(0)
+
+#define glamor_set_repeat_normalize_tcoords(priv, repeat_type,		\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices)	\
+  do {									\
+	glamor_set_repeat_normalize_tcoords_ext(priv, repeat_type,	\
+					    xscale, yscale,		\
+					    _x1_, _y1_, _x2_, _y2_,	\
+	                                    yInverted, vertices, 2);	\
+ } while(0)
+
+#define glamor_set_normalize_tcoords_tri_stripe(xscale, yscale,		\
+						x1, y1, x2, y2,		\
+						yInverted, vertices)	\
+    do {								\
+	(vertices)[0] = t_from_x_coord_x(xscale, x1);			\
+	(vertices)[2] = t_from_x_coord_x(xscale, x2);			\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (_X_LIKELY(yInverted)) {					\
+	    (vertices)[1] = t_from_x_coord_y_inverted(yscale, y1);	\
+	    (vertices)[7] = t_from_x_coord_y_inverted(yscale, y2);	\
+	}								\
+	else {								\
+	    (vertices)[1] = t_from_x_coord_y(yscale, y1);		\
+	    (vertices)[7] = t_from_x_coord_y(yscale, y2);		\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
+    } while(0)
+
+#define glamor_set_tcoords(width, height, x1, y1, x2, y2,	\
+			   yInverted, vertices)			\
+    do {							\
+	(vertices)[0] = (x1);					\
+	(vertices)[2] = (x2);					\
+	(vertices)[4] = (vertices)[2];				\
+	(vertices)[6] = (vertices)[0];				\
+	if (_X_LIKELY(yInverted)) {				\
+	    (vertices)[1] = (y1);				\
+	    (vertices)[5] = (y2);				\
+	}							\
+	else {							\
+	    (vertices)[1] = height - (y2);			\
+	    (vertices)[5] = height - (y1);			\
+	}							\
+	(vertices)[3] = (vertices)[1];				\
+	(vertices)[7] = (vertices)[5];				\
+    } while(0)
+
+#define glamor_set_tcoords_ext(width, height, x1, y1, x2, y2,	\
+			       yInverted, vertices, stride)	\
+    do {							\
+	(vertices)[0] = (x1);					\
+	(vertices)[1*stride] = (x2);				\
+	(vertices)[2*stride] = (vertices)[1*stride];		\
+	(vertices)[3*stride] = (vertices)[0];			\
+	if (_X_LIKELY(yInverted)) {				\
+	    (vertices)[1] = (y1);				\
+	    (vertices)[2*stride + 1] = (y2);			\
+	}							\
+	else {							\
+	    (vertices)[1] = height - (y2);			\
+	    (vertices)[2*stride + 1] = height - (y1);		\
+	}							\
+	(vertices)[1*stride + 1] = (vertices)[1];		\
+	(vertices)[3*stride + 1] = (vertices)[2*stride + 1];	\
+    } while(0)
+
+#define glamor_set_normalize_one_vcoord(xscale, yscale, x, y,		\
+					yInverted, vertices)		\
+    do {								\
+	(vertices)[0] = v_from_x_coord_x(xscale, x);			\
+	if (_X_LIKELY(yInverted)) {					\
+	    (vertices)[1] = v_from_x_coord_y_inverted(yscale, y);	\
+	} else {							\
+	    (vertices)[1] = v_from_x_coord_y(yscale, y);		\
+	}								\
+    } while(0)
+
+#define glamor_set_normalize_tri_vcoords(xscale, yscale, vtx,		\
+					 yInverted, vertices)		\
+    do {								\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[0], (vtx)[1],		\
+					yInverted, vertices);		\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[2], (vtx)[3],		\
+					yInverted, vertices+2);		\
+	glamor_set_normalize_one_vcoord(xscale, yscale,			\
+					(vtx)[4], (vtx)[5],		\
+					yInverted, vertices+4);		\
+    } while(0)
+
+#define glamor_set_tcoords_tri_strip(width, height, x1, y1, x2, y2,	\
+				     yInverted, vertices)		\
+    do {								\
+	(vertices)[0] = (x1);						\
+	(vertices)[2] = (x2);						\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (_X_LIKELY(yInverted)) {	    				\
+	    (vertices)[1] = (y1);					\
+	    (vertices)[7] = (y2);					\
+	}								\
+	else {								\
+	    (vertices)[1] = height - (y2);				\
+	    (vertices)[7] = height - (y1);				\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
+    } while(0)
+
+#define glamor_set_normalize_vcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, stride)	\
+  do {									\
+    int fbo_x_off, fbo_y_off;						\
+    /* vertices may be write-only, so we use following			\
+     * temporary variable. */						\
+    float _t0_, _t1_, _t2_, _t5_;					\
+    pixmap_priv_get_fbo_off(priv, &fbo_x_off, &fbo_y_off);		\
+    (vertices)[0] = _t0_ = v_from_x_coord_x(xscale, x1 + fbo_x_off);	\
+    (vertices)[1 * stride] = _t2_ = v_from_x_coord_x(xscale,		\
+					x2 + fbo_x_off);		\
+    (vertices)[2 * stride] = _t2_;					\
+    (vertices)[3 * stride] = _t0_;					\
+    if (_X_LIKELY(yInverted)) {						\
+      (vertices)[1] = _t1_ = v_from_x_coord_y_inverted(yscale,		\
+				y1 + fbo_y_off);			\
+      (vertices)[2 * stride + 1] = _t5_ =				\
+			v_from_x_coord_y_inverted(yscale,		\
+					y2 + fbo_y_off);		\
+    }									\
+    else {								\
+      (vertices)[1] = _t1_ = v_from_x_coord_y(yscale, y1 + fbo_y_off);	\
+      (vertices)[2 * stride + 1] = _t5_ = v_from_x_coord_y(yscale,	\
+					y2 + fbo_y_off);		\
+    }									\
+    (vertices)[1 * stride + 1] = _t1_;					\
+    (vertices)[3 * stride + 1] = _t5_;					\
+  } while(0)
+
+#define glamor_set_normalize_vcoords(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices)		\
+  do {									\
+	glamor_set_normalize_vcoords_ext(priv, xscale, yscale,		\
+				     x1, y1, x2, y2,			\
+                                     yInverted, vertices, 2);		\
+  } while(0)
+
+#define glamor_set_const_ext(params, nparam, vertices, nverts, stride)	\
+    do {								\
+	int _i_ = 0, _j_ = 0;						\
+	for(; _i_ < nverts; _i_++) {					\
+	    for(_j_ = 0; _j_ < nparam; _j_++) {				\
+		vertices[stride*_i_ + _j_] = params[_j_];		\
+	    }								\
+	}								\
+    } while(0)
+
+#define glamor_set_normalize_vcoords_tri_strip(xscale, yscale,		\
+					       x1, y1, x2, y2,		\
+					       yInverted, vertices)	\
+    do {								\
+	(vertices)[0] = v_from_x_coord_x(xscale, x1);			\
+	(vertices)[2] = v_from_x_coord_x(xscale, x2);			\
+	(vertices)[6] = (vertices)[2];					\
+	(vertices)[4] = (vertices)[0];					\
+	if (_X_LIKELY(yInverted)) {	    				\
+	    (vertices)[1] = v_from_x_coord_y_inverted(yscale, y1);	\
+	    (vertices)[7] = v_from_x_coord_y_inverted(yscale, y2);	\
+	}								\
+	else {								\
+	    (vertices)[1] = v_from_x_coord_y(yscale, y1);		\
+	    (vertices)[7] = v_from_x_coord_y(yscale, y2);		\
+	}								\
+	(vertices)[3] = (vertices)[1];					\
+	(vertices)[5] = (vertices)[7];					\
+    } while(0)
+
+#define glamor_set_normalize_pt(xscale, yscale, x, y,		\
+                                yInverted, pt)			\
+    do {							\
+        (pt)[0] = t_from_x_coord_x(xscale, x);			\
+        if (_X_LIKELY(yInverted)) {				\
+            (pt)[1] = t_from_x_coord_y_inverted(yscale, y);	\
+        } else {						\
+            (pt)[1] = t_from_x_coord_y(yscale, y);		\
+        }							\
+    } while(0)
+
+#define glamor_set_circle_centre(width, height, x, y,	\
+				 yInverted, c)		\
+    do {						\
+        (c)[0] = (float)x;				\
+        if (_X_LIKELY(yInverted)) {	    		\
+            (c)[1] = (float)y;				\
+        } else {					\
+            (c)[1] = (float)height - (float)y;		\
+        }						\
+    } while(0)
+
+inline static void
+glamor_calculate_boxes_bound(BoxPtr bound, BoxPtr boxes, int nbox)
+{
+    int x_min, y_min;
+    int x_max, y_max;
+    int i;
+
+    x_min = y_min = MAXSHORT;
+    x_max = y_max = MINSHORT;
+    for (i = 0; i < nbox; i++) {
+        if (x_min > boxes[i].x1)
+            x_min = boxes[i].x1;
+        if (y_min > boxes[i].y1)
+            y_min = boxes[i].y1;
+
+        if (x_max < boxes[i].x2)
+            x_max = boxes[i].x2;
+        if (y_max < boxes[i].y2)
+            y_max = boxes[i].y2;
+    }
+    bound->x1 = x_min;
+    bound->y1 = y_min;
+    bound->x2 = x_max;
+    bound->y2 = y_max;
+}
+
+inline static void
+glamor_translate_boxes(BoxPtr boxes, int nbox, int dx, int dy)
+{
+    int i;
+
+    for (i = 0; i < nbox; i++) {
+        boxes[i].x1 += dx;
+        boxes[i].y1 += dy;
+        boxes[i].x2 += dx;
+        boxes[i].y2 += dy;
+    }
+}
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
+#endif
+
+#define ALIGN(i,m)	(((i) + (m) - 1) & ~((m) - 1))
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+#define MAX(a,b)	((a) > (b) ? (a) : (b))
+
+#define glamor_check_fbo_size(_glamor_,_w_, _h_)    ((_w_) > 0 && (_h_) > 0 \
+                                                    && (_w_) <= _glamor_->max_fbo_size  \
+                                                    && (_h_) <= _glamor_->max_fbo_size)
+
+/* For 1bpp pixmap, we don't store it as texture. */
+#define glamor_check_pixmap_fbo_depth(_depth_) (			\
+						_depth_ == 8		\
+						|| _depth_ == 15	\
+						|| _depth_ == 16	\
+						|| _depth_ == 24	\
+						|| _depth_ == 30	\
+						|| _depth_ == 32)
+
+#define GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv) (pixmap_priv && pixmap_priv->base.is_picture == 1)
+#define GLAMOR_PIXMAP_PRIV_HAS_FBO(pixmap_priv)    (pixmap_priv && pixmap_priv->base.gl_fbo == GLAMOR_FBO_NORMAL)
+#define GLAMOR_PIXMAP_PRIV_HAS_FBO_DOWNLOADED(pixmap_priv)    (pixmap_priv && (pixmap_priv->base.gl_fbo == GLAMOR_FBO_DOWNLOADED))
+
+/**
+ * Borrow from uxa.
+ */
+static inline CARD32
+format_for_depth(int depth)
+{
+    switch (depth) {
+    case 1:
+        return PICT_a1;
+    case 4:
+        return PICT_a4;
+    case 8:
+        return PICT_a8;
+    case 15:
+        return PICT_x1r5g5b5;
+    case 16:
+        return PICT_r5g6b5;
+    default:
+    case 24:
+        return PICT_x8r8g8b8;
+#if XORG_VERSION_CURRENT >= 10699900
+    case 30:
+        return PICT_x2r10g10b10;
+#endif
+    case 32:
+        return PICT_a8r8g8b8;
+    }
+}
+
+static inline GLenum
+gl_iformat_for_pixmap(PixmapPtr pixmap)
+{
+    glamor_screen_private *glamor_priv =
+        glamor_get_screen_private(pixmap->drawable.pScreen);
+
+    if (glamor_priv->gl_flavor == GLAMOR_GL_DESKTOP &&
+        (pixmap->drawable.depth == 1 || pixmap->drawable.depth == 8)) {
+        return GL_ALPHA;
+    } else {
+        return GL_RGBA;
+    }
+}
+
+static inline CARD32
+format_for_pixmap(PixmapPtr pixmap)
+{
+    glamor_pixmap_private *pixmap_priv;
+    PictFormatShort pict_format;
+
+    pixmap_priv = glamor_get_pixmap_private(pixmap);
+    if (GLAMOR_PIXMAP_PRIV_IS_PICTURE(pixmap_priv))
+        pict_format = pixmap_priv->base.picture->format;
+    else
+        pict_format = format_for_depth(pixmap->drawable.depth);
+
+    return pict_format;
+}
+
+#define REVERT_NONE       		0
+#define REVERT_NORMAL     		1
+#define REVERT_DOWNLOADING_A1		2
+#define REVERT_UPLOADING_A1		3
+#define REVERT_DOWNLOADING_2_10_10_10 	4
+#define REVERT_UPLOADING_2_10_10_10 	5
+#define REVERT_DOWNLOADING_1_5_5_5  	7
+#define REVERT_UPLOADING_1_5_5_5    	8
+#define REVERT_DOWNLOADING_10_10_10_2 	9
+#define REVERT_UPLOADING_10_10_10_2 	10
+
+#define SWAP_NONE_DOWNLOADING  	0
+#define SWAP_DOWNLOADING  	1
+#define SWAP_UPLOADING	  	2
+#define SWAP_NONE_UPLOADING	3
+
+inline static int
+cache_format(GLenum format)
+{
+    switch (format) {
+    case GL_ALPHA:
+        return 2;
+    case GL_RGB:
+        return 1;
+    case GL_RGBA:
+        return 0;
+    default:
+        return -1;
+    }
+}
+
+/* borrowed from uxa */
+static inline Bool
+glamor_get_rgba_from_pixel(CARD32 pixel,
+                           float *red,
+                           float *green,
+                           float *blue, float *alpha, CARD32 format)
+{
+    int rbits, bbits, gbits, abits;
+    int rshift, bshift, gshift, ashift;
+
+    rbits = PICT_FORMAT_R(format);
+    gbits = PICT_FORMAT_G(format);
+    bbits = PICT_FORMAT_B(format);
+    abits = PICT_FORMAT_A(format);
+
+    if (PICT_FORMAT_TYPE(format) == PICT_TYPE_A) {
+        rshift = gshift = bshift = ashift = 0;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
+        bshift = 0;
+        gshift = bbits;
+        rshift = gshift + gbits;
+        ashift = rshift + rbits;
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ABGR) {
+        rshift = 0;
+        gshift = rbits;
+        bshift = gshift + gbits;
+        ashift = bshift + bbits;
+#if XORG_VERSION_CURRENT >= 10699900
+    }
+    else if (PICT_FORMAT_TYPE(format) == PICT_TYPE_BGRA) {
+        ashift = 0;
+        rshift = abits;
+        if (abits == 0)
+            rshift = PICT_FORMAT_BPP(format) - (rbits + gbits + bbits);
+        gshift = rshift + rbits;
+        bshift = gshift + gbits;
+#endif
+    }
+    else {
+        return FALSE;
+    }
+#define COLOR_INT_TO_FLOAT(_fc_, _p_, _s_, _bits_)	\
+  *_fc_ = (((_p_) >> (_s_)) & (( 1 << (_bits_)) - 1))	\
+    / (float)((1<<(_bits_)) - 1)
+
+    if (rbits)
+        COLOR_INT_TO_FLOAT(red, pixel, rshift, rbits);
+    else
+        *red = 0;
+
+    if (gbits)
+        COLOR_INT_TO_FLOAT(green, pixel, gshift, gbits);
+    else
+        *green = 0;
+
+    if (bbits)
+        COLOR_INT_TO_FLOAT(blue, pixel, bshift, bbits);
+    else
+        *blue = 0;
+
+    if (abits)
+        COLOR_INT_TO_FLOAT(alpha, pixel, ashift, abits);
+    else
+        *alpha = 1;
+
+    return TRUE;
+}
+
+inline static Bool
+glamor_pict_format_is_compatible(PicturePtr picture)
+{
+    GLenum iformat;
+    PixmapPtr pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
+
+    iformat = gl_iformat_for_pixmap(pixmap);
+    switch (iformat) {
+    case GL_RGBA:
+        return (picture->format == PICT_a8r8g8b8 ||
+                picture->format == PICT_x8r8g8b8);
+    case GL_ALPHA:
+        return (picture->format == PICT_a8);
+    default:
+        return FALSE;
+    }
+}
+
+/* return TRUE if we can access this pixmap at DDX driver. */
+inline static Bool
+glamor_ddx_fallback_check_pixmap(DrawablePtr drawable)
+{
+    PixmapPtr pixmap = glamor_get_drawable_pixmap(drawable);
+    glamor_pixmap_private *pixmap_priv = glamor_get_pixmap_private(pixmap);
+
+    return (!pixmap_priv
+            || (pixmap_priv->type == GLAMOR_TEXTURE_DRM
+                || pixmap_priv->type == GLAMOR_MEMORY
+                || pixmap_priv->type == GLAMOR_DRM_ONLY));
+}
+
+inline static Bool
+glamor_ddx_fallback_check_gc(GCPtr gc)
+{
+    PixmapPtr pixmap;
+
+    if (!gc)
+        return TRUE;
+    switch (gc->fillStyle) {
+    case FillStippled:
+    case FillOpaqueStippled:
+        pixmap = gc->stipple;
+        break;
+    case FillTiled:
+        pixmap = gc->tile.pixmap;
+        break;
+    default:
+        pixmap = NULL;
+    }
+    return (!pixmap || glamor_ddx_fallback_check_pixmap(&pixmap->drawable));
+}
+
+inline static Bool
+glamor_is_large_pixmap(PixmapPtr pixmap)
+{
+    glamor_pixmap_private *priv;
+
+    priv = glamor_get_pixmap_private(pixmap);
+    return (priv->type == GLAMOR_TEXTURE_LARGE);
+}
+
+inline static Bool
+glamor_is_large_picture(PicturePtr picture)
+{
+    PixmapPtr pixmap;
+
+    if (picture->pDrawable) {
+        pixmap = glamor_get_drawable_pixmap(picture->pDrawable);
+        return glamor_is_large_pixmap(pixmap);
+    }
+    return FALSE;
+}
+
+inline static Bool
+glamor_tex_format_is_readable(GLenum format)
+{
+    return ((format == GL_RGBA || format == GL_RGB || format == GL_ALPHA));
+
+}
+
+static inline void
+_glamor_dump_pixmap_bits(PixmapPtr pixmap, int x, int y, int w, int h)
+{
+    int i, j;
+    unsigned char *p = pixmap->devPrivate.ptr;
+    int stride = pixmap->devKind;
+
+    p = p + y * stride + x;
+
+    for (i = 0; i < h; i++) {
+        ErrorF("line %3d: ", i);
+        for (j = 0; j < w; j++)
+            ErrorF("%2d ", (p[j / 8] & (1 << (j % 8))) >> (j % 8));
+        p += stride;
+        ErrorF("\n");
+    }
+}
+
+static inline void
+_glamor_dump_pixmap_byte(PixmapPtr pixmap, int x, int y, int w, int h)
+{
+    int i, j;
+    unsigned char *p = pixmap->devPrivate.ptr;
+    int stride = pixmap->devKind;
+
+    p = p + y * stride + x;
+
+    for (i = 0; i < h; i++) {
+        ErrorF("line %3d: ", i);
+        for (j = 0; j < w; j++)
+            ErrorF("%2x ", p[j]);
+        p += stride;
+        ErrorF("\n");
+    }
+}
+
+static inline void
+_glamor_dump_pixmap_sword(PixmapPtr pixmap, int x, int y, int w, int h)
+{
+    int i, j;
+    unsigned short *p = pixmap->devPrivate.ptr;
+    int stride = pixmap->devKind / 2;
+
+    p = p + y * stride + x;
+
+    for (i = 0; i < h; i++) {
+        ErrorF("line %3d: ", i);
+        for (j = 0; j < w; j++)
+            ErrorF("%2x ", p[j]);
+        p += stride;
+        ErrorF("\n");
+    }
+}
+
+static inline void
+_glamor_dump_pixmap_word(PixmapPtr pixmap, int x, int y, int w, int h)
+{
+    int i, j;
+    unsigned int *p = pixmap->devPrivate.ptr;
+    int stride = pixmap->devKind / 4;
+
+    p = p + y * stride + x;
+
+    for (i = 0; i < h; i++) {
+        ErrorF("line %3d: ", i);
+        for (j = 0; j < w; j++)
+            ErrorF("%2x ", p[j]);
+        p += stride;
+        ErrorF("\n");
+    }
+}
+
+static inline void
+glamor_dump_pixmap(PixmapPtr pixmap, int x, int y, int w, int h)
+{
+    w = ((x + w) > pixmap->drawable.width) ? (pixmap->drawable.width - x) : w;
+    h = ((y + h) > pixmap->drawable.height) ? (pixmap->drawable.height - y) : h;
+
+    glamor_prepare_access(&pixmap->drawable, GLAMOR_ACCESS_RO);
+    switch (pixmap->drawable.depth) {
+    case 8:
+        _glamor_dump_pixmap_byte(pixmap, x, y, w, h);
+        break;
+    case 15:
+    case 16:
+        _glamor_dump_pixmap_sword(pixmap, x, y, w, h);
+        break;
+
+    case 24:
+    case 32:
+        _glamor_dump_pixmap_word(pixmap, x, y, w, h);
+        break;
+    case 1:
+        _glamor_dump_pixmap_bits(pixmap, x, y, w, h);
+        break;
+    default:
+        ErrorF("dump depth %d, not implemented.\n", pixmap->drawable.depth);
+    }
+    glamor_finish_access(&pixmap->drawable);
+}
+
+static inline void
+_glamor_compare_pixmaps(PixmapPtr pixmap1, PixmapPtr pixmap2,
+                        int x, int y, int w, int h,
+                        PictFormatShort short_format, int all, int diffs)
+{
+    int i, j;
+    unsigned char *p1 = pixmap1->devPrivate.ptr;
+    unsigned char *p2 = pixmap2->devPrivate.ptr;
+    int line_need_printed = 0;
+    int test_code = 0xAABBCCDD;
+    int little_endian = 0;
+    unsigned char *p_test;
+    int bpp = pixmap1->drawable.depth == 8 ? 1 : 4;
+    int stride = pixmap1->devKind;
+
+    assert(pixmap1->devKind == pixmap2->devKind);
+
+    ErrorF("stride:%d, width:%d, height:%d\n", stride, w, h);
+
+    p1 = p1 + y * stride + x;
+    p2 = p2 + y * stride + x;
+
+    if (all) {
+        for (i = 0; i < h; i++) {
+            ErrorF("line %3d: ", i);
+
+            for (j = 0; j < stride; j++) {
+                if (j % bpp == 0)
+                    ErrorF("[%d]%2x:%2x ", j / bpp, p1[j], p2[j]);
+                else
+                    ErrorF("%2x:%2x ", p1[j], p2[j]);
+            }
+
+            p1 += stride;
+            p2 += stride;
+            ErrorF("\n");
+        }
+    }
+    else {
+        if (short_format == PICT_a8r8g8b8) {
+            p_test = (unsigned char *) &test_code;
+            little_endian = (*p_test == 0xDD);
+            bpp = 4;
+
+            for (i = 0; i < h; i++) {
+                line_need_printed = 0;
+
+                for (j = 0; j < stride; j++) {
+                    if (p1[j] != p2[j] &&
+                        (p1[j] - p2[j] > diffs || p2[j] - p1[j] > diffs)) {
+                        if (line_need_printed) {
+                            if (little_endian) {
+                                switch (j % 4) {
+                                case 2:
+                                    ErrorF("[%d]RED:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 1:
+                                    ErrorF("[%d]GREEN:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 0:
+                                    ErrorF("[%d]BLUE:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 3:
+                                    ErrorF("[%d]Alpha:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                }
+                            }
+                            else {
+                                switch (j % 4) {
+                                case 1:
+                                    ErrorF("[%d]RED:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 2:
+                                    ErrorF("[%d]GREEN:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 3:
+                                    ErrorF("[%d]BLUE:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                case 0:
+                                    ErrorF("[%d]Alpha:%2x:%2x ", j / bpp, p1[j],
+                                           p2[j]);
+                                    break;
+                                }
+                            }
+                        }
+                        else {
+                            line_need_printed = 1;
+                            j = -1;
+                            ErrorF("line %3d: ", i);
+                            continue;
+                        }
+                    }
+                }
+
+                p1 += stride;
+                p2 += stride;
+                ErrorF("\n");
+            }
+        }                       //more format can be added here.
+        else {                  // the default format, just print.
+            for (i = 0; i < h; i++) {
+                line_need_printed = 0;
+
+                for (j = 0; j < stride; j++) {
+                    if (p1[j] != p2[j]) {
+                        if (line_need_printed) {
+                            ErrorF("[%d]%2x:%2x ", j / bpp, p1[j], p2[j]);
+                        }
+                        else {
+                            line_need_printed = 1;
+                            j = -1;
+                            ErrorF("line %3d: ", i);
+                            continue;
+                        }
+                    }
+                }
+
+                p1 += stride;
+                p2 += stride;
+                ErrorF("\n");
+            }
+        }
+    }
+}
+
+static inline void
+glamor_compare_pixmaps(PixmapPtr pixmap1, PixmapPtr pixmap2,
+                       int x, int y, int w, int h, int all, int diffs)
+{
+    assert(pixmap1->drawable.depth == pixmap2->drawable.depth);
+
+    if (glamor_prepare_access(&pixmap1->drawable, GLAMOR_ACCESS_RO) &&
+        glamor_prepare_access(&pixmap2->drawable, GLAMOR_ACCESS_RO)) {
+        _glamor_compare_pixmaps(pixmap1, pixmap2, x, y, w, h, -1, all, diffs);
+    }
+    glamor_finish_access(&pixmap1->drawable);
+    glamor_finish_access(&pixmap2->drawable);
+}
+
+/* This function is used to compare two pictures.
+   If the picture has no drawable, we use fb functions to generate it. */
+static inline void
+glamor_compare_pictures(ScreenPtr screen,
+                        PicturePtr fst_picture,
+                        PicturePtr snd_picture,
+                        int x_source, int y_source,
+                        int width, int height, int all, int diffs)
+{
+    PixmapPtr fst_pixmap;
+    PixmapPtr snd_pixmap;
+    int fst_generated, snd_generated;
+    int error;
+    int fst_type = -1;
+    int snd_type = -1;          // -1 represent has drawable.
+
+    if (fst_picture->format != snd_picture->format) {
+        ErrorF("Different picture format can not compare!\n");
+        return;
+    }
+
+    if (!fst_picture->pDrawable) {
+        fst_type = fst_picture->pSourcePict->type;
+    }
+
+    if (!snd_picture->pDrawable) {
+        snd_type = snd_picture->pSourcePict->type;
+    }
+
+    if ((fst_type != -1) && (snd_type != -1) && (fst_type != snd_type)) {
+        ErrorF("Different picture type will never be same!\n");
+        return;
+    }
+
+    fst_generated = snd_generated = 0;
+
+    if (!fst_picture->pDrawable) {
+        PicturePtr pixman_pic;
+        PixmapPtr pixmap = NULL;
+        PictFormatShort format;
+
+        format = fst_picture->format;
+
+        pixmap = glamor_create_pixmap(screen,
+                                      width, height,
+                                      PIXMAN_FORMAT_DEPTH(format),
+                                      GLAMOR_CREATE_PIXMAP_CPU);
+
+        pixman_pic = CreatePicture(0,
+                                   &pixmap->drawable,
+                                   PictureMatchFormat(screen,
+                                                      PIXMAN_FORMAT_DEPTH
+                                                      (format), format), 0, 0,
+                                   serverClient, &error);
+
+        fbComposite(PictOpSrc, fst_picture, NULL, pixman_pic,
+                    x_source, y_source, 0, 0, 0, 0, width, height);
+
+        glamor_destroy_pixmap(pixmap);
+
+        fst_picture = pixman_pic;
+        fst_generated = 1;
+    }
+
+    if (!snd_picture->pDrawable) {
+        PicturePtr pixman_pic;
+        PixmapPtr pixmap = NULL;
+        PictFormatShort format;
+
+        format = snd_picture->format;
+
+        pixmap = glamor_create_pixmap(screen,
+                                      width, height,
+                                      PIXMAN_FORMAT_DEPTH(format),
+                                      GLAMOR_CREATE_PIXMAP_CPU);
+
+        pixman_pic = CreatePicture(0,
+                                   &pixmap->drawable,
+                                   PictureMatchFormat(screen,
+                                                      PIXMAN_FORMAT_DEPTH
+                                                      (format), format), 0, 0,
+                                   serverClient, &error);
+
+        fbComposite(PictOpSrc, snd_picture, NULL, pixman_pic,
+                    x_source, y_source, 0, 0, 0, 0, width, height);
+
+        glamor_destroy_pixmap(pixmap);
+
+        snd_picture = pixman_pic;
+        snd_generated = 1;
+    }
+
+    fst_pixmap = glamor_get_drawable_pixmap(fst_picture->pDrawable);
+    snd_pixmap = glamor_get_drawable_pixmap(snd_picture->pDrawable);
+
+    if (fst_pixmap->drawable.depth != snd_pixmap->drawable.depth) {
+        if (fst_generated)
+            glamor_destroy_picture(fst_picture);
+        if (snd_generated)
+            glamor_destroy_picture(snd_picture);
+
+        ErrorF("Different pixmap depth can not compare!\n");
+        return;
+    }
+
+    if ((fst_type == SourcePictTypeLinear) ||
+        (fst_type == SourcePictTypeRadial) ||
+        (fst_type == SourcePictTypeConical) ||
+        (snd_type == SourcePictTypeLinear) ||
+        (snd_type == SourcePictTypeRadial) ||
+        (snd_type == SourcePictTypeConical)) {
+        x_source = y_source = 0;
+    }
+
+    if (glamor_prepare_access(&fst_pixmap->drawable, GLAMOR_ACCESS_RO) &&
+        glamor_prepare_access(&snd_pixmap->drawable, GLAMOR_ACCESS_RO)) {
+        _glamor_compare_pixmaps(fst_pixmap, snd_pixmap,
+                                x_source, y_source,
+                                width, height, fst_picture->format,
+                                all, diffs);
+    }
+    glamor_finish_access(&fst_pixmap->drawable);
+    glamor_finish_access(&snd_pixmap->drawable);
+
+    if (fst_generated)
+        glamor_destroy_picture(fst_picture);
+    if (snd_generated)
+        glamor_destroy_picture(snd_picture);
+
+    return;
+}
+
+#ifdef __i386__
+static inline unsigned long
+__fls(unsigned long x)
+{
+ asm("bsr %1,%0":"=r"(x)
+ :     "rm"(x));
+    return x;
+}
+#else
+static inline unsigned long
+__fls(unsigned long x)
+{
+    int n;
+
+    if (x == 0)
+        return (0);
+    n = 0;
+    if (x <= 0x0000FFFF) {
+        n = n + 16;
+        x = x << 16;
+    }
+    if (x <= 0x00FFFFFF) {
+        n = n + 8;
+        x = x << 8;
+    }
+    if (x <= 0x0FFFFFFF) {
+        n = n + 4;
+        x = x << 4;
+    }
+    if (x <= 0x3FFFFFFF) {
+        n = n + 2;
+        x = x << 2;
+    }
+    if (x <= 0x7FFFFFFF) {
+        n = n + 1;
+    }
+    return 31 - n;
+}
+#endif
+
+static inline void
+glamor_make_current(glamor_screen_private *glamor_priv)
+{
+    if (lastGLContext != &glamor_priv->ctx) {
+        lastGLContext = &glamor_priv->ctx;
+        glamor_priv->ctx.make_current(&glamor_priv->ctx);
+    }
+}
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_utils.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shmint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shmint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shmint.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/*
+ * Copyright ¬© 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _SHMINT_H_
+#define _SHMINT_H_
+
+#include <X11/extensions/shmproto.h>
+
+#include "screenint.h"
+#include "pixmap.h"
+#include "gc.h"
+
+#define XSHM_PUT_IMAGE_ARGS \
+    DrawablePtr		/* dst */, \
+    GCPtr		/* pGC */, \
+    int			/* depth */, \
+    unsigned int	/* format */, \
+    int			/* w */, \
+    int			/* h */, \
+    int			/* sx */, \
+    int			/* sy */, \
+    int			/* sw */, \
+    int			/* sh */, \
+    int			/* dx */, \
+    int			/* dy */, \
+    char *                      /* data */
+
+#define XSHM_CREATE_PIXMAP_ARGS \
+    ScreenPtr	/* pScreen */, \
+    int		/* width */, \
+    int		/* height */, \
+    int		/* depth */, \
+    char *                      /* addr */
+
+typedef struct _ShmFuncs {
+    PixmapPtr (*CreatePixmap) (XSHM_CREATE_PIXMAP_ARGS);
+    void (*PutImage) (XSHM_PUT_IMAGE_ARGS);
+} ShmFuncs, *ShmFuncsPtr;
+
+#if XTRANS_SEND_FDS
+#define SHM_FD_PASSING  1
+#endif
+
+typedef struct _ShmDesc {
+    struct _ShmDesc *next;
+    int shmid;
+    int refcnt;
+    char *addr;
+    Bool writable;
+    unsigned long size;
+#ifdef SHM_FD_PASSING
+    Bool is_fd;
+    struct busfault *busfault;
+    XID resource;
+#endif
+} ShmDescRec, *ShmDescPtr;
+
+#ifdef SHM_FD_PASSING
+#define SHMDESC_IS_FD(shmdesc)  ((shmdesc)->is_fd)
+#else
+#define SHMDESC_IS_FD(shmdesc)  (0)
+#endif
+
+extern _X_EXPORT void
+ ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs);
+
+extern _X_EXPORT void
+ ShmRegisterFbFuncs(ScreenPtr pScreen);
+
+extern _X_EXPORT RESTYPE ShmSegType;
+extern _X_EXPORT int ShmCompletionCode;
+extern _X_EXPORT int BadShmSegCode;
+
+#endif                          /* _SHMINT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shmint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbeModes.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbeModes.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbeModes.h	(Revision 52145)
@@ -0,0 +1,94 @@
+/*
+ * Copyright ¬© 2002 David Dawes
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the author(s) shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from
+ * the author(s).
+ *
+ * Authors: David Dawes <dawes@xfree86.org>
+ *
+ */
+
+#ifndef _VBE_MODES_H
+
+/*
+ * This is intended to be stored in the DisplayModeRec's private area.
+ * It includes all the information necessary to VBE information.
+ */
+typedef struct _VbeModeInfoData {
+    int mode;
+    VbeModeInfoBlock *data;
+    VbeCRTCInfoBlock *block;
+} VbeModeInfoData;
+
+#define V_DEPTH_1	0x001
+#define V_DEPTH_4	0x002
+#define V_DEPTH_8	0x004
+#define V_DEPTH_15	0x008
+#define V_DEPTH_16	0x010
+#define V_DEPTH_24_24	0x020
+#define V_DEPTH_24_32	0x040
+#define V_DEPTH_24	(V_DEPTH_24_24 | V_DEPTH_24_32)
+#define V_DEPTH_30	0x080
+#define V_DEPTH_32	0x100
+
+#define VBE_MODE_SUPPORTED(m)	(((m)->ModeAttributes & 0x01) != 0)
+#define VBE_MODE_COLOR(m)	(((m)->ModeAttributes & 0x08) != 0)
+#define VBE_MODE_GRAPHICS(m)	(((m)->ModeAttributes & 0x10) != 0)
+#define VBE_MODE_VGA(m)		(((m)->ModeAttributes & 0x40) == 0)
+#define VBE_MODE_LINEAR(m)	(((m)->ModeAttributes & 0x80) != 0 && \
+				 ((m)->PhysBasePtr != 0))
+
+#define VBE_MODE_USABLE(m, f)	(VBE_MODE_SUPPORTED(m) || \
+				 (f & V_MODETYPE_BAD)) && \
+				VBE_MODE_GRAPHICS(m) && \
+				(VBE_MODE_VGA(m) || VBE_MODE_LINEAR(m))
+
+#define V_MODETYPE_VBE		0x01
+#define V_MODETYPE_VGA		0x02
+#define V_MODETYPE_BAD		0x04
+
+extern _X_EXPORT int VBEFindSupportedDepths(vbeInfoPtr pVbe, VbeInfoBlock * vbe,
+                                            int *flags24, int modeTypes);
+extern _X_EXPORT DisplayModePtr VBEGetModePool(ScrnInfoPtr pScrn,
+                                               vbeInfoPtr pVbe,
+                                               VbeInfoBlock * vbe,
+                                               int modeTypes);
+extern _X_EXPORT void VBESetModeNames(DisplayModePtr pMode);
+extern _X_EXPORT void VBESetModeParameters(ScrnInfoPtr pScrn, vbeInfoPtr pVbe);
+
+/*
+ * Note: These are alternatives to the standard helpers.  They should
+ * usually just wrap the standard helpers.
+ */
+extern _X_EXPORT int VBEValidateModes(ScrnInfoPtr scrp,
+                                      DisplayModePtr availModes,
+                                      const char **modeNames,
+                                      ClockRangePtr clockRanges,
+                                      int *linePitches, int minPitch,
+                                      int maxPitch, int pitchInc, int minHeight,
+                                      int maxHeight, int virtualX, int virtualY,
+                                      int apertureSize,
+                                      LookupModeFlags strategy);
+extern _X_EXPORT void VBEPrintModes(ScrnInfoPtr scrp);
+
+#endif                          /* VBE_MODES_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbeModes.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/wfbrename.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/wfbrename.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/wfbrename.h	(Revision 52145)
@@ -0,0 +1,170 @@
+#define fb16Lane wfb16Lane
+#define fb24_32CopyMtoN wfb24_32CopyMtoN
+#define fb24_32CreateScreenResources wfb24_32CreateScreenResources
+#define fb24_32GetImage wfb24_32GetImage
+#define fb24_32GetSpans wfb24_32GetSpans
+#define fb24_32ModifyPixmapHeader wfb24_32ModifyPixmapHeader
+#define fb24_32PutZImage wfb24_32PutZImage
+#define fb24_32ReformatTile wfb24_32ReformatTile
+#define fb24_32SetSpans wfb24_32SetSpans
+#define fb32Lane wfb32Lane
+#define fb8Lane wfb8Lane
+#define fbAddTraps wfbAddTraps
+#define fbAddTriangles wfbAddTriangles
+#define fbAllocatePrivates wfbAllocatePrivates
+#define fbArc16 wfbArc16
+#define fbArc24 wfbArc24
+#define fbArc32 wfbArc32
+#define fbArc8 wfbArc8
+#define fbBlt wfbBlt
+#define fbBlt24 wfbBlt24
+#define fbBltOne wfbBltOne
+#define fbBltOne24 wfbBltOne24
+#define fbBltPlane wfbBltPlane
+#define fbBltStip wfbBltStip
+#define fbBres wfbBres
+#define fbBresDash wfbBresDash
+#define fbBresDash16 wfbBresDash16
+#define fbBresDash24 wfbBresDash24
+#define fbBresDash32 wfbBresDash32
+#define fbBresDash8 wfbBresDash8
+#define fbBresFill wfbBresFill
+#define fbBresFillDash wfbBresFillDash
+#define fbBresSolid wfbBresSolid
+#define fbBresSolid16 wfbBresSolid16
+#define fbBresSolid24 wfbBresSolid24
+#define fbBresSolid32 wfbBresSolid32
+#define fbBresSolid8 wfbBresSolid8
+#define fbChangeWindowAttributes wfbChangeWindowAttributes
+#define fbClearVisualTypes wfbClearVisualTypes
+#define fbCloseScreen wfbCloseScreen
+#define fbComposite wfbComposite
+#define fbCopy1toN wfbCopy1toN
+#define fbCopyArea wfbCopyArea
+#define fbCopyNto1 wfbCopyNto1
+#define fbCopyNtoN wfbCopyNtoN
+#define fbCopyPlane wfbCopyPlane
+#define fbCopyRegion wfbCopyRegion
+#define fbCopyWindow wfbCopyWindow
+#define fbCopyWindowProc wfbCopyWindowProc
+#define fbCreateDefColormap wfbCreateDefColormap
+#define fbCreateGC wfbCreateGC
+#define fbCreatePixmap wfbCreatePixmap
+#define fbCreatePixmapBpp wfbCreatePixmapBpp
+#define fbCreateWindow wfbCreateWindow
+#define fbDestroyGlyphCache wfbDestroyGlyphCache
+#define fbDestroyPixmap wfbDestroyPixmap
+#define fbDestroyWindow wfbDestroyWindow
+#define fbDoCopy wfbDoCopy
+#define fbDots wfbDots
+#define fbDots16 wfbDots16
+#define fbDots24 wfbDots24
+#define fbDots32 wfbDots32
+#define fbDots8 wfbDots8
+#define fbEvenStipple wfbEvenStipple
+#define fbEvenTile wfbEvenTile
+#define fbExpandDirectColors wfbExpandDirectColors
+#define fbFill wfbFill
+#define fbFillRegionSolid wfbFillRegionSolid
+#define fbFillSpans wfbFillSpans
+#define fbFixCoordModePrevious wfbFixCoordModePrevious
+#define fbGCFuncs wfbGCFuncs
+#define fbGCOps wfbGCOps
+#define fbGeneration wfbGeneration
+#define fbGetImage wfbGetImage
+#define fbGetScreenPrivateKey wfbGetScreenPrivateKey
+#define fbGetSpans wfbGetSpans
+#define _fbGetWindowPixmap _wfbGetWindowPixmap
+#define fbGlyph16 wfbGlyph16
+#define fbGlyph24 wfbGlyph24
+#define fbGlyph32 wfbGlyph32
+#define fbGlyph8 wfbGlyph8
+#define fbGlyphIn wfbGlyphIn
+#define fbHasVisualTypes wfbHasVisualTypes
+#define fbImageGlyphBlt wfbImageGlyphBlt
+#define fbIn wfbIn
+#define fbInitializeColormap wfbInitializeColormap
+#define fbInitVisuals wfbInitVisuals
+#define fbInstallColormap wfbInstallColormap
+#define fbLaneTable wfbLaneTable
+#define fbListInstalledColormaps wfbListInstalledColormaps
+#define fbMapWindow wfbMapWindow
+#define FbMergeRopBits wFbMergeRopBits
+#define fbOddStipple wfbOddStipple
+#define fbOddTile wfbOddTile
+#define fbOver wfbOver
+#define fbOver24 wfbOver24
+#define fbOverlayCloseScreen wfbOverlayCloseScreen
+#define fbOverlayCopyWindow wfbOverlayCopyWindow
+#define fbOverlayCreateScreenResources wfbOverlayCreateScreenResources
+#define fbOverlayCreateWindow wfbOverlayCreateWindow
+#define fbOverlayFinishScreenInit wfbOverlayFinishScreenInit
+#define fbOverlayGeneration wfbOverlayGeneration
+#define fbOverlayGetScreenPrivateKey wfbOverlayGetScreenPrivateKey
+#define fbOverlayPaintKey wfbOverlayPaintKey
+#define fbOverlaySetupScreen wfbOverlaySetupScreen
+#define fbOverlayUpdateLayerRegion wfbOverlayUpdateLayerRegion
+#define fbOverlayWindowExposures wfbOverlayWindowExposures
+#define fbOverlayWindowLayer wfbOverlayWindowLayer
+#define fbPadPixmap wfbPadPixmap
+#define fbPictureInit wfbPictureInit
+#define fbPixmapToRegion wfbPixmapToRegion
+#define fbPolyArc wfbPolyArc
+#define fbPolyFillRect wfbPolyFillRect
+#define fbPolyGlyphBlt wfbPolyGlyphBlt
+#define fbPolyLine wfbPolyLine
+#define fbPolyline16 wfbPolyline16
+#define fbPolyline24 wfbPolyline24
+#define fbPolyline32 wfbPolyline32
+#define fbPolyline8 wfbPolyline8
+#define fbPolyPoint wfbPolyPoint
+#define fbPolySegment wfbPolySegment
+#define fbPolySegment16 wfbPolySegment16
+#define fbPolySegment24 wfbPolySegment24
+#define fbPolySegment32 wfbPolySegment32
+#define fbPolySegment8 wfbPolySegment8
+#define fbPositionWindow wfbPositionWindow
+#define fbPushFill wfbPushFill
+#define fbPushImage wfbPushImage
+#define fbPushPattern wfbPushPattern
+#define fbPushPixels wfbPushPixels
+#define fbPutImage wfbPutImage
+#define fbPutXYImage wfbPutXYImage
+#define fbPutZImage wfbPutZImage
+#define fbQueryBestSize wfbQueryBestSize
+#define fbRasterizeTrapezoid wfbRasterizeTrapezoid
+#define fbRealizeFont wfbRealizeFont
+#define fbReduceRasterOp wfbReduceRasterOp
+#define fbReplicatePixel wfbReplicatePixel
+#define fbResolveColor wfbResolveColor
+#define fbScreenPrivateKeyRec wfbScreenPrivateKeyRec
+#define fbSegment wfbSegment
+#define fbSelectBres wfbSelectBres
+#define fbSetSpans wfbSetSpans
+#define fbSetupScreen wfbSetupScreen
+#define fbSetVisualTypes wfbSetVisualTypes
+#define fbSetVisualTypesAndMasks wfbSetVisualTypesAndMasks
+#define _fbSetWindowPixmap _wfbSetWindowPixmap
+#define fbSolid wfbSolid
+#define fbSolid24 wfbSolid24
+#define fbSolidBoxClipped wfbSolidBoxClipped
+#define fbStipple wfbStipple
+#define fbStipple1Bits wfbStipple1Bits
+#define fbStipple24Bits wfbStipple24Bits
+#define fbStipple2Bits wfbStipple2Bits
+#define fbStipple4Bits wfbStipple4Bits
+#define fbStipple8Bits wfbStipple8Bits
+#define fbStippleTable wfbStippleTable
+#define fbTile wfbTile
+#define fbTransparentSpan wfbTransparentSpan
+#define fbTrapezoids wfbTrapezoids
+#define fbTriangles wfbTriangles
+#define fbUninstallColormap wfbUninstallColormap
+#define fbUnmapWindow wfbUnmapWindow
+#define fbUnrealizeFont wfbUnrealizeFont
+#define fbValidateGC wfbValidateGC
+#define fbWinPrivateKeyRec wfbWinPrivateKeyRec
+#define fbZeroLine wfbZeroLine
+#define fbZeroSegment wfbZeroSegment
+#define free_pixman_pict wfb_free_pixman_pict
+#define image_from_pict wfb_image_from_pict

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/wfbrename.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-versions.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-versions.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-versions.h	(Revision 52145)
@@ -0,0 +1,156 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * This file specifies the server-supported protocol versions.
+ */
+#ifndef _PROTOCOL_VERSIONS_
+#define _PROTOCOL_VERSIONS_
+
+/* Apple DRI */
+#define SERVER_APPLEDRI_MAJOR_VERSION		1
+#define SERVER_APPLEDRI_MINOR_VERSION		0
+#define SERVER_APPLEDRI_PATCH_VERSION		0
+
+/* AppleWM */
+#define SERVER_APPLEWM_MAJOR_VERSION		1
+#define SERVER_APPLEWM_MINOR_VERSION		3
+#define SERVER_APPLEWM_PATCH_VERSION		0
+
+/* Composite */
+#define SERVER_COMPOSITE_MAJOR_VERSION		0
+#define SERVER_COMPOSITE_MINOR_VERSION		4
+
+/* Damage */
+#define SERVER_DAMAGE_MAJOR_VERSION		1
+#define SERVER_DAMAGE_MINOR_VERSION		1
+
+/* DRI3 */
+#define SERVER_DRI3_MAJOR_VERSION               1
+#define SERVER_DRI3_MINOR_VERSION               0
+
+/* DMX */
+#define SERVER_DMX_MAJOR_VERSION		2
+#define SERVER_DMX_MINOR_VERSION		2
+#define SERVER_DMX_PATCH_VERSION		20040604
+
+/* Generic event extension */
+#define SERVER_GE_MAJOR_VERSION                 1
+#define SERVER_GE_MINOR_VERSION                 0
+
+/* GLX */
+#define SERVER_GLX_MAJOR_VERSION		1
+#define SERVER_GLX_MINOR_VERSION		4
+
+/* Xinerama */
+#define SERVER_PANORAMIX_MAJOR_VERSION          1
+#define SERVER_PANORAMIX_MINOR_VERSION		1
+
+/* Present */
+#define SERVER_PRESENT_MAJOR_VERSION            1
+#define SERVER_PRESENT_MINOR_VERSION            0
+
+/* RandR */
+#define SERVER_RANDR_MAJOR_VERSION		1
+#define SERVER_RANDR_MINOR_VERSION		4
+
+/* Record */
+#define SERVER_RECORD_MAJOR_VERSION		1
+#define SERVER_RECORD_MINOR_VERSION		13
+
+/* Render */
+#define SERVER_RENDER_MAJOR_VERSION		0
+#define SERVER_RENDER_MINOR_VERSION		11
+
+/* RandR Xinerama */
+#define SERVER_RRXINERAMA_MAJOR_VERSION		1
+#define SERVER_RRXINERAMA_MINOR_VERSION		1
+
+/* Screensaver */
+#define SERVER_SAVER_MAJOR_VERSION		1
+#define SERVER_SAVER_MINOR_VERSION		1
+
+/* Security */
+#define SERVER_SECURITY_MAJOR_VERSION		1
+#define SERVER_SECURITY_MINOR_VERSION		0
+
+/* Shape */
+#define SERVER_SHAPE_MAJOR_VERSION		1
+#define SERVER_SHAPE_MINOR_VERSION		1
+
+/* SHM */
+#define SERVER_SHM_MAJOR_VERSION		1
+#if XTRANS_SEND_FDS
+#define SERVER_SHM_MINOR_VERSION		2
+#else
+#define SERVER_SHM_MINOR_VERSION		1
+#endif
+
+/* Sync */
+#define SERVER_SYNC_MAJOR_VERSION		3
+#define SERVER_SYNC_MINOR_VERSION		1
+
+/* Windows WM */
+#define SERVER_WINDOWSWM_MAJOR_VERSION		1
+#define SERVER_WINDOWSWM_MINOR_VERSION		0
+#define SERVER_WINDOWSWM_PATCH_VERSION		0
+
+/* DGA */
+#define SERVER_XDGA_MAJOR_VERSION		2
+#define SERVER_XDGA_MINOR_VERSION		0
+
+/* Big Font */
+#define SERVER_XF86BIGFONT_MAJOR_VERSION	1
+#define SERVER_XF86BIGFONT_MINOR_VERSION	1
+
+/* DRI */
+#define SERVER_XF86DRI_MAJOR_VERSION		4
+#define SERVER_XF86DRI_MINOR_VERSION		1
+#define SERVER_XF86DRI_PATCH_VERSION		20040604
+
+/* Vidmode */
+#define SERVER_XF86VIDMODE_MAJOR_VERSION	2
+#define SERVER_XF86VIDMODE_MINOR_VERSION	2
+
+/* Fixes */
+#define SERVER_XFIXES_MAJOR_VERSION		5
+#define SERVER_XFIXES_MINOR_VERSION		0
+
+/* X Input */
+#define SERVER_XI_MAJOR_VERSION			2
+#define SERVER_XI_MINOR_VERSION			3
+
+/* XKB */
+#define SERVER_XKB_MAJOR_VERSION		1
+#define SERVER_XKB_MINOR_VERSION		0
+
+/* Resource */
+#define SERVER_XRES_MAJOR_VERSION		1
+#define SERVER_XRES_MINOR_VERSION		2
+
+/* XvMC */
+#define SERVER_XVMC_MAJOR_VERSION		1
+#define SERVER_XVMC_MINOR_VERSION		1
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-versions.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mioverlay.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mioverlay.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mioverlay.h	(Revision 52145)
@@ -0,0 +1,28 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef __MIOVERLAY_H
+#define __MIOVERLAY_H
+
+typedef void (*miOverlayTransFunc) (ScreenPtr, int, BoxPtr);
+typedef Bool (*miOverlayInOverlayFunc) (WindowPtr);
+
+extern _X_EXPORT Bool
+
+miInitOverlay(ScreenPtr pScreen,
+              miOverlayInOverlayFunc inOverlay, miOverlayTransFunc trans);
+
+extern _X_EXPORT Bool
+
+miOverlayGetPrivateClips(WindowPtr pWin,
+                         RegionPtr *borderClip, RegionPtr *clipList);
+
+extern _X_EXPORT Bool miOverlayCollectUnderlayRegions(WindowPtr, RegionPtr *);
+extern _X_EXPORT void miOverlayComputeCompositeClip(GCPtr, WindowPtr);
+extern _X_EXPORT Bool miOverlayCopyUnderlay(ScreenPtr);
+extern _X_EXPORT void miOverlaySetTransFunction(ScreenPtr, miOverlayTransFunc);
+extern _X_EXPORT void miOverlaySetRootClip(ScreenPtr, Bool);
+
+#endif                          /* __MIOVERLAY_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mioverlay.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/README
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/README	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/README	(Revision 52145)
@@ -0,0 +1,18 @@
+The contents of this directory were extracted from the contents of the
+archive xorg-server-1.16.0.tar.bz2, as downloaded from ftp.x.org, using the
+following shell script:
+
+for i in `find xorg-server-1.16.0 -name '*.h' | grep -v hw/xwin |
+ grep -v hw/xquartz | grep -v hw/kdrive | grep -v hw/xnest |
+ grep -v hw/xprint | grep -v hw/xgl`
+  do
+    cp ${i} ${PATH_VBOX}/src/VBox/Additions/x11/x11include/xorg-server-1.16.0/
+  done
+sed -e 's/\(Uchar.*:[0-9];$\)/__extension__ \1/g' \
+    -e '/union {/,/}/ s/};/} dummy;/' \
+    ${PATH_VBOX}/src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h \
+    > ${PATH_VBOX}/src/VBox/Additions/x11/x11include/xorg-server-1.16.0/\
+edid-new.h
+mv ${PATH_VBOX}/src/VBox/Additions/x11/x11include/xorg-server-1.16.0/\
+edid-new.h \
+${PATH_VBOX}/src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/README
___________________________________________________________________
Added: svn:keywords
## -0,0 +1 ##
+Author Date Id Revision
\ No newline at end of property
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpixmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpixmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpixmap.h	(Revision 52145)
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for pixmap support.  \see dmxpixmap.c */
+
+#ifndef DMXPIXMAP_H
+#define DMXPIXMAP_H
+
+#include "pixmapstr.h"
+
+/** Pixmap private area. */
+typedef struct _dmxPixPriv {
+    Pixmap pixmap;
+    XImage *detachedImage;
+} dmxPixPrivRec, *dmxPixPrivPtr;
+
+extern Bool dmxInitPixmap(ScreenPtr pScreen);
+
+extern PixmapPtr dmxCreatePixmap(ScreenPtr pScreen,
+                                 int width, int height, int depth,
+                                 unsigned usage_hint);
+extern Bool dmxDestroyPixmap(PixmapPtr pPixmap);
+extern RegionPtr dmxBitmapToRegion(PixmapPtr pPixmap);
+
+extern void dmxBECreatePixmap(PixmapPtr pPixmap);
+extern Bool dmxBEFreePixmap(PixmapPtr pPixmap);
+
+/** Get pixmap private pointer. */
+#define DMX_GET_PIXMAP_PRIV(_pPix)					\
+    (dmxPixPrivPtr)dixLookupPrivate(&(_pPix)->devPrivates, dmxPixPrivateKey)
+
+#endif                          /* DMXPIXMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpixmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsrv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsrv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsrv.h	(Revision 52145)
@@ -0,0 +1,152 @@
+/*
+
+Copyright 1991, 1993, 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/***********************************************************
+Copyright 1991,1993 by Digital Equipment Corporation, Maynard, Massachusetts,
+and Olivetti Research Limited, Cambridge, England.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the names of Digital or Olivetti
+not be used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+
+******************************************************************/
+
+#ifndef _SYNCSRV_H_
+#define _SYNCSRV_H_
+
+#include "list.h"
+#include "misync.h"
+#include "misyncstr.h"
+
+/*
+ * The System Counter interface
+ */
+
+typedef enum {
+    XSyncCounterNeverChanges,
+    XSyncCounterNeverIncreases,
+    XSyncCounterNeverDecreases,
+    XSyncCounterUnrestricted
+} SyncCounterType;
+
+typedef void (*SyncSystemCounterQueryValue)(void *counter,
+                                            CARD64 *value_return
+    );
+typedef void (*SyncSystemCounterBracketValues)(void *counter,
+                                               CARD64 *pbracket_less,
+                                               CARD64 *pbracket_greater
+    );
+
+typedef struct _SysCounterInfo {
+    SyncCounter *pCounter;
+    char *name;
+    CARD64 resolution;
+    CARD64 bracket_greater;
+    CARD64 bracket_less;
+    SyncCounterType counterType;        /* how can this counter change */
+    SyncSystemCounterQueryValue QueryValue;
+    SyncSystemCounterBracketValues BracketValues;
+    void *private;
+    struct xorg_list entry;
+} SysCounterInfo;
+
+typedef struct _SyncAlarmClientList {
+    ClientPtr client;
+    XID delete_id;
+    struct _SyncAlarmClientList *next;
+} SyncAlarmClientList;
+
+typedef struct _SyncAlarm {
+    SyncTrigger trigger;
+    ClientPtr client;
+    XSyncAlarm alarm_id;
+    CARD64 delta;
+    int events;
+    int state;
+    SyncAlarmClientList *pEventClients;
+} SyncAlarm;
+
+typedef struct {
+    ClientPtr client;
+    CARD32 delete_id;
+    int num_waitconditions;
+} SyncAwaitHeader;
+
+typedef struct {
+    SyncTrigger trigger;
+    CARD64 event_threshold;
+    SyncAwaitHeader *pHeader;
+} SyncAwait;
+
+typedef union {
+    SyncAwaitHeader header;
+    SyncAwait await;
+} SyncAwaitUnion;
+
+extern SyncCounter* SyncCreateSystemCounter(const char *name,
+                                            CARD64 initial_value,
+                                            CARD64 resolution,
+                                            SyncCounterType counterType,
+                                            SyncSystemCounterQueryValue QueryValue,
+                                            SyncSystemCounterBracketValues BracketValues
+    );
+
+extern void SyncChangeCounter(SyncCounter *pCounter,
+                              CARD64 new_value
+    );
+
+extern void SyncDestroySystemCounter(void *pCounter);
+
+extern SyncCounter *SyncInitDeviceIdleTime(DeviceIntPtr dev);
+extern void SyncRemoveDeviceIdleTime(SyncCounter *counter);
+
+int
+SyncCreateFenceFromFD(ClientPtr client, DrawablePtr pDraw, XID id, int fd, BOOL initially_triggered);
+
+int
+SyncFDFromFence(ClientPtr client, DrawablePtr pDraw, SyncFence *fence);
+
+void
+SyncDeleteTriggerFromSyncObject(SyncTrigger * pTrigger);
+
+int
+SyncAddTriggerToSyncObject(SyncTrigger * pTrigger);
+
+#endif                          /* _SYNCSRV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/syncsrv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdev.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEV_H
+#define UNGRDEV_H 1
+
+int SProcXUngrabDevice(ClientPtr        /* client */
+    );
+
+int ProcXUngrabDevice(ClientPtr /* client */
+    );
+
+#endif                          /* UNGRDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picture.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picture.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picture.h	(Revision 52145)
@@ -0,0 +1,232 @@
+/*
+ *
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _PICTURE_H_
+#define _PICTURE_H_
+
+#include "privates.h"
+
+#include <pixman.h>
+
+typedef struct _DirectFormat *DirectFormatPtr;
+typedef struct _PictFormat *PictFormatPtr;
+typedef struct _Picture *PicturePtr;
+
+/*
+ * While the protocol is generous in format support, the
+ * sample implementation allows only packed RGB and GBR
+ * representations for data to simplify software rendering,
+ */
+#define PICT_FORMAT(bpp,type,a,r,g,b)	PIXMAN_FORMAT(bpp, type, a, r, g, b)
+
+/*
+ * gray/color formats use a visual index instead of argb
+ */
+#define PICT_VISFORMAT(bpp,type,vi)	(((bpp) << 24) |  \
+					 ((type) << 16) | \
+					 ((vi)))
+
+#define PICT_FORMAT_BPP(f)	PIXMAN_FORMAT_BPP(f)
+#define PICT_FORMAT_TYPE(f)	PIXMAN_FORMAT_TYPE(f)
+#define PICT_FORMAT_A(f)	PIXMAN_FORMAT_A(f)
+#define PICT_FORMAT_R(f)	PIXMAN_FORMAT_R(f)
+#define PICT_FORMAT_G(f)	PIXMAN_FORMAT_G(f)
+#define PICT_FORMAT_B(f)	PIXMAN_FORMAT_B(f)
+#define PICT_FORMAT_RGB(f)	PIXMAN_FORMAT_RGB(f)
+#define PICT_FORMAT_VIS(f)	PIXMAN_FORMAT_VIS(f)
+
+#define PICT_TYPE_OTHER		PIXMAN_TYPE_OTHER
+#define PICT_TYPE_A		PIXMAN_TYPE_A
+#define PICT_TYPE_ARGB		PIXMAN_TYPE_ARGB
+#define PICT_TYPE_ABGR		PIXMAN_TYPE_ABGR
+#define PICT_TYPE_COLOR		PIXMAN_TYPE_COLOR
+#define PICT_TYPE_GRAY		PIXMAN_TYPE_GRAY
+#define PICT_TYPE_BGRA		PIXMAN_TYPE_BGRA
+
+#define PICT_FORMAT_COLOR(f)	PIXMAN_FORMAT_COLOR(f)
+
+/* 32bpp formats */
+typedef enum _PictFormatShort {
+    PICT_a2r10g10b10 = PIXMAN_a2r10g10b10,
+    PICT_x2r10g10b10 = PIXMAN_x2r10g10b10,
+    PICT_a2b10g10r10 = PIXMAN_a2b10g10r10,
+    PICT_x2b10g10r10 = PIXMAN_x2b10g10r10,
+
+    PICT_a8r8g8b8 = PIXMAN_a8r8g8b8,
+    PICT_x8r8g8b8 = PIXMAN_x8r8g8b8,
+    PICT_a8b8g8r8 = PIXMAN_a8b8g8r8,
+    PICT_x8b8g8r8 = PIXMAN_x8b8g8r8,
+    PICT_b8g8r8a8 = PIXMAN_b8g8r8a8,
+    PICT_b8g8r8x8 = PIXMAN_b8g8r8x8,
+
+/* 24bpp formats */
+    PICT_r8g8b8 = PIXMAN_r8g8b8,
+    PICT_b8g8r8 = PIXMAN_b8g8r8,
+
+/* 16bpp formats */
+    PICT_r5g6b5 = PIXMAN_r5g6b5,
+    PICT_b5g6r5 = PIXMAN_b5g6r5,
+
+    PICT_a1r5g5b5 = PIXMAN_a1r5g5b5,
+    PICT_x1r5g5b5 = PIXMAN_x1r5g5b5,
+    PICT_a1b5g5r5 = PIXMAN_a1b5g5r5,
+    PICT_x1b5g5r5 = PIXMAN_x1b5g5r5,
+    PICT_a4r4g4b4 = PIXMAN_a4r4g4b4,
+    PICT_x4r4g4b4 = PIXMAN_x4r4g4b4,
+    PICT_a4b4g4r4 = PIXMAN_a4b4g4r4,
+    PICT_x4b4g4r4 = PIXMAN_x4b4g4r4,
+
+/* 8bpp formats */
+    PICT_a8 = PIXMAN_a8,
+    PICT_r3g3b2 = PIXMAN_r3g3b2,
+    PICT_b2g3r3 = PIXMAN_b2g3r3,
+    PICT_a2r2g2b2 = PIXMAN_a2r2g2b2,
+    PICT_a2b2g2r2 = PIXMAN_a2b2g2r2,
+
+    PICT_c8 = PIXMAN_c8,
+    PICT_g8 = PIXMAN_g8,
+
+    PICT_x4a4 = PIXMAN_x4a4,
+
+    PICT_x4c4 = PIXMAN_x4c4,
+    PICT_x4g4 = PIXMAN_x4g4,
+
+/* 4bpp formats */
+    PICT_a4 = PIXMAN_a4,
+    PICT_r1g2b1 = PIXMAN_r1g2b1,
+    PICT_b1g2r1 = PIXMAN_b1g2r1,
+    PICT_a1r1g1b1 = PIXMAN_a1r1g1b1,
+    PICT_a1b1g1r1 = PIXMAN_a1b1g1r1,
+
+    PICT_c4 = PIXMAN_c4,
+    PICT_g4 = PIXMAN_g4,
+
+/* 1bpp formats */
+    PICT_a1 = PIXMAN_a1,
+
+    PICT_g1 = PIXMAN_g1
+} PictFormatShort;
+
+/*
+ * For dynamic indexed visuals (GrayScale and PseudoColor), these control the 
+ * selection of colors allocated for drawing to Pictures.  The default
+ * policy depends on the size of the colormap:
+ *
+ * Size		Default Policy
+ * ----------------------------
+ *  < 64	PolicyMono
+ *  < 256	PolicyGray
+ *  256		PolicyColor (only on PseudoColor)
+ *
+ * The actual allocation code lives in miindex.c, and so is
+ * austensibly server dependent, but that code does:
+ *
+ * PolicyMono	    Allocate no additional colors, use black and white
+ * PolicyGray	    Allocate 13 gray levels (11 cells used)
+ * PolicyColor	    Allocate a 4x4x4 cube and 13 gray levels (71 cells used)
+ * PolicyAll	    Allocate as big a cube as possible, fill with gray (all)
+ *
+ * Here's a picture to help understand how many colors are
+ * actually allocated (this is just the gray ramp):
+ *
+ *                 gray level
+ * all   0000 1555 2aaa 4000 5555 6aaa 8000 9555 aaaa bfff d555 eaaa ffff
+ * b/w   0000                                                        ffff
+ * 4x4x4                     5555                aaaa
+ * extra      1555 2aaa 4000      6aaa 8000 9555      bfff d555 eaaa
+ *
+ * The default colormap supplies two gray levels (black/white), the
+ * 4x4x4 cube allocates another two and nine more are allocated to fill
+ * in the 13 levels.  When the 4x4x4 cube is not allocated, a total of
+ * 11 cells are allocated.
+ */
+
+#define PictureCmapPolicyInvalid    -1
+#define PictureCmapPolicyDefault    0
+#define PictureCmapPolicyMono	    1
+#define PictureCmapPolicyGray	    2
+#define PictureCmapPolicyColor	    3
+#define PictureCmapPolicyAll	    4
+
+extern _X_EXPORT int PictureCmapPolicy;
+
+extern _X_EXPORT int PictureParseCmapPolicy(const char *name);
+
+extern _X_EXPORT int RenderErrBase;
+
+/* Fixed point updates from Carl Worth, USC, Information Sciences Institute */
+
+typedef pixman_fixed_32_32_t xFixed_32_32;
+
+typedef pixman_fixed_48_16_t xFixed_48_16;
+
+#define MAX_FIXED_48_16		pixman_max_fixed_48_16
+#define MIN_FIXED_48_16		pixman_min_fixed_48_16
+
+typedef pixman_fixed_1_31_t xFixed_1_31;
+typedef pixman_fixed_1_16_t xFixed_1_16;
+typedef pixman_fixed_16_16_t xFixed_16_16;
+
+/*
+ * An unadorned "xFixed" is the same as xFixed_16_16, 
+ * (since it's quite common in the code) 
+ */
+typedef pixman_fixed_t xFixed;
+
+#define XFIXED_BITS	16
+
+#define xFixedToInt(f)	pixman_fixed_to_int(f)
+#define IntToxFixed(i)	pixman_int_to_fixed(i)
+#define xFixedE		pixman_fixed_e
+#define xFixed1		pixman_fixed_1
+#define xFixed1MinusE	pixman_fixed_1_minus_e
+#define xFixedFrac(f)	pixman_fixed_frac(f)
+#define xFixedFloor(f)	pixman_fixed_floor(f)
+#define xFixedCeil(f)	pixman_fixed_ceil(f)
+
+#define xFixedFraction(f)	pixman_fixed_fraction(f)
+#define xFixedMod2(f)		pixman_fixed_mod2(f)
+
+/* whether 't' is a well defined not obviously empty trapezoid */
+#define xTrapezoidValid(t)  ((t)->left.p1.y != (t)->left.p2.y && \
+			     (t)->right.p1.y != (t)->right.p2.y && \
+			     (int) ((t)->bottom - (t)->top) > 0)
+
+/*
+ * Standard NTSC luminance conversions:
+ *
+ *  y = r * 0.299 + g * 0.587 + b * 0.114
+ *
+ * Approximate this for a bit more speed:
+ *
+ *  y = (r * 153 + g * 301 + b * 58) / 512
+ *
+ * This gives 17 bits of luminance; to get 15 bits, lop the low two
+ */
+
+#define CvtR8G8B8toY15(s)	(((((s) >> 16) & 0xff) * 153 + \
+				  (((s) >>  8) & 0xff) * 301 + \
+				  (((s)      ) & 0xff) * 58) >> 2)
+
+#endif                          /* _PICTURE_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picture.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/queryst.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/queryst.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/queryst.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYST_H
+#define QUERYST_H 1
+
+int SProcXQueryDeviceState(ClientPtr    /* client */
+    );
+
+int ProcXQueryDeviceState(ClientPtr     /* client */
+    );
+
+void SRepXQueryDeviceState(ClientPtr /* client */ ,
+                           int /* size */ ,
+                           xQueryDeviceStateReply *     /* rep */
+    );
+
+#endif                          /* QUERYST_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/queryst.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closure.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closure.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closure.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CLOSURE_H
+#define CLOSURE_H 1
+
+typedef struct _LFclosure *LFclosurePtr;
+typedef struct _LFWIclosure *LFWIclosurePtr;
+typedef struct _OFclosure *OFclosurePtr;
+typedef struct _PTclosure *PTclosurePtr;
+typedef struct _ITclosure *ITclosurePtr;
+
+#endif                          /* CLOSURE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closure.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/config-backends.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/config-backends.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/config-backends.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * Copyright ¬© 2006-2007 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "input.h"
+#include "list.h"
+
+void remove_devices(const char *backend, const char *config_info);
+BOOL device_is_duplicate(const char *config_info);
+
+#ifdef CONFIG_UDEV
+int config_udev_pre_init(void);
+int config_udev_init(void);
+void config_udev_fini(void);
+void config_udev_odev_probe(config_odev_probe_proc_ptr probe_callback);
+#elif defined(CONFIG_HAL)
+int config_hal_init(void);
+void config_hal_fini(void);
+#elif defined(CONFIG_WSCONS)
+int config_wscons_init(void);
+void config_wscons_fini(void);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/config-backends.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconfig.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconfig.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconfig.h	(Revision 52145)
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DMX configuration file support.  \see dmxconfig.c */
+
+#ifndef _DMXCONFIG_H_
+#define _DMXCONFIG_H_
+
+#include <xkb-config.h>
+
+extern void dmxConfigStoreDisplay(const char *display);
+extern void dmxConfigStoreInput(const char *input);     /* Core devices */
+extern void dmxConfigStoreXInput(const char *input);    /* Non-core devices */
+extern void dmxConfigStoreFile(const char *file);
+extern void dmxConfigStoreConfig(const char *config);
+extern void dmxConfigConfigure(void);
+extern void dmxConfigSetMaxScreens(void);
+
+extern void dmxConfigSetXkbRules(const char *rules);
+extern void dmxConfigSetXkbModel(const char *model);
+extern void dmxConfigSetXkbLayout(const char *layout);
+extern void dmxConfigSetXkbVariant(const char *variant);
+extern void dmxConfigSetXkbOptions(const char *options);
+
+extern char *dmxConfigGetXkbRules(void);
+extern char *dmxConfigGetXkbModel(void);
+extern char *dmxConfigGetXkbLayout(void);
+extern char *dmxConfigGetXkbVariant(void);
+extern char *dmxConfigGetXkbOptions(void);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconfig.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_dispatch.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_dispatch.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_dispatch.h	(Revision 52145)
@@ -0,0 +1,1359 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_recv.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_DISPATCH_H_ )
+#define _INDIRECT_DISPATCH_H_
+
+#include <X11/Xfuncproto.h>
+
+struct __GLXclientStateRec;
+
+extern _X_HIDDEN void __glXDisp_MapGrid1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MapGrid1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid1f(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MapGrid1f(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_NewList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_NewList(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN void __glXDisp_LoadIdentity(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LoadIdentity(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Histogram(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Histogram(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMapfv(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_RasterPos4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PolygonStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PolygonStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetPixelMapfv(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetPixelMapfv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_Color3uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3uiv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsEnabled(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsEnabled(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalCoord2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalCoord2fv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DestroyPixmap(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyPixmap(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FramebufferTexture1D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMapiv(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDisp_SwapBuffers(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_SwapBuffers(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_Indexubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Indexubv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_Render(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_Render(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexImage3D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_MakeContextCurrent(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_MakeContextCurrent(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetFBConfigs(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetFBConfigs(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModeliv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LightModeliv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs1dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Normal3bv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_VendorPrivate(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_VendorPrivate(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexGeniv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGeniv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RenderbufferStorage(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RenderbufferStorage(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenQueries(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenQueries(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_BlendColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlendColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scalef(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Scalef(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Normal3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PassThrough(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PassThrough(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Viewport(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Viewport(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DepthRange(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DepthRange(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetQueryiv(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetQueryiv(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_ResetHistogram(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ResetHistogram(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nbv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nbv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameteriv(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameteriv(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameterivEXT(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterivEXT(struct
+                                                                __GLXclientStateRec
+                                                                *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_Vertex2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex2dv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetVisualConfigs(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetVisualConfigs(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_DeleteRenderbuffers(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DeleteRenderbuffers(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CopyContext(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CopyContext(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointSize(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PointSize(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PopName(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PopName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClampColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClampColor(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexEnvfv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexEnvfv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_LineStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LineStipple(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnvi(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexEnvi(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetClipPlane(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetClipPlane(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scaled(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Scaled(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CallLists(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CallLists(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_AlphaFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_AlphaFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rotated(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rotated(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_ReadPixels(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_ReadPixels(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_EdgeFlagv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EdgeFlagv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexParameteri(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DestroyContext(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyContext(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_DrawPixels(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DrawPixels(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenLists(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenLists(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_MapGrid2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MapGrid2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MapGrid2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MapGrid2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Scissor(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Scissor(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Fogf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogi(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Fogi(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelMapfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelMapfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2iv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_AreTexturesResident(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_AreTexturesResident(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDisp_AreTexturesResidentEXT(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_AreTexturesResidentEXT(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_Color3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2fvARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterfvARB(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramLocalParameterfvARB(struct
+                                                                 __GLXclientStateRec
+                                                                 *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ColorTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Accum(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Accum(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexImage(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexImage(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_ConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_Finish(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_Finish(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_ClearStencil(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClearStencil(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord1fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearIndex(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClearIndex(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LoadMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LoadMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PushMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionParameterfv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexGendv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexGendv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_EndList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_EndList(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN void __glXDisp_EvalCoord1fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalCoord1fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalMesh2(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalMesh2(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs3fvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterdvARB(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramEnvParameterdvARB(struct
+                                                               __GLXclientStateRec
+                                                               *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetFBConfigsSGIX(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetFBConfigsSGIX(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindFramebuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BindFramebuffer(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateNewContext(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateNewContext(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmax(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmax(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxEXT(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmaxEXT(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_BlendFuncSeparate(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlendFuncSeparate(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Normal3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_End(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_End(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs3svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs3svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs2dvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateContextAttribsARB(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateContextAttribsARB(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindTexture(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BindTexture(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexSubImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGenfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGenfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawBuffers(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DrawBuffers(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateContextWithConfigSGIX(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateContextWithConfigSGIX(struct
+                                                               __GLXclientStateRec
+                                                               *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_CopySubBufferMESA(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CopySubBufferMESA(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BlendEquation(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlendEquation(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetError(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetError(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Indexdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushName(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PushName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1dv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateGLXPbufferSGIX(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateGLXPbufferSGIX(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsRenderbuffer(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsRenderbuffer(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_DepthMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DepthMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4iv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetMaterialiv(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMaterialiv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_StencilOp(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_StencilOp(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FramebufferTextureLayer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FramebufferTextureLayer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Ortho(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Ortho(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnvfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexEnvfv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_QueryServerString(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_QueryServerString(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_LoadMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LoadMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4bv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetCompressedTexImage(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetCompressedTexImage(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteLists(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DeleteLists(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_LogicOp(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LogicOp(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RenderbufferStorageMultisample(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RenderbufferStorageMultisample(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ActiveTexture(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ActiveTexture(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3bv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_WaitX(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_WaitX(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1dvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenTextures(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenTextures(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_GenTexturesEXT(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenTexturesEXT(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetDrawableAttributes(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetDrawableAttributes(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_RasterPos2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DrawBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateGLXPixmapWithConfigSGIX(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(struct
+                                                                 __GLXclientStateRec
+                                                                 *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_DepthFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DepthFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelMapusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelMapusv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BlendFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlendFunc(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_WaitGL(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_WaitGL(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexImage2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_Flush(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_Flush(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_Color4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PushAttrib(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PushAttrib(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DestroyPbuffer(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyPbuffer(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexParameteriv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_QueryExtensionsString(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_QueryExtensionsString(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_RasterPos3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetColorTable(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTable(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableSGI(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTableSGI(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_Indexiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Indexiv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateContext(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateContext(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_CopyColorTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyColorTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PointParameterfv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameterfv(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterfv(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameterfvEXT(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterfvEXT(struct
+                                                              __GLXclientStateRec
+                                                              *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_Frustum(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Frustum(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetString(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetString(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDisp_CreateGLXPixmap(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateGLXPixmap(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexEnvf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexEnvf(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenProgramsARB(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenProgramsARB(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDisp_DeleteTextures(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DeleteTextures(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDisp_DeleteTexturesEXT(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DeleteTexturesEXT(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexLevelParameteriv(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexLevelParameteriv(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_ClearAccum(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClearAccum(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_QueryVersion(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_QueryVersion(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FramebufferTexture3D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetDrawableAttributesSGIX(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetDrawableAttributesSGIX(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_ColorTableParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorTableParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyTexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lightfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Lightfv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetFramebufferAttachmentParameteriv(struct
+                                                                   __GLXclientStateRec
+                                                                   *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetFramebufferAttachmentParameteriv(struct
+                                                                       __GLXclientStateRec
+                                                                       *,
+                                                                       GLbyte
+                                                                       *);
+extern _X_HIDDEN void __glXDisp_ClearDepth(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClearDepth(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4fv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreatePixmap(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreatePixmap(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_Lightiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Lightiv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexParameteriv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexParameteriv(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsQuery(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsQuery(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN void __glXDisp_Rectdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rectdv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Materialiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3fvEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PolygonMode(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PolygonMode(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Niv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Niv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramStringARB(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexGeni(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGeni(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGenf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGenf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGend(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGend(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetPolygonStipple(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetPolygonStipple(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs1fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib2dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib2dvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DestroyWindow(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyWindow(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_Color4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelZoom(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelZoom(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorTableParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorTableParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelMapuiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelMapuiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3dv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsTexture(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsTexture(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsTextureEXT(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsTextureEXT(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BeginQuery(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BeginQuery(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_SetClientInfo2ARB(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_SetClientInfo2ARB(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMapdv(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3iv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DestroyGLXPixmap(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyGLXPixmap(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_PixelStoref(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_PixelStoref(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_PrioritizeTextures(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PrioritizeTextures(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_PixelStorei(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_PixelStorei(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_DestroyGLXPbufferSGIX(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DestroyGLXPbufferSGIX(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN void __glXDisp_EvalCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ColorMaterial(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorMaterial(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttribs1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1fvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetSeparableFilter(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetSeparableFilter(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetSeparableFilterEXT(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetSeparableFilterEXT(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN int __glXDisp_FeedbackBuffer(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_FeedbackBuffer(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_RasterPos2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FrontFace(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FrontFace(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_RenderLarge(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_RenderLarge(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_PolygonOffset(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PolygonOffset(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Normal3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Lightf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Lightf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MatrixMode(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MatrixMode(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetPixelMapusv(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetPixelMapusv(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_Lighti(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Lighti(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenFramebuffers(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenFramebuffers(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsFramebuffer(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsFramebuffer(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributesSGIX(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_ChangeDrawableAttributesSGIX(struct
+                                                                __GLXclientStateRec
+                                                                *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_BlendEquationSeparate(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlendEquationSeparate(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreatePbuffer(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreatePbuffer(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetDoublev(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetDoublev(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_MultMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultMatrixd(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultMatrixf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClearColor(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClearColor(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsDirect(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsDirect(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PointParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PointParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PointParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexEnviv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexEnviv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4iv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_SwapIntervalSGI(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_SwapIntervalSGI(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameterfv(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterfv(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameterfvSGI(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterfvSGI(struct
+                                                               __GLXclientStateRec
+                                                               *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_FramebufferTexture2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FramebufferTexture2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Bitmap(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Bitmap(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexLevelParameterfv(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexLevelParameterfv(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN int __glXDisp_CheckFramebufferStatus(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CheckFramebufferStatus(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_Vertex2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex2sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetIntegerv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetIntegerv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindProgramARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BindProgramARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramEnvParameterfvARB(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramEnvParameterfvARB(struct
+                                                               __GLXclientStateRec
+                                                               *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3svNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexEnviv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexEnviv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_VendorPrivateWithReply(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_VendorPrivateWithReply(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN void __glXDisp_SeparableFilter2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SeparableFilter2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetQueryObjectuiv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetQueryObjectuiv(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_Map1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Map1d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map1f(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Map1f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexImage2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexImage2D(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_ChangeDrawableAttributes(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_ChangeDrawableAttributes(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameteriv(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameteriv(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameterivEXT(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterivEXT(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_PixelTransferf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelTransferf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyTexImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Fogiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EndQuery(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EndQuery(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PixelTransferi(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PixelTransferi(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Clear(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Clear(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ReadBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ReadBuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionParameteri(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModeli(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LightModeli(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ListBase(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ListBase(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ConvolutionParameterf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ConvolutionParameterf(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameteriv(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTableParameteriv(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetColorTableParameterivSGI(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetColorTableParameterivSGI(struct
+                                                               __GLXclientStateRec
+                                                               *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_ReleaseTexImageEXT(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_ReleaseTexImageEXT(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_CallList(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CallList(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_GenerateMipmap(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_GenerateMipmap(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rectiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord1iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex2fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex3sv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetQueryObjectiv(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetQueryObjectiv(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_SetClientInfoARB(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_SetClientInfoARB(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_BindTexImageEXT(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_BindTexImageEXT(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN void __glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalMesh1(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalMesh1(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CompressedTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CompressedTexSubImage3D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex2iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LineWidth(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LineWidth(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexGendv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexGendv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ResetMinmax(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ResetMinmax(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameterfv(struct
+                                                         __GLXclientStateRec *,
+                                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterfv(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetConvolutionParameterfvEXT(struct
+                                                            __GLXclientStateRec
+                                                            *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionParameterfvEXT(struct
+                                                                __GLXclientStateRec
+                                                                *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMaterialfv(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMaterialfv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN void __glXDisp_WindowPos3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_WindowPos3fv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteProgramsARB(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DeleteProgramsARB(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_UseXFont(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_UseXFont(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN void __glXDisp_ShadeModel(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ShadeModel(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Materialfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FogCoordfvEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FogCoordfvEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DrawArrays(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DrawArrays(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SampleCoverage(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SampleCoverage(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color3iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4ubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4ubv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramLocalParameterdvARB(struct
+                                                             __GLXclientStateRec
+                                                             *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramLocalParameterdvARB(struct
+                                                                 __GLXclientStateRec
+                                                                 *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameteriv(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogramParameteriv(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramParameterivEXT(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogramParameterivEXT(struct
+                                                              __GLXclientStateRec
+                                                              *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_PointParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PointParameteriv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rotatef(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rotatef(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetProgramivARB(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetProgramivARB(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN void __glXDisp_BindRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BindRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalPoint2(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalPoint2(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalPoint1(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalPoint1(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PopMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PopMatrix(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_DeleteFramebuffers(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_DeleteFramebuffers(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_MakeCurrentReadSGI(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_MakeCurrentReadSGI(struct __GLXclientStateRec
+                                                      *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetTexGeniv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexGeniv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_MakeCurrent(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_MakeCurrent(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_FramebufferRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FramebufferRenderbuffer(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_IsProgramARB(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsProgramARB(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4uiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Map2d(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Map2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Map2f(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ProgramStringARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ProgramStringARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4bv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4bv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetConvolutionFilter(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionFilter(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetConvolutionFilterEXT(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetConvolutionFilterEXT(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs4dvNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexGenfv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexGenfv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogram(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogram(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetHistogramEXT(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetHistogramEXT(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN void __glXDisp_ActiveStencilFaceEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materialf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Materialf(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Materiali(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Materiali(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Indexsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Indexsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib1fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModelfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LightModelfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord2dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_EvalCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_EvalCoord1dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Translated(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Translated(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Translatef(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Translatef(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_StencilMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_StencilMask(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_CreateWindow(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_CreateWindow(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetLightiv(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetLightiv(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDisp_IsList(struct __GLXclientStateRec *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_IsList(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDisp_RenderMode(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_RenderMode(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_LoadName(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LoadName(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyTexSubImage1D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CullFace(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CullFace(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_QueryContextInfoEXT(struct __GLXclientStateRec *,
+                                                   GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_QueryContextInfoEXT(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttribs2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs2fvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_StencilFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_StencilFunc(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyPixels(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyPixels(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Rectsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rectsv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexParameterfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nubv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_ClipPlane(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ClipPlane(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3usv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3dv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetPixelMapuiv(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetPixelMapuiv(struct __GLXclientStateRec *,
+                                                  GLbyte *);
+extern _X_HIDDEN void __glXDisp_Indexfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Indexfv(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_QueryContext(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_QueryContext(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_BlitFramebuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_BlitFramebuffer(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_IndexMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_IndexMask(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetFloatv(struct __GLXclientStateRec *,
+                                         GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetFloatv(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN void __glXDisp_TexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_FogCoorddv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_FogCoorddv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_PopAttrib(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_PopAttrib(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Fogfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Fogfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_InitNames(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_InitNames(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Normal3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Normal3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Minmax(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Minmax(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_DeleteQueries(struct __GLXclientStateRec *,
+                                             GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_DeleteQueries(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetBooleanv(struct __GLXclientStateRec *,
+                                           GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetBooleanv(struct __GLXclientStateRec *,
+                                               GLbyte *);
+extern _X_HIDDEN void __glXDisp_Hint(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Hint(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Color4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Color4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_CopyColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_CopyColorSubTable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_VertexAttrib3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib3dvNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_TexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_TexCoord4dv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Begin(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Begin(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_ClientInfo(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_ClientInfo(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_Rectfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Rectfv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_LightModelf(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_LightModelf(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetTexParameterfv(struct __GLXclientStateRec *,
+                                                 GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetTexParameterfv(struct __GLXclientStateRec
+                                                     *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetLightfv(struct __GLXclientStateRec *,
+                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetLightfv(struct __GLXclientStateRec *,
+                                              GLbyte *);
+extern _X_HIDDEN void __glXDisp_Disable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Disable(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2fvARB(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_SelectBuffer(struct __GLXclientStateRec *,
+                                            GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_SelectBuffer(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN void __glXDisp_ColorMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_ColorMask(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_RasterPos4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_RasterPos4iv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Enable(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Enable(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GetRenderbufferParameteriv(struct
+                                                          __GLXclientStateRec *,
+                                                          GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetRenderbufferParameteriv(struct
+                                                              __GLXclientStateRec
+                                                              *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttribs4svNV(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttribs4svNV(GLbyte * pc);
+extern _X_HIDDEN int __glXDisp_GenRenderbuffers(struct __GLXclientStateRec *,
+                                                GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GenRenderbuffers(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameterfv(struct __GLXclientStateRec
+                                                    *, GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterfv(struct
+                                                        __GLXclientStateRec *,
+                                                        GLbyte *);
+extern _X_HIDDEN int __glXDisp_GetMinmaxParameterfvEXT(struct
+                                                       __GLXclientStateRec *,
+                                                       GLbyte *);
+extern _X_HIDDEN int __glXDispSwap_GetMinmaxParameterfvEXT(struct
+                                                           __GLXclientStateRec
+                                                           *, GLbyte *);
+extern _X_HIDDEN void __glXDisp_VertexAttrib4Nuiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_VertexAttrib4Nuiv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_Vertex3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_Vertex3fv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_SecondaryColor3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_SecondaryColor3sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDisp_MultiTexCoord2sv(GLbyte * pc);
+extern _X_HIDDEN void __glXDispSwap_MultiTexCoord2sv(GLbyte * pc);
+
+#endif                          /* !defined( _INDIRECT_DISPATCH_H_ ) */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_dispatch.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-common.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-common.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-common.h	(Revision 52145)
@@ -0,0 +1,155 @@
+/**
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a
+ *  copy of this software and associated documentation files (the "Software"),
+ *  to deal in the Software without restriction, including without limitation
+ *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ *  Software is furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice (including the next
+ *  paragraph) shall be included in all copies or substantial portions of the
+ *  Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ *  DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "exevents.h"
+#include <assert.h>
+
+#ifndef PROTOCOL_COMMON_H
+#define PROTOCOL_COMMON_H
+
+/* Check default values in a reply */
+#define reply_check_defaults(rep, len, type) \
+    { \
+        assert((len) >= sz_x##type##Reply); \
+        assert((rep)->repType == X_Reply); \
+        assert((rep)->RepType == X_##type); \
+        assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
+        assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
+    }
+
+/* initialise default values for request */
+#define request_init(req, type) \
+    { \
+        (req)->reqType = 128; /* doesn't matter */ \
+        (req)->ReqType = X_##type; \
+        (req)->length = (sz_x##type##Req >> 2); \
+    }
+
+/* Various defines used in the tests. Some tests may use different values
+ * than these defaults */
+/* default client index */
+#define CLIENT_INDEX            1
+/* default client mask for resources and windows */
+#define CLIENT_MASK             ((CLIENT_INDEX) << CLIENTOFFSET)
+/* default client sequence number for replies */
+#define CLIENT_SEQUENCE         0x100
+/* default root window id */
+#define ROOT_WINDOW_ID          0x10
+/* default client window id */
+#define CLIENT_WINDOW_ID        0x100001
+/* invalid window ID. use for BadWindow checks. */
+#define INVALID_WINDOW_ID       0x111111
+/* initial fake sprite position */
+#define SPRITE_X                100
+#define SPRITE_Y                200
+
+/* Various structs used throughout the tests */
+
+/* The default devices struct, contains one pointer + keyboard and the
+ * matching master devices. Initialize with init_devices() if needed. */
+struct devices {
+    DeviceIntPtr vcp;
+    DeviceIntPtr vck;
+    DeviceIntPtr mouse;
+    DeviceIntPtr kbd;
+
+    int num_devices;
+    int num_master_devices;
+};
+
+/**
+ * The set of default devices available in all tests if necessary.
+ */
+extern struct devices devices;
+
+/**
+ * test-specific userdata, passed into the reply handler.
+ */
+extern void *global_userdata;
+
+/**
+ * The reply handler called from WriteToClient. Set this handler if you need
+ * to check the reply values.
+ */
+void (*reply_handler) (ClientPtr client, int len, char *data, void *userdata);
+
+/**
+ * The default screen used for the windows. Initialized by init_simple().
+ */
+extern ScreenRec screen;
+
+/**
+ * Semi-initialized root window. initialized by init().
+ */
+extern WindowRec root;
+
+/**
+ * Semi-initialized top-level window. initialized by init().
+ */
+extern WindowRec window;
+
+/* various simple functions for quick setup */
+/**
+ * Initialize the above struct with default devices and return the struct.
+ * Usually not needed if you call ::init_simple.
+ */
+struct devices init_devices(void);
+
+/**
+ * Init a mostly zeroed out client with default values for index and mask.
+ */
+ClientRec init_client(int request_len, void *request_data);
+
+/**
+ * Init a mostly zeroed out window with the given window ID.
+ * Usually not needed if you call ::init_simple which sets up root and
+ * window.
+ */
+void init_window(WindowPtr window, WindowPtr parent, int id);
+
+/**
+ * Create a very simple setup that provides the minimum values for most
+ * tests, including a screen, the root and client window and the default
+ * device setup.
+ */
+void init_simple(void);
+
+/* Declarations for various overrides in the test files. */
+void __wrap_WriteToClient(ClientPtr client, int len, void *data);
+int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len,
+                          unsigned char *mask);
+int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client,
+                           Mask access);
+int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client,
+                           Mask access);
+Bool __wrap_AddResource(XID id, RESTYPE type, void *value);
+int __wrap_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
+int __real_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
+
+#endif                          /* PROTOCOL_COMMON_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/protocol-common.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx.h	(Revision 52145)
@@ -0,0 +1,408 @@
+/*
+ * Copyright 2001-2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Main header file included by all other DMX-related files.
+ */
+
+/** \mainpage
+ * - <a href="http://dmx.sourceforge.net">DMX Home Page</a>
+ * - <a href="http://sourceforge.net/projects/dmx">DMX Project Page (on
+ * Source Forge)</a>
+ * - <a href="http://dmx.sourceforge.net/dmx.html">Distributed Multihead
+ * X design</a>, the design document for DMX
+ * - <a href="http://dmx.sourceforge.net/DMXSpec.txt">Client-to-Server
+ * DMX Extension to the X Protocol</a>
+ */
+
+#ifndef DMX_H
+#define DMX_H
+
+#if HAVE_DMX_CONFIG_H
+#include <dmx-config.h>
+#endif
+
+#include "gcstruct.h"
+
+/* Handle client-side include files in one place. */
+#include "dmxclient.h"
+
+#include "globals.h"
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+#ifdef GLXEXT
+#include <GL/glx.h>
+#include <GL/glxint.h>
+#endif
+
+typedef enum {
+    PosNone = -1,
+    PosAbsolute = 0,
+    PosRightOf,
+    PosLeftOf,
+    PosAbove,
+    PosBelow,
+    PosRelative
+} PositionType;
+
+/** Provide the typedef globally, but keep the contents opaque outside
+ * of the input routines.  \see dmxinput.h */
+typedef struct _DMXInputInfo DMXInputInfo;
+
+/** Provide the typedef globally, but keep the contents opaque outside
+ * of the XSync statistic routines.  \see dmxstat.c */
+typedef struct _DMXStatInfo DMXStatInfo;
+
+/** Global structure containing information about each backend screen. */
+typedef struct _DMXScreenInfo {
+    const char *name;             /**< Name from command line or config file */
+    int index;                    /**< Index into dmxScreens global          */
+
+    /*---------- Back-end X server information ----------*/
+
+    Display *beDisplay;           /**< Back-end X server's display */
+    int beWidth;                  /**< Width of BE display */
+    int beHeight;                 /**< Height of BE display */
+    int beDepth;                  /**< Depth of BE display */
+    int beBPP;                    /**< Bits per pixel of BE display */
+    int beXDPI;                   /**< Horizontal dots per inch of BE */
+    int beYDPI;                   /**< Vertical dots per inch of BE */
+
+    int beNumDepths;              /**< Number of depths on BE server */
+    int *beDepths;                /**< Depths from BE server */
+
+    int beNumPixmapFormats;           /**< Number of pixmap formats on BE */
+    XPixmapFormatValues *bePixmapFormats; /**< Pixmap formats on BE */
+
+    int beNumVisuals;             /**< Number of visuals on BE */
+    XVisualInfo *beVisuals;       /**< Visuals from BE server */
+    int beDefVisualIndex;           /**< Default visual index of BE */
+
+    int beNumDefColormaps;           /**< Number of default colormaps */
+    Colormap *beDefColormaps;     /**< Default colormaps for DMX server */
+
+    Pixel beBlackPixel;           /**< Default black pixel for BE */
+    Pixel beWhitePixel;           /**< Default white pixel for BE */
+
+    /*---------- Screen window information ----------*/
+
+    Window scrnWin;               /**< "Screen" window on backend display */
+    int scrnX;                    /**< X offset of "screen" WRT BE display */
+    int scrnY;                    /**< Y offset of "screen" WRT BE display */
+    int scrnWidth;                /**< Width of "screen" */
+    int scrnHeight;               /**< Height of "screen" */
+    int scrnXSign;                /**< X offset sign of "screen" */
+    int scrnYSign;                /**< Y offset sign of "screen" */
+
+                                  /** Default drawables for "screen" */
+    Drawable scrnDefDrawables[MAXFORMATS];
+
+    struct _DMXScreenInfo *next;  /**< List of "screens" on same display */
+    struct _DMXScreenInfo *over;  /**< List of "screens" that overlap */
+
+    /*---------- Root window information ----------*/
+
+    Window rootWin;               /**< "Root" window on backend display */
+    int rootX;                    /**< X offset of "root" window WRT "screen"*/
+    int rootY;                    /**< Y offset of "root" window WRT "screen"*/
+    int rootWidth;                /**< Width of "root" window */
+    int rootHeight;               /**< Height of "root" window */
+
+    int rootXOrigin;              /**< Global X origin of "root" window */
+    int rootYOrigin;              /**< Global Y origin of "root" window */
+
+    /*---------- Shadow framebuffer information ----------*/
+
+    void *shadow;                 /**< Shadow framebuffer data (if enabled) */
+    XlibGC shadowGC;              /**< Default GC used by shadow FB code */
+    XImage *shadowFBImage;        /**< Screen image used by shadow FB code */
+
+    /*---------- Other related information ----------*/
+
+    int shared;                   /**< Non-zero if another Xdmx is running */
+
+    Bool WMRunningOnBE;
+
+    Cursor noCursor;
+    Cursor curCursor;
+    /* Support for cursors on overlapped
+     * backend displays. */
+    CursorPtr cursor;
+    int cursorVisible;
+    int cursorNotShared;        /* for overlapping screens on a backend */
+
+    PositionType where;             /**< Relative layout information */
+    int whereX;                     /**< Relative layout information */
+    int whereY;                     /**< Relative layout information */
+    int whereRefScreen;             /**< Relative layout information */
+
+    int savedTimeout;               /**< Original screen saver timeout */
+    int dpmsCapable;                /**< Non-zero if backend is DPMS capable */
+    int dpmsEnabled;                /**< Non-zero if DPMS enabled */
+    int dpmsStandby;                /**< Original DPMS standby value  */
+    int dpmsSuspend;                /**< Original DPMS suspend value  */
+    int dpmsOff;                    /**< Original DPMS off value  */
+
+    DMXStatInfo *stat;              /**< Statistics about XSync  */
+    Bool needsSync;                 /**< True if an XSync is pending  */
+
+#ifdef GLXEXT
+                                  /** Visual information for glxProxy */
+    int numGlxVisuals;
+    __GLXvisualConfig *glxVisuals;
+    int glxMajorOpcode;
+    int glxErrorBase;
+
+                                  /** FB config information for glxProxy */
+    __GLXFBConfig *fbconfigs;
+    int numFBConfigs;
+#endif
+
+                                    /** Function pointers to wrapped screen
+				     *  functions */
+    CloseScreenProcPtr CloseScreen;
+    SaveScreenProcPtr SaveScreen;
+
+    CreateGCProcPtr CreateGC;
+
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    PositionWindowProcPtr PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    RestackWindowProcPtr RestackWindow;
+    WindowExposuresProcPtr WindowExposures;
+    CopyWindowProcPtr CopyWindow;
+
+    ResizeWindowProcPtr ResizeWindow;
+    ReparentWindowProcPtr ReparentWindow;
+
+    ChangeBorderWidthProcPtr ChangeBorderWidth;
+
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+
+    CreatePixmapProcPtr CreatePixmap;
+    DestroyPixmapProcPtr DestroyPixmap;
+    BitmapToRegionProcPtr BitmapToRegion;
+
+    RealizeFontProcPtr RealizeFont;
+    UnrealizeFontProcPtr UnrealizeFont;
+
+    CreateColormapProcPtr CreateColormap;
+    DestroyColormapProcPtr DestroyColormap;
+    InstallColormapProcPtr InstallColormap;
+    StoreColorsProcPtr StoreColors;
+
+    SetShapeProcPtr SetShape;
+
+    CreatePictureProcPtr CreatePicture;
+    DestroyPictureProcPtr DestroyPicture;
+    ChangePictureClipProcPtr ChangePictureClip;
+    DestroyPictureClipProcPtr DestroyPictureClip;
+
+    ChangePictureProcPtr ChangePicture;
+    ValidatePictureProcPtr ValidatePicture;
+
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+    CompositeRectsProcPtr CompositeRects;
+
+    InitIndexedProcPtr InitIndexed;
+    CloseIndexedProcPtr CloseIndexed;
+    UpdateIndexedProcPtr UpdateIndexed;
+
+    TrapezoidsProcPtr Trapezoids;
+    TrianglesProcPtr Triangles;
+} DMXScreenInfo;
+
+/* Global variables available to all Xserver/hw/dmx routines. */
+extern int dmxNumScreens;                       /**< Number of dmxScreens */
+extern DMXScreenInfo *dmxScreens;               /**< List of outputs */
+extern XErrorEvent dmxLastErrorEvent;           /**< Last error that
+
+                                                 * occurred */
+extern Bool dmxErrorOccurred;                   /**< True if an error
+
+                                                 * occurred */
+extern Bool dmxOffScreenOpt;                    /**< True if using off
+
+                                                 * screen
+                                                 * optimizations */
+extern Bool dmxSubdividePrimitives;             /**< True if using the
+
+                                                 * primitive subdivision
+                                                 * optimization */
+extern Bool dmxLazyWindowCreation;              /**< True if using the
+
+                                                 * lazy window creation
+                                                 * optimization */
+extern Bool dmxUseXKB;                          /**< True if the XKB
+
+                                                 * extension should be
+                                                 * used with the backend
+                                                 * servers */
+extern int dmxDepth;                            /**< Requested depth if
+
+                                                 * non-zero */
+#ifdef GLXEXT
+extern Bool dmxGLXProxy;                        /**< True if glxProxy
+
+						 * support is enabled */
+extern Bool dmxGLXSwapGroupSupport;             /**< True if glxProxy
+
+						 * support for swap
+						 * groups and barriers
+						 * is enabled */
+extern Bool dmxGLXSyncSwap;                     /**< True if glxProxy
+
+						 * should force an XSync
+						 * request after each
+						 * swap buffers call */
+extern Bool dmxGLXFinishSwap;                   /**< True if glxProxy
+
+						 * should force a
+						 * glFinish request
+						 * after each swap
+						 * buffers call */
+#endif
+extern char *dmxFontPath;                       /**< NULL if no font
+
+						 * path is set on the
+						 * command line;
+						 * otherwise, a string
+						 * of comma separated
+						 * paths built from the
+						 * command line
+						 * specified font
+						 * paths */
+extern Bool dmxIgnoreBadFontPaths;              /**< True if bad font
+
+						 * paths should be
+						 * ignored during server
+						 * init */
+extern Bool dmxAddRemoveScreens;                /**< True if add and
+
+						 * remove screens support
+						 * is enabled */
+
+/** Wrap screen or GC function pointer */
+#define DMX_WRAP(_entry, _newfunc, _saved, _actual)			\
+do {									\
+    (_saved)->_entry  = (_actual)->_entry;				\
+    (_actual)->_entry = (_newfunc);					\
+} while (0)
+
+/** Unwrap screen or GC function pointer */
+#define DMX_UNWRAP(_entry, _saved, _actual)				\
+do {									\
+    (_actual)->_entry = (_saved)->_entry;				\
+} while (0)
+
+/* Define the MAXSCREENSALLOC/FREE macros, when MAXSCREENS patch has not
+ * been applied to sources. */
+#ifdef MAXSCREENS
+#define MAXSCREEN_MAKECONSTSTR1(x) #x
+#define MAXSCREEN_MAKECONSTSTR2(x) MAXSCREEN_MAKECONSTSTR1(x)
+
+#define MAXSCREEN_FAILED_TXT "Failed at ["                              \
+   MAXSCREEN_MAKECONSTSTR2(__LINE__) ":" __FILE__ "] to allocate object: "
+
+#define _MAXSCREENSALLOCF(o,size,fatal)                                 \
+    do {                                                                \
+        if (!o) {                                                       \
+            o = calloc((size), sizeof(*(o)));                          \
+            if (!o && fatal) FatalError(MAXSCREEN_FAILED_TXT #o);       \
+        }                                                               \
+    } while (0)
+#define _MAXSCREENSALLOCR(o,size,retval)                                \
+    do {                                                                \
+        if (!o) {                                                       \
+            o = calloc((size), sizeof(*(o)));                          \
+            if (!o) return retval;                                      \
+        }                                                               \
+    } while (0)
+
+#define MAXSCREENSFREE(o)                                               \
+    do {                                                                \
+        free(o);                                                \
+        o = NULL;                                                       \
+    } while (0)
+
+#define MAXSCREENSALLOC(o)              _MAXSCREENSALLOCF(o,MAXSCREENS,  0)
+#define MAXSCREENSALLOC_FATAL(o)        _MAXSCREENSALLOCF(o,MAXSCREENS,  1)
+#define MAXSCREENSALLOC_RETURN(o,r)     _MAXSCREENSALLOCR(o,MAXSCREENS, (r))
+#define MAXSCREENSALLOCPLUSONE(o)       _MAXSCREENSALLOCF(o,MAXSCREENS+1,0)
+#define MAXSCREENSALLOCPLUSONE_FATAL(o) _MAXSCREENSALLOCF(o,MAXSCREENS+1,1)
+#define MAXSCREENSCALLOC(o,m)           _MAXSCREENSALLOCF(o,MAXSCREENS*(m),0)
+#define MAXSCREENSCALLOC_FATAL(o,m)     _MAXSCREENSALLOCF(o,MAXSCREENS*(m),1)
+#endif
+
+extern DevPrivateKeyRec dmxGCPrivateKeyRec;
+
+#define dmxGCPrivateKey (&dmxGCPrivateKeyRec) /**< Private index for GCs       */
+
+extern DevPrivateKeyRec dmxWinPrivateKeyRec;
+
+#define dmxWinPrivateKey (&dmxWinPrivateKeyRec) /**< Private index for Windows   */
+
+extern DevPrivateKeyRec dmxPixPrivateKeyRec;
+
+#define dmxPixPrivateKey (&dmxPixPrivateKeyRec) /**< Private index for Pixmaps   */
+
+extern int dmxFontPrivateIndex;        /**< Private index for Fonts     */
+
+extern DevPrivateKeyRec dmxScreenPrivateKeyRec;
+
+#define dmxScreenPrivateKey (&dmxScreenPrivateKeyRec) /**< Private index for Screens   */
+
+extern DevPrivateKeyRec dmxColormapPrivateKeyRec;
+
+#define dmxColormapPrivateKey (&dmxColormapPrivateKeyRec) /**< Private index for Colormaps */
+
+extern DevPrivateKeyRec dmxPictPrivateKeyRec;
+
+#define dmxPictPrivateKey (&dmxPictPrivateKeyRec) /**< Private index for Picts     */
+
+extern DevPrivateKeyRec dmxGlyphSetPrivateKeyRec;
+
+#define dmxGlyphSetPrivateKey (&dmxGlyphSetPrivateKeyRec) /**< Private index for GlyphSets */
+
+void DMXExtensionInit(void);
+
+#endif                          /* DMX_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gc.h	(Revision 52145)
@@ -0,0 +1,147 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef GC_H
+#define GC_H
+
+#include <X11/X.h>              /* for GContext, Mask */
+#include <X11/Xdefs.h>          /* for Bool */
+#include <X11/Xproto.h>
+#include "screenint.h"          /* for ScreenPtr */
+#include "pixmap.h"             /* for DrawablePtr */
+
+/* clientClipType field in GC */
+#define CT_NONE			0
+#define CT_PIXMAP		1
+#define CT_REGION		2
+#define CT_UNSORTED		6
+#define CT_YSORTED		10
+#define CT_YXSORTED		14
+#define CT_YXBANDED		18
+
+#define GCQREASON_VALIDATE	1
+#define GCQREASON_CHANGE	2
+#define GCQREASON_COPY_SRC	3
+#define GCQREASON_COPY_DST	4
+#define GCQREASON_DESTROY	5
+
+#define GC_CHANGE_SERIAL_BIT        (((unsigned long)1)<<31)
+#define GC_CALL_VALIDATE_BIT        (1L<<30)
+#define GCExtensionInterest   (1L<<29)
+
+#define DRAWABLE_SERIAL_BITS        (~(GC_CHANGE_SERIAL_BIT))
+
+#define MAX_SERIAL_NUM     (1L<<28)
+
+#define NEXT_SERIAL_NUMBER ((++globalSerialNumber) > MAX_SERIAL_NUM ? \
+	    (globalSerialNumber  = 1): globalSerialNumber)
+
+typedef struct _GCInterest *GCInterestPtr;
+typedef struct _GC *GCPtr;
+typedef struct _GCOps *GCOpsPtr;
+
+extern _X_EXPORT void ValidateGC(DrawablePtr /*pDraw */ ,
+                                 GCPtr /*pGC */ );
+
+typedef union {
+    CARD32 val;
+    void *ptr;
+} ChangeGCVal, *ChangeGCValPtr;
+
+extern int ChangeGCXIDs(ClientPtr /*client */ ,
+                        GCPtr /*pGC */ ,
+                        BITS32 /*mask */ ,
+                        CARD32 * /*pval */ );
+
+extern _X_EXPORT int ChangeGC(ClientPtr /*client */ ,
+                              GCPtr /*pGC */ ,
+                              BITS32 /*mask */ ,
+                              ChangeGCValPtr /*pCGCV */ );
+
+extern _X_EXPORT GCPtr CreateGC(DrawablePtr /*pDrawable */ ,
+                                BITS32 /*mask */ ,
+                                XID * /*pval */ ,
+                                int * /*pStatus */ ,
+                                XID /*gcid */ ,
+                                ClientPtr /*client */ );
+
+extern _X_EXPORT int CopyGC(GCPtr /*pgcSrc */ ,
+                            GCPtr /*pgcDst */ ,
+                            BITS32 /*mask */ );
+
+extern _X_EXPORT int FreeGC(void */*pGC */ ,
+                            XID /*gid */ );
+
+extern _X_EXPORT void FreeGCperDepth(int /*screenNum */ );
+
+extern _X_EXPORT Bool CreateGCperDepth(int /*screenNum */ );
+
+extern _X_EXPORT Bool CreateDefaultStipple(int /*screenNum */ );
+
+extern _X_EXPORT void FreeDefaultStipple(int /*screenNum */ );
+
+extern _X_EXPORT int SetDashes(GCPtr /*pGC */ ,
+                               unsigned /*offset */ ,
+                               unsigned /*ndash */ ,
+                               unsigned char * /*pdash */ );
+
+extern _X_EXPORT int VerifyRectOrder(int /*nrects */ ,
+                                     xRectangle * /*prects */ ,
+                                     int /*ordering */ );
+
+extern _X_EXPORT int SetClipRects(GCPtr /*pGC */ ,
+                                  int /*xOrigin */ ,
+                                  int /*yOrigin */ ,
+                                  int /*nrects */ ,
+                                  xRectangle * /*prects */ ,
+                                  int /*ordering */ );
+
+extern _X_EXPORT GCPtr GetScratchGC(unsigned /*depth */ ,
+                                    ScreenPtr /*pScreen */ );
+
+extern _X_EXPORT void FreeScratchGC(GCPtr /*pGC */ );
+
+#endif                          /* GC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/gc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxlog.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxlog.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxlog.h	(Revision 52145)
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * This header is included by all files that need to use the DMX logging
+ * facilities. */
+
+#ifndef _DMXLOG_H_
+#define _DMXLOG_H_
+
+/** Logging levels -- output is tunable with #dmxSetLogLevel. */
+typedef enum {
+    dmxDebug,                   /**< Usually verbose debugging info */
+    dmxInfo,                    /**< Non-warning information */
+    dmxWarning,                 /**< A warning that may indicate DMX
+                                 * will not function as the user
+                                 * intends. */
+    dmxError,                   /**< A non-fatal error that probably
+                                 * indicates DMX will not function as
+                                 * desired.*/
+    dmxFatal                    /**< A fatal error that will cause DMX
+                                 * to shut down. */
+} dmxLogLevel;
+
+/* Logging functions used by Xserver/hw/dmx routines. */
+extern dmxLogLevel dmxSetLogLevel(dmxLogLevel newLevel);
+extern dmxLogLevel dmxGetLogLevel(void);
+extern void dmxLog(dmxLogLevel logLevel, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogCont(dmxLogLevel logLevel, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern const char *dmxEventName(int type);
+
+#ifndef DMX_LOG_STANDALONE
+extern void dmxLogOutput(DMXScreenInfo * dmxScreen, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogOutputCont(DMXScreenInfo * dmxScreen, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogOutputWarning(DMXScreenInfo * dmxScreen, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogInput(DMXInputInfo * dmxInput, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogInputCont(DMXInputInfo * dmxInput, const char *format,
+                             ...) _X_ATTRIBUTE_PRINTF(2, 3);
+extern void dmxLogArgs(dmxLogLevel logLevel, int argc, char **argv);
+extern void dmxLogVisual(DMXScreenInfo * dmxScreen, XVisualInfo * vi,
+                         int defaultVisual);
+extern const char *dmxXInputEventName(int type);
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxlog.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misc.h	(Revision 52145)
@@ -0,0 +1,451 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+Copyright 1992, 1993 Data General Corporation;
+Copyright 1992, 1993 OMRON Corporation  
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that the
+above copyright notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting documentation, and that
+neither the name OMRON or DATA GENERAL be used in advertising or publicity
+pertaining to distribution of the software without specific, written prior
+permission of the party whose name is to be used.  Neither OMRON or 
+DATA GENERAL make any representation about the suitability of this software
+for any purpose.  It is provided "as is" without express or implied warranty.  
+
+OMRON AND DATA GENERAL EACH DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+IN NO EVENT SHALL OMRON OR DATA GENERAL BE LIABLE FOR ANY SPECIAL, INDIRECT
+OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+OF THIS SOFTWARE.
+
+******************************************************************/
+#ifndef MISC_H
+#define MISC_H 1
+/*
+ *  X internal definitions 
+ *
+ */
+
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xmd.h>
+#include <X11/X.h>
+#include <X11/Xdefs.h>
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifndef MAXSCREENS
+#define MAXSCREENS	16
+#endif
+#ifndef MAXGPUSCREENS
+#define MAXGPUSCREENS	16
+#endif
+#define MAXCLIENTS	256
+#define MAXEXTENSIONS   128
+#define MAXFORMATS	8
+#define MAXDEVICES	40      /* input devices */
+#define GPU_SCREEN_OFFSET 256
+
+/* 128 event opcodes for core + extension events, excluding GE */
+#define MAXEVENTS       128
+#define EXTENSION_EVENT_BASE 64
+#define EXTENSION_BASE 128
+
+typedef uint32_t ATOM;
+
+#ifndef TRUE
+#define TRUE 1
+#define FALSE 0
+#endif
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr;  /* also in dix.h */
+
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef struct _xReq *xReqPtr;
+
+#include "os.h"                 /* for ALLOCATE_LOCAL and DEALLOCATE_LOCAL */
+#include <X11/Xfuncs.h>         /* for bcopy, bzero, and bcmp */
+
+#define NullBox ((BoxPtr)0)
+#define MILLI_PER_MIN (1000 * 60)
+#define MILLI_PER_SECOND (1000)
+
+    /* this next is used with None and ParentRelative to tell
+       PaintWin() what to use to paint the background. Also used
+       in the macro IS_VALID_PIXMAP */
+
+#define USE_BACKGROUND_PIXEL 3
+#define USE_BORDER_PIXEL 3
+
+/* byte swap a 32-bit literal */
+static inline uint32_t
+lswapl(uint32_t x)
+{
+    return ((x & 0xff) << 24) |
+        ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | ((x >> 24) & 0xff);
+}
+
+/* byte swap a 16-bit literal */
+static inline uint16_t
+lswaps(uint16_t x)
+{
+    return ((x & 0xff) << 8) | ((x >> 8) & 0xff);
+}
+
+#undef min
+#undef max
+
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#define max(a, b) (((a) > (b)) ? (a) : (b))
+/* abs() is a function, not a macro; include the file declaring
+ * it in case we haven't done that yet.
+ */
+#include <stdlib.h>
+#define sign(x) ((x) < 0 ? -1 : ((x) > 0 ? 1 : 0))
+/* this assumes b > 0 */
+#define modulus(a, b, d)    if (((d) = (a) % (b)) < 0) (d) += (b)
+/*
+ * return the least significant bit in x which is set
+ *
+ * This works on 1's complement and 2's complement machines.
+ * If you care about the extra instruction on 2's complement
+ * machines, change to ((x) & (-(x)))
+ */
+#define lowbit(x) ((x) & (~(x) + 1))
+
+/* XXX Not for modules */
+#include <limits.h>
+#if !defined(MAXSHORT) || !defined(MINSHORT) || \
+    !defined(MAXINT) || !defined(MININT)
+/*
+ * Some implementations #define these through <math.h>, so preclude
+ * #include'ing it later.
+ */
+
+#include <math.h>
+#undef MAXSHORT
+#define MAXSHORT SHRT_MAX
+#undef MINSHORT
+#define MINSHORT SHRT_MIN
+#undef MAXINT
+#define MAXINT INT_MAX
+#undef MININT
+#define MININT INT_MIN
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdio.h>              /* for fopen, etc... */
+
+#endif
+
+#ifndef PATH_MAX
+#include <sys/param.h>
+#ifndef PATH_MAX
+#ifdef MAXPATHLEN
+#define PATH_MAX MAXPATHLEN
+#else
+#define PATH_MAX 1024
+#endif
+#endif
+#endif
+
+/**
+ * Calculate the number of bytes needed to hold bits.
+ * @param bits The minimum number of bits needed.
+ * @return The number of bytes needed to hold bits.
+ */
+static inline int
+bits_to_bytes(const int bits)
+{
+    return ((bits + 7) >> 3);
+}
+
+/**
+ * Calculate the number of 4-byte units needed to hold the given number of
+ * bytes.
+ * @param bytes The minimum number of bytes needed.
+ * @return The number of 4-byte units needed to hold bytes.
+ */
+static inline int
+bytes_to_int32(const int bytes)
+{
+    return (((bytes) + 3) >> 2);
+}
+
+/**
+ * Calculate the number of bytes (in multiples of 4) needed to hold bytes.
+ * @param bytes The minimum number of bytes needed.
+ * @return The closest multiple of 4 that is equal or higher than bytes.
+ */
+static inline int
+pad_to_int32(const int bytes)
+{
+    return (((bytes) + 3) & ~3);
+}
+
+/**
+ * Calculate padding needed to bring the number of bytes to an even
+ * multiple of 4.
+ * @param bytes The minimum number of bytes needed.
+ * @return The bytes of padding needed to arrive at the closest multiple of 4
+ * that is equal or higher than bytes.
+ */
+static inline int
+padding_for_int32(const int bytes)
+{
+    return ((-bytes) & 3);
+}
+
+
+extern char **xstrtokenize(const char *str, const char *separators);
+extern void FormatInt64(int64_t num, char *string);
+extern void FormatUInt64(uint64_t num, char *string);
+extern void FormatUInt64Hex(uint64_t num, char *string);
+extern void FormatDouble(double dbl, char *string);
+
+/**
+ * Compare the two version numbers comprising of major.minor.
+ *
+ * @return A value less than 0 if a is less than b, 0 if a is equal to b,
+ * or a value greater than 0
+ */
+static inline int
+version_compare(uint32_t a_major, uint32_t a_minor,
+                uint32_t b_major, uint32_t b_minor)
+{
+    if (a_major > b_major)
+        return 1;
+    if (a_major < b_major)
+        return -1;
+    if (a_minor > b_minor)
+        return 1;
+    if (a_minor < b_minor)
+        return -1;
+
+    return 0;
+}
+
+/* some macros to help swap requests, replies, and events */
+
+#define LengthRestB(stuff) \
+    ((client->req_len << 2) - sizeof(*stuff))
+
+#define LengthRestS(stuff) \
+    ((client->req_len << 1) - (sizeof(*stuff) >> 1))
+
+#define LengthRestL(stuff) \
+    (client->req_len - (sizeof(*stuff) >> 2))
+
+#define SwapRestS(stuff) \
+    SwapShorts((short *)(stuff + 1), LengthRestS(stuff))
+
+#define SwapRestL(stuff) \
+    SwapLongs((CARD32 *)(stuff + 1), LengthRestL(stuff))
+
+#if defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
+void __attribute__ ((error("wrong sized variable passed to swap")))
+wrong_size(void);
+#else
+static inline void
+wrong_size(void)
+{
+}
+#endif
+
+#if !(defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)))
+static inline int
+__builtin_constant_p(int x)
+{
+    return 0;
+}
+#endif
+
+/* byte swap a 64-bit value */
+static inline void
+swap_uint64(uint64_t *x)
+{
+    char n;
+
+    n = ((char *) x)[0];
+    ((char *) x)[0] = ((char *) x)[7];
+    ((char *) x)[7] = n;
+
+    n = ((char *) x)[1];
+    ((char *) x)[1] = ((char *) x)[6];
+    ((char *) x)[6] = n;
+
+    n = ((char *) x)[2];
+    ((char *) x)[2] = ((char *) x)[5];
+    ((char *) x)[5] = n;
+
+    n = ((char *) x)[3];
+    ((char *) x)[3] = ((char *) x)[4];
+    ((char *) x)[4] = n;
+}
+
+#define swapll(x) do { \
+		if (sizeof(*(x)) != 8) \
+			wrong_size(); \
+                swap_uint64((uint64_t *)(x));   \
+	} while (0)
+
+/* byte swap a 32-bit value */
+static inline void
+swap_uint32(uint32_t * x)
+{
+    char n = ((char *) x)[0];
+
+    ((char *) x)[0] = ((char *) x)[3];
+    ((char *) x)[3] = n;
+    n = ((char *) x)[1];
+    ((char *) x)[1] = ((char *) x)[2];
+    ((char *) x)[2] = n;
+}
+
+#define swapl(x) do { \
+		if (sizeof(*(x)) != 4) \
+			wrong_size(); \
+		if (__builtin_constant_p((uintptr_t)(x) & 3) && ((uintptr_t)(x) & 3) == 0) \
+			*(x) = lswapl(*(x)); \
+		else \
+			swap_uint32((uint32_t *)(x)); \
+	} while (0)
+
+/* byte swap a 16-bit value */
+static inline void
+swap_uint16(uint16_t * x)
+{
+    char n = ((char *) x)[0];
+
+    ((char *) x)[0] = ((char *) x)[1];
+    ((char *) x)[1] = n;
+}
+
+#define swaps(x) do { \
+		if (sizeof(*(x)) != 2) \
+			wrong_size(); \
+		if (__builtin_constant_p((uintptr_t)(x) & 1) && ((uintptr_t)(x) & 1) == 0) \
+			*(x) = lswaps(*(x)); \
+		else \
+			swap_uint16((uint16_t *)(x)); \
+	} while (0)
+
+/* copy 32-bit value from src to dst byteswapping on the way */
+#define cpswapl(src, dst) do { \
+		if (sizeof((src)) != 4 || sizeof((dst)) != 4) \
+			wrong_size(); \
+		(dst) = lswapl((src)); \
+	} while (0)
+
+/* copy short from src to dst byteswapping on the way */
+#define cpswaps(src, dst) do { \
+		if (sizeof((src)) != 2 || sizeof((dst)) != 2) \
+			wrong_size(); \
+		(dst) = lswaps((src)); \
+	} while (0)
+
+extern _X_EXPORT void SwapLongs(CARD32 *list, unsigned long count);
+
+extern _X_EXPORT void SwapShorts(short *list, unsigned long count);
+
+extern _X_EXPORT void MakePredeclaredAtoms(void);
+
+extern _X_EXPORT int Ones(unsigned long /*mask */ );
+
+typedef struct _xPoint *DDXPointPtr;
+typedef struct pixman_box16 *BoxPtr;
+typedef struct _xEvent *xEventPtr;
+typedef struct _xRectangle *xRectanglePtr;
+typedef struct _GrabRec *GrabPtr;
+
+/*  typedefs from other places - duplicated here to minimize the amount
+ *  of unnecessary junk that one would normally have to include to get
+ *  these symbols defined
+ */
+
+#ifndef _XTYPEDEF_CHARINFOPTR
+typedef struct _CharInfo *CharInfoPtr;  /* also in fonts/include/font.h */
+
+#define _XTYPEDEF_CHARINFOPTR
+#endif
+
+extern _X_EXPORT unsigned long globalSerialNumber;
+extern _X_EXPORT unsigned long serverGeneration;
+
+/* Don't use this directly, use BUG_WARN or BUG_WARN_MSG instead */
+#define __BUG_WARN_MSG(cond, with_msg, ...)                                \
+          do { if (cond) {                                                \
+              ErrorFSigSafe("BUG: triggered 'if (" #cond ")'\n");          \
+              ErrorFSigSafe("BUG: %s:%u in %s()\n",                        \
+                           __FILE__, __LINE__, __func__);                 \
+              if (with_msg) ErrorFSigSafe(__VA_ARGS__);                    \
+              xorg_backtrace();                                           \
+          } } while(0)
+
+#define BUG_WARN_MSG(cond, ...)                                           \
+          __BUG_WARN_MSG(cond, 1, __VA_ARGS__)
+
+#define BUG_WARN(cond)  __BUG_WARN_MSG(cond, 0, NULL)
+
+#define BUG_RETURN(cond) \
+        do { if (cond) { __BUG_WARN_MSG(cond, 0, NULL); return; } } while(0)
+
+#define BUG_RETURN_MSG(cond, ...) \
+        do { if (cond) { __BUG_WARN_MSG(cond, 1, __VA_ARGS__); return; } } while(0)
+
+#define BUG_RETURN_VAL(cond, val) \
+        do { if (cond) { __BUG_WARN_MSG(cond, 0, NULL); return (val); } } while(0)
+
+#define BUG_RETURN_VAL_MSG(cond, val, ...) \
+        do { if (cond) { __BUG_WARN_MSG(cond, 1, __VA_ARGS__); return (val); } } while(0)
+
+#endif                          /* MISC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misprite.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misprite.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misprite.h	(Revision 52145)
@@ -0,0 +1,48 @@
+/*
+ * misprite.h
+ *
+ * software-sprite/sprite drawing interface spec
+ *
+ * mi versions of these routines exist.
+ */
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+extern Bool miSpriteInitialize(ScreenPtr /*pScreen */ ,
+                               miPointerScreenFuncPtr   /*screenFuncs */
+    );
+
+extern Bool miDCRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool miDCUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool miDCPutUpCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                            CursorPtr pCursor, int x, int y,
+                            unsigned long source, unsigned long mask);
+extern Bool miDCSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                int x, int y, int w, int h);
+extern Bool miDCRestoreUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                   int x, int y, int w, int h);
+extern Bool miDCDeviceInitialize(DeviceIntPtr pDev, ScreenPtr pScreen);
+extern void miDCDeviceCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misprite.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86cmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86cmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86cmap.h	(Revision 52145)
@@ -0,0 +1,67 @@
+
+/*
+ * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86CMAP_H
+#define _XF86CMAP_H
+
+#include "xf86str.h"
+#include "colormapst.h"
+
+#define CMAP_PALETTED_TRUECOLOR		0x0000001
+#define CMAP_RELOAD_ON_MODE_SWITCH	0x0000002
+#define CMAP_LOAD_EVEN_IF_OFFSCREEN	0x0000004
+
+extern _X_EXPORT Bool xf86HandleColormaps(ScreenPtr pScreen,
+                                          int maxCol,
+                                          int sigRGBbits,
+                                          xf86LoadPaletteProc * loadPalette,
+                                          xf86SetOverscanProc * setOverscan,
+                                          unsigned int flags);
+
+extern _X_EXPORT Bool xf86ColormapAllocatePrivates(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT int
+ xf86ChangeGamma(ScreenPtr pScreen, Gamma newGamma);
+
+extern _X_EXPORT int
+
+xf86ChangeGammaRamp(ScreenPtr pScreen,
+                    int size,
+                    unsigned short *red,
+                    unsigned short *green, unsigned short *blue);
+
+extern _X_EXPORT int xf86GetGammaRampSize(ScreenPtr pScreen);
+
+extern _X_EXPORT int
+
+xf86GetGammaRamp(ScreenPtr pScreen,
+                 int size,
+                 unsigned short *red,
+                 unsigned short *green, unsigned short *blue);
+
+#endif                          /* _XF86CMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86cmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadowfb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadowfb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadowfb.h	(Revision 52145)
@@ -0,0 +1,39 @@
+
+#ifndef _SHADOWFB_H
+#define _SHADOWFB_H
+
+#include "xf86str.h"
+
+/*
+ * User defined callback function.  Passed a pointer to the ScrnInfo struct,
+ * the number of dirty rectangles, and a pointer to the first dirty rectangle
+ * in the array.
+ */
+typedef void (*RefreshAreaFuncPtr) (ScrnInfoPtr, int, BoxPtr);
+
+/*
+ * ShadowFBInit initializes the shadowfb subsystem.  refreshArea is a pointer
+ * to a user supplied callback function.  This function will be called after
+ * any operation that modifies the framebuffer.  The newly dirtied rectangles
+ * are passed to the callback.
+ *
+ * Returns FALSE in the event of an error.
+ */
+extern _X_EXPORT Bool
+ ShadowFBInit(ScreenPtr pScreen, RefreshAreaFuncPtr refreshArea);
+
+/*
+ * ShadowFBInit2 is a more featureful refinement of the original shadowfb.
+ * ShadowFBInit2 allows you to specify two callbacks, one to be called
+ * immediately before an operation that modifies the framebuffer, and another
+ * to be called immediately after.  
+ *
+ * Returns FALSE in the event of an error
+ */
+extern _X_EXPORT Bool
+
+ShadowFBInit2(ScreenPtr pScreen,
+              RefreshAreaFuncPtr preRefreshArea,
+              RefreshAreaFuncPtr postRefreshArea);
+
+#endif                          /* _SHADOWFB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadowfb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setdval.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setdval.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setdval.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETDVAL_H
+#define SETDVAL_H 1
+
+int SProcXSetDeviceValuators(ClientPtr  /* client */
+    );
+
+int ProcXSetDeviceValuators(ClientPtr   /* client */
+    );
+
+void SRepXSetDeviceValuators(ClientPtr /* client */ ,
+                             int /* size */ ,
+                             xSetDeviceValuatorsReply * /* rep */
+    );
+
+#endif                          /* SETDVAL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setdval.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDacPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDacPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDacPriv.h	(Revision 52145)
@@ -0,0 +1,13 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86RamDac.h"
+#include "xf86cmap.h"
+
+void RamDacGetRecPrivate(void);
+Bool RamDacGetRec(ScrnInfoPtr pScrn);
+int RamDacGetScreenIndex(void);
+void RamDacLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
+                       LOCO * colors, VisualPtr pVisual);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDacPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXh.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXh.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXh.h	(Revision 52145)
@@ -0,0 +1,73 @@
+
+/*
+ *	Server dispatcher function replacements
+ */
+
+extern int PanoramiXCreateWindow(ClientPtr client);
+extern int PanoramiXChangeWindowAttributes(ClientPtr client);
+extern int PanoramiXDestroyWindow(ClientPtr client);
+extern int PanoramiXDestroySubwindows(ClientPtr client);
+extern int PanoramiXChangeSaveSet(ClientPtr client);
+extern int PanoramiXReparentWindow(ClientPtr client);
+extern int PanoramiXMapWindow(ClientPtr client);
+extern int PanoramiXMapSubwindows(ClientPtr client);
+extern int PanoramiXUnmapWindow(ClientPtr client);
+extern int PanoramiXUnmapSubwindows(ClientPtr client);
+extern int PanoramiXConfigureWindow(ClientPtr client);
+extern int PanoramiXCirculateWindow(ClientPtr client);
+extern int PanoramiXGetGeometry(ClientPtr client);
+extern int PanoramiXTranslateCoords(ClientPtr client);
+extern int PanoramiXCreatePixmap(ClientPtr client);
+extern int PanoramiXFreePixmap(ClientPtr client);
+extern int PanoramiXChangeGC(ClientPtr client);
+extern int PanoramiXCopyGC(ClientPtr client);
+extern int PanoramiXCopyColormapAndFree(ClientPtr client);
+extern int PanoramiXCreateGC(ClientPtr client);
+extern int PanoramiXSetDashes(ClientPtr client);
+extern int PanoramiXSetClipRectangles(ClientPtr client);
+extern int PanoramiXFreeGC(ClientPtr client);
+extern int PanoramiXClearToBackground(ClientPtr client);
+extern int PanoramiXCopyArea(ClientPtr client);
+extern int PanoramiXCopyPlane(ClientPtr client);
+extern int PanoramiXPolyPoint(ClientPtr client);
+extern int PanoramiXPolyLine(ClientPtr client);
+extern int PanoramiXPolySegment(ClientPtr client);
+extern int PanoramiXPolyRectangle(ClientPtr client);
+extern int PanoramiXPolyArc(ClientPtr client);
+extern int PanoramiXFillPoly(ClientPtr client);
+extern int PanoramiXPolyFillArc(ClientPtr client);
+extern int PanoramiXPolyFillRectangle(ClientPtr client);
+extern int PanoramiXPutImage(ClientPtr client);
+extern int PanoramiXGetImage(ClientPtr client);
+extern int PanoramiXPolyText8(ClientPtr client);
+extern int PanoramiXPolyText16(ClientPtr client);
+extern int PanoramiXImageText8(ClientPtr client);
+extern int PanoramiXImageText16(ClientPtr client);
+extern int PanoramiXCreateColormap(ClientPtr client);
+extern int PanoramiXFreeColormap(ClientPtr client);
+extern int PanoramiXInstallColormap(ClientPtr client);
+extern int PanoramiXUninstallColormap(ClientPtr client);
+extern int PanoramiXAllocColor(ClientPtr client);
+extern int PanoramiXAllocNamedColor(ClientPtr client);
+extern int PanoramiXAllocColorCells(ClientPtr client);
+extern int PanoramiXStoreNamedColor(ClientPtr client);
+extern int PanoramiXFreeColors(ClientPtr client);
+extern int PanoramiXStoreColors(ClientPtr client);
+extern int PanoramiXAllocColorPlanes(ClientPtr client);
+
+#define PROC_EXTERN(pfunc)      extern int pfunc(ClientPtr)
+
+PROC_EXTERN(ProcPanoramiXQueryVersion);
+PROC_EXTERN(ProcPanoramiXGetState);
+PROC_EXTERN(ProcPanoramiXGetScreenCount);
+PROC_EXTERN(ProcPanoramiXGetScreenSize);
+
+PROC_EXTERN(ProcXineramaQueryScreens);
+PROC_EXTERN(ProcXineramaIsActive);
+
+extern int SProcPanoramiXDispatch(ClientPtr client);
+
+extern int connBlockScreenStart;
+extern xConnSetupPrefix connSetupPrefix;
+
+extern int (*SavedProcVector[256]) (ClientPtr client);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXh.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixaccess.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixaccess.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixaccess.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_ACCESS_H
+#define DIX_ACCESS_H
+
+/* These are the access modes that can be passed in the last parameter
+ * to several of the dix lookup functions.  They were originally part
+ * of the Security extension, now used by XACE.
+ *
+ * You can or these values together to indicate multiple modes
+ * simultaneously.
+ */
+
+#define DixUnknownAccess	0       /* don't know intentions */
+#define DixReadAccess		(1<<0)  /* inspecting the object */
+#define DixWriteAccess		(1<<1)  /* changing the object */
+#define DixDestroyAccess	(1<<2)  /* destroying the object */
+#define DixCreateAccess		(1<<3)  /* creating the object */
+#define DixGetAttrAccess	(1<<4)  /* get object attributes */
+#define DixSetAttrAccess	(1<<5)  /* set object attributes */
+#define DixListPropAccess	(1<<6)  /* list properties of object */
+#define DixGetPropAccess	(1<<7)  /* get properties of object */
+#define DixSetPropAccess	(1<<8)  /* set properties of object */
+#define DixGetFocusAccess	(1<<9)  /* get focus of object */
+#define DixSetFocusAccess	(1<<10) /* set focus of object */
+#define DixListAccess		(1<<11) /* list objects */
+#define DixAddAccess		(1<<12) /* add object */
+#define DixRemoveAccess		(1<<13) /* remove object */
+#define DixHideAccess		(1<<14) /* hide object */
+#define DixShowAccess		(1<<15) /* show object */
+#define DixBlendAccess		(1<<16) /* mix contents of objects */
+#define DixGrabAccess		(1<<17) /* exclusive access to object */
+#define DixFreezeAccess		(1<<18) /* freeze status of object */
+#define DixForceAccess		(1<<19) /* force status of object */
+#define DixInstallAccess	(1<<20) /* install object */
+#define DixUninstallAccess	(1<<21) /* uninstall object */
+#define DixSendAccess		(1<<22) /* send to object */
+#define DixReceiveAccess	(1<<23) /* receive from object */
+#define DixUseAccess		(1<<24) /* use object */
+#define DixManageAccess		(1<<25) /* manage object */
+#define DixDebugAccess		(1<<26) /* debug object */
+#define DixBellAccess		(1<<27) /* audible sound */
+#define DixPostAccess		(1<<28) /* post or follow-up call */
+
+#endif                          /* DIX_ACCESS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixaccess.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9885.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9885.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9885.h	(Revision 52145)
@@ -0,0 +1,63 @@
+#ifndef __TDA9885_H__
+#define __TDA9885_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    I2CDevRec d;
+
+    /* write-only parameters */
+    /* B DATA */
+    CARD8 sound_trap;
+    CARD8 auto_mute_fm;
+    CARD8 carrier_mode;
+    CARD8 modulation;
+    CARD8 forced_mute_audio;
+    CARD8 port1;
+    CARD8 port2;
+    /* C DATA */
+    CARD8 top_adjustment;
+    CARD8 deemphasis;
+    CARD8 audio_gain;
+    /* E DATA */
+    CARD8 standard_sound_carrier;
+    CARD8 standard_video_if;
+    CARD8 minimum_gain;
+    CARD8 gating;
+    CARD8 vif_agc;
+    /* read-only values */
+
+    CARD8 after_reset;
+    CARD8 afc_status;
+    CARD8 vif_level;
+    CARD8 afc_win;
+    CARD8 fm_carrier;
+} TDA9885Rec, *TDA9885Ptr;
+
+#define TDA9885_ADDR_1   0x86
+#define TDA9885_ADDR_2   0x84
+#define TDA9885_ADDR_3   0x96
+#define TDA9885_ADDR_4   0x94
+
+#define xf86_Detect_tda9885		Detect_tda9885
+extern _X_EXPORT TDA9885Ptr Detect_tda9885(I2CBusPtr b, I2CSlaveAddr addr);
+
+#define xf86_tda9885_init		tda9885_init
+extern _X_EXPORT Bool tda9885_init(TDA9885Ptr t);
+
+#define xf86_tda9885_setparameters	tda9885_setparameters
+extern _X_EXPORT void tda9885_setparameters(TDA9885Ptr t);
+
+#define xf86_tda9885_getstatus		tda9885_getstatus
+extern _X_EXPORT void tda9885_getstatus(TDA9885Ptr t);
+
+#define xf86_tda9885_dumpstatus		tda9885_dumpstatus
+extern _X_EXPORT void tda9885_dumpstatus(TDA9885Ptr t);
+
+#define TDA9885SymbolsList  \
+		"Detect_tda9885", \
+		"tda9885_init", \
+		"tda9885_setaudio", \
+		"tda9885_mute"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda9885.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixevents.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixevents.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixevents.h	(Revision 52145)
@@ -0,0 +1,80 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXEVENTS_H
+#define DIXEVENTS_H
+
+extern _X_EXPORT void SetCriticalEvent(int /* event */ );
+
+extern _X_EXPORT CursorPtr GetSpriteCursor(DeviceIntPtr /*pDev */ );
+
+extern _X_EXPORT int ProcAllowEvents(ClientPtr /* client */ );
+
+extern _X_EXPORT int MaybeDeliverEventsToClient(WindowPtr /* pWin */ ,
+                                                xEvent * /* pEvents */ ,
+                                                int /* count */ ,
+                                                Mask /* filter */ ,
+                                                ClientPtr /* dontClient */ );
+
+extern _X_EXPORT int ProcWarpPointer(ClientPtr /* client */ );
+
+extern _X_EXPORT int EventSelectForWindow(WindowPtr /* pWin */ ,
+                                          ClientPtr /* client */ ,
+                                          Mask /* mask */ );
+
+extern _X_EXPORT int EventSuppressForWindow(WindowPtr /* pWin */ ,
+                                            ClientPtr /* client */ ,
+                                            Mask /* mask */ ,
+                                            Bool * /* checkOptional */ );
+
+extern _X_EXPORT int ProcSetInputFocus(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcGetInputFocus(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcGrabPointer(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcChangeActivePointerGrab(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcUngrabPointer(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcGrabKeyboard(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcUngrabKeyboard(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcQueryPointer(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcSendEvent(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcUngrabKey(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcGrabKey(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcGrabButton(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcUngrabButton(ClientPtr /* client */ );
+
+extern _X_EXPORT int ProcRecolorCursor(ClientPtr /* client */ );
+
+#endif                          /* DIXEVENTS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixevents.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xv.h	(Revision 52145)
@@ -0,0 +1,266 @@
+
+/*
+ * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XV_H_
+#define _XF86XV_H_
+
+#include "xvdix.h"
+#include "xf86str.h"
+
+#define VIDEO_NO_CLIPPING			0x00000001
+#define VIDEO_INVERT_CLIPLIST			0x00000002
+#define VIDEO_OVERLAID_IMAGES			0x00000004
+#define VIDEO_OVERLAID_STILLS			0x00000008
+/*
+ * Usage of VIDEO_CLIP_TO_VIEWPORT is not recommended.
+ * It can make reput behaviour inconsistent.
+ */
+#define VIDEO_CLIP_TO_VIEWPORT			0x00000010
+
+typedef struct {
+    int id;
+    int type;
+    int byte_order;
+    unsigned char guid[16];
+    int bits_per_pixel;
+    int format;
+    int num_planes;
+
+    /* for RGB formats only */
+    int depth;
+    unsigned int red_mask;
+    unsigned int green_mask;
+    unsigned int blue_mask;
+
+    /* for YUV formats only */
+    unsigned int y_sample_bits;
+    unsigned int u_sample_bits;
+    unsigned int v_sample_bits;
+    unsigned int horz_y_period;
+    unsigned int horz_u_period;
+    unsigned int horz_v_period;
+    unsigned int vert_y_period;
+    unsigned int vert_u_period;
+    unsigned int vert_v_period;
+    char component_order[32];
+    int scanline_order;
+} XF86ImageRec, *XF86ImagePtr;
+
+typedef struct {
+    ScrnInfoPtr pScrn;
+    int id;
+    unsigned short width, height;
+    int *pitches;               /* bytes */
+    int *offsets;               /* in bytes from start of framebuffer */
+    DevUnion devPrivate;
+} XF86SurfaceRec, *XF86SurfacePtr;
+
+typedef int (*PutVideoFuncPtr) (ScrnInfoPtr pScrn,
+                                short vid_x, short vid_y, short drw_x,
+                                short drw_y, short vid_w, short vid_h,
+                                short drw_w, short drw_h, RegionPtr clipBoxes,
+                                void *data, DrawablePtr pDraw);
+typedef int (*PutStillFuncPtr) (ScrnInfoPtr pScrn, short vid_x, short vid_y,
+                                short drw_x, short drw_y, short vid_w,
+                                short vid_h, short drw_w, short drw_h,
+                                RegionPtr clipBoxes, void *data,
+                                DrawablePtr pDraw);
+typedef int (*GetVideoFuncPtr) (ScrnInfoPtr pScrn, short vid_x, short vid_y,
+                                short drw_x, short drw_y, short vid_w,
+                                short vid_h, short drw_w, short drw_h,
+                                RegionPtr clipBoxes, void *data,
+                                DrawablePtr pDraw);
+typedef int (*GetStillFuncPtr) (ScrnInfoPtr pScrn, short vid_x, short vid_y,
+                                short drw_x, short drw_y, short vid_w,
+                                short vid_h, short drw_w, short drw_h,
+                                RegionPtr clipBoxes, void *data,
+                                DrawablePtr pDraw);
+typedef void (*StopVideoFuncPtr) (ScrnInfoPtr pScrn, void *data, Bool Exit);
+typedef int (*SetPortAttributeFuncPtr) (ScrnInfoPtr pScrn, Atom attribute,
+                                        INT32 value, void *data);
+typedef int (*GetPortAttributeFuncPtr) (ScrnInfoPtr pScrn, Atom attribute,
+                                        INT32 *value, void *data);
+typedef void (*QueryBestSizeFuncPtr) (ScrnInfoPtr pScrn, Bool motion,
+                                      short vid_w, short vid_h, short drw_w,
+                                      short drw_h, unsigned int *p_w,
+                                      unsigned int *p_h, void *data);
+typedef int (*PutImageFuncPtr) (ScrnInfoPtr pScrn, short src_x, short src_y,
+                                short drw_x, short drw_y, short src_w,
+                                short src_h, short drw_w, short drw_h,
+                                int image, unsigned char *buf, short width,
+                                short height, Bool Sync, RegionPtr clipBoxes,
+                                void *data, DrawablePtr pDraw);
+typedef int (*ReputImageFuncPtr) (ScrnInfoPtr pScrn, short src_x, short src_y,
+                                  short drw_x, short drw_y, short src_w,
+                                  short src_h, short drw_w, short drw_h,
+                                  RegionPtr clipBoxes, void *data,
+                                  DrawablePtr pDraw);
+typedef int (*QueryImageAttributesFuncPtr) (ScrnInfoPtr pScrn, int image,
+                                            unsigned short *width,
+                                            unsigned short *height,
+                                            int *pitches, int *offsets);
+typedef void (*ClipNotifyFuncPtr) (ScrnInfoPtr pScrn, void *data,
+                                   WindowPtr window, int dx, int dy);
+
+typedef enum {
+    XV_OFF,
+    XV_PENDING,
+    XV_ON
+} XvStatus;
+
+/*** this is what the driver needs to fill out ***/
+
+typedef struct {
+    int id;
+    const char *name;
+    unsigned short width, height;
+    XvRationalRec rate;
+} XF86VideoEncodingRec, *XF86VideoEncodingPtr;
+
+typedef struct {
+    char depth;
+    short class;
+} XF86VideoFormatRec, *XF86VideoFormatPtr;
+
+typedef struct {
+    int flags;
+    int min_value;
+    int max_value;
+    const char *name;
+} XF86AttributeRec, *XF86AttributePtr;
+
+typedef struct {
+    unsigned int type;
+    int flags;
+    const char *name;
+    int nEncodings;
+    XF86VideoEncodingPtr pEncodings;
+    int nFormats;
+    XF86VideoFormatPtr pFormats;
+    int nPorts;
+    DevUnion *pPortPrivates;
+    int nAttributes;
+    XF86AttributePtr pAttributes;
+    int nImages;
+    XF86ImagePtr pImages;
+    PutVideoFuncPtr PutVideo;
+    PutStillFuncPtr PutStill;
+    GetVideoFuncPtr GetVideo;
+    GetStillFuncPtr GetStill;
+    StopVideoFuncPtr StopVideo;
+    SetPortAttributeFuncPtr SetPortAttribute;
+    GetPortAttributeFuncPtr GetPortAttribute;
+    QueryBestSizeFuncPtr QueryBestSize;
+    PutImageFuncPtr PutImage;
+    ReputImageFuncPtr ReputImage;       /* image/still */
+    QueryImageAttributesFuncPtr QueryImageAttributes;
+    ClipNotifyFuncPtr ClipNotify;
+} XF86VideoAdaptorRec, *XF86VideoAdaptorPtr;
+
+typedef struct {
+    XF86ImagePtr image;
+    int flags;
+    int (*alloc_surface) (ScrnInfoPtr pScrn,
+                          int id,
+                          unsigned short width,
+                          unsigned short height, XF86SurfacePtr surface);
+    int (*free_surface) (XF86SurfacePtr surface);
+    int (*display) (XF86SurfacePtr surface,
+                    short vid_x, short vid_y,
+                    short drw_x, short drw_y,
+                    short vid_w, short vid_h,
+                    short drw_w, short drw_h, RegionPtr clipBoxes);
+    int (*stop) (XF86SurfacePtr surface);
+    int (*getAttribute) (ScrnInfoPtr pScrn, Atom attr, INT32 *value);
+    int (*setAttribute) (ScrnInfoPtr pScrn, Atom attr, INT32 value);
+    int max_width;
+    int max_height;
+    int num_attributes;
+    XF86AttributePtr attributes;
+} XF86OffscreenImageRec, *XF86OffscreenImagePtr;
+
+extern _X_EXPORT Bool
+ xf86XVScreenInit(ScreenPtr pScreen, XF86VideoAdaptorPtr * Adaptors, int num);
+
+typedef int (*xf86XVInitGenericAdaptorPtr) (ScrnInfoPtr pScrn,
+                                            XF86VideoAdaptorPtr ** Adaptors);
+
+extern _X_EXPORT int
+ xf86XVRegisterGenericAdaptorDriver(xf86XVInitGenericAdaptorPtr InitFunc);
+
+extern _X_EXPORT int
+ xf86XVListGenericAdaptors(ScrnInfoPtr pScrn, XF86VideoAdaptorPtr ** Adaptors);
+
+extern _X_EXPORT Bool
+
+xf86XVRegisterOffscreenImages(ScreenPtr pScreen,
+                              XF86OffscreenImagePtr images, int num);
+
+extern _X_EXPORT XF86OffscreenImagePtr
+xf86XVQueryOffscreenImages(ScreenPtr pScreen, int *num);
+
+extern _X_EXPORT XF86VideoAdaptorPtr xf86XVAllocateVideoAdaptorRec(ScrnInfoPtr
+                                                                   pScrn);
+
+extern _X_EXPORT void xf86XVFreeVideoAdaptorRec(XF86VideoAdaptorPtr ptr);
+
+extern _X_EXPORT void
+ xf86XVFillKeyHelper(ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes);
+
+extern _X_EXPORT void
+
+xf86XVFillKeyHelperDrawable(DrawablePtr pDraw, CARD32 key, RegionPtr clipboxes);
+
+extern _X_EXPORT void
+
+xf86XVFillKeyHelperPort(DrawablePtr pDraw, void *data, CARD32 key,
+                        RegionPtr clipboxes, Bool fillEverything);
+
+extern _X_EXPORT Bool
+
+xf86XVClipVideoHelper(BoxPtr dst,
+                      INT32 *xa,
+                      INT32 *xb,
+                      INT32 *ya,
+                      INT32 *yb, RegionPtr reg, INT32 width, INT32 height);
+
+extern _X_EXPORT void
+
+xf86XVCopyYUV12ToPacked(const void *srcy,
+                        const void *srcv,
+                        const void *srcu,
+                        void *dst,
+                        int srcPitchy,
+                        int srcPitchuv, int dstPitch, int h, int w);
+
+extern _X_EXPORT void
+
+xf86XVCopyPacked(const void *src,
+                 void *dst, int srcPitch, int dstPitch, int h, int w);
+
+#endif                          /* _XF86XV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transform.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transform.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transform.h	(Revision 52145)
@@ -0,0 +1,87 @@
+/*
+ * Copyright ¬© 2014 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _GLAMOR_TRANSFORM_H_
+#define _GLAMOR_TRANSFORM_H_
+
+void
+glamor_set_destination_drawable(DrawablePtr     drawable,
+                                int             box_x,
+                                int             box_y,
+                                Bool            do_drawable_translate,
+                                Bool            center_offset,
+                                GLint           matrix_uniform_location,
+                                int             *p_off_x,
+                                int             *p_off_y);
+
+void
+glamor_set_color(PixmapPtr      pixmap,
+                 CARD32         pixel,
+                 GLint          uniform);
+
+Bool
+glamor_set_texture(PixmapPtr    pixmap,
+                   PixmapPtr    texture,
+                   int          off_x,
+                   int          off_y,
+                   GLint        offset_uniform,
+                   GLint        size_uniform);
+
+Bool
+glamor_set_solid(PixmapPtr      pixmap,
+                 GCPtr          gc,
+                 Bool           use_alu,
+                 GLint          uniform);
+
+Bool
+glamor_set_tiled(PixmapPtr      pixmap,
+                 GCPtr          gc,
+                 GLint          offset_uniform,
+                 GLint          size_uniform);
+
+Bool
+glamor_set_stippled(PixmapPtr      pixmap,
+                    GCPtr          gc,
+                    GLint          fg_uniform,
+                    GLint          offset_uniform,
+                    GLint          size_uniform);
+
+/*
+ * Vertex shader bits that transform X coordinates to pixmap
+ * coordinates using the matrix computed above
+ */
+
+#define GLAMOR_DECLARE_MATRIX   "uniform vec4 v_matrix;\n"
+#define GLAMOR_X_POS(x) #x " *v_matrix.x + v_matrix.y"
+#define GLAMOR_Y_POS(y) #y " *v_matrix.z + v_matrix.w"
+#if 0
+#define GLAMOR_POS(dst,src) \
+    "       " #dst ".x = " #src ".x * v_matrix.x + v_matrix.y;\n" \
+    "       " #dst ".y = " #src ".y * v_matrix.z + v_matrix.w;\n" \
+    "       " #dst ".z = 0.0;\n" \
+    "       " #dst ".w = 1.0;\n"
+#endif
+#define GLAMOR_POS(dst,src) \
+    "       " #dst ".xy = " #src ".xy * v_matrix.xz + v_matrix.yw;\n" \
+    "       " #dst ".zw = vec2(0.0,1.0);\n"
+
+#endif /* _GLAMOR_TRANSFORM_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transform.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbe.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbe.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbe.h	(Revision 52145)
@@ -0,0 +1,357 @@
+
+/*
+ *                   XFree86 vbe module
+ *               Copyright 2000 Egbert Eich
+ *
+ * The mode query/save/set/restore functions from the vesa driver 
+ * have been moved here.
+ * Copyright (c) 2000 by Conectiva S.A. (http://www.conectiva.com)
+ * Authors: Paulo C√©sar Pereira de Andrade <pcpa@conectiva.com.br> 
+ */
+
+#ifndef _VBE_H
+#define _VBE_H
+#include "xf86int10.h"
+#include "xf86DDC.h"
+
+typedef enum {
+    DDC_UNCHECKED,
+    DDC_NONE,
+    DDC_1,
+    DDC_2,
+    DDC_1_2
+} ddc_lvl;
+
+typedef struct {
+    xf86Int10InfoPtr pInt10;
+    int version;
+    void *memory;
+    int real_mode_base;
+    int num_pages;
+    Bool init_int10;
+    ddc_lvl ddc;
+    Bool ddc_blank;
+} vbeInfoRec, *vbeInfoPtr;
+
+#define VBE_VERSION_MAJOR(x) *((CARD8*)(&x) + 1)
+#define VBE_VERSION_MINOR(x) (CARD8)(x)
+
+extern _X_EXPORT vbeInfoPtr VBEInit(xf86Int10InfoPtr pInt, int entityIndex);
+extern _X_EXPORT vbeInfoPtr VBEExtendedInit(xf86Int10InfoPtr pInt,
+                                            int entityIndex, int Flags);
+extern _X_EXPORT void vbeFree(vbeInfoPtr pVbe);
+extern _X_EXPORT xf86MonPtr vbeDoEDID(vbeInfoPtr pVbe, void *pDDCModule);
+
+#pragma pack(1)
+
+typedef struct vbeControllerInfoBlock {
+    CARD8 VbeSignature[4];
+    CARD16 VbeVersion;
+    CARD32 OemStringPtr;
+    CARD8 Capabilities[4];
+    CARD32 VideoModePtr;
+    CARD16 TotalMem;
+    CARD16 OemSoftwareRev;
+    CARD32 OemVendorNamePtr;
+    CARD32 OemProductNamePtr;
+    CARD32 OemProductRevPtr;
+    CARD8 Scratch[222];
+    CARD8 OemData[256];
+} vbeControllerInfoRec, *vbeControllerInfoPtr;
+
+#if defined(__GNUC__) || defined(__USLC__) || defined(__SUNPRO_C)
+#pragma pack()                  /* All GCC versions recognise this syntax */
+#else
+#pragma pack(0)
+#endif
+
+#if !( defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)) )
+#define __attribute__(a)
+#endif
+
+typedef struct _VbeInfoBlock VbeInfoBlock;
+typedef struct _VbeModeInfoBlock VbeModeInfoBlock;
+typedef struct _VbeCRTCInfoBlock VbeCRTCInfoBlock;
+
+/*
+ * INT 0
+ */
+
+struct _VbeInfoBlock {
+    /* VESA 1.2 fields */
+    CARD8 VESASignature[4];     /* VESA */
+    CARD16 VESAVersion;         /* Higher byte major, lower byte minor */
+                                        /*CARD32 */ char *OEMStringPtr;
+                                        /* Pointer to OEM string */
+    CARD8 Capabilities[4];      /* Capabilities of the video environment */
+
+                                        /*CARD32 */ CARD16 *VideoModePtr;
+                                        /* pointer to supported Super VGA modes */
+
+    CARD16 TotalMemory;         /* Number of 64kb memory blocks on board */
+    /* if not VESA 2, 236 scratch bytes follow (256 bytes total size) */
+
+    /* VESA 2 fields */
+    CARD16 OemSoftwareRev;      /* VBE implementation Software revision */
+                                        /*CARD32 */ char *OemVendorNamePtr;
+                                        /* Pointer to Vendor Name String */
+                                                /*CARD32 */ char *OemProductNamePtr;
+                                                /* Pointer to Product Name String */
+                                        /*CARD32 */ char *OemProductRevPtr;
+                                        /* Pointer to Product Revision String */
+    CARD8 Reserved[222];        /* Reserved for VBE implementation */
+    CARD8 OemData[256];         /* Data Area for OEM Strings */
+} __attribute__ ((packed));
+
+/* Return Super VGA Information */
+extern _X_EXPORT VbeInfoBlock *VBEGetVBEInfo(vbeInfoPtr pVbe);
+extern _X_EXPORT void VBEFreeVBEInfo(VbeInfoBlock * block);
+
+/*
+ * INT 1
+ */
+
+struct _VbeModeInfoBlock {
+    CARD16 ModeAttributes;      /* mode attributes */
+    CARD8 WinAAttributes;       /* window A attributes */
+    CARD8 WinBAttributes;       /* window B attributes */
+    CARD16 WinGranularity;      /* window granularity */
+    CARD16 WinSize;             /* window size */
+    CARD16 WinASegment;         /* window A start segment */
+    CARD16 WinBSegment;         /* window B start segment */
+    CARD32 WinFuncPtr;          /* real mode pointer to window function */
+    CARD16 BytesPerScanline;    /* bytes per scanline */
+
+    /* Mandatory information for VBE 1.2 and above */
+    CARD16 XResolution;         /* horizontal resolution in pixels or characters */
+    CARD16 YResolution;         /* vertical resolution in pixels or characters */
+    CARD8 XCharSize;            /* character cell width in pixels */
+    CARD8 YCharSize;            /* character cell height in pixels */
+    CARD8 NumberOfPlanes;       /* number of memory planes */
+    CARD8 BitsPerPixel;         /* bits per pixel */
+    CARD8 NumberOfBanks;        /* number of banks */
+    CARD8 MemoryModel;          /* memory model type */
+    CARD8 BankSize;             /* bank size in KB */
+    CARD8 NumberOfImages;       /* number of images */
+    CARD8 Reserved;             /* 1 *//* reserved for page function */
+
+    /* Direct color fields (required for direct/6 and YUV/7 memory models) */
+    CARD8 RedMaskSize;          /* size of direct color red mask in bits */
+    CARD8 RedFieldPosition;     /* bit position of lsb of red mask */
+    CARD8 GreenMaskSize;        /* size of direct color green mask in bits */
+    CARD8 GreenFieldPosition;   /* bit position of lsb of green mask */
+    CARD8 BlueMaskSize;         /* size of direct color blue mask in bits */
+    CARD8 BlueFieldPosition;    /* bit position of lsb of blue mask */
+    CARD8 RsvdMaskSize;         /* size of direct color reserved mask in bits */
+    CARD8 RsvdFieldPosition;    /* bit position of lsb of reserved mask */
+    CARD8 DirectColorModeInfo;  /* direct color mode attributes */
+
+    /* Mandatory information for VBE 2.0 and above */
+    CARD32 PhysBasePtr;         /* physical address for flat memory frame buffer */
+    CARD32 Reserved32;          /* 0 *//* Reserved - always set to 0 */
+    CARD16 Reserved16;          /* 0 *//* Reserved - always set to 0 */
+
+    /* Mandatory information for VBE 3.0 and above */
+    CARD16 LinBytesPerScanLine; /* bytes per scan line for linear modes */
+    CARD8 BnkNumberOfImagePages;        /* number of images for banked modes */
+    CARD8 LinNumberOfImagePages;        /* number of images for linear modes */
+    CARD8 LinRedMaskSize;       /* size of direct color red mask (linear modes) */
+    CARD8 LinRedFieldPosition;  /* bit position of lsb of red mask (linear modes) */
+    CARD8 LinGreenMaskSize;     /* size of direct color green mask (linear modes) */
+    CARD8 LinGreenFieldPosition;        /* bit position of lsb of green mask (linear modes) */
+    CARD8 LinBlueMaskSize;      /* size of direct color blue mask (linear modes) */
+    CARD8 LinBlueFieldPosition; /* bit position of lsb of blue mask (linear modes) */
+    CARD8 LinRsvdMaskSize;      /* size of direct color reserved mask (linear modes) */
+    CARD8 LinRsvdFieldPosition; /* bit position of lsb of reserved mask (linear modes) */
+    CARD32 MaxPixelClock;       /* maximum pixel clock (in Hz) for graphics mode */
+    CARD8 Reserved2[189];       /* remainder of VbeModeInfoBlock */
+} __attribute__ ((packed));
+
+/* Return VBE Mode Information */
+extern _X_EXPORT VbeModeInfoBlock *VBEGetModeInfo(vbeInfoPtr pVbe, int mode);
+extern _X_EXPORT void VBEFreeModeInfo(VbeModeInfoBlock * block);
+
+/*
+ * INT2
+ */
+
+#define CRTC_DBLSCAN	(1<<0)
+#define CRTC_INTERLACE	(1<<1)
+#define CRTC_NHSYNC	(1<<2)
+#define CRTC_NVSYNC	(1<<3)
+
+struct _VbeCRTCInfoBlock {
+    CARD16 HorizontalTotal;     /* Horizontal total in pixels */
+    CARD16 HorizontalSyncStart; /* Horizontal sync start in pixels */
+    CARD16 HorizontalSyncEnd;   /* Horizontal sync end in pixels */
+    CARD16 VerticalTotal;       /* Vertical total in lines */
+    CARD16 VerticalSyncStart;   /* Vertical sync start in lines */
+    CARD16 VerticalSyncEnd;     /* Vertical sync end in lines */
+    CARD8 Flags;                /* Flags (Interlaced, Double Scan etc) */
+    CARD32 PixelClock;          /* Pixel clock in units of Hz */
+    CARD16 RefreshRate;         /* Refresh rate in units of 0.01 Hz */
+    CARD8 Reserved[40];         /* remainder of ModeInfoBlock */
+} __attribute__ ((packed));
+
+/* VbeCRTCInfoBlock is in the VESA 3.0 specs */
+
+extern _X_EXPORT Bool VBESetVBEMode(vbeInfoPtr pVbe, int mode,
+                                    VbeCRTCInfoBlock * crtc);
+
+/*
+ * INT 3
+ */
+
+extern _X_EXPORT Bool VBEGetVBEMode(vbeInfoPtr pVbe, int *mode);
+
+/*
+ * INT 4
+ */
+
+/* Save/Restore Super VGA video state */
+/* function values are (values stored in VESAPtr):
+ *	0 := query & allocate amount of memory to save state
+ *	1 := save state
+ *	2 := restore state
+ *
+ *	function 0 called automatically if function 1 called without
+ *	a previous call to function 0.
+ */
+
+typedef enum {
+    MODE_QUERY,
+    MODE_SAVE,
+    MODE_RESTORE
+} vbeSaveRestoreFunction;
+
+extern _X_EXPORT Bool
+
+VBESaveRestore(vbeInfoPtr pVbe, vbeSaveRestoreFunction fuction,
+               void **memory, int *size, int *real_mode_pages);
+
+/*
+ * INT 5
+ */
+
+extern _X_EXPORT Bool
+ VBEBankSwitch(vbeInfoPtr pVbe, unsigned int iBank, int window);
+
+/*
+ * INT 6
+ */
+
+typedef enum {
+    SCANWID_SET,
+    SCANWID_GET,
+    SCANWID_SET_BYTES,
+    SCANWID_GET_MAX
+} vbeScanwidthCommand;
+
+#define VBESetLogicalScanline(pVbe, width)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_SET, width, \
+					NULL, NULL, NULL)
+#define VBESetLogicalScanlineBytes(pVbe, width)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_SET_BYTES, width, \
+					NULL, NULL, NULL)
+#define VBEGetLogicalScanline(pVbe, pixels, bytes, max)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_GET, 0, \
+					pixels, bytes, max)
+#define VBEGetMaxLogicalScanline(pVbe, pixels, bytes, max)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_GET_MAX, 0, \
+					pixels, bytes, max)
+extern _X_EXPORT Bool VBESetGetLogicalScanlineLength(vbeInfoPtr pVbe,
+                                                     vbeScanwidthCommand
+                                                     command, int width,
+                                                     int *pixels, int *bytes,
+                                                     int *max);
+
+/*
+ * INT 7
+ */
+
+/* 16 bit code */
+extern _X_EXPORT Bool VBESetDisplayStart(vbeInfoPtr pVbe, int x, int y,
+                                         Bool wait_retrace);
+extern _X_EXPORT Bool VBEGetDisplayStart(vbeInfoPtr pVbe, int *x, int *y);
+
+/*
+ * INT 8
+ */
+
+/* if bits is 0, then it is a GET */
+extern _X_EXPORT int VBESetGetDACPaletteFormat(vbeInfoPtr pVbe, int bits);
+
+/*
+ * INT 9
+ */
+
+/*
+ *  If getting a palette, the data argument is not used. It will return
+ * the data.
+ *  If setting a palette, it will return the pointer received on success,
+ * NULL on failure.
+ */
+extern _X_EXPORT CARD32 *VBESetGetPaletteData(vbeInfoPtr pVbe, Bool set,
+                                              int first, int num, CARD32 *data,
+                                              Bool secondary,
+                                              Bool wait_retrace);
+#define VBEFreePaletteData(data)	free(data)
+
+/*
+ * INT A
+ */
+
+typedef struct _VBEpmi {
+    int seg_tbl;
+    int tbl_off;
+    int tbl_len;
+} VBEpmi;
+
+extern _X_EXPORT VBEpmi *VBEGetVBEpmi(vbeInfoPtr pVbe);
+
+#define VESAFreeVBEpmi(pmi)	free(pmi)
+
+/* high level helper functions */
+
+typedef struct _vbeModeInfoRec {
+    int width;
+    int height;
+    int bpp;
+    int n;
+    struct _vbeModeInfoRec *next;
+} vbeModeInfoRec, *vbeModeInfoPtr;
+
+typedef struct {
+    CARD8 *state;
+    CARD8 *pstate;
+    int statePage;
+    int stateSize;
+    int stateMode;
+} vbeSaveRestoreRec, *vbeSaveRestorePtr;
+
+extern _X_EXPORT void
+
+VBEVesaSaveRestore(vbeInfoPtr pVbe, vbeSaveRestorePtr vbe_sr,
+                   vbeSaveRestoreFunction function);
+
+extern _X_EXPORT int VBEGetPixelClock(vbeInfoPtr pVbe, int mode, int Clock);
+extern _X_EXPORT Bool VBEDPMSSet(vbeInfoPtr pVbe, int mode);
+
+struct vbePanelID {
+    short hsize;
+    short vsize;
+    short fptype;
+    char redbpp;
+    char greenbpp;
+    char bluebpp;
+    char reservedbpp;
+    int reserved_offscreen_mem_size;
+    int reserved_offscreen_mem_pointer;
+    char reserved[14];
+};
+
+extern _X_EXPORT void VBEInterpretPanelID(ScrnInfoPtr pScrn,
+                                          struct vbePanelID *data);
+extern _X_EXPORT struct vbePanelID *VBEReadPanelID(vbeInfoPtr pVbe);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vbe.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loaderProcs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loaderProcs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loaderProcs.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/*
+ * Copyright 1995-1998 by Metro Link, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Metro Link, Inc. not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Metro Link, Inc. makes no
+ * representations about the suitability of this software for any purpose.
+ *  It is provided "as is" without express or implied warranty.
+ *
+ * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LOADERPROCS_H
+#define _LOADERPROCS_H
+
+#include "xf86Module.h"
+
+typedef struct module_desc {
+    struct module_desc *child;
+    struct module_desc *sib;
+    struct module_desc *parent;
+    char *name;
+    char *path;
+    void *handle;
+    ModuleSetupProc SetupProc;
+    ModuleTearDownProc TearDownProc;
+    void *TearDownData;         /* returned from SetupProc */
+    const XF86ModuleVersionInfo *VersionInfo;
+} ModuleDesc, *ModuleDescPtr;
+
+/* External API for the loader */
+
+void LoaderInit(void);
+
+ModuleDescPtr LoadDriver(const char *, const char *, int, void *, int *,
+                         int *);
+ModuleDescPtr LoadModule(const char *, const char *, const char **,
+                         const char **, void *, const XF86ModReqInfo *,
+                         int *, int *);
+ModuleDescPtr DuplicateModule(ModuleDescPtr mod, ModuleDescPtr parent);
+void UnloadDriver(ModuleDescPtr);
+void LoaderSetPath(const char *path);
+
+void LoaderUnload(const char *, void *);
+unsigned long LoaderGetModuleVersion(ModuleDescPtr mod);
+
+void LoaderResetOptions(void);
+void LoaderSetOptions(unsigned long);
+
+/* Options for LoaderSetOptions */
+#define LDR_OPT_ABI_MISMATCH_NONFATAL		0x0001
+
+#endif                          /* _LOADERPROCS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loaderProcs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdisp.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdisp.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdisp.h	(Revision 52145)
@@ -0,0 +1,2 @@
+extern void XineramifyXv(void);
+extern void XvResetProcVector(void);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdisp.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmotion.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmotion.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmotion.h	(Revision 52145)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to functions supporting motion events.  \see dmxmotion.c */
+
+#ifndef _DMXMOTION_H_
+#define _DMXMOTION_H_
+
+extern int dmxPointerGetMotionBufferSize(void);
+extern int dmxPointerGetMotionEvents(DeviceIntPtr pDevice,
+                                     xTimecoord * coords,
+                                     unsigned long start,
+                                     unsigned long stop, ScreenPtr pScreen);
+extern void dmxPointerPutMotionEvent(DeviceIntPtr pDevice,
+                                     int firstAxis, int axesCount, int *v,
+                                     unsigned long time);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmotion.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri.h	(Revision 52145)
@@ -0,0 +1,361 @@
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Jens Owen <jens@tungstengraphics.com>
+ *
+ */
+
+/* Prototypes for DRI functions */
+
+#ifndef _DRI_H_
+
+#include <pciaccess.h>
+
+#include "scrnintstr.h"
+#include "xf86dri.h"
+
+typedef int DRISyncType;
+
+#define DRI_NO_SYNC 0
+#define DRI_2D_SYNC 1
+#define DRI_3D_SYNC 2
+
+typedef int DRIContextType;
+
+typedef struct _DRIContextPrivRec DRIContextPrivRec, *DRIContextPrivPtr;
+
+typedef enum _DRIContextFlags {
+    DRI_CONTEXT_2DONLY = 0x01,
+    DRI_CONTEXT_PRESERVED = 0x02,
+    DRI_CONTEXT_RESERVED = 0x04 /* DRI Only -- no kernel equivalent */
+} DRIContextFlags;
+
+#define DRI_NO_CONTEXT 0
+#define DRI_2D_CONTEXT 1
+#define DRI_3D_CONTEXT 2
+
+typedef int DRISwapMethod;
+
+#define DRI_HIDE_X_CONTEXT 0
+#define DRI_SERVER_SWAP    1
+#define DRI_KERNEL_SWAP    2
+
+typedef int DRIWindowRequests;
+
+#define DRI_NO_WINDOWS       0
+#define DRI_3D_WINDOWS_ONLY  1
+#define DRI_ALL_WINDOWS      2
+
+typedef void (*ClipNotifyPtr) (WindowPtr, int, int);
+typedef void (*AdjustFramePtr) (ScrnInfoPtr pScrn, int x, int y);
+
+/*
+ * These functions can be wrapped by the DRI.  Each of these have
+ * generic default funcs (initialized in DRICreateInfoRec) and can be
+ * overridden by the driver in its [driver]DRIScreenInit function.
+ */
+typedef struct {
+    ScreenWakeupHandlerProcPtr WakeupHandler;
+    ScreenBlockHandlerProcPtr BlockHandler;
+    WindowExposuresProcPtr WindowExposures;
+    CopyWindowProcPtr CopyWindow;
+    ValidateTreeProcPtr ValidateTree;
+    PostValidateTreeProcPtr PostValidateTree;
+    ClipNotifyProcPtr ClipNotify;
+    AdjustFramePtr AdjustFrame;
+} DRIWrappedFuncsRec, *DRIWrappedFuncsPtr;
+
+/*
+ * Prior to Xorg 6.8.99.8, the DRIInfoRec structure was implicitly versioned
+ * by the XF86DRI_*_VERSION defines in xf86dristr.h.  These numbers were also
+ * being used to version the XFree86-DRI protocol.  Bugs #3066 and #3163
+ * showed that this was inadequate.  The DRIInfoRec structure is now versioned
+ * by the DRIINFO_*_VERSION defines in this file. - ajax, 2005-05-18.
+ *
+ * Revision history:
+ * 4.1.0 and earlier: DRIQueryVersion returns XF86DRI_*_VERSION.
+ * 4.2.0: DRIQueryVersion begins returning DRIINFO_*_VERSION.
+ * 5.0.0: frameBufferPhysicalAddress changed from CARD32 to pointer.
+ */
+
+#define DRIINFO_MAJOR_VERSION   5
+#define DRIINFO_MINOR_VERSION   4
+#define DRIINFO_PATCH_VERSION   0
+
+typedef unsigned long long (*DRITexOffsetStartProcPtr) (PixmapPtr pPix);
+typedef void (*DRITexOffsetFinishProcPtr) (PixmapPtr pPix);
+
+typedef struct {
+    /* driver call back functions
+     *
+     * New fields should be added at the end for backwards compatibility.
+     * Bump the DRIINFO patch number to indicate bugfixes.
+     * Bump the DRIINFO minor number to indicate new fields.
+     * Bump the DRIINFO major number to indicate binary-incompatible changes.
+     */
+    Bool (*CreateContext) (ScreenPtr pScreen,
+                           VisualPtr visual,
+                           drm_context_t hHWContext,
+                           void *pVisualConfigPriv, DRIContextType context);
+    void (*DestroyContext) (ScreenPtr pScreen,
+                            drm_context_t hHWContext, DRIContextType context);
+    void (*SwapContext) (ScreenPtr pScreen,
+                         DRISyncType syncType,
+                         DRIContextType readContextType,
+                         void *readContextStore,
+                         DRIContextType writeContextType,
+                         void *writeContextStore);
+    void (*InitBuffers) (WindowPtr pWin, RegionPtr prgn, CARD32 indx);
+    void (*MoveBuffers) (WindowPtr pWin,
+                         DDXPointRec ptOldOrg, RegionPtr prgnSrc, CARD32 indx);
+    void (*TransitionTo3d) (ScreenPtr pScreen);
+    void (*TransitionTo2d) (ScreenPtr pScreen);
+
+    void (*SetDrawableIndex) (WindowPtr pWin, CARD32 indx);
+    Bool (*OpenFullScreen) (ScreenPtr pScreen);
+    Bool (*CloseFullScreen) (ScreenPtr pScreen);
+
+    /* wrapped functions */
+    DRIWrappedFuncsRec wrap;
+
+    /* device info */
+    char *drmDriverName;
+    char *clientDriverName;
+    char *busIdString;
+    int ddxDriverMajorVersion;
+    int ddxDriverMinorVersion;
+    int ddxDriverPatchVersion;
+    void *frameBufferPhysicalAddress;
+    long frameBufferSize;
+    long frameBufferStride;
+    long SAREASize;
+    int maxDrawableTableEntry;
+    int ddxDrawableTableEntry;
+    long contextSize;
+    DRISwapMethod driverSwapMethod;
+    DRIWindowRequests bufferRequests;
+    int devPrivateSize;
+    void *devPrivate;
+    Bool createDummyCtx;
+    Bool createDummyCtxPriv;
+
+    /* New with DRI version 4.1.0 */
+    void (*TransitionSingleToMulti3D) (ScreenPtr pScreen);
+    void (*TransitionMultiToSingle3D) (ScreenPtr pScreen);
+
+    /* New with DRI version 5.1.0 */
+    void (*ClipNotify) (ScreenPtr pScreen, WindowPtr *ppWin, int num);
+
+    /* New with DRI version 5.2.0 */
+    Bool allocSarea;
+    Bool keepFDOpen;
+
+    /* New with DRI version 5.3.0 */
+    DRITexOffsetStartProcPtr texOffsetStart;
+    DRITexOffsetFinishProcPtr texOffsetFinish;
+
+    /* New with DRI version 5.4.0 */
+    int dontMapFrameBuffer;
+    drm_handle_t hFrameBuffer;  /* Handle to framebuffer, either
+                                 * mapped by DDX driver or DRI */
+
+} DRIInfoRec, *DRIInfoPtr;
+
+extern _X_EXPORT Bool DRIOpenDRMMaster(ScrnInfoPtr pScrn,
+                                       unsigned long sAreaSize,
+                                       const char *busID,
+                                       const char *drmDriverName);
+
+extern _X_EXPORT Bool DRIScreenInit(ScreenPtr pScreen,
+                                    DRIInfoPtr pDRIInfo, int *pDRMFD);
+
+extern _X_EXPORT void DRICloseScreen(ScreenPtr pScreen);
+
+extern Bool DRIExtensionInit(void);
+
+extern _X_EXPORT void DRIReset(void);
+
+extern _X_EXPORT Bool DRIQueryDirectRenderingCapable(ScreenPtr pScreen,
+                                                     Bool *isCapable);
+
+extern _X_EXPORT Bool DRIOpenConnection(ScreenPtr pScreen,
+                                        drm_handle_t * hSAREA,
+                                        char **busIdString);
+
+extern _X_EXPORT Bool DRIAuthConnection(ScreenPtr pScreen, drm_magic_t magic);
+
+extern _X_EXPORT Bool DRICloseConnection(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRIGetClientDriverName(ScreenPtr pScreen,
+                                             int *ddxDriverMajorVersion,
+                                             int *ddxDriverMinorVersion,
+                                             int *ddxDriverPatchVersion,
+                                             char **clientDriverName);
+
+extern _X_EXPORT Bool DRICreateContext(ScreenPtr pScreen,
+                                       VisualPtr visual,
+                                       XID context, drm_context_t * pHWContext);
+
+extern _X_EXPORT Bool DRIDestroyContext(ScreenPtr pScreen, XID context);
+
+extern _X_EXPORT Bool DRIContextPrivDelete(void *pResource, XID id);
+
+extern _X_EXPORT Bool DRICreateDrawable(ScreenPtr pScreen,
+                                        ClientPtr client,
+                                        DrawablePtr pDrawable,
+                                        drm_drawable_t * hHWDrawable);
+
+extern _X_EXPORT Bool DRIDestroyDrawable(ScreenPtr pScreen,
+                                         ClientPtr client,
+                                         DrawablePtr pDrawable);
+
+extern _X_EXPORT Bool DRIDrawablePrivDelete(void *pResource, XID id);
+
+extern _X_EXPORT Bool DRIGetDrawableInfo(ScreenPtr pScreen,
+                                         DrawablePtr pDrawable,
+                                         unsigned int *indx,
+                                         unsigned int *stamp,
+                                         int *X,
+                                         int *Y,
+                                         int *W,
+                                         int *H,
+                                         int *numClipRects,
+                                         drm_clip_rect_t ** pClipRects,
+                                         int *backX,
+                                         int *backY,
+                                         int *numBackClipRects,
+                                         drm_clip_rect_t ** pBackClipRects);
+
+extern _X_EXPORT Bool DRIGetDeviceInfo(ScreenPtr pScreen,
+                                       drm_handle_t * hFrameBuffer,
+                                       int *fbOrigin,
+                                       int *fbSize,
+                                       int *fbStride,
+                                       int *devPrivateSize, void **pDevPrivate);
+
+extern _X_EXPORT DRIInfoPtr DRICreateInfoRec(void);
+
+extern _X_EXPORT void DRIDestroyInfoRec(DRIInfoPtr DRIInfo);
+
+extern _X_EXPORT Bool DRIFinishScreenInit(ScreenPtr pScreen);
+
+extern _X_EXPORT void DRIWakeupHandler(void *wakeupData,
+                                       int result, void *pReadmask);
+
+extern _X_EXPORT void DRIBlockHandler(void *blockData,
+                                      OSTimePtr pTimeout, void *pReadmask);
+
+extern _X_EXPORT void DRIDoWakeupHandler(ScreenPtr pScreen,
+                                         unsigned long result,
+                                         void *pReadmask);
+
+extern _X_EXPORT void DRIDoBlockHandler(ScreenPtr pScreen,
+                                        void *pTimeout, void *pReadmask);
+
+extern _X_EXPORT void DRISwapContext(int drmFD, void *oldctx, void *newctx);
+
+extern _X_EXPORT void *DRIGetContextStore(DRIContextPrivPtr context);
+
+extern _X_EXPORT void DRIWindowExposures(WindowPtr pWin,
+                                         RegionPtr prgn, RegionPtr bsreg);
+
+extern _X_EXPORT Bool DRIDestroyWindow(WindowPtr pWin);
+
+extern _X_EXPORT void DRICopyWindow(WindowPtr pWin,
+                                    DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+extern _X_EXPORT int DRIValidateTree(WindowPtr pParent,
+                                     WindowPtr pChild, VTKind kind);
+
+extern _X_EXPORT void DRIPostValidateTree(WindowPtr pParent,
+                                          WindowPtr pChild, VTKind kind);
+
+extern _X_EXPORT void DRIClipNotify(WindowPtr pWin, int dx, int dy);
+
+extern _X_EXPORT CARD32 DRIGetDrawableIndex(WindowPtr pWin);
+
+extern _X_EXPORT void DRIPrintDrawableLock(ScreenPtr pScreen, char *msg);
+
+extern _X_EXPORT void DRILock(ScreenPtr pScreen, int flags);
+
+extern _X_EXPORT void DRIUnlock(ScreenPtr pScreen);
+
+extern _X_EXPORT DRIWrappedFuncsRec *DRIGetWrappedFuncs(ScreenPtr pScreen);
+
+extern _X_EXPORT void *DRIGetSAREAPrivate(ScreenPtr pScreen);
+
+extern _X_EXPORT unsigned int DRIGetDrawableStamp(ScreenPtr pScreen,
+                                                  CARD32 drawable_index);
+
+extern _X_EXPORT DRIContextPrivPtr DRICreateContextPriv(ScreenPtr pScreen,
+                                                        drm_context_t *
+                                                        pHWContext,
+                                                        DRIContextFlags flags);
+
+extern _X_EXPORT DRIContextPrivPtr DRICreateContextPrivFromHandle(ScreenPtr
+                                                                  pScreen,
+                                                                  drm_context_t
+                                                                  hHWContext,
+                                                                  DRIContextFlags
+                                                                  flags);
+
+extern _X_EXPORT Bool DRIDestroyContextPriv(DRIContextPrivPtr pDRIContextPriv);
+
+extern _X_EXPORT drm_context_t DRIGetContext(ScreenPtr pScreen);
+
+extern _X_EXPORT void DRIQueryVersion(int *majorVersion,
+                                      int *minorVersion, int *patchVersion);
+
+extern _X_EXPORT void DRIAdjustFrame(ScrnInfoPtr pScrn, int x, int y);
+
+extern _X_EXPORT void DRIMoveBuffersHelper(ScreenPtr pScreen,
+                                           int dx,
+                                           int dy,
+                                           int *xdir, int *ydir, RegionPtr reg);
+
+extern _X_EXPORT char *DRICreatePCIBusID(const struct pci_device *PciInfo);
+
+extern _X_EXPORT int drmInstallSIGIOHandler(int fd,
+                                            void (*f) (int, void *, void *));
+extern _X_EXPORT int drmRemoveSIGIOHandler(int fd);
+extern _X_EXPORT int DRIMasterFD(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void *DRIMasterSareaPointer(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT drm_handle_t DRIMasterSareaHandle(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void DRIGetTexOffsetFuncs(ScreenPtr pScreen,
+                                           DRITexOffsetStartProcPtr *
+                                           texOffsetStartFunc,
+                                           DRITexOffsetFinishProcPtr *
+                                           texOffsetFinishFunc);
+
+#define _DRI_H_
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxswap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxswap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxswap.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2003 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+#ifndef __GLX_swap_h__
+#define __GLX_swap_h__
+
+extern int JoinSwapGroupSGIX(DrawablePtr pDraw, DrawablePtr pMember);
+extern int SGSwapBuffers(__GLXclientState * cl, XID drawId, GLXContextTag tag,
+                         DrawablePtr pDraw);
+
+extern void SwapBarrierInit(void);
+extern void SwapBarrierReset(void);
+extern int QueryMaxSwapBarriersSGIX(int screen);
+extern int BindSwapBarrierSGIX(DrawablePtr pDraw, int barrier);
+
+#endif                          /* !__GLX_swap_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxswap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RandR12.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RandR12.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RandR12.h	(Revision 52145)
@@ -0,0 +1,43 @@
+/*
+ * Copyright ¬© 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _XF86_RANDR_H_
+#define _XF86_RANDR_H_
+#include <randrstr.h>
+#include <X11/extensions/render.h>
+
+extern _X_EXPORT Bool xf86RandR12CreateScreenResources(ScreenPtr pScreen);
+extern _X_EXPORT Bool xf86RandR12Init(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12CloseScreen(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12SetRotations(ScreenPtr pScreen,
+                                              Rotation rotation);
+extern _X_EXPORT void xf86RandR12SetTransformSupport(ScreenPtr pScreen,
+                                                     Bool transforms);
+extern _X_EXPORT Bool xf86RandR12SetConfig(ScreenPtr pScreen, Rotation rotation,
+                                           int rate, RRScreenSizePtr pSize);
+extern _X_EXPORT Rotation xf86RandR12GetRotation(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12GetOriginalVirtualSize(ScrnInfoPtr pScrn,
+                                                        int *x, int *y);
+extern _X_EXPORT Bool xf86RandR12PreInit(ScrnInfoPtr pScrn);
+extern _X_EXPORT void xf86RandR12TellChanged(ScreenPtr pScreen);
+
+#endif                          /* _XF86_RANDR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RandR12.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getmmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getmmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getmmap.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETMMAP_H
+#define GETMMAP_H 1
+
+int SProcXGetDeviceModifierMapping(ClientPtr    /* client */
+    );
+
+int ProcXGetDeviceModifierMapping(ClientPtr     /* client */
+    );
+
+void SRepXGetDeviceModifierMapping(ClientPtr /* client */ ,
+                                   int /* size */ ,
+                                   xGetDeviceModifierMappingReply *     /* rep */
+    );
+
+#endif                          /* GETMMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getmmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/i2c_def.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/i2c_def.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/i2c_def.h	(Revision 52145)
@@ -0,0 +1,6 @@
+#ifndef __I2C_DEF_H__
+#define __I2C_DEF_H__
+
+#include "xf86i2c.h"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/i2c_def.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/g_disptab.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/g_disptab.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/g_disptab.h	(Revision 52145)
@@ -0,0 +1,680 @@
+/* DO NOT EDIT - THIS FILE IS AUTOMATICALLY GENERATED */
+#ifndef _GLX_g_disptab_h_
+#define _GLX_g_disptab_h_
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+extern int __glXRender(__GLXclientState *, GLbyte *);
+extern int __glXRenderLarge(__GLXclientState *, GLbyte *);
+extern int __glXSendLargeCommand(__GLXclientState * cl,
+                                 GLXContextTag contextTag);
+extern int __glXCreateContext(__GLXclientState *, GLbyte *);
+extern int __glXCreateNewContext(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDestroyContext(__GLXclientState *, GLbyte *);
+extern int __glXMakeCurrent(__GLXclientState *, GLbyte *);
+extern int __glXMakeContextCurrent(__GLXclientState *, GLbyte *);
+extern int __glXCreatePbuffer(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDestroyPbuffer(__GLXclientState * cl, GLbyte * pc);
+extern int __glXGetDrawableAttributes(__GLXclientState * cl, GLbyte * pc);
+extern int __glXChangeDrawableAttributes(__GLXclientState * cl, GLbyte * pc);
+extern int __glXIsDirect(__GLXclientState *, GLbyte *);
+extern int __glXQueryVersion(__GLXclientState *, GLbyte *);
+extern int __glXWaitGL(__GLXclientState *, GLbyte *);
+extern int __glXWaitX(__GLXclientState *, GLbyte *);
+extern int __glXCopyContext(__GLXclientState *, GLbyte *);
+extern int __glXSwapBuffers(__GLXclientState *, GLbyte *);
+extern int __glXUseXFont(__GLXclientState *, GLbyte *);
+extern int __glXCreateGLXPixmap(__GLXclientState *, GLbyte *);
+extern int __glXCreatePixmap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXGetVisualConfigs(__GLXclientState *, GLbyte *);
+extern int __glXDestroyGLXPixmap(__GLXclientState *, GLbyte *);
+extern int __glXVendorPrivate(__GLXclientState *, GLbyte *);
+extern int __glXVendorPrivateWithReply(__GLXclientState *, GLbyte *);
+extern int __glXQueryExtensionsString(__GLXclientState *, GLbyte *);
+extern int __glXQueryServerString(__GLXclientState *, GLbyte *);
+extern int __glXClientInfo(__GLXclientState *, GLbyte *);
+extern int __glXGetFBConfigs(__GLXclientState *, GLbyte *);
+extern int __glXCreateWindow(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDestroyWindow(__GLXclientState * cl, GLbyte * pc);
+extern int __glXQueryContext(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDisp_NewList(__GLXclientState *, GLbyte *);
+extern int __glXDisp_EndList(__GLXclientState *, GLbyte *);
+extern int __glXDisp_DeleteLists(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GenLists(__GLXclientState *, GLbyte *);
+extern int __glXDisp_FeedbackBuffer(__GLXclientState *, GLbyte *);
+extern int __glXDisp_SelectBuffer(__GLXclientState *, GLbyte *);
+extern int __glXDisp_RenderMode(__GLXclientState *, GLbyte *);
+extern int __glXDisp_Finish(__GLXclientState *, GLbyte *);
+extern int __glXDisp_PixelStoref(__GLXclientState *, GLbyte *);
+extern int __glXDisp_PixelStorei(__GLXclientState *, GLbyte *);
+extern int __glXDisp_ReadPixels(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetBooleanv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetClipPlane(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetDoublev(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetError(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetFloatv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetIntegerv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetLightfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetLightiv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMapdv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMapfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMapiv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMaterialfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMaterialiv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetPixelMapfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetPixelMapuiv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetPixelMapusv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetPolygonStipple(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetString(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexEnvfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexEnviv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexGendv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexGenfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexGeniv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexImage(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexLevelParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetTexLevelParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_IsEnabled(__GLXclientState *, GLbyte *);
+extern int __glXDisp_IsList(__GLXclientState *, GLbyte *);
+extern int __glXDisp_Flush(__GLXclientState *, GLbyte *);
+extern int __glXDisp_AreTexturesResident(__GLXclientState *, GLbyte *);
+extern int __glXDisp_DeleteTextures(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GenTextures(__GLXclientState *, GLbyte *);
+extern int __glXDisp_IsTexture(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetColorTable(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetColorTableParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetColorTableParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetConvolutionFilter(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetConvolutionParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetConvolutionParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetSeparableFilter(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetHistogram(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetHistogramParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetHistogramParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMinmax(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMinmaxParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDisp_GetMinmaxParameteriv(__GLXclientState *, GLbyte *);
+
+extern void __glXDisp_CallList(GLbyte *);
+extern void __glXDisp_CallLists(GLbyte *);
+extern void __glXDisp_ListBase(GLbyte *);
+extern void __glXDisp_Begin(GLbyte *);
+extern void __glXDisp_Bitmap(GLbyte *);
+extern void __glXDisp_Color3bv(GLbyte *);
+extern void __glXDisp_Color3dv(GLbyte *);
+extern void __glXDisp_Color3fv(GLbyte *);
+extern void __glXDisp_Color3iv(GLbyte *);
+extern void __glXDisp_Color3sv(GLbyte *);
+extern void __glXDisp_Color3ubv(GLbyte *);
+extern void __glXDisp_Color3uiv(GLbyte *);
+extern void __glXDisp_Color3usv(GLbyte *);
+extern void __glXDisp_Color4bv(GLbyte *);
+extern void __glXDisp_Color4dv(GLbyte *);
+extern void __glXDisp_Color4fv(GLbyte *);
+extern void __glXDisp_Color4iv(GLbyte *);
+extern void __glXDisp_Color4sv(GLbyte *);
+extern void __glXDisp_Color4ubv(GLbyte *);
+extern void __glXDisp_Color4uiv(GLbyte *);
+extern void __glXDisp_Color4usv(GLbyte *);
+extern void __glXDisp_EdgeFlagv(GLbyte *);
+extern void __glXDisp_End(GLbyte *);
+extern void __glXDisp_Indexdv(GLbyte *);
+extern void __glXDisp_Indexfv(GLbyte *);
+extern void __glXDisp_Indexiv(GLbyte *);
+extern void __glXDisp_Indexsv(GLbyte *);
+extern void __glXDisp_Normal3bv(GLbyte *);
+extern void __glXDisp_Normal3dv(GLbyte *);
+extern void __glXDisp_Normal3fv(GLbyte *);
+extern void __glXDisp_Normal3iv(GLbyte *);
+extern void __glXDisp_Normal3sv(GLbyte *);
+extern void __glXDisp_RasterPos2dv(GLbyte *);
+extern void __glXDisp_RasterPos2fv(GLbyte *);
+extern void __glXDisp_RasterPos2iv(GLbyte *);
+extern void __glXDisp_RasterPos2sv(GLbyte *);
+extern void __glXDisp_RasterPos3dv(GLbyte *);
+extern void __glXDisp_RasterPos3fv(GLbyte *);
+extern void __glXDisp_RasterPos3iv(GLbyte *);
+extern void __glXDisp_RasterPos3sv(GLbyte *);
+extern void __glXDisp_RasterPos4dv(GLbyte *);
+extern void __glXDisp_RasterPos4fv(GLbyte *);
+extern void __glXDisp_RasterPos4iv(GLbyte *);
+extern void __glXDisp_RasterPos4sv(GLbyte *);
+extern void __glXDisp_Rectdv(GLbyte *);
+extern void __glXDisp_Rectfv(GLbyte *);
+extern void __glXDisp_Rectiv(GLbyte *);
+extern void __glXDisp_Rectsv(GLbyte *);
+extern void __glXDisp_TexCoord1dv(GLbyte *);
+extern void __glXDisp_TexCoord1fv(GLbyte *);
+extern void __glXDisp_TexCoord1iv(GLbyte *);
+extern void __glXDisp_TexCoord1sv(GLbyte *);
+extern void __glXDisp_TexCoord2dv(GLbyte *);
+extern void __glXDisp_TexCoord2fv(GLbyte *);
+extern void __glXDisp_TexCoord2iv(GLbyte *);
+extern void __glXDisp_TexCoord2sv(GLbyte *);
+extern void __glXDisp_TexCoord3dv(GLbyte *);
+extern void __glXDisp_TexCoord3fv(GLbyte *);
+extern void __glXDisp_TexCoord3iv(GLbyte *);
+extern void __glXDisp_TexCoord3sv(GLbyte *);
+extern void __glXDisp_TexCoord4dv(GLbyte *);
+extern void __glXDisp_TexCoord4fv(GLbyte *);
+extern void __glXDisp_TexCoord4iv(GLbyte *);
+extern void __glXDisp_TexCoord4sv(GLbyte *);
+extern void __glXDisp_Vertex2dv(GLbyte *);
+extern void __glXDisp_Vertex2fv(GLbyte *);
+extern void __glXDisp_Vertex2iv(GLbyte *);
+extern void __glXDisp_Vertex2sv(GLbyte *);
+extern void __glXDisp_Vertex3dv(GLbyte *);
+extern void __glXDisp_Vertex3fv(GLbyte *);
+extern void __glXDisp_Vertex3iv(GLbyte *);
+extern void __glXDisp_Vertex3sv(GLbyte *);
+extern void __glXDisp_Vertex4dv(GLbyte *);
+extern void __glXDisp_Vertex4fv(GLbyte *);
+extern void __glXDisp_Vertex4iv(GLbyte *);
+extern void __glXDisp_Vertex4sv(GLbyte *);
+extern void __glXDisp_ClipPlane(GLbyte *);
+extern void __glXDisp_ColorMaterial(GLbyte *);
+extern void __glXDisp_CullFace(GLbyte *);
+extern void __glXDisp_Fogf(GLbyte *);
+extern void __glXDisp_Fogfv(GLbyte *);
+extern void __glXDisp_Fogi(GLbyte *);
+extern void __glXDisp_Fogiv(GLbyte *);
+extern void __glXDisp_FrontFace(GLbyte *);
+extern void __glXDisp_Hint(GLbyte *);
+extern void __glXDisp_Lightf(GLbyte *);
+extern void __glXDisp_Lightfv(GLbyte *);
+extern void __glXDisp_Lighti(GLbyte *);
+extern void __glXDisp_Lightiv(GLbyte *);
+extern void __glXDisp_LightModelf(GLbyte *);
+extern void __glXDisp_LightModelfv(GLbyte *);
+extern void __glXDisp_LightModeli(GLbyte *);
+extern void __glXDisp_LightModeliv(GLbyte *);
+extern void __glXDisp_LineStipple(GLbyte *);
+extern void __glXDisp_LineWidth(GLbyte *);
+extern void __glXDisp_Materialf(GLbyte *);
+extern void __glXDisp_Materialfv(GLbyte *);
+extern void __glXDisp_Materiali(GLbyte *);
+extern void __glXDisp_Materialiv(GLbyte *);
+extern void __glXDisp_PointSize(GLbyte *);
+extern void __glXDisp_PolygonMode(GLbyte *);
+extern void __glXDisp_PolygonStipple(GLbyte *);
+extern void __glXDisp_Scissor(GLbyte *);
+extern void __glXDisp_ShadeModel(GLbyte *);
+extern void __glXDisp_TexParameterf(GLbyte *);
+extern void __glXDisp_TexParameterfv(GLbyte *);
+extern void __glXDisp_TexParameteri(GLbyte *);
+extern void __glXDisp_TexParameteriv(GLbyte *);
+extern void __glXDisp_TexImage1D(GLbyte *);
+extern void __glXDisp_TexImage2D(GLbyte *);
+extern void __glXDisp_TexEnvf(GLbyte *);
+extern void __glXDisp_TexEnvfv(GLbyte *);
+extern void __glXDisp_TexEnvi(GLbyte *);
+extern void __glXDisp_TexEnviv(GLbyte *);
+extern void __glXDisp_TexGend(GLbyte *);
+extern void __glXDisp_TexGendv(GLbyte *);
+extern void __glXDisp_TexGenf(GLbyte *);
+extern void __glXDisp_TexGenfv(GLbyte *);
+extern void __glXDisp_TexGeni(GLbyte *);
+extern void __glXDisp_TexGeniv(GLbyte *);
+extern void __glXDisp_InitNames(GLbyte *);
+extern void __glXDisp_LoadName(GLbyte *);
+extern void __glXDisp_PassThrough(GLbyte *);
+extern void __glXDisp_PopName(GLbyte *);
+extern void __glXDisp_PushName(GLbyte *);
+extern void __glXDisp_DrawBuffer(GLbyte *);
+extern void __glXDisp_Clear(GLbyte *);
+extern void __glXDisp_ClearAccum(GLbyte *);
+extern void __glXDisp_ClearIndex(GLbyte *);
+extern void __glXDisp_ClearColor(GLbyte *);
+extern void __glXDisp_ClearStencil(GLbyte *);
+extern void __glXDisp_ClearDepth(GLbyte *);
+extern void __glXDisp_StencilMask(GLbyte *);
+extern void __glXDisp_ColorMask(GLbyte *);
+extern void __glXDisp_DepthMask(GLbyte *);
+extern void __glXDisp_IndexMask(GLbyte *);
+extern void __glXDisp_Accum(GLbyte *);
+extern void __glXDisp_Disable(GLbyte *);
+extern void __glXDisp_Enable(GLbyte *);
+extern void __glXDisp_PopAttrib(GLbyte *);
+extern void __glXDisp_PushAttrib(GLbyte *);
+extern void __glXDisp_Map1d(GLbyte *);
+extern void __glXDisp_Map1f(GLbyte *);
+extern void __glXDisp_Map2d(GLbyte *);
+extern void __glXDisp_Map2f(GLbyte *);
+extern void __glXDisp_MapGrid1d(GLbyte *);
+extern void __glXDisp_MapGrid1f(GLbyte *);
+extern void __glXDisp_MapGrid2d(GLbyte *);
+extern void __glXDisp_MapGrid2f(GLbyte *);
+extern void __glXDisp_EvalCoord1dv(GLbyte *);
+extern void __glXDisp_EvalCoord1fv(GLbyte *);
+extern void __glXDisp_EvalCoord2dv(GLbyte *);
+extern void __glXDisp_EvalCoord2fv(GLbyte *);
+extern void __glXDisp_EvalMesh1(GLbyte *);
+extern void __glXDisp_EvalPoint1(GLbyte *);
+extern void __glXDisp_EvalMesh2(GLbyte *);
+extern void __glXDisp_EvalPoint2(GLbyte *);
+extern void __glXDisp_AlphaFunc(GLbyte *);
+extern void __glXDisp_BlendFunc(GLbyte *);
+extern void __glXDisp_LogicOp(GLbyte *);
+extern void __glXDisp_StencilFunc(GLbyte *);
+extern void __glXDisp_StencilOp(GLbyte *);
+extern void __glXDisp_DepthFunc(GLbyte *);
+extern void __glXDisp_PixelZoom(GLbyte *);
+extern void __glXDisp_PixelTransferf(GLbyte *);
+extern void __glXDisp_PixelTransferi(GLbyte *);
+extern void __glXDisp_PixelMapfv(GLbyte *);
+extern void __glXDisp_PixelMapuiv(GLbyte *);
+extern void __glXDisp_PixelMapusv(GLbyte *);
+extern void __glXDisp_ReadBuffer(GLbyte *);
+extern void __glXDisp_CopyPixels(GLbyte *);
+extern void __glXDisp_DrawPixels(GLbyte *);
+extern void __glXDisp_DepthRange(GLbyte *);
+extern void __glXDisp_Frustum(GLbyte *);
+extern void __glXDisp_LoadIdentity(GLbyte *);
+extern void __glXDisp_LoadMatrixf(GLbyte *);
+extern void __glXDisp_LoadMatrixd(GLbyte *);
+extern void __glXDisp_MatrixMode(GLbyte *);
+extern void __glXDisp_MultMatrixf(GLbyte *);
+extern void __glXDisp_MultMatrixd(GLbyte *);
+extern void __glXDisp_Ortho(GLbyte *);
+extern void __glXDisp_PopMatrix(GLbyte *);
+extern void __glXDisp_PushMatrix(GLbyte *);
+extern void __glXDisp_Rotated(GLbyte *);
+extern void __glXDisp_Rotatef(GLbyte *);
+extern void __glXDisp_Scaled(GLbyte *);
+extern void __glXDisp_Scalef(GLbyte *);
+extern void __glXDisp_Translated(GLbyte *);
+extern void __glXDisp_Translatef(GLbyte *);
+extern void __glXDisp_Viewport(GLbyte *);
+extern void __glXDisp_PolygonOffset(GLbyte *);
+extern void __glXDisp_DrawArrays(GLbyte *);
+extern void __glXDisp_Indexubv(GLbyte *);
+extern void __glXDisp_ColorSubTable(GLbyte *);
+extern void __glXDisp_CopyColorSubTable(GLbyte *);
+extern void __glXDisp_ActiveTextureARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord1dvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord1fvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord1ivARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord1svARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord2dvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord2fvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord2ivARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord2svARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord3dvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord3fvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord3ivARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord3svARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord4dvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord4fvARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord4ivARB(GLbyte *);
+extern void __glXDisp_MultiTexCoord4svARB(GLbyte *);
+
+extern int __glXSwapRender(__GLXclientState *, GLbyte *);
+extern int __glXSwapRenderLarge(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreateContext(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreateNewContext(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapDestroyContext(__GLXclientState *, GLbyte *);
+extern int __glXSwapMakeCurrent(__GLXclientState *, GLbyte *);
+extern int __glXSwapMakeContextCurrent(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreatePbuffer(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapDestroyPbuffer(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapGetDrawableAttributes(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapChangeDrawableAttributes(__GLXclientState * cl,
+                                             GLbyte * pc);
+extern int __glXSwapIsDirect(__GLXclientState *, GLbyte *);
+extern int __glXSwapQueryVersion(__GLXclientState *, GLbyte *);
+extern int __glXSwapWaitGL(__GLXclientState *, GLbyte *);
+extern int __glXSwapWaitX(__GLXclientState *, GLbyte *);
+extern int __glXSwapCopyContext(__GLXclientState *, GLbyte *);
+extern int __glXSwapSwapBuffers(__GLXclientState *, GLbyte *);
+extern int __glXSwapUseXFont(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreateGLXPixmap(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreatePixmap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapGetVisualConfigs(__GLXclientState *, GLbyte *);
+extern int __glXSwapDestroyGLXPixmap(__GLXclientState *, GLbyte *);
+extern int __glXSwapVendorPrivate(__GLXclientState *, GLbyte *);
+extern int __glXSwapVendorPrivateWithReply(__GLXclientState *, GLbyte *);
+extern int __glXSwapQueryExtensionsString(__GLXclientState *, GLbyte *);
+extern int __glXSwapQueryServerString(__GLXclientState *, GLbyte *);
+extern int __glXSwapClientInfo(__GLXclientState *, GLbyte *);
+extern int __glXSwapGetFBConfigs(__GLXclientState *, GLbyte *);
+extern int __glXSwapCreateWindow(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapDestroyWindow(__GLXclientState * cl, GLbyte * pc);
+extern int __glXSwapQueryContext(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDispSwap_NewList(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_EndList(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_DeleteLists(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GenLists(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_FeedbackBuffer(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_SelectBuffer(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_RenderMode(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_Finish(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_PixelStoref(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_PixelStorei(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_ReadPixels(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetBooleanv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetClipPlane(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetDoublev(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetError(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetFloatv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetIntegerv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetLightfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetLightiv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMapdv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMapfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMapiv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMaterialfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMaterialiv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetPixelMapfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetPixelMapuiv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetPixelMapusv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetPolygonStipple(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetString(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexEnvfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexEnviv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexGendv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexGenfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexGeniv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexImage(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexLevelParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetTexLevelParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_IsEnabled(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_IsList(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_Flush(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_AreTexturesResident(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_DeleteTextures(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GenTextures(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_IsTexture(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetColorTable(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetColorTableParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetColorTableParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetConvolutionFilter(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetConvolutionParameterfv(__GLXclientState *,
+                                                   GLbyte *);
+extern int __glXDispSwap_GetConvolutionParameteriv(__GLXclientState *,
+                                                   GLbyte *);
+extern int __glXDispSwap_GetSeparableFilter(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetHistogram(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetHistogramParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetHistogramParameteriv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMinmax(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMinmaxParameterfv(__GLXclientState *, GLbyte *);
+extern int __glXDispSwap_GetMinmaxParameteriv(__GLXclientState *, GLbyte *);
+
+extern void __glXDispSwap_CallList(GLbyte *);
+extern void __glXDispSwap_CallLists(GLbyte *);
+extern void __glXDispSwap_ListBase(GLbyte *);
+extern void __glXDispSwap_Begin(GLbyte *);
+extern void __glXDispSwap_Bitmap(GLbyte *);
+extern void __glXDispSwap_Color3bv(GLbyte *);
+extern void __glXDispSwap_Color3dv(GLbyte *);
+extern void __glXDispSwap_Color3fv(GLbyte *);
+extern void __glXDispSwap_Color3iv(GLbyte *);
+extern void __glXDispSwap_Color3sv(GLbyte *);
+extern void __glXDispSwap_Color3ubv(GLbyte *);
+extern void __glXDispSwap_Color3uiv(GLbyte *);
+extern void __glXDispSwap_Color3usv(GLbyte *);
+extern void __glXDispSwap_Color4bv(GLbyte *);
+extern void __glXDispSwap_Color4dv(GLbyte *);
+extern void __glXDispSwap_Color4fv(GLbyte *);
+extern void __glXDispSwap_Color4iv(GLbyte *);
+extern void __glXDispSwap_Color4sv(GLbyte *);
+extern void __glXDispSwap_Color4ubv(GLbyte *);
+extern void __glXDispSwap_Color4uiv(GLbyte *);
+extern void __glXDispSwap_Color4usv(GLbyte *);
+extern void __glXDispSwap_EdgeFlagv(GLbyte *);
+extern void __glXDispSwap_End(GLbyte *);
+extern void __glXDispSwap_Indexdv(GLbyte *);
+extern void __glXDispSwap_Indexfv(GLbyte *);
+extern void __glXDispSwap_Indexiv(GLbyte *);
+extern void __glXDispSwap_Indexsv(GLbyte *);
+extern void __glXDispSwap_Normal3bv(GLbyte *);
+extern void __glXDispSwap_Normal3dv(GLbyte *);
+extern void __glXDispSwap_Normal3fv(GLbyte *);
+extern void __glXDispSwap_Normal3iv(GLbyte *);
+extern void __glXDispSwap_Normal3sv(GLbyte *);
+extern void __glXDispSwap_RasterPos2dv(GLbyte *);
+extern void __glXDispSwap_RasterPos2fv(GLbyte *);
+extern void __glXDispSwap_RasterPos2iv(GLbyte *);
+extern void __glXDispSwap_RasterPos2sv(GLbyte *);
+extern void __glXDispSwap_RasterPos3dv(GLbyte *);
+extern void __glXDispSwap_RasterPos3fv(GLbyte *);
+extern void __glXDispSwap_RasterPos3iv(GLbyte *);
+extern void __glXDispSwap_RasterPos3sv(GLbyte *);
+extern void __glXDispSwap_RasterPos4dv(GLbyte *);
+extern void __glXDispSwap_RasterPos4fv(GLbyte *);
+extern void __glXDispSwap_RasterPos4iv(GLbyte *);
+extern void __glXDispSwap_RasterPos4sv(GLbyte *);
+extern void __glXDispSwap_Rectdv(GLbyte *);
+extern void __glXDispSwap_Rectfv(GLbyte *);
+extern void __glXDispSwap_Rectiv(GLbyte *);
+extern void __glXDispSwap_Rectsv(GLbyte *);
+extern void __glXDispSwap_TexCoord1dv(GLbyte *);
+extern void __glXDispSwap_TexCoord1fv(GLbyte *);
+extern void __glXDispSwap_TexCoord1iv(GLbyte *);
+extern void __glXDispSwap_TexCoord1sv(GLbyte *);
+extern void __glXDispSwap_TexCoord2dv(GLbyte *);
+extern void __glXDispSwap_TexCoord2fv(GLbyte *);
+extern void __glXDispSwap_TexCoord2iv(GLbyte *);
+extern void __glXDispSwap_TexCoord2sv(GLbyte *);
+extern void __glXDispSwap_TexCoord3dv(GLbyte *);
+extern void __glXDispSwap_TexCoord3fv(GLbyte *);
+extern void __glXDispSwap_TexCoord3iv(GLbyte *);
+extern void __glXDispSwap_TexCoord3sv(GLbyte *);
+extern void __glXDispSwap_TexCoord4dv(GLbyte *);
+extern void __glXDispSwap_TexCoord4fv(GLbyte *);
+extern void __glXDispSwap_TexCoord4iv(GLbyte *);
+extern void __glXDispSwap_TexCoord4sv(GLbyte *);
+extern void __glXDispSwap_Vertex2dv(GLbyte *);
+extern void __glXDispSwap_Vertex2fv(GLbyte *);
+extern void __glXDispSwap_Vertex2iv(GLbyte *);
+extern void __glXDispSwap_Vertex2sv(GLbyte *);
+extern void __glXDispSwap_Vertex3dv(GLbyte *);
+extern void __glXDispSwap_Vertex3fv(GLbyte *);
+extern void __glXDispSwap_Vertex3iv(GLbyte *);
+extern void __glXDispSwap_Vertex3sv(GLbyte *);
+extern void __glXDispSwap_Vertex4dv(GLbyte *);
+extern void __glXDispSwap_Vertex4fv(GLbyte *);
+extern void __glXDispSwap_Vertex4iv(GLbyte *);
+extern void __glXDispSwap_Vertex4sv(GLbyte *);
+extern void __glXDispSwap_ClipPlane(GLbyte *);
+extern void __glXDispSwap_ColorMaterial(GLbyte *);
+extern void __glXDispSwap_CullFace(GLbyte *);
+extern void __glXDispSwap_Fogf(GLbyte *);
+extern void __glXDispSwap_Fogfv(GLbyte *);
+extern void __glXDispSwap_Fogi(GLbyte *);
+extern void __glXDispSwap_Fogiv(GLbyte *);
+extern void __glXDispSwap_FrontFace(GLbyte *);
+extern void __glXDispSwap_Hint(GLbyte *);
+extern void __glXDispSwap_Lightf(GLbyte *);
+extern void __glXDispSwap_Lightfv(GLbyte *);
+extern void __glXDispSwap_Lighti(GLbyte *);
+extern void __glXDispSwap_Lightiv(GLbyte *);
+extern void __glXDispSwap_LightModelf(GLbyte *);
+extern void __glXDispSwap_LightModelfv(GLbyte *);
+extern void __glXDispSwap_LightModeli(GLbyte *);
+extern void __glXDispSwap_LightModeliv(GLbyte *);
+extern void __glXDispSwap_LineStipple(GLbyte *);
+extern void __glXDispSwap_LineWidth(GLbyte *);
+extern void __glXDispSwap_Materialf(GLbyte *);
+extern void __glXDispSwap_Materialfv(GLbyte *);
+extern void __glXDispSwap_Materiali(GLbyte *);
+extern void __glXDispSwap_Materialiv(GLbyte *);
+extern void __glXDispSwap_PointSize(GLbyte *);
+extern void __glXDispSwap_PolygonMode(GLbyte *);
+extern void __glXDispSwap_PolygonStipple(GLbyte *);
+extern void __glXDispSwap_Scissor(GLbyte *);
+extern void __glXDispSwap_ShadeModel(GLbyte *);
+extern void __glXDispSwap_TexParameterf(GLbyte *);
+extern void __glXDispSwap_TexParameterfv(GLbyte *);
+extern void __glXDispSwap_TexParameteri(GLbyte *);
+extern void __glXDispSwap_TexParameteriv(GLbyte *);
+extern void __glXDispSwap_TexImage1D(GLbyte *);
+extern void __glXDispSwap_TexImage2D(GLbyte *);
+extern void __glXDispSwap_TexEnvf(GLbyte *);
+extern void __glXDispSwap_TexEnvfv(GLbyte *);
+extern void __glXDispSwap_TexEnvi(GLbyte *);
+extern void __glXDispSwap_TexEnviv(GLbyte *);
+extern void __glXDispSwap_TexGend(GLbyte *);
+extern void __glXDispSwap_TexGendv(GLbyte *);
+extern void __glXDispSwap_TexGenf(GLbyte *);
+extern void __glXDispSwap_TexGenfv(GLbyte *);
+extern void __glXDispSwap_TexGeni(GLbyte *);
+extern void __glXDispSwap_TexGeniv(GLbyte *);
+extern void __glXDispSwap_InitNames(GLbyte *);
+extern void __glXDispSwap_LoadName(GLbyte *);
+extern void __glXDispSwap_PassThrough(GLbyte *);
+extern void __glXDispSwap_PopName(GLbyte *);
+extern void __glXDispSwap_PushName(GLbyte *);
+extern void __glXDispSwap_DrawBuffer(GLbyte *);
+extern void __glXDispSwap_Clear(GLbyte *);
+extern void __glXDispSwap_ClearAccum(GLbyte *);
+extern void __glXDispSwap_ClearIndex(GLbyte *);
+extern void __glXDispSwap_ClearColor(GLbyte *);
+extern void __glXDispSwap_ClearStencil(GLbyte *);
+extern void __glXDispSwap_ClearDepth(GLbyte *);
+extern void __glXDispSwap_StencilMask(GLbyte *);
+extern void __glXDispSwap_ColorMask(GLbyte *);
+extern void __glXDispSwap_DepthMask(GLbyte *);
+extern void __glXDispSwap_IndexMask(GLbyte *);
+extern void __glXDispSwap_Accum(GLbyte *);
+extern void __glXDispSwap_Disable(GLbyte *);
+extern void __glXDispSwap_Enable(GLbyte *);
+extern void __glXDispSwap_PopAttrib(GLbyte *);
+extern void __glXDispSwap_PushAttrib(GLbyte *);
+extern void __glXDispSwap_Map1d(GLbyte *);
+extern void __glXDispSwap_Map1f(GLbyte *);
+extern void __glXDispSwap_Map2d(GLbyte *);
+extern void __glXDispSwap_Map2f(GLbyte *);
+extern void __glXDispSwap_MapGrid1d(GLbyte *);
+extern void __glXDispSwap_MapGrid1f(GLbyte *);
+extern void __glXDispSwap_MapGrid2d(GLbyte *);
+extern void __glXDispSwap_MapGrid2f(GLbyte *);
+extern void __glXDispSwap_EvalCoord1dv(GLbyte *);
+extern void __glXDispSwap_EvalCoord1fv(GLbyte *);
+extern void __glXDispSwap_EvalCoord2dv(GLbyte *);
+extern void __glXDispSwap_EvalCoord2fv(GLbyte *);
+extern void __glXDispSwap_EvalMesh1(GLbyte *);
+extern void __glXDispSwap_EvalPoint1(GLbyte *);
+extern void __glXDispSwap_EvalMesh2(GLbyte *);
+extern void __glXDispSwap_EvalPoint2(GLbyte *);
+extern void __glXDispSwap_AlphaFunc(GLbyte *);
+extern void __glXDispSwap_BlendFunc(GLbyte *);
+extern void __glXDispSwap_LogicOp(GLbyte *);
+extern void __glXDispSwap_StencilFunc(GLbyte *);
+extern void __glXDispSwap_StencilOp(GLbyte *);
+extern void __glXDispSwap_DepthFunc(GLbyte *);
+extern void __glXDispSwap_PixelZoom(GLbyte *);
+extern void __glXDispSwap_PixelTransferf(GLbyte *);
+extern void __glXDispSwap_PixelTransferi(GLbyte *);
+extern void __glXDispSwap_PixelMapfv(GLbyte *);
+extern void __glXDispSwap_PixelMapuiv(GLbyte *);
+extern void __glXDispSwap_PixelMapusv(GLbyte *);
+extern void __glXDispSwap_ReadBuffer(GLbyte *);
+extern void __glXDispSwap_CopyPixels(GLbyte *);
+extern void __glXDispSwap_DrawPixels(GLbyte *);
+extern void __glXDispSwap_DepthRange(GLbyte *);
+extern void __glXDispSwap_Frustum(GLbyte *);
+extern void __glXDispSwap_LoadIdentity(GLbyte *);
+extern void __glXDispSwap_LoadMatrixf(GLbyte *);
+extern void __glXDispSwap_LoadMatrixd(GLbyte *);
+extern void __glXDispSwap_MatrixMode(GLbyte *);
+extern void __glXDispSwap_MultMatrixf(GLbyte *);
+extern void __glXDispSwap_MultMatrixd(GLbyte *);
+extern void __glXDispSwap_Ortho(GLbyte *);
+extern void __glXDispSwap_PopMatrix(GLbyte *);
+extern void __glXDispSwap_PushMatrix(GLbyte *);
+extern void __glXDispSwap_Rotated(GLbyte *);
+extern void __glXDispSwap_Rotatef(GLbyte *);
+extern void __glXDispSwap_Scaled(GLbyte *);
+extern void __glXDispSwap_Scalef(GLbyte *);
+extern void __glXDispSwap_Translated(GLbyte *);
+extern void __glXDispSwap_Translatef(GLbyte *);
+extern void __glXDispSwap_Viewport(GLbyte *);
+extern void __glXDispSwap_PolygonOffset(GLbyte *);
+extern void __glXDispSwap_DrawArrays(GLbyte *);
+extern void __glXDispSwap_Indexubv(GLbyte *);
+extern void __glXDispSwap_ColorSubTable(GLbyte *);
+extern void __glXDispSwap_CopyColorSubTable(GLbyte *);
+extern void __glXDispSwap_ActiveTextureARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord1dvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord1fvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord1ivARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord1svARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord2dvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord2fvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord2ivARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord2svARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord3dvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord3fvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord3ivARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord3svARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord4dvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord4fvARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord4ivARB(GLbyte *);
+extern void __glXDispSwap_MultiTexCoord4svARB(GLbyte *);
+
+extern void __glXDispSwap_TexSubImage1D(GLbyte *);
+extern void __glXDispSwap_TexSubImage2D(GLbyte *);
+extern void __glXDispSwap_ConvolutionFilter1D(GLbyte *);
+extern void __glXDispSwap_ConvolutionFilter2D(GLbyte *);
+extern void __glXDispSwap_ConvolutionParameterfv(GLbyte *);
+extern void __glXDispSwap_ConvolutionParameteriv(GLbyte *);
+extern void __glXDispSwap_CopyConvolutionFilter1D(GLbyte *);
+extern void __glXDispSwap_CopyConvolutionFilter2D(GLbyte *);
+extern void __glXDispSwap_SeparableFilter2D(GLbyte *);
+extern void __glXDispSwap_TexImage3D(GLbyte *);
+extern void __glXDispSwap_TexSubImage3D(GLbyte *);
+extern void __glXDispSwap_DrawArrays(GLbyte *);
+extern void __glXDispSwap_PrioritizeTextures(GLbyte *);
+extern void __glXDispSwap_CopyTexImage1D(GLbyte *);
+extern void __glXDispSwap_CopyTexImage2D(GLbyte *);
+extern void __glXDispSwap_CopyTexSubImage1D(GLbyte *);
+extern void __glXDispSwap_CopyTexSubImage2D(GLbyte *);
+extern void __glXDispSwap_CopyTexSubImage3D(GLbyte *);
+
+#define __GLX_MIN_GLXCMD_OPCODE 1
+#define __GLX_MAX_GLXCMD_OPCODE 20
+#define __GLX_MIN_RENDER_OPCODE 1
+#define __GLX_MAX_RENDER_OPCODE 213
+#define __GLX_MIN_SINGLE_OPCODE 1
+#define __GLX_MAX_SINGLE_OPCODE 159
+#define __GLX_SINGLE_TABLE_SIZE 160
+#define __GLX_RENDER_TABLE_SIZE 214
+
+#define __GLX_MIN_RENDER_OPCODE_EXT 4096
+#define __GLX_MAX_RENDER_OPCODE_EXT 4123
+
+extern __GLXdispatchSingleProcPtr __glXSingleTable[__GLX_SINGLE_TABLE_SIZE];
+extern __GLXdispatchSingleProcPtr __glXSwapSingleTable[__GLX_SINGLE_TABLE_SIZE];
+#endif                          /* _GLX_g_disptab_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/g_disptab.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exevents.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exevents.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exevents.h	(Revision 52145)
@@ -0,0 +1,307 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/********************************************************************
+ * Interface of 'exevents.c'
+ */
+
+#ifndef EXEVENTS_H
+#define EXEVENTS_H
+
+#include <X11/extensions/XIproto.h>
+#include "inputstr.h"
+
+/***************************************************************
+ *              Interface available to drivers                 *
+ ***************************************************************/
+
+/**
+ * Scroll flags for ::SetScrollValuator.
+ */
+enum ScrollFlags {
+    SCROLL_FLAG_NONE = 0,
+    /**
+     * Do not emulate legacy button events for valuator events on this axis.
+     */
+    SCROLL_FLAG_DONT_EMULATE = (1 << 1),
+    /**
+     * This axis is the preferred axis for valuator emulation for this axis'
+     * scroll type.
+     */
+    SCROLL_FLAG_PREFERRED = (1 << 2)
+};
+
+extern _X_EXPORT int InitProximityClassDeviceStruct(DeviceIntPtr /* dev */ );
+
+extern _X_EXPORT Bool InitValuatorAxisStruct(DeviceIntPtr /* dev */ ,
+                                             int /* axnum */ ,
+                                             Atom /* label */ ,
+                                             int /* minval */ ,
+                                             int /* maxval */ ,
+                                             int /* resolution */ ,
+                                             int /* min_res */ ,
+                                             int /* max_res */ ,
+                                             int /* mode */ );
+
+extern _X_EXPORT Bool SetScrollValuator(DeviceIntPtr /* dev */ ,
+                                        int /* axnum */ ,
+                                        enum ScrollType /* type */ ,
+                                        double /* increment */ ,
+                                        int /* flags */ );
+
+/* Input device properties */
+extern _X_EXPORT void XIDeleteAllDeviceProperties(DeviceIntPtr  /* device */
+    );
+
+extern _X_EXPORT int XIDeleteDeviceProperty(DeviceIntPtr /* device */ ,
+                                            Atom /* property */ ,
+                                            Bool        /* fromClient */
+    );
+
+extern _X_EXPORT int XIChangeDeviceProperty(DeviceIntPtr /* dev */ ,
+                                            Atom /* property */ ,
+                                            Atom /* type */ ,
+                                            int /* format */ ,
+                                            int /* mode */ ,
+                                            unsigned long /* len */ ,
+                                            const void * /* value */ ,
+                                            Bool        /* sendevent */
+    );
+
+extern _X_EXPORT int XIGetDeviceProperty(DeviceIntPtr /* dev */ ,
+                                         Atom /* property */ ,
+                                         XIPropertyValuePtr *   /* value */
+    );
+
+extern _X_EXPORT int XISetDevicePropertyDeletable(DeviceIntPtr /* dev */ ,
+                                                  Atom /* property */ ,
+                                                  Bool  /* deletable */
+    );
+
+extern _X_EXPORT long XIRegisterPropertyHandler(DeviceIntPtr dev,
+                                                int (*SetProperty) (DeviceIntPtr
+                                                                    dev,
+                                                                    Atom
+                                                                    property,
+                                                                    XIPropertyValuePtr
+                                                                    prop,
+                                                                    BOOL
+                                                                    checkonly),
+                                                int (*GetProperty) (DeviceIntPtr
+                                                                    dev,
+                                                                    Atom
+                                                                    property),
+                                                int (*DeleteProperty)
+                                                (DeviceIntPtr dev,
+                                                 Atom property)
+    );
+
+extern _X_EXPORT void XIUnregisterPropertyHandler(DeviceIntPtr dev, long id);
+
+extern _X_EXPORT Atom XIGetKnownProperty(const char *name);
+
+extern _X_EXPORT DeviceIntPtr XIGetDevice(xEvent *ev);
+
+extern _X_EXPORT int XIPropToInt(XIPropertyValuePtr val,
+                                 int *nelem_return, int **buf_return);
+
+extern _X_EXPORT int XIPropToFloat(XIPropertyValuePtr val,
+                                   int *nelem_return, float **buf_return);
+
+/****************************************************************************
+ *                      End of driver interface                             *
+ ****************************************************************************/
+
+/**
+ * Attached to the devPrivates of each client. Specifies the version number as
+ * supported by the client.
+ */
+typedef struct _XIClientRec {
+    int major_version;
+    int minor_version;
+} XIClientRec, *XIClientPtr;
+
+typedef struct _GrabParameters {
+    int grabtype;               /* CORE, etc. */
+    unsigned int ownerEvents;
+    unsigned int this_device_mode;
+    unsigned int other_devices_mode;
+    Window grabWindow;
+    Window confineTo;
+    Cursor cursor;
+    unsigned int modifiers;
+} GrabParameters;
+
+extern int
+ UpdateDeviceState(DeviceIntPtr /* device */ ,
+                   DeviceEvent * /*  xE    */ );
+
+extern void
+ ProcessOtherEvent(InternalEvent * /* ev */ ,
+                   DeviceIntPtr /* other */ );
+
+extern int
+ CheckGrabValues(ClientPtr /* client */ ,
+                 GrabParameters * /* param */ );
+
+extern int
+ GrabButton(ClientPtr /* client */ ,
+            DeviceIntPtr /* dev */ ,
+            DeviceIntPtr /* modifier_device */ ,
+            int /* button */ ,
+            GrabParameters * /* param */ ,
+            enum InputLevel /* grabtype */ ,
+            GrabMask * /* eventMask */ );
+
+extern int
+ GrabKey(ClientPtr /* client */ ,
+         DeviceIntPtr /* dev */ ,
+         DeviceIntPtr /* modifier_device */ ,
+         int /* key */ ,
+         GrabParameters * /* param */ ,
+         enum InputLevel /* grabtype */ ,
+         GrabMask * /* eventMask */ );
+
+extern int
+ GrabWindow(ClientPtr /* client */ ,
+            DeviceIntPtr /* dev */ ,
+            int /* type */ ,
+            GrabParameters * /* param */ ,
+            GrabMask * /* eventMask */ );
+
+extern int
+ GrabTouch(ClientPtr /* client */ ,
+           DeviceIntPtr /* dev */ ,
+           DeviceIntPtr /* mod_dev */ ,
+           GrabParameters * /* param */ ,
+           GrabMask * /* eventMask */ );
+
+extern int
+ SelectForWindow(DeviceIntPtr /* dev */ ,
+                 WindowPtr /* pWin */ ,
+                 ClientPtr /* client */ ,
+                 Mask /* mask */ ,
+                 Mask /* exclusivemasks */ );
+
+extern int
+ AddExtensionClient(WindowPtr /* pWin */ ,
+                    ClientPtr /* client */ ,
+                    Mask /* mask */ ,
+                    int /* mskidx */ );
+
+extern void
+ RecalculateDeviceDeliverableEvents(WindowPtr /* pWin */ );
+
+extern int
+ InputClientGone(WindowPtr /* pWin */ ,
+                 XID /* id */ );
+
+extern void
+ WindowGone(WindowPtr /* win */ );
+
+extern int
+ SendEvent(ClientPtr /* client */ ,
+           DeviceIntPtr /* d */ ,
+           Window /* dest */ ,
+           Bool /* propagate */ ,
+           xEvent * /* ev */ ,
+           Mask /* mask */ ,
+           int /* count */ );
+
+extern int
+ SetButtonMapping(ClientPtr /* client */ ,
+                  DeviceIntPtr /* dev */ ,
+                  int /* nElts */ ,
+                  BYTE * /* map */ );
+
+extern int
+ ChangeKeyMapping(ClientPtr /* client */ ,
+                  DeviceIntPtr /* dev */ ,
+                  unsigned /* len */ ,
+                  int /* type */ ,
+                  KeyCode /* firstKeyCode */ ,
+                  CARD8 /* keyCodes */ ,
+                  CARD8 /* keySymsPerKeyCode */ ,
+                  KeySym * /* map */ );
+
+extern void
+ DeleteWindowFromAnyExtEvents(WindowPtr /* pWin */ ,
+                              Bool /* freeResources */ );
+
+extern int
+ MaybeSendDeviceMotionNotifyHint(deviceKeyButtonPointer * /* pEvents */ ,
+                                 Mask /* mask */ );
+
+extern void
+ CheckDeviceGrabAndHintWindow(WindowPtr /* pWin */ ,
+                              int /* type */ ,
+                              deviceKeyButtonPointer * /* xE */ ,
+                              GrabPtr /* grab */ ,
+                              ClientPtr /* client */ ,
+                              Mask /* deliveryMask */ );
+
+extern void
+ MaybeStopDeviceHint(DeviceIntPtr /* dev */ ,
+                     ClientPtr /* client */ );
+
+extern int
+ DeviceEventSuppressForWindow(WindowPtr /* pWin */ ,
+                              ClientPtr /* client */ ,
+                              Mask /* mask */ ,
+                              int /* maskndx */ );
+
+extern void
+ SendEventToAllWindows(DeviceIntPtr /* dev */ ,
+                       Mask /* mask */ ,
+                       xEvent * /* ev */ ,
+                       int /* count */ );
+
+extern void
+ TouchRejected(DeviceIntPtr /* sourcedev */ ,
+               TouchPointInfoPtr /* ti */ ,
+               XID /* resource */ ,
+               TouchOwnershipEvent * /* ev */ );
+
+extern _X_HIDDEN void XI2EventSwap(xGenericEvent * /* from */ ,
+                                   xGenericEvent * /* to */ );
+
+/* For an event such as MappingNotify which affects client interpretation
+ * of input events sent by device dev, should we notify the client, or
+ * would it merely be irrelevant and confusing? */
+extern int
+ XIShouldNotify(ClientPtr client, DeviceIntPtr dev);
+
+extern void
+ XISendDeviceChangedEvent(DeviceIntPtr device, DeviceChangedEvent *dce);
+
+extern int
+
+XISetEventMask(DeviceIntPtr dev, WindowPtr win, ClientPtr client,
+               unsigned int len, unsigned char *mask);
+
+extern int
+ XICheckInvalidMaskBits(ClientPtr client, unsigned char *mask, int len);
+
+#endif                          /* EXEVENTS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exevents.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_reqsize.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_reqsize.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_reqsize.h	(Revision 52145)
@@ -0,0 +1,151 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_REQSIZE_H_ )
+#define _INDIRECT_REQSIZE_H_
+
+#include <X11/Xfuncproto.h>
+
+#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#define PURE __attribute__((pure))
+#else
+#define PURE
+#endif
+
+extern PURE _X_HIDDEN int __glXCallListsReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXBitmapReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXFogfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXFogivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXLightfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXLightivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXLightModelfvReqSize(const GLbyte * pc,
+                                                   Bool swap);
+extern PURE _X_HIDDEN int __glXLightModelivReqSize(const GLbyte * pc,
+                                                   Bool swap);
+extern PURE _X_HIDDEN int __glXMaterialfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXMaterialivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXPolygonStippleReqSize(const GLbyte * pc,
+                                                     Bool swap);
+extern PURE _X_HIDDEN int __glXTexParameterfvReqSize(const GLbyte * pc,
+                                                     Bool swap);
+extern PURE _X_HIDDEN int __glXTexParameterivReqSize(const GLbyte * pc,
+                                                     Bool swap);
+extern PURE _X_HIDDEN int __glXTexImage1DReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexImage2DReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexEnvfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexEnvivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexGendvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexGenfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexGenivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXMap1dReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXMap1fReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXMap2dReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXMap2fReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXPixelMapfvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXPixelMapuivReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXPixelMapusvReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXDrawPixelsReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXDrawArraysReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXPrioritizeTexturesReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXTexSubImage1DReqSize(const GLbyte * pc,
+                                                    Bool swap);
+extern PURE _X_HIDDEN int __glXTexSubImage2DReqSize(const GLbyte * pc,
+                                                    Bool swap);
+extern PURE _X_HIDDEN int __glXColorTableReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXColorTableParameterfvReqSize(const GLbyte * pc,
+                                                            Bool swap);
+extern PURE _X_HIDDEN int __glXColorTableParameterivReqSize(const GLbyte * pc,
+                                                            Bool swap);
+extern PURE _X_HIDDEN int __glXColorSubTableReqSize(const GLbyte * pc,
+                                                    Bool swap);
+extern PURE _X_HIDDEN int __glXConvolutionFilter1DReqSize(const GLbyte * pc,
+                                                          Bool swap);
+extern PURE _X_HIDDEN int __glXConvolutionFilter2DReqSize(const GLbyte * pc,
+                                                          Bool swap);
+extern PURE _X_HIDDEN int __glXConvolutionParameterfvReqSize(const GLbyte * pc,
+                                                             Bool swap);
+extern PURE _X_HIDDEN int __glXConvolutionParameterivReqSize(const GLbyte * pc,
+                                                             Bool swap);
+extern PURE _X_HIDDEN int __glXSeparableFilter2DReqSize(const GLbyte * pc,
+                                                        Bool swap);
+extern PURE _X_HIDDEN int __glXTexImage3DReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXTexSubImage3DReqSize(const GLbyte * pc,
+                                                    Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexImage1DReqSize(const GLbyte * pc,
+                                                           Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexImage2DReqSize(const GLbyte * pc,
+                                                           Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexImage3DReqSize(const GLbyte * pc,
+                                                           Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage1DReqSize(const GLbyte * pc,
+                                                              Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage2DReqSize(const GLbyte * pc,
+                                                              Bool swap);
+extern PURE _X_HIDDEN int __glXCompressedTexSubImage3DReqSize(const GLbyte * pc,
+                                                              Bool swap);
+extern PURE _X_HIDDEN int __glXPointParameterfvReqSize(const GLbyte * pc,
+                                                       Bool swap);
+extern PURE _X_HIDDEN int __glXPointParameterivReqSize(const GLbyte * pc,
+                                                       Bool swap);
+extern PURE _X_HIDDEN int __glXDrawBuffersReqSize(const GLbyte * pc, Bool swap);
+extern PURE _X_HIDDEN int __glXProgramStringARBReqSize(const GLbyte * pc,
+                                                       Bool swap);
+extern PURE _X_HIDDEN int __glXDeleteFramebuffersReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXDeleteRenderbuffersReqSize(const GLbyte * pc,
+                                                          Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs1dvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs1fvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs1svNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs2dvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs2fvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs2svNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs3dvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs3fvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs3svNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs4dvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs4fvNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs4svNVReqSize(const GLbyte * pc,
+                                                         Bool swap);
+extern PURE _X_HIDDEN int __glXVertexAttribs4ubvNVReqSize(const GLbyte * pc,
+                                                          Bool swap);
+
+#undef PURE
+
+#endif                          /* !defined( _INDIRECT_REQSIZE_H_ ) */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_reqsize.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixgrabs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixgrabs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixgrabs.h	(Revision 52145)
@@ -0,0 +1,64 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXGRABS_H
+#define DIXGRABS_H 1
+
+struct _GrabParameters;
+
+extern void PrintDeviceGrabInfo(DeviceIntPtr dev);
+extern void UngrabAllDevices(Bool kill_client);
+
+extern GrabPtr AllocGrab(const GrabPtr src);
+extern void FreeGrab(GrabPtr grab);
+extern Bool CopyGrab(GrabPtr dst, const GrabPtr src);
+
+extern GrabPtr CreateGrab(int /* client */ ,
+                          DeviceIntPtr /* device */ ,
+                          DeviceIntPtr /* modDevice */ ,
+                          WindowPtr /* window */ ,
+                          enum InputLevel /* grabtype */ ,
+                          GrabMask * /* mask */ ,
+                          struct _GrabParameters * /* param */ ,
+                          int /* type */ ,
+                          KeyCode /* keybut */ ,
+                          WindowPtr /* confineTo */ ,
+                          CursorPtr /* cursor */ );
+
+extern _X_EXPORT int DeletePassiveGrab(void */* value */ ,
+                                       XID /* id */ );
+
+extern _X_EXPORT Bool GrabMatchesSecond(GrabPtr /* pFirstGrab */ ,
+                                        GrabPtr /* pSecondGrab */ ,
+                                        Bool /*ignoreDevice */ );
+
+extern _X_EXPORT int AddPassiveGrabToList(ClientPtr /* client */ ,
+                                          GrabPtr /* pGrab */ );
+
+extern _X_EXPORT Bool DeletePassiveGrabFromList(GrabPtr /* pMinuendGrab */ );
+
+extern Bool GrabIsPointerGrab(GrabPtr grab);
+extern Bool GrabIsKeyboardGrab(GrabPtr grab);
+#endif                          /* DIXGRABS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixgrabs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BT.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BT.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BT.h	(Revision 52145)
@@ -0,0 +1,37 @@
+
+#include "xf86RamDac.h"
+
+extern _X_EXPORT RamDacHelperRecPtr BTramdacProbe(ScrnInfoPtr pScrn,
+                                                  RamDacSupportedInfoRecPtr
+                                                  ramdacs);
+extern _X_EXPORT void BTramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                   RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                      RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacSetBpp(ScrnInfoPtr pScrn,
+                                     RamDacRegRecPtr RamDacRegRec);
+
+#define ATT20C504_RAMDAC 	(VENDOR_BT << 16) | 0x00
+#define ATT20C505_RAMDAC 	(VENDOR_BT << 16) | 0x01
+#define BT485_RAMDAC		(VENDOR_BT << 16) | 0x02
+
+/*
+ * BT registers
+ */
+
+#define BT_WRITE_ADDR		0x00
+#define BT_RAMDAC_DATA		0x01
+#define BT_PIXEL_MASK		0x02
+#define BT_READ_ADDR		0x03
+#define BT_CURS_WR_ADDR		0x04
+#define BT_CURS_DATA		0x05
+#define BT_COMMAND_REG_0	0x06
+#define BT_CURS_RD_ADDR		0x07
+#define BT_COMMAND_REG_1	0x08
+#define BT_COMMAND_REG_2	0x09
+#define BT_STATUS_REG		0x0A
+#define BT_CURS_RAM_DATA	0x0B
+#define BT_CURS_X_LOW		0x0C
+#define BT_CURS_X_HIGH		0x0D
+#define BT_CURS_Y_LOW		0x0E
+#define BT_CURS_Y_HIGH		0x0F

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BT.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmmap.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETMMAP_H
+#define SETMMAP_H 1
+
+int SProcXSetDeviceModifierMapping(ClientPtr    /* client */
+    );
+
+int ProcXSetDeviceModifierMapping(ClientPtr     /* client */
+    );
+
+void SRepXSetDeviceModifierMapping(ClientPtr /* client */ ,
+                                   int /* size */ ,
+                                   xSetDeviceModifierMappingReply *     /* rep */
+    );
+
+#endif                          /* SETMMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setmmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixes.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixes.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixes.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/*
+ * Copyright ¬© 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XFIXES_H_
+#define _XFIXES_H_
+
+#include "resource.h"
+
+extern _X_EXPORT RESTYPE RegionResType;
+extern _X_EXPORT int XFixesErrorBase;
+
+#define VERIFY_REGION(pRegion, rid, client, mode)			\
+    do {								\
+	int err;							\
+	err = dixLookupResourceByType((void **) &pRegion, rid,	\
+				      RegionResType, client, mode);	\
+	if (err != Success) {						\
+	    client->errorValue = rid;					\
+	    return err;							\
+	}								\
+    } while (0)
+
+#define VERIFY_REGION_OR_NONE(pRegion, rid, client, mode) { \
+    pRegion = 0; \
+    if (rid) VERIFY_REGION(pRegion, rid, client, mode); \
+}
+
+extern _X_EXPORT RegionPtr
+ XFixesRegionCopy(RegionPtr pRegion);
+
+#include "xibarriers.h"
+
+#endif                          /* _XFIXES_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixes.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinput.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinput.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinput.h	(Revision 52145)
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Kevin E. Martin <kem@redhat.com>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * This file provides access to:
+ * - global variables available to all hw/dmx routines, and
+ * - enumerations and typedefs needed by input routines in hw/dmx (and
+ *   hw/dmx/input).
+ *
+ * The goal is that no files in hw/dmx should include header files from
+ * hw/dmx/input -- the interface defined here should be the only
+ * interface exported to the hw/dmx layer.  \see input/dmxinputinit.c.
+ */
+
+#ifndef DMXINPUT_H
+#define DMXINPUT_H
+
+/** Maximum number of file descriptors for SIGIO handling */
+#define DMX_MAX_SIGIO_FDS 4
+
+struct _DMXInputInfo;
+
+/** Reason why window layout was updated. */
+typedef enum {
+    DMX_UPDATE_REALIZE,         /**< Window realized        */
+    DMX_UPDATE_UNREALIZE,       /**< Window unrealized      */
+    DMX_UPDATE_RESTACK,         /**< Stacking order changed */
+    DMX_UPDATE_COPY,            /**< Window copied          */
+    DMX_UPDATE_RESIZE,          /**< Window resized         */
+    DMX_UPDATE_REPARENT         /**< Window reparented      */
+} DMXUpdateType;
+
+typedef void (*ProcessInputEventsProc) (struct _DMXInputInfo *);
+typedef void (*UpdateWindowInfoProc) (struct _DMXInputInfo *,
+                                      DMXUpdateType, WindowPtr);
+
+/** An opaque structure that is only exposed in the dmx/input layer. */
+typedef struct _DMXLocalInputInfo *DMXLocalInputInfoPtr;
+
+/** State of the SIGIO engine */
+typedef enum {
+    DMX_NOSIGIO = 0,            /**< Device does not use SIGIO at all. */
+    DMX_USESIGIO,               /**< Device can use SIGIO, but is not
+                                 * (e.g., because the VT is switch
+                                 * away). */
+    DMX_ACTIVESIGIO             /**< Device is currently using SIGIO. */
+} dmxSigioState;
+
+/** DMXInputInfo is typedef'd in \a dmx.h so that all routines can have
+ * access to the global pointers.  However, the elements are only
+ * available to input-related routines. */
+struct _DMXInputInfo {
+    const char *name;              /**< Name of input display or device
+                                    * (from command line or config
+                                    * file)  */
+    Bool freename;                    /**< If true, free name on destroy */
+    Bool detached;                    /**< If true, input screen is detached */
+    int inputIdx;                     /**< Index into #dmxInputs global */
+    int scrnIdx;                      /**< Index into #dmxScreens global */
+    Bool core;                     /**< If True, initialize these
+                                    * devices as devices that send core
+                                    * events */
+    Bool console;                    /**< True if console and backend
+                                      * input share the same backend
+                                      * display  */
+
+    Bool windows;                    /**< True if window outlines are
+                                      * draw in console */
+
+    ProcessInputEventsProc processInputEvents;
+    UpdateWindowInfoProc updateWindowInfo;
+
+    /* Local input information */
+    dmxSigioState sigioState;              /**< Current stat */
+    int sigioFdCount;                      /**< Number of fds in use */
+    int sigioFd[DMX_MAX_SIGIO_FDS];                        /**< List of fds */
+    Bool sigioAdded[DMX_MAX_SIGIO_FDS];                    /**< Active fds */
+
+    /** True if a VT switch is pending, but has not yet happened. */
+    int vt_switch_pending;
+
+    /** True if a VT switch has happened. */
+    int vt_switched;
+
+    /** Number of devices handled in this _DMXInputInfo structure. */
+    int numDevs;
+
+    /** List of actual input devices.  Each _DMXInputInfo structure can
+     * refer to more than one device.  For example, the keyboard and the
+     * pointer of a backend display; or all of the XInput extension
+     * devices on a backend display. */
+    DMXLocalInputInfoPtr *devs;
+
+    char *keycodes;                    /**< XKB keycodes from command line */
+    char *symbols;                     /**< XKB symbols from command line */
+    char *geometry;                    /**< XKB geometry from command line */
+};
+
+extern int dmxNumInputs;                  /**< Number of #dmxInputs */
+extern DMXInputInfo *dmxInputs;           /**< List of inputs */
+
+extern void dmxInputInit(DMXInputInfo * dmxInput);
+extern void dmxInputReInit(DMXInputInfo * dmxInput);
+extern void dmxInputLateReInit(DMXInputInfo * dmxInput);
+extern void dmxInputFree(DMXInputInfo * dmxInput);
+extern void dmxInputLogDevices(void);
+extern void dmxUpdateWindowInfo(DMXUpdateType type, WindowPtr pWindow);
+
+/* These functions are defined in input/dmxeq.c */
+extern void dmxeqSwitchScreen(DeviceIntPtr pDev, ScreenPtr pScreen,
+                              Bool fromDIX);
+
+/* This type is used in input/dmxevents.c.  Also, these functions are
+ * defined in input/dmxevents.c */
+typedef enum {
+    DMX_NO_BLOCK = 0,
+    DMX_BLOCK = 1
+} DMXBlockType;
+
+extern void dmxGetGlobalPosition(int *x, int *y);
+extern DMXScreenInfo *dmxFindFirstScreen(int x, int y);
+extern void dmxCoreMotion(DevicePtr pDev, int x, int y, int delta,
+                          DMXBlockType block);
+
+/* Support for dynamic addition of inputs.  This functions is defined in
+ * config/dmxconfig.c */
+extern DMXInputInfo *dmxConfigAddInput(const char *name, int core);
+#endif                          /* DMXINPUT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinput.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86x86emu.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86x86emu.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86x86emu.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef XF86X86EMU_H_
+#define XF86X86EMU_H_
+#include <x86emu.h>
+
+#define M _X86EMU_env
+
+#define X86_EAX M.x86.R_EAX
+#define X86_EBX M.x86.R_EBX
+#define X86_ECX M.x86.R_ECX
+#define X86_EDX M.x86.R_EDX
+#define X86_ESI M.x86.R_ESI
+#define X86_EDI M.x86.R_EDI
+#define X86_EBP M.x86.R_EBP
+#define X86_EIP M.x86.R_EIP
+#define X86_ESP M.x86.R_ESP
+#define X86_EFLAGS M.x86.R_EFLG
+
+#define X86_FLAGS M.x86.R_FLG
+#define X86_AX M.x86.R_AX
+#define X86_BX M.x86.R_BX
+#define X86_CX M.x86.R_CX
+#define X86_DX M.x86.R_DX
+#define X86_SI M.x86.R_SI
+#define X86_DI M.x86.R_DI
+#define X86_BP M.x86.R_BP
+#define X86_IP M.x86.R_IP
+#define X86_SP M.x86.R_SP
+#define X86_CS M.x86.R_CS
+#define X86_DS M.x86.R_DS
+#define X86_ES M.x86.R_ES
+#define X86_SS M.x86.R_SS
+#define X86_FS M.x86.R_FS
+#define X86_GS M.x86.R_GS
+
+#define X86_AL M.x86.R_AL
+#define X86_BL M.x86.R_BL
+#define X86_CL M.x86.R_CL
+#define X86_DL M.x86.R_DL
+
+#define X86_AH M.x86.R_AH
+#define X86_BH M.x86.R_BH
+#define X86_CH M.x86.R_CH
+#define X86_DH M.x86.R_DH
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86x86emu.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx_glxvisuals.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx_glxvisuals.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx_glxvisuals.h	(Revision 52145)
@@ -0,0 +1,57 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLXVISUALS_H
+#define _GLXVISUALS_H
+
+#include <GL/glxint.h>
+
+/** GLX Visual private area. */
+typedef struct {
+    int x_visual_depth;
+    int x_visual_class;
+} dmxGlxVisualPrivate;
+
+__GLXvisualConfig *GetGLXVisualConfigs(Display * dpy,
+                                       int screen, int *nconfigs);
+
+__GLXFBConfig *GetGLXFBConfigs(Display * dpy,
+                               int glxMajorOpcode, int *nconfigs);
+
+__GLXvisualConfig *GetGLXVisualConfigsFromFBConfigs(__GLXFBConfig * fbconfigs,
+                                                    int nfbconfigs,
+                                                    XVisualInfo * visuals,
+                                                    int nvisuals,
+                                                    __GLXvisualConfig
+                                                    * glxConfigs,
+                                                    int nGlxConfigs,
+                                                    int *nconfigs);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx_glxvisuals.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfont.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfont.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfont.h	(Revision 52145)
@@ -0,0 +1,147 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXFONT_H
+#define DIXFONT_H 1
+
+#include "dix.h"
+#include <X11/fonts/font.h>
+#include "closure.h"
+#include <X11/fonts/fontstruct.h>
+#include <X11/fonts/fontproto.h>
+
+#define NullDIXFontProp ((DIXFontPropPtr)0)
+
+typedef struct _DIXFontProp *DIXFontPropPtr;
+
+extern _X_EXPORT Bool SetDefaultFont(const char * /*defaultfontname */ );
+
+extern _X_EXPORT void QueueFontWakeup(FontPathElementPtr /*fpe */ );
+
+extern _X_EXPORT void RemoveFontWakeup(FontPathElementPtr /*fpe */ );
+
+extern _X_EXPORT void FontWakeup(void */*data */ ,
+                                 int /*count */ ,
+                                 void */*LastSelectMask */ );
+
+extern _X_EXPORT int OpenFont(ClientPtr /*client */ ,
+                              XID /*fid */ ,
+                              Mask /*flags */ ,
+                              unsigned /*lenfname */ ,
+                              const char * /*pfontname */ );
+
+extern _X_EXPORT int CloseFont(void */*pfont */ ,
+                               XID /*fid */ );
+
+typedef struct _xQueryFontReply *xQueryFontReplyPtr;
+
+extern _X_EXPORT void QueryFont(FontPtr /*pFont */ ,
+                                xQueryFontReplyPtr /*pReply */ ,
+                                int /*nProtoCCIStructs */ );
+
+extern _X_EXPORT int ListFonts(ClientPtr /*client */ ,
+                               unsigned char * /*pattern */ ,
+                               unsigned int /*length */ ,
+                               unsigned int /*max_names */ );
+
+extern _X_EXPORT int
+ doListFontsWithInfo(ClientPtr /*client */ ,
+                     LFWIclosurePtr /*c */ );
+
+extern _X_EXPORT int doPolyText(ClientPtr /*client */ ,
+                                PTclosurePtr    /*c */
+    );
+
+extern _X_EXPORT int PolyText(ClientPtr /*client */ ,
+                              DrawablePtr /*pDraw */ ,
+                              GCPtr /*pGC */ ,
+                              unsigned char * /*pElt */ ,
+                              unsigned char * /*endReq */ ,
+                              int /*xorg */ ,
+                              int /*yorg */ ,
+                              int /*reqType */ ,
+                              XID /*did */ );
+
+extern _X_EXPORT int doImageText(ClientPtr /*client */ ,
+                                 ITclosurePtr /*c */ );
+
+extern _X_EXPORT int ImageText(ClientPtr /*client */ ,
+                               DrawablePtr /*pDraw */ ,
+                               GCPtr /*pGC */ ,
+                               int /*nChars */ ,
+                               unsigned char * /*data */ ,
+                               int /*xorg */ ,
+                               int /*yorg */ ,
+                               int /*reqType */ ,
+                               XID /*did */ );
+
+extern _X_EXPORT int SetFontPath(ClientPtr /*client */ ,
+                                 int /*npaths */ ,
+                                 unsigned char * /*paths */ );
+
+extern _X_EXPORT int SetDefaultFontPath(const char * /*path */ );
+
+extern _X_EXPORT int GetFontPath(ClientPtr client,
+                                 int *count,
+                                 int *length, unsigned char **result);
+
+extern _X_EXPORT void DeleteClientFontStuff(ClientPtr /*client */ );
+
+/* Quartz support on Mac OS X pulls in the QuickDraw
+   framework whose InitFonts function conflicts here. */
+#ifdef __APPLE__
+#define InitFonts Darwin_X_InitFonts
+#endif
+extern _X_EXPORT void InitFonts(void);
+
+extern _X_EXPORT void FreeFonts(void);
+
+extern _X_EXPORT FontPtr find_old_font(XID /*id */ );
+
+#define GetGlyphs dixGetGlyphs
+extern _X_EXPORT void dixGetGlyphs(FontPtr /*font */ ,
+                                   unsigned long /*count */ ,
+                                   unsigned char * /*chars */ ,
+                                   FontEncoding /*fontEncoding */ ,
+                                   unsigned long * /*glyphcount */ ,
+                                   CharInfoPtr * /*glyphs */ );
+
+extern _X_EXPORT void QueryGlyphExtents(FontPtr /*pFont */ ,
+                                        CharInfoPtr * /*charinfo */ ,
+                                        unsigned long /*count */ ,
+                                        ExtentInfoPtr /*info */ );
+
+extern _X_EXPORT Bool QueryTextExtents(FontPtr /*pFont */ ,
+                                       unsigned long /*count */ ,
+                                       unsigned char * /*chars */ ,
+                                       ExtentInfoPtr /*info */ );
+
+extern _X_EXPORT Bool ParseGlyphCachingMode(char * /*str */ );
+
+extern _X_EXPORT void InitGlyphCaching(void);
+
+extern _X_EXPORT void SetGlyphCachingMode(int /*newmode */ );
+
+extern _X_EXPORT void register_fpe_functions(void);
+
+#endif                          /* DIXFONT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfont.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiselectev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiselectev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiselectev.h	(Revision 52145)
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XISELECTEVENTS_H
+#define XISELECTEVENTS_H 1
+
+int SProcXISelectEvents(ClientPtr client);
+int ProcXISelectEvents(ClientPtr client);
+int SProcXIGetSelectedEvents(ClientPtr client);
+int ProcXIGetSelectedEvents(ClientPtr client);
+void SRepXIGetSelectedEvents(ClientPtr client,
+                             int len, xXIGetSelectedEventsReply * rep);
+
+#endif                          /* _XISELECTEVENTS_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiselectev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regionstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regionstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regionstr.h	(Revision 52145)
@@ -0,0 +1,376 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef REGIONSTRUCT_H
+#define REGIONSTRUCT_H
+
+typedef struct pixman_region16 RegionRec, *RegionPtr;
+
+#include "miscstruct.h"
+
+/* Return values from RectIn() */
+
+#define rgnOUT 0
+#define rgnIN  1
+#define rgnPART 2
+
+#define NullRegion ((RegionPtr)0)
+
+/*
+ *   clip region
+ */
+
+typedef struct pixman_region16_data RegDataRec, *RegDataPtr;
+
+extern _X_EXPORT BoxRec RegionEmptyBox;
+extern _X_EXPORT RegDataRec RegionEmptyData;
+extern _X_EXPORT RegDataRec RegionBrokenData;
+static inline Bool
+RegionNil(RegionPtr reg)
+{
+    return ((reg)->data && !(reg)->data->numRects);
+}
+
+/* not a region */
+
+static inline Bool
+RegionNar(RegionPtr reg)
+{
+    return ((reg)->data == &RegionBrokenData);
+}
+
+static inline int
+RegionNumRects(RegionPtr reg)
+{
+    return ((reg)->data ? (reg)->data->numRects : 1);
+}
+
+static inline int
+RegionSize(RegionPtr reg)
+{
+    return ((reg)->data ? (reg)->data->size : 0);
+}
+
+static inline BoxPtr
+RegionRects(RegionPtr reg)
+{
+    return ((reg)->data ? (BoxPtr) ((reg)->data + 1) : &(reg)->extents);
+}
+
+static inline BoxPtr
+RegionBoxptr(RegionPtr reg)
+{
+    return ((BoxPtr) ((reg)->data + 1));
+}
+
+static inline BoxPtr
+RegionBox(RegionPtr reg, int i)
+{
+    return (&RegionBoxptr(reg)[i]);
+}
+
+static inline BoxPtr
+RegionTop(RegionPtr reg)
+{
+    return RegionBox(reg, (reg)->data->numRects);
+}
+
+static inline BoxPtr
+RegionEnd(RegionPtr reg)
+{
+    return RegionBox(reg, (reg)->data->numRects - 1);
+}
+
+static inline size_t
+RegionSizeof(int n)
+{
+    return (sizeof(RegDataRec) + ((n) * sizeof(BoxRec)));
+}
+
+static inline void
+RegionInit(RegionPtr _pReg, BoxPtr _rect, int _size)
+{
+    if ((_rect) != NULL) {
+        (_pReg)->extents = *(_rect);
+        (_pReg)->data = (RegDataPtr) NULL;
+    }
+    else {
+        (_pReg)->extents = RegionEmptyBox;
+        if (((_size) > 1) && ((_pReg)->data =
+                              (RegDataPtr) malloc(RegionSizeof(_size)))) {
+            (_pReg)->data->size = (_size);
+            (_pReg)->data->numRects = 0;
+        }
+        else
+            (_pReg)->data = &RegionEmptyData;
+    }
+}
+
+static inline Bool
+RegionInitBoxes(RegionPtr pReg, BoxPtr boxes, int nBoxes)
+{
+    return pixman_region_init_rects(pReg, boxes, nBoxes);
+}
+
+static inline void
+RegionUninit(RegionPtr _pReg)
+{
+    if ((_pReg)->data && (_pReg)->data->size) {
+        free((_pReg)->data);
+        (_pReg)->data = NULL;
+    }
+}
+
+static inline void
+RegionReset(RegionPtr _pReg, BoxPtr _pBox)
+{
+    (_pReg)->extents = *(_pBox);
+    RegionUninit(_pReg);
+    (_pReg)->data = (RegDataPtr) NULL;
+}
+
+static inline Bool
+RegionNotEmpty(RegionPtr _pReg)
+{
+    return !RegionNil(_pReg);
+}
+
+static inline Bool
+RegionBroken(RegionPtr _pReg)
+{
+    return RegionNar(_pReg);
+}
+
+static inline void
+RegionEmpty(RegionPtr _pReg)
+{
+    RegionUninit(_pReg);
+    (_pReg)->extents.x2 = (_pReg)->extents.x1;
+    (_pReg)->extents.y2 = (_pReg)->extents.y1;
+    (_pReg)->data = &RegionEmptyData;
+}
+
+static inline BoxPtr
+RegionExtents(RegionPtr _pReg)
+{
+    return (&(_pReg)->extents);
+}
+
+static inline void
+RegionNull(RegionPtr _pReg)
+{
+    (_pReg)->extents = RegionEmptyBox;
+    (_pReg)->data = &RegionEmptyData;
+}
+
+extern _X_EXPORT void InitRegions(void);
+
+extern _X_EXPORT RegionPtr RegionCreate(BoxPtr /*rect */ ,
+                                        int /*size */ );
+
+extern _X_EXPORT void RegionDestroy(RegionPtr /*pReg */ );
+
+extern _X_EXPORT RegionPtr RegionDuplicate(RegionPtr /* pOld */);
+
+static inline Bool
+RegionCopy(RegionPtr dst, RegionPtr src)
+{
+    return pixman_region_copy(dst, src);
+}
+
+static inline Bool
+RegionIntersect(RegionPtr newReg,       /* destination Region */
+                RegionPtr reg1, RegionPtr reg2  /* source regions     */
+    )
+{
+    return pixman_region_intersect(newReg, reg1, reg2);
+}
+
+static inline Bool
+RegionUnion(RegionPtr newReg,   /* destination Region */
+            RegionPtr reg1, RegionPtr reg2      /* source regions     */
+    )
+{
+    return pixman_region_union(newReg, reg1, reg2);
+}
+
+extern _X_EXPORT Bool RegionAppend(RegionPtr /*dstrgn */ ,
+                                   RegionPtr /*rgn */ );
+
+extern _X_EXPORT Bool RegionValidate(RegionPtr /*badreg */ ,
+                                     Bool * /*pOverlap */ );
+
+extern _X_EXPORT RegionPtr RegionFromRects(int /*nrects */ ,
+                                           xRectanglePtr /*prect */ ,
+                                           int /*ctype */ );
+
+/*-
+ *-----------------------------------------------------------------------
+ * Subtract --
+ *	Subtract regS from regM and leave the result in regD.
+ *	S stands for subtrahend, M for minuend and D for difference.
+ *
+ * Results:
+ *	TRUE if successful.
+ *
+ * Side Effects:
+ *	regD is overwritten.
+ *
+ *-----------------------------------------------------------------------
+ */
+static inline Bool
+RegionSubtract(RegionPtr regD, RegionPtr regM, RegionPtr regS)
+{
+    return pixman_region_subtract(regD, regM, regS);
+}
+
+/*-
+ *-----------------------------------------------------------------------
+ * Inverse --
+ *	Take a region and a box and return a region that is everything
+ *	in the box but not in the region. The careful reader will note
+ *	that this is the same as subtracting the region from the box...
+ *
+ * Results:
+ *	TRUE.
+ *
+ * Side Effects:
+ *	newReg is overwritten.
+ *
+ *-----------------------------------------------------------------------
+ */
+
+static inline Bool
+RegionInverse(RegionPtr newReg, /* Destination region */
+              RegionPtr reg1,   /* Region to invert */
+              BoxPtr invRect    /* Bounding box for inversion */
+    )
+{
+    return pixman_region_inverse(newReg, reg1, invRect);
+}
+
+static inline int
+RegionContainsRect(RegionPtr region, BoxPtr prect)
+{
+    return pixman_region_contains_rectangle(region, prect);
+}
+
+/* TranslateRegion(pReg, x, y)
+   translates in place
+*/
+
+static inline void
+RegionTranslate(RegionPtr pReg, int x, int y)
+{
+    pixman_region_translate(pReg, x, y);
+}
+
+extern _X_EXPORT Bool RegionBreak(RegionPtr /*pReg */ );
+
+static inline Bool
+RegionContainsPoint(RegionPtr pReg, int x, int y, BoxPtr box    /* "return" value */
+    )
+{
+    return pixman_region_contains_point(pReg, x, y, box);
+}
+
+static inline Bool
+RegionEqual(RegionPtr reg1, RegionPtr reg2)
+{
+    return pixman_region_equal(reg1, reg2);
+}
+
+extern _X_EXPORT Bool RegionRectAlloc(RegionPtr /*pRgn */ ,
+                                      int       /*n */
+    );
+
+#ifdef DEBUG
+extern _X_EXPORT Bool RegionIsValid(RegionPtr   /*prgn */
+    );
+#endif
+
+extern _X_EXPORT void RegionPrint(RegionPtr /*pReg */ );
+
+#define INCLUDE_LEGACY_REGION_DEFINES
+#ifdef INCLUDE_LEGACY_REGION_DEFINES
+
+#define REGION_NIL				RegionNil
+#define REGION_NAR				RegionNar
+#define REGION_NUM_RECTS			RegionNumRects
+#define REGION_SIZE				RegionSize
+#define REGION_RECTS				RegionRects
+#define REGION_BOXPTR				RegionBoxptr
+#define REGION_BOX				RegionBox
+#define REGION_TOP				RegionTop
+#define REGION_END				RegionEnd
+#define REGION_SZOF				RegionSizeof
+#define BITMAP_TO_REGION			BitmapToRegion
+#define REGION_CREATE(pScreen, r, s)		RegionCreate(r,s)
+#define REGION_COPY(pScreen, d, r)		RegionCopy(d, r)
+#define REGION_DESTROY(pScreen, r)		RegionDestroy(r)
+#define REGION_INTERSECT(pScreen, res, r1, r2)	RegionIntersect(res, r1, r2)
+#define REGION_UNION(pScreen, res, r1, r2)	RegionUnion(res, r1, r2)
+#define REGION_SUBTRACT(pScreen, res, r1, r2)	RegionSubtract(res, r1, r2)
+#define REGION_INVERSE(pScreen, n, r, b)	RegionInverse(n, r, b)
+#define REGION_TRANSLATE(pScreen, r, x, y)	RegionTranslate(r, x, y)
+#define RECT_IN_REGION(pScreen, r, b) 		RegionContainsRect(r, b)
+#define POINT_IN_REGION(pScreen, r, x, y, b) 	RegionContainsPoint(r, x, y, b)
+#define REGION_EQUAL(pScreen, r1, r2)		RegionEqual(r1, r2)
+#define REGION_APPEND(pScreen, d, r)		RegionAppend(d, r)
+#define REGION_VALIDATE(pScreen, r, o)		RegionValidate(r, o)
+#define RECTS_TO_REGION(pScreen, n, r, c)	RegionFromRects(n, r, c)
+#define REGION_BREAK(pScreen, r)		RegionBreak(r)
+#define REGION_INIT(pScreen, r, b, s)		RegionInit(r, b, s)
+#define REGION_UNINIT(pScreen, r)		RegionUninit(r)
+#define REGION_RESET(pScreen, r, b)		RegionReset(r, b)
+#define REGION_NOTEMPTY(pScreen, r)		RegionNotEmpty(r)
+#define REGION_BROKEN(pScreen, r)		RegionBroken(r)
+#define REGION_EMPTY(pScreen, r)		RegionEmpty(r)
+#define REGION_EXTENTS(pScreen, r)		RegionExtents(r)
+#define REGION_NULL(pScreen, r)			RegionNull(r)
+
+#endif                          /* INCLUDE_LEGACY_REGION_DEFINES */
+#endif                          /* REGIONSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regionstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TI.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TI.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TI.h	(Revision 52145)
@@ -0,0 +1,106 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT unsigned long TIramdacCalculateMNPForClock(unsigned long
+                                                            RefClock,
+                                                            unsigned long
+                                                            ReqClock,
+                                                            char IsPixClock,
+                                                            unsigned long
+                                                            MinClock,
+                                                            unsigned long
+                                                            MaxClock,
+                                                            unsigned long *rM,
+                                                            unsigned long *rN,
+                                                            unsigned long *rP);
+extern _X_EXPORT RamDacHelperRecPtr TIramdacProbe(ScrnInfoPtr pScrn,
+                                                  RamDacSupportedInfoRecPtr
+                                                  ramdacs);
+extern _X_EXPORT void TIramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                   RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                      RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3026SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3030SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacHWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void TIramdacLoadPalette(ScrnInfoPtr pScrn, int numColors,
+                                          int *indices, LOCO * colors,
+                                          VisualPtr pVisual);
+
+typedef void TIramdacLoadPaletteProc(ScrnInfoPtr, int, int *, LOCO *,
+                                     VisualPtr);
+extern _X_EXPORT TIramdacLoadPaletteProc *TIramdacLoadPaletteWeak(void);
+
+#define TI3030_RAMDAC		(VENDOR_TI << 16) | 0x00
+#define TI3026_RAMDAC		(VENDOR_TI << 16) | 0x01
+
+/*
+ * TI Ramdac registers
+ */
+
+#define TIDAC_rev		0x01
+#define TIDAC_ind_curs_ctrl	0x06
+#define TIDAC_byte_router_ctrl	0x07
+#define TIDAC_latch_ctrl	0x0f
+#define TIDAC_true_color_ctrl	0x18
+#define TIDAC_multiplex_ctrl	0x19
+#define TIDAC_clock_select	0x1a
+#define TIDAC_palette_page	0x1c
+#define TIDAC_general_ctrl	0x1d
+#define TIDAC_misc_ctrl		0x1e
+#define TIDAC_pll_addr		0x2c
+#define TIDAC_pll_pixel_data	0x2d
+#define TIDAC_pll_memory_data	0x2e
+#define TIDAC_pll_loop_data	0x2f
+#define TIDAC_key_over_low	0x30
+#define TIDAC_key_over_high	0x31
+#define TIDAC_key_red_low	0x32
+#define TIDAC_key_red_high	0x33
+#define TIDAC_key_green_low	0x34
+#define TIDAC_key_green_high	0x35
+#define TIDAC_key_blue_low	0x36
+#define TIDAC_key_blue_high	0x37
+#define TIDAC_key_ctrl		0x38
+#define TIDAC_clock_ctrl	0x39
+#define TIDAC_sense_test	0x3a
+#define TIDAC_test_mode_data	0x3b
+#define TIDAC_crc_remain_lsb	0x3c
+#define TIDAC_crc_remain_msb	0x3d
+#define TIDAC_crc_bit_select	0x3e
+#define TIDAC_id		0x3f
+
+/* These are pll values that are accessed via TIDAC_pll_pixel_data */
+#define TIDAC_PIXEL_N		0x80
+#define TIDAC_PIXEL_M		0x81
+#define TIDAC_PIXEL_P		0x82
+#define TIDAC_PIXEL_VALID	0x83
+
+/* These are pll values that are accessed via TIDAC_pll_loop_data */
+#define TIDAC_LOOP_N		0x90
+#define TIDAC_LOOP_M		0x91
+#define TIDAC_LOOP_P		0x92
+#define TIDAC_LOOP_VALID	0x93
+
+/* Direct mapping addresses */
+#define TIDAC_INDEX		0xa0
+#define TIDAC_PALETTE_DATA	0xa1
+#define TIDAC_READ_MASK		0xa2
+#define TIDAC_READ_ADDR		0xa3
+#define TIDAC_CURS_WRITE_ADDR	0xa4
+#define TIDAC_CURS_COLOR	0xa5
+#define TIDAC_CURS_READ_ADDR	0xa7
+#define TIDAC_CURS_CTL		0xa9
+#define TIDAC_INDEXED_DATA	0xaa
+#define TIDAC_CURS_RAM_DATA	0xab
+#define TIDAC_CURS_XLOW		0xac
+#define TIDAC_CURS_XHIGH	0xad
+#define TIDAC_CURS_YLOW		0xae
+#define TIDAC_CURS_YHIGH	0xaf
+
+#define TIDAC_sw_reset		0xff
+
+/* Constants */
+#define TIDAC_TVP_3026_ID       0x26
+#define TIDAC_TVP_3030_ID       0x30

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TI.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevb.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEVB_H
+#define UNGRDEVB_H 1
+
+int SProcXUngrabDeviceButton(ClientPtr  /* client */
+    );
+
+int ProcXUngrabDeviceButton(ClientPtr   /* client */
+    );
+
+#endif                          /* UNGRDEVB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TIPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TIPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TIPriv.h	(Revision 52145)
@@ -0,0 +1,29 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "TI.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86TIramdacInfo;
+
+extern xf86TIramdacInfo TIramdacDeviceInfo[];
+
+#ifdef INIT_TI_RAMDAC_INFO
+xf86TIramdacInfo TIramdacDeviceInfo[] = {
+    {"TI TVP3030"},
+    {"TI TVP3026"}
+};
+#endif
+
+#define TISAVE(_reg) do { 						\
+    ramdacReg->DacRegs[_reg] = (*ramdacPtr->ReadDAC)(pScrn, _reg);	\
+} while (0)
+
+#define TIRESTORE(_reg) do { 						\
+    (*ramdacPtr->WriteDAC)(pScrn, _reg, 				\
+	(ramdacReg->DacRegs[_reg] & 0xFF00) >> 8, 			\
+	ramdacReg->DacRegs[_reg]);					\
+} while (0)

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/TIPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsigio.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsigio.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsigio.h	(Revision 52145)
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to SIGIO handling support.  \see dmxsigio.c */
+
+#ifndef _DMXSIGIO_H_
+#define _DMXSIGIO_H_
+extern void dmxSigioEnableInput(void);
+extern void dmxSigioDisableInput(void);
+extern void dmxSigioRegister(DMXInputInfo * dmxInput, int fd);
+extern void dmxSigioUnregister(DMXInputInfo * dmxInput);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsigio.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xsha1.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xsha1.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xsha1.h	(Revision 52145)
@@ -0,0 +1,19 @@
+#ifndef XSHA1_H
+#define XSHA1_H
+
+/* Initialize SHA1 computation.  Returns NULL on error. */
+void *x_sha1_init(void);
+
+/*
+ * Add some data to be hashed.  ctx is the value returned by x_sha1_init()
+ * Returns 0 on error, 1 on success.
+ */
+int x_sha1_update(void *ctx, void *data, int size);
+
+/*
+ * Place the hash in result, and free ctx.
+ * Returns 0 on error, 1 on success. 
+ */
+int x_sha1_final(void *ctx, unsigned char result[20]);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xsha1.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/uda1380.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/uda1380.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/uda1380.h	(Revision 52145)
@@ -0,0 +1,81 @@
+/*************************************************************************************
+ * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this 
+ * software and associated documentation files (the "Software"), to deal in the Software 
+ * without restriction, including without limitation the rights to use, copy, modify, 
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software, 
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or 
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, 
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the author shall not be used in advertising or 
+ * otherwise to promote the sale, use or other dealings in this Software without prior written 
+ * authorization from the author.
+ *
+ * Revision 1.3  2005/09/24 21:56:00  bogdand
+ * Changed the license to a X/MIT one
+ *
+ * Revision 1.2  2005/07/01 22:43:11  daniels
+ * Change all misc.h and os.h references to <X11/foo.h>.
+ *
+ *
+ ************************************************************************************/
+
+#ifndef __UDA1380_H__
+#define __UDA1380_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    I2CDevRec d;
+
+    CARD16 analog_mixer_settings;       /* register 0x03 */
+
+} UDA1380Rec, *UDA1380Ptr;
+
+#define UDA1380_ADDR_1   0x30
+#define UDA1380_ADDR_2   0x34
+
+#define xf86_Detect_uda1380		Detect_uda1380
+extern _X_EXPORT UDA1380Ptr Detect_uda1380(I2CBusPtr b, I2CSlaveAddr addr);
+
+#define xf86_uda1380_init		uda1380_init
+extern _X_EXPORT Bool uda1380_init(UDA1380Ptr t);
+
+#define xf86_uda1380_shutdown		uda1380_shutdown
+extern _X_EXPORT void uda1380_shutdown(UDA1380Ptr t);
+
+#define xf86_uda1380_setvolume		uda1380_setvolume
+extern _X_EXPORT void uda1380_setvolume(UDA1380Ptr t, INT32);
+
+#define xf86_uda1380_mute		uda1380_mute
+extern _X_EXPORT void uda1380_mute(UDA1380Ptr t, Bool);
+
+#define xf86_uda1380_setparameters	uda1380_setparameters
+extern _X_EXPORT void uda1380_setparameters(UDA1380Ptr t);
+
+#define xf86_uda1380_getstatus		uda1380_getstatus
+extern _X_EXPORT void uda1380_getstatus(UDA1380Ptr t);
+
+#define xf86_uda1380_dumpstatus		uda1380_dumpstatus
+extern _X_EXPORT void uda1380_dumpstatus(UDA1380Ptr t);
+
+#define UDA1380SymbolsList  \
+		"Detect_uda1380", \
+		"uda1380_init", \
+		"uda1380_shutdown", \
+		"uda1380_setvolume", \
+		"uda1380_mute", \
+		"uda1380_setparameters", \
+		"uda1380_getstatus", \
+		"uda1380_dumpstatus"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/uda1380.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/busfault.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/busfault.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/busfault.h	(Revision 52145)
@@ -0,0 +1,48 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _BUSFAULT_H_
+#define _BUSFAULT_H_
+
+#include <dix-config.h>
+
+#ifdef BUSFAULT
+
+#include <sys/types.h>
+
+typedef void (*busfault_notify_ptr) (void *context);
+
+struct busfault *
+busfault_register_mmap(void *addr, size_t size, busfault_notify_ptr notify, void *context);
+
+void
+busfault_unregister(struct busfault *busfault);
+
+void
+busfault_check(void);
+
+Bool
+busfault_init(void);
+
+#endif
+
+#endif /* _BUSFAULT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/busfault.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/CanvasP.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/CanvasP.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/CanvasP.h	(Revision 52145)
@@ -0,0 +1,65 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+Copyright 2002 Red Hat Inc., Durham, North Carolina.
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ * This file was originally taken from xc/lib/Xaw/TemplateP.h
+ */
+
+#ifndef _CanvasP_h
+#define _CanvasP_h
+
+#include "Canvas.h"
+
+/* include superclass private header file */
+#include <X11/CoreP.h>
+
+typedef struct {
+    XtPointer extension;
+} CanvasClassPart;
+
+typedef struct _CanvasClassRec {
+    CoreClassPart core_class;
+    CanvasClassPart canvas_class;
+} CanvasClassRec;
+
+extern CanvasClassRec canvasClassRec;
+
+typedef struct {
+    XtCallbackList input_callback;
+    XtCallbackList expose_callback;
+    XtCallbackList resize_callback;
+} CanvasPart;
+
+typedef struct _CanvasRec {
+    CorePart core;
+    CanvasPart canvas;
+} CanvasRec;
+
+#endif                          /* _CanvasP_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/CanvasP.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx-config.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx-config.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx-config.h	(Revision 52145)
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2005 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Provide configuration define's and undef's to build Xdmx in X.Org's
+ * modular source tree.
+ */
+
+#ifndef DMX_CONFIG_H
+#define DMX_CONFIG_H
+
+#include <dix-config.h>
+
+/*
+ * Note 1: This is a signed int that is printed as a decimal number.
+ *         Since we want to make it human-interpretable, the fields are
+ *         defined as:
+ *         2147483648
+ *         AAbbyymmdd
+ *         AA: major version 01-20
+ *         bb: minor version 00-99
+ *         yy: year          00-99 [See Note 2]
+ *         mm: month         01-12
+ *         dd: day           01-31
+ *
+ * Note 2: The default epoch for the year is 2000.
+ *         To change the default epoch, change the DMX_VENDOR_RELEASE
+ *         macro below, bumb the minor version number, and change
+ *         xdpyinfo to key off the major/minor version to determine the
+ *         new epoch.  Remember to do this on January 1, 2100 and every
+ *         100 years thereafter.
+ */
+#define DMX_VENDOR_RELEASE(major,minor,year,month,day) \
+    ((major)     * 100000000) + \
+    ((minor)     *   1000000) + \
+    ((year-2000) *     10000) + \
+    ((month)     *       100) + \
+    ((day)       *         1)
+#define VENDOR_RELEASE  DMX_VENDOR_RELEASE(1,2,2007,4,24)
+#define VENDOR_STRING   "DMX Project"
+
+/* Enable the DMX extension */
+#define DMXEXT
+
+#endif                          /* DMX_CONFIG_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmx-config.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/parser.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/parser.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/parser.h	(Revision 52145)
@@ -0,0 +1,123 @@
+/* A Bison parser, made by GNU Bison 2.7.12-4996.  */
+
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_PARSER_H_INCLUDED
+# define YY_YY_PARSER_H_INCLUDED
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_VIRTUAL = 258,
+     T_DISPLAY = 259,
+     T_WALL = 260,
+     T_OPTION = 261,
+     T_PARAM = 262,
+     T_STRING = 263,
+     T_DIMENSION = 264,
+     T_OFFSET = 265,
+     T_ORIGIN = 266,
+     T_COMMENT = 267,
+     T_LINE_COMMENT = 268
+   };
+#endif
+/* Tokens.  */
+#define T_VIRTUAL 258
+#define T_DISPLAY 259
+#define T_WALL 260
+#define T_OPTION 261
+#define T_PARAM 262
+#define T_STRING 263
+#define T_DIMENSION 264
+#define T_OFFSET 265
+#define T_ORIGIN 266
+#define T_COMMENT 267
+#define T_LINE_COMMENT 268
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+/* Line 2053 of yacc.c  */
+#line 56 "parser.y"
+
+    DMXConfigTokenPtr      token;
+    DMXConfigStringPtr     string;
+    DMXConfigNumberPtr     number;
+    DMXConfigPairPtr       pair;
+    DMXConfigFullDimPtr    fdim;
+    DMXConfigPartDimPtr    pdim;
+    DMXConfigDisplayPtr    display;
+    DMXConfigWallPtr       wall;
+    DMXConfigOptionPtr     option;
+    DMXConfigParamPtr      param;
+    DMXConfigCommentPtr    comment;
+    DMXConfigSubPtr        subentry;
+    DMXConfigVirtualPtr    virtual;
+    DMXConfigEntryPtr      entry;
+
+
+/* Line 2053 of yacc.c  */
+#line 101 "parser.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+#endif /* !YY_YY_PARSER_H_INCLUDED  */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/parser.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvmcext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvmcext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvmcext.h	(Revision 52145)
@@ -0,0 +1,98 @@
+
+#ifndef _XVMC_H
+#define _XVMC_H
+#include <X11/extensions/Xv.h>
+#include "xvdix.h"
+
+typedef struct {
+    int num_xvimages;
+    int *xvimage_ids;
+} XvMCImageIDList;
+
+typedef struct {
+    int surface_type_id;
+    int chroma_format;
+    int color_description;
+    unsigned short max_width;
+    unsigned short max_height;
+    unsigned short subpicture_max_width;
+    unsigned short subpicture_max_height;
+    int mc_type;
+    int flags;
+    XvMCImageIDList *compatible_subpictures;
+} XvMCSurfaceInfoRec, *XvMCSurfaceInfoPtr;
+
+typedef struct {
+    XID context_id;
+    ScreenPtr pScreen;
+    int adapt_num;
+    int surface_type_id;
+    unsigned short width;
+    unsigned short height;
+    CARD32 flags;
+    int refcnt;
+    void *port_priv;
+    void *driver_priv;
+} XvMCContextRec, *XvMCContextPtr;
+
+typedef struct {
+    XID surface_id;
+    int surface_type_id;
+    XvMCContextPtr context;
+    void *driver_priv;
+} XvMCSurfaceRec, *XvMCSurfacePtr;
+
+typedef struct {
+    XID subpicture_id;
+    int xvimage_id;
+    unsigned short width;
+    unsigned short height;
+    int num_palette_entries;
+    int entry_bytes;
+    char component_order[4];
+    XvMCContextPtr context;
+    void *driver_priv;
+} XvMCSubpictureRec, *XvMCSubpicturePtr;
+
+typedef int (*XvMCCreateContextProcPtr) (XvPortPtr port,
+                                         XvMCContextPtr context,
+                                         int *num_priv, CARD32 **priv);
+
+typedef void (*XvMCDestroyContextProcPtr) (XvMCContextPtr context);
+
+typedef int (*XvMCCreateSurfaceProcPtr) (XvMCSurfacePtr surface,
+                                         int *num_priv, CARD32 **priv);
+
+typedef void (*XvMCDestroySurfaceProcPtr) (XvMCSurfacePtr surface);
+
+typedef int (*XvMCCreateSubpictureProcPtr) (XvMCSubpicturePtr subpicture,
+                                            int *num_priv, CARD32 **priv);
+
+typedef void (*XvMCDestroySubpictureProcPtr) (XvMCSubpicturePtr subpicture);
+
+typedef struct {
+    XvAdaptorPtr xv_adaptor;
+    int num_surfaces;
+    XvMCSurfaceInfoPtr *surfaces;
+    int num_subpictures;
+    XvImagePtr *subpictures;
+    XvMCCreateContextProcPtr CreateContext;
+    XvMCDestroyContextProcPtr DestroyContext;
+    XvMCCreateSurfaceProcPtr CreateSurface;
+    XvMCDestroySurfaceProcPtr DestroySurface;
+    XvMCCreateSubpictureProcPtr CreateSubpicture;
+    XvMCDestroySubpictureProcPtr DestroySubpicture;
+} XvMCAdaptorRec, *XvMCAdaptorPtr;
+
+extern int (*XvMCScreenInitProc)(ScreenPtr, int, XvMCAdaptorPtr);
+
+extern _X_EXPORT int XvMCScreenInit(ScreenPtr pScreen,
+                                    int num, XvMCAdaptorPtr adapt);
+
+extern _X_EXPORT XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id);
+
+extern _X_EXPORT int xf86XvMCRegisterDRInfo(ScreenPtr pScreen, const char *name,
+                                            const char *busID, int major, int minor,
+                                            int patchLevel);
+
+#endif                          /* _XVMC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvmcext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86OSpriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86OSpriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86OSpriv.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 1999-2000 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86OSPRIV_H
+#define _XF86OSPRIV_H
+
+typedef void *(*MapMemProcPtr) (int, unsigned long, unsigned long, int);
+typedef void (*UnmapMemProcPtr) (int, void *, unsigned long);
+typedef void *(*SetWCProcPtr) (int, unsigned long, unsigned long, Bool,
+                                 MessageType);
+typedef void (*ProtectMemProcPtr) (int, void *, unsigned long, Bool);
+typedef void (*UndoWCProcPtr) (int, void *);
+
+typedef struct {
+    Bool initialised;
+    MapMemProcPtr mapMem;
+    UnmapMemProcPtr unmapMem;
+    ProtectMemProcPtr protectMem;
+    SetWCProcPtr setWC;
+    UndoWCProcPtr undoWC;
+    Bool linearSupported;
+} VidMemInfo, *VidMemInfoPtr;
+
+void xf86OSInitVidMem(VidMemInfoPtr);
+
+#endif                          /* _XF86OSPRIV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86OSpriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbrules.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbrules.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbrules.h	(Revision 52145)
@@ -0,0 +1,120 @@
+#ifndef _XKBRULES_H_
+#define	_XKBRULES_H_ 1
+
+/************************************************************
+ Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
+
+ Permission to use, copy, modify, and distribute this
+ software and its documentation for any purpose and without
+ fee is hereby granted, provided that the above copyright
+ notice appear in all copies and that both that copyright
+ notice and this permission notice appear in supporting
+ documentation, and that the name of Silicon Graphics not be
+ used in advertising or publicity pertaining to distribution
+ of the software without specific prior written permission.
+ Silicon Graphics makes no representation about the suitability
+ of this software for any purpose. It is provided "as is"
+ without any express or implied warranty.
+
+ SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ ********************************************************/
+
+/***====================================================================***/
+
+typedef struct _XkbRMLVOSet {
+    char *rules;
+    char *model;
+    char *layout;
+    char *variant;
+    char *options;
+} XkbRMLVOSet;
+
+typedef struct _XkbRF_VarDefs {
+    const char *model;
+    const char *layout;
+    const char *variant;
+    const char *options;
+} XkbRF_VarDefsRec, *XkbRF_VarDefsPtr;
+
+typedef struct _XkbRF_Rule {
+    int number;
+    int layout_num;
+    int variant_num;
+    const char *model;
+    const char *layout;
+    const char *variant;
+    const char *option;
+    /* yields */
+    const char *keycodes;
+    const char *symbols;
+    const char *types;
+    const char *compat;
+    const char *geometry;
+    unsigned flags;
+} XkbRF_RuleRec, *XkbRF_RulePtr;
+
+typedef struct _XkbRF_Group {
+    int number;
+    const char *name;
+    char *words;
+} XkbRF_GroupRec, *XkbRF_GroupPtr;
+
+#define	XkbRF_PendingMatch	(1L<<1)
+#define	XkbRF_Option		(1L<<2)
+#define	XkbRF_Append		(1L<<3)
+#define	XkbRF_Normal		(1L<<4)
+#define	XkbRF_Invalid		(1L<<5)
+
+typedef struct _XkbRF_Rules {
+    unsigned short sz_rules;
+    unsigned short num_rules;
+    XkbRF_RulePtr rules;
+    unsigned short sz_groups;
+    unsigned short num_groups;
+    XkbRF_GroupPtr groups;
+} XkbRF_RulesRec, *XkbRF_RulesPtr;
+
+/***====================================================================***/
+
+_XFUNCPROTOBEGIN
+
+/* Seems preferable to dragging xkbstr.h in. */
+    struct _XkbComponentNames;
+
+extern _X_EXPORT Bool XkbRF_GetComponents(XkbRF_RulesPtr /* rules */ ,
+                                          XkbRF_VarDefsPtr /* var_defs */ ,
+                                          struct _XkbComponentNames *   /* names */
+    );
+
+extern _X_EXPORT Bool XkbRF_LoadRules(FILE * /* file */ ,
+                                      XkbRF_RulesPtr    /* rules */
+    );
+
+extern _X_EXPORT Bool XkbRF_LoadRulesByName(char * /* base */ ,
+                                            char * /* locale */ ,
+                                            XkbRF_RulesPtr      /* rules */
+    );
+
+/***====================================================================***/
+
+extern _X_EXPORT XkbRF_RulesPtr XkbRF_Create(void);
+
+extern _X_EXPORT void XkbRF_Free(XkbRF_RulesPtr /* rules */ ,
+                                 Bool   /* freeRules */
+    );
+
+/***====================================================================***/
+
+#define	_XKB_RF_NAMES_PROP_ATOM		"_XKB_RULES_NAMES"
+#define	_XKB_RF_NAMES_PROP_MAXLEN	1024
+
+_XFUNCPROTOEND
+#endif                          /* _XKBRULES_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbrules.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessWindow.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessWindow.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessWindow.h	(Revision 52145)
@@ -0,0 +1,63 @@
+/*
+ * Rootless window management
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESSWINDOW_H
+#define _ROOTLESSWINDOW_H
+
+#include "rootlessCommon.h"
+
+Bool RootlessCreateWindow(WindowPtr pWin);
+Bool RootlessDestroyWindow(WindowPtr pWin);
+
+void RootlessSetShape(WindowPtr pWin, int kind);
+
+Bool RootlessChangeWindowAttributes(WindowPtr pWin, unsigned long vmask);
+Bool RootlessPositionWindow(WindowPtr pWin, int x, int y);
+Bool RootlessRealizeWindow(WindowPtr pWin);
+Bool RootlessUnrealizeWindow(WindowPtr pWin);
+void RootlessRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib);
+void RootlessCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
+                        RegionPtr prgnSrc);
+void RootlessMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib,
+                        VTKind kind);
+void RootlessResizeWindow(WindowPtr pWin, int x, int y, unsigned int w,
+                          unsigned int h, WindowPtr pSib);
+void RootlessReparentWindow(WindowPtr pWin, WindowPtr pPriorParent);
+void RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width);
+
+#ifdef __APPLE__
+void RootlessNativeWindowMoved(WindowPtr pWin);
+void RootlessNativeWindowStateChanged(WindowPtr pWin, unsigned int state);
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessWindow.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifillarc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifillarc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifillarc.h	(Revision 52145)
@@ -0,0 +1,187 @@
+/************************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+********************************************************/
+
+#ifndef __MIFILLARC_H__
+#define __MIFILLARC_H__
+
+#define FULLCIRCLE (360 * 64)
+
+typedef struct _miFillArc {
+    int xorg, yorg;
+    int y;
+    int dx, dy;
+    int e;
+    int ym, yk, xm, xk;
+} miFillArcRec;
+
+/* could use 64-bit integers */
+typedef struct _miFillArcD {
+    int xorg, yorg;
+    int y;
+    int dx, dy;
+    double e;
+    double ym, yk, xm, xk;
+} miFillArcDRec;
+
+#define miFillArcEmpty(arc) (!(arc)->angle2 || \
+			     !(arc)->width || !(arc)->height || \
+			     (((arc)->width == 1) && ((arc)->height & 1)))
+
+#define miCanFillArc(arc) (((arc)->width == (arc)->height) || \
+			   (((arc)->width <= 800) && ((arc)->height <= 800)))
+
+#define MIFILLARCSETUP() \
+    x = 0; \
+    y = info.y; \
+    e = info.e; \
+    xk = info.xk; \
+    xm = info.xm; \
+    yk = info.yk; \
+    ym = info.ym; \
+    dx = info.dx; \
+    dy = info.dy; \
+    xorg = info.xorg; \
+    yorg = info.yorg
+
+#define MIFILLARCSTEP(slw) \
+    e += yk; \
+    while (e >= 0) \
+    { \
+	x++; \
+	xk -= xm; \
+	e += xk; \
+    } \
+    y--; \
+    yk -= ym; \
+    slw = (x << 1) + dx; \
+    if ((e == xk) && (slw > 1)) \
+	slw--
+
+#define MIFILLCIRCSTEP(slw) MIFILLARCSTEP(slw)
+#define MIFILLELLSTEP(slw) MIFILLARCSTEP(slw)
+
+#define miFillArcLower(slw) (((y + dy) != 0) && ((slw > 1) || (e != xk)))
+
+typedef struct _miSliceEdge {
+    int x;
+    int stepx;
+    int deltax;
+    int e;
+    int dy;
+    int dx;
+} miSliceEdgeRec, *miSliceEdgePtr;
+
+typedef struct _miArcSlice {
+    miSliceEdgeRec edge1, edge2;
+    int min_top_y, max_top_y;
+    int min_bot_y, max_bot_y;
+    Bool edge1_top, edge2_top;
+    Bool flip_top, flip_bot;
+} miArcSliceRec;
+
+#define MIARCSLICESTEP(edge) \
+    edge.x -= edge.stepx; \
+    edge.e -= edge.dx; \
+    if (edge.e <= 0) \
+    { \
+	edge.x -= edge.deltax; \
+	edge.e += edge.dy; \
+    }
+
+#define miFillSliceUpper(slice) \
+		((y >= slice.min_top_y) && (y <= slice.max_top_y))
+
+#define miFillSliceLower(slice) \
+		((y >= slice.min_bot_y) && (y <= slice.max_bot_y))
+
+#define MIARCSLICEUPPER(xl,xr,slice,slw) \
+    xl = xorg - x; \
+    xr = xl + slw - 1; \
+    if (slice.edge1_top && (slice.edge1.x < xr)) \
+	xr = slice.edge1.x; \
+    if (slice.edge2_top && (slice.edge2.x > xl)) \
+	xl = slice.edge2.x;
+
+#define MIARCSLICELOWER(xl,xr,slice,slw) \
+    xl = xorg - x; \
+    xr = xl + slw - 1; \
+    if (!slice.edge1_top && (slice.edge1.x > xl)) \
+	xl = slice.edge1.x; \
+    if (!slice.edge2_top && (slice.edge2.x < xr)) \
+	xr = slice.edge2.x;
+
+#define MIWIDEARCSETUP(x,y,dy,slw,e,xk,xm,yk,ym) \
+    x = 0; \
+    y = slw >> 1; \
+    yk = y << 3; \
+    xm = 8; \
+    ym = 8; \
+    if (dy) \
+    { \
+	xk = 0; \
+	if (slw & 1) \
+	    e = -1; \
+	else \
+	    e = -(y << 2) - 2; \
+    } \
+    else \
+    { \
+	y++; \
+	yk += 4; \
+	xk = -4; \
+	if (slw & 1) \
+	    e = -(y << 2) - 3; \
+	else \
+	    e = - (y << 3); \
+    }
+
+#define MIFILLINARCSTEP(slw) \
+    ine += inyk; \
+    while (ine >= 0) \
+    { \
+	inx++; \
+	inxk -= inxm; \
+	ine += inxk; \
+    } \
+    iny--; \
+    inyk -= inym; \
+    slw = (inx << 1) + dx; \
+    if ((ine == inxk) && (slw > 1)) \
+	slw--
+
+#define miFillInArcLower(slw) (((iny + dy) != 0) && \
+			       ((slw > 1) || (ine != inxk)))
+
+extern _X_EXPORT void miFillArcSetup(xArc * /*arc */ ,
+                                     miFillArcRec *     /*info */
+    );
+
+extern _X_EXPORT void miFillArcSliceSetup(xArc * /*arc */ ,
+                                          miArcSliceRec * /*slice */ ,
+                                          GCPtr /*pGC */
+    );
+
+#endif                          /* __MIFILLARC_H__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifillarc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxerror.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxerror.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxerror.h	(Revision 52145)
@@ -0,0 +1,51 @@
+#ifndef _GLX_error_h_
+#define _GLX_error_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+/*
+** Error codes.  These have the extension error base added to them
+** when the extension initializes.
+*/
+extern int __glXerrorBase;
+extern int __glXBadContext;
+extern int __glXBadContextState;
+extern int __glXBadDrawable;
+extern int __glXBadPixmap;
+extern int __glXBadCurrentWindow;
+extern int __glXBadContextTag;
+extern int __glXBadRenderRequest;
+extern int __glXBadLargeRequest;
+extern int __glXUnsupportedPrivateRequest;
+extern int __glXBadFBConfig;
+extern int __glXBadPbuffer;
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxerror.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerypointer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerypointer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerypointer.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYDP_H
+#define QUERYDP_H 1
+
+int SProcXIQueryPointer(ClientPtr /* client */ );
+int ProcXIQueryPointer(ClientPtr /* client */ );
+void SRepXIQueryPointer(ClientPtr /* client */ ,
+                        int /* size */ ,
+                        xXIQueryPointerReply * /* rep */ );
+
+#endif                          /* QUERYDP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiquerypointer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Crtc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Crtc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Crtc.h	(Revision 52145)
@@ -0,0 +1,1025 @@
+/*
+ * Copyright ¬© 2006 Keith Packard
+ * Copyright ¬© 2011 Aaron Plattner
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+#ifndef _XF86CRTC_H_
+#define _XF86CRTC_H_
+
+#include <edid.h>
+#include "randrstr.h"
+#include "xf86Modes.h"
+#include "xf86Cursor.h"
+#include "xf86i2c.h"
+#include "damage.h"
+#include "picturestr.h"
+
+/* Compat definitions for older X Servers. */
+#ifndef M_T_PREFERRED
+#define M_T_PREFERRED	0x08
+#endif
+#ifndef M_T_DRIVER
+#define M_T_DRIVER	0x40
+#endif
+#ifndef M_T_USERPREF
+#define M_T_USERPREF	0x80
+#endif
+#ifndef HARDWARE_CURSOR_ARGB
+#define HARDWARE_CURSOR_ARGB				0x00004000
+#endif
+
+typedef struct _xf86Crtc xf86CrtcRec, *xf86CrtcPtr;
+typedef struct _xf86Output xf86OutputRec, *xf86OutputPtr;
+
+/* define a standard for connector types */
+typedef enum _xf86ConnectorType {
+    XF86ConnectorNone,
+    XF86ConnectorVGA,
+    XF86ConnectorDVI_I,
+    XF86ConnectorDVI_D,
+    XF86ConnectorDVI_A,
+    XF86ConnectorComposite,
+    XF86ConnectorSvideo,
+    XF86ConnectorComponent,
+    XF86ConnectorLFP,
+    XF86ConnectorProprietary,
+    XF86ConnectorHDMI,
+    XF86ConnectorDisplayPort,
+} xf86ConnectorType;
+
+typedef enum _xf86OutputStatus {
+    XF86OutputStatusConnected,
+    XF86OutputStatusDisconnected,
+    XF86OutputStatusUnknown
+} xf86OutputStatus;
+
+typedef struct _xf86CrtcFuncs {
+   /**
+    * Turns the crtc on/off, or sets intermediate power levels if available.
+    *
+    * Unsupported intermediate modes drop to the lower power setting.  If the
+    * mode is DPMSModeOff, the crtc must be disabled sufficiently for it to
+    * be safe to call mode_set.
+    */
+    void
+     (*dpms) (xf86CrtcPtr crtc, int mode);
+
+   /**
+    * Saves the crtc's state for restoration on VT switch.
+    */
+    void
+     (*save) (xf86CrtcPtr crtc);
+
+   /**
+    * Restore's the crtc's state at VT switch.
+    */
+    void
+     (*restore) (xf86CrtcPtr crtc);
+
+    /**
+     * Lock CRTC prior to mode setting, mostly for DRI.
+     * Returns whether unlock is needed
+     */
+    Bool
+     (*lock) (xf86CrtcPtr crtc);
+
+    /**
+     * Unlock CRTC after mode setting, mostly for DRI
+     */
+    void
+     (*unlock) (xf86CrtcPtr crtc);
+
+    /**
+     * Callback to adjust the mode to be set in the CRTC.
+     *
+     * This allows a CRTC to adjust the clock or even the entire set of
+     * timings, which is used for panels with fixed timings or for
+     * buses with clock limitations.
+     */
+    Bool
+     (*mode_fixup) (xf86CrtcPtr crtc,
+                    DisplayModePtr mode, DisplayModePtr adjusted_mode);
+
+    /**
+     * Prepare CRTC for an upcoming mode set.
+     */
+    void
+     (*prepare) (xf86CrtcPtr crtc);
+
+    /**
+     * Callback for setting up a video mode after fixups have been made.
+     */
+    void
+     (*mode_set) (xf86CrtcPtr crtc,
+                  DisplayModePtr mode,
+                  DisplayModePtr adjusted_mode, int x, int y);
+
+    /**
+     * Commit mode changes to a CRTC
+     */
+    void
+     (*commit) (xf86CrtcPtr crtc);
+
+    /* Set the color ramps for the CRTC to the given values. */
+    void
+     (*gamma_set) (xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
+                   int size);
+
+    /**
+     * Allocate the shadow area, delay the pixmap creation until needed
+     */
+    void *(*shadow_allocate) (xf86CrtcPtr crtc, int width, int height);
+
+    /**
+     * Create shadow pixmap for rotation support
+     */
+    PixmapPtr
+     (*shadow_create) (xf86CrtcPtr crtc, void *data, int width, int height);
+
+    /**
+     * Destroy shadow pixmap
+     */
+    void
+     (*shadow_destroy) (xf86CrtcPtr crtc, PixmapPtr pPixmap, void *data);
+
+    /**
+     * Set cursor colors
+     */
+    void
+     (*set_cursor_colors) (xf86CrtcPtr crtc, int bg, int fg);
+
+    /**
+     * Set cursor position
+     */
+    void
+     (*set_cursor_position) (xf86CrtcPtr crtc, int x, int y);
+
+    /**
+     * Show cursor
+     */
+    void
+     (*show_cursor) (xf86CrtcPtr crtc);
+
+    /**
+     * Hide cursor
+     */
+    void
+     (*hide_cursor) (xf86CrtcPtr crtc);
+
+    /**
+     * Load monochrome image
+     */
+    void
+     (*load_cursor_image) (xf86CrtcPtr crtc, CARD8 *image);
+    Bool
+     (*load_cursor_image_check) (xf86CrtcPtr crtc, CARD8 *image);
+
+    /**
+     * Load ARGB image
+     */
+    void
+     (*load_cursor_argb) (xf86CrtcPtr crtc, CARD32 *image);
+    Bool
+     (*load_cursor_argb_check) (xf86CrtcPtr crtc, CARD32 *image);
+
+    /**
+     * Clean up driver-specific bits of the crtc
+     */
+    void
+     (*destroy) (xf86CrtcPtr crtc);
+
+    /**
+     * Less fine-grained mode setting entry point for kernel modesetting
+     */
+    Bool
+     (*set_mode_major) (xf86CrtcPtr crtc, DisplayModePtr mode,
+                        Rotation rotation, int x, int y);
+
+    /**
+     * Callback for panning. Doesn't change the mode.
+     * Added in ABI version 2
+     */
+    void
+     (*set_origin) (xf86CrtcPtr crtc, int x, int y);
+
+    /**
+     */
+    Bool
+    (*set_scanout_pixmap)(xf86CrtcPtr crtc, PixmapPtr pixmap);
+
+} xf86CrtcFuncsRec, *xf86CrtcFuncsPtr;
+
+#define XF86_CRTC_VERSION 5
+
+struct _xf86Crtc {
+    /**
+     * ABI versioning
+     */
+    int version;
+
+    /**
+     * Associated ScrnInfo
+     */
+    ScrnInfoPtr scrn;
+
+    /**
+     * Desired state of this CRTC
+     *
+     * Set when this CRTC should be driving one or more outputs 
+     */
+    Bool enabled;
+
+    /**
+     * Active mode
+     *
+     * This reflects the mode as set in the CRTC currently
+     * It will be cleared when the VT is not active or
+     * during server startup
+     */
+    DisplayModeRec mode;
+    Rotation rotation;
+    PixmapPtr rotatedPixmap;
+    void *rotatedData;
+
+    /**
+     * Position on screen
+     *
+     * Locates this CRTC within the frame buffer
+     */
+    int x, y;
+
+    /**
+     * Desired mode
+     *
+     * This is set to the requested mode, independent of
+     * whether the VT is active. In particular, it receives
+     * the startup configured mode and saves the active mode
+     * on VT switch.
+     */
+    DisplayModeRec desiredMode;
+    Rotation desiredRotation;
+    int desiredX, desiredY;
+
+    /** crtc-specific functions */
+    const xf86CrtcFuncsRec *funcs;
+
+    /**
+     * Driver private
+     *
+     * Holds driver-private information
+     */
+    void *driver_private;
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * RandR crtc
+     *
+     * When RandR 1.2 is available, this
+     * points at the associated crtc object
+     */
+    RRCrtcPtr randr_crtc;
+#else
+    void *randr_crtc;
+#endif
+
+    /**
+     * Current cursor is ARGB
+     */
+    Bool cursor_argb;
+    /**
+     * Track whether cursor is within CRTC range 
+     */
+    Bool cursor_in_range;
+    /**
+     * Track state of cursor associated with this CRTC
+     */
+    Bool cursor_shown;
+
+    /**
+     * Current transformation matrix
+     */
+    PictTransform crtc_to_framebuffer;
+    /* framebuffer_to_crtc was removed in ABI 2 */
+    struct pict_f_transform f_crtc_to_framebuffer;      /* ABI 2 */
+    struct pict_f_transform f_framebuffer_to_crtc;      /* ABI 2 */
+    PictFilterPtr filter;       /* ABI 2 */
+    xFixed *params;             /* ABI 2 */
+    int nparams;                /* ABI 2 */
+    int filter_width;           /* ABI 2 */
+    int filter_height;          /* ABI 2 */
+    Bool transform_in_use;
+    RRTransformRec transform;   /* ABI 2 */
+    Bool transformPresent;      /* ABI 2 */
+    RRTransformRec desiredTransform;    /* ABI 2 */
+    Bool desiredTransformPresent;       /* ABI 2 */
+    /**
+     * Bounding box in screen space
+     */
+    BoxRec bounds;
+    /**
+     * Panning:
+     * TotalArea: total panning area, larger than CRTC's size
+     * TrackingArea: Area of the pointer for which the CRTC is panned
+     * border: Borders of the displayed CRTC area which induces panning if the pointer reaches them
+     * Added in ABI version 2
+     */
+    BoxRec panningTotalArea;
+    BoxRec panningTrackingArea;
+    INT16 panningBorder[4];
+
+    /**
+     * Current gamma, especially useful after initial config.
+     * Added in ABI version 3
+     */
+    CARD16 *gamma_red;
+    CARD16 *gamma_green;
+    CARD16 *gamma_blue;
+    int gamma_size;
+
+    /**
+     * Actual state of this CRTC
+     *
+     * Set to TRUE after modesetting, set to FALSE if no outputs are connected
+     * Added in ABI version 3
+     */
+    Bool active;
+    /**
+     * Clear the shadow
+     */
+    Bool shadowClear;
+
+    /**
+     * Indicates that the driver is handling the transform, so the shadow
+     * surface should be disabled.  The driver writes this field before calling
+     * xf86CrtcRotate to indicate that it is handling the transform (including
+     * rotation and reflection).
+     *
+     * Setting this flag also causes the server to stop adjusting the cursor
+     * image and position.
+     *
+     * Added in ABI version 4
+     */
+    Bool driverIsPerformingTransform;
+
+    /* Added in ABI version 5
+     */
+    PixmapPtr current_scanout;
+};
+
+typedef struct _xf86OutputFuncs {
+    /**
+     * Called to allow the output a chance to create properties after the
+     * RandR objects have been created.
+     */
+    void
+     (*create_resources) (xf86OutputPtr output);
+
+    /**
+     * Turns the output on/off, or sets intermediate power levels if available.
+     *
+     * Unsupported intermediate modes drop to the lower power setting.  If the
+     * mode is DPMSModeOff, the output must be disabled, as the DPLL may be
+     * disabled afterwards.
+     */
+    void
+     (*dpms) (xf86OutputPtr output, int mode);
+
+    /**
+     * Saves the output's state for restoration on VT switch.
+     */
+    void
+     (*save) (xf86OutputPtr output);
+
+    /**
+     * Restore's the output's state at VT switch.
+     */
+    void
+     (*restore) (xf86OutputPtr output);
+
+    /**
+     * Callback for testing a video mode for a given output.
+     *
+     * This function should only check for cases where a mode can't be supported
+     * on the output specifically, and not represent generic CRTC limitations.
+     *
+     * \return MODE_OK if the mode is valid, or another MODE_* otherwise.
+     */
+    int
+     (*mode_valid) (xf86OutputPtr output, DisplayModePtr pMode);
+
+    /**
+     * Callback to adjust the mode to be set in the CRTC.
+     *
+     * This allows an output to adjust the clock or even the entire set of
+     * timings, which is used for panels with fixed timings or for
+     * buses with clock limitations.
+     */
+    Bool
+     (*mode_fixup) (xf86OutputPtr output,
+                    DisplayModePtr mode, DisplayModePtr adjusted_mode);
+
+    /**
+     * Callback for preparing mode changes on an output
+     */
+    void
+     (*prepare) (xf86OutputPtr output);
+
+    /**
+     * Callback for committing mode changes on an output
+     */
+    void
+     (*commit) (xf86OutputPtr output);
+
+    /**
+     * Callback for setting up a video mode after fixups have been made.
+     *
+     * This is only called while the output is disabled.  The dpms callback
+     * must be all that's necessary for the output, to turn the output on
+     * after this function is called.
+     */
+    void
+     (*mode_set) (xf86OutputPtr output,
+                  DisplayModePtr mode, DisplayModePtr adjusted_mode);
+
+    /**
+     * Probe for a connected output, and return detect_status.
+     */
+     xf86OutputStatus(*detect) (xf86OutputPtr output);
+
+    /**
+     * Query the device for the modes it provides.
+     *
+     * This function may also update MonInfo, mm_width, and mm_height.
+     *
+     * \return singly-linked list of modes or NULL if no modes found.
+     */
+     DisplayModePtr(*get_modes) (xf86OutputPtr output);
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * Callback when an output's property has changed.
+     */
+    Bool
+     (*set_property) (xf86OutputPtr output,
+                      Atom property, RRPropertyValuePtr value);
+#endif
+#ifdef RANDR_13_INTERFACE
+    /**
+     * Callback to get an updated property value
+     */
+    Bool
+     (*get_property) (xf86OutputPtr output, Atom property);
+#endif
+#ifdef RANDR_GET_CRTC_INTERFACE
+    /**
+     * Callback to get current CRTC for a given output
+     */
+     xf86CrtcPtr(*get_crtc) (xf86OutputPtr output);
+#endif
+    /**
+     * Clean up driver-specific bits of the output
+     */
+    void
+     (*destroy) (xf86OutputPtr output);
+} xf86OutputFuncsRec, *xf86OutputFuncsPtr;
+
+#define XF86_OUTPUT_VERSION 2
+
+struct _xf86Output {
+    /**
+     * ABI versioning
+     */
+    int version;
+
+    /**
+     * Associated ScrnInfo
+     */
+    ScrnInfoPtr scrn;
+
+    /**
+     * Currently connected crtc (if any)
+     *
+     * If this output is not in use, this field will be NULL.
+     */
+    xf86CrtcPtr crtc;
+
+    /**
+     * Possible CRTCs for this output as a mask of crtc indices
+     */
+    CARD32 possible_crtcs;
+
+    /**
+     * Possible outputs to share the same CRTC as a mask of output indices
+     */
+    CARD32 possible_clones;
+
+    /**
+     * Whether this output can support interlaced modes
+     */
+    Bool interlaceAllowed;
+
+    /**
+     * Whether this output can support double scan modes
+     */
+    Bool doubleScanAllowed;
+
+    /**
+     * List of available modes on this output.
+     *
+     * This should be the list from get_modes(), plus perhaps additional
+     * compatible modes added later.
+     */
+    DisplayModePtr probed_modes;
+
+    /**
+     * Options parsed from the related monitor section
+     */
+    OptionInfoPtr options;
+
+    /**
+     * Configured monitor section
+     */
+    XF86ConfMonitorPtr conf_monitor;
+
+    /**
+     * Desired initial position
+     */
+    int initial_x, initial_y;
+
+    /**
+     * Desired initial rotation
+     */
+    Rotation initial_rotation;
+
+    /**
+     * Current connection status
+     *
+     * This indicates whether a monitor is known to be connected
+     * to this output or not, or whether there is no way to tell
+     */
+    xf86OutputStatus status;
+
+    /** EDID monitor information */
+    xf86MonPtr MonInfo;
+
+    /** subpixel order */
+    int subpixel_order;
+
+    /** Physical size of the currently attached output device. */
+    int mm_width, mm_height;
+
+    /** Output name */
+    char *name;
+
+    /** output-specific functions */
+    const xf86OutputFuncsRec *funcs;
+
+    /** driver private information */
+    void *driver_private;
+
+    /** Whether to use the old per-screen Monitor config section */
+    Bool use_screen_monitor;
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * RandR 1.2 output structure.
+     *
+     * When RandR 1.2 is available, this points at the associated
+     * RandR output structure and is created when this output is created
+     */
+    RROutputPtr randr_output;
+#else
+    void *randr_output;
+#endif
+    /** 
+     * Desired initial panning
+     * Added in ABI version 2
+     */
+    BoxRec initialTotalArea;
+    BoxRec initialTrackingArea;
+    INT16 initialBorder[4];
+};
+
+typedef struct _xf86ProviderFuncs {
+    /**
+     * Called to allow the provider a chance to create properties after the
+     * RandR objects have been created.
+     */
+    void
+    (*create_resources) (ScrnInfoPtr scrn);
+
+    /**
+     * Callback when an provider's property has changed.
+     */
+    Bool
+    (*set_property) (ScrnInfoPtr scrn,
+                     Atom property, RRPropertyValuePtr value);
+
+    /**
+     * Callback to get an updated property value
+     */
+    Bool
+    (*get_property) (ScrnInfoPtr provider, Atom property);
+
+} xf86ProviderFuncsRec, *xf86ProviderFuncsPtr;
+
+typedef struct _xf86CrtcConfigFuncs {
+    /**
+     * Requests that the driver resize the screen.
+     *
+     * The driver is responsible for updating scrn->virtualX and scrn->virtualY.
+     * If the requested size cannot be set, the driver should leave those values
+     * alone and return FALSE.
+     *
+     * A naive driver that cannot reallocate the screen may simply change
+     * virtual[XY].  A more advanced driver will want to also change the
+     * devPrivate.ptr and devKind of the screen pixmap, update any offscreen
+     * pixmaps it may have moved, and change pScrn->displayWidth.
+     */
+    Bool
+     (*resize) (ScrnInfoPtr scrn, int width, int height);
+} xf86CrtcConfigFuncsRec, *xf86CrtcConfigFuncsPtr;
+
+typedef void (*xf86_crtc_notify_proc_ptr) (ScreenPtr pScreen);
+
+typedef struct _xf86CrtcConfig {
+    int num_output;
+    xf86OutputPtr *output;
+    /**
+     * compat_output is used whenever we deal
+     * with legacy code that only understands a single
+     * output. pScrn->modes will be loaded from this output,
+     * adjust frame will whack this output, etc.
+     */
+    int compat_output;
+
+    int num_crtc;
+    xf86CrtcPtr *crtc;
+
+    int minWidth, minHeight;
+    int maxWidth, maxHeight;
+
+    /* For crtc-based rotation */
+    DamagePtr rotation_damage;
+    Bool rotation_damage_registered;
+
+    /* DGA */
+    unsigned int dga_flags;
+    unsigned long dga_address;
+    DGAModePtr dga_modes;
+    int dga_nmode;
+    int dga_width, dga_height, dga_stride;
+    DisplayModePtr dga_save_mode;
+
+    const xf86CrtcConfigFuncsRec *funcs;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+
+    CloseScreenProcPtr CloseScreen;
+
+    /* Cursor information */
+    xf86CursorInfoPtr cursor_info;
+    CursorPtr cursor;
+    CARD8 *cursor_image;
+    Bool cursor_on;
+    CARD32 cursor_fg, cursor_bg;
+
+    /**
+     * Options parsed from the related device section
+     */
+    OptionInfoPtr options;
+
+    Bool debug_modes;
+
+    /* wrap screen BlockHandler for rotation */
+    ScreenBlockHandlerProcPtr BlockHandler;
+
+    /* callback when crtc configuration changes */
+    xf86_crtc_notify_proc_ptr xf86_crtc_notify;
+
+    char *name;
+    const xf86ProviderFuncsRec *provider_funcs;
+#ifdef RANDR_12_INTERFACE
+    RRProviderPtr randr_provider;
+#else
+    void *randr_provider;
+#endif
+} xf86CrtcConfigRec, *xf86CrtcConfigPtr;
+
+extern _X_EXPORT int xf86CrtcConfigPrivateIndex;
+
+#define XF86_CRTC_CONFIG_PTR(p)	((xf86CrtcConfigPtr) ((p)->privates[xf86CrtcConfigPrivateIndex].ptr))
+
+static _X_INLINE xf86OutputPtr
+xf86CompatOutput(ScrnInfoPtr pScrn)
+{
+    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
+
+    return config->output[config->compat_output];
+}
+
+static _X_INLINE xf86CrtcPtr
+xf86CompatCrtc(ScrnInfoPtr pScrn)
+{
+    xf86OutputPtr compat_output = xf86CompatOutput(pScrn);
+
+    if (!compat_output)
+        return NULL;
+    return compat_output->crtc;
+}
+
+static _X_INLINE RRCrtcPtr
+xf86CompatRRCrtc(ScrnInfoPtr pScrn)
+{
+    xf86CrtcPtr compat_crtc = xf86CompatCrtc(pScrn);
+
+    if (!compat_crtc)
+        return NULL;
+    return compat_crtc->randr_crtc;
+}
+
+/*
+ * Initialize xf86CrtcConfig structure
+ */
+
+extern _X_EXPORT void
+ xf86CrtcConfigInit(ScrnInfoPtr scrn, const xf86CrtcConfigFuncsRec * funcs);
+
+extern _X_EXPORT void
+
+xf86CrtcSetSizeRange(ScrnInfoPtr scrn,
+                     int minWidth, int minHeight, int maxWidth, int maxHeight);
+
+/*
+ * Crtc functions
+ */
+extern _X_EXPORT xf86CrtcPtr
+xf86CrtcCreate(ScrnInfoPtr scrn, const xf86CrtcFuncsRec * funcs);
+
+extern _X_EXPORT void
+ xf86CrtcDestroy(xf86CrtcPtr crtc);
+
+/**
+ * Sets the given video mode on the given crtc
+ */
+
+extern _X_EXPORT Bool
+
+xf86CrtcSetModeTransform(xf86CrtcPtr crtc, DisplayModePtr mode,
+                         Rotation rotation, RRTransformPtr transform, int x,
+                         int y);
+
+extern _X_EXPORT Bool
+
+xf86CrtcSetMode(xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
+                int x, int y);
+
+extern _X_EXPORT void
+ xf86CrtcSetOrigin(xf86CrtcPtr crtc, int x, int y);
+
+/*
+ * Assign crtc rotation during mode set
+ */
+extern _X_EXPORT Bool
+ xf86CrtcRotate(xf86CrtcPtr crtc);
+
+/*
+ * Clean up any rotation data, used when a crtc is turned off
+ * as well as when rotation is disabled.
+ */
+extern _X_EXPORT void
+ xf86RotateDestroy(xf86CrtcPtr crtc);
+
+/*
+ * free shadow memory allocated for all crtcs
+ */
+extern _X_EXPORT void
+ xf86RotateFreeShadow(ScrnInfoPtr pScrn);
+
+/*
+ * Clean up rotation during CloseScreen
+ */
+extern _X_EXPORT void
+ xf86RotateCloseScreen(ScreenPtr pScreen);
+
+/**
+ * Return whether any output is assigned to the crtc
+ */
+extern _X_EXPORT Bool
+ xf86CrtcInUse(xf86CrtcPtr crtc);
+
+/*
+ * Output functions
+ */
+extern _X_EXPORT xf86OutputPtr
+xf86OutputCreate(ScrnInfoPtr scrn,
+                 const xf86OutputFuncsRec * funcs, const char *name);
+
+extern _X_EXPORT void
+ xf86OutputUseScreenMonitor(xf86OutputPtr output, Bool use_screen_monitor);
+
+extern _X_EXPORT Bool
+ xf86OutputRename(xf86OutputPtr output, const char *name);
+
+extern _X_EXPORT void
+ xf86OutputDestroy(xf86OutputPtr output);
+
+extern _X_EXPORT void
+ xf86ProbeOutputModes(ScrnInfoPtr pScrn, int maxX, int maxY);
+
+extern _X_EXPORT void
+ xf86SetScrnInfoModes(ScrnInfoPtr pScrn);
+
+#ifdef RANDR_13_INTERFACE
+#define ScreenInitRetType	int
+#else
+#define ScreenInitRetType	Bool
+#endif
+
+extern _X_EXPORT ScreenInitRetType xf86CrtcScreenInit(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+ xf86InitialConfiguration(ScrnInfoPtr pScrn, Bool canGrow);
+
+extern _X_EXPORT void
+ xf86DPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);
+
+extern _X_EXPORT Bool
+ xf86SaveScreen(ScreenPtr pScreen, int mode);
+
+extern _X_EXPORT void
+ xf86DisableUnusedFunctions(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT DisplayModePtr
+xf86OutputFindClosestMode(xf86OutputPtr output, DisplayModePtr desired);
+
+extern _X_EXPORT Bool
+
+xf86SetSingleMode(ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation);
+
+/**
+ * Set the EDID information for the specified output
+ */
+extern _X_EXPORT void
+ xf86OutputSetEDID(xf86OutputPtr output, xf86MonPtr edid_mon);
+
+/**
+ * Return the list of modes supported by the EDID information
+ * stored in 'output'
+ */
+extern _X_EXPORT DisplayModePtr xf86OutputGetEDIDModes(xf86OutputPtr output);
+
+extern _X_EXPORT xf86MonPtr
+xf86OutputGetEDID(xf86OutputPtr output, I2CBusPtr pDDCBus);
+
+/**
+ * Initialize dga for this screen
+ */
+
+#ifdef XFreeXDGA
+extern _X_EXPORT Bool
+ xf86DiDGAInit(ScreenPtr pScreen, unsigned long dga_address);
+
+/* this is the real function, used only internally */
+_X_INTERNAL Bool
+ _xf86_di_dga_init_internal(ScreenPtr pScreen);
+
+/**
+ * Re-initialize dga for this screen (as when the set of modes changes)
+ */
+
+extern _X_EXPORT Bool
+ xf86DiDGAReInit(ScreenPtr pScreen);
+#endif
+
+/* This is the real function, used only internally */
+_X_INTERNAL Bool
+ _xf86_di_dga_reinit_internal(ScreenPtr pScreen);
+
+/*
+ * Set the subpixel order reported for the screen using
+ * the information from the outputs
+ */
+
+extern _X_EXPORT void
+ xf86CrtcSetScreenSubpixelOrder(ScreenPtr pScreen);
+
+/*
+ * Get a standard string name for a connector type 
+ */
+extern _X_EXPORT const char *xf86ConnectorGetName(xf86ConnectorType connector);
+
+/*
+ * Using the desired mode information in each crtc, set
+ * modes (used in EnterVT functions, or at server startup)
+ */
+
+extern _X_EXPORT Bool
+ xf86SetDesiredModes(ScrnInfoPtr pScrn);
+
+/**
+ * Initialize the CRTC-based cursor code. CRTC function vectors must
+ * contain relevant cursor setting functions.
+ *
+ * Driver should call this from ScreenInit function
+ */
+extern _X_EXPORT Bool
+ xf86_cursors_init(ScreenPtr screen, int max_width, int max_height, int flags);
+
+/**
+ * Called when anything on the screen is reconfigured.
+ *
+ * Reloads cursor images as needed, then adjusts cursor positions.
+ * 
+ * Driver should call this from crtc commit function.
+ */
+extern _X_EXPORT void
+ xf86_reload_cursors(ScreenPtr screen);
+
+/**
+ * Called from EnterVT to turn the cursors back on
+ */
+extern _X_EXPORT void
+ xf86_show_cursors(ScrnInfoPtr scrn);
+
+/**
+ * Called by the driver to turn cursors off
+ */
+extern _X_EXPORT void
+ xf86_hide_cursors(ScrnInfoPtr scrn);
+
+/**
+ * Clean up CRTC-based cursor code. Driver must call this at CloseScreen time.
+ */
+extern _X_EXPORT void
+ xf86_cursors_fini(ScreenPtr screen);
+
+/**
+ * Transform the cursor's coordinates based on the crtc transform.  Normally
+ * this is done by the server, but if crtc->driverIsPerformingTransform is TRUE,
+ * then the server does not transform the cursor position automatically.
+ */
+extern _X_EXPORT void
+ xf86CrtcTransformCursorPos(xf86CrtcPtr crtc, int *x, int *y);
+
+#ifdef XV
+/*
+ * For overlay video, compute the relevant CRTC and
+ * clip video to that.
+ * wraps xf86XVClipVideoHelper()
+ */
+
+extern _X_EXPORT Bool
+
+xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
+                            xf86CrtcPtr * crtc_ret,
+                            xf86CrtcPtr desired_crtc,
+                            BoxPtr dst,
+                            INT32 *xa,
+                            INT32 *xb,
+                            INT32 *ya,
+                            INT32 *yb,
+                            RegionPtr reg, INT32 width, INT32 height);
+#endif
+
+extern _X_EXPORT xf86_crtc_notify_proc_ptr
+xf86_wrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr new);
+
+extern _X_EXPORT void
+ xf86_unwrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr old);
+
+extern _X_EXPORT void
+ xf86_crtc_notify(ScreenPtr pScreen);
+
+/**
+ * Gamma
+ */
+
+extern _X_EXPORT Bool
+ xf86_crtc_supports_gamma(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void
+xf86ProviderSetup(ScrnInfoPtr scrn,
+                  const xf86ProviderFuncsRec * funcs, const char *name);
+
+extern _X_EXPORT void
+xf86DetachAllCrtc(ScrnInfoPtr scrn);
+
+#endif                          /* _XF86CRTC_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Crtc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optrec.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optrec.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optrec.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* 
+ * This file contains the Option Record that is passed between the Parser,
+ * and Module setup procs.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86Optrec_h_
+#define _xf86Optrec_h_
+#include <stdio.h>
+#include <string.h>
+#include "xf86Optionstr.h"
+
+#include <X11/Xfuncproto.h>
+
+extern _X_EXPORT XF86OptionPtr xf86addNewOption(XF86OptionPtr head, char *name,
+                                                char *val);
+extern _X_EXPORT XF86OptionPtr xf86optionListDup(XF86OptionPtr opt);
+extern _X_EXPORT void xf86optionListFree(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86optionName(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86optionValue(XF86OptionPtr opt);
+extern _X_EXPORT XF86OptionPtr xf86newOption(char *name, char *value);
+extern _X_EXPORT XF86OptionPtr xf86nextOption(XF86OptionPtr list);
+extern _X_EXPORT XF86OptionPtr xf86findOption(XF86OptionPtr list,
+                                              const char *name);
+extern _X_EXPORT const char *xf86findOptionValue(XF86OptionPtr list,
+                                                 const char *name);
+extern _X_EXPORT XF86OptionPtr xf86optionListCreate(const char **options,
+                                                    int count, int used);
+extern _X_EXPORT XF86OptionPtr xf86optionListMerge(XF86OptionPtr head,
+                                                   XF86OptionPtr tail);
+extern _X_EXPORT int xf86nameCompare(const char *s1, const char *s2);
+extern _X_EXPORT char *xf86uLongToString(unsigned long i);
+extern _X_EXPORT XF86OptionPtr xf86parseOption(XF86OptionPtr head);
+extern _X_EXPORT void xf86printOptionList(FILE * fp, XF86OptionPtr list,
+                                          int tabs);
+
+#endif                          /* _xf86Optrec_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optrec.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbrop.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbrop.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbrop.h	(Revision 52145)
@@ -0,0 +1,137 @@
+/*
+ * Copyright ¬© 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FBROP_H_
+#define _FBROP_H_
+
+typedef struct _mergeRopBits {
+    FbBits ca1, cx1, ca2, cx2;
+} FbMergeRopRec, *FbMergeRopPtr;
+
+extern _X_EXPORT const FbMergeRopRec FbMergeRopBits[16];
+
+#define FbDeclareMergeRop() FbBits   _ca1, _cx1, _ca2, _cx2;
+#define FbDeclarePrebuiltMergeRop()	FbBits	_cca, _ccx;
+
+#define FbInitializeMergeRop(alu,pm) {\
+    const FbMergeRopRec  *_bits; \
+    _bits = &FbMergeRopBits[alu]; \
+    _ca1 = _bits->ca1 &  pm; \
+    _cx1 = _bits->cx1 | ~pm; \
+    _ca2 = _bits->ca2 &  pm; \
+    _cx2 = _bits->cx2 &  pm; \
+}
+
+#define FbDestInvarientRop(alu,pm)  ((pm) == FB_ALLONES && \
+				     (((alu) >> 1 & 5) == ((alu) & 5)))
+
+#define FbDestInvarientMergeRop()   (_ca1 == 0 && _cx1 == 0)
+
+/* AND has higher precedence than XOR */
+
+#define FbDoMergeRop(src, dst) \
+    (((dst) & (((src) & _ca1) ^ _cx1)) ^ (((src) & _ca2) ^ _cx2))
+
+#define FbDoDestInvarientMergeRop(src)	(((src) & _ca2) ^ _cx2)
+
+#define FbDoMaskMergeRop(src, dst, mask) \
+    (((dst) & ((((src) & _ca1) ^ _cx1) | ~(mask))) ^ ((((src) & _ca2) ^ _cx2) & (mask)))
+
+#define FbDoLeftMaskByteMergeRop(dst, src, lb, l) { \
+    FbBits  __xor = ((src) & _ca2) ^ _cx2; \
+    FbDoLeftMaskByteRRop(dst,lb,l,((src) & _ca1) ^ _cx1,__xor); \
+}
+
+#define FbDoRightMaskByteMergeRop(dst, src, rb, r) { \
+    FbBits  __xor = ((src) & _ca2) ^ _cx2; \
+    FbDoRightMaskByteRRop(dst,rb,r,((src) & _ca1) ^ _cx1,__xor); \
+}
+
+#define FbDoRRop(dst, and, xor)	(((dst) & (and)) ^ (xor))
+
+#define FbDoMaskRRop(dst, and, xor, mask) \
+    (((dst) & ((and) | ~(mask))) ^ (xor & mask))
+
+/*
+ * Take a single bit (0 or 1) and generate a full mask
+ */
+#define fbFillFromBit(b,t)	(~((t) ((b) & 1)-1))
+
+#define fbXorT(rop,fg,pm,t) ((((fg) & fbFillFromBit((rop) >> 1,t)) | \
+			      (~(fg) & fbFillFromBit((rop) >> 3,t))) & (pm))
+
+#define fbAndT(rop,fg,pm,t) ((((fg) & fbFillFromBit (rop ^ (rop>>1),t)) | \
+			      (~(fg) & fbFillFromBit((rop>>2) ^ (rop>>3),t))) | \
+			     ~(pm))
+
+#define fbXor(rop,fg,pm)	fbXorT(rop,fg,pm,FbBits)
+
+#define fbAnd(rop,fg,pm)	fbAndT(rop,fg,pm,FbBits)
+
+#define fbXorStip(rop,fg,pm)    fbXorT(rop,fg,pm,FbStip)
+
+#define fbAndStip(rop,fg,pm)	fbAndT(rop,fg,pm,FbStip)
+
+/*
+ * Stippling operations; 
+ */
+
+extern _X_EXPORT const FbBits fbStipple16Bits[256];     /* half of table */
+
+#define FbStipple16Bits(b) \
+    (fbStipple16Bits[(b)&0xff] | fbStipple16Bits[(b) >> 8] << FB_HALFUNIT)
+extern _X_EXPORT const FbBits fbStipple8Bits[256];
+extern _X_EXPORT const FbBits fbStipple4Bits[16];
+extern _X_EXPORT const FbBits fbStipple2Bits[4];
+extern _X_EXPORT const FbBits fbStipple1Bits[2];
+extern _X_EXPORT const FbBits *const fbStippleTable[];
+
+#define FbStippleRRop(dst, b, fa, fx, ba, bx) \
+    (FbDoRRop(dst, fa, fx) & b) | (FbDoRRop(dst, ba, bx) & ~b)
+
+#define FbStippleRRopMask(dst, b, fa, fx, ba, bx, m) \
+    (FbDoMaskRRop(dst, fa, fx, m) & (b)) | (FbDoMaskRRop(dst, ba, bx, m) & ~(b))
+
+#define FbDoLeftMaskByteStippleRRop(dst, b, fa, fx, ba, bx, lb, l) { \
+    FbBits  __xor = ((fx) & (b)) | ((bx) & ~(b)); \
+    FbDoLeftMaskByteRRop(dst, lb, l, ((fa) & (b)) | ((ba) & ~(b)), __xor); \
+}
+
+#define FbDoRightMaskByteStippleRRop(dst, b, fa, fx, ba, bx, rb, r) { \
+    FbBits  __xor = ((fx) & (b)) | ((bx) & ~(b)); \
+    FbDoRightMaskByteRRop(dst, rb, r, ((fa) & (b)) | ((ba) & ~(b)), __xor); \
+}
+
+#define FbOpaqueStipple(b, fg, bg) (((fg) & (b)) | ((bg) & ~(b)))
+
+/*
+ * Compute rop for using tile code for 1-bit dest stipples; modifies
+ * existing rop to flip depending on pixel values
+ */
+#define FbStipple1RopPick(alu,b)    (((alu) >> (2 - (((b) & 1) << 1))) & 3)
+
+#define FbOpaqueStipple1Rop(alu,fg,bg)    (FbStipple1RopPick(alu,fg) | \
+					   (FbStipple1RopPick(alu,bg) << 2))
+
+#define FbStipple1Rop(alu,fg)	    (FbStipple1RopPick(alu,fg) | 4)
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbrop.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/bt829.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/bt829.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/bt829.h	(Revision 52145)
@@ -0,0 +1,103 @@
+#ifndef __BT829_H__
+#define __BT829_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    int tunertype;              /* Must be set before init */
+    /* Private variables */
+    I2CDevRec d;
+
+    CARD8 brightness;
+    CARD8 ccmode;
+    CARD8 code;
+    CARD16 contrast;
+    CARD8 format;
+    int height;
+    CARD8 hue;
+    CARD8 len;
+    CARD8 mux;
+    CARD8 out_en;
+    CARD8 p_io;
+    CARD16 sat_u;
+    CARD16 sat_v;
+    CARD8 vbien;
+    CARD8 vbifmt;
+    int width;
+
+    CARD16 hdelay;
+    CARD16 hscale;
+    CARD16 vactive;
+    CARD16 vdelay;
+    CARD16 vscale;
+
+    CARD16 htotal;
+    CARD8 id;
+    CARD8 svideo_mux;
+} BT829Rec, *BT829Ptr;
+
+#define xf86_bt829_Detect	bt829_Detect
+extern _X_EXPORT BT829Ptr bt829_Detect(I2CBusPtr b, I2CSlaveAddr addr);
+
+/* ATI card specific initialization */
+#define BT829_ATI_ADDR_1	0x8A
+#define BT829_ATI_ADDR_2	0x88
+
+#define xf86_bt829_ATIInit	bt829_ATIInit
+extern _X_EXPORT int bt829_ATIInit(BT829Ptr bt);
+
+#define BT829_NTSC		1       /* NTSC-M */
+#define BT829_NTSC_JAPAN	2       /* NTSC-Japan */
+#define BT829_PAL		3       /* PAL-B,D,G,H,I */
+#define BT829_PAL_M		4       /* PAL-M */
+#define BT829_PAL_N		5       /* PAL-N */
+#define BT829_SECAM		6       /* SECAM */
+#define BT829_PAL_N_COMB	7       /* PAL-N combination */
+
+#define xf86_bt829_SetFormat	bt829_SetFormat
+extern _X_EXPORT int bt829_SetFormat(BT829Ptr bt, CARD8 format);
+
+#define BT829_MUX2	1       /* ATI -> composite video */
+#define BT829_MUX0	2       /* ATI -> tv tuner */
+#define BT829_MUX1	3       /* ATI -> s-video */
+
+#define xf86_bt829_SetMux	bt829_SetMux
+extern _X_EXPORT int bt829_SetMux(BT829Ptr bt, CARD8 mux);
+
+#define xf86_bt829_SetCaptSize		bt829_SetCaptSize
+extern _X_EXPORT int bt829_SetCaptSize(BT829Ptr bt, int width, int height);
+
+#define xf86_bt829_SetBrightness	bt829_SetBrightness
+extern _X_EXPORT void bt829_SetBrightness(BT829Ptr bt, int brightness);
+
+#define xf86_bt829_SetContrast		bt829_SetContrast
+extern _X_EXPORT void bt829_SetContrast(BT829Ptr bt, int contrast);
+
+#define xf86_bt829_SetSaturation	bt829_SetSaturation
+extern _X_EXPORT void bt829_SetSaturation(BT829Ptr bt, int saturation);
+
+#define xf86_bt829_SetTint		bt829_SetTint
+extern _X_EXPORT void bt829_SetTint(BT829Ptr bt, int hue);      /* Hue */
+
+#define xf86_bt829_SetOUT_EN		bt829_SetOUT_EN
+extern _X_EXPORT void bt829_SetOUT_EN(BT829Ptr bt, BOOL out_en);        /* VPOLE register */
+
+#define xf86_bt829_SetP_IO		bt829_SetP_IO
+extern _X_EXPORT void bt829_SetP_IO(BT829Ptr bt, CARD8 p_io);   /* P_IO register */
+
+extern _X_EXPORT int bt829_SetCC(BT829Ptr bt);
+
+#define BT829SymbolsList   \
+		"bt829_Detect", \
+		"bt829_ATIInit", \
+		"bt829_SetFormat", \
+		"bt829_SetMux", \
+		"bt829_SetBrightness", \
+		"bt829_SetContrast", \
+		"bt829_SetSaturation", \
+		"bt829_SetTint", \
+		"bt829_SetCaptSize", \
+		"bt829_SetOUT_EN", \
+		"bt829_SetP_IO"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/bt829.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointrst.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointrst.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointrst.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/*
+ * mipointrst.h
+ *
+ */
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef MIPOINTRST_H
+#define MIPOINTRST_H
+
+#include "mipointer.h"
+#include "scrnintstr.h"
+
+typedef struct {
+    ScreenPtr pScreen;          /* current screen */
+    ScreenPtr pSpriteScreen;    /* screen containing current sprite */
+    CursorPtr pCursor;          /* current cursor */
+    CursorPtr pSpriteCursor;    /* cursor on screen */
+    BoxRec limits;              /* current constraints */
+    Bool confined;              /* pointer can't change screens */
+    int x, y;                   /* hot spot location */
+    int devx, devy;             /* sprite position */
+    Bool generateEvent;         /* generate an event during warping? */
+} miPointerRec, *miPointerPtr;
+
+typedef struct {
+    miPointerSpriteFuncPtr spriteFuncs; /* sprite-specific methods */
+    miPointerScreenFuncPtr screenFuncs; /* screen-specific methods */
+    CloseScreenProcPtr CloseScreen;
+    Bool waitForUpdate;         /* don't move cursor in SIGIO */
+    Bool showTransparent;       /* show empty cursors */
+} miPointerScreenRec, *miPointerScreenPtr;
+#endif                          /* MIPOINTRST_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointrst.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/registry.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/registry.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/registry.h	(Revision 52145)
@@ -0,0 +1,66 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_REGISTRY_H
+#define DIX_REGISTRY_H
+
+/*
+ * Result returned from any unsuccessful lookup
+ */
+#define XREGISTRY_UNKNOWN "<unknown>"
+
+#ifdef XREGISTRY
+
+#include "resource.h"
+#include "extnsionst.h"
+
+/* Internal string registry - for auditing, debugging, security, etc. */
+
+/*
+ * Registration functions.  The name string is not copied, so it must
+ * not be a stack variable.
+ */
+extern _X_EXPORT void RegisterResourceName(RESTYPE type, const char *name);
+extern _X_EXPORT void RegisterExtensionNames(ExtensionEntry * ext);
+
+/*
+ * Lookup functions.  The returned string must not be modified or freed.
+ */
+extern _X_EXPORT const char *LookupMajorName(int major);
+extern _X_EXPORT const char *LookupRequestName(int major, int minor);
+extern _X_EXPORT const char *LookupEventName(int event);
+extern _X_EXPORT const char *LookupErrorName(int error);
+extern _X_EXPORT const char *LookupResourceName(RESTYPE rtype);
+
+/*
+ * Setup and teardown
+ */
+extern _X_EXPORT void dixResetRegistry(void);
+extern _X_EXPORT void dixFreeRegistry(void);
+
+#else                           /* XREGISTRY */
+
+/* Define calls away when the registry is not being built. */
+
+#define RegisterResourceName(a, b) { ; }
+#define RegisterExtensionNames(a) { ; }
+
+#define LookupMajorName(a) XREGISTRY_UNKNOWN
+#define LookupRequestName(a, b) XREGISTRY_UNKNOWN
+#define LookupEventName(a) XREGISTRY_UNKNOWN
+#define LookupErrorName(a) XREGISTRY_UNKNOWN
+#define LookupResourceName(a) XREGISTRY_UNKNOWN
+
+#define dixResetRegistry() { ; }
+#define dixFreeRegistry() { ; }
+
+#endif                          /* XREGISTRY */
+#endif                          /* DIX_REGISTRY_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/registry.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Pci.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Pci.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Pci.h	(Revision 52145)
@@ -0,0 +1,148 @@
+/*
+ * Copyright 1998 by Concurrent Computer Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Concurrent Computer
+ * Corporation not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Concurrent Computer Corporation makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Copyright 1998 by Metro Link Incorporated
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Metro Link
+ * Incorporated not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Metro Link Incorporated makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * This file is derived in part from the original xf86_PCI.h that included
+ * following copyright message:
+ *
+ * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holder(s)
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holder(s) make(s) no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file has the private Pci definitions.  The public ones are imported
+ * from xf86Pci.h.  Drivers should not use this file.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _PCI_H
+#define _PCI_H 1
+
+#include "xf86Pci.h"
+
+/*
+ * Global Definitions
+ */
+#if (defined(__alpha__) || defined(__ia64__)) && defined (linux)
+#define PCI_DOM_MASK	0x01fful
+#else
+#define PCI_DOM_MASK 0x0ffu
+#endif
+
+#ifndef PCI_DOM_MASK
+#define PCI_DOM_MASK 0x0ffu
+#endif
+#define PCI_DOMBUS_MASK (((PCI_DOM_MASK) << 8) | 0x0ffu)
+
+/*
+ * "b" contains an optional domain number.
+ */
+#define PCI_MAKE_TAG(b,d,f)  ((((b) & (PCI_DOMBUS_MASK)) << 16) | \
+			      (((d) & 0x00001fu) << 11) | \
+			      (((f) & 0x000007u) << 8))
+
+#define PCI_MAKE_BUS(d,b)    ((((d) & (PCI_DOM_MASK)) << 8) | ((b) & 0xffu))
+
+#define PCI_DOM_FROM_BUS(bus)  (((bus) >> 8) & (PCI_DOM_MASK))
+#define PCI_BUS_NO_DOMAIN(bus) ((bus) & 0xffu)
+#define PCI_TAG_NO_DOMAIN(tag) ((tag) & 0x00ffff00u)
+
+#if defined(linux)
+#define osPciInit(x) do {} while (0)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
+	defined(__OpenBSD__) || defined(__NetBSD__) || \
+	defined(__DragonFly__) || defined(__sun) || defined(__GNU__)
+extern void osPciInit(void);
+#else
+#error No PCI support available for this architecture/OS combination
+#endif
+
+#endif                          /* _PCI_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Pci.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdpms.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdpms.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdpms.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Author:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DPMS extension support.  \see dmxdpms.c */
+
+#ifndef _DMXDPMS_H_
+#define _DMXDPMS_H_
+extern void dmxDPMSInit(DMXScreenInfo * dmxScreen);
+extern void dmxDPMSTerm(DMXScreenInfo * dmxScreen);
+extern void dmxDPMSWakeup(void);        /* Call when input is processed */
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxdpms.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/client.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/client.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/client.h	(Revision 52145)
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies). All
+ * rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/* Author: Rami Ylim√§ki <rami.ylimaki@vincit.fi> */
+
+#ifndef CLIENT_H
+#define CLIENT_H
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif                          /* HAVE_DIX_CONFIG_H */
+#include <X11/Xfuncproto.h>
+#include <sys/types.h>
+
+/* Client IDs. Use GetClientPid, GetClientCmdName and GetClientCmdArgs
+ * instead of accessing the fields directly. */
+typedef struct {
+    pid_t pid;                  /* process ID, -1 if not available */
+    const char *cmdname;        /* process name, NULL if not available */
+    const char *cmdargs;        /* process arguments, NULL if not available */
+} ClientIdRec, *ClientIdPtr;
+
+struct _Client;
+
+/* Initialize and clean up. */
+void ReserveClientIds(struct _Client *client);
+void ReleaseClientIds(struct _Client *client);
+
+/* Determine client IDs for caching. Exported on purpose for
+ * extensions such as SELinux. */
+extern _X_EXPORT pid_t DetermineClientPid(struct _Client *client);
+extern _X_EXPORT void DetermineClientCmd(pid_t, const char **cmdname,
+                                         const char **cmdargs);
+
+/* Query cached client IDs. Exported on purpose for drivers. */
+extern _X_EXPORT pid_t GetClientPid(struct _Client *client);
+extern _X_EXPORT const char *GetClientCmdName(struct _Client *client);
+extern _X_EXPORT const char *GetClientCmdArgs(struct _Client *client);
+
+#endif                          /* CLIENT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/client.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getselev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getselev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getselev.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETSELEV_H
+#define GETSELEV_H 1
+
+int SProcXGetSelectedExtensionEvents(ClientPtr  /* client */
+    );
+
+int ProcXGetSelectedExtensionEvents(ClientPtr   /* client */
+    );
+
+void SRepXGetSelectedExtensionEvents(ClientPtr /* client */ ,
+                                     int /* size */ ,
+                                     xGetSelectedExtensionEventsReply * /* rep */
+    );
+
+#endif                          /* GETSELEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getselev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ms.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ms.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ms.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux MS mouse driver.  \see lnx-ms.c */
+
+#ifndef _LNX_MS_H_
+#define _LNX_MS_H_
+
+extern void *msLinuxCreatePrivate(DeviceIntPtr pMouse);
+extern void msLinuxDestroyPrivate(void *priv);
+extern void msLinuxRead(DevicePtr pDev,
+                        dmxMotionProcPtr motion,
+                        dmxEnqueueProcPtr enqueue,
+                        dmxCheckSpecialProcPtr checkspecial,
+                        DMXBlockType block);
+extern void msLinuxInit(DevicePtr pDev);
+extern void msLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int msLinuxOn(DevicePtr pDev);
+extern void msLinuxOff(DevicePtr pDev);
+extern void msLinuxCtrl(DevicePtr pDev, PtrCtrl * ctrl);
+extern void msLinuxVTPreSwitch(void *p);
+extern void msLinuxVTPostSwitch(void *p);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ms.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rrtransform.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rrtransform.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rrtransform.h	(Revision 52145)
@@ -0,0 +1,79 @@
+/*
+ * Copyright ¬© 2007 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _RRTRANSFORM_H_
+#define _RRTRANSFORM_H_
+
+#include <X11/extensions/randr.h>
+#include "picturestr.h"
+
+typedef struct _rrTransform RRTransformRec, *RRTransformPtr;
+
+struct _rrTransform {
+    PictTransform transform;
+    struct pict_f_transform f_transform;
+    struct pict_f_transform f_inverse;
+    PictFilterPtr filter;
+    xFixed *params;
+    int nparams;
+    int width;
+    int height;
+};
+
+extern _X_EXPORT void
+ RRTransformInit(RRTransformPtr transform);
+
+extern _X_EXPORT void
+ RRTransformFini(RRTransformPtr transform);
+
+extern _X_EXPORT Bool
+ RRTransformEqual(RRTransformPtr a, RRTransformPtr b);
+
+extern _X_EXPORT Bool
+
+RRTransformSetFilter(RRTransformPtr dst,
+                     PictFilterPtr filter,
+                     xFixed * params, int nparams, int width, int height);
+
+extern _X_EXPORT Bool
+ RRTransformCopy(RRTransformPtr dst, RRTransformPtr src);
+
+/*
+ * Compute the complete transformation matrix including
+ * client-specified transform, rotation/reflection values and the crtc 
+ * offset.
+ *
+ * Return TRUE if the resulting transform is not a simple translation.
+ */
+extern _X_EXPORT Bool
+
+RRTransformCompute(int x,
+                   int y,
+                   int width,
+                   int height,
+                   Rotation rotation,
+                   RRTransformPtr rr_transform,
+                   PictTransformPtr transform,
+                   struct pict_f_transform *f_transform,
+                   struct pict_f_transform *f_inverse);
+
+#endif                          /* _RRTRANSFORM_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rrtransform.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxwindow.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxwindow.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxwindow.h	(Revision 52145)
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for window support.  \see dmxwindow.c */
+
+#ifndef DMXWINDOW_H
+#define DMXWINDOW_H
+
+#include "windowstr.h"
+
+/** Window private area. */
+typedef struct _dmxWinPriv {
+    Window window;
+    Bool offscreen;
+    Bool mapped;
+    Bool restacked;
+    unsigned long attribMask;
+    Colormap cmap;
+    Visual *visual;
+    Bool isShaped;
+    Bool hasPict;
+#ifdef GLXEXT
+    void *swapGroup;
+    int barrier;
+    void (*windowDestroyed) (WindowPtr);
+    void (*windowUnmapped) (WindowPtr);
+#endif
+} dmxWinPrivRec, *dmxWinPrivPtr;
+
+extern Bool dmxInitWindow(ScreenPtr pScreen);
+
+extern Window dmxCreateRootWindow(WindowPtr pWindow);
+
+extern void dmxGetDefaultWindowAttributes(WindowPtr pWindow,
+                                          Colormap * cmap, Visual ** visual);
+extern void dmxCreateAndRealizeWindow(WindowPtr pWindow, Bool doSync);
+
+extern Bool dmxCreateWindow(WindowPtr pWindow);
+extern Bool dmxDestroyWindow(WindowPtr pWindow);
+extern Bool dmxPositionWindow(WindowPtr pWindow, int x, int y);
+extern Bool dmxChangeWindowAttributes(WindowPtr pWindow, unsigned long mask);
+extern Bool dmxRealizeWindow(WindowPtr pWindow);
+extern Bool dmxUnrealizeWindow(WindowPtr pWindow);
+extern void dmxRestackWindow(WindowPtr pWindow, WindowPtr pOldNextSib);
+extern void dmxWindowExposures(WindowPtr pWindow, RegionPtr prgn,
+                               RegionPtr other_exposed);
+extern void dmxCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
+                          RegionPtr prgnSrc);
+
+extern void dmxResizeWindow(WindowPtr pWindow, int x, int y,
+                            unsigned int w, unsigned int h, WindowPtr pSib);
+extern void dmxReparentWindow(WindowPtr pWindow, WindowPtr pPriorParent);
+
+extern void dmxChangeBorderWidth(WindowPtr pWindow, unsigned int width);
+
+extern void dmxResizeScreenWindow(ScreenPtr pScreen,
+                                  int x, int y, int w, int h);
+extern void dmxResizeRootWindow(WindowPtr pRoot, int x, int y, int w, int h);
+
+extern Bool dmxBEDestroyWindow(WindowPtr pWindow);
+
+/* Support for shape extension */
+extern void dmxSetShape(WindowPtr pWindow, int kind);
+
+/** Get window private pointer. */
+#define DMX_GET_WINDOW_PRIV(_pWin) ((dmxWinPrivPtr) \
+    dixLookupPrivate(&(_pWin)->devPrivates, dmxWinPrivateKey))
+
+/* All of these macros are only used in dmxwindow.c */
+#define DMX_WINDOW_FUNC_PROLOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_UNWRAP(funcs, pGCPriv, (_pGC));					\
+    if (pGCPriv->ops)							\
+	DMX_UNWRAP(ops, pGCPriv, (_pGC));				\
+} while (0)
+
+#define DMX_WINDOW_FUNC_EPILOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_WRAP(funcs, &dmxGCFuncs, pGCPriv, (_pGC));			\
+    if (pGCPriv->ops)							\
+	DMX_WRAP(ops, &dmxGCOps, pGCPriv, (_pGC));			\
+} while (0)
+
+#define DMX_WINDOW_X1(_pWin)						\
+    ((_pWin)->drawable.x - wBorderWidth(_pWin))
+#define DMX_WINDOW_Y1(_pWin)						\
+    ((_pWin)->drawable.y - wBorderWidth(_pWin))
+#define DMX_WINDOW_X2(_pWin)						\
+    ((_pWin)->drawable.x + wBorderWidth(_pWin) + (_pWin)->drawable.width)
+#define DMX_WINDOW_Y2(_pWin)						\
+    ((_pWin)->drawable.y + wBorderWidth(_pWin) + (_pWin)->drawable.height)
+
+#define DMX_WINDOW_OFFSCREEN(_pWin)					\
+    (DMX_WINDOW_X1(_pWin) >= (_pWin)->drawable.pScreen->width  ||	\
+     DMX_WINDOW_Y1(_pWin) >= (_pWin)->drawable.pScreen->height ||	\
+     DMX_WINDOW_X2(_pWin) <= 0                                 ||	\
+     DMX_WINDOW_Y2(_pWin) <= 0)
+
+#endif                          /* DMXWINDOW_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxwindow.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangecursor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangecursor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangecursor.h	(Revision 52145)
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHDEVCUR_H
+#define CHDEVCUR_H 1
+
+int SProcXIChangeCursor(ClientPtr /* client */ );
+int ProcXIChangeCursor(ClientPtr /* client */ );
+
+#endif                          /* CHDEVCUR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangecursor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/property.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/property.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/property.h	(Revision 52145)
@@ -0,0 +1,85 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PROPERTY_H
+#define PROPERTY_H
+
+#include "window.h"
+
+typedef struct _Property *PropertyPtr;
+
+extern _X_EXPORT int dixLookupProperty(PropertyPtr * /*result */ ,
+                                       WindowPtr /*pWin */ ,
+                                       Atom /*proprty */ ,
+                                       ClientPtr /*pClient */ ,
+                                       Mask /*access_mode */ );
+
+extern _X_EXPORT int dixChangeWindowProperty(ClientPtr /*pClient */ ,
+                                             WindowPtr /*pWin */ ,
+                                             Atom /*property */ ,
+                                             Atom /*type */ ,
+                                             int /*format */ ,
+                                             int /*mode */ ,
+                                             unsigned long /*len */ ,
+                                             void */*value */ ,
+                                             Bool /*sendevent */ );
+
+extern _X_EXPORT int ChangeWindowProperty(WindowPtr /*pWin */ ,
+                                          Atom /*property */ ,
+                                          Atom /*type */ ,
+                                          int /*format */ ,
+                                          int /*mode */ ,
+                                          unsigned long /*len */ ,
+                                          void */*value */ ,
+                                          Bool /*sendevent */ );
+
+extern _X_EXPORT int DeleteProperty(ClientPtr /*client */ ,
+                                    WindowPtr /*pWin */ ,
+                                    Atom /*propName */ );
+
+extern _X_EXPORT void DeleteAllWindowProperties(WindowPtr /*pWin */ );
+
+#endif                          /* PROPERTY_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/property.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbdevhw.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbdevhw.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbdevhw.h	(Revision 52145)
@@ -0,0 +1,66 @@
+
+#ifndef _FBDEVHW_H_
+#define _FBDEVHW_H_
+
+#include "xf86str.h"
+#include "colormapst.h"
+
+#define FBDEVHW_PACKED_PIXELS		0       /* Packed Pixels        */
+#define FBDEVHW_PLANES			1       /* Non interleaved planes */
+#define FBDEVHW_INTERLEAVED_PLANES	2       /* Interleaved planes   */
+#define FBDEVHW_TEXT			3       /* Text/attributes      */
+#define FBDEVHW_VGA_PLANES		4       /* EGA/VGA planes       */
+
+extern _X_EXPORT Bool fbdevHWGetRec(ScrnInfoPtr pScrn);
+extern _X_EXPORT void fbdevHWFreeRec(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT int fbdevHWGetFD(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT Bool fbdevHWProbe(struct pci_device *pPci, char *device,
+                                   char **namep);
+extern _X_EXPORT Bool fbdevHWInit(ScrnInfoPtr pScrn, struct pci_device *pPci,
+                                  char *device);
+
+extern _X_EXPORT char *fbdevHWGetName(ScrnInfoPtr pScrn);
+extern _X_EXPORT int fbdevHWGetDepth(ScrnInfoPtr pScrn, int *fbbpp);
+extern _X_EXPORT int fbdevHWGetLineLength(ScrnInfoPtr pScrn);
+extern _X_EXPORT int fbdevHWGetType(ScrnInfoPtr pScrn);
+extern _X_EXPORT int fbdevHWGetVidmem(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void *fbdevHWMapVidmem(ScrnInfoPtr pScrn);
+extern _X_EXPORT int fbdevHWLinearOffset(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool fbdevHWUnmapVidmem(ScrnInfoPtr pScrn);
+extern _X_EXPORT void *fbdevHWMapMMIO(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool fbdevHWUnmapMMIO(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void fbdevHWSetVideoModes(ScrnInfoPtr pScrn);
+extern _X_EXPORT DisplayModePtr fbdevHWGetBuildinMode(ScrnInfoPtr pScrn);
+extern _X_EXPORT void fbdevHWUseBuildinMode(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool fbdevHWModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
+extern _X_EXPORT void fbdevHWSave(ScrnInfoPtr pScrn);
+extern _X_EXPORT void fbdevHWRestore(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void fbdevHWLoadPalette(ScrnInfoPtr pScrn, int numColors,
+                                         int *indices, LOCO * colors,
+                                         VisualPtr pVisual);
+
+extern _X_EXPORT ModeStatus fbdevHWValidMode(ScrnInfoPtr pScrn, DisplayModePtr mode,
+                                             Bool verbose, int flags);
+extern _X_EXPORT Bool fbdevHWSwitchMode(ScrnInfoPtr pScrn, DisplayModePtr mode);
+extern _X_EXPORT void fbdevHWAdjustFrame(ScrnInfoPtr pScrn, int x, int y);
+extern _X_EXPORT Bool fbdevHWEnterVT(ScrnInfoPtr pScrn);
+extern _X_EXPORT void fbdevHWLeaveVT(ScrnInfoPtr pScrn);
+extern _X_EXPORT void fbdevHWDPMSSet(ScrnInfoPtr pScrn, int mode, int flags);
+
+extern _X_EXPORT Bool fbdevHWSaveScreen(ScreenPtr pScreen, int mode);
+
+extern _X_EXPORT xf86SwitchModeProc *fbdevHWSwitchModeWeak(void);
+extern _X_EXPORT xf86AdjustFrameProc *fbdevHWAdjustFrameWeak(void);
+extern _X_EXPORT xf86EnterVTProc *fbdevHWEnterVTWeak(void);
+extern _X_EXPORT xf86LeaveVTProc *fbdevHWLeaveVTWeak(void);
+extern _X_EXPORT xf86ValidModeProc *fbdevHWValidModeWeak(void);
+extern _X_EXPORT xf86DPMSSetProc *fbdevHWDPMSSetWeak(void);
+extern _X_EXPORT xf86LoadPaletteProc *fbdevHWLoadPaletteWeak(void);
+extern _X_EXPORT SaveScreenProcPtr fbdevHWSaveScreenWeak(void);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbdevhw.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Cursor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Cursor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Cursor.h	(Revision 52145)
@@ -0,0 +1,84 @@
+
+#ifndef _XF86CURSOR_H
+#define _XF86CURSOR_H
+
+#include "xf86str.h"
+#include "mipointer.h"
+
+typedef struct _xf86CursorInfoRec {
+    ScrnInfoPtr pScrn;
+    int Flags;
+    int MaxWidth;
+    int MaxHeight;
+    void (*SetCursorColors) (ScrnInfoPtr pScrn, int bg, int fg);
+    void (*SetCursorPosition) (ScrnInfoPtr pScrn, int x, int y);
+    void (*LoadCursorImage) (ScrnInfoPtr pScrn, unsigned char *bits);
+    Bool (*LoadCursorImageCheck) (ScrnInfoPtr pScrn, unsigned char *bits);
+    void (*HideCursor) (ScrnInfoPtr pScrn);
+    void (*ShowCursor) (ScrnInfoPtr pScrn);
+    unsigned char *(*RealizeCursor) (struct _xf86CursorInfoRec *, CursorPtr);
+    Bool (*UseHWCursor) (ScreenPtr, CursorPtr);
+
+#ifdef ARGB_CURSOR
+    Bool (*UseHWCursorARGB) (ScreenPtr, CursorPtr);
+    void (*LoadCursorARGB) (ScrnInfoPtr, CursorPtr);
+    Bool (*LoadCursorARGBCheck) (ScrnInfoPtr, CursorPtr);
+#endif
+
+} xf86CursorInfoRec, *xf86CursorInfoPtr;
+
+static inline Bool
+xf86DriverHasLoadCursorImage(xf86CursorInfoPtr infoPtr)
+{
+    return infoPtr->LoadCursorImageCheck || infoPtr->LoadCursorImage;
+}
+
+static inline Bool
+xf86DriverLoadCursorImage(xf86CursorInfoPtr infoPtr, unsigned char *bits)
+{
+    if(infoPtr->LoadCursorImageCheck)
+        return infoPtr->LoadCursorImageCheck(infoPtr->pScrn, bits);
+    infoPtr->LoadCursorImage(infoPtr->pScrn, bits);
+    return TRUE;
+}
+
+static inline Bool
+xf86DriverHasLoadCursorARGB(xf86CursorInfoPtr infoPtr)
+{
+    return infoPtr->LoadCursorARGBCheck || infoPtr->LoadCursorARGB;
+}
+
+static inline Bool
+xf86DriverLoadCursorARGB(xf86CursorInfoPtr infoPtr, CursorPtr pCursor)
+{
+    if(infoPtr->LoadCursorARGBCheck)
+        return infoPtr->LoadCursorARGBCheck(infoPtr->pScrn, pCursor);
+    infoPtr->LoadCursorARGB(infoPtr->pScrn, pCursor);
+    return TRUE;
+}
+
+extern _X_EXPORT Bool xf86InitCursor(ScreenPtr pScreen,
+                                     xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT xf86CursorInfoPtr xf86CreateCursorInfoRec(void);
+extern _X_EXPORT void xf86DestroyCursorInfoRec(xf86CursorInfoPtr);
+extern _X_EXPORT void xf86ForceHWCursor(ScreenPtr pScreen, Bool on);
+
+#define HARDWARE_CURSOR_INVERT_MASK 			0x00000001
+#define HARDWARE_CURSOR_AND_SOURCE_WITH_MASK		0x00000002
+#define HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK		0x00000004
+#define HARDWARE_CURSOR_SOURCE_MASK_NOT_INTERLEAVED	0x00000008
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1	0x00000010
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8	0x00000020
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_16	0x00000040
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32	0x00000080
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64	0x00000100
+#define HARDWARE_CURSOR_TRUECOLOR_AT_8BPP		0x00000200
+#define HARDWARE_CURSOR_BIT_ORDER_MSBFIRST		0x00000400
+#define HARDWARE_CURSOR_NIBBLE_SWAPPED			0x00000800
+#define HARDWARE_CURSOR_SHOW_TRANSPARENT		0x00001000
+#define HARDWARE_CURSOR_UPDATE_UNHIDDEN			0x00002000
+#ifdef ARGB_CURSOR
+#define HARDWARE_CURSOR_ARGB				0x00004000
+#endif
+
+#endif                          /* _XF86CURSOR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Cursor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compsize.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compsize.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compsize.h	(Revision 52145)
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2011 Apple Inc.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __compsize_h__
+#define __compsize_h__
+
+extern GLint __glColorTableParameterfv_size(GLenum pname);
+extern GLint __glColorTableParameteriv_size(GLenum pname);
+extern GLint __glConvolutionParameterfv_size(GLenum pname);
+extern GLint __glConvolutionParameteriv_size(GLenum pname);
+extern GLint __glFogfv_size(GLenum pname);
+extern GLint __glFogiv_size(GLenum pname);
+extern GLint __glLightModelfv_size(GLenum pname);
+extern GLint __glLightModeliv_size(GLenum pname);
+extern GLint __glLightfv_size(GLenum pname);
+extern GLint __glLightiv_size(GLenum pname);
+extern GLint __glMaterialfv_size(GLenum pname);
+extern GLint __glMaterialiv_size(GLenum pname);
+extern GLint __glTexEnvfv_size(GLenum e);
+extern GLint __glTexEnviv_size(GLenum e);
+extern GLint __glTexGendv_size(GLenum e);
+extern GLint __glTexGenfv_size(GLenum e);
+extern GLint __glTexGeniv_size(GLenum e);
+extern GLint __glTexParameterfv_size(GLenum e);
+extern GLint __glTexParameteriv_size(GLenum e);
+
+#endif                          /* !__compsize_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compsize.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixstruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixstruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixstruct.h	(Revision 52145)
@@ -0,0 +1,193 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXSTRUCT_H
+#define DIXSTRUCT_H
+
+#include "client.h"
+#include "dix.h"
+#include "resource.h"
+#include "cursor.h"
+#include "gc.h"
+#include "pixmap.h"
+#include "privates.h"
+#include <X11/Xmd.h>
+
+/*
+ * 	direct-mapped hash table, used by resource manager to store
+ *      translation from client ids to server addresses.
+ */
+
+extern _X_EXPORT CallbackListPtr ClientStateCallback;
+
+typedef struct {
+    ClientPtr client;
+    xConnSetupPrefix *prefix;
+    xConnSetup *setup;
+} NewClientInfoRec;
+
+typedef void (*ReplySwapPtr) (ClientPtr /* pClient */ ,
+                              int /* size */ ,
+                              void * /* pbuf */ );
+
+extern _X_EXPORT void
+ReplyNotSwappd(ClientPtr /* pClient */ ,
+               int /* size */ ,
+               void * /* pbuf */ ) _X_NORETURN;
+
+typedef enum { ClientStateInitial,
+    ClientStateRunning,
+    ClientStateRetained,
+    ClientStateGone
+} ClientState;
+
+typedef struct _saveSet {
+    struct _Window *windowPtr;
+    Bool toRoot;
+    Bool map;
+} SaveSetElt;
+#define SaveSetWindow(ss)   ((ss).windowPtr)
+#define SaveSetToRoot(ss)   ((ss).toRoot)
+#define SaveSetShouldMap(ss)	    ((ss).map)
+#define SaveSetAssignWindow(ss,w)   ((ss).windowPtr = (w))
+#define SaveSetAssignToRoot(ss,tr)  ((ss).toRoot = (tr))
+#define SaveSetAssignMap(ss,m)      ((ss).map = (m))
+
+typedef struct _Client {
+    void *requestBuffer;
+    void *osPrivate;             /* for OS layer, including scheduler */
+    Mask clientAsMask;
+    short index;
+    unsigned char majorOp, minorOp;
+    unsigned int swapped:1;
+    unsigned int local:1;
+    unsigned int big_requests:1; /* supports large requests */
+    unsigned int clientGone:1;
+    unsigned int closeDownMode:2;
+    unsigned int clientState:2;
+    signed char smart_priority;
+    short noClientException;      /* this client died or needs to be killed */
+    int priority;
+    ReplySwapPtr pSwapReplyFunc;
+    XID errorValue;
+    int sequence;
+    int ignoreCount;            /* count for Attend/IgnoreClient */
+    int numSaved;
+    SaveSetElt *saveSet;
+    int (**requestVector) (ClientPtr /* pClient */ );
+    CARD32 req_len;             /* length of current request */
+    unsigned int replyBytesRemaining;
+    PrivateRec *devPrivates;
+    unsigned short xkbClientFlags;
+    unsigned short mapNotifyMask;
+    unsigned short newKeyboardNotifyMask;
+    unsigned short vMajor, vMinor;
+    KeyCode minKC, maxKC;
+
+    int smart_start_tick;
+    int smart_stop_tick;
+
+    DeviceIntPtr clientPtr;
+    ClientIdPtr clientIds;
+#if XTRANS_SEND_FDS
+    int req_fds;
+#endif
+} ClientRec;
+
+#if XTRANS_SEND_FDS
+static inline void
+SetReqFds(ClientPtr client, int req_fds) {
+    if (client->req_fds != 0 && req_fds != client->req_fds)
+        LogMessage(X_ERROR, "Mismatching number of request fds %d != %d\n", req_fds, client->req_fds);
+    client->req_fds = req_fds;
+}
+#endif
+
+/*
+ * Scheduling interface
+ */
+extern _X_EXPORT long SmartScheduleTime;
+extern _X_EXPORT long SmartScheduleInterval;
+extern _X_EXPORT long SmartScheduleSlice;
+extern _X_EXPORT long SmartScheduleMaxSlice;
+extern _X_EXPORT Bool SmartScheduleDisable;
+extern _X_EXPORT void
+SmartScheduleStartTimer(void);
+extern _X_EXPORT void
+SmartScheduleStopTimer(void);
+
+#define SMART_MAX_PRIORITY  (20)
+#define SMART_MIN_PRIORITY  (-20)
+
+extern _X_EXPORT void
+SmartScheduleInit(void);
+
+/* This prototype is used pervasively in Xext, dix */
+#define DISPATCH_PROC(func) int func(ClientPtr /* client */)
+
+typedef struct _WorkQueue {
+    struct _WorkQueue *next;
+    Bool (*function) (ClientPtr /* pClient */ ,
+                      void *    /* closure */
+        );
+    ClientPtr client;
+    void *closure;
+} WorkQueueRec;
+
+extern _X_EXPORT TimeStamp currentTime;
+
+extern _X_EXPORT int
+CompareTimeStamps(TimeStamp /*a */ ,
+                  TimeStamp /*b */ );
+
+extern _X_EXPORT TimeStamp
+ClientTimeToServerTime(CARD32 /*c */ );
+
+typedef struct _CallbackRec {
+    CallbackProcPtr proc;
+    void *data;
+    Bool deleted;
+    struct _CallbackRec *next;
+} CallbackRec, *CallbackPtr;
+
+typedef struct _CallbackList {
+    int inCallback;
+    Bool deleted;
+    int numDeleted;
+    CallbackPtr list;
+} CallbackListRec;
+
+/* proc vectors */
+
+extern _X_EXPORT int (*InitialVector[3]) (ClientPtr /*client */ );
+
+extern _X_EXPORT int (*ProcVector[256]) (ClientPtr /*client */ );
+
+extern _X_EXPORT int (*SwappedProcVector[256]) (ClientPtr /*client */ );
+
+extern _X_EXPORT ReplySwapPtr ReplySwapVector[256];
+
+extern _X_EXPORT int
+ProcBadRequest(ClientPtr /*client */ );
+
+#endif                          /* DIXSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixstruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/screenint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/screenint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/screenint.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SCREENINT_H
+#define SCREENINT_H
+
+#include "misc.h"
+
+typedef struct _PixmapFormat *PixmapFormatPtr;
+typedef struct _Visual *VisualPtr;
+typedef struct _Depth *DepthPtr;
+typedef struct _Screen *ScreenPtr;
+
+extern _X_EXPORT int AddScreen(Bool (* /*pfnInit */ )(
+                                                         ScreenPtr /*pScreen */
+                                                         ,
+                                                         int /*argc */ ,
+                                                         char ** /*argv */ ),
+                               int /*argc */ ,
+                               char ** /*argv */ );
+
+
+extern _X_EXPORT int AddGPUScreen(Bool (*pfnInit) (ScreenPtr /*pScreen */ ,
+                                                   int /*argc */ ,
+                                                   char **      /*argv */
+                                                   ),
+                                  int argc, char **argv);
+
+extern _X_EXPORT void RemoveGPUScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+AttachUnboundGPU(ScreenPtr pScreen, ScreenPtr newScreen);
+extern _X_EXPORT void
+DetachUnboundGPU(ScreenPtr unbound);
+
+extern _X_EXPORT void
+AttachOutputGPU(ScreenPtr pScreen, ScreenPtr newScreen);
+
+extern _X_EXPORT void
+DetachOutputGPU(ScreenPtr output);
+
+extern _X_EXPORT void
+AttachOffloadGPU(ScreenPtr pScreen, ScreenPtr newScreen);
+
+extern _X_EXPORT void
+DetachOffloadGPU(ScreenPtr slave);
+
+typedef struct _ColormapRec *ColormapPtr;
+
+#endif                          /* SCREENINT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/screenint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glx_extinit.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glx_extinit.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glx_extinit.h	(Revision 52145)
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 1994-2003 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is furnished to do
+ * so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-
+ * NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall not
+ * be used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from the XFree86 Project.
+ */
+
+#ifndef GLX_EXT_INIT_H
+#define GLX_EXT_INIT_H
+
+/* this is separate due to sdksyms pulling in extinit.h */
+#ifdef GLXEXT
+extern void GlxExtensionInit(void);
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glx_extinit.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/input.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/input.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/input.h	(Revision 52145)
@@ -0,0 +1,704 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+#ifndef INPUT_H
+#define INPUT_H
+
+#include "misc.h"
+#include "screenint.h"
+#include <X11/Xmd.h>
+#include <X11/Xproto.h>
+#include <stdint.h>
+#include "window.h"             /* for WindowPtr */
+#include "xkbrules.h"
+#include "events.h"
+#include "list.h"
+#include <X11/extensions/XI2.h>
+
+#define DEVICE_INIT	0
+#define DEVICE_ON	1
+#define DEVICE_OFF	2
+#define DEVICE_CLOSE	3
+#define DEVICE_ABORT	4
+
+#define POINTER_RELATIVE	(1 << 1)
+#define POINTER_ABSOLUTE	(1 << 2)
+#define POINTER_ACCELERATE	(1 << 3)
+#define POINTER_SCREEN		(1 << 4)        /* Data in screen coordinates */
+#define POINTER_NORAW		(1 << 5)        /* Don't generate RawEvents */
+#define POINTER_EMULATED	(1 << 6)        /* Event was emulated from another event */
+#define POINTER_DESKTOP		(1 << 7)        /* Data in desktop coordinates */
+
+/* GetTouchEvent flags */
+#define TOUCH_ACCEPT            (1 << 0)
+#define TOUCH_REJECT            (1 << 1)
+#define TOUCH_PENDING_END       (1 << 2)
+#define TOUCH_CLIENT_ID         (1 << 3)        /* touch ID is the client-visible id */
+#define TOUCH_REPLAYING         (1 << 4)        /* event is being replayed */
+#define TOUCH_POINTER_EMULATED  (1 << 5)        /* touch event may be pointer emulated */
+#define TOUCH_END               (1 << 6)        /* really end this touch now */
+
+/*int constants for pointer acceleration schemes*/
+#define PtrAccelNoOp            0
+#define PtrAccelPredictable     1
+#define PtrAccelLightweight     2
+#define PtrAccelDefault         PtrAccelPredictable
+
+#define MAX_VALUATORS 36
+/* Maximum number of valuators, divided by six, rounded up, to get number
+ * of events. */
+#define MAX_VALUATOR_EVENTS 6
+#define MAX_BUTTONS 256         /* completely arbitrarily chosen */
+
+#define NO_AXIS_LIMITS -1
+
+#define MAP_LENGTH	MAX_BUTTONS
+#define DOWN_LENGTH	(MAX_BUTTONS/8)      /* 256/8 => number of bytes to hold 256 bits */
+#define NullGrab ((GrabPtr)NULL)
+#define PointerRootWin ((WindowPtr)PointerRoot)
+#define NoneWin ((WindowPtr)None)
+#define NullDevice ((DevicePtr)NULL)
+
+#ifndef FollowKeyboard
+#define FollowKeyboard 		3
+#endif
+#ifndef FollowKeyboardWin
+#define FollowKeyboardWin  ((WindowPtr) FollowKeyboard)
+#endif
+#ifndef RevertToFollowKeyboard
+#define RevertToFollowKeyboard	3
+#endif
+
+enum InputLevel {
+    CORE = 1,
+    XI = 2,
+    XI2 = 3,
+};
+
+typedef unsigned long Leds;
+typedef struct _OtherClients *OtherClientsPtr;
+typedef struct _InputClients *InputClientsPtr;
+typedef struct _DeviceIntRec *DeviceIntPtr;
+typedef struct _ValuatorClassRec *ValuatorClassPtr;
+typedef struct _ClassesRec *ClassesPtr;
+typedef struct _SpriteRec *SpritePtr;
+typedef struct _TouchClassRec *TouchClassPtr;
+typedef struct _TouchPointInfo *TouchPointInfoPtr;
+typedef struct _DDXTouchPointInfo *DDXTouchPointInfoPtr;
+typedef union _GrabMask GrabMask;
+
+typedef struct _ValuatorMask ValuatorMask;
+
+/* The DIX stores incoming input events in this list */
+extern InternalEvent *InputEventList;
+
+typedef int (*DeviceProc) (DeviceIntPtr /*device */ ,
+                           int /*what */ );
+
+typedef void (*ProcessInputProc) (InternalEvent * /*event */ ,
+                                  DeviceIntPtr /*device */ );
+
+typedef Bool (*DeviceHandleProc) (DeviceIntPtr /*device */ ,
+                                  void *        /*data */
+    );
+
+typedef void (*DeviceUnwrapProc) (DeviceIntPtr /*device */ ,
+                                  DeviceHandleProc /*proc */ ,
+                                  void *        /*data */
+    );
+
+/* pointer acceleration handling */
+typedef void (*PointerAccelSchemeProc) (DeviceIntPtr /*device */ ,
+                                        ValuatorMask * /*valuators */ ,
+                                        CARD32 /*evtime */ );
+
+typedef void (*DeviceCallbackProc) (DeviceIntPtr /*pDev */ );
+
+struct _ValuatorAccelerationRec;
+typedef Bool (*PointerAccelSchemeInitProc) (DeviceIntPtr /*dev */ ,
+                                            struct _ValuatorAccelerationRec *
+                                            /*protoScheme */ );
+
+typedef struct _DeviceRec {
+    void *devicePrivate;
+    ProcessInputProc processInputProc;  /* current */
+    ProcessInputProc realInputProc;     /* deliver */
+    ProcessInputProc enqueueInputProc;  /* enqueue */
+    Bool on;                    /* used by DDX to keep state */
+} DeviceRec, *DevicePtr;
+
+typedef struct {
+    int click, bell, bell_pitch, bell_duration;
+    Bool autoRepeat;
+    unsigned char autoRepeats[32];
+    Leds leds;
+    unsigned char id;
+} KeybdCtrl;
+
+typedef struct {
+    KeySym *map;
+    KeyCode minKeyCode, maxKeyCode;
+    int mapWidth;
+} KeySymsRec, *KeySymsPtr;
+
+typedef struct {
+    int num, den, threshold;
+    unsigned char id;
+} PtrCtrl;
+
+typedef struct {
+    int resolution, min_value, max_value;
+    int integer_displayed;
+    unsigned char id;
+} IntegerCtrl;
+
+typedef struct {
+    int max_symbols, num_symbols_supported;
+    int num_symbols_displayed;
+    KeySym *symbols_supported;
+    KeySym *symbols_displayed;
+    unsigned char id;
+} StringCtrl;
+
+typedef struct {
+    int percent, pitch, duration;
+    unsigned char id;
+} BellCtrl;
+
+typedef struct {
+    Leds led_values;
+    Mask led_mask;
+    unsigned char id;
+} LedCtrl;
+
+extern _X_EXPORT KeybdCtrl defaultKeyboardControl;
+extern _X_EXPORT PtrCtrl defaultPointerControl;
+
+typedef struct _InputOption InputOption;
+typedef struct _XI2Mask XI2Mask;
+
+typedef struct _InputAttributes {
+    char *product;
+    char *vendor;
+    char *device;
+    char *pnp_id;
+    char *usb_id;
+    char **tags;                /* null-terminated */
+    uint32_t flags;
+} InputAttributes;
+
+#define ATTR_KEYBOARD (1<<0)
+#define ATTR_POINTER (1<<1)
+#define ATTR_JOYSTICK (1<<2)
+#define ATTR_TABLET (1<<3)
+#define ATTR_TOUCHPAD (1<<4)
+#define ATTR_TOUCHSCREEN (1<<5)
+
+/* Key/Button has been run through all input processing and events sent to clients. */
+#define KEY_PROCESSED 1
+#define BUTTON_PROCESSED 1
+/* Key/Button has not been fully processed, no events have been sent. */
+#define KEY_POSTED 2
+#define BUTTON_POSTED 2
+
+extern _X_EXPORT void set_key_down(DeviceIntPtr pDev, int key_code, int type);
+extern _X_EXPORT void set_key_up(DeviceIntPtr pDev, int key_code, int type);
+extern _X_EXPORT int key_is_down(DeviceIntPtr pDev, int key_code, int type);
+extern _X_EXPORT void set_button_down(DeviceIntPtr pDev, int button, int type);
+extern _X_EXPORT void set_button_up(DeviceIntPtr pDev, int button, int type);
+extern _X_EXPORT int button_is_down(DeviceIntPtr pDev, int button, int type);
+
+extern void InitCoreDevices(void);
+extern void InitXTestDevices(void);
+
+extern _X_EXPORT DeviceIntPtr AddInputDevice(ClientPtr /*client */ ,
+                                             DeviceProc /*deviceProc */ ,
+                                             Bool /*autoStart */ );
+
+extern _X_EXPORT Bool EnableDevice(DeviceIntPtr /*device */ ,
+                                   BOOL /* sendevent */ );
+
+extern _X_EXPORT Bool ActivateDevice(DeviceIntPtr /*device */ ,
+                                     BOOL /* sendevent */ );
+
+extern _X_EXPORT Bool DisableDevice(DeviceIntPtr /*device */ ,
+                                    BOOL /* sendevent */ );
+extern void DisableAllDevices(void);
+extern int InitAndStartDevices(void);
+
+extern void CloseDownDevices(void);
+extern void AbortDevices(void);
+
+extern void UndisplayDevices(void);
+
+extern _X_EXPORT int RemoveDevice(DeviceIntPtr /*dev */ ,
+                                  BOOL /* sendevent */ );
+
+extern _X_EXPORT int NumMotionEvents(void);
+
+extern _X_EXPORT int dixLookupDevice(DeviceIntPtr * /* dev */ ,
+                                     int /* id */ ,
+                                     ClientPtr /* client */ ,
+                                     Mask /* access_mode */ );
+
+extern _X_EXPORT void QueryMinMaxKeyCodes(KeyCode * /*minCode */ ,
+                                          KeyCode * /*maxCode */ );
+
+extern _X_EXPORT Bool SetKeySymsMap(KeySymsPtr /*dst */ ,
+                                    KeySymsPtr /*src */ );
+
+extern _X_EXPORT Bool InitButtonClassDeviceStruct(DeviceIntPtr /*device */ ,
+                                                  int /*numButtons */ ,
+                                                  Atom * /* labels */ ,
+                                                  CARD8 * /*map */ );
+
+extern _X_INTERNAL ValuatorClassPtr AllocValuatorClass(ValuatorClassPtr src,
+                                                       int numAxes);
+
+extern _X_EXPORT Bool InitValuatorClassDeviceStruct(DeviceIntPtr /*device */ ,
+                                                    int /*numAxes */ ,
+                                                    Atom * /* labels */ ,
+                                                    int /*numMotionEvents */ ,
+                                                    int /*mode */ );
+
+extern _X_EXPORT Bool InitPointerAccelerationScheme(DeviceIntPtr /*dev */ ,
+                                                    int /*scheme */ );
+
+extern _X_EXPORT Bool InitFocusClassDeviceStruct(DeviceIntPtr /*device */ );
+
+extern _X_EXPORT Bool InitTouchClassDeviceStruct(DeviceIntPtr /*device */ ,
+                                                 unsigned int /*max_touches */ ,
+                                                 unsigned int /*mode */ ,
+                                                 unsigned int /*numAxes */ );
+
+typedef void (*BellProcPtr) (int /*percent */ ,
+                             DeviceIntPtr /*device */ ,
+                             void */*ctrl */ ,
+                             int);
+
+typedef void (*KbdCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                KeybdCtrl * /*ctrl */ );
+
+typedef void (*PtrCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                PtrCtrl * /*ctrl */ );
+
+extern _X_EXPORT Bool InitPtrFeedbackClassDeviceStruct(DeviceIntPtr /*device */
+                                                       ,
+                                                       PtrCtrlProcPtr
+                                                       /*controlProc */ );
+
+typedef void (*StringCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                   StringCtrl * /*ctrl */ );
+
+extern _X_EXPORT Bool InitStringFeedbackClassDeviceStruct(DeviceIntPtr
+                                                          /*device */ ,
+                                                          StringCtrlProcPtr
+                                                          /*controlProc */ ,
+                                                          int /*max_symbols */ ,
+                                                          int
+                                                          /*num_symbols_supported */
+                                                          ,
+                                                          KeySym * /*symbols */
+                                                          );
+
+typedef void (*BellCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                 BellCtrl * /*ctrl */ );
+
+extern _X_EXPORT Bool InitBellFeedbackClassDeviceStruct(DeviceIntPtr /*device */
+                                                        ,
+                                                        BellProcPtr
+                                                        /*bellProc */ ,
+                                                        BellCtrlProcPtr
+                                                        /*controlProc */ );
+
+typedef void (*LedCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                LedCtrl * /*ctrl */ );
+
+extern _X_EXPORT Bool InitLedFeedbackClassDeviceStruct(DeviceIntPtr /*device */
+                                                       ,
+                                                       LedCtrlProcPtr
+                                                       /*controlProc */ );
+
+typedef void (*IntegerCtrlProcPtr) (DeviceIntPtr /*device */ ,
+                                    IntegerCtrl * /*ctrl */ );
+
+extern _X_EXPORT Bool InitIntegerFeedbackClassDeviceStruct(DeviceIntPtr
+                                                           /*device */ ,
+                                                           IntegerCtrlProcPtr
+                                                           /*controlProc */ );
+
+extern _X_EXPORT Bool InitPointerDeviceStruct(DevicePtr /*device */ ,
+                                              CARD8 * /*map */ ,
+                                              int /*numButtons */ ,
+                                              Atom * /* btn_labels */ ,
+                                              PtrCtrlProcPtr /*controlProc */ ,
+                                              int /*numMotionEvents */ ,
+                                              int /*numAxes */ ,
+                                              Atom * /* axes_labels */ );
+
+extern _X_EXPORT Bool InitKeyboardDeviceStruct(DeviceIntPtr /*device */ ,
+                                               XkbRMLVOSet * /*rmlvo */ ,
+                                               BellProcPtr /*bellProc */ ,
+                                               KbdCtrlProcPtr /*controlProc */
+                                               );
+
+extern _X_EXPORT Bool InitKeyboardDeviceStructFromString(DeviceIntPtr dev,
+							 const char *keymap,
+							 int keymap_length,
+							 BellProcPtr bell_func,
+							 KbdCtrlProcPtr ctrl_func);
+
+extern int ApplyPointerMapping(DeviceIntPtr /* pDev */ ,
+                               CARD8 * /* map */ ,
+                               int /* len */ ,
+                               ClientPtr /* client */ );
+
+extern Bool BadDeviceMap(BYTE * /*buff */ ,
+                         int /*length */ ,
+                         unsigned /*low */ ,
+                         unsigned /*high */ ,
+                         XID * /*errval */ );
+
+extern void NoteLedState(DeviceIntPtr /*keybd */ ,
+                         int /*led */ ,
+                         Bool /*on */ );
+
+extern void MaybeStopHint(DeviceIntPtr /*device */ ,
+                          ClientPtr /*client */ );
+
+extern void ProcessPointerEvent(InternalEvent * /* ev */ ,
+                                DeviceIntPtr /*mouse */ );
+
+extern void ProcessKeyboardEvent(InternalEvent * /*ev */ ,
+                                 DeviceIntPtr /*keybd */ );
+
+extern Bool LegalModifier(unsigned int /*key */ ,
+                          DeviceIntPtr /*pDev */ );
+
+extern _X_EXPORT void ProcessInputEvents(void);
+
+extern _X_EXPORT void InitInput(int /*argc */ ,
+                                char ** /*argv */ );
+extern _X_EXPORT void CloseInput(void);
+
+extern _X_EXPORT int GetMaximumEventsNum(void);
+
+extern _X_EXPORT InternalEvent *InitEventList(int num_events);
+extern _X_EXPORT void FreeEventList(InternalEvent *list, int num_events);
+
+extern void CreateClassesChangedEvent(InternalEvent *event,
+                                      DeviceIntPtr master,
+                                      DeviceIntPtr slave, int flags);
+
+extern InternalEvent *UpdateFromMaster(InternalEvent *events,
+                                       DeviceIntPtr pDev,
+                                       int type, int *num_events);
+
+extern _X_EXPORT int GetPointerEvents(InternalEvent *events,
+                                      DeviceIntPtr pDev,
+                                      int type,
+                                      int buttons,
+                                      int flags, const ValuatorMask *mask);
+
+extern _X_EXPORT void QueuePointerEvents(DeviceIntPtr pDev,
+                                         int type,
+                                         int buttons,
+                                         int flags, const ValuatorMask *mask);
+
+extern _X_EXPORT int GetKeyboardEvents(InternalEvent *events,
+                                       DeviceIntPtr pDev,
+                                       int type,
+                                       int key_code, const ValuatorMask *mask);
+
+extern _X_EXPORT void QueueKeyboardEvents(DeviceIntPtr pDev,
+                                          int type,
+                                          int key_code,
+                                          const ValuatorMask *mask);
+
+extern int GetTouchEvents(InternalEvent *events,
+                          DeviceIntPtr pDev,
+                          uint32_t ddx_touchid,
+                          uint16_t type,
+                          uint32_t flags, const ValuatorMask *mask);
+
+void QueueTouchEvents(DeviceIntPtr device,
+                      int type,
+                      uint32_t ddx_touchid,
+                      int flags, const ValuatorMask *mask);
+
+extern int GetTouchOwnershipEvents(InternalEvent *events,
+                                   DeviceIntPtr pDev,
+                                   TouchPointInfoPtr ti,
+                                   uint8_t mode, XID resource, uint32_t flags);
+
+extern void GetDixTouchEnd(InternalEvent *ievent,
+                           DeviceIntPtr dev,
+                           TouchPointInfoPtr ti,
+                           uint32_t flags);
+
+extern _X_EXPORT int GetProximityEvents(InternalEvent *events,
+                                        DeviceIntPtr pDev,
+                                        int type, const ValuatorMask *mask);
+
+extern _X_EXPORT void QueueProximityEvents(DeviceIntPtr pDev,
+                                           int type, const ValuatorMask *mask);
+
+#ifdef PANORAMIX
+_X_EXPORT
+#endif
+extern void PostSyntheticMotion(DeviceIntPtr pDev,
+                                int x, int y, int screen, unsigned long time);
+
+extern _X_EXPORT int GetMotionHistorySize(void);
+
+extern _X_EXPORT void AllocateMotionHistory(DeviceIntPtr pDev);
+
+extern _X_EXPORT int GetMotionHistory(DeviceIntPtr pDev,
+                                      xTimecoord ** buff,
+                                      unsigned long start,
+                                      unsigned long stop,
+                                      ScreenPtr pScreen, BOOL core);
+
+extern void ReleaseButtonsAndKeys(DeviceIntPtr dev);
+
+extern int AttachDevice(ClientPtr client,
+                        DeviceIntPtr slave, DeviceIntPtr master);
+
+extern _X_EXPORT DeviceIntPtr GetPairedDevice(DeviceIntPtr kbd);
+extern DeviceIntPtr GetMaster(DeviceIntPtr dev, int type);
+
+extern _X_EXPORT int AllocDevicePair(ClientPtr client,
+                                     const char *name,
+                                     DeviceIntPtr *ptr,
+                                     DeviceIntPtr *keybd,
+                                     DeviceProc ptr_proc,
+                                     DeviceProc keybd_proc, Bool master);
+extern void DeepCopyDeviceClasses(DeviceIntPtr from,
+                                  DeviceIntPtr to, DeviceChangedEvent *dce);
+
+/* Helper functions. */
+extern _X_EXPORT int generate_modkeymap(ClientPtr client, DeviceIntPtr dev,
+                                        KeyCode **modkeymap,
+                                        int *max_keys_per_mod);
+extern int change_modmap(ClientPtr client, DeviceIntPtr dev, KeyCode *map,
+                         int max_keys_per_mod);
+extern int AllocXTestDevice(ClientPtr client, const char *name,
+                            DeviceIntPtr *ptr, DeviceIntPtr *keybd,
+                            DeviceIntPtr master_ptr, DeviceIntPtr master_keybd);
+extern BOOL IsXTestDevice(DeviceIntPtr dev, DeviceIntPtr master);
+extern DeviceIntPtr GetXTestDevice(DeviceIntPtr master);
+extern void SendDevicePresenceEvent(int deviceid, int type);
+extern _X_EXPORT InputAttributes *DuplicateInputAttributes(InputAttributes *
+                                                           attrs);
+extern _X_EXPORT void FreeInputAttributes(InputAttributes * attrs);
+
+enum TouchListenerState {
+    LISTENER_AWAITING_BEGIN = 0,   /**< Waiting for a TouchBegin event */
+    LISTENER_AWAITING_OWNER,       /**< Waiting for a TouchOwnership event */
+    LISTENER_EARLY_ACCEPT,         /**< Waiting for ownership, has already
+                                        accepted */
+    LISTENER_IS_OWNER,             /**< Is the current owner, hasn't accepted */
+    LISTENER_HAS_ACCEPTED,         /**< Is the current owner, has accepted */
+    LISTENER_HAS_END,              /**< Has already received the end event */
+};
+
+enum TouchListenerType {
+    LISTENER_GRAB,
+    LISTENER_POINTER_GRAB,
+    LISTENER_REGULAR,
+    LISTENER_POINTER_REGULAR,
+};
+
+extern void TouchInitDDXTouchPoint(DeviceIntPtr dev,
+                                   DDXTouchPointInfoPtr ddxtouch);
+extern DDXTouchPointInfoPtr TouchBeginDDXTouch(DeviceIntPtr dev,
+                                               uint32_t ddx_id);
+extern void TouchEndDDXTouch(DeviceIntPtr dev, DDXTouchPointInfoPtr ti);
+extern DDXTouchPointInfoPtr TouchFindByDDXID(DeviceIntPtr dev,
+                                             uint32_t ddx_id, Bool create);
+extern Bool TouchInitTouchPoint(TouchClassPtr touch, ValuatorClassPtr v,
+                                int index);
+extern void TouchFreeTouchPoint(DeviceIntPtr dev, int index);
+extern TouchPointInfoPtr TouchBeginTouch(DeviceIntPtr dev, int sourceid,
+                                         uint32_t touchid,
+                                         Bool emulate_pointer);
+extern TouchPointInfoPtr TouchFindByClientID(DeviceIntPtr dev,
+                                             uint32_t client_id);
+extern void TouchEndTouch(DeviceIntPtr dev, TouchPointInfoPtr ti);
+extern Bool TouchEventHistoryAllocate(TouchPointInfoPtr ti);
+extern void TouchEventHistoryFree(TouchPointInfoPtr ti);
+extern void TouchEventHistoryPush(TouchPointInfoPtr ti, const DeviceEvent *ev);
+extern void TouchEventHistoryReplay(TouchPointInfoPtr ti, DeviceIntPtr dev,
+                                    XID resource);
+extern Bool TouchResourceIsOwner(TouchPointInfoPtr ti, XID resource);
+extern void TouchAddListener(TouchPointInfoPtr ti, XID resource, int resource_type,
+                             enum InputLevel level, enum TouchListenerType type,
+                             enum TouchListenerState state, WindowPtr window, GrabPtr grab);
+extern Bool TouchRemoveListener(TouchPointInfoPtr ti, XID resource);
+extern void TouchSetupListeners(DeviceIntPtr dev, TouchPointInfoPtr ti,
+                                InternalEvent *ev);
+extern Bool TouchBuildSprite(DeviceIntPtr sourcedev, TouchPointInfoPtr ti,
+                             InternalEvent *ev);
+extern Bool TouchBuildDependentSpriteTrace(DeviceIntPtr dev, SpritePtr sprite);
+extern int TouchConvertToPointerEvent(const InternalEvent *ev,
+                                      InternalEvent *motion,
+                                      InternalEvent *button);
+extern int TouchGetPointerEventType(const InternalEvent *ev);
+extern void TouchRemovePointerGrab(DeviceIntPtr dev);
+extern void TouchListenerGone(XID resource);
+extern int TouchListenerAcceptReject(DeviceIntPtr dev, TouchPointInfoPtr ti,
+                                     int listener, int mode);
+extern int TouchAcceptReject(ClientPtr client, DeviceIntPtr dev, int mode,
+                             uint32_t touchid, Window grab_window, XID *error);
+extern void TouchEndPhysicallyActiveTouches(DeviceIntPtr dev);
+extern void TouchDeliverDeviceClassesChangedEvent(TouchPointInfoPtr ti,
+                                                  Time time, XID resource);
+extern void TouchEmitTouchEnd(DeviceIntPtr dev, TouchPointInfoPtr ti, int flags, XID resource);
+extern void TouchAcceptAndEnd(DeviceIntPtr dev, int touchid);
+
+/* misc event helpers */
+extern Mask GetEventMask(DeviceIntPtr dev, xEvent *ev, InputClientsPtr clients);
+extern Mask GetEventFilter(DeviceIntPtr dev, xEvent *event);
+extern Bool WindowXI2MaskIsset(DeviceIntPtr dev, WindowPtr win, xEvent *ev);
+extern int GetXI2MaskByte(XI2Mask *mask, DeviceIntPtr dev, int event_type);
+void FixUpEventFromWindow(SpritePtr pSprite,
+                          xEvent *xE,
+                          WindowPtr pWin, Window child, Bool calcChild);
+extern Bool PointInBorderSize(WindowPtr pWin, int x, int y);
+extern WindowPtr XYToWindow(SpritePtr pSprite, int x, int y);
+extern int EventIsDeliverable(DeviceIntPtr dev, int evtype, WindowPtr win);
+extern Bool ActivatePassiveGrab(DeviceIntPtr dev, GrabPtr grab,
+                                InternalEvent *ev, InternalEvent *real_event);
+/**
+ * Masks specifying the type of event to deliver for an InternalEvent; used
+ * by EventIsDeliverable.
+ * @defgroup EventIsDeliverable return flags
+ * @{
+ */
+#define EVENT_XI1_MASK                (1 << 0) /**< XI1.x event */
+#define EVENT_CORE_MASK               (1 << 1) /**< Core event */
+#define EVENT_DONT_PROPAGATE_MASK     (1 << 2) /**< DontPropagate mask set */
+#define EVENT_XI2_MASK                (1 << 3) /**< XI2 mask set on window */
+/* @} */
+
+enum EventDeliveryState {
+    EVENT_DELIVERED,     /**< Event has been delivered to a client  */
+    EVENT_NOT_DELIVERED, /**< Event was not delivered to any client */
+    EVENT_SKIP,          /**< Event can be discarded by the caller  */
+    EVENT_REJECTED,      /**< Event was rejected for delivery to the client */
+};
+
+/* Implemented by the DDX. */
+extern _X_EXPORT int NewInputDeviceRequest(InputOption *options,
+                                           InputAttributes * attrs,
+                                           DeviceIntPtr *dev);
+extern _X_EXPORT void DeleteInputDeviceRequest(DeviceIntPtr dev);
+
+extern _X_EXPORT void DDXRingBell(int volume, int pitch, int duration);
+
+#define VALUATOR_MODE_ALL_AXES -1
+extern _X_HIDDEN int valuator_get_mode(DeviceIntPtr dev, int axis);
+extern _X_HIDDEN void valuator_set_mode(DeviceIntPtr dev, int axis, int mode);
+
+/* Set to TRUE by default - os/utils.c sets it to FALSE on user request,
+   xfixes/cursor.c uses it to determine if the cursor is enabled */
+extern Bool EnableCursor;
+
+/* Set to FALSE by default - ChangeWindowAttributes sets it to TRUE on
+ * CWCursor, xfixes/cursor.c uses it to determine if the cursor is enabled
+ */
+extern Bool CursorVisible;
+
+extern _X_EXPORT ValuatorMask *valuator_mask_new(int num_valuators);
+extern _X_EXPORT void valuator_mask_free(ValuatorMask **mask);
+extern _X_EXPORT void valuator_mask_set_range(ValuatorMask *mask,
+                                              int first_valuator,
+                                              int num_valuators,
+                                              const int *valuators);
+extern _X_EXPORT void valuator_mask_set(ValuatorMask *mask, int valuator,
+                                        int data);
+extern _X_EXPORT void valuator_mask_set_double(ValuatorMask *mask, int valuator,
+                                               double data);
+extern _X_EXPORT void valuator_mask_zero(ValuatorMask *mask);
+extern _X_EXPORT int valuator_mask_size(const ValuatorMask *mask);
+extern _X_EXPORT int valuator_mask_isset(const ValuatorMask *mask, int bit);
+extern _X_EXPORT void valuator_mask_unset(ValuatorMask *mask, int bit);
+extern _X_EXPORT int valuator_mask_num_valuators(const ValuatorMask *mask);
+extern _X_EXPORT void valuator_mask_copy(ValuatorMask *dest,
+                                         const ValuatorMask *src);
+extern _X_EXPORT int valuator_mask_get(const ValuatorMask *mask, int valnum);
+extern _X_EXPORT double valuator_mask_get_double(const ValuatorMask *mask,
+                                                 int valnum);
+extern _X_EXPORT Bool valuator_mask_fetch(const ValuatorMask *mask,
+                                          int valnum, int *val);
+extern _X_EXPORT Bool valuator_mask_fetch_double(const ValuatorMask *mask,
+                                                 int valnum, double *val);
+
+/* InputOption handling interface */
+extern _X_EXPORT InputOption *input_option_new(InputOption *list,
+                                               const char *key,
+                                               const char *value);
+extern _X_EXPORT void input_option_free_list(InputOption **opt);
+extern _X_EXPORT InputOption *input_option_free_element(InputOption *opt,
+                                                        const char *key);
+extern _X_EXPORT InputOption *input_option_find(InputOption *list,
+                                                const char *key);
+extern _X_EXPORT const char *input_option_get_key(const InputOption *opt);
+extern _X_EXPORT const char *input_option_get_value(const InputOption *opt);
+extern _X_EXPORT void input_option_set_key(InputOption *opt, const char *key);
+extern _X_EXPORT void input_option_set_value(InputOption *opt,
+                                             const char *value);
+
+extern _X_HIDDEN Bool point_on_screen(ScreenPtr pScreen, int x, int y);
+extern _X_HIDDEN void update_desktop_dimensions(void);
+
+extern _X_HIDDEN void input_constrain_cursor(DeviceIntPtr pDev, ScreenPtr screen,
+                                             int current_x, int current_y,
+                                             int dest_x, int dest_y,
+                                             int *out_x, int *out_y,
+                                             int *nevents, InternalEvent* events);
+
+#endif                          /* INPUT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/input.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Module.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Module.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Module.h	(Revision 52145)
@@ -0,0 +1,199 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains the parts of the loader interface that are visible
+ * to modules.  This is the only loader-related header that modules should
+ * include.
+ *
+ * It should include a bare minimum of other headers.
+ *
+ * Longer term, the module/loader code should probably live directly under
+ * Xserver/.
+ *
+ * XXX This file arguably belongs in xfree86/loader/.
+ */
+
+#ifndef _XF86MODULE_H
+#define _XF86MODULE_H
+
+#include "misc.h"
+#include "extension.h"
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+typedef enum {
+    LD_RESOLV_IFDONE = 0,       /* only check if no more
+                                   delays pending */
+    LD_RESOLV_NOW = 1,          /* finish one delay step */
+    LD_RESOLV_FORCE = 2         /* force checking... */
+} LoaderResolveOptions;
+
+#define DEFAULT_LIST ((char *)-1)
+
+/* Built-in ABI classes.  These definitions must not be changed. */
+#define ABI_CLASS_NONE		NULL
+#define ABI_CLASS_ANSIC		"X.Org ANSI C Emulation"
+#define ABI_CLASS_VIDEODRV	"X.Org Video Driver"
+#define ABI_CLASS_XINPUT	"X.Org XInput driver"
+#define ABI_CLASS_EXTENSION	"X.Org Server Extension"
+#define ABI_CLASS_FONT		"X.Org Font Renderer"
+
+#define ABI_MINOR_MASK		0x0000FFFF
+#define ABI_MAJOR_MASK		0xFFFF0000
+#define GET_ABI_MINOR(v)	((v) & ABI_MINOR_MASK)
+#define GET_ABI_MAJOR(v)	(((v) & ABI_MAJOR_MASK) >> 16)
+#define SET_ABI_VERSION(maj, min) \
+		((((maj) << 16) & ABI_MAJOR_MASK) | ((min) & ABI_MINOR_MASK))
+
+/*
+ * ABI versions.  Each version has a major and minor revision.  Modules
+ * using lower minor revisions must work with servers of a higher minor
+ * revision.  There is no compatibility between different major revisions.
+ * Whenever the ABI_ANSIC_VERSION is changed, the others must also be
+ * changed.  The minor revision mask is 0x0000FFFF and the major revision
+ * mask is 0xFFFF0000.
+ */
+#define ABI_ANSIC_VERSION	SET_ABI_VERSION(0, 4)
+#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(18, 0)
+#define ABI_XINPUT_VERSION	SET_ABI_VERSION(21, 0)
+#define ABI_EXTENSION_VERSION	SET_ABI_VERSION(8, 0)
+#define ABI_FONT_VERSION	SET_ABI_VERSION(0, 6)
+
+#define MODINFOSTRING1	0xef23fdc5
+#define MODINFOSTRING2	0x10dc023a
+
+#ifndef MODULEVENDORSTRING
+#define MODULEVENDORSTRING	"X.Org Foundation"
+#endif
+
+/* Error return codes for errmaj.  New codes must only be added at the end. */
+typedef enum {
+    LDR_NOERROR = 0,
+    LDR_NOMEM,                  /* memory allocation failed */
+    LDR_NOENT,                  /* Module file does not exist */
+    LDR_NOSUBENT,               /* pre-requsite file to be sub-loaded does not exist */
+    LDR_NOSPACE,                /* internal module array full */
+    LDR_NOMODOPEN,              /* module file could not be opened (check errmin) */
+    LDR_UNKTYPE,                /* file is not a recognized module type */
+    LDR_NOLOAD,                 /* type specific loader failed */
+    LDR_ONCEONLY,               /* Module should only be loaded once (not an error) */
+    LDR_NOPORTOPEN,             /* could not open port (check errmin) */
+    LDR_NOHARDWARE,             /* could not query/initialize the hardware device */
+    LDR_MISMATCH,               /* the module didn't match the spec'd requirments */
+    LDR_BADUSAGE,               /* LoadModule is called with bad arguments */
+    LDR_INVALID,                /* The module doesn't have a valid ModuleData object */
+    LDR_BADOS,                  /* The module doesn't support the OS */
+    LDR_MODSPECIFIC             /* A module-specific error in the SetupProc */
+} LoaderErrorCode;
+
+/*
+ * Some common module classes.  The moduleclass can be used to identify
+ * that modules loaded are of the correct type.  This is a finer
+ * classification than the ABI classes even though the default set of
+ * classes have the same names.  For example, not all modules that require
+ * the video driver ABI are themselves video drivers.
+ */
+#define MOD_CLASS_NONE		NULL
+#define MOD_CLASS_VIDEODRV	"X.Org Video Driver"
+#define MOD_CLASS_XINPUT	"X.Org XInput Driver"
+#define MOD_CLASS_FONT		"X.Org Font Renderer"
+#define MOD_CLASS_EXTENSION	"X.Org Server Extension"
+
+/* This structure is expected to be returned by the initfunc */
+typedef struct {
+    const char *modname;        /* name of module, e.g. "foo" */
+    const char *vendor;         /* vendor specific string */
+    CARD32 _modinfo1_;          /* constant MODINFOSTRING1/2 to find */
+    CARD32 _modinfo2_;          /* infoarea with a binary editor or sign tool */
+    CARD32 xf86version;         /* contains XF86_VERSION_CURRENT */
+    CARD8 majorversion;         /* module-specific major version */
+    CARD8 minorversion;         /* module-specific minor version */
+    CARD16 patchlevel;          /* module-specific patch level */
+    const char *abiclass;       /* ABI class that the module uses */
+    CARD32 abiversion;          /* ABI version */
+    const char *moduleclass;    /* module class description */
+    CARD32 checksum[4];         /* contains a digital signature of the */
+    /* version info structure */
+} XF86ModuleVersionInfo;
+
+/*
+ * This structure can be used to callers of LoadModule and LoadSubModule to
+ * specify version and/or ABI requirements.
+ */
+typedef struct {
+    CARD8 majorversion;         /* module-specific major version */
+    CARD8 minorversion;         /* moudle-specific minor version */
+    CARD16 patchlevel;          /* module-specific patch level */
+    const char *abiclass;       /* ABI class that the module uses */
+    CARD32 abiversion;          /* ABI version */
+    const char *moduleclass;    /* module class */
+} XF86ModReqInfo;
+
+/* values to indicate unspecified fields in XF86ModReqInfo. */
+#define MAJOR_UNSPEC		0xFF
+#define MINOR_UNSPEC		0xFF
+#define PATCH_UNSPEC		0xFFFF
+#define ABI_VERS_UNSPEC		0xFFFFFFFF
+
+#define MODULE_VERSION_NUMERIC(maj, min, patch) \
+	((((maj) & 0xFF) << 24) | (((min) & 0xFF) << 16) | (patch & 0xFFFF))
+#define GET_MODULE_MAJOR_VERSION(vers)	(((vers) >> 24) & 0xFF)
+#define GET_MODULE_MINOR_VERSION(vers)	(((vers) >> 16) & 0xFF)
+#define GET_MODULE_PATCHLEVEL(vers)	((vers) & 0xFFFF)
+
+#define INITARGS void
+
+/* Prototypes for Loader functions that are exported to modules */
+extern _X_EXPORT void *LoadSubModule(void *, const char *, const char **,
+                                       const char **, void *,
+                                       const XF86ModReqInfo *, int *, int *);
+extern _X_EXPORT void UnloadSubModule(void *);
+extern _X_EXPORT void UnloadModule(void *);
+extern _X_EXPORT void *LoaderSymbol(const char *);
+extern _X_EXPORT const char **LoaderListDirs(const char **, const char **);
+extern _X_EXPORT void LoaderFreeDirList(char **);
+extern _X_EXPORT void LoaderErrorMsg(const char *, const char *, int, int);
+extern _X_EXPORT void LoaderGetOS(const char **name, int *major, int *minor,
+                                  int *teeny);
+extern _X_EXPORT Bool LoaderShouldIgnoreABI(void);
+extern _X_EXPORT int LoaderGetABIVersion(const char *abiclass);
+
+typedef void *(*ModuleSetupProc) (void *, void *, int *, int *);
+typedef void (*ModuleTearDownProc) (void *);
+
+#define MODULESETUPPROTO(func) void *func(void *, void *, int*, int*)
+#define MODULETEARDOWNPROTO(func) void func(void *)
+
+typedef struct {
+    XF86ModuleVersionInfo *vers;
+    ModuleSetupProc setup;
+    ModuleTearDownProc teardown;
+} XF86ModuleData;
+
+#endif                          /* _XF86STR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Module.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgc.h	(Revision 52145)
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for GC support.  \see dmxgc.c */
+
+#ifndef DMXGC_H
+#define DMXGC_H
+
+#include "gcstruct.h"
+
+/** GC private area. */
+typedef struct _dmxGCPriv {
+    GCOps *ops;
+    GCFuncs *funcs;
+    XlibGC gc;
+    Bool msc;
+} dmxGCPrivRec, *dmxGCPrivPtr;
+
+extern Bool dmxInitGC(ScreenPtr pScreen);
+
+extern Bool dmxCreateGC(GCPtr pGC);
+extern void dmxValidateGC(GCPtr pGC, unsigned long changes,
+                          DrawablePtr pDrawable);
+extern void dmxChangeGC(GCPtr pGC, unsigned long mask);
+extern void dmxCopyGC(GCPtr pGCSrc, unsigned long changes, GCPtr pGCDst);
+extern void dmxDestroyGC(GCPtr pGC);
+extern void dmxChangeClip(GCPtr pGC, int type, void *pvalue, int nrects);
+extern void dmxDestroyClip(GCPtr pGC);
+extern void dmxCopyClip(GCPtr pGCDst, GCPtr pGCSrc);
+
+extern void dmxBECreateGC(ScreenPtr pScreen, GCPtr pGC);
+extern Bool dmxBEFreeGC(GCPtr pGC);
+
+/** Get private. */
+#define DMX_GET_GC_PRIV(_pGC)						\
+    (dmxGCPrivPtr)dixLookupPrivate(&(_pGC)->devPrivates, dmxGCPrivateKey)
+
+#define DMX_GC_FUNC_PROLOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr _pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_UNWRAP(funcs, _pGCPriv, (_pGC));				\
+    if (_pGCPriv->ops)							\
+	DMX_UNWRAP(ops, _pGCPriv, (_pGC));				\
+} while (0)
+
+#define DMX_GC_FUNC_EPILOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr _pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_WRAP(funcs, &dmxGCFuncs, _pGCPriv, (_pGC));			\
+    if (_pGCPriv->ops)							\
+	DMX_WRAP(ops, &dmxGCOps, _pGCPriv, (_pGC));			\
+} while (0)
+
+#endif                          /* DMXGC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ps2.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ps2.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ps2.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux PS/2 mouse driver.  \see lnx-ps2.c */
+
+#ifndef _LNX_PS2_H_
+#define _LNX_PS2_H_
+
+extern void *ps2LinuxCreatePrivate(DeviceIntPtr pMouse);
+extern void ps2LinuxDestroyPrivate(void *priv);
+extern void ps2LinuxRead(DevicePtr pDev,
+                         dmxMotionProcPtr motion,
+                         dmxEnqueueProcPtr enqueue,
+                         dmxCheckSpecialProcPtr checkspecial,
+                         DMXBlockType block);
+extern void ps2LinuxInit(DevicePtr pDev);
+extern void ps2LinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int ps2LinuxOn(DevicePtr pDev);
+extern void ps2LinuxOff(DevicePtr pDev);
+extern void ps2LinuxCtrl(DevicePtr pDev, PtrCtrl * ctrl);
+extern void ps2LinuxVTPreSwitch(void *p);
+extern void ps2LinuxVTPostSwitch(void *p);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-ps2.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closedev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closedev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closedev.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CLOSEDEV_H
+#define CLOSEDEV_H 1
+
+int SProcXCloseDevice(ClientPtr /* client */
+    );
+
+int ProcXCloseDevice(ClientPtr  /* client */
+    );
+
+#endif                          /* CLOSEDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closedev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgdctl.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgdctl.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgdctl.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGDCTL_H
+#define CHGDCTL_H 1
+
+int SProcXChangeDeviceControl(ClientPtr /* client */
+    );
+
+int ProcXChangeDeviceControl(ClientPtr  /* client */
+    );
+
+void SRepXChangeDeviceControl(ClientPtr /* client */ ,
+                              int /* size */ ,
+                              xChangeDeviceControlReply *       /* rep */
+    );
+
+#endif                          /* CHGDCTL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgdctl.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xibarriers.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xibarriers.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xibarriers.h	(Revision 52145)
@@ -0,0 +1,48 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XIBARRIERS_H_
+#define _XIBARRIERS_H_
+
+#include "resource.h"
+
+extern _X_EXPORT RESTYPE PointerBarrierType;
+
+struct PointerBarrier {
+    INT16 x1, x2, y1, y2;
+    CARD32 directions;
+};
+
+int
+barrier_get_direction(int, int, int, int);
+BOOL
+barrier_is_blocking(const struct PointerBarrier *, int, int, int, int,
+                        double *);
+BOOL
+barrier_is_blocking_direction(const struct PointerBarrier *, int);
+void
+barrier_clamp_to_barrier(struct PointerBarrier *barrier, int dir, int *x,
+                             int *y);
+
+#include <xfixesint.h>
+
+int
+XICreatePointerBarrier(ClientPtr client,
+                       xXFixesCreatePointerBarrierReq * stuff);
+
+int
+XIDestroyPointerBarrier(ClientPtr client,
+                        xXFixesDestroyPointerBarrierReq * stuff);
+
+Bool XIBarrierInit(void);
+void XIBarrierReset(void);
+
+int SProcXIBarrierReleasePointer(ClientPtr client);
+int ProcXIBarrierReleasePointer(ClientPtr client);
+
+void XIBarrierNewMasterDevice(ClientPtr client, int deviceid);
+void XIBarrierRemoveMasterDevice(ClientPtr client, int deviceid);
+
+#endif /* _XIBARRIERS_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xibarriers.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damageextint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damageextint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damageextint.h	(Revision 52145)
@@ -0,0 +1,73 @@
+/*
+ * Copyright ¬© 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGEEXTINT_H_
+#define _DAMAGEEXTINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/damageproto.h>
+#include "windowstr.h"
+#include "selection.h"
+#include "scrnintstr.h"
+#include "damage.h"
+#include "xfixes.h"
+
+typedef struct _DamageClient {
+    CARD32 major_version;
+    CARD32 minor_version;
+    int critical;
+} DamageClientRec, *DamageClientPtr;
+
+#define GetDamageClient(pClient) ((DamageClientPtr)dixLookupPrivate(&(pClient)->devPrivates, DamageClientPrivateKey))
+
+typedef struct _DamageExt {
+    DamagePtr pDamage;
+    DrawablePtr pDrawable;
+    DamageReportLevel level;
+    ClientPtr pClient;
+    XID id;
+    XID drawable;
+} DamageExtRec, *DamageExtPtr;
+
+#define VERIFY_DAMAGEEXT(pDamageExt, rid, client, mode) { \
+    int rc = dixLookupResourceByType((void **)&(pDamageExt), rid, \
+                                     DamageExtType, client, mode); \
+    if (rc != Success) \
+        return rc; \
+}
+
+void
+ DamageExtSetCritical(ClientPtr pClient, Bool critical);
+
+void PanoramiXDamageInit(void);
+void PanoramiXDamageReset(void);
+
+#endif                          /* _DAMAGEEXTINT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damageextint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mispans.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mispans.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mispans.h	(Revision 52145)
@@ -0,0 +1,87 @@
+/***********************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISPANS_H
+#define MISPANS_H
+
+typedef struct {
+    int count;                  /* number of spans                  */
+    DDXPointPtr points;         /* pointer to list of start points  */
+    int *widths;                /* pointer to list of widths        */
+} Spans;
+
+typedef struct {
+    int size;                   /* Total number of *Spans allocated     */
+    int count;                  /* Number of *Spans actually in group   */
+    Spans *group;               /* List of Spans                        */
+    int ymin, ymax;             /* Min, max y values encountered        */
+} SpanGroup;
+
+/* Initialize SpanGroup.  MUST BE DONE before use. */
+extern _X_EXPORT void miInitSpanGroup(SpanGroup *       /*spanGroup */
+    );
+
+/* Add a Spans to a SpanGroup. The spans MUST BE in y-sorted order */
+extern _X_EXPORT void miAppendSpans(SpanGroup * /*spanGroup */ ,
+                                    SpanGroup * /*otherGroup */ ,
+                                    Spans *     /*spans */
+    );
+
+/* Paint a span group, insuring that each pixel is painted at most once */
+extern _X_EXPORT void miFillUniqueSpanGroup(DrawablePtr /*pDraw */ ,
+                                            GCPtr /*pGC */ ,
+                                            SpanGroup * /*spanGroup */
+    );
+
+/* Free up data in a span group.  MUST BE DONE or you'll suffer memory leaks */
+extern _X_EXPORT void miFreeSpanGroup(SpanGroup *       /*spanGroup */
+    );
+
+/* Rops which must use span groups */
+#define miSpansCarefulRop(rop)	(((rop) & 0xc) == 0x8 || ((rop) & 0x3) == 0x2)
+#define miSpansEasyRop(rop)	(!miSpansCarefulRop(rop))
+
+#endif                          /* MISPANS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mispans.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mistruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mistruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mistruct.h	(Revision 52145)
@@ -0,0 +1,62 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISTRUCT_H
+#define MISTRUCT_H
+
+#include "mi.h"
+#include "regionstr.h"
+
+/* information about dashes */
+typedef struct _miDash {
+    DDXPointRec pt;
+    int e1, e2;                 /* keep these, so we don't have to do it again */
+    int e;                      /* bresenham error term for this point on line */
+    int which;
+    int newLine;                /* 0 if part of same original line as previous dash */
+} miDashRec;
+
+#endif                          /* MISTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mistruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Canvas.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Canvas.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Canvas.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+Copyright 2002 Red Hat Inc., Durham, North Carolina.
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ * This file was originally taken from xc/lib/Xaw/Template.h
+ */
+
+#ifndef _Canvas_h
+#define _Canvas_h
+
+#include <X11/Intrinsic.h>
+
+#define XtNcanvasExposeCallback "canvasExposeCallback"
+#define XtCcanvasExposeCallback "CanvasExposeCallback"
+#define XtNcanvasResizeCallback "canvasResizeCallback"
+#define XtCcanvasResizeCallback "CanvasResizeCallback"
+
+typedef struct _CanvasClassRec *CanvasWidgetClass;
+typedef struct _CanvasRec *CanvasWidget;
+extern WidgetClass canvasWidgetClass;
+
+typedef struct _CanvasExposeDataRec {
+    Widget w;
+    XEvent *event;
+    Region region;
+} CanvasExposeDataRec, *CanvasExposeDataPtr;
+
+#endif                          /* _Canvas_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Canvas.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbstr.h	(Revision 52145)
@@ -0,0 +1,640 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBSTR_H_
+#define	_XKBSTR_H_
+
+#include <X11/extensions/XKB.h>
+
+#define	XkbCharToInt(v) ((int) ((v) & 0x80 ? ((v) | (~0xff)) : ((v) & 0x7f)))
+#define	XkbIntTo2Chars(i, h, l) ((h) = (i >> 8) & 0xff, (l) = (i) & 0xff)
+
+#if defined(WORD64) && defined(UNSIGNEDBITFIELDS)
+#define	Xkb2CharsToInt(h, l) ((int) ((h) & 0x80 ? \
+                              (((h) << 8) | (l) | (~0xffff)) : \
+                              (((h) << 8) | (l) & 0x7fff))
+#else
+#define	Xkb2CharsToInt(h,l)	((short)(((h)<<8)|(l)))
+#endif
+
+        /*
+         * Common data structures and access macros
+         */
+
+typedef struct _XkbStateRec {
+    unsigned char group;        /* base + latched + locked */
+    /* FIXME: Why are base + latched short and not char?? */
+    unsigned short base_group;  /* physically ... down? */
+    unsigned short latched_group;
+    unsigned char locked_group;
+
+    unsigned char mods;         /* base + latched + locked */
+    unsigned char base_mods;    /* physically down */
+    unsigned char latched_mods;
+    unsigned char locked_mods;
+
+    unsigned char compat_state; /* mods + group for core state */
+
+    /* grab mods = all depressed and latched mods, _not_ locked mods */
+    unsigned char grab_mods;    /* grab mods minus internal mods */
+    unsigned char compat_grab_mods;     /* grab mods + group for core state,
+                                           but not locked groups if
+                                           IgnoreGroupLocks set */
+
+    /* effective mods = all mods (depressed, latched, locked) */
+    unsigned char lookup_mods;  /* effective mods minus internal mods */
+    unsigned char compat_lookup_mods;   /* effective mods + group */
+
+    unsigned short ptr_buttons; /* core pointer buttons */
+} XkbStateRec, *XkbStatePtr;
+
+#define	XkbStateFieldFromRec(s)	XkbBuildCoreState((s)->lookup_mods,(s)->group)
+#define	XkbGrabStateFromRec(s)	XkbBuildCoreState((s)->grab_mods,(s)->group)
+
+typedef struct _XkbMods {
+    unsigned char mask;         /* effective mods */
+    unsigned char real_mods;
+    unsigned short vmods;
+} XkbModsRec, *XkbModsPtr;
+
+typedef struct _XkbKTMapEntry {
+    Bool active;
+    unsigned char level;
+    XkbModsRec mods;
+} XkbKTMapEntryRec, *XkbKTMapEntryPtr;
+
+typedef struct _XkbKeyType {
+    XkbModsRec mods;
+    unsigned char num_levels;
+    unsigned char map_count;
+    XkbKTMapEntryPtr map;
+    XkbModsPtr preserve;
+    Atom name;
+    Atom *level_names;
+} XkbKeyTypeRec, *XkbKeyTypePtr;
+
+#define	XkbNumGroups(g)			((g)&0x0f)
+#define	XkbOutOfRangeGroupInfo(g)	((g)&0xf0)
+#define	XkbOutOfRangeGroupAction(g)	((g)&0xc0)
+#define	XkbOutOfRangeGroupNumber(g)	(((g)&0x30)>>4)
+#define	XkbSetGroupInfo(g, w, n) (((w) & 0xc0) | (((n) & 3) << 4) | \
+                                  ((g) & 0x0f))
+#define	XkbSetNumGroups(g,n)	(((g)&0xf0)|((n)&0x0f))
+
+        /*
+         * Structures and access macros used primarily by the server
+         */
+
+typedef struct _XkbBehavior {
+    unsigned char type;
+    unsigned char data;
+} XkbBehavior;
+
+#define	XkbAnyActionDataSize 7
+typedef struct _XkbAnyAction {
+    unsigned char type;
+    unsigned char data[XkbAnyActionDataSize];
+} XkbAnyAction;
+
+typedef struct _XkbModAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char mask;
+    unsigned char real_mods;
+    /* FIXME: Make this an int. */
+    unsigned char vmods1;
+    unsigned char vmods2;
+} XkbModAction;
+
+#define	XkbModActionVMods(a) ((short) (((a)->vmods1 << 8) | (a)->vmods2))
+#define	XkbSetModActionVMods(a,v) \
+	((a)->vmods1 = (((v) >> 8) & 0xff), \
+         (a)->vmods2 = (v) & 0xff)
+
+typedef struct _XkbGroupAction {
+    unsigned char type;
+    unsigned char flags;
+    /* FIXME: Make this an int. */
+    char group_XXX;
+} XkbGroupAction;
+
+#define	XkbSAGroup(a)		(XkbCharToInt((a)->group_XXX))
+#define	XkbSASetGroup(a,g)	((a)->group_XXX=(g))
+
+typedef struct _XkbISOAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char mask;
+    unsigned char real_mods;
+    /* FIXME: Make this an int. */
+    char group_XXX;
+    unsigned char affect;
+    unsigned char vmods1;
+    unsigned char vmods2;
+} XkbISOAction;
+
+typedef struct _XkbPtrAction {
+    unsigned char type;
+    unsigned char flags;
+    /* FIXME: Make this an int. */
+    unsigned char high_XXX;
+    unsigned char low_XXX;
+    unsigned char high_YYY;
+    unsigned char low_YYY;
+} XkbPtrAction;
+
+#define	XkbPtrActionX(a)      (Xkb2CharsToInt((a)->high_XXX,(a)->low_XXX))
+#define	XkbPtrActionY(a)      (Xkb2CharsToInt((a)->high_YYY,(a)->low_YYY))
+#define	XkbSetPtrActionX(a,x) (XkbIntTo2Chars(x,(a)->high_XXX,(a)->low_XXX))
+#define	XkbSetPtrActionY(a,y) (XkbIntTo2Chars(y,(a)->high_YYY,(a)->low_YYY))
+
+typedef struct _XkbPtrBtnAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char count;
+    unsigned char button;
+} XkbPtrBtnAction;
+
+typedef struct _XkbPtrDfltAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char affect;
+    char valueXXX;
+} XkbPtrDfltAction;
+
+#define	XkbSAPtrDfltValue(a)		(XkbCharToInt((a)->valueXXX))
+#define	XkbSASetPtrDfltValue(a, c) ((a)->valueXXX = (c) & 0xff)
+
+typedef struct _XkbSwitchScreenAction {
+    unsigned char type;
+    unsigned char flags;
+    char screenXXX;
+} XkbSwitchScreenAction;
+
+#define	XkbSAScreen(a)			(XkbCharToInt((a)->screenXXX))
+#define	XkbSASetScreen(a, s) ((a)->screenXXX = (s) & 0xff)
+
+typedef struct _XkbCtrlsAction {
+    unsigned char type;
+    unsigned char flags;
+    /* FIXME: Make this an int. */
+    unsigned char ctrls3;
+    unsigned char ctrls2;
+    unsigned char ctrls1;
+    unsigned char ctrls0;
+} XkbCtrlsAction;
+
+#define	XkbActionSetCtrls(a, c) ((a)->ctrls3 = ((c) >> 24) & 0xff, \
+                                 (a)->ctrls2 = ((c) >> 16) & 0xff, \
+                                 (a)->ctrls1 = ((c) >> 8) & 0xff, \
+                                 (a)->ctrls0 = (c) & 0xff)
+#define	XkbActionCtrls(a) ((((unsigned int)(a)->ctrls3)<<24)|\
+			   (((unsigned int)(a)->ctrls2)<<16)|\
+			   (((unsigned int)(a)->ctrls1)<<8)|\
+                           ((unsigned int) (a)->ctrls0))
+
+typedef struct _XkbMessageAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char message[6];
+} XkbMessageAction;
+
+typedef struct _XkbRedirectKeyAction {
+    unsigned char type;
+    unsigned char new_key;
+    unsigned char mods_mask;
+    unsigned char mods;
+    /* FIXME: Make this an int. */
+    unsigned char vmods_mask0;
+    unsigned char vmods_mask1;
+    unsigned char vmods0;
+    unsigned char vmods1;
+} XkbRedirectKeyAction;
+
+#define	XkbSARedirectVMods(a)		((((unsigned int)(a)->vmods1)<<8)|\
+					((unsigned int)(a)->vmods0))
+/* FIXME: This is blatantly not setting vmods.   Yeesh. */
+#define	XkbSARedirectSetVMods(a,m)	(((a)->vmods_mask1=(((m)>>8)&0xff)),\
+					 ((a)->vmods_mask0=((m)&0xff)))
+#define	XkbSARedirectVModsMask(a)	((((unsigned int)(a)->vmods_mask1)<<8)|\
+					((unsigned int)(a)->vmods_mask0))
+#define	XkbSARedirectSetVModsMask(a,m)	(((a)->vmods_mask1=(((m)>>8)&0xff)),\
+					 ((a)->vmods_mask0=((m)&0xff)))
+
+typedef struct _XkbDeviceBtnAction {
+    unsigned char type;
+    unsigned char flags;
+    unsigned char count;
+    unsigned char button;
+    unsigned char device;
+} XkbDeviceBtnAction;
+
+typedef struct _XkbDeviceValuatorAction {
+    unsigned char type;
+    unsigned char device;
+    unsigned char v1_what;
+    unsigned char v1_ndx;
+    unsigned char v1_value;
+    unsigned char v2_what;
+    unsigned char v2_ndx;
+    unsigned char v2_value;
+} XkbDeviceValuatorAction;
+
+typedef union _XkbAction {
+    XkbAnyAction any;
+    XkbModAction mods;
+    XkbGroupAction group;
+    XkbISOAction iso;
+    XkbPtrAction ptr;
+    XkbPtrBtnAction btn;
+    XkbPtrDfltAction dflt;
+    XkbSwitchScreenAction screen;
+    XkbCtrlsAction ctrls;
+    XkbMessageAction msg;
+    XkbRedirectKeyAction redirect;
+    XkbDeviceBtnAction devbtn;
+    XkbDeviceValuatorAction devval;
+    unsigned char type;
+} XkbAction;
+
+typedef struct _XkbControls {
+    unsigned char mk_dflt_btn;
+    unsigned char num_groups;
+    unsigned char groups_wrap;
+    XkbModsRec internal;
+    XkbModsRec ignore_lock;
+    unsigned int enabled_ctrls;
+    unsigned short repeat_delay;
+    unsigned short repeat_interval;
+    unsigned short slow_keys_delay;
+    unsigned short debounce_delay;
+    unsigned short mk_delay;
+    unsigned short mk_interval;
+    unsigned short mk_time_to_max;
+    unsigned short mk_max_speed;
+    short mk_curve;
+    unsigned short ax_options;
+    unsigned short ax_timeout;
+    unsigned short axt_opts_mask;
+    unsigned short axt_opts_values;
+    unsigned int axt_ctrls_mask;
+    unsigned int axt_ctrls_values;
+    unsigned char per_key_repeat[XkbPerKeyBitArraySize];
+} XkbControlsRec, *XkbControlsPtr;
+
+#define	XkbAX_AnyFeedback(c)	((c)->enabled_ctrls&XkbAccessXFeedbackMask)
+#define	XkbAX_NeedOption(c,w)	((c)->ax_options&(w))
+#define	XkbAX_NeedFeedback(c, w) (XkbAX_AnyFeedback((c)) && \
+                                  XkbAX_NeedOption((c), (w)))
+
+typedef struct _XkbServerMapRec {
+    unsigned short num_acts;
+    unsigned short size_acts;
+    XkbAction *acts;
+
+    XkbBehavior *behaviors;
+    unsigned short *key_acts;
+#if defined(__cplusplus) || defined(c_plusplus)
+    /* explicit is a C++ reserved word */
+    unsigned char *c_explicit;
+#else
+    unsigned char *explicit;
+#endif
+    unsigned char vmods[XkbNumVirtualMods];
+    unsigned short *vmodmap;
+} XkbServerMapRec, *XkbServerMapPtr;
+
+#define	XkbSMKeyActionsPtr(m, k) (&(m)->acts[(m)->key_acts[(k)]])
+
+        /*
+         * Structures and access macros used primarily by clients
+         */
+
+typedef struct _XkbSymMapRec {
+    unsigned char kt_index[XkbNumKbdGroups];
+    unsigned char group_info;
+    unsigned char width;
+    unsigned short offset;
+} XkbSymMapRec, *XkbSymMapPtr;
+
+typedef struct _XkbClientMapRec {
+    unsigned char size_types;
+    unsigned char num_types;
+    XkbKeyTypePtr types;
+
+    unsigned short size_syms;
+    unsigned short num_syms;
+    KeySym *syms;
+    XkbSymMapPtr key_sym_map;
+
+    unsigned char *modmap;
+} XkbClientMapRec, *XkbClientMapPtr;
+
+#define	XkbCMKeyGroupInfo(m, k) ((m)->key_sym_map[(k)].group_info)
+#define	XkbCMKeyNumGroups(m, k) (XkbNumGroups((m)->key_sym_map[(k)].group_info))
+#define	XkbCMKeyGroupWidth(m, k, g) (XkbCMKeyType((m), (k), (g))->num_levels)
+#define	XkbCMKeyGroupsWidth(m, k) ((m)->key_sym_map[(k)].width)
+#define	XkbCMKeyTypeIndex(m, k, g) ((m)->key_sym_map[(k)].kt_index[(g) & 0x3])
+#define	XkbCMKeyType(m, k, g) (&(m)->types[XkbCMKeyTypeIndex((m), (k), (g))])
+#define	XkbCMKeyNumSyms(m, k) (XkbCMKeyGroupsWidth((m), (k)) * \
+                               XkbCMKeyNumGroups((m), (k)))
+#define	XkbCMKeySymsOffset(m, k) ((m)->key_sym_map[(k)].offset)
+#define	XkbCMKeySymsPtr(m, k) (&(m)->syms[XkbCMKeySymsOffset((m), (k))])
+
+        /*
+         * Compatibility structures and access macros
+         */
+
+typedef struct _XkbSymInterpretRec {
+    KeySym sym;
+    unsigned char flags;
+    unsigned char match;
+    unsigned char mods;
+    unsigned char virtual_mod;
+    XkbAnyAction act;
+} XkbSymInterpretRec, *XkbSymInterpretPtr;
+
+typedef struct _XkbCompatMapRec {
+    XkbSymInterpretPtr sym_interpret;
+    XkbModsRec groups[XkbNumKbdGroups];
+    unsigned short num_si;
+    unsigned short size_si;
+} XkbCompatMapRec, *XkbCompatMapPtr;
+
+typedef struct _XkbIndicatorMapRec {
+    unsigned char flags;
+    /* FIXME: For some reason, interepretation of groups is wildly
+     *        different between which being base/latched/locked. */
+    unsigned char which_groups;
+    unsigned char groups;
+    unsigned char which_mods;
+    XkbModsRec mods;
+    unsigned int ctrls;
+} XkbIndicatorMapRec, *XkbIndicatorMapPtr;
+
+#define	XkbIM_IsAuto(i)	(!((i)->flags & XkbIM_NoAutomatic) && \
+			    (((i)->which_groups&&(i)->groups)||\
+			     ((i)->which_mods&&(i)->mods.mask)||\
+                          (i)->ctrls))
+#define	XkbIM_InUse(i)	((i)->flags || (i)->which_groups || (i)->which_mods || \
+                         (i)->ctrls)
+
+typedef struct _XkbIndicatorRec {
+    unsigned long phys_indicators;
+    XkbIndicatorMapRec maps[XkbNumIndicators];
+} XkbIndicatorRec, *XkbIndicatorPtr;
+
+typedef struct _XkbKeyNameRec {
+    char name[XkbKeyNameLength];
+} XkbKeyNameRec, *XkbKeyNamePtr;
+
+typedef struct _XkbKeyAliasRec {
+    char real[XkbKeyNameLength];
+    char alias[XkbKeyNameLength];
+} XkbKeyAliasRec, *XkbKeyAliasPtr;
+
+        /*
+         * Names for everything 
+         */
+typedef struct _XkbNamesRec {
+    Atom keycodes;
+    Atom geometry;
+    Atom symbols;
+    Atom types;
+    Atom compat;
+    Atom vmods[XkbNumVirtualMods];
+    Atom indicators[XkbNumIndicators];
+    Atom groups[XkbNumKbdGroups];
+    XkbKeyNamePtr keys;
+    XkbKeyAliasPtr key_aliases;
+    Atom *radio_groups;
+    Atom phys_symbols;
+
+    unsigned char num_keys;
+    unsigned char num_key_aliases;
+    unsigned short num_rg;
+} XkbNamesRec, *XkbNamesPtr;
+
+typedef struct _XkbGeometry *XkbGeometryPtr;
+
+        /*
+         * Tie it all together into one big keyboard description
+         */
+typedef struct _XkbDesc {
+    unsigned int defined;
+    unsigned short flags;
+    unsigned short device_spec;
+    KeyCode min_key_code;
+    KeyCode max_key_code;
+
+    XkbControlsPtr ctrls;
+    XkbServerMapPtr server;
+    XkbClientMapPtr map;
+    XkbIndicatorPtr indicators;
+    XkbNamesPtr names;
+    XkbCompatMapPtr compat;
+    XkbGeometryPtr geom;
+} XkbDescRec, *XkbDescPtr;
+
+#define	XkbKeyKeyTypeIndex(d, k, g)	(XkbCMKeyTypeIndex((d)->map, (k), (g)))
+#define	XkbKeyKeyType(d, k, g)		(XkbCMKeyType((d)->map, (k), (g)))
+#define	XkbKeyGroupWidth(d, k, g)	(XkbCMKeyGroupWidth((d)->map, (k), (g)))
+#define	XkbKeyGroupsWidth(d, k)		(XkbCMKeyGroupsWidth((d)->map, (k)))
+#define	XkbKeyGroupInfo(d,k)		(XkbCMKeyGroupInfo((d)->map,(k)))
+#define	XkbKeyNumGroups(d,k)		(XkbCMKeyNumGroups((d)->map,(k)))
+#define	XkbKeyNumSyms(d,k)		(XkbCMKeyNumSyms((d)->map,(k)))
+#define	XkbKeySymsPtr(d,k)		(XkbCMKeySymsPtr((d)->map,(k)))
+#define	XkbKeySym(d, k, n)		(XkbKeySymsPtr((d), (k))[(n)])
+#define	XkbKeySymEntry(d,k,sl,g) \
+    (XkbKeySym((d), (k), (XkbKeyGroupsWidth((d), (k)) * (g)) + (sl)))
+#define	XkbKeyAction(d,k,n) \
+    (XkbKeyHasActions((d), (k)) ? & XkbKeyActionsPtr((d), (k))[(n)] : NULL)
+#define	XkbKeyActionEntry(d,k,sl,g) \
+    (XkbKeyHasActions((d), (k)) ? \
+     XkbKeyAction((d), (k), ((XkbKeyGroupsWidth((d), (k)) * (g)) + (sl))) : \
+     NULL)
+
+#define	XkbKeyHasActions(d, k) (!!(d)->server->key_acts[(k)])
+#define	XkbKeyNumActions(d, k) (XkbKeyHasActions((d), (k)) ? \
+                                XkbKeyNumSyms((d), (k)) : 1)
+#define	XkbKeyActionsPtr(d, k) (XkbSMKeyActionsPtr((d)->server, (k)))
+#define	XkbKeycodeInRange(d, k) ((k) >= (d)->min_key_code && \
+				 (k) <= (d)->max_key_code)
+#define	XkbNumKeys(d)		((d)->max_key_code-(d)->min_key_code+1)
+
+        /*
+         * The following structures can be used to track changes
+         * to a keyboard device
+         */
+typedef struct _XkbMapChanges {
+    unsigned short changed;
+    KeyCode min_key_code;
+    KeyCode max_key_code;
+    unsigned char first_type;
+    unsigned char num_types;
+    KeyCode first_key_sym;
+    unsigned char num_key_syms;
+    KeyCode first_key_act;
+    unsigned char num_key_acts;
+    KeyCode first_key_behavior;
+    unsigned char num_key_behaviors;
+    KeyCode first_key_explicit;
+    unsigned char num_key_explicit;
+    KeyCode first_modmap_key;
+    unsigned char num_modmap_keys;
+    KeyCode first_vmodmap_key;
+    unsigned char num_vmodmap_keys;
+    unsigned char pad;
+    unsigned short vmods;
+} XkbMapChangesRec, *XkbMapChangesPtr;
+
+typedef struct _XkbControlsChanges {
+    unsigned int changed_ctrls;
+    unsigned int enabled_ctrls_changes;
+    Bool num_groups_changed;
+} XkbControlsChangesRec, *XkbControlsChangesPtr;
+
+typedef struct _XkbIndicatorChanges {
+    unsigned int state_changes;
+    unsigned int map_changes;
+} XkbIndicatorChangesRec, *XkbIndicatorChangesPtr;
+
+typedef struct _XkbNameChanges {
+    unsigned int changed;
+    unsigned char first_type;
+    unsigned char num_types;
+    unsigned char first_lvl;
+    unsigned char num_lvls;
+    unsigned char num_aliases;
+    unsigned char num_rg;
+    unsigned char first_key;
+    unsigned char num_keys;
+    unsigned short changed_vmods;
+    unsigned long changed_indicators;
+    unsigned char changed_groups;
+} XkbNameChangesRec, *XkbNameChangesPtr;
+
+typedef struct _XkbCompatChanges {
+    unsigned char changed_groups;
+    unsigned short first_si;
+    unsigned short num_si;
+} XkbCompatChangesRec, *XkbCompatChangesPtr;
+
+typedef struct _XkbChanges {
+    unsigned short device_spec;
+    unsigned short state_changes;
+    XkbMapChangesRec map;
+    XkbControlsChangesRec ctrls;
+    XkbIndicatorChangesRec indicators;
+    XkbNameChangesRec names;
+    XkbCompatChangesRec compat;
+} XkbChangesRec, *XkbChangesPtr;
+
+        /*
+         * These data structures are used to construct a keymap from 
+         * a set of components or to list components in the server
+         * database.
+         */
+typedef struct _XkbComponentNames {
+    char *keycodes;
+    char *types;
+    char *compat;
+    char *symbols;
+    char *geometry;
+} XkbComponentNamesRec, *XkbComponentNamesPtr;
+
+typedef struct _XkbComponentName {
+    unsigned short flags;
+    char *name;
+} XkbComponentNameRec, *XkbComponentNamePtr;
+
+typedef struct _XkbComponentList {
+    int num_keymaps;
+    int num_keycodes;
+    int num_types;
+    int num_compat;
+    int num_symbols;
+    int num_geometry;
+    XkbComponentNamePtr keymaps;
+    XkbComponentNamePtr keycodes;
+    XkbComponentNamePtr types;
+    XkbComponentNamePtr compat;
+    XkbComponentNamePtr symbols;
+    XkbComponentNamePtr geometry;
+} XkbComponentListRec, *XkbComponentListPtr;
+
+        /*
+         * The following data structures describe and track changes to a 
+         * non-keyboard extension device 
+         */
+typedef struct _XkbDeviceLedInfo {
+    unsigned short led_class;
+    unsigned short led_id;
+    unsigned int phys_indicators;
+    unsigned int maps_present;
+    unsigned int names_present;
+    unsigned int state;
+    Atom names[XkbNumIndicators];
+    XkbIndicatorMapRec maps[XkbNumIndicators];
+} XkbDeviceLedInfoRec, *XkbDeviceLedInfoPtr;
+
+typedef struct _XkbDeviceInfo {
+    char *name;
+    Atom type;
+    unsigned short device_spec;
+    Bool has_own_state;
+    unsigned short supported;
+    unsigned short unsupported;
+
+    unsigned short num_btns;
+    XkbAction *btn_acts;
+
+    unsigned short sz_leds;
+    unsigned short num_leds;
+    unsigned short dflt_kbd_fb;
+    unsigned short dflt_led_fb;
+    XkbDeviceLedInfoPtr leds;
+} XkbDeviceInfoRec, *XkbDeviceInfoPtr;
+
+#define	XkbXI_DevHasBtnActs(d)	((d)->num_btns > 0 && (d)->btn_acts)
+#define	XkbXI_LegalDevBtn(d,b)	(XkbXI_DevHasBtnActs(d) && (b) < (d)->num_btns)
+#define	XkbXI_DevHasLeds(d)	((d)->num_leds > 0 && (d)->leds)
+
+typedef struct _XkbDeviceLedChanges {
+    unsigned short led_class;
+    unsigned short led_id;
+    unsigned int defined;       /* names or maps changed */
+    struct _XkbDeviceLedChanges *next;
+} XkbDeviceLedChangesRec, *XkbDeviceLedChangesPtr;
+
+typedef struct _XkbDeviceChanges {
+    unsigned int changed;
+    unsigned short first_btn;
+    unsigned short num_btns;
+    XkbDeviceLedChangesRec leds;
+} XkbDeviceChangesRec, *XkbDeviceChangesPtr;
+
+#endif                          /* _XKBSTR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxscreens.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxscreens.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxscreens.h	(Revision 52145)
@@ -0,0 +1,163 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GLX_screens_h_
+#define _GLX_screens_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+typedef struct __GLXconfig __GLXconfig;
+struct __GLXconfig {
+    __GLXconfig *next;
+    GLuint doubleBufferMode;
+    GLuint stereoMode;
+
+    GLint redBits, greenBits, blueBits, alphaBits;      /* bits per comp */
+    GLuint redMask, greenMask, blueMask, alphaMask;
+    GLint rgbBits;              /* total bits for rgb */
+    GLint indexBits;            /* total bits for colorindex */
+
+    GLint accumRedBits, accumGreenBits, accumBlueBits, accumAlphaBits;
+    GLint depthBits;
+    GLint stencilBits;
+
+    GLint numAuxBuffers;
+
+    GLint level;
+
+    /* GLX */
+    GLint visualID;
+    GLint visualType;     /**< One of the GLX X visual types. (i.e., 
+			   * \c GLX_TRUE_COLOR, etc.)
+			   */
+
+    /* EXT_visual_rating / GLX 1.2 */
+    GLint visualRating;
+
+    /* EXT_visual_info / GLX 1.2 */
+    GLint transparentPixel;
+    /*    colors are floats scaled to ints */
+    GLint transparentRed, transparentGreen, transparentBlue, transparentAlpha;
+    GLint transparentIndex;
+
+    /* ARB_multisample / SGIS_multisample */
+    GLint sampleBuffers;
+    GLint samples;
+
+    /* SGIX_fbconfig / GLX 1.3 */
+    GLint drawableType;
+    GLint renderType;
+    GLint xRenderable;
+    GLint fbconfigID;
+
+    /* SGIX_pbuffer / GLX 1.3 */
+    GLint maxPbufferWidth;
+    GLint maxPbufferHeight;
+    GLint maxPbufferPixels;
+    GLint optimalPbufferWidth;  /* Only for SGIX_pbuffer. */
+    GLint optimalPbufferHeight; /* Only for SGIX_pbuffer. */
+
+    /* SGIX_visual_select_group */
+    GLint visualSelectGroup;
+
+    /* OML_swap_method */
+    GLint swapMethod;
+
+    /* EXT_texture_from_pixmap */
+    GLint bindToTextureRgb;
+    GLint bindToTextureRgba;
+    GLint bindToMipmapTexture;
+    GLint bindToTextureTargets;
+    GLint yInverted;
+
+    /* ARB_framebuffer_sRGB */
+    GLint sRGBCapable;
+};
+
+GLint glxConvertToXVisualType(int visualType);
+
+/*
+** Screen dependent data.  These methods are the interface between the DIX
+** and DDX layers of the GLX server extension.  The methods provide an
+** interface for context management on a screen.
+*/
+typedef struct __GLXscreen __GLXscreen;
+struct __GLXscreen {
+    void (*destroy) (__GLXscreen * screen);
+
+    __GLXcontext *(*createContext) (__GLXscreen * screen,
+                                    __GLXconfig * modes,
+                                    __GLXcontext * shareContext,
+                                    unsigned num_attribs,
+                                    const uint32_t *attribs,
+                                    int *error);
+
+    __GLXdrawable *(*createDrawable) (ClientPtr client,
+                                      __GLXscreen * context,
+                                      DrawablePtr pDraw,
+                                      XID drawId,
+                                      int type,
+                                      XID glxDrawId, __GLXconfig * modes);
+    int (*swapInterval) (__GLXdrawable * drawable, int interval);
+
+    ScreenPtr pScreen;
+
+    /* Linked list of valid fbconfigs for this screen. */
+    __GLXconfig *fbconfigs;
+    int numFBConfigs;
+
+    /* Subset of fbconfigs that are exposed as GLX visuals. */
+    __GLXconfig **visuals;
+    GLint numVisuals;
+
+    char *GLextensions;
+
+    char *GLXextensions;
+
+    /**
+     * \name GLX version supported by this screen.
+     *
+     * Since the GLX version advertised by the server is for the whole server,
+     * the GLX protocol code uses the minimum version supported on all screens.
+     */
+    /*@{ */
+    unsigned GLXmajor;
+    unsigned GLXminor;
+    /*@} */
+
+    Bool (*CloseScreen) (ScreenPtr pScreen);
+};
+
+void __glXScreenInit(__GLXscreen * screen, ScreenPtr pScreen);
+void __glXScreenDestroy(__GLXscreen * screen);
+
+#endif                          /* !__GLX_screens_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxscreens.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-mouse.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-mouse.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-mouse.h	(Revision 52145)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB mouse driver.  \see usb-mouse.c \see usb-common.c */
+
+#ifndef _USB_MOU_H_
+#define _USB_MOU_H_
+extern void mouUSBRead(DevicePtr pDev,
+                       dmxMotionProcPtr motion,
+                       dmxEnqueueProcPtr enqueue,
+                       dmxCheckSpecialProcPtr checkspecial, DMXBlockType block);
+extern void mouUSBInit(DevicePtr pDev);
+extern void mouUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int mouUSBOn(DevicePtr pDev);
+extern void mouUSBCtrl(DevicePtr pDev, PtrCtrl * ctrl);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-mouse.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifpoly.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifpoly.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifpoly.h	(Revision 52145)
@@ -0,0 +1,102 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef __MIFPOLY_H__
+#define __MIFPOLY_H__
+
+#include <X11/Xfuncproto.h>
+
+#define EPSILON	0.000001
+#define ISEQUAL(a,b) (fabs((a) - (b)) <= EPSILON)
+#define UNEQUAL(a,b) (fabs((a) - (b)) > EPSILON)
+#define WITHINHALF(a, b) (((a) - (b) > 0.0) ? (a) - (b) < 0.5 : \
+					     (b) - (a) <= 0.5)
+#define ROUNDTOINT(x)   ((int) (((x) > 0.0) ? ((x) + 0.5) : ((x) - 0.5)))
+#define ISZERO(x) 	(fabs((x)) <= EPSILON)
+#define PTISEQUAL(a,b) (ISEQUAL(a.x,b.x) && ISEQUAL(a.y,b.y))
+#define PTUNEQUAL(a,b) (UNEQUAL(a.x,b.x) || UNEQUAL(a.y,b.y))
+#define PtEqual(a, b) (((a).x == (b).x) && ((a).y == (b).y))
+
+#define NotEnd		0
+#define FirstEnd	1
+#define SecondEnd	2
+
+#define SQSECANT 108.856472512142       /* 1/sin^2(11/2) - for 11o miter cutoff */
+#define D2SECANT 5.21671526231167       /* 1/2*sin(11/2) - max extension per width */
+
+static _X_INLINE int
+ICEIL(double x)
+{
+    int _cTmp = x;
+
+    return ((x == _cTmp) || (x < 0.0)) ? _cTmp : _cTmp + 1;
+}
+
+/* Point with sub-pixel positioning.  In this case we use doubles, but
+ * see mifpolycon.c for other suggestions 
+ */
+typedef struct _SppPoint {
+    double x, y;
+} SppPointRec, *SppPointPtr;
+
+typedef struct _SppArc {
+    double x, y, width, height;
+    double angle1, angle2;
+} SppArcRec, *SppArcPtr;
+
+/* mifpolycon.c */
+
+extern _X_EXPORT void miFillSppPoly(DrawablePtr /*dst */ ,
+                                    GCPtr /*pgc */ ,
+                                    int /*count */ ,
+                                    SppPointPtr /*ptsIn */ ,
+                                    int /*xTrans */ ,
+                                    int /*yTrans */ ,
+                                    double /*xFtrans */ ,
+                                    double      /*yFtrans */
+    );
+
+#endif                          /* __MIFPOLY_H__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mifpoly.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkbd.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkbd.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkbd.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGKBD_H
+#define CHGKBD_H 1
+
+int SProcXChangeKeyboardDevice(ClientPtr        /* client */
+    );
+
+int ProcXChangeKeyboardDevice(ClientPtr /* client */
+    );
+
+#endif                          /* CHGKBD_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgkbd.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/globals.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/globals.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/globals.h	(Revision 52145)
@@ -0,0 +1,53 @@
+
+#ifndef _XSERV_GLOBAL_H_
+#define _XSERV_GLOBAL_H_
+
+#include <signal.h>
+
+#include "window.h"             /* for WindowPtr */
+#include "extinit.h"
+
+/* Global X server variables that are visible to mi, dix, os, and ddx */
+
+extern _X_EXPORT CARD32 defaultScreenSaverTime;
+extern _X_EXPORT CARD32 defaultScreenSaverInterval;
+extern _X_EXPORT CARD32 ScreenSaverTime;
+extern _X_EXPORT CARD32 ScreenSaverInterval;
+
+#ifdef SCREENSAVER
+extern _X_EXPORT Bool screenSaverSuspended;
+#endif
+
+extern _X_EXPORT const char *defaultFontPath;
+extern _X_EXPORT int monitorResolution;
+extern _X_EXPORT int defaultColorVisualClass;
+
+extern _X_EXPORT int GrabInProgress;
+extern _X_EXPORT Bool noTestExtensions;
+extern _X_EXPORT char *SeatId;
+extern _X_EXPORT char *ConnectionInfo;
+extern _X_EXPORT sig_atomic_t inSignalContext;
+
+#ifdef DPMSExtension
+extern _X_EXPORT CARD32 DPMSStandbyTime;
+extern _X_EXPORT CARD32 DPMSSuspendTime;
+extern _X_EXPORT CARD32 DPMSOffTime;
+extern _X_EXPORT CARD16 DPMSPowerLevel;
+extern _X_EXPORT Bool DPMSEnabled;
+extern _X_EXPORT Bool DPMSDisabledSwitch;
+extern _X_EXPORT Bool DPMSCapableFlag;
+#endif
+
+#ifdef PANORAMIX
+extern _X_EXPORT Bool PanoramiXExtensionDisabledHack;
+#endif
+
+#ifdef XSELINUX
+#define SELINUX_MODE_DEFAULT    0
+#define SELINUX_MODE_DISABLED   1
+#define SELINUX_MODE_PERMISSIVE 2
+#define SELINUX_MODE_ENFORCING  3
+extern _X_EXPORT int selinuxEnforcingState;
+#endif
+
+#endif                          /* !_XSERV_GLOBAL_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/globals.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix.h	(Revision 52145)
@@ -0,0 +1,613 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_H
+#define DIX_H
+
+#include "callback.h"
+#include "gc.h"
+#include "window.h"
+#include "input.h"
+#include "cursor.h"
+#include "geext.h"
+#include "events.h"
+#include <X11/extensions/XI.h>
+
+#define EARLIER -1
+#define SAMETIME 0
+#define LATER 1
+
+#define NullClient ((ClientPtr) 0)
+#define REQUEST(type) \
+	type *stuff = (type *)client->requestBuffer
+
+#define ARRAY_SIZE(a)  (sizeof((a)) / sizeof((a)[0]))
+
+#define REQUEST_SIZE_MATCH(req)\
+    if ((sizeof(req) >> 2) != client->req_len)\
+         return(BadLength)
+
+#define REQUEST_AT_LEAST_SIZE(req) \
+    if ((sizeof(req) >> 2) > client->req_len )\
+         return(BadLength)
+
+#define REQUEST_FIXED_SIZE(req, n)\
+    if (((sizeof(req) >> 2) > client->req_len) || \
+        (((sizeof(req) + (n) + 3) >> 2) != client->req_len)) \
+         return(BadLength)
+
+#define LEGAL_NEW_RESOURCE(id,client)\
+    if (!LegalNewID(id,client)) \
+    {\
+	client->errorValue = id;\
+        return BadIDChoice;\
+    }
+
+#define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, mode)\
+    {\
+	int tmprc = dixLookupDrawable(&(pDraw), drawID, client, M_ANY, mode);\
+	if (tmprc != Success)\
+	    return tmprc;\
+	tmprc = dixLookupGC(&(pGC), stuff->gc, client, DixUseAccess);\
+	if (tmprc != Success)\
+	    return tmprc;\
+	if ((pGC->depth != pDraw->depth) || (pGC->pScreen != pDraw->pScreen))\
+	    return BadMatch;\
+    }\
+    if (pGC->serialNumber != pDraw->serialNumber)\
+	ValidateGC(pDraw, pGC);
+
+#define WriteReplyToClient(pClient, size, pReply) { \
+   if ((pClient)->swapped) \
+      (*ReplySwapVector[((xReq *)(pClient)->requestBuffer)->reqType]) \
+           (pClient, (int)(size), pReply); \
+   else WriteToClient(pClient, (int)(size), (pReply)); }
+
+#define WriteSwappedDataToClient(pClient, size, pbuf) \
+   if ((pClient)->swapped) \
+      (*(pClient)->pSwapReplyFunc)(pClient, (int)(size), pbuf); \
+   else WriteToClient(pClient, (int)(size), (pbuf));
+
+typedef struct _TimeStamp *TimeStampPtr;
+
+#ifndef _XTYPEDEF_CLIENTPTR
+typedef struct _Client *ClientPtr;      /* also in misc.h */
+
+#define _XTYPEDEF_CLIENTPTR
+#endif
+
+typedef struct _WorkQueue *WorkQueuePtr;
+
+extern _X_EXPORT ClientPtr clients[MAXCLIENTS];
+extern _X_EXPORT ClientPtr serverClient;
+extern _X_EXPORT int currentMaxClients;
+extern _X_EXPORT char dispatchExceptionAtReset;
+
+typedef int HWEventQueueType;
+typedef HWEventQueueType *HWEventQueuePtr;
+
+extern _X_EXPORT HWEventQueuePtr checkForInput[2];
+
+typedef struct _TimeStamp {
+    CARD32 months;              /* really ~49.7 days */
+    CARD32 milliseconds;
+} TimeStamp;
+
+/* dispatch.c */
+
+extern _X_EXPORT void SetInputCheck(HWEventQueuePtr /*c0 */ ,
+                                    HWEventQueuePtr /*c1 */ );
+
+extern _X_EXPORT void CloseDownClient(ClientPtr /*client */ );
+
+extern _X_EXPORT void UpdateCurrentTime(void);
+
+extern _X_EXPORT void UpdateCurrentTimeIf(void);
+
+extern _X_EXPORT int dixDestroyPixmap(void */*value */ ,
+                                      XID /*pid */ );
+
+extern _X_EXPORT void InitClient(ClientPtr /*client */ ,
+                                 int /*i */ ,
+                                 void */*ospriv */ );
+
+extern _X_EXPORT ClientPtr NextAvailableClient(void */*ospriv */ );
+
+extern _X_EXPORT void SendErrorToClient(ClientPtr /*client */ ,
+                                        unsigned int /*majorCode */ ,
+                                        unsigned int /*minorCode */ ,
+                                        XID /*resId */ ,
+                                        int /*errorCode */ );
+
+extern _X_EXPORT void MarkClientException(ClientPtr /*client */ );
+
+extern _X_HIDDEN Bool CreateConnectionBlock(void);
+
+/* dixutils.c */
+
+extern _X_EXPORT int CompareISOLatin1Lowered(const unsigned char * /*a */ ,
+                                             int alen,
+                                             const unsigned char * /*b */ ,
+                                             int blen);
+
+extern _X_EXPORT int dixLookupWindow(WindowPtr *result,
+                                     XID id,
+                                     ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT int dixLookupDrawable(DrawablePtr *result,
+                                       XID id,
+                                       ClientPtr client,
+                                       Mask type_mask, Mask access_mode);
+
+extern _X_EXPORT int dixLookupGC(GCPtr *result,
+                                 XID id, ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT int dixLookupFontable(FontPtr *result,
+                                       XID id,
+                                       ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT int dixLookupClient(ClientPtr *result,
+                                     XID id,
+                                     ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT void NoopDDA(void);
+
+extern _X_EXPORT int AlterSaveSetForClient(ClientPtr /*client */ ,
+                                           WindowPtr /*pWin */ ,
+                                           unsigned /*mode */ ,
+                                           Bool /*toRoot */ ,
+                                           Bool /*map */ );
+
+extern _X_EXPORT void DeleteWindowFromAnySaveSet(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void BlockHandler(void */*pTimeout */ ,
+                                   void */*pReadmask */ );
+
+extern _X_EXPORT void WakeupHandler(int /*result */ ,
+                                    void */*pReadmask */ );
+
+void
+ EnableLimitedSchedulingLatency(void);
+
+void
+ DisableLimitedSchedulingLatency(void);
+
+typedef void (*WakeupHandlerProcPtr) (void */* blockData */ ,
+                                      int /* result */ ,
+                                      void */* pReadmask */ );
+
+extern _X_EXPORT Bool RegisterBlockAndWakeupHandlers(BlockHandlerProcPtr
+                                                     /*blockHandler */ ,
+                                                     WakeupHandlerProcPtr
+                                                     /*wakeupHandler */ ,
+                                                     void */*blockData */ );
+
+extern _X_EXPORT void RemoveBlockAndWakeupHandlers(BlockHandlerProcPtr
+                                                   /*blockHandler */ ,
+                                                   WakeupHandlerProcPtr
+                                                   /*wakeupHandler */ ,
+                                                   void */*blockData */ );
+
+extern _X_EXPORT void InitBlockAndWakeupHandlers(void);
+
+extern _X_EXPORT void ProcessWorkQueue(void);
+
+extern _X_EXPORT void ProcessWorkQueueZombies(void);
+
+extern _X_EXPORT Bool QueueWorkProc(Bool (* /*function */ )(
+                                                               ClientPtr
+                                                               /*clientUnused */
+                                                               ,
+                                                               void *
+                                                               /*closure */ ),
+                                    ClientPtr /*client */ ,
+                                    void */*closure */
+    );
+
+typedef Bool (*ClientSleepProcPtr) (ClientPtr /*client */ ,
+                                    void */*closure */ );
+
+extern _X_EXPORT Bool ClientSleep(ClientPtr /*client */ ,
+                                  ClientSleepProcPtr /* function */ ,
+                                  void */*closure */ );
+
+#ifndef ___CLIENTSIGNAL_DEFINED___
+#define ___CLIENTSIGNAL_DEFINED___
+extern _X_EXPORT Bool ClientSignal(ClientPtr /*client */ );
+#endif                          /* ___CLIENTSIGNAL_DEFINED___ */
+
+extern _X_EXPORT void ClientWakeup(ClientPtr /*client */ );
+
+extern _X_EXPORT Bool ClientIsAsleep(ClientPtr /*client */ );
+
+/* atom.c */
+
+extern _X_EXPORT Atom MakeAtom(const char * /*string */ ,
+                               unsigned /*len */ ,
+                               Bool /*makeit */ );
+
+extern _X_EXPORT Bool ValidAtom(Atom /*atom */ );
+
+extern _X_EXPORT const char *NameForAtom(Atom /*atom */ );
+
+extern _X_EXPORT void
+AtomError(void)
+    _X_NORETURN;
+
+extern _X_EXPORT void
+FreeAllAtoms(void);
+
+extern _X_EXPORT void
+InitAtoms(void);
+
+/* main.c */
+
+extern _X_EXPORT void
+SetVendorRelease(int release);
+
+extern _X_EXPORT void
+SetVendorString(const char *string);
+
+int
+dix_main(int argc, char *argv[], char *envp[]);
+
+/* events.c */
+
+extern void
+SetMaskForEvent(int /* deviceid */ ,
+                Mask /* mask */ ,
+                int /* event */ );
+
+extern _X_EXPORT void
+ConfineToShape(DeviceIntPtr /* pDev */ ,
+               RegionPtr /* shape */ ,
+               int * /* px */ ,
+               int * /* py */ );
+
+extern _X_EXPORT Bool
+IsParent(WindowPtr /* maybeparent */ ,
+         WindowPtr /* child */ );
+
+extern _X_EXPORT WindowPtr
+GetCurrentRootWindow(DeviceIntPtr pDev);
+
+extern _X_EXPORT WindowPtr
+GetSpriteWindow(DeviceIntPtr pDev);
+
+extern _X_EXPORT void
+NoticeTime(const DeviceIntPtr dev,
+           TimeStamp time);
+extern _X_EXPORT void
+NoticeEventTime(InternalEvent *ev,
+                DeviceIntPtr dev);
+extern _X_EXPORT TimeStamp
+LastEventTime(int deviceid);
+extern _X_EXPORT Bool
+LastEventTimeWasReset(int deviceid);
+extern _X_EXPORT void
+LastEventTimeToggleResetFlag(int deviceid, Bool state);
+extern _X_EXPORT void
+LastEventTimeToggleResetAll(Bool state);
+
+extern void
+EnqueueEvent(InternalEvent * /* ev */ ,
+             DeviceIntPtr /* device */ );
+extern void
+PlayReleasedEvents(void);
+
+extern void
+ActivatePointerGrab(DeviceIntPtr /* mouse */ ,
+                    GrabPtr /* grab */ ,
+                    TimeStamp /* time */ ,
+                    Bool /* autoGrab */ );
+
+extern void
+DeactivatePointerGrab(DeviceIntPtr /* mouse */ );
+
+extern void
+ActivateKeyboardGrab(DeviceIntPtr /* keybd */ ,
+                     GrabPtr /* grab */ ,
+                     TimeStamp /* time */ ,
+                     Bool /* passive */ );
+
+extern void
+DeactivateKeyboardGrab(DeviceIntPtr /* keybd */ );
+
+extern BOOL
+ActivateFocusInGrab(DeviceIntPtr /* dev */ ,
+                    WindowPtr /* old */ ,
+                    WindowPtr /* win */ );
+
+extern void
+AllowSome(ClientPtr /* client */ ,
+          TimeStamp /* time */ ,
+          DeviceIntPtr /* thisDev */ ,
+          int /* newState */ );
+
+extern void
+ReleaseActiveGrabs(ClientPtr client);
+
+extern GrabPtr
+CheckPassiveGrabsOnWindow(WindowPtr /* pWin */ ,
+                          DeviceIntPtr /* device */ ,
+                          InternalEvent * /* event */ ,
+                          BOOL /* checkCore */ ,
+                          BOOL /* activate */ );
+
+extern _X_EXPORT int
+DeliverEventsToWindow(DeviceIntPtr /* pWin */ ,
+                      WindowPtr /* pWin */ ,
+                      xEventPtr /* pEvents */ ,
+                      int /* count */ ,
+                      Mask /* filter */ ,
+                      GrabPtr /* grab */ );
+
+extern _X_EXPORT void
+DeliverRawEvent(RawDeviceEvent * /* ev */ ,
+                DeviceIntPtr    /* dev */
+    );
+
+extern int
+DeliverDeviceEvents(WindowPtr /* pWin */ ,
+                    InternalEvent * /* event */ ,
+                    GrabPtr /* grab */ ,
+                    WindowPtr /* stopAt */ ,
+                    DeviceIntPtr /* dev */ );
+
+extern int
+DeliverOneGrabbedEvent(InternalEvent * /* event */ ,
+                       DeviceIntPtr /* dev */ ,
+                       enum InputLevel /* level */ );
+
+extern void
+DeliverTouchEvents(DeviceIntPtr /* dev */ ,
+                   TouchPointInfoPtr /* ti */ ,
+                   InternalEvent * /* ev */ ,
+                   XID /* resource */ );
+
+extern void
+InitializeSprite(DeviceIntPtr /* pDev */ ,
+                 WindowPtr /* pWin */ );
+extern void
+FreeSprite(DeviceIntPtr pDev);
+
+extern void
+UpdateSpriteForScreen(DeviceIntPtr /* pDev */ ,
+                      ScreenPtr /* pScreen */ );
+
+extern _X_EXPORT void
+WindowHasNewCursor(WindowPtr /* pWin */ );
+
+extern Bool
+CheckDeviceGrabs(DeviceIntPtr /* device */ ,
+                 DeviceEvent * /* event */ ,
+                 WindowPtr /* ancestor */ );
+
+extern void
+DeliverFocusedEvent(DeviceIntPtr /* keybd */ ,
+                    InternalEvent * /* event */ ,
+                    WindowPtr /* window */ );
+
+extern int
+DeliverGrabbedEvent(InternalEvent * /* event */ ,
+                    DeviceIntPtr /* thisDev */ ,
+                    Bool /* deactivateGrab */ );
+
+extern void
+FixKeyState(DeviceEvent * /* event */ ,
+            DeviceIntPtr /* keybd */ );
+
+extern void
+RecalculateDeliverableEvents(WindowPtr /* pWin */ );
+
+extern _X_EXPORT int
+OtherClientGone(void */* value */ ,
+                XID /* id */ );
+
+extern void
+DoFocusEvents(DeviceIntPtr /* dev */ ,
+              WindowPtr /* fromWin */ ,
+              WindowPtr /* toWin */ ,
+              int /* mode */ );
+
+extern int
+SetInputFocus(ClientPtr /* client */ ,
+              DeviceIntPtr /* dev */ ,
+              Window /* focusID */ ,
+              CARD8 /* revertTo */ ,
+              Time /* ctime */ ,
+              Bool /* followOK */ );
+
+extern int
+GrabDevice(ClientPtr /* client */ ,
+           DeviceIntPtr /* dev */ ,
+           unsigned /* this_mode */ ,
+           unsigned /* other_mode */ ,
+           Window /* grabWindow */ ,
+           unsigned /* ownerEvents */ ,
+           Time /* ctime */ ,
+           GrabMask * /* mask */ ,
+           int /* grabtype */ ,
+           Cursor /* curs */ ,
+           Window /* confineToWin */ ,
+           CARD8 * /* status */ );
+
+extern void
+InitEvents(void);
+
+extern void
+CloseDownEvents(void);
+
+extern void
+DeleteWindowFromAnyEvents(WindowPtr /* pWin */ ,
+                          Bool /* freeResources */ );
+
+extern Mask
+EventMaskForClient(WindowPtr /* pWin */ ,
+                   ClientPtr /* client */ );
+
+extern _X_EXPORT int
+DeliverEvents(WindowPtr /*pWin */ ,
+              xEventPtr /*xE */ ,
+              int /*count */ ,
+              WindowPtr /*otherParent */ );
+
+extern Bool
+CheckMotion(DeviceEvent * /* ev */ ,
+            DeviceIntPtr /* pDev */ );
+
+extern _X_EXPORT void
+WriteEventsToClient(ClientPtr /*pClient */ ,
+                    int /*count */ ,
+                    xEventPtr /*events */ );
+
+extern _X_EXPORT int
+TryClientEvents(ClientPtr /*client */ ,
+                DeviceIntPtr /* device */ ,
+                xEventPtr /*pEvents */ ,
+                int /*count */ ,
+                Mask /*mask */ ,
+                Mask /*filter */ ,
+                GrabPtr /*grab */ );
+
+extern _X_EXPORT void
+WindowsRestructured(void);
+
+extern int
+SetClientPointer(ClientPtr /* client */ ,
+                 DeviceIntPtr /* device */ );
+
+extern _X_EXPORT DeviceIntPtr
+PickPointer(ClientPtr /* client */ );
+
+extern _X_EXPORT DeviceIntPtr
+PickKeyboard(ClientPtr /* client */ );
+
+extern Bool
+IsInterferingGrab(ClientPtr /* client */ ,
+                  DeviceIntPtr /* dev */ ,
+                  xEvent * /* events */ );
+
+#ifdef PANORAMIX
+extern _X_EXPORT void
+ReinitializeRootWindow(WindowPtr win, int xoff, int yoff);
+#endif
+
+#ifdef RANDR
+extern _X_EXPORT void
+ScreenRestructured(ScreenPtr pScreen);
+#endif
+
+#ifndef HAVE_FFS
+extern _X_EXPORT int
+ffs(int i);
+#endif
+
+/*
+ *  ServerGrabCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr ServerGrabCallback;
+
+typedef enum { SERVER_GRABBED, SERVER_UNGRABBED,
+    CLIENT_PERVIOUS, CLIENT_IMPERVIOUS
+} ServerGrabState;
+
+typedef struct {
+    ClientPtr client;
+    ServerGrabState grabstate;
+} ServerGrabInfoRec;
+
+/*
+ *  EventCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr EventCallback;
+
+typedef struct {
+    ClientPtr client;
+    xEventPtr events;
+    int count;
+} EventInfoRec;
+
+/*
+ *  DeviceEventCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr DeviceEventCallback;
+
+typedef struct {
+    InternalEvent *event;
+    DeviceIntPtr device;
+} DeviceEventInfoRec;
+
+extern int
+XItoCoreType(int xi_type);
+extern Bool
+DevHasCursor(DeviceIntPtr pDev);
+extern _X_EXPORT Bool
+IsPointerDevice(DeviceIntPtr dev);
+extern _X_EXPORT Bool
+IsKeyboardDevice(DeviceIntPtr dev);
+extern Bool
+IsPointerEvent(InternalEvent *event);
+extern Bool
+IsTouchEvent(InternalEvent *event);
+extern _X_EXPORT Bool
+IsMaster(DeviceIntPtr dev);
+extern _X_EXPORT Bool
+IsFloating(DeviceIntPtr dev);
+
+extern _X_HIDDEN void
+CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);
+extern _X_HIDDEN int
+CorePointerProc(DeviceIntPtr dev, int what);
+extern _X_HIDDEN int
+CoreKeyboardProc(DeviceIntPtr dev, int what);
+
+extern _X_EXPORT void *lastGLContext;
+
+#endif                          /* DIX_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangehierarchy.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangehierarchy.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangehierarchy.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+/***********************************************************************
+ *
+ * Request change in the device hierarchy.
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHDEVHIER_H
+#define CHDEVHIER_H 1
+
+int SProcXIChangeHierarchy(ClientPtr /* client */ );
+int ProcXIChangeHierarchy(ClientPtr /* client */ );
+
+void XISendDeviceHierarchyEvent(int flags[]);
+
+#endif                          /* CHDEVHIER_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xichangehierarchy.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevk.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevk.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevk.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEVK_H
+#define UNGRDEVK_H 1
+
+int SProcXUngrabDeviceKey(ClientPtr     /* client */
+    );
+
+int ProcXUngrabDeviceKey(ClientPtr      /* client */
+    );
+
+#endif                          /* UNGRDEVK_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ungrdevk.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_debug.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_debug.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_debug.h	(Revision 52145)
@@ -0,0 +1,107 @@
+/*
+ * Copyright ¬© 2009 Intel Corporation
+ * Copyright ¬© 1998 Keith Packard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Zhigang Gong <zhigang.gong@gmail.com>
+ *
+ */
+
+#ifndef __GLAMOR_DEBUG_H__
+#define __GLAMOR_DEBUG_H__
+
+#define GLAMOR_DELAYED_STRING_MAX 64
+
+#define GLAMOR_DEBUG_NONE                     0
+#define GLAMOR_DEBUG_UNIMPL                   0
+#define GLAMOR_DEBUG_FALLBACK                 1
+#define GLAMOR_DEBUG_TEXTURE_DOWNLOAD         2
+#define GLAMOR_DEBUG_TEXTURE_DYNAMIC_UPLOAD   3
+
+extern void
+AbortServer(void)
+    _X_NORETURN;
+
+#define GLAMOR_PANIC(_format_, ...)			\
+  do {							\
+    LogMessageVerb(X_NONE, 0, "Glamor Fatal Error"	\
+		   " at %32s line %d: " _format_ "\n",	\
+		   __FUNCTION__, __LINE__,		\
+		   ##__VA_ARGS__ );			\
+    exit(1);                                            \
+  } while(0)
+
+#define __debug_output_message(_format_, _prefix_, ...) \
+  LogMessageVerb(X_NONE, 0,				\
+		 "%32s:\t" _format_ ,		\
+		 /*_prefix_,*/				\
+		 __FUNCTION__,				\
+		 ##__VA_ARGS__)
+
+#define glamor_debug_output(_level_, _format_,...)	\
+  do {							\
+    if (glamor_debug_level >= _level_)			\
+      __debug_output_message(_format_,			\
+			     "Glamor debug",		\
+			     ##__VA_ARGS__);		\
+  } while(0)
+
+#define glamor_fallback(_format_,...)			\
+  do {							\
+    if (glamor_debug_level >= GLAMOR_DEBUG_FALLBACK)	\
+      __debug_output_message(_format_,			\
+			     "Glamor fallback",		\
+			     ##__VA_ARGS__);} while(0)
+
+#define glamor_delayed_fallback(_screen_, _format_,...)			\
+  do {									\
+    if (glamor_debug_level >= GLAMOR_DEBUG_FALLBACK)  {			\
+      glamor_screen_private *_glamor_priv_;				\
+      _glamor_priv_ = glamor_get_screen_private(_screen_);		\
+      _glamor_priv_->delayed_fallback_pending = 1;			\
+      snprintf(_glamor_priv_->delayed_fallback_string,			\
+	       GLAMOR_DELAYED_STRING_MAX,				\
+	       "glamor delayed fallback: \t%s " _format_ ,		\
+               __FUNCTION__, ##__VA_ARGS__); } } while(0)
+
+#define glamor_clear_delayed_fallbacks(_screen_)			\
+  do {									\
+    if (glamor_debug_level >= GLAMOR_DEBUG_FALLBACK) {			\
+      glamor_screen_private *_glamor_priv_;				\
+	_glamor_priv_ = glamor_get_screen_private(_screen_);		\
+      _glamor_priv_->delayed_fallback_pending = 0;  } } while(0)
+
+#define glamor_report_delayed_fallbacks(_screen_)			\
+  do {									\
+    if (glamor_debug_level >= GLAMOR_DEBUG_FALLBACK) {			\
+      glamor_screen_private *_glamor_priv_;				\
+      _glamor_priv_ = glamor_get_screen_private(_screen_);		\
+      LogMessageVerb(X_INFO, 0, "%s",					\
+		     _glamor_priv_->delayed_fallback_string);		\
+      _glamor_priv_->delayed_fallback_pending = 0;  } } while(0)
+
+#define DEBUGF(str, ...)  do {} while(0)
+//#define DEBUGF(str, ...) ErrorF(str, ##__VA_ARGS__)
+#define DEBUGRegionPrint(x) do {} while (0)
+//#define DEBUGRegionPrint RegionPrint
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_debug.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_ops.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_ops.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_ops.h	(Revision 52145)
@@ -0,0 +1,141 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for primitive operation functions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_PRIM_OPS_H
+#define __X86EMU_PRIM_OPS_H
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+    u16 aaa_word(u16 d);
+    u16 aas_word(u16 d);
+    u16 aad_word(u16 d);
+    u16 aam_word(u8 d);
+    u8 adc_byte(u8 d, u8 s);
+    u16 adc_word(u16 d, u16 s);
+    u32 adc_long(u32 d, u32 s);
+    u8 add_byte(u8 d, u8 s);
+    u16 add_word(u16 d, u16 s);
+    u32 add_long(u32 d, u32 s);
+    u8 and_byte(u8 d, u8 s);
+    u16 and_word(u16 d, u16 s);
+    u32 and_long(u32 d, u32 s);
+    u8 cmp_byte(u8 d, u8 s);
+    u16 cmp_word(u16 d, u16 s);
+    u32 cmp_long(u32 d, u32 s);
+    u8 daa_byte(u8 d);
+    u8 das_byte(u8 d);
+    u8 dec_byte(u8 d);
+    u16 dec_word(u16 d);
+    u32 dec_long(u32 d);
+    u8 inc_byte(u8 d);
+    u16 inc_word(u16 d);
+    u32 inc_long(u32 d);
+    u8 or_byte(u8 d, u8 s);
+    u16 or_word(u16 d, u16 s);
+    u32 or_long(u32 d, u32 s);
+    u8 neg_byte(u8 s);
+    u16 neg_word(u16 s);
+    u32 neg_long(u32 s);
+    u8 not_byte(u8 s);
+    u16 not_word(u16 s);
+    u32 not_long(u32 s);
+    u8 rcl_byte(u8 d, u8 s);
+    u16 rcl_word(u16 d, u8 s);
+    u32 rcl_long(u32 d, u8 s);
+    u8 rcr_byte(u8 d, u8 s);
+    u16 rcr_word(u16 d, u8 s);
+    u32 rcr_long(u32 d, u8 s);
+    u8 rol_byte(u8 d, u8 s);
+    u16 rol_word(u16 d, u8 s);
+    u32 rol_long(u32 d, u8 s);
+    u8 ror_byte(u8 d, u8 s);
+    u16 ror_word(u16 d, u8 s);
+    u32 ror_long(u32 d, u8 s);
+    u8 shl_byte(u8 d, u8 s);
+    u16 shl_word(u16 d, u8 s);
+    u32 shl_long(u32 d, u8 s);
+    u8 shr_byte(u8 d, u8 s);
+    u16 shr_word(u16 d, u8 s);
+    u32 shr_long(u32 d, u8 s);
+    u8 sar_byte(u8 d, u8 s);
+    u16 sar_word(u16 d, u8 s);
+    u32 sar_long(u32 d, u8 s);
+    u16 shld_word(u16 d, u16 fill, u8 s);
+    u32 shld_long(u32 d, u32 fill, u8 s);
+    u16 shrd_word(u16 d, u16 fill, u8 s);
+    u32 shrd_long(u32 d, u32 fill, u8 s);
+    u8 sbb_byte(u8 d, u8 s);
+    u16 sbb_word(u16 d, u16 s);
+    u32 sbb_long(u32 d, u32 s);
+    u8 sub_byte(u8 d, u8 s);
+    u16 sub_word(u16 d, u16 s);
+    u32 sub_long(u32 d, u32 s);
+    void test_byte(u8 d, u8 s);
+    void test_word(u16 d, u16 s);
+    void test_long(u32 d, u32 s);
+    u8 xor_byte(u8 d, u8 s);
+    u16 xor_word(u16 d, u16 s);
+    u32 xor_long(u32 d, u32 s);
+    void imul_byte(u8 s);
+    void imul_word(u16 s);
+    void imul_long(u32 s);
+    void imul_long_direct(u32 * res_lo, u32 * res_hi, u32 d, u32 s);
+    void mul_byte(u8 s);
+    void mul_word(u16 s);
+    void mul_long(u32 s);
+    void idiv_byte(u8 s);
+    void idiv_word(u16 s);
+    void idiv_long(u32 s);
+    void div_byte(u8 s);
+    void div_word(u16 s);
+    void div_long(u32 s);
+    void ins(int size);
+    void outs(int size);
+    u16 mem_access_word(int addr);
+    void push_word(u16 w);
+    void push_long(u32 w);
+    u16 pop_word(void);
+    u32 pop_long(void);
+    void cpuid(void);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_PRIM_OPS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_ops.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXsrv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXsrv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXsrv.h	(Revision 52145)
@@ -0,0 +1,63 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _PANORAMIXSRV_H_
+#define _PANORAMIXSRV_H_
+
+#include "panoramiX.h"
+
+extern _X_EXPORT int PanoramiXNumScreens;
+extern _X_EXPORT int PanoramiXPixWidth;
+extern _X_EXPORT int PanoramiXPixHeight;
+extern _X_EXPORT RegionRec PanoramiXScreenRegion;
+
+extern _X_EXPORT VisualID PanoramiXTranslateVisualID(int screen, VisualID orig);
+extern _X_EXPORT void PanoramiXConsolidate(void);
+extern _X_EXPORT Bool PanoramiXCreateConnectionBlock(void);
+extern _X_EXPORT PanoramiXRes *PanoramiXFindIDByScrnum(RESTYPE, XID, int);
+extern _X_EXPORT Bool
+XineramaRegisterConnectionBlockCallback(void (*func) (void));
+extern _X_EXPORT int XineramaDeleteResource(void *, XID);
+
+extern _X_EXPORT void XineramaReinitData(void);
+
+extern _X_EXPORT RESTYPE XRC_DRAWABLE;
+extern _X_EXPORT RESTYPE XRT_WINDOW;
+extern _X_EXPORT RESTYPE XRT_PIXMAP;
+extern _X_EXPORT RESTYPE XRT_GC;
+extern _X_EXPORT RESTYPE XRT_COLORMAP;
+extern _X_EXPORT RESTYPE XRT_PICTURE;
+
+/*
+ * Drivers are allowed to wrap this function.  Each wrapper can decide that the
+ * two visuals are unequal, but if they are deemed equal, the wrapper must call
+ * down and return FALSE if the wrapped function does.  This ensures that all
+ * layers agree that the visuals are equal.  The first visual is always from
+ * screen 0.
+ */
+typedef Bool (*XineramaVisualsEqualProcPtr) (VisualPtr, ScreenPtr, VisualPtr);
+extern _X_EXPORT XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr;
+
+extern _X_EXPORT void XineramaGetImageData(DrawablePtr *pDrawables,
+                                           int left,
+                                           int top,
+                                           int width,
+                                           int height,
+                                           unsigned int format,
+                                           unsigned long planemask,
+                                           char *data, int pitch, Bool isRoot);
+
+static inline void
+panoramix_setup_ids(PanoramiXRes * resource, ClientPtr client, XID base_id)
+{
+    int j;
+
+    resource->info[0].id = base_id;
+    FOR_NSCREENS_FORWARD_SKIP(j) {
+        resource->info[j].id = FakeClientID(client->index);
+    }
+}
+
+#endif                          /* _PANORAMIXSRV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/panoramiXsrv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/callback.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/callback.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/callback.h	(Revision 52145)
@@ -0,0 +1,91 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CALLBACK_H
+#define CALLBACK_H
+
+#include <X11/X.h>              /* for GContext, Mask */
+#include <X11/Xdefs.h>          /* for Bool */
+#include <X11/Xproto.h>
+#include <X11/Xfuncproto.h>
+
+/*
+ *  callback manager stuff
+ */
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr;  /* also in misc.h */
+
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef void (*CallbackProcPtr) (CallbackListPtr *, void *, void *);
+
+extern _X_EXPORT Bool AddCallback(CallbackListPtr * /*pcbl */ ,
+                                  CallbackProcPtr /*callback */ ,
+                                  void */*data */ );
+
+extern _X_EXPORT Bool DeleteCallback(CallbackListPtr * /*pcbl */ ,
+                                     CallbackProcPtr /*callback */ ,
+                                     void */*data */ );
+
+extern _X_EXPORT void _CallCallbacks(CallbackListPtr * /*pcbl */ ,
+                                     void */*call_data */ );
+
+static inline void
+CallCallbacks(CallbackListPtr *pcbl, void *call_data)
+{
+    if (!pcbl || !*pcbl)
+        return;
+    _CallCallbacks(pcbl, call_data);
+}
+
+extern _X_EXPORT void DeleteCallbackList(CallbackListPtr * /*pcbl */ );
+
+extern _X_EXPORT void InitCallbackManager(void);
+extern _X_EXPORT void DeleteCallbackManager(void);
+
+#endif                          /* CALLBACK_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/callback.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micoord.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micoord.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micoord.h	(Revision 52145)
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2000 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from the
+ * XFree86 Project.
+ *
+ */
+
+#ifndef _MICOORD_H_
+#define _MICOORD_H_ 1
+
+#include "servermd.h"
+
+/* Macros which handle a coordinate in a single register */
+
+/*
+ * Most compilers will convert divisions by 65536 into shifts, if signed
+ * shifts exist.  If your machine does arithmetic shifts and your compiler
+ * can't get it right, add to this line.
+ */
+
+/*
+ * mips compiler - what a joke - it CSEs the 65536 constant into a reg
+ * forcing as to use div instead of shift.  Let's be explicit.
+ */
+
+#if defined(mips) || \
+    defined(sparc) || defined(__sparc64__) || \
+    defined(__alpha) || defined(__alpha__) || \
+    defined(__i386__) || defined(__i386) || defined(__ia64__) || \
+    defined(__s390x__) || defined(__s390__) || \
+    defined(__amd64__) || defined(amd64) || defined(__amd64)
+#define GetHighWord(x) (((int) (x)) >> 16)
+#else
+#define GetHighWord(x) (((int) (x)) / 65536)
+#endif
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define intToCoord(i,x,y)   (((x) = GetHighWord(i)), ((y) = (int) ((short) (i))))
+#define coordToInt(x,y)	(((x) << 16) | ((y) & 0xffff))
+#define intToX(i)	(GetHighWord(i))
+#define intToY(i)	((int) ((short) i))
+#else
+#define intToCoord(i,x,y)   (((x) = (int) ((short) (i))), ((y) = GetHighWord(i)))
+#define coordToInt(x,y)	(((y) << 16) | ((x) & 0xffff))
+#define intToX(i)	((int) ((short) (i)))
+#define intToY(i)	(GetHighWord(i))
+#endif
+
+#endif                          /* _MICOORD_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micoord.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/randrstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/randrstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/randrstr.h	(Revision 52145)
@@ -0,0 +1,1056 @@
+/*
+ * Copyright ¬© 2000 Compaq Computer Corporation
+ * Copyright ¬© 2002 Hewlett-Packard Company
+ * Copyright ¬© 2006 Intel Corporation
+ * Copyright ¬© 2008 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _RANDRSTR_H_
+#define _RANDRSTR_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "resource.h"
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "pixmapstr.h"
+#include "extnsionst.h"
+#include "servermd.h"
+#include "rrtransform.h"
+#include <X11/extensions/randr.h>
+#include <X11/extensions/randrproto.h>
+#include <X11/extensions/render.h>      /* we share subpixel order information */
+#include "picturestr.h"
+#include <X11/Xfuncproto.h>
+
+/* required for ABI compatibility for now */
+#define RANDR_10_INTERFACE 1
+#define RANDR_12_INTERFACE 1
+#define RANDR_13_INTERFACE 1    /* requires RANDR_12_INTERFACE */
+#define RANDR_GET_CRTC_INTERFACE 1
+
+#define RANDR_INTERFACE_VERSION 0x0104
+
+typedef XID RRMode;
+typedef XID RROutput;
+typedef XID RRCrtc;
+typedef XID RRProvider;
+
+extern _X_EXPORT int RREventBase, RRErrorBase;
+
+extern _X_EXPORT int (*ProcRandrVector[RRNumberRequests]) (ClientPtr);
+extern _X_EXPORT int (*SProcRandrVector[RRNumberRequests]) (ClientPtr);
+
+/*
+ * Modeline for a monitor. Name follows directly after this struct
+ */
+
+#define RRModeName(pMode) ((char *) (pMode + 1))
+typedef struct _rrMode RRModeRec, *RRModePtr;
+typedef struct _rrPropertyValue RRPropertyValueRec, *RRPropertyValuePtr;
+typedef struct _rrProperty RRPropertyRec, *RRPropertyPtr;
+typedef struct _rrCrtc RRCrtcRec, *RRCrtcPtr;
+typedef struct _rrOutput RROutputRec, *RROutputPtr;
+typedef struct _rrProvider RRProviderRec, *RRProviderPtr;
+
+struct _rrMode {
+    int refcnt;
+    xRRModeInfo mode;
+    char *name;
+    ScreenPtr userScreen;
+};
+
+struct _rrPropertyValue {
+    Atom type;                  /* ignored by server */
+    short format;               /* format of data for swapping - 8,16,32 */
+    long size;                  /* size of data in (format/8) bytes */
+    void *data;                 /* private to client */
+};
+
+struct _rrProperty {
+    RRPropertyPtr next;
+    ATOM propertyName;
+    Bool is_pending;
+    Bool range;
+    Bool immutable;
+    int num_valid;
+    INT32 *valid_values;
+    RRPropertyValueRec current, pending;
+};
+
+struct _rrCrtc {
+    RRCrtc id;
+    ScreenPtr pScreen;
+    RRModePtr mode;
+    int x, y;
+    Rotation rotation;
+    Rotation rotations;
+    Bool changed;
+    int numOutputs;
+    RROutputPtr *outputs;
+    int gammaSize;
+    CARD16 *gammaRed;
+    CARD16 *gammaBlue;
+    CARD16 *gammaGreen;
+    void *devPrivate;
+    Bool transforms;
+    RRTransformRec client_pending_transform;
+    RRTransformRec client_current_transform;
+    PictTransform transform;
+    struct pict_f_transform f_transform;
+    struct pict_f_transform f_inverse;
+
+    PixmapPtr scanout_pixmap;
+};
+
+struct _rrOutput {
+    RROutput id;
+    ScreenPtr pScreen;
+    char *name;
+    int nameLength;
+    CARD8 connection;
+    CARD8 subpixelOrder;
+    int mmWidth;
+    int mmHeight;
+    RRCrtcPtr crtc;
+    int numCrtcs;
+    RRCrtcPtr *crtcs;
+    int numClones;
+    RROutputPtr *clones;
+    int numModes;
+    int numPreferred;
+    RRModePtr *modes;
+    int numUserModes;
+    RRModePtr *userModes;
+    Bool changed;
+    RRPropertyPtr properties;
+    Bool pendingProperties;
+    void *devPrivate;
+};
+
+struct _rrProvider {
+    RRProvider id;
+    ScreenPtr pScreen;
+    uint32_t capabilities;
+    char *name;
+    int nameLength;
+    RRPropertyPtr properties;
+    Bool pendingProperties;
+    Bool changed;
+    struct _rrProvider *offload_sink;
+    struct _rrProvider *output_source;
+};
+
+#if RANDR_12_INTERFACE
+typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr pScreen,
+                                        CARD16 width,
+                                        CARD16 height,
+                                        CARD32 mmWidth, CARD32 mmHeight);
+
+typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr pScreen,
+                                  RRCrtcPtr crtc,
+                                  RRModePtr mode,
+                                  int x,
+                                  int y,
+                                  Rotation rotation,
+                                  int numOutputs, RROutputPtr * outputs);
+
+typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);
+
+typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr pScreen, RRCrtcPtr crtc);
+
+typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr pScreen,
+                                            RROutputPtr output,
+                                            Atom property,
+                                            RRPropertyValuePtr value);
+
+typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr pScreen,
+                                             RROutputPtr output,
+                                             RRModePtr mode);
+
+typedef void (*RRModeDestroyProcPtr) (ScreenPtr pScreen, RRModePtr mode);
+
+#endif
+
+#if RANDR_13_INTERFACE
+typedef Bool (*RROutputGetPropertyProcPtr) (ScreenPtr pScreen,
+                                            RROutputPtr output, Atom property);
+typedef Bool (*RRGetPanningProcPtr) (ScreenPtr pScrn,
+                                     RRCrtcPtr crtc,
+                                     BoxPtr totalArea,
+                                     BoxPtr trackingArea, INT16 *border);
+typedef Bool (*RRSetPanningProcPtr) (ScreenPtr pScrn,
+                                     RRCrtcPtr crtc,
+                                     BoxPtr totalArea,
+                                     BoxPtr trackingArea, INT16 *border);
+
+#endif                          /* RANDR_13_INTERFACE */
+
+typedef Bool (*RRProviderGetPropertyProcPtr) (ScreenPtr pScreen,
+                                            RRProviderPtr provider, Atom property);
+typedef Bool (*RRProviderSetPropertyProcPtr) (ScreenPtr pScreen,
+                                              RRProviderPtr provider,
+                                              Atom property,
+                                              RRPropertyValuePtr value);
+
+typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation * rotations);
+typedef Bool (*RRCloseScreenProcPtr) (ScreenPtr pscreen);
+
+typedef Bool (*RRProviderSetOutputSourceProcPtr)(ScreenPtr pScreen,
+                                          RRProviderPtr provider,
+                                          RRProviderPtr output_source);
+
+typedef Bool (*RRProviderSetOffloadSinkProcPtr)(ScreenPtr pScreen,
+                                         RRProviderPtr provider,
+                                         RRProviderPtr offload_sink);
+
+
+typedef void (*RRProviderDestroyProcPtr)(ScreenPtr pScreen,
+                                         RRProviderPtr provider);
+
+/* These are for 1.0 compatibility */
+
+typedef struct _rrRefresh {
+    CARD16 rate;
+    RRModePtr mode;
+} RRScreenRate, *RRScreenRatePtr;
+
+typedef struct _rrScreenSize {
+    int id;
+    short width, height;
+    short mmWidth, mmHeight;
+    int nRates;
+    RRScreenRatePtr pRates;
+} RRScreenSize, *RRScreenSizePtr;
+
+#ifdef RANDR_10_INTERFACE
+
+typedef Bool (*RRSetConfigProcPtr) (ScreenPtr pScreen,
+                                    Rotation rotation,
+                                    int rate, RRScreenSizePtr pSize);
+
+#endif
+
+typedef Bool (*RRCrtcSetScanoutPixmapProcPtr)(RRCrtcPtr crtc, PixmapPtr pixmap);
+
+typedef struct _rrScrPriv {
+    /*
+     * 'public' part of the structure; DDXen fill this in
+     * as they initialize
+     */
+#if RANDR_10_INTERFACE
+    RRSetConfigProcPtr rrSetConfig;
+#endif
+    RRGetInfoProcPtr rrGetInfo;
+#if RANDR_12_INTERFACE
+    RRScreenSetSizeProcPtr rrScreenSetSize;
+    RRCrtcSetProcPtr rrCrtcSet;
+    RRCrtcSetGammaProcPtr rrCrtcSetGamma;
+    RRCrtcGetGammaProcPtr rrCrtcGetGamma;
+    RROutputSetPropertyProcPtr rrOutputSetProperty;
+    RROutputValidateModeProcPtr rrOutputValidateMode;
+    RRModeDestroyProcPtr rrModeDestroy;
+#endif
+#if RANDR_13_INTERFACE
+    RROutputGetPropertyProcPtr rrOutputGetProperty;
+    RRGetPanningProcPtr rrGetPanning;
+    RRSetPanningProcPtr rrSetPanning;
+#endif
+    /* TODO #if RANDR_15_INTERFACE */
+    RRCrtcSetScanoutPixmapProcPtr rrCrtcSetScanoutPixmap;
+
+    RRProviderSetOutputSourceProcPtr rrProviderSetOutputSource;
+    RRProviderSetOffloadSinkProcPtr rrProviderSetOffloadSink;
+    RRProviderGetPropertyProcPtr rrProviderGetProperty;
+    RRProviderSetPropertyProcPtr rrProviderSetProperty;
+    /*
+     * Private part of the structure; not considered part of the ABI
+     */
+    TimeStamp lastSetTime;      /* last changed by client */
+    TimeStamp lastConfigTime;   /* possible configs changed */
+    RRCloseScreenProcPtr CloseScreen;
+
+    Bool changed;               /* some config changed */
+    Bool configChanged;         /* configuration changed */
+    Bool layoutChanged;         /* screen layout changed */
+    Bool resourcesChanged;      /* screen resources change */
+
+    CARD16 minWidth, minHeight;
+    CARD16 maxWidth, maxHeight;
+    CARD16 width, height;       /* last known screen size */
+    CARD16 mmWidth, mmHeight;   /* last known screen size */
+
+    int numOutputs;
+    RROutputPtr *outputs;
+    RROutputPtr primaryOutput;
+
+    int numCrtcs;
+    RRCrtcPtr *crtcs;
+
+    /* Last known pointer position */
+    RRCrtcPtr pointerCrtc;
+
+#ifdef RANDR_10_INTERFACE
+    /*
+     * Configuration information
+     */
+    Rotation rotations;
+    CARD16 reqWidth, reqHeight;
+
+    int nSizes;
+    RRScreenSizePtr pSizes;
+
+    Rotation rotation;
+    int rate;
+    int size;
+#endif
+    Bool discontiguous;
+
+    RRProviderPtr provider;
+
+    RRProviderDestroyProcPtr rrProviderDestroy;
+
+} rrScrPrivRec, *rrScrPrivPtr;
+
+extern _X_EXPORT DevPrivateKeyRec rrPrivKeyRec;
+
+#define rrPrivKey (&rrPrivKeyRec)
+
+#define rrGetScrPriv(pScr)  ((rrScrPrivPtr)dixLookupPrivate(&(pScr)->devPrivates, rrPrivKey))
+#define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
+#define SetRRScreen(s,p) dixSetPrivate(&(s)->devPrivates, rrPrivKey, p)
+
+/*
+ * each window has a list of clients requesting
+ * RRNotify events.  Each client has a resource
+ * for each window it selects RRNotify input for,
+ * this resource is used to delete the RRNotifyRec
+ * entry from the per-window queue.
+ */
+
+typedef struct _RREvent *RREventPtr;
+
+typedef struct _RREvent {
+    RREventPtr next;
+    ClientPtr client;
+    WindowPtr window;
+    XID clientResource;
+    int mask;
+} RREventRec;
+
+typedef struct _RRTimes {
+    TimeStamp setTime;
+    TimeStamp configTime;
+} RRTimesRec, *RRTimesPtr;
+
+typedef struct _RRClient {
+    int major_version;
+    int minor_version;
+/*  RRTimesRec	times[0]; */
+} RRClientRec, *RRClientPtr;
+
+extern _X_EXPORT RESTYPE RRClientType, RREventType;     /* resource types for event masks */
+extern _X_EXPORT DevPrivateKeyRec RRClientPrivateKeyRec;
+
+#define RRClientPrivateKey (&RRClientPrivateKeyRec)
+extern _X_EXPORT RESTYPE RRCrtcType, RRModeType, RROutputType, RRProviderType;
+
+#define VERIFY_RR_OUTPUT(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((void **)&(ptr), id,\
+	                                 RROutputType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define VERIFY_RR_CRTC(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((void **)&(ptr), id,\
+	                                 RRCrtcType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define VERIFY_RR_MODE(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((void **)&(ptr), id,\
+	                                 RRModeType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define VERIFY_RR_PROVIDER(id, ptr, a)\
+    {\
+        int rc = dixLookupResourceByType((void **)&(ptr), id,\
+                                         RRProviderType, client, a);\
+        if (rc != Success) {\
+            client->errorValue = id;\
+            return rc;\
+        }\
+    }
+
+#define GetRRClient(pClient)    ((RRClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RRClientPrivateKey))
+#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)
+
+#ifdef RANDR_12_INTERFACE
+/*
+ * Set the range of sizes for the screen
+ */
+extern _X_EXPORT void
+
+RRScreenSetSizeRange(ScreenPtr pScreen,
+                     CARD16 minWidth,
+                     CARD16 minHeight, CARD16 maxWidth, CARD16 maxHeight);
+#endif
+
+/* rrscreen.c */
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+extern _X_EXPORT void
+ RRScreenSizeNotify(ScreenPtr pScreen);
+
+/*
+ * Request that the screen be resized
+ */
+extern _X_EXPORT Bool
+
+RRScreenSizeSet(ScreenPtr pScreen,
+                CARD16 width, CARD16 height, CARD32 mmWidth, CARD32 mmHeight);
+
+/*
+ * Send ConfigureNotify event to root window when 'something' happens
+ */
+extern _X_EXPORT void
+ RRSendConfigNotify(ScreenPtr pScreen);
+
+/*
+ * screen dispatch
+ */
+extern _X_EXPORT int
+ ProcRRGetScreenSizeRange(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetScreenSize(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetScreenResources(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetScreenResourcesCurrent(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetScreenConfig(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetScreenInfo(ClientPtr client);
+
+/*
+ * Deliver a ScreenNotify event
+ */
+extern _X_EXPORT void
+ RRDeliverScreenEvent(ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ RRResourcesChanged(ScreenPtr pScreen);
+
+/* randr.c */
+/* set a screen change on the primary screen */
+extern _X_EXPORT void
+RRSetChanged(ScreenPtr pScreen);
+
+/*
+ * Send all pending events
+ */
+extern _X_EXPORT void
+ RRTellChanged(ScreenPtr pScreen);
+
+/*
+ * Poll the driver for changed information
+ */
+extern _X_EXPORT Bool
+ RRGetInfo(ScreenPtr pScreen, Bool force_query);
+
+extern _X_EXPORT Bool RRInit(void);
+
+extern _X_EXPORT Bool RRScreenInit(ScreenPtr pScreen);
+
+extern _X_EXPORT RROutputPtr RRFirstOutput(ScreenPtr pScreen);
+
+extern _X_EXPORT CARD16
+ RRVerticalRefresh(xRRModeInfo * mode);
+
+#ifdef RANDR_10_INTERFACE
+/*
+ * This is the old interface, deprecated but left
+ * around for compatibility
+ */
+
+/*
+ * Then, register the specific size with the screen
+ */
+
+extern _X_EXPORT RRScreenSizePtr
+RRRegisterSize(ScreenPtr pScreen,
+               short width, short height, short mmWidth, short mmHeight);
+
+extern _X_EXPORT Bool
+ RRRegisterRate(ScreenPtr pScreen, RRScreenSizePtr pSize, int rate);
+
+/*
+ * Finally, set the current configuration of the screen
+ */
+
+extern _X_EXPORT void
+
+RRSetCurrentConfig(ScreenPtr pScreen,
+                   Rotation rotation, int rate, RRScreenSizePtr pSize);
+
+extern _X_EXPORT Rotation RRGetRotation(ScreenPtr pScreen);
+
+#endif
+
+/* rrcrtc.c */
+
+/*
+ * Notify the CRTC of some change; layoutChanged indicates that
+ * some position or size element changed
+ */
+extern _X_EXPORT void
+ RRCrtcChanged(RRCrtcPtr crtc, Bool layoutChanged);
+
+/*
+ * Create a CRTC
+ */
+extern _X_EXPORT RRCrtcPtr RRCrtcCreate(ScreenPtr pScreen, void *devPrivate);
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+extern _X_EXPORT void
+ RRCrtcSetRotations(RRCrtcPtr crtc, Rotation rotations);
+
+/*
+ * Set whether transforms are allowed on a CRTC
+ */
+extern _X_EXPORT void
+ RRCrtcSetTransformSupport(RRCrtcPtr crtc, Bool transforms);
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
+extern _X_EXPORT Bool
+
+RRCrtcNotify(RRCrtcPtr crtc,
+             RRModePtr mode,
+             int x,
+             int y,
+             Rotation rotation,
+             RRTransformPtr transform, int numOutputs, RROutputPtr * outputs);
+
+extern _X_EXPORT void
+ RRDeliverCrtcEvent(ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
+
+/*
+ * Request that the Crtc be reconfigured
+ */
+extern _X_EXPORT Bool
+
+RRCrtcSet(RRCrtcPtr crtc,
+          RRModePtr mode,
+          int x,
+          int y, Rotation rotation, int numOutput, RROutputPtr * outputs);
+
+/*
+ * Request that the Crtc gamma be changed
+ */
+
+extern _X_EXPORT Bool
+ RRCrtcGammaSet(RRCrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue);
+
+/*
+ * Request current gamma back from the DDX (if possible).
+ * This includes gamma size.
+ */
+
+extern _X_EXPORT Bool
+ RRCrtcGammaGet(RRCrtcPtr crtc);
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
+
+extern _X_EXPORT Bool
+ RRCrtcGammaNotify(RRCrtcPtr crtc);
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+extern _X_EXPORT Bool
+ RRCrtcGammaSetSize(RRCrtcPtr crtc, int size);
+
+/*
+ * Return the area of the frame buffer scanned out by the crtc,
+ * taking into account the current mode and rotation
+ */
+
+extern _X_EXPORT void
+ RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);
+
+/*
+ * Return crtc transform
+ */
+extern _X_EXPORT RRTransformPtr RRCrtcGetTransform(RRCrtcPtr crtc);
+
+/*
+ * Check whether the pending and current transforms are the same
+ */
+extern _X_EXPORT Bool
+ RRCrtcPendingTransform(RRCrtcPtr crtc);
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+extern _X_EXPORT void
+ RRCrtcDestroy(RRCrtcPtr crtc);
+
+/*
+ * Set the pending CRTC transformation
+ */
+
+extern _X_EXPORT int
+
+RRCrtcTransformSet(RRCrtcPtr crtc,
+                   PictTransformPtr transform,
+                   struct pict_f_transform *f_transform,
+                   struct pict_f_transform *f_inverse,
+                   char *filter, int filter_len, xFixed * params, int nparams);
+
+/*
+ * Initialize crtc type
+ */
+extern _X_EXPORT Bool
+ RRCrtcInit(void);
+
+/*
+ * Initialize crtc type error value
+ */
+extern _X_EXPORT void
+ RRCrtcInitErrorValue(void);
+
+/*
+ * Detach and free a scanout pixmap
+ */
+extern _X_EXPORT void
+ RRCrtcDetachScanoutPixmap(RRCrtcPtr crtc);
+
+extern _X_EXPORT Bool
+ RRReplaceScanoutPixmap(DrawablePtr pDrawable, PixmapPtr pPixmap, Bool enable);
+
+/*
+ * Crtc dispatch
+ */
+
+extern _X_EXPORT int
+ ProcRRGetCrtcInfo(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetCrtcConfig(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetCrtcGammaSize(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetCrtcGamma(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetCrtcGamma(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetCrtcTransform(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetCrtcTransform(ClientPtr client);
+
+int
+ ProcRRGetPanning(ClientPtr client);
+
+int
+ ProcRRSetPanning(ClientPtr client);
+
+void
+ RRConstrainCursorHarder(DeviceIntPtr, ScreenPtr, int, int *, int *);
+
+/* rrdispatch.c */
+extern _X_EXPORT Bool
+ RRClientKnowsRates(ClientPtr pClient);
+
+/* rrmode.c */
+/*
+ * Find, and if necessary, create a mode
+ */
+
+extern _X_EXPORT RRModePtr RRModeGet(xRRModeInfo * modeInfo, const char *name);
+
+/*
+ * Destroy a mode.
+ */
+
+extern _X_EXPORT void
+ RRModeDestroy(RRModePtr mode);
+
+/*
+ * Return a list of modes that are valid for some output in pScreen
+ */
+extern _X_EXPORT RRModePtr *RRModesForScreen(ScreenPtr pScreen, int *num_ret);
+
+/*
+ * Initialize mode type
+ */
+extern _X_EXPORT Bool
+ RRModeInit(void);
+
+/*
+ * Initialize mode type error value
+ */
+extern _X_EXPORT void
+ RRModeInitErrorValue(void);
+
+extern _X_EXPORT int
+ ProcRRCreateMode(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRDestroyMode(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRAddOutputMode(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRDeleteOutputMode(ClientPtr client);
+
+/* rroutput.c */
+
+/*
+ * Notify the output of some change. configChanged indicates whether
+ * any external configuration (mode list, clones, connected status)
+ * has changed, or whether the change was strictly internal
+ * (which crtc is in use)
+ */
+extern _X_EXPORT void
+ RROutputChanged(RROutputPtr output, Bool configChanged);
+
+/*
+ * Create an output
+ */
+
+extern _X_EXPORT RROutputPtr
+RROutputCreate(ScreenPtr pScreen,
+               const char *name, int nameLength, void *devPrivate);
+
+/*
+ * Notify extension that output parameters have been changed
+ */
+extern _X_EXPORT Bool
+ RROutputSetClones(RROutputPtr output, RROutputPtr * clones, int numClones);
+
+extern _X_EXPORT Bool
+
+RROutputSetModes(RROutputPtr output,
+                 RRModePtr * modes, int numModes, int numPreferred);
+
+extern _X_EXPORT int
+ RROutputAddUserMode(RROutputPtr output, RRModePtr mode);
+
+extern _X_EXPORT int
+ RROutputDeleteUserMode(RROutputPtr output, RRModePtr mode);
+
+extern _X_EXPORT Bool
+ RROutputSetCrtcs(RROutputPtr output, RRCrtcPtr * crtcs, int numCrtcs);
+
+extern _X_EXPORT Bool
+ RROutputSetConnection(RROutputPtr output, CARD8 connection);
+
+extern _X_EXPORT Bool
+ RROutputSetSubpixelOrder(RROutputPtr output, int subpixelOrder);
+
+extern _X_EXPORT Bool
+ RROutputSetPhysicalSize(RROutputPtr output, int mmWidth, int mmHeight);
+
+extern _X_EXPORT void
+ RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);
+
+extern _X_EXPORT void
+ RROutputDestroy(RROutputPtr output);
+
+extern _X_EXPORT int
+ ProcRRGetOutputInfo(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRSetOutputPrimary(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetOutputPrimary(ClientPtr client);
+
+/*
+ * Initialize output type
+ */
+extern _X_EXPORT Bool
+ RROutputInit(void);
+
+/*
+ * Initialize output type error value
+ */
+extern _X_EXPORT void
+ RROutputInitErrorValue(void);
+
+/* rrpointer.c */
+extern _X_EXPORT void
+ RRPointerMoved(ScreenPtr pScreen, int x, int y);
+
+extern _X_EXPORT void
+ RRPointerScreenConfigured(ScreenPtr pScreen);
+
+/* rrproperty.c */
+
+extern _X_EXPORT void
+ RRDeleteAllOutputProperties(RROutputPtr output);
+
+extern _X_EXPORT RRPropertyValuePtr
+RRGetOutputProperty(RROutputPtr output, Atom property, Bool pending);
+
+extern _X_EXPORT RRPropertyPtr
+RRQueryOutputProperty(RROutputPtr output, Atom property);
+
+extern _X_EXPORT void
+ RRDeleteOutputProperty(RROutputPtr output, Atom property);
+
+extern _X_EXPORT Bool
+ RRPostPendingProperties(RROutputPtr output);
+
+extern _X_EXPORT int
+
+RRChangeOutputProperty(RROutputPtr output, Atom property, Atom type,
+                       int format, int mode, unsigned long len,
+                       void *value, Bool sendevent, Bool pending);
+
+extern _X_EXPORT int
+
+RRConfigureOutputProperty(RROutputPtr output, Atom property,
+                          Bool pending, Bool range, Bool immutable,
+                          int num_values, INT32 *values);
+extern _X_EXPORT int
+ ProcRRChangeOutputProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRGetOutputProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRListOutputProperties(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRQueryOutputProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRConfigureOutputProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRDeleteOutputProperty(ClientPtr client);
+
+/* rrprovider.c */
+extern _X_EXPORT void
+RRProviderInitErrorValue(void);
+
+extern _X_EXPORT int
+ProcRRGetProviders(ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetProviderInfo(ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetProviderOutputSource(ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetProviderOffloadSink(ClientPtr client);
+
+extern _X_EXPORT Bool
+RRProviderInit(void);
+
+extern _X_EXPORT RRProviderPtr
+RRProviderCreate(ScreenPtr pScreen, const char *name,
+                 int nameLength);
+
+extern _X_EXPORT void
+RRProviderDestroy (RRProviderPtr provider);
+
+extern _X_EXPORT void
+RRProviderSetCapabilities(RRProviderPtr provider, uint32_t capabilities);
+
+extern _X_EXPORT Bool
+RRProviderLookup(XID id, RRProviderPtr *provider_p);
+
+extern _X_EXPORT void
+RRDeliverProviderEvent(ClientPtr client, WindowPtr pWin, RRProviderPtr provider);
+
+/* rrproviderproperty.c */
+
+extern _X_EXPORT void
+ RRDeleteAllProviderProperties(RRProviderPtr provider);
+
+extern _X_EXPORT RRPropertyValuePtr
+ RRGetProviderProperty(RRProviderPtr provider, Atom property, Bool pending);
+
+extern _X_EXPORT RRPropertyPtr
+ RRQueryProviderProperty(RRProviderPtr provider, Atom property);
+
+extern _X_EXPORT void
+ RRDeleteProviderProperty(RRProviderPtr provider, Atom property);
+
+extern _X_EXPORT int
+RRChangeProviderProperty(RRProviderPtr provider, Atom property, Atom type,
+                       int format, int mode, unsigned long len,
+                       void *value, Bool sendevent, Bool pending);
+
+extern _X_EXPORT int
+ RRConfigureProviderProperty(RRProviderPtr provider, Atom property,
+                             Bool pending, Bool range, Bool immutable,
+                             int num_values, INT32 *values);
+
+extern _X_EXPORT Bool
+ RRPostProviderPendingProperties(RRProviderPtr provider);
+
+extern _X_EXPORT int
+ ProcRRGetProviderProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRListProviderProperties(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRQueryProviderProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRConfigureProviderProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRChangeProviderProperty(ClientPtr client);
+
+extern _X_EXPORT int
+ ProcRRDeleteProviderProperty(ClientPtr client);
+/* rrxinerama.c */
+#ifdef XINERAMA
+extern _X_EXPORT void
+ RRXineramaExtensionInit(void);
+#endif
+
+#endif                          /* _RANDRSTR_H_ */
+
+/*
+ 
+randr extension implementation structure
+
+Query state:
+    ProcRRGetScreenInfo/ProcRRGetScreenResources
+	RRGetInfo
+ 
+	    ‚Ä¢ Request configuration from driver, either 1.0 or 1.2 style
+	    ‚Ä¢ These functions only record state changes, all
+	      other actions are pended until RRTellChanged is called
+ 
+	    ->rrGetInfo
+	    1.0:
+		RRRegisterSize
+		RRRegisterRate
+		RRSetCurrentConfig
+	    1.2:
+		RRScreenSetSizeRange
+		RROutputSetCrtcs
+		RRModeGet
+		RROutputSetModes
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROutputSetClones
+		RRCrtcNotify
+ 
+	‚Ä¢ Must delay scanning configuration until after ->rrGetInfo returns
+	  because some drivers will call SetCurrentConfig in the middle
+	  of the ->rrGetInfo operation.
+ 
+	1.0:
+
+	    ‚Ä¢ Scan old configuration, mirror to new structures
+ 
+	    RRScanOldConfig
+		RRCrtcCreate
+		RROutputCreate
+		RROutputSetCrtcs
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROldModeAdd	‚Ä¢ This adds modes one-at-a-time
+		    RRModeGet
+		RRCrtcNotify
+ 
+	‚Ä¢ send events, reset pointer if necessary
+ 
+	RRTellChanged
+	    WalkTree (sending events)
+ 
+	    ‚Ä¢ when layout has changed:
+		RRPointerScreenConfigured
+		RRSendConfigNotify
+ 
+Asynchronous state setting (1.2 only)
+    When setting state asynchronously, the driver invokes the
+    ->rrGetInfo function and then calls RRTellChanged to flush
+    the changes to the clients and reset pointer if necessary
+
+Set state
+
+    ProcRRSetScreenConfig
+	RRCrtcSet
+	    1.2:
+		->rrCrtcSet
+		    RRCrtcNotify
+	    1.0:
+		->rrSetConfig
+		RRCrtcNotify
+	    RRTellChanged
+ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/randrstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86pciBus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86pciBus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86pciBus.h	(Revision 52145)
@@ -0,0 +1,56 @@
+
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_PCI_BUS_H
+#define _XF86_PCI_BUS_H
+
+void xf86PciProbe(void);
+Bool xf86PciAddMatchingDev(DriverPtr drvp);
+Bool xf86PciProbeDev(DriverPtr drvp);
+void xf86PciIsolateDevice(const char *argument);
+int xf86PciMatchDriver(char *matches[], int nmatches);
+Bool xf86PciConfigure(void *busData, struct pci_device *pDev);
+void xf86PciConfigureNewDev(void *busData, struct pci_device *pVideo,
+                            GDevRec * GDev, int *chipset);
+
+#define MATCH_PCI_DEVICES(x, y) (((x)->domain == (y)->domain) &&        \
+                                 ((x)->bus == (y)->bus) &&              \
+                                 ((x)->func == (y)->func) &&            \
+                                 ((x)->dev == (y)->dev))
+
+int
+xf86MatchDriverFromFiles(uint16_t match_vendor, uint16_t match_chip,
+                         char *matches[], int nmatches);
+int
+xf86VideoPtrToDriverList(struct pci_device *dev,
+                         char *returnList[], int returnListMax);
+#endif                          /* _XF86_PCI_BUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86pciBus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-private.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-private.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-private.h	(Revision 52145)
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Private header file for USB support.  This file provides
+ * Linux-specific include files and the definition of the private
+ * structure.  \see usb-common.c \see usb-keyboard.c \see usb-mouse.c
+ * \see usb-other.c */
+
+#ifndef _USB_PRIVATE_H_
+#define _USB_PRIVATE_H_
+
+#include "dmxinputinit.h"
+#include "inputstr.h"
+#include <X11/Xos.h>
+#include <errno.h>
+#include <linux/input.h>
+#include "usb-common.h"
+
+                                /*  Support for force feedback was
+                                 *  introduced in Linxu 2.4.10 */
+#ifndef EV_MSC
+#define EV_MSC      0x04
+#endif
+#ifndef EV_FF
+#define EV_FF       0x15
+#endif
+#ifndef LED_SLEEP
+#define LED_SLEEP   0x05
+#endif
+#ifndef LED_SUSPEND
+#define LED_SUSPEND 0x06
+#endif
+#ifndef LED_MUTE
+#define LED_MUTE    0x07
+#endif
+#ifndef LED_MISC
+#define LED_MISC    0x08
+#endif
+#ifndef BTN_DEAD
+#define BTN_DEAD    0x12f
+#endif
+#ifndef BTN_THUMBL
+#define BTN_THUMBL  0x13d
+#endif
+#ifndef BTN_THUMBR
+#define BTN_THUMBR  0x13e
+#endif
+#ifndef MSC_SERIAL
+#define MSC_SERIAL  0x00
+#endif
+#ifndef MSC_MAX
+#define MSC_MAX     0x07
+#endif
+
+                                /* Support for older kernels. */
+#ifndef ABS_WHEEL
+#define ABS_WHEEL   0x08
+#endif
+#ifndef ABS_GAS
+#define ABS_GAS     0x09
+#endif
+#ifndef ABS_BRAKE
+#define ABS_BRAKE   0x0a
+#endif
+
+#define NUM_STATE_ENTRIES (256/32)
+
+/* Private area for USB devices. */
+typedef struct _myPrivate {
+    DeviceIntPtr pDevice;                   /**< Device (mouse or other) */
+    int fd;                                 /**< File descriptor */
+    unsigned char mask[EV_MAX / 8 + 1];     /**< Mask */
+    int numRel, numAbs, numLeds;            /**< Counts */
+    int relmap[REL_CNT];                    /**< Relative axis map */
+    int absmap[ABS_CNT];                    /**< Absolute axis map */
+
+    CARD32 kbdState[NUM_STATE_ENTRIES];         /**< Keyboard state */
+    DeviceIntPtr pKeyboard;                     /** Keyboard device */
+
+    int pitch;                  /**< Bell pitch  */
+    unsigned long duration;     /**< Bell duration */
+
+    /* FIXME: dmxInput is never initialized */
+    DMXInputInfo *dmxInput;     /**< For pretty-printing */
+} myPrivate;
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-private.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Xinput.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Xinput.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Xinput.h	(Revision 52145)
@@ -0,0 +1,212 @@
+/*
+ * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@XFree86.org>
+ *                                                                            
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is  hereby granted without fee, provided that
+ * the  above copyright   notice appear  in   all  copies and  that both  that
+ * copyright  notice   and   this  permission   notice  appear  in  supporting
+ * documentation, and that   the  name of  Frederic   Lepied not  be  used  in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific,  written      prior  permission.     Frederic  Lepied   makes  no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.                   
+ *                                                                            
+ * FREDERIC  LEPIED DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
+ * EVENT  SHALL FREDERIC  LEPIED BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
+ * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * Copyright (c) 2000-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _xf86Xinput_h
+#define _xf86Xinput_h
+
+#include "xf86str.h"
+#include "inputstr.h"
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XIproto.h>
+#include "XIstubs.h"
+
+/* Input device flags */
+#define XI86_ALWAYS_CORE	0x04    /* device always controls the pointer */
+/* the device sends Xinput and core pointer events */
+#define XI86_SEND_CORE_EVENTS	XI86_ALWAYS_CORE
+/* 0x08 is reserved for legacy XI86_SEND_DRAG_EVENTS, do not use for now */
+/* server-internal only */
+#define XI86_DEVICE_DISABLED    0x10    /* device was disabled before vt switch */
+#define XI86_SERVER_FD		0x20	/* fd is managed by xserver */
+
+/* Input device driver capabilities */
+#define XI86_DRV_CAP_SERVER_FD	0x01
+
+/* This holds the input driver entry and module information. */
+typedef struct _InputDriverRec {
+    int driverVersion;
+    const char *driverName;
+    void (*Identify) (int flags);
+    int (*PreInit) (struct _InputDriverRec * drv,
+                    struct _InputInfoRec * pInfo, int flags);
+    void (*UnInit) (struct _InputDriverRec * drv,
+                    struct _InputInfoRec * pInfo, int flags);
+    void *module;
+    const char **default_options;
+    int capabilities;
+} InputDriverRec, *InputDriverPtr;
+
+/* This is to input devices what the ScrnInfoRec is to screens. */
+
+typedef struct _InputInfoRec {
+    struct _InputInfoRec *next;
+    char *name;
+    char *driver;
+
+    int flags;
+
+    Bool (*device_control) (DeviceIntPtr device, int what);
+    void (*read_input) (struct _InputInfoRec * local);
+    int (*control_proc) (struct _InputInfoRec * local, xDeviceCtl * control);
+    int (*switch_mode) (ClientPtr client, DeviceIntPtr dev, int mode);
+    int (*set_device_valuators)
+     (struct _InputInfoRec * local,
+      int *valuators, int first_valuator, int num_valuators);
+
+    int fd;
+    int major;
+    int minor;
+    DeviceIntPtr dev;
+    void *private;
+    const char *type_name;
+    InputDriverPtr drv;
+    void *module;
+    XF86OptionPtr options;
+    InputAttributes *attrs;
+} *InputInfoPtr;
+
+/* xf86Globals.c */
+extern InputInfoPtr xf86InputDevs;
+
+/* xf86Xinput.c */
+extern _X_EXPORT void xf86PostMotionEvent(DeviceIntPtr device, int is_absolute,
+                                          int first_valuator, int num_valuators,
+                                          ...);
+extern _X_EXPORT void xf86PostMotionEventP(DeviceIntPtr device, int is_absolute,
+                                           int first_valuator,
+                                           int num_valuators,
+                                           const int *valuators);
+extern _X_EXPORT void xf86PostMotionEventM(DeviceIntPtr device, int is_absolute,
+                                           const ValuatorMask *mask);
+extern _X_EXPORT void xf86PostProximityEvent(DeviceIntPtr device, int is_in,
+                                             int first_valuator,
+                                             int num_valuators, ...);
+extern _X_EXPORT void xf86PostProximityEventP(DeviceIntPtr device, int is_in,
+                                              int first_valuator,
+                                              int num_valuators,
+                                              const int *valuators);
+extern _X_EXPORT void xf86PostProximityEventM(DeviceIntPtr device, int is_in,
+                                              const ValuatorMask *mask);
+extern _X_EXPORT void xf86PostButtonEvent(DeviceIntPtr device, int is_absolute,
+                                          int button, int is_down,
+                                          int first_valuator, int num_valuators,
+                                          ...);
+extern _X_EXPORT void xf86PostButtonEventP(DeviceIntPtr device, int is_absolute,
+                                           int button, int is_down,
+                                           int first_valuator,
+                                           int num_valuators,
+                                           const int *valuators);
+extern _X_EXPORT void xf86PostButtonEventM(DeviceIntPtr device, int is_absolute,
+                                           int button, int is_down,
+                                           const ValuatorMask *mask);
+extern _X_EXPORT void xf86PostKeyEvent(DeviceIntPtr device,
+                                       unsigned int key_code, int is_down,
+                                       int is_absolute, int first_valuator,
+                                       int num_valuators, ...);
+extern _X_EXPORT void xf86PostKeyEventM(DeviceIntPtr device,
+                                        unsigned int key_code, int is_down,
+                                        int is_absolute,
+                                        const ValuatorMask *mask);
+extern _X_EXPORT void xf86PostKeyEventP(DeviceIntPtr device,
+                                        unsigned int key_code, int is_down,
+                                        int is_absolute, int first_valuator,
+                                        int num_valuators,
+                                        const int *valuators);
+extern _X_EXPORT void xf86PostKeyboardEvent(DeviceIntPtr device,
+                                            unsigned int key_code, int is_down);
+extern _X_EXPORT void xf86PostTouchEvent(DeviceIntPtr dev, uint32_t touchid,
+                                         uint16_t type, uint32_t flags,
+                                         const ValuatorMask *mask);
+extern _X_EXPORT InputInfoPtr xf86FirstLocalDevice(void);
+extern _X_EXPORT int xf86ScaleAxis(int Cx, int to_max, int to_min, int from_max,
+                                   int from_min);
+extern _X_EXPORT void xf86ProcessCommonOptions(InputInfoPtr pInfo,
+                                               XF86OptionPtr options);
+extern _X_EXPORT Bool xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum,
+                                                 Atom label, int minval,
+                                                 int maxval, int resolution,
+                                                 int min_res, int max_res,
+                                                 int mode);
+extern _X_EXPORT void xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum);
+extern _X_EXPORT void xf86AddEnabledDevice(InputInfoPtr pInfo);
+extern _X_EXPORT void xf86RemoveEnabledDevice(InputInfoPtr pInfo);
+extern _X_EXPORT void xf86DisableDevice(DeviceIntPtr dev, Bool panic);
+extern _X_EXPORT void xf86EnableDevice(DeviceIntPtr dev);
+extern _X_EXPORT void xf86InputEnableVTProbe(void);
+
+/* not exported */
+int xf86NewInputDevice(InputInfoPtr pInfo, DeviceIntPtr *pdev, BOOL is_auto);
+InputInfoPtr xf86AllocateInput(void);
+
+/* xf86Helper.c */
+extern _X_EXPORT void xf86AddInputDriver(InputDriverPtr driver, void *module,
+                                         int flags);
+extern _X_EXPORT void xf86DeleteInputDriver(int drvIndex);
+extern _X_EXPORT InputDriverPtr xf86LookupInputDriver(const char *name);
+extern _X_EXPORT InputInfoPtr xf86LookupInput(const char *name);
+extern _X_EXPORT void xf86DeleteInput(InputInfoPtr pInp, int flags);
+extern _X_EXPORT void xf86MotionHistoryAllocate(InputInfoPtr pInfo);
+extern _X_EXPORT void
+xf86IDrvMsgVerb(InputInfoPtr dev,
+                MessageType type, int verb, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(4, 5);
+extern _X_EXPORT void
+xf86IDrvMsg(InputInfoPtr dev, MessageType type, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(3, 4);
+extern _X_EXPORT void
+xf86VIDrvMsgVerb(InputInfoPtr dev,
+                 MessageType type, int verb, const char *format, va_list args)
+_X_ATTRIBUTE_PRINTF(4, 0);
+
+/* xf86Option.c */
+extern _X_EXPORT void
+xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts);
+
+#endif                          /* _xf86Xinput_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Xinput.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDac.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDac.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDac.h	(Revision 52145)
@@ -0,0 +1,88 @@
+
+#ifndef _XF86RAMDAC_H
+#define _XF86RAMDAC_H 1
+
+#include "colormapst.h"
+#include "xf86Cursor.h"
+
+/* Define unique vendor codes for RAMDAC's */
+#define VENDOR_IBM	0x0000
+#define VENDOR_BT	0x0001
+#define VENDOR_TI	0x0002
+
+typedef struct _RamDacRegRec {
+/* This is probably the nastiest assumption, we allocate 1024 slots for
+ * ramdac registers, should be enough. I've checked IBM and TVP series 
+ * and they seem o.k 
+ * Then we allocate 768 entries for the DAC too. IBM640 needs 1024 -FIXME
+ */
+    unsigned short DacRegs[0x400];      /* register set */
+    unsigned char DAC[0x300];   /* colour map */
+    Bool Overlay;
+} RamDacRegRec, *RamDacRegRecPtr;
+
+typedef struct _RamDacHWRegRec {
+    RamDacRegRec SavedReg;
+    RamDacRegRec ModeReg;
+} RamDacHWRec, *RamDacHWRecPtr;
+
+typedef struct _RamDacRec {
+    CARD32 RamDacType;
+
+    void (*LoadPalette) (ScrnInfoPtr pScrn,
+                         int numColors,
+                         int *indices, LOCO * colors, VisualPtr pVisual);
+
+    unsigned char (*ReadDAC) (ScrnInfoPtr pScrn, CARD32);
+
+    void (*WriteDAC) (ScrnInfoPtr pScrn, CARD32, unsigned char, unsigned char);
+
+    void (*WriteAddress) (ScrnInfoPtr pScrn, CARD32);
+
+    void (*WriteData) (ScrnInfoPtr pScrn, unsigned char);
+
+    void (*ReadAddress) (ScrnInfoPtr pScrn, CARD32);
+
+    unsigned char (*ReadData) (ScrnInfoPtr pScrn);
+} RamDacRec, *RamDacRecPtr;
+
+typedef struct _RamDacHelperRec {
+    CARD32 RamDacType;
+
+    void (*Restore) (ScrnInfoPtr pScrn,
+                     RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);
+
+    void (*Save) (ScrnInfoPtr pScrn,
+                  RamDacRecPtr ramdacPtr, RamDacRegRecPtr ramdacReg);
+
+    void (*SetBpp) (ScrnInfoPtr pScrn, RamDacRegRecPtr ramdacReg);
+
+    void (*HWCursorInit) (xf86CursorInfoPtr infoPtr);
+} RamDacHelperRec, *RamDacHelperRecPtr;
+
+#define RAMDACHWPTR(p) ((RamDacHWRecPtr)((p)->privates[RamDacGetHWIndex()].ptr))
+
+typedef struct _RamdacScreenRec {
+    RamDacRecPtr RamDacRec;
+} RamDacScreenRec, *RamDacScreenRecPtr;
+
+#define RAMDACSCRPTR(p) ((RamDacScreenRecPtr)((p)->privates[RamDacGetScreenIndex()].ptr))->RamDacRec
+
+extern _X_EXPORT int RamDacHWPrivateIndex;
+extern _X_EXPORT int RamDacScreenPrivateIndex;
+
+typedef struct {
+    int token;
+} RamDacSupportedInfoRec, *RamDacSupportedInfoRecPtr;
+
+extern _X_EXPORT RamDacRecPtr RamDacCreateInfoRec(void);
+extern _X_EXPORT RamDacHelperRecPtr RamDacHelperCreateInfoRec(void);
+extern _X_EXPORT void RamDacDestroyInfoRec(RamDacRecPtr RamDacRec);
+extern _X_EXPORT void RamDacHelperDestroyInfoRec(RamDacHelperRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors,
+                                            int sigRGBbits, unsigned int flags);
+extern _X_EXPORT void RamDacFreeRec(ScrnInfoPtr pScrn);
+extern _X_EXPORT int RamDacGetHWIndex(void);
+
+#endif                          /* _XF86RAMDAC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86RamDac.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-other.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-other.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-other.h	(Revision 52145)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB generic driver.  \see usb-other.c \see usb-common.c */
+
+#ifndef _USB_OTHER_H_
+#define _USB_OTHER_H_
+extern void othUSBRead(DevicePtr pDev,
+                       dmxMotionProcPtr motion,
+                       dmxEnqueueProcPtr enqueue,
+                       dmxCheckSpecialProcPtr checkspecial, DMXBlockType block);
+extern void othUSBInit(DevicePtr pDev);
+extern void othUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int othUSBOn(DevicePtr pDev);
+extern void othUSBCtrl(DevicePtr pDev, PtrCtrl * ctrl);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-other.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xacestr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xacestr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xacestr.h	(Revision 52145)
@@ -0,0 +1,147 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XACESTR_H
+#define _XACESTR_H
+
+#include "dix.h"
+#include "resource.h"
+#include "extnsionst.h"
+#include "window.h"
+#include "input.h"
+#include "property.h"
+#include "selection.h"
+#include "xace.h"
+
+/* XACE_CORE_DISPATCH */
+typedef struct {
+    ClientPtr client;
+    int status;
+} XaceCoreDispatchRec;
+
+/* XACE_RESOURCE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    XID id;
+    RESTYPE rtype;
+    void *res;
+    RESTYPE ptype;
+    void *parent;
+    Mask access_mode;
+    int status;
+} XaceResourceAccessRec;
+
+/* XACE_DEVICE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    DeviceIntPtr dev;
+    Mask access_mode;
+    int status;
+} XaceDeviceAccessRec;
+
+/* XACE_PROPERTY_ACCESS */
+typedef struct {
+    ClientPtr client;
+    WindowPtr pWin;
+    PropertyPtr *ppProp;
+    Mask access_mode;
+    int status;
+} XacePropertyAccessRec;
+
+/* XACE_SEND_ACCESS */
+typedef struct {
+    ClientPtr client;
+    DeviceIntPtr dev;
+    WindowPtr pWin;
+    xEventPtr events;
+    int count;
+    int status;
+} XaceSendAccessRec;
+
+/* XACE_RECEIVE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    WindowPtr pWin;
+    xEventPtr events;
+    int count;
+    int status;
+} XaceReceiveAccessRec;
+
+/* XACE_CLIENT_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ClientPtr target;
+    Mask access_mode;
+    int status;
+} XaceClientAccessRec;
+
+/* XACE_EXT_DISPATCH */
+/* XACE_EXT_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ExtensionEntry *ext;
+    Mask access_mode;
+    int status;
+} XaceExtAccessRec;
+
+/* XACE_SERVER_ACCESS */
+typedef struct {
+    ClientPtr client;
+    Mask access_mode;
+    int status;
+} XaceServerAccessRec;
+
+/* XACE_SELECTION_ACCESS */
+typedef struct {
+    ClientPtr client;
+    Selection **ppSel;
+    Mask access_mode;
+    int status;
+} XaceSelectionAccessRec;
+
+/* XACE_SCREEN_ACCESS */
+/* XACE_SCREENSAVER_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ScreenPtr screen;
+    Mask access_mode;
+    int status;
+} XaceScreenAccessRec;
+
+/* XACE_AUTH_AVAIL */
+typedef struct {
+    ClientPtr client;
+    XID authId;
+} XaceAuthAvailRec;
+
+/* XACE_KEY_AVAIL */
+typedef struct {
+    xEventPtr event;
+    DeviceIntPtr keybd;
+    int count;
+} XaceKeyAvailRec;
+
+/* XACE_AUDIT_BEGIN */
+/* XACE_AUDIT_END */
+typedef struct {
+    ClientPtr client;
+    int requestResult;
+} XaceAuditRec;
+
+#endif                          /* _XACESTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xacestr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/msp3430.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/msp3430.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/msp3430.h	(Revision 52145)
@@ -0,0 +1,116 @@
+#ifndef __MSP3430_H__
+#define __MSP3430_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    I2CDevRec d;
+
+    int standard;
+    int connector;
+    int mode;
+
+    CARD8 hardware_version, major_revision, product_code, rom_version;
+#ifdef MSP_DEBUG
+    CARD8 registers_present[256];
+#endif
+
+    CARD16 chip_id;
+    CARD8 chip_family;
+    Bool recheck;               /*reinitialization needed after channel change */
+    CARD8 c_format;             /*current state of audio format */
+    CARD16 c_standard;          /*current state of standard register */
+    CARD8 c_source;             /*current state of source register */
+    CARD8 c_matrix;             /*current state of matrix register */
+    CARD8 c_fmmatrix;           /*current state of fmmatrix register */
+    int c_mode;                 /* current state of mode for autoswitchimg */
+    CARD8 volume;
+} MSP3430Rec, *MSP3430Ptr;
+
+#define MSP3430_ADDR_1      0x80
+#define MSP3430_ADDR_2		0x84
+#define MSP3430_ADDR_3		0x88
+
+#define MSP3430_PAL		1
+#define MSP3430_NTSC		2
+#define MSP3430_PAL_DK1         (0x100 | MSP3430_PAL)
+#define MSP3430_SECAM           3
+
+#define MSP3430_CONNECTOR_1     1       /* tuner on AIW cards */
+#define MSP3430_CONNECTOR_2     2       /* SVideo on AIW cards */
+#define MSP3430_CONNECTOR_3     3       /* composite on AIW cards */
+
+#define MSP3430_ADDR(a)         ((a)->d.SlaveAddr)
+
+#define MSP3430_FAST_MUTE	0xFF
+/* a handy volume transform function, -1000..1000 -> 0x01..0x7F */
+#define MSP3430_VOLUME(value) (0x01+(0x7F-0x01)*log(value+1001)/log(2001))
+
+/*----------------------------------------------------------*/
+
+/* MSP chip families */
+#define MSPFAMILY_UNKNOWN	0
+#define MSPFAMILY_34x0D		1
+#define MSPFAMILY_34x5D		2
+#define MSPFAMILY_34x0G		3
+#define MSPFAMILY_34x5G		4
+
+/* values for MSP standard */
+#define MSPSTANDARD_UNKNOWN	0x00
+#define MSPSTANDARD_AUTO	0x01
+#define MSPSTANDARD_FM_M	0x02
+#define MSPSTANDARD_FM_BG	0x03
+#define MSPSTANDARD_FM_DK1	0x04
+#define MSPSTANDARD_FM_DK2	0x04
+#define MSPSTANDARD_NICAM_BG	0x08
+#define MSPSTANDARD_NICAM_L	0x09
+#define MSPSTANDARD_NICAM_I	0x0A
+#define MSPSTANDARD_NICAM_DK	0x0B
+
+/* values for MSP format */
+#define MSPFORMAT_UNKNOWN	0x00
+#define MSPFORMAT_FM		0x10
+#define MSPFORMAT_1xFM		0x00|MSPFORMAT_FM
+#define MSPFORMAT_2xFM		0x01|MSPFORMAT_FM
+#define MSPFORMAT_NICAM		0x20
+#define MSPFORMAT_NICAM_FM	0x00|MSPFORMAT_NICAM
+#define MSPFORMAT_NICAM_AM	0x01|MSPFORMAT_NICAM
+#define MSPFORMAT_SCART		0x30
+
+/* values for MSP mode */
+#define MSPMODE_UNKNOWN		0
+/* automatic modes */
+#define MSPMODE_STEREO_AB	1
+#define MSPMODE_STEREO_A	2
+#define MSPMODE_STEREO_B	3
+/* forced modes */
+#define MSPMODE_MONO		4
+#define MSPMODE_STEREO		5
+#define MSPMODE_AB			6
+#define MSPMODE_A			7
+#define MSPMODE_B			8
+/*----------------------------------------------------------*/
+
+#define xf86_InitMSP3430	InitMSP3430
+extern _X_EXPORT void InitMSP3430(MSP3430Ptr m);
+
+#define xf86_DetectMSP3430	DetectMSP3430
+extern _X_EXPORT MSP3430Ptr DetectMSP3430(I2CBusPtr b, I2CSlaveAddr addr);
+
+#define xf86_ResetMSP3430	ResetMSP3430
+extern _X_EXPORT void ResetMSP3430(MSP3430Ptr m);
+
+#define xf86_MSP3430SetVolume	MSP3430SetVolume
+extern _X_EXPORT void MSP3430SetVolume(MSP3430Ptr m, CARD8 value);
+
+#define xf86_MSP3430SetSAP	MSP3430SetSAP
+extern _X_EXPORT void MSP3430SetSAP(MSP3430Ptr m, int mode);
+
+#define MSP3430SymbolsList \
+		"InitMSP3430", \
+		"DetectMSP3430", \
+		"ResetMSP3430", \
+		"MSP3430SetVolume", \
+		"MSP3430SetSAP"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/msp3430.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiallowev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiallowev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiallowev.h	(Revision 52145)
@@ -0,0 +1,36 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIALLOWEV_H
+#define XIALLOWEV_H 1
+
+int ProcXIAllowEvents(ClientPtr client);
+int SProcXIAllowEvents(ClientPtr client);
+
+#endif                          /* XIALLOWEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiallowev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootless.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootless.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootless.h	(Revision 52145)
@@ -0,0 +1,363 @@
+/*
+ * External interface to generic rootless mode
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESS_H
+#define _ROOTLESS_H
+
+#include "rootlessConfig.h"
+#include "mi.h"
+#include "gcstruct.h"
+
+/*
+   Each top-level rootless window has a one-to-one correspondence to a physical
+   on-screen window. The physical window is refered to as a "frame".
+ */
+
+typedef void *RootlessFrameID;
+
+/*
+ * RootlessWindowRec
+ *  This structure stores the per-frame data used by the rootless code.
+ *  Each top-level X window has one RootlessWindowRec associated with it.
+ */
+typedef struct _RootlessWindowRec {
+    // Position and size includes the window border
+    // Position is in per-screen coordinates
+    int x, y;
+    unsigned int width, height;
+    unsigned int borderWidth;
+    int level;
+
+    RootlessFrameID wid;        // implementation specific frame id
+    WindowPtr win;              // underlying X window
+
+    // Valid only when drawing (ie. is_drawing is set)
+    char *pixelData;
+    int bytesPerRow;
+
+    PixmapPtr pixmap;
+
+    unsigned int is_drawing:1;  // Currently drawing?
+    unsigned int is_reorder_pending:1;
+    unsigned int is_offscreen:1;
+    unsigned int is_obscured:1;
+} RootlessWindowRec, *RootlessWindowPtr;
+
+/* Offset for screen-local to global coordinate transforms */
+extern int rootlessGlobalOffsetX;
+extern int rootlessGlobalOffsetY;
+
+/* The minimum number of bytes or pixels for which to use the
+   implementation's accelerated functions. */
+extern unsigned int rootless_CopyBytes_threshold;
+extern unsigned int rootless_CopyWindow_threshold;
+
+/* Gravity for window contents during resizing */
+enum rl_gravity_enum {
+    RL_GRAVITY_NONE = 0,        /* no gravity, fill everything */
+    RL_GRAVITY_NORTH_WEST = 1,  /* anchor to top-left corner */
+    RL_GRAVITY_NORTH_EAST = 2,  /* anchor to top-right corner */
+    RL_GRAVITY_SOUTH_EAST = 3,  /* anchor to bottom-right corner */
+    RL_GRAVITY_SOUTH_WEST = 4,  /* anchor to bottom-left corner */
+};
+
+/*------------------------------------------
+   Rootless Implementation Functions
+  ------------------------------------------*/
+
+/*
+ * Create a new frame.
+ *  The frame is created unmapped.
+ *
+ *  pFrame      RootlessWindowPtr for this frame should be completely
+ *              initialized before calling except for pFrame->wid, which
+ *              is set by this function.
+ *  pScreen     Screen on which to place the new frame
+ *  newX, newY  Position of the frame.
+ *  pNewShape   Shape for the frame (in frame-local coordinates). NULL for
+ *              unshaped frames.
+ */
+typedef Bool (*RootlessCreateFrameProc)
+ (RootlessWindowPtr pFrame, ScreenPtr pScreen, int newX, int newY,
+  RegionPtr pNewShape);
+
+/*
+ * Destroy a frame.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ */
+typedef void (*RootlessDestroyFrameProc)
+ (RootlessFrameID wid);
+
+/*
+ * Move a frame on screen.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ *  pScreen     Screen to move the new frame to
+ *  newX, newY  New position of the frame
+ */
+typedef void (*RootlessMoveFrameProc)
+ (RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);
+
+/*
+ * Resize and move a frame.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ *  pScreen     Screen to move the new frame to
+ *  newX, newY  New position of the frame
+ *  newW, newH  New size of the frame
+ *  gravity     Gravity for window contents (rl_gravity_enum). This is always
+ *              RL_GRAVITY_NONE unless ROOTLESS_RESIZE_GRAVITY is set.
+ */
+typedef void (*RootlessResizeFrameProc)
+ (RootlessFrameID wid, ScreenPtr pScreen,
+  int newX, int newY, unsigned int newW, unsigned int newH,
+  unsigned int gravity);
+
+/*
+ * Change frame ordering (AKA stacking, layering).
+ *  Drawing is stopped before this is called. Unmapped frames are mapped by
+ *  setting their ordering.
+ *
+ *  wid         Frame id
+ *  nextWid     Frame id of frame that is now above this one or NULL if this
+ *              frame is at the top.
+ */
+typedef void (*RootlessRestackFrameProc)
+ (RootlessFrameID wid, RootlessFrameID nextWid);
+
+/*
+ * Change frame's shape.
+ *  Drawing is stopped before this is called.
+ *
+ *  wid         Frame id
+ *  pNewShape   New shape for the frame (in frame-local coordinates)
+ *              or NULL if now unshaped.
+ */
+typedef void (*RootlessReshapeFrameProc)
+ (RootlessFrameID wid, RegionPtr pNewShape);
+
+/*
+ * Unmap a frame.
+ *
+ *  wid         Frame id
+ */
+typedef void (*RootlessUnmapFrameProc)
+ (RootlessFrameID wid);
+
+/*
+ * Start drawing to a frame.
+ *  Prepare a frame for direct access to its backing buffer.
+ *
+ *  wid         Frame id
+ *  pixelData   Address of the backing buffer (returned)
+ *  bytesPerRow Width in bytes of the backing buffer (returned)
+ */
+typedef void (*RootlessStartDrawingProc)
+ (RootlessFrameID wid, char **pixelData, int *bytesPerRow);
+
+/*
+ * Stop drawing to a frame.
+ *  No drawing to the frame's backing buffer will occur until drawing
+ *  is started again.
+ *
+ *  wid         Frame id
+ *  flush       Flush drawing updates for this frame to the screen.
+ */
+typedef void (*RootlessStopDrawingProc)
+ (RootlessFrameID wid, Bool flush);
+
+/*
+ * Flush drawing updates to the screen.
+ *  Drawing is stopped before this is called.
+ *
+ *  wid         Frame id
+ *  pDamage     Region containing all the changed pixels in frame-lcoal
+ *              coordinates. This is clipped to the window's clip.
+ */
+typedef void (*RootlessUpdateRegionProc)
+ (RootlessFrameID wid, RegionPtr pDamage);
+
+/*
+ * Mark damaged rectangles as requiring redisplay to screen.
+ *
+ *  wid         Frame id
+ *  nrects      Number of damaged rectangles
+ *  rects       Array of damaged rectangles in frame-local coordinates
+ *  shift_x,    Vector to shift rectangles by
+ *   shift_y
+ */
+typedef void (*RootlessDamageRectsProc)
+ (RootlessFrameID wid, int nrects, const BoxRec * rects,
+  int shift_x, int shift_y);
+
+/*
+ * Switch the window associated with a frame. (Optional)
+ *  When a framed window is reparented, the frame is resized and set to
+ *  use the new top-level parent. If defined this function will be called
+ *  afterwards for implementation specific bookkeeping.
+ *
+ *  pFrame      Frame whose window has switched
+ *  oldWin      Previous window wrapped by this frame
+ */
+typedef void (*RootlessSwitchWindowProc)
+ (RootlessWindowPtr pFrame, WindowPtr oldWin);
+
+/*
+ * Check if window should be reordered. (Optional)
+ *  The underlying window system may animate windows being ordered in.
+ *  We want them to be mapped but remain ordered out until the animation
+ *  completes. If defined this function will be called to check if a
+ *  framed window should be reordered now. If this function returns
+ *  FALSE, the window will still be mapped from the X11 perspective, but
+ *  the RestackFrame function will not be called for its frame.
+ *
+ *  pFrame      Frame to reorder
+ */
+typedef Bool (*RootlessDoReorderWindowProc)
+ (RootlessWindowPtr pFrame);
+
+/*
+ * Copy bytes. (Optional)
+ *  Source and destinate may overlap and the right thing should happen.
+ *
+ *  width       Bytes to copy per row
+ *  height      Number of rows
+ *  src         Source data
+ *  srcRowBytes Width of source in bytes
+ *  dst         Destination data
+ *  dstRowBytes Width of destination in bytes
+ */
+typedef void (*RootlessCopyBytesProc)
+ (unsigned int width, unsigned int height,
+  const void *src, unsigned int srcRowBytes,
+  void *dst, unsigned int dstRowBytes);
+
+/*
+ * Copy area in frame to another part of frame. (Optional)
+ *
+ *  wid         Frame id
+ *  dstNrects   Number of rectangles to copy
+ *  dstRects    Array of rectangles to copy
+ *  dx, dy      Number of pixels away to copy area
+ */
+typedef void (*RootlessCopyWindowProc)
+ (RootlessFrameID wid, int dstNrects, const BoxRec * dstRects, int dx, int dy);
+
+typedef void (*RootlessHideWindowProc)
+ (RootlessFrameID wid);
+
+typedef void (*RootlessUpdateColormapProc)
+ (RootlessFrameID wid, ScreenPtr pScreen);
+
+/*
+ * Rootless implementation function list
+ */
+typedef struct _RootlessFrameProcs {
+    RootlessCreateFrameProc CreateFrame;
+    RootlessDestroyFrameProc DestroyFrame;
+
+    RootlessMoveFrameProc MoveFrame;
+    RootlessResizeFrameProc ResizeFrame;
+    RootlessRestackFrameProc RestackFrame;
+    RootlessReshapeFrameProc ReshapeFrame;
+    RootlessUnmapFrameProc UnmapFrame;
+
+    RootlessStartDrawingProc StartDrawing;
+    RootlessStopDrawingProc StopDrawing;
+    RootlessUpdateRegionProc UpdateRegion;
+    RootlessDamageRectsProc DamageRects;
+
+    /* Optional frame functions */
+    RootlessSwitchWindowProc SwitchWindow;
+    RootlessDoReorderWindowProc DoReorderWindow;
+    RootlessHideWindowProc HideWindow;
+    RootlessUpdateColormapProc UpdateColormap;
+
+    /* Optional acceleration functions */
+    RootlessCopyBytesProc CopyBytes;
+    RootlessCopyWindowProc CopyWindow;
+} RootlessFrameProcsRec, *RootlessFrameProcsPtr;
+
+/*
+ * Initialize rootless mode on the given screen.
+ */
+Bool RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs);
+
+/*
+ * Return the frame ID for the physical window displaying the given window. 
+ *
+ *  create      If true and the window has no frame, attempt to create one
+ */
+RootlessFrameID RootlessFrameForWindow(WindowPtr pWin, Bool create);
+
+/*
+ * Return the top-level parent of a window.
+ *  The root is the top-level parent of itself, even though the root is
+ *  not otherwise considered to be a top-level window.
+ */
+WindowPtr TopLevelParent(WindowPtr pWindow);
+
+/*
+ * Prepare a window for direct access to its backing buffer.
+ */
+void RootlessStartDrawing(WindowPtr pWindow);
+
+/*
+ * Finish drawing to a window's backing buffer.
+ *
+ *  flush       If true, damaged areas are flushed to the screen.
+ */
+void RootlessStopDrawing(WindowPtr pWindow, Bool flush);
+
+/*
+ * Alocate a new screen pixmap.
+ *  miCreateScreenResources does not do this properly with a null
+ *  framebuffer pointer.
+ */
+void RootlessUpdateScreenPixmap(ScreenPtr pScreen);
+
+/*
+ * Reposition all windows on a screen to their correct positions.
+ */
+void RootlessRepositionWindows(ScreenPtr pScreen);
+
+/*
+ * Bring all windows to the front of the native stack
+ */
+void RootlessOrderAllWindows(Bool include_unhitable);
+#endif                          /* _ROOTLESS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootless.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconsole.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconsole.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconsole.h	(Revision 52145)
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for console device support.  \see dmxconsole.c \see dmxcommon.c */
+
+#ifndef _DMXCONSOLE_H_
+#define _DMXCONSOLE_H_
+
+extern void *dmxConsoleCreatePrivate(DeviceIntPtr pDevice);
+extern void dmxConsoleDestroyPrivate(void *private);
+extern void dmxConsoleInit(DevicePtr pDev);
+extern void dmxConsoleReInit(DevicePtr pDev);
+extern void dmxConsoleMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxConsoleKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxConsoleCollectEvents(DevicePtr pDev,
+                                    dmxMotionProcPtr motion,
+                                    dmxEnqueueProcPtr enqueue,
+                                    dmxCheckSpecialProcPtr checkspecial,
+                                    DMXBlockType block);
+extern int dmxConsoleFunctions(void *private, DMXFunctionType function);
+extern void dmxConsoleUpdatePosition(void *private, int x, int y);
+extern void dmxConsoleKbdSetCtrl(void *private, KeybdCtrl * ctrl);
+extern void dmxConsoleCapture(DMXInputInfo * dmxInput);
+extern void dmxConsoleUncapture(DMXInputInfo * dmxInput);
+extern void dmxConsoleUpdateInfo(void *private,
+                                 DMXUpdateType, WindowPtr pWindow);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxconsole.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mizerarc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mizerarc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mizerarc.h	(Revision 52145)
@@ -0,0 +1,124 @@
+/************************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+********************************************************/
+
+typedef struct {
+    int x;
+    int y;
+    int mask;
+} miZeroArcPtRec;
+
+typedef struct {
+    int x, y, k1, k3, a, b, d, dx, dy;
+    int alpha, beta;
+    int xorg, yorg;
+    int xorgo, yorgo;
+    int w, h;
+    int initialMask;
+    miZeroArcPtRec start, altstart, end, altend;
+    int firstx, firsty;
+    int startAngle, endAngle;
+} miZeroArcRec;
+
+#define miCanZeroArc(arc) (((arc)->width == (arc)->height) || \
+			   (((arc)->width <= 800) && ((arc)->height <= 800)))
+
+#define MIARCSETUP() \
+    x = info.x; \
+    y = info.y; \
+    k1 = info.k1; \
+    k3 = info.k3; \
+    a = info.a; \
+    b = info.b; \
+    d = info.d; \
+    dx = info.dx; \
+    dy = info.dy
+
+#define MIARCOCTANTSHIFT(clause) \
+    if (a < 0) \
+    { \
+	if (y == info.h) \
+	{ \
+	    d = -1; \
+	    a = b = k1 = 0; \
+	} \
+	else \
+	{ \
+	    dx = (k1 << 1) - k3; \
+	    k1 = dx - k1; \
+	    k3 = -k3; \
+	    b = b + a - (k1 >> 1); \
+	    d = b + ((-a) >> 1) - d + (k3 >> 3); \
+	    if (dx < 0) \
+		a = -((-dx) >> 1) - a; \
+	    else \
+		a = (dx >> 1) - a; \
+	    dx = 0; \
+	    dy = 1; \
+	    clause \
+	} \
+    }
+
+#define MIARCSTEP(move1,move2) \
+    b -= k1; \
+    if (d < 0) \
+    { \
+	x += dx; \
+	y += dy; \
+	a += k1; \
+	d += b; \
+	move1 \
+    } \
+    else \
+    { \
+	x++; \
+	y++; \
+	a += k3; \
+	d -= a; \
+	move2 \
+    }
+
+#define MIARCCIRCLESTEP(clause) \
+    b -= k1; \
+    x++; \
+    if (d < 0) \
+    { \
+	a += k1; \
+	d += b; \
+    } \
+    else \
+    { \
+	y++; \
+	a += k3; \
+	d -= a; \
+	clause \
+    }
+
+/* mizerarc.c */
+
+extern _X_EXPORT Bool miZeroArcSetup(xArc * /*arc */ ,
+                                     miZeroArcRec * /*info */ ,
+                                     Bool       /*ok360 */
+    );

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mizerarc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxevents.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxevents.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxevents.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to event processing functions.  \see dmxevents.h */
+
+#ifndef _DMXEVENTS_H_
+#define _DMXEVENTS_H_
+
+extern void dmxMotion(DevicePtr pDev, int *v, int firstAxis, int axesCount,
+                      DMXMotionType type, DMXBlockType block);
+extern void dmxEnqueue(DevicePtr pDev, int type, int detail, KeySym keySym,
+                       XEvent * e, DMXBlockType block);
+extern int dmxCheckSpecialKeys(DevicePtr pDev, KeySym keySym);
+extern void dmxInvalidateGlobalPosition(void);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxevents.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSproc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSproc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSproc.h	(Revision 52145)
@@ -0,0 +1,231 @@
+/*
+ * Copyright 1990, 1991 by Thomas Roell, Dinkelscherben, Germany
+ * Copyright 1992 by David Dawes <dawes@XFree86.org>
+ * Copyright 1992 by Jim Tsillas <jtsilla@damon.ccs.northeastern.edu>
+ * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
+ * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
+ * Copyright 1992 by Orest Zborowski <obz@eskimo.com>
+ * Copyright 1993 by Vrije Universiteit, The Netherlands
+ * Copyright 1993 by David Wexelblat <dwex@XFree86.org>
+ * Copyright 1994, 1996 by Holger Veit <Holger.Veit@gmd.de>
+ * Copyright 1994-2003 by The XFree86 Project, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holders 
+ * not be used in advertising or publicity pertaining to distribution of 
+ * the software without specific, written prior permission.  The above listed
+ * copyright holders make no representations about the suitability of this 
+ * software for any purpose.  It is provided "as is" without express or 
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD 
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDERS BE 
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING 
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * The ARM32 code here carries the following copyright:
+ *
+ * Copyright 1997
+ * Digital Equipment Corporation. All rights reserved.
+ * This software is furnished under license and may be used and copied only in 
+ * accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * this software in source and/or binary form. No title or ownership is
+ * transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and retain
+ *    this copyright notice and list of conditions as they appear in the
+ *    source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of Digital 
+ *    Equipment Corporation. Neither the "Digital Equipment Corporation"
+ *    name nor any trademark or logo of Digital Equipment Corporation may be
+ *    used to endorse or promote products derived from this software without
+ *    the prior written permission of Digital Equipment Corporation.
+ *
+ * 3) This software is provided "AS-IS" and any express or implied warranties,
+ *    including but not limited to, any implied warranties of merchantability,
+ *    fitness for a particular purpose, or non-infringement are disclaimed.
+ *    In no event shall DIGITAL be liable for any damages whatsoever, and in
+ *    particular, DIGITAL shall not be liable for special, indirect,
+ *    consequential, or incidental damages or damages for lost profits, loss
+ *    of revenue or loss of use, whether such damages arise in contract, 
+ *    negligence, tort, under statute, in equity, at law or otherwise, even
+ *    if advised of the possibility of such damage. 
+ *
+ */
+
+#ifndef _XF86_OSPROC_H
+#define _XF86_OSPROC_H
+
+/*
+ * The actual prototypes have been pulled into this seperate file so
+ * that they can can be used without pulling in all of the OS specific
+ * stuff like sys/stat.h, etc. This casues problem for loadable modules.
+ */
+
+/*
+ * Flags for xf86MapVidMem().  Multiple flags can be or'd together.  The
+ * flags may be used as hints.  For example it would be permissible to
+ * enable write combining for memory marked only for framebuffer use.
+ */
+
+#define VIDMEM_FRAMEBUFFER	0x01    /* memory for framebuffer use */
+#define VIDMEM_MMIO		0x02    /* memory for I/O use */
+#define VIDMEM_MMIO_32BIT	0x04    /* memory accesses >= 32bit */
+#define VIDMEM_READSIDEEFFECT	0x08    /* reads can have side-effects */
+#define VIDMEM_SPARSE		0x10    /* sparse mapping required
+                                         * assumed when VIDMEM_MMIO is
+                                         * set. May be used with
+                                         * VIDMEM_FRAMEBUFFER) */
+#define VIDMEM_READONLY		0x20    /* read-only mapping
+                                         * used when reading BIOS images
+                                         * through xf86MapVidMem() */
+
+/*
+ * OS-independent modem state flags for xf86SetSerialModemState() and
+ * xf86GetSerialModemState().
+ */
+#define XF86_M_LE		0x001   /* line enable */
+#define XF86_M_DTR		0x002   /* data terminal ready */
+#define XF86_M_RTS		0x004   /* request to send */
+#define XF86_M_ST		0x008   /* secondary transmit */
+#define XF86_M_SR		0x010   /* secondary receive */
+#define XF86_M_CTS		0x020   /* clear to send */
+#define XF86_M_CAR		0x040   /* carrier detect */
+#define XF86_M_RNG		0x080   /* ring */
+#define XF86_M_DSR		0x100   /* data set ready */
+
+#ifndef NO_OSLIB_PROTOTYPES
+/*
+ * This is to prevent re-entrancy to FatalError() when aborting.
+ * Anything that can be called as a result of AbortDDX() should use this
+ * instead of FatalError().
+ */
+
+#define xf86FatalError(a, b) \
+	if (dispatchException & DE_TERMINATE) { \
+		ErrorF(a, b); \
+		ErrorF("\n"); \
+		return; \
+	} else FatalError(a, b)
+
+/***************************************************************************/
+/* Prototypes                                                              */
+/***************************************************************************/
+
+#include <X11/Xfuncproto.h>
+#include "opaque.h"
+#include "xf86Optionstr.h"
+
+_XFUNCPROTOBEGIN
+
+/* public functions */
+extern _X_EXPORT Bool xf86LinearVidMem(void);
+extern _X_EXPORT _X_DEPRECATED Bool xf86CheckMTRR(int);
+extern _X_EXPORT _X_DEPRECATED void *xf86MapVidMem(int, int, unsigned long,
+                                                     unsigned long);
+extern _X_EXPORT _X_DEPRECATED void xf86UnMapVidMem(int, void *,
+                                                    unsigned long);
+extern _X_EXPORT int xf86ReadBIOS(unsigned long, unsigned long, unsigned char *,
+                                  int);
+extern _X_EXPORT Bool xf86EnableIO(void);
+extern _X_EXPORT void xf86DisableIO(void);
+
+#ifdef __NetBSD__
+extern _X_EXPORT void xf86SetTVOut(int);
+extern _X_EXPORT void xf86SetRGBOut(void);
+#endif
+extern _X_EXPORT void xf86OSRingBell(int, int, int);
+extern _X_EXPORT void xf86SetReallySlowBcopy(void);
+extern _X_EXPORT void xf86SlowBcopy(unsigned char *, unsigned char *, int);
+extern _X_EXPORT int xf86OpenSerial(XF86OptionPtr options);
+extern _X_EXPORT int xf86SetSerial(int fd, XF86OptionPtr options);
+extern _X_EXPORT int xf86SetSerialSpeed(int fd, int speed);
+extern _X_EXPORT int xf86ReadSerial(int fd, void *buf, int count);
+extern _X_EXPORT int xf86WriteSerial(int fd, const void *buf, int count);
+extern _X_EXPORT int xf86CloseSerial(int fd);
+extern _X_EXPORT int xf86FlushInput(int fd);
+extern _X_EXPORT int xf86WaitForInput(int fd, int timeout);
+extern _X_EXPORT int xf86SerialSendBreak(int fd, int duration);
+extern _X_EXPORT int xf86SetSerialModemState(int fd, int state);
+extern _X_EXPORT int xf86GetSerialModemState(int fd);
+extern _X_EXPORT int xf86SerialModemSetBits(int fd, int bits);
+extern _X_EXPORT int xf86SerialModemClearBits(int fd, int bits);
+extern _X_EXPORT int xf86LoadKernelModule(const char *pathname);
+
+/* AGP GART interface */
+
+typedef struct _AgpInfo {
+    CARD32 bridgeId;
+    CARD32 agpMode;
+    unsigned long base;
+    unsigned long size;
+    unsigned long totalPages;
+    unsigned long systemPages;
+    unsigned long usedPages;
+} AgpInfo, *AgpInfoPtr;
+
+extern _X_EXPORT Bool xf86AgpGARTSupported(void);
+extern _X_EXPORT AgpInfoPtr xf86GetAGPInfo(int screenNum);
+extern _X_EXPORT Bool xf86AcquireGART(int screenNum);
+extern _X_EXPORT Bool xf86ReleaseGART(int screenNum);
+extern _X_EXPORT int xf86AllocateGARTMemory(int screenNum, unsigned long size,
+                                            int type, unsigned long *physical);
+extern _X_EXPORT Bool xf86DeallocateGARTMemory(int screenNum, int key);
+extern _X_EXPORT Bool xf86BindGARTMemory(int screenNum, int key,
+                                         unsigned long offset);
+extern _X_EXPORT Bool xf86UnbindGARTMemory(int screenNum, int key);
+extern _X_EXPORT Bool xf86EnableAGP(int screenNum, CARD32 mode);
+extern _X_EXPORT Bool xf86GARTCloseScreen(int screenNum);
+
+/* These routines are in shared/sigio.c and are not loaded as part of the
+   module.  These routines are small, and the code if very POSIX-signal (or
+   OS-signal) specific, so it seemed better to provide more complex
+   wrappers than to wrap each individual function called. */
+extern _X_EXPORT int xf86InstallSIGIOHandler(int fd, void (*f) (int, void *),
+                                             void *);
+extern _X_EXPORT int xf86RemoveSIGIOHandler(int fd);
+extern _X_EXPORT int xf86BlockSIGIO(void);
+extern _X_EXPORT void xf86UnblockSIGIO(int);
+extern _X_EXPORT void xf86AssertBlockedSIGIO(char *);
+extern _X_EXPORT Bool xf86SIGIOSupported(void);
+
+#ifdef XF86_OS_PRIVS
+typedef void (*PMClose) (void);
+extern _X_EXPORT void xf86OpenConsole(void);
+extern _X_EXPORT void xf86CloseConsole(void);
+extern _X_HIDDEN Bool xf86VTActivate(int vtno);
+extern _X_EXPORT Bool xf86VTSwitchPending(void);
+extern _X_EXPORT Bool xf86VTSwitchAway(void);
+extern _X_EXPORT Bool xf86VTSwitchTo(void);
+extern _X_EXPORT void xf86VTRequest(int sig);
+extern _X_EXPORT int xf86ProcessArgument(int, char **, int);
+extern _X_EXPORT void xf86UseMsg(void);
+extern _X_EXPORT PMClose xf86OSPMOpen(void);
+
+extern _X_EXPORT void xf86InitVidMem(void);
+
+#endif                          /* XF86_OS_PRIVS */
+
+#ifdef XSERVER_PLATFORM_BUS
+#include "hotplug.h"
+void
+xf86PlatformDeviceProbe(struct OdevAttributes *attribs);
+
+void
+xf86PlatformReprobeDevice(int index, struct OdevAttributes *attribs);
+#endif
+
+_XFUNCPROTOEND
+#endif                          /* NO_OSLIB_PROTOTYPES */
+#endif                          /* _XF86_OSPROC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSproc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exglobals.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exglobals.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exglobals.h	(Revision 52145)
@@ -0,0 +1,85 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/*****************************************************************
+ *
+ * Globals referenced elsewhere in the server.
+ *
+ */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "privates.h"
+
+#ifndef EXGLOBALS_H
+#define EXGLOBALS_H 1
+
+extern int IReqCode;
+extern int IEventBase;
+extern int BadDevice;
+extern int BadMode;
+extern int DeviceBusy;
+extern int BadClass;
+
+/* Note: only the ones needed in files other than extinit.c are declared */
+extern const Mask DevicePointerMotionMask;
+extern const Mask DevicePointerMotionHintMask;
+extern const Mask DeviceFocusChangeMask;
+extern const Mask DeviceStateNotifyMask;
+extern const Mask DeviceMappingNotifyMask;
+extern const Mask DeviceOwnerGrabButtonMask;
+extern const Mask DeviceButtonGrabMask;
+extern const Mask DeviceButtonMotionMask;
+extern const Mask DevicePresenceNotifyMask;
+extern const Mask DevicePropertyNotifyMask;
+extern const Mask XIAllMasks;
+
+extern Mask PropagateMask[];
+
+extern int DeviceValuator;
+extern int DeviceKeyPress;
+extern int DeviceKeyRelease;
+extern int DeviceButtonPress;
+extern int DeviceButtonRelease;
+extern int DeviceMotionNotify;
+extern int DeviceFocusIn;
+extern int DeviceFocusOut;
+extern int ProximityIn;
+extern int ProximityOut;
+extern int DeviceStateNotify;
+extern int DeviceKeyStateNotify;
+extern int DeviceButtonStateNotify;
+extern int DeviceMappingNotify;
+extern int ChangeDeviceNotify;
+extern int DevicePresenceNotify;
+extern int DevicePropertyNotify;
+
+extern RESTYPE RT_INPUTCLIENT;
+
+extern DevPrivateKeyRec XIClientPrivateKeyRec;
+
+#define XIClientPrivateKey (&XIClientPrivateKeyRec)
+
+#endif                          /* EXGLOBALS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exglobals.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inpututils.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inpututils.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inpututils.h	(Revision 52145)
@@ -0,0 +1,69 @@
+/*
+ * Copyright ¬© 2010 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include "dix-config.h"
+#endif
+
+#ifndef INPUTUTILS_H
+#define INPUTUTILS_H
+
+#include "input.h"
+#include <X11/extensions/XI2proto.h>
+
+extern Mask event_filters[MAXDEVICES][MAXEVENTS];
+
+struct _ValuatorMask {
+    int8_t last_bit;            /* highest bit set in mask */
+    uint8_t mask[(MAX_VALUATORS + 7) / 8];
+    double valuators[MAX_VALUATORS];    /* valuator data */
+};
+
+extern void verify_internal_event(const InternalEvent *ev);
+extern void init_device_event(DeviceEvent *event, DeviceIntPtr dev, Time ms);
+extern int event_get_corestate(DeviceIntPtr mouse, DeviceIntPtr kbd);
+extern void event_set_state(DeviceIntPtr mouse, DeviceIntPtr kbd,
+                            DeviceEvent *event);
+extern Mask event_get_filter_from_type(DeviceIntPtr dev, int evtype);
+extern Mask event_get_filter_from_xi2type(int evtype);
+
+FP3232 double_to_fp3232(double in);
+FP1616 double_to_fp1616(double in);
+double fp1616_to_double(FP1616 in);
+double fp3232_to_double(FP3232 in);
+
+XI2Mask *xi2mask_new(void);
+XI2Mask *xi2mask_new_with_size(size_t, size_t); /* don't use it */
+void xi2mask_free(XI2Mask **mask);
+Bool xi2mask_isset(XI2Mask *mask, const DeviceIntPtr dev, int event_type);
+Bool xi2mask_isset_for_device(XI2Mask *mask, const DeviceIntPtr dev, int event_type);
+void xi2mask_set(XI2Mask *mask, int deviceid, int event_type);
+void xi2mask_zero(XI2Mask *mask, int deviceid);
+void xi2mask_merge(XI2Mask *dest, const XI2Mask *source);
+size_t xi2mask_num_masks(const XI2Mask *mask);
+size_t xi2mask_mask_size(const XI2Mask *mask);
+void xi2mask_set_one_mask(XI2Mask *xi2mask, int deviceid,
+                          const unsigned char *mask, size_t mask_size);
+const unsigned char *xi2mask_get_one_mask(const XI2Mask *xi2mask, int deviceid);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inpututils.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscanfill.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscanfill.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscanfill.h	(Revision 52145)
@@ -0,0 +1,142 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SCANFILLINCLUDED
+#define SCANFILLINCLUDED
+/*
+ *     scanfill.h
+ *
+ *     Written by Brian Kelleher; Jan 1985
+ *
+ *     This file contains a few macros to help track
+ *     the edge of a filled object.  The object is assumed
+ *     to be filled in scanline order, and thus the
+ *     algorithm used is an extension of Bresenham's line
+ *     drawing algorithm which assumes that y is always the
+ *     major axis.
+ *     Since these pieces of code are the same for any filled shape,
+ *     it is more convenient to gather the library in one
+ *     place, but since these pieces of code are also in
+ *     the inner loops of output primitives, procedure call
+ *     overhead is out of the question.
+ *     See the author for a derivation if needed.
+ */
+
+/*
+ *  In scan converting polygons, we want to choose those pixels
+ *  which are inside the polygon.  Thus, we add .5 to the starting
+ *  x coordinate for both left and right edges.  Now we choose the
+ *  first pixel which is inside the pgon for the left edge and the
+ *  first pixel which is outside the pgon for the right edge.
+ *  Draw the left pixel, but not the right.
+ *
+ *  How to add .5 to the starting x coordinate:
+ *      If the edge is moving to the right, then subtract dy from the
+ *  error term from the general form of the algorithm.
+ *      If the edge is moving to the left, then add dy to the error term.
+ *
+ *  The reason for the difference between edges moving to the left
+ *  and edges moving to the right is simple:  If an edge is moving
+ *  to the right, then we want the algorithm to flip immediately.
+ *  If it is moving to the left, then we don't want it to flip until
+ *  we traverse an entire pixel.
+ */
+#define BRESINITPGON(dy, x1, x2, xStart, d, m, m1, incr1, incr2) { \
+    int dx;      /* local storage */ \
+\
+    /* \
+     *  if the edge is horizontal, then it is ignored \
+     *  and assumed not to be processed.  Otherwise, do this stuff. \
+     */ \
+    if ((dy) != 0) { \
+        xStart = (x1); \
+        dx = (x2) - xStart; \
+        if (dx < 0) { \
+            m = dx / (dy); \
+            m1 = m - 1; \
+            incr1 = -2 * dx + 2 * (dy) * m1; \
+            incr2 = -2 * dx + 2 * (dy) * m; \
+            d = 2 * m * (dy) - 2 * dx - 2 * (dy); \
+        } else { \
+            m = dx / (dy); \
+            m1 = m + 1; \
+            incr1 = 2 * dx - 2 * (dy) * m1; \
+            incr2 = 2 * dx - 2 * (dy) * m; \
+            d = -2 * m * (dy) + 2 * dx; \
+        } \
+    } \
+}
+
+#define BRESINCRPGON(d, minval, m, m1, incr1, incr2) { \
+    if (m1 > 0) { \
+        if (d > 0) { \
+            minval += m1; \
+            d += incr1; \
+        } \
+        else { \
+            minval += m; \
+            d += incr2; \
+        } \
+    } else {\
+        if (d >= 0) { \
+            minval += m1; \
+            d += incr1; \
+        } \
+        else { \
+            minval += m; \
+            d += incr2; \
+        } \
+    } \
+}
+
+/*
+ *     This structure contains all of the information needed
+ *     to run the bresenham algorithm.
+ *     The variables may be hardcoded into the declarations
+ *     instead of using this structure to make use of
+ *     register declarations.
+ */
+typedef struct {
+    int minor;                  /* minor axis        */
+    int d;                      /* decision variable */
+    int m, m1;                  /* slope and slope+1 */
+    int incr1, incr2;           /* error increments */
+} BRESINFO;
+
+#define BRESINITPGONSTRUCT(dmaj, min1, min2, bres) \
+	BRESINITPGON(dmaj, min1, min2, bres.minor, bres.d, \
+                     bres.m, bres.m1, bres.incr1, bres.incr2)
+
+#define BRESINCRPGONSTRUCT(bres) \
+        BRESINCRPGON(bres.d, bres.minor, bres.m, bres.m1, bres.incr1, bres.incr2)
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscanfill.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hotplug.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hotplug.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hotplug.h	(Revision 52145)
@@ -0,0 +1,106 @@
+/*
+ * Copyright ¬© 2006-2007 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef HOTPLUG_H
+#define HOTPLUG_H
+
+#include "list.h"
+
+extern _X_EXPORT void config_pre_init(void);
+extern _X_EXPORT void config_init(void);
+extern _X_EXPORT void config_fini(void);
+
+enum { ODEV_ATTRIB_UNKNOWN = -1, ODEV_ATTRIB_STRING = 0, ODEV_ATTRIB_INT };
+
+struct OdevAttribute {
+    struct xorg_list member;
+    int attrib_id;
+    union {
+        char *attrib_name;
+        int attrib_value;
+    };
+    int attrib_type;
+};
+
+struct OdevAttributes {
+    struct xorg_list list;
+};
+
+/* Note starting with xserver 1.16 this function never fails */
+struct OdevAttributes *
+config_odev_allocate_attribute_list(void);
+
+void
+config_odev_free_attribute_list(struct OdevAttributes *attribs);
+
+/* Note starting with xserver 1.16 this function never fails */
+Bool
+config_odev_add_attribute(struct OdevAttributes *attribs, int attrib,
+                          const char *attrib_name);
+
+char *
+config_odev_get_attribute(struct OdevAttributes *attribs, int attrib_id);
+
+/* Note starting with xserver 1.16 this function never fails */
+Bool
+config_odev_add_int_attribute(struct OdevAttributes *attribs, int attrib,
+                              int attrib_value);
+
+int
+config_odev_get_int_attribute(struct OdevAttributes *attribs, int attrib,
+                              int def);
+
+void
+config_odev_free_attributes(struct OdevAttributes *attribs);
+
+/* path to kernel device node - Linux e.g. /dev/dri/card0 */
+#define ODEV_ATTRIB_PATH 1
+/* system device path - Linux e.g. /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0/drm/card1 */
+#define ODEV_ATTRIB_SYSPATH 2
+/* DRI-style bus id */
+#define ODEV_ATTRIB_BUSID 3
+/* Server managed FD */
+#define ODEV_ATTRIB_FD 4
+/* Major number of the device node pointed to by ODEV_ATTRIB_PATH */
+#define ODEV_ATTRIB_MAJOR 5
+/* Minor number of the device node pointed to by ODEV_ATTRIB_PATH */
+#define ODEV_ATTRIB_MINOR 6
+/* kernel driver name */
+#define ODEV_ATTRIB_DRIVER 7
+
+typedef void (*config_odev_probe_proc_ptr)(struct OdevAttributes *attribs);
+void config_odev_probe(config_odev_probe_proc_ptr probe_callback);
+
+#ifdef CONFIG_UDEV_KMS
+void NewGPUDeviceRequest(struct OdevAttributes *attribs);
+void DeleteGPUDeviceRequest(struct OdevAttributes *attribs);
+#endif
+
+#define ServerIsNotSeat0() (SeatId && strcmp(SeatId, "seat0"))
+
+struct xf86_platform_device *
+xf86_find_platform_device_by_devnum(int major, int minor);
+
+#endif                          /* HOTPLUG_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hotplug.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compositeext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compositeext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compositeext.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/*
+ * Copyright ¬© 2009 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _COMPOSITEEXT_H_
+#define _COMPOSITEEXT_H_
+
+#include "misc.h"
+#include "scrnintstr.h"
+
+extern _X_EXPORT Bool CompositeRegisterAlternateVisuals(ScreenPtr pScreen,
+                                                        VisualID * vids,
+                                                        int nVisuals);
+
+extern _X_EXPORT Bool CompositeRegisterImplicitRedirectionException(ScreenPtr pScreen,
+                                                                    VisualID parentVisual,
+                                                                    VisualID winVisual);
+
+extern _X_EXPORT RESTYPE CompositeClientWindowType;
+
+#endif                          /* _COMPOSITEEXT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compositeext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsync.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsync.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsync.h	(Revision 52145)
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for sync support.  \see dmxsync.c */
+
+#ifndef _DMXSYNC_H_
+#define _DMXSYNC_H_
+
+extern void dmxSyncActivate(const char *interval);
+extern void dmxSyncInit(void);
+extern void dmxSync(DMXScreenInfo * dmxScreen, Bool now);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxsync.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_context.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_context.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_context.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+ * Copyright ¬© 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * @file glamor_context.h
+ *
+ * This is the struct of state required for context switching in
+ * glamor.  It has to use types that don't require including either
+ * server headers or Xlib headers, since it will be included by both
+ * the server and the GLX (xlib) code.
+ */
+
+struct glamor_context {
+    /** Either an EGLDisplay or an Xlib Display */
+    void *display;
+
+    /** Either a GLXContext or an EGLContext. */
+    void *ctx;
+
+    /** The EGLSurface we should MakeCurrent to */
+    void *drawable;
+
+    /** The GLXDrawable we should MakeCurrent to */
+    uint32_t drawable_xid;
+
+    void (*make_current)(struct glamor_context *glamor_ctx);
+};
+
+Bool glamor_glx_screen_init(struct glamor_context *glamor_ctx);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_context.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transfer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transfer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transfer.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+ * Copyright ¬© 2014 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _GLAMOR_TRANSFER_H_
+#define _GLAMOR_TRANSFER_H_
+
+void
+glamor_format_for_pixmap(PixmapPtr pixmap, GLenum *format, GLenum *type);
+
+void
+glamor_upload_boxes(PixmapPtr pixmap, BoxPtr in_boxes, int in_nbox,
+                    int dx_src, int dy_src,
+                    int dx_dst, int dy_dst,
+                    uint8_t *bits, uint32_t byte_stride);
+
+void
+glamor_upload_region(PixmapPtr pixmap, RegionPtr region,
+                     int region_x, int region_y,
+                     uint8_t *bits, uint32_t byte_stride);
+
+void
+glamor_upload_pixmap(PixmapPtr pixmap);
+
+void
+glamor_download_boxes(PixmapPtr pixmap, BoxPtr in_boxes, int in_nbox,
+                      int dx_src, int dy_src,
+                      int dx_dst, int dy_dst,
+                      uint8_t *bits, uint32_t byte_stride);
+
+void
+glamor_download_rect(PixmapPtr pixmap, int x, int y, int w, int h, uint8_t *bits);
+
+void
+glamor_download_pixmap(PixmapPtr pixmap);
+
+#endif /* _GLAMOR_TRANSFER_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_transfer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcursor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcursor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcursor.h	(Revision 52145)
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Kevin E. Martin <kem@redhat.com>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for cursor support.  \see dmxcursor.c. */
+
+#ifndef DMXCURSOR_H
+#define DMXCURSOR_H
+
+#include "mipointer.h"
+
+/** Cursor private area. */
+typedef struct _dmxCursorPriv {
+    Cursor cursor;
+} dmxCursorPrivRec, *dmxCursorPrivPtr;
+
+/** Cursor functions for mi layer. \see dmxcursor.c \see dmxscrinit.c */
+extern miPointerScreenFuncRec dmxPointerCursorFuncs;
+
+/** Sprite functions for mi layer. \see dmxcursor.c \see dmxscrinit.c */
+extern miPointerSpriteFuncRec dmxPointerSpriteFuncs;
+
+extern void dmxReInitOrigins(void);
+extern void dmxInitOrigins(void);
+extern void dmxInitOverlap(void);
+extern void dmxCursorNoMulti(void);
+extern void dmxMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y);
+extern void dmxCheckCursor(void);
+extern int dmxOnScreen(int x, int y, DMXScreenInfo * dmxScreen);
+extern void dmxHideCursor(DMXScreenInfo * dmxScreen);
+
+extern void dmxBECreateCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool dmxBEFreeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+
+#define DMX_GET_CURSOR_PRIV(_pCursor, _pScreen) ((dmxCursorPrivPtr) \
+    dixLookupScreenPrivate(&(_pCursor)->devPrivates, CursorScreenKey, _pScreen))
+
+#define DMX_SET_CURSOR_PRIV(_pCursor, _pScreen, v) \
+    dixSetScreenPrivate(&(_pCursor)->devPrivates, CursorScreenKey, _pScreen, v)
+
+#endif                          /* DMXCURSOR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcursor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/debug.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/debug.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/debug.h	(Revision 52145)
@@ -0,0 +1,209 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for debug definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_DEBUG_H
+#define __X86EMU_DEBUG_H
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+/* checks to be enabled for "runtime" */
+
+#define CHECK_IP_FETCH_F                0x1
+#define CHECK_SP_ACCESS_F               0x2
+#define CHECK_MEM_ACCESS_F              0x4     /*using regular linear pointer */
+#define CHECK_DATA_ACCESS_F             0x8     /*using segment:offset */
+
+#ifdef DEBUG
+#define CHECK_IP_FETCH()              	(M.x86.check & CHECK_IP_FETCH_F)
+#define CHECK_SP_ACCESS()             	(M.x86.check & CHECK_SP_ACCESS_F)
+#define CHECK_MEM_ACCESS()            	(M.x86.check & CHECK_MEM_ACCESS_F)
+#define CHECK_DATA_ACCESS()           	(M.x86.check & CHECK_DATA_ACCESS_F)
+#else
+#define CHECK_IP_FETCH()
+#define CHECK_SP_ACCESS()
+#define CHECK_MEM_ACCESS()
+#define CHECK_DATA_ACCESS()
+#endif
+
+#ifdef DEBUG
+#define DEBUG_INSTRUMENT()    	(M.x86.debug & DEBUG_INSTRUMENT_F)
+#define DEBUG_DECODE()        	(M.x86.debug & DEBUG_DECODE_F)
+#define DEBUG_TRACE()         	(M.x86.debug & DEBUG_TRACE_F)
+#define DEBUG_STEP()          	(M.x86.debug & DEBUG_STEP_F)
+#define DEBUG_DISASSEMBLE()   	(M.x86.debug & DEBUG_DISASSEMBLE_F)
+#define DEBUG_BREAK()         	(M.x86.debug & DEBUG_BREAK_F)
+#define DEBUG_SVC()           	(M.x86.debug & DEBUG_SVC_F)
+#define DEBUG_SAVE_IP_CS()     (M.x86.debug & DEBUG_SAVE_IP_CS_F)
+
+#define DEBUG_FS()            	(M.x86.debug & DEBUG_FS_F)
+#define DEBUG_PROC()          	(M.x86.debug & DEBUG_PROC_F)
+#define DEBUG_SYSINT()        	(M.x86.debug & DEBUG_SYSINT_F)
+#define DEBUG_TRACECALL()     	(M.x86.debug & DEBUG_TRACECALL_F)
+#define DEBUG_TRACECALLREGS() 	(M.x86.debug & DEBUG_TRACECALL_REGS_F)
+#define DEBUG_SYS()           	(M.x86.debug & DEBUG_SYS_F)
+#define DEBUG_MEM_TRACE()     	(M.x86.debug & DEBUG_MEM_TRACE_F)
+#define DEBUG_IO_TRACE()      	(M.x86.debug & DEBUG_IO_TRACE_F)
+#define DEBUG_DECODE_NOPRINT() (M.x86.debug & DEBUG_DECODE_NOPRINT_F)
+#else
+#define DEBUG_INSTRUMENT()    	0
+#define DEBUG_DECODE()        	0
+#define DEBUG_TRACE()         	0
+#define DEBUG_STEP()          	0
+#define DEBUG_DISASSEMBLE()   	0
+#define DEBUG_BREAK()         	0
+#define DEBUG_SVC()           	0
+#define DEBUG_SAVE_IP_CS()     0
+#define DEBUG_FS()            	0
+#define DEBUG_PROC()          	0
+#define DEBUG_SYSINT()        	0
+#define DEBUG_TRACECALL()     	0
+#define DEBUG_TRACECALLREGS() 	0
+#define DEBUG_SYS()           	0
+#define DEBUG_MEM_TRACE()     	0
+#define DEBUG_IO_TRACE()      	0
+#define DEBUG_DECODE_NOPRINT() 0
+#endif
+
+#ifdef DEBUG
+
+#define DECODE_PRINTF(x)     	if (DEBUG_DECODE()) \
+									x86emu_decode_printf(x)
+#define DECODE_PRINTF2(x,y)  	if (DEBUG_DECODE()) \
+									x86emu_decode_printf2(x,y)
+
+/*
+ * The following allow us to look at the bytes of an instruction.  The
+ * first INCR_INSTRN_LEN, is called everytime bytes are consumed in
+ * the decoding process.  The SAVE_IP_CS is called initially when the
+ * major opcode of the instruction is accessed.
+ */
+#define INC_DECODED_INST_LEN(x)                    	\
+	if (DEBUG_DECODE())  	                       	\
+		x86emu_inc_decoded_inst_len(x)
+
+#define SAVE_IP_CS(x,y)                               			\
+	if (DEBUG_DECODE() | DEBUG_TRACECALL() | DEBUG_BREAK() \
+              | DEBUG_IO_TRACE() | DEBUG_SAVE_IP_CS()) { \
+		M.x86.saved_cs = x;                          			\
+		M.x86.saved_ip = y;                          			\
+	}
+#else
+#define INC_DECODED_INST_LEN(x)
+#define DECODE_PRINTF(x)
+#define DECODE_PRINTF2(x,y)
+#define SAVE_IP_CS(x,y)
+#endif
+
+#ifdef DEBUG
+#define TRACE_REGS()                                   		\
+	if (DEBUG_DISASSEMBLE()) {                         		\
+		x86emu_just_disassemble();                        	\
+		goto EndOfTheInstructionProcedure;             		\
+	}                                                   	\
+	if (DEBUG_TRACE() || DEBUG_DECODE()) X86EMU_trace_regs()
+#else
+#define TRACE_REGS()
+#endif
+
+#ifdef DEBUG
+#define SINGLE_STEP()		if (DEBUG_STEP()) x86emu_single_step()
+#else
+#define SINGLE_STEP()
+#endif
+
+#define TRACE_AND_STEP()	\
+	TRACE_REGS();			\
+	SINGLE_STEP()
+
+#ifdef DEBUG
+#define START_OF_INSTR()
+#define END_OF_INSTR()		EndOfTheInstructionProcedure: x86emu_end_instr();
+#define END_OF_INSTR_NO_TRACE()	x86emu_end_instr();
+#else
+#define START_OF_INSTR()
+#define END_OF_INSTR()
+#define END_OF_INSTR_NO_TRACE()
+#endif
+
+#ifdef DEBUG
+#define  CALL_TRACE(u,v,w,x,s)                                 \
+	if (DEBUG_TRACECALLREGS())									\
+		x86emu_dump_regs();                                     \
+	if (DEBUG_TRACECALL())                                     	\
+		printk("%04x:%04x: CALL %s%04x:%04x\n", u , v, s, w, x);
+#define RETURN_TRACE(n,u,v)                                    \
+	if (DEBUG_TRACECALLREGS())									\
+		x86emu_dump_regs();                                     \
+	if (DEBUG_TRACECALL())                                     	\
+		printk("%04x:%04x: %s\n",u,v,n);
+#else
+#define CALL_TRACE(u,v,w,x,s)
+#define RETURN_TRACE(n,u,v)
+#endif
+
+#ifdef DEBUG
+#define	DB(x)	x
+#else
+#define	DB(x)
+#endif
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+    extern void x86emu_inc_decoded_inst_len(int x);
+    extern void x86emu_decode_printf(const char *x);
+    extern void x86emu_decode_printf2(const char *x, int y);
+    extern void x86emu_just_disassemble(void);
+    extern void x86emu_single_step(void);
+    extern void x86emu_end_instr(void);
+    extern void x86emu_dump_regs(void);
+    extern void x86emu_dump_xregs(void);
+    extern void x86emu_print_int_vect(u16 iv);
+    extern void x86emu_instrument_instruction(void);
+    extern void x86emu_check_ip_access(void);
+    extern void x86emu_check_sp_access(void);
+    extern void x86emu_check_mem_access(u32 p);
+    extern void x86emu_check_data_access(uint s, uint o);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_DEBUG_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/debug.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Pci.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Pci.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Pci.h	(Revision 52145)
@@ -0,0 +1,259 @@
+/*
+ * Copyright 1998 by Concurrent Computer Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Concurrent Computer
+ * Corporation not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Concurrent Computer Corporation makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Copyright 1998 by Metro Link Incorporated
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Metro Link
+ * Incorporated not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Metro Link Incorporated makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * This file is derived in part from the original xf86_PCI.h that included
+ * following copyright message:
+ *
+ * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holder(s)
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holder(s) make(s) no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains just the public interface to the PCI code.
+ * Drivers should use this file rather than Pci.h.
+ */
+
+#ifndef _XF86PCI_H
+#define _XF86PCI_H 1
+#include <X11/Xarch.h>
+#include <X11/Xfuncproto.h>
+#include "misc.h"
+#include <pciaccess.h>
+
+/*
+ * PCI cfg space definitions (e.g. stuff right out of the PCI spec)
+ */
+
+/* Device identification register */
+#define PCI_ID_REG			0x00
+
+/* Command and status register */
+#define PCI_CMD_STAT_REG		0x04
+#define PCI_CMD_BASE_REG		0x10
+#define PCI_CMD_BIOS_REG		0x30
+#define PCI_CMD_MASK			0xffff
+#define PCI_CMD_IO_ENABLE		0x01
+#define PCI_CMD_MEM_ENABLE		0x02
+#define PCI_CMD_MASTER_ENABLE		0x04
+#define PCI_CMD_SPECIAL_ENABLE		0x08
+#define PCI_CMD_INVALIDATE_ENABLE	0x10
+#define PCI_CMD_PALETTE_ENABLE		0x20
+#define PCI_CMD_PARITY_ENABLE		0x40
+#define PCI_CMD_STEPPING_ENABLE		0x80
+#define PCI_CMD_SERR_ENABLE		0x100
+#define PCI_CMD_BACKTOBACK_ENABLE	0x200
+#define PCI_CMD_BIOS_ENABLE		0x01
+
+/* base class */
+#define PCI_CLASS_REG		0x08
+#define PCI_CLASS_MASK		0xff000000
+#define PCI_CLASS_SHIFT		24
+#define PCI_CLASS_EXTRACT(x)	\
+	(((x) & PCI_CLASS_MASK) >> PCI_CLASS_SHIFT)
+
+/* base class values */
+#define PCI_CLASS_PREHISTORIC		0x00
+#define PCI_CLASS_MASS_STORAGE		0x01
+#define PCI_CLASS_NETWORK		0x02
+#define PCI_CLASS_DISPLAY		0x03
+#define PCI_CLASS_MULTIMEDIA		0x04
+#define PCI_CLASS_MEMORY		0x05
+#define PCI_CLASS_BRIDGE		0x06
+#define PCI_CLASS_COMMUNICATIONS	0x07
+#define PCI_CLASS_SYSPERIPH		0x08
+#define PCI_CLASS_INPUT			0x09
+#define PCI_CLASS_DOCKING		0x0a
+#define PCI_CLASS_PROCESSOR		0x0b
+#define PCI_CLASS_SERIALBUS		0x0c
+#define PCI_CLASS_WIRELESS		0x0d
+#define PCI_CLASS_I2O			0x0e
+#define PCI_CLASS_SATELLITE		0x0f
+#define PCI_CLASS_CRYPT			0x10
+#define PCI_CLASS_DATA_ACQUISTION	0x11
+#define PCI_CLASS_UNDEFINED		0xff
+
+/* sub class */
+#define PCI_SUBCLASS_MASK	0x00ff0000
+#define PCI_SUBCLASS_SHIFT	16
+#define PCI_SUBCLASS_EXTRACT(x)	\
+	(((x) & PCI_SUBCLASS_MASK) >> PCI_SUBCLASS_SHIFT)
+
+/* Sub class values */
+/* 0x00 prehistoric subclasses */
+#define PCI_SUBCLASS_PREHISTORIC_MISC	0x00
+#define PCI_SUBCLASS_PREHISTORIC_VGA	0x01
+
+/* 0x03 display subclasses */
+#define PCI_SUBCLASS_DISPLAY_VGA	0x00
+#define PCI_SUBCLASS_DISPLAY_XGA	0x01
+#define PCI_SUBCLASS_DISPLAY_MISC	0x80
+
+/* 0x04 multimedia subclasses */
+#define PCI_SUBCLASS_MULTIMEDIA_VIDEO	0x00
+#define PCI_SUBCLASS_MULTIMEDIA_AUDIO	0x01
+#define PCI_SUBCLASS_MULTIMEDIA_MISC	0x80
+
+/* 0x06 bridge subclasses */
+#define PCI_SUBCLASS_BRIDGE_HOST	0x00
+#define PCI_SUBCLASS_BRIDGE_ISA		0x01
+#define PCI_SUBCLASS_BRIDGE_EISA	0x02
+#define PCI_SUBCLASS_BRIDGE_MC		0x03
+#define PCI_SUBCLASS_BRIDGE_PCI		0x04
+#define PCI_SUBCLASS_BRIDGE_PCMCIA	0x05
+#define PCI_SUBCLASS_BRIDGE_NUBUS	0x06
+#define PCI_SUBCLASS_BRIDGE_CARDBUS	0x07
+#define PCI_SUBCLASS_BRIDGE_RACEWAY	0x08
+#define PCI_SUBCLASS_BRIDGE_MISC	0x80
+#define PCI_IF_BRIDGE_PCI_SUBTRACTIVE	0x01
+
+/* 0x0b processor subclasses */
+#define PCI_SUBCLASS_PROCESSOR_386	0x00
+#define PCI_SUBCLASS_PROCESSOR_486	0x01
+#define PCI_SUBCLASS_PROCESSOR_PENTIUM	0x02
+#define PCI_SUBCLASS_PROCESSOR_ALPHA	0x10
+#define PCI_SUBCLASS_PROCESSOR_POWERPC	0x20
+#define PCI_SUBCLASS_PROCESSOR_MIPS	0x30
+#define PCI_SUBCLASS_PROCESSOR_COPROC	0x40
+
+/* PCI-PCI bridge mapping registers */
+#define PCI_PCI_BRIDGE_BUS_REG		0x18
+#define PCI_SUBORDINATE_BUS_MASK	0x00ff0000
+#define PCI_SECONDARY_BUS_MASK		0x0000ff00
+#define PCI_PRIMARY_BUS_MASK		0x000000ff
+
+#define PCI_PCI_BRIDGE_IO_REG		0x1c
+#define PCI_PCI_BRIDGE_MEM_REG		0x20
+#define PCI_PCI_BRIDGE_PMEM_REG		0x24
+
+#define PCI_PCI_BRIDGE_CONTROL_REG	0x3E
+#define PCI_PCI_BRIDGE_PARITY_EN	0x01
+#define PCI_PCI_BRIDGE_SERR_EN		0x02
+#define PCI_PCI_BRIDGE_ISA_EN		0x04
+#define PCI_PCI_BRIDGE_VGA_EN		0x08
+#define PCI_PCI_BRIDGE_MASTER_ABORT_EN	0x20
+#define PCI_PCI_BRIDGE_SECONDARY_RESET	0x40
+#define PCI_PCI_BRIDGE_FAST_B2B_EN	0x80
+
+/* Subsystem identification register */
+#define PCI_SUBSYSTEM_ID_REG		0x2c
+
+/* User defined cfg space regs */
+#define PCI_REG_USERCONFIG		0x40
+#define PCI_OPTION_REG			0x40
+
+/*
+ * Typedefs, etc...
+ */
+
+/* Primitive Types */
+typedef unsigned long ADDRESS;  /* Memory/PCI address */
+typedef unsigned long IOADDRESS _X_DEPRECATED;  /* Must be large enough for a pointer */
+typedef CARD32 PCITAG _X_DEPRECATED;
+
+typedef enum {
+    PCI_MEM,
+    PCI_MEM_SIZE,
+    PCI_MEM_SPARSE_BASE,
+    PCI_MEM_SPARSE_MASK,
+    PCI_IO,
+    PCI_IO_SIZE,
+    PCI_IO_SPARSE_BASE,
+    PCI_IO_SPARSE_MASK
+} PciAddrType;
+
+/* Public PCI access functions */
+extern _X_EXPORT Bool xf86scanpci(void);
+
+/* Domain access functions.  Some of these probably shouldn't be public */
+extern _X_EXPORT struct pci_io_handle *xf86MapLegacyIO(struct pci_device *dev);
+extern _X_EXPORT void xf86UnmapLegacyIO(struct pci_device *,
+                                        struct pci_io_handle *);
+
+#endif                          /* _XF86PCI_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Pci.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-keyboard.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-keyboard.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-keyboard.h	(Revision 52145)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB keyboard driver. \see usb-keyboard.c \see usb-common.c */
+
+#ifndef _USB_KEYBOARD_H_
+#define _USB_KEYBOARD_H_
+extern void kbdUSBInit(DevicePtr pDev);
+extern void kbdUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int kbdUSBOn(DevicePtr pDev);
+extern void kbdUSBRead(DevicePtr pDev,
+                       dmxMotionProcPtr motion,
+                       dmxEnqueueProcPtr enqueue,
+                       dmxCheckSpecialProcPtr checkspecial, DMXBlockType block);
+extern void kbdUSBCtrl(DevicePtr pDev, KeybdCtrl * ctrl);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-keyboard.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/propertyst.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/propertyst.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/propertyst.h	(Revision 52145)
@@ -0,0 +1,66 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PROPERTYSTRUCT_H
+#define PROPERTYSTRUCT_H
+#include "misc.h"
+#include "property.h"
+#include "privates.h"
+/* 
+ *   PROPERTY -- property element
+ */
+
+typedef struct _Property {
+    struct _Property *next;
+    ATOM propertyName;
+    ATOM type;                  /* ignored by server */
+    uint32_t format;            /* format of data for swapping - 8,16,32 */
+    uint32_t size;              /* size of data in (format/8) bytes */
+    void *data;                 /* private to client */
+    PrivateRec *devPrivates;
+} PropertyRec;
+
+#endif                          /* PROPERTYSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/propertyst.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcompat.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcompat.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcompat.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to VDL compatibility support.  \see dmxcompat.c
+ *
+ * This file is not used by the DMX server.
+ */
+
+#ifndef _DMXCOMPAT_H_
+#define _DMXCOMPAT_H_
+
+extern DMXConfigEntryPtr dmxVDLRead(const char *filename);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcompat.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstubs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstubs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstubs.h	(Revision 52145)
@@ -0,0 +1,43 @@
+#ifndef DIXFONTSTUBS_H
+#define DIXFONTSTUBS_H 1
+
+/*
+ * libXfont stubs replacements
+ * This header exists solely for the purpose of sdksyms generation;
+ * source code should #include "dixfonts.h" instead, which pulls in these
+ * declarations from <X11/fonts/fontproto.h>
+ */
+extern _X_EXPORT int client_auth_generation(ClientPtr client);
+
+extern _X_EXPORT void DeleteFontClientID(Font id);
+
+extern _X_EXPORT int GetDefaultPointSize(void);
+
+extern _X_EXPORT Font GetNewFontClientID(void);
+
+extern _X_EXPORT int init_fs_handlers(FontPathElementPtr fpe,
+                                      BlockHandlerProcPtr block_handler);
+
+extern _X_EXPORT int RegisterFPEFunctions(NameCheckFunc name_func,
+                                          InitFpeFunc init_func,
+                                          FreeFpeFunc free_func,
+                                          ResetFpeFunc reset_func,
+                                          OpenFontFunc open_func,
+                                          CloseFontFunc close_func,
+                                          ListFontsFunc list_func,
+                                          StartLfwiFunc start_lfwi_func,
+                                          NextLfwiFunc next_lfwi_func,
+                                          WakeupFpeFunc wakeup_func,
+                                          ClientDiedFunc client_died,
+                                          LoadGlyphsFunc load_glyphs,
+                                          StartLaFunc start_list_alias_func,
+                                          NextLaFunc next_list_alias_func,
+                                          SetPathFunc set_path_func);
+
+extern _X_EXPORT void remove_fs_handlers(FontPathElementPtr fpe,
+                                         BlockHandlerProcPtr blockHandler,
+                                         Bool all);
+
+extern _X_EXPORT int StoreFontClientFont(FontPtr pfont, Font id);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dixfontstubs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcb.h	(Revision 52145)
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Header file for connection block functions.  \see dmxcb.c.
+ */
+
+#ifndef _DMXCB_H_
+#define _DMXCB_H_
+/** The cursor position, in global coordinates. */
+extern int dmxGlobalWidth, dmxGlobalHeight;
+
+/** #dmxComputeWidthHeight can either recompute the global bounding box
+ * or not. */
+typedef enum {
+    DMX_RECOMPUTE_BOUNDING_BOX,
+    DMX_NO_RECOMPUTE_BOUNDING_BOX
+} DMXRecomputeFlag;
+
+extern void dmxSetWidthHeight(int width, int height);
+extern void dmxComputeWidthHeight(DMXRecomputeFlag flag);
+extern void dmxConnectionBlockCallback(void);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closestr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closestr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closestr.h	(Revision 52145)
@@ -0,0 +1,126 @@
+/*
+
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifndef CLOSESTR_H
+#define CLOSESTR_H
+
+#include <X11/Xproto.h>
+#include "closure.h"
+#include "dix.h"
+#include "misc.h"
+#include "gcstruct.h"
+
+/* closure structures */
+
+/* OpenFont */
+
+typedef struct _OFclosure {
+    ClientPtr client;
+    short current_fpe;
+    short num_fpes;
+    FontPathElementPtr *fpe_list;
+    Mask flags;
+
+/* XXX -- get these from request buffer instead? */
+    const char *origFontName;
+    int origFontNameLen;
+    XID fontid;
+    char *fontname;
+    int fnamelen;
+    FontPtr non_cachable_font;
+} OFclosureRec;
+
+/* ListFontsWithInfo */
+
+#define XLFDMAXFONTNAMELEN	256
+typedef struct _LFWIstate {
+    char pattern[XLFDMAXFONTNAMELEN];
+    int patlen;
+    int current_fpe;
+    int max_names;
+    Bool list_started;
+    void *private;
+} LFWIstateRec, *LFWIstatePtr;
+
+typedef struct _LFWIclosure {
+    ClientPtr client;
+    int num_fpes;
+    FontPathElementPtr *fpe_list;
+    xListFontsWithInfoReply *reply;
+    int length;
+    LFWIstateRec current;
+    LFWIstateRec saved;
+    int savedNumFonts;
+    Bool haveSaved;
+    char *savedName;
+} LFWIclosureRec;
+
+/* ListFonts */
+
+typedef struct _LFclosure {
+    ClientPtr client;
+    int num_fpes;
+    FontPathElementPtr *fpe_list;
+    FontNamesPtr names;
+    LFWIstateRec current;
+    LFWIstateRec saved;
+    Bool haveSaved;
+    char *savedName;
+    int savedNameLen;
+} LFclosureRec;
+
+/* PolyText */
+
+typedef struct _PTclosure {
+    ClientPtr client;
+    DrawablePtr pDraw;
+    GC *pGC;
+    unsigned char *pElt;
+    unsigned char *endReq;
+    unsigned char *data;
+    int xorg;
+    int yorg;
+    CARD8 reqType;
+    XID did;
+    int err;
+} PTclosureRec;
+
+/* ImageText */
+
+typedef struct _ITclosure {
+    ClientPtr client;
+    DrawablePtr pDraw;
+    GC *pGC;
+    BYTE nChars;
+    unsigned char *data;
+    int xorg;
+    int yorg;
+    CARD8 reqType;
+    XID did;
+} ITclosureRec;
+#endif                          /* CLOSESTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/closestr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86bigfontsrv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86bigfontsrv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86bigfontsrv.h	(Revision 52145)
@@ -0,0 +1,33 @@
+/*
+ * Copyright ¬© 2010 Yaakov Selkowitz
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XF86BIGFONTSRV_H_
+#define _XF86BIGFONTSRV_H_
+
+#include <X11/fonts/font.h>
+
+extern void XF86BigfontFreeFontShm(FontPtr);
+extern void XF86BigfontCleanup(void);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86bigfontsrv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2.h	(Revision 52145)
@@ -0,0 +1,362 @@
+/*
+ * Copyright ¬© 2007 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian H√∏gsberg (krh@redhat.com)
+ */
+
+#ifndef _DRI2_H_
+#define _DRI2_H_
+
+#include <X11/extensions/dri2tokens.h>
+
+/* Version 2 structure (with format at the end) */
+typedef struct {
+    unsigned int attachment;
+    unsigned int name;
+    unsigned int pitch;
+    unsigned int cpp;
+    unsigned int flags;
+    unsigned int format;
+    void *driverPrivate;
+} DRI2BufferRec, *DRI2BufferPtr;
+
+extern CARD8 dri2_major;        /* version of DRI2 supported by DDX */
+extern CARD8 dri2_minor;
+
+typedef DRI2BufferRec DRI2Buffer2Rec, *DRI2Buffer2Ptr;
+typedef void (*DRI2SwapEventPtr) (ClientPtr client, void *data, int type,
+                                  CARD64 ust, CARD64 msc, CARD32 sbc);
+
+typedef DRI2BufferPtr(*DRI2CreateBuffersProcPtr) (DrawablePtr pDraw,
+                                                  unsigned int *attachments,
+                                                  int count);
+typedef void (*DRI2DestroyBuffersProcPtr) (DrawablePtr pDraw,
+                                           DRI2BufferPtr buffers, int count);
+typedef void (*DRI2CopyRegionProcPtr) (DrawablePtr pDraw,
+                                       RegionPtr pRegion,
+                                       DRI2BufferPtr pDestBuffer,
+                                       DRI2BufferPtr pSrcBuffer);
+typedef void (*DRI2WaitProcPtr) (WindowPtr pWin, unsigned int sequence);
+typedef int (*DRI2AuthMagicProcPtr) (int fd, uint32_t magic);
+typedef int (*DRI2AuthMagic2ProcPtr) (ScreenPtr pScreen, uint32_t magic);
+
+/**
+ * Schedule a buffer swap
+ *
+ * This callback is used to support glXSwapBuffers and the OML_sync_control
+ * extension (see it for a description of the params).
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the server may block the client at the next
+ * GLX request using DRI2WaitSwap. When the event arrives, drivers should call
+ * \c DRI2SwapComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * The DDX is responsible for doing a flip, exchange, or blit of the swap
+ * when the corresponding event arrives.  The \c DRI2CanFlip and
+ * \c DRI2CanExchange functions can be used as helpers for this purpose.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param pDestBuffer current front buffer
+ * \param pSrcBuffer current back buffer
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ * \param func function to call when the swap completes
+ * \param data data for the callback \p func.
+ */
+typedef int (*DRI2ScheduleSwapProcPtr) (ClientPtr client,
+                                        DrawablePtr pDraw,
+                                        DRI2BufferPtr pDestBuffer,
+                                        DRI2BufferPtr pSrcBuffer,
+                                        CARD64 * target_msc,
+                                        CARD64 divisor,
+                                        CARD64 remainder,
+                                        DRI2SwapEventPtr func, void *data);
+typedef DRI2BufferPtr(*DRI2CreateBufferProcPtr) (DrawablePtr pDraw,
+                                                 unsigned int attachment,
+                                                 unsigned int format);
+typedef void (*DRI2DestroyBufferProcPtr) (DrawablePtr pDraw,
+                                          DRI2BufferPtr buffer);
+/**
+ * Notifies driver when DRI2GetBuffers reuses a dri2 buffer.
+ *
+ * Driver may rename the dri2 buffer in this notify if it is required.
+ *
+ * \param pDraw drawable whose count we want
+ * \param buffer buffer that will be returned to client
+ */
+typedef void (*DRI2ReuseBufferNotifyProcPtr) (DrawablePtr pDraw,
+                                              DRI2BufferPtr buffer);
+/**
+ * Get current media stamp counter values
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.
+ *
+ * Drivers should return the current frame counter and the timestamp from
+ * when the returned frame count was last incremented.
+ *
+ * The count should correspond to the screen where the drawable is currently
+ * visible.  If the drawable isn't visible (e.g. redirected), the server
+ * should return BadDrawable to the client, pending GLX spec updates to
+ * define this behavior.
+ *
+ * \param pDraw drawable whose count we want
+ * \param ust timestamp from when the count was last incremented.
+ * \param mst current frame count
+ */
+typedef int (*DRI2GetMSCProcPtr) (DrawablePtr pDraw, CARD64 * ust,
+                                  CARD64 * msc);
+/**
+ * Schedule a frame count related wait
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.  See those specifications for details on how to handle
+ * the divisor and remainder parameters.
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the driver should block the client using
+ * \c DRI2BlockClient.  When the event arrives, drivers should call
+ * \c DRI2WaitMSCComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ */
+typedef int (*DRI2ScheduleWaitMSCProcPtr) (ClientPtr client,
+                                           DrawablePtr pDraw,
+                                           CARD64 target_msc,
+                                           CARD64 divisor, CARD64 remainder);
+
+typedef void (*DRI2InvalidateProcPtr) (DrawablePtr pDraw, void *data, XID id);
+
+/**
+ * DRI2 calls this hook when ever swap_limit is going to be changed. Default
+ * implementation for the hook only accepts one as swap_limit. If driver can
+ * support other swap_limits it has to implement supported limits with this
+ * callback.
+ *
+ * \param pDraw drawable whos swap_limit is going to be changed
+ * \param swap_limit new swap_limit that going to be set
+ * \return TRUE if limit is support, FALSE if not.
+ */
+typedef Bool (*DRI2SwapLimitValidateProcPtr) (DrawablePtr pDraw,
+                                              int swap_limit);
+
+typedef DRI2BufferPtr(*DRI2CreateBuffer2ProcPtr) (ScreenPtr pScreen,
+                                                  DrawablePtr pDraw,
+                                                  unsigned int attachment,
+                                                  unsigned int format);
+typedef void (*DRI2DestroyBuffer2ProcPtr) (ScreenPtr pScreen, DrawablePtr pDraw,
+                                          DRI2BufferPtr buffer);
+
+typedef void (*DRI2CopyRegion2ProcPtr) (ScreenPtr pScreen, DrawablePtr pDraw,
+                                        RegionPtr pRegion,
+                                        DRI2BufferPtr pDestBuffer,
+                                        DRI2BufferPtr pSrcBuffer);
+
+/**
+ * \brief Get the value of a parameter.
+ *
+ * The parameter's \a value is looked up on the screen associated with
+ * \a pDrawable.
+ *
+ * \return \c Success or error code.
+ */
+typedef int (*DRI2GetParamProcPtr) (ClientPtr client,
+                                    DrawablePtr pDrawable,
+                                    CARD64 param,
+                                    BOOL *is_param_recognized,
+                                    CARD64 *value);
+
+/**
+ * Version of the DRI2InfoRec structure defined in this header
+ */
+#define DRI2INFOREC_VERSION 9
+
+typedef struct {
+    unsigned int version;       /**< Version of this struct */
+    int fd;
+    const char *driverName;
+    const char *deviceName;
+
+    DRI2CreateBufferProcPtr CreateBuffer;
+    DRI2DestroyBufferProcPtr DestroyBuffer;
+    DRI2CopyRegionProcPtr CopyRegion;
+    DRI2WaitProcPtr Wait;
+
+    /* added in version 4 */
+
+    DRI2ScheduleSwapProcPtr ScheduleSwap;
+    DRI2GetMSCProcPtr GetMSC;
+    DRI2ScheduleWaitMSCProcPtr ScheduleWaitMSC;
+
+    /* number of drivers in the driverNames array */
+    unsigned int numDrivers;
+    /* array of driver names, indexed by DRI2Driver* driver types */
+    /* a name of NULL means that driver is not supported */
+    const char *const *driverNames;
+
+    /* added in version 5 */
+
+    DRI2AuthMagicProcPtr AuthMagic;
+
+    /* added in version 6 */
+
+    DRI2ReuseBufferNotifyProcPtr ReuseBufferNotify;
+    DRI2SwapLimitValidateProcPtr SwapLimitValidate;
+
+    /* added in version 7 */
+    DRI2GetParamProcPtr GetParam;
+
+    /* added in version 8 */
+    /* AuthMagic callback which passes extra context */
+    /* If this is NULL the AuthMagic callback is used */
+    /* If this is non-NULL the AuthMagic callback is ignored */
+    DRI2AuthMagic2ProcPtr AuthMagic2;
+
+    /* added in version 9 */
+    DRI2CreateBuffer2ProcPtr CreateBuffer2;
+    DRI2DestroyBuffer2ProcPtr DestroyBuffer2;
+    DRI2CopyRegion2ProcPtr CopyRegion2;
+} DRI2InfoRec, *DRI2InfoPtr;
+
+extern _X_EXPORT Bool DRI2ScreenInit(ScreenPtr pScreen, DRI2InfoPtr info);
+
+extern _X_EXPORT void DRI2CloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRI2HasSwapControl(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRI2Connect(ClientPtr client, ScreenPtr pScreen,
+                                  unsigned int driverType,
+                                  int *fd,
+                                  const char **driverName,
+                                  const char **deviceName);
+
+extern _X_EXPORT Bool DRI2Authenticate(ClientPtr client, ScreenPtr pScreen, uint32_t magic);
+
+extern _X_EXPORT int DRI2CreateDrawable(ClientPtr client,
+                                        DrawablePtr pDraw,
+                                        XID id,
+                                        DRI2InvalidateProcPtr invalidate,
+                                        void *priv);
+
+extern _X_EXPORT int DRI2CreateDrawable2(ClientPtr client,
+                                         DrawablePtr pDraw,
+                                         XID id,
+                                         DRI2InvalidateProcPtr invalidate,
+                                         void *priv,
+                                         XID *dri2_id_out);
+
+extern _X_EXPORT DRI2BufferPtr *DRI2GetBuffers(DrawablePtr pDraw,
+                                               int *width,
+                                               int *height,
+                                               unsigned int *attachments,
+                                               int count, int *out_count);
+
+extern _X_EXPORT int DRI2CopyRegion(DrawablePtr pDraw,
+                                    RegionPtr pRegion,
+                                    unsigned int dest, unsigned int src);
+
+/**
+ * Determine the major and minor version of the DRI2 extension.
+ *
+ * Provides a mechanism to other modules (e.g., 2D drivers) to determine the
+ * version of the DRI2 extension.  While it is possible to peek directly at
+ * the \c XF86ModuleData from a layered module, such a module will fail to
+ * load (due to an unresolved symbol) if the DRI2 extension is not loaded.
+ *
+ * \param major  Location to store the major verion of the DRI2 extension
+ * \param minor  Location to store the minor verion of the DRI2 extension
+ *
+ * \note
+ * This interface was added some time after the initial release of the DRI2
+ * module.  Layered modules that wish to use this interface must first test
+ * its existance by calling \c xf86LoaderCheckSymbol.
+ */
+extern _X_EXPORT void DRI2Version(int *major, int *minor);
+
+extern _X_EXPORT DRI2BufferPtr *DRI2GetBuffersWithFormat(DrawablePtr pDraw,
+                                                         int *width,
+                                                         int *height,
+                                                         unsigned int
+                                                         *attachments,
+                                                         int count,
+                                                         int *out_count);
+
+extern _X_EXPORT void DRI2SwapInterval(DrawablePtr pDrawable, int interval);
+extern _X_EXPORT Bool DRI2SwapLimit(DrawablePtr pDraw, int swap_limit);
+extern _X_EXPORT int DRI2SwapBuffers(ClientPtr client, DrawablePtr pDrawable,
+                                     CARD64 target_msc, CARD64 divisor,
+                                     CARD64 remainder, CARD64 * swap_target,
+                                     DRI2SwapEventPtr func, void *data);
+extern _X_EXPORT Bool DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable);
+
+extern _X_EXPORT int DRI2GetMSC(DrawablePtr pDrawable, CARD64 * ust,
+                                CARD64 * msc, CARD64 * sbc);
+extern _X_EXPORT int DRI2WaitMSC(ClientPtr client, DrawablePtr pDrawable,
+                                 CARD64 target_msc, CARD64 divisor,
+                                 CARD64 remainder);
+extern _X_EXPORT int ProcDRI2WaitMSCReply(ClientPtr client, CARD64 ust,
+                                          CARD64 msc, CARD64 sbc);
+extern _X_EXPORT int DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw,
+                                 CARD64 target_sbc);
+extern _X_EXPORT Bool DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw);
+
+extern _X_EXPORT Bool DRI2CanFlip(DrawablePtr pDraw);
+
+extern _X_EXPORT Bool DRI2CanExchange(DrawablePtr pDraw);
+
+/* Note: use *only* for MSC related waits */
+extern _X_EXPORT void DRI2BlockClient(ClientPtr client, DrawablePtr pDraw);
+
+extern _X_EXPORT void DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw,
+                                       int frame, unsigned int tv_sec,
+                                       unsigned int tv_usec, int type,
+                                       DRI2SwapEventPtr swap_complete,
+                                       void *swap_data);
+extern _X_EXPORT void DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw,
+                                          int frame, unsigned int tv_sec,
+                                          unsigned int tv_usec);
+
+extern _X_EXPORT int DRI2GetParam(ClientPtr client,
+                                  DrawablePtr pDrawable,
+                                  CARD64 param,
+                                  BOOL *is_param_recognized,
+                                  CARD64 *value);
+
+extern _X_EXPORT DrawablePtr DRI2UpdatePrime(DrawablePtr pDraw, DRI2BufferPtr pDest);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regs.h	(Revision 52145)
@@ -0,0 +1,348 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for x86 register definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_REGS_H
+#define __X86EMU_REGS_H
+
+#include <X11/Xfuncproto.h>
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#ifdef PACK
+#pragma PACK
+#endif
+
+/*
+ * General EAX, EBX, ECX, EDX type registers.  Note that for
+ * portability, and speed, the issue of byte swapping is not addressed
+ * in the registers.  All registers are stored in the default format
+ * available on the host machine.  The only critical issue is that the
+ * registers should line up EXACTLY in the same manner as they do in
+ * the 386.  That is:
+ *
+ * EAX & 0xff  === AL
+ * EAX & 0xffff == AX
+ *
+ * etc.  The result is that alot of the calculations can then be
+ * done using the native instruction set fully.
+ */
+
+#ifdef	__BIG_ENDIAN__
+
+typedef struct {
+    u32 e_reg;
+} I32_reg_t;
+
+typedef struct {
+    u16 filler0, x_reg;
+} I16_reg_t;
+
+typedef struct {
+    u8 filler0, filler1, h_reg, l_reg;
+} I8_reg_t;
+
+#else                           /* !__BIG_ENDIAN__ */
+
+typedef struct {
+    u32 e_reg;
+} I32_reg_t;
+
+typedef struct {
+    u16 x_reg;
+} I16_reg_t;
+
+typedef struct {
+    u8 l_reg, h_reg;
+} I8_reg_t;
+
+#endif                          /* BIG_ENDIAN */
+
+typedef union {
+    I32_reg_t I32_reg;
+    I16_reg_t I16_reg;
+    I8_reg_t I8_reg;
+} i386_general_register;
+
+struct i386_general_regs {
+    i386_general_register A, B, C, D;
+};
+
+typedef struct i386_general_regs Gen_reg_t;
+
+struct i386_special_regs {
+    i386_general_register SP, BP, SI, DI, IP;
+    u32 FLAGS;
+};
+
+/*  
+ * Segment registers here represent the 16 bit quantities
+ * CS, DS, ES, SS.
+ */
+
+#if defined(__sun) && defined(CS) /* avoid conflicts with Solaris sys/regset.h */
+# undef CS
+# undef DS
+# undef SS
+# undef ES
+# undef FS
+# undef GS
+#endif
+
+struct i386_segment_regs {
+    u16 CS, DS, SS, ES, FS, GS;
+};
+
+/* 8 bit registers */
+#define R_AH  gen.A.I8_reg.h_reg
+#define R_AL  gen.A.I8_reg.l_reg
+#define R_BH  gen.B.I8_reg.h_reg
+#define R_BL  gen.B.I8_reg.l_reg
+#define R_CH  gen.C.I8_reg.h_reg
+#define R_CL  gen.C.I8_reg.l_reg
+#define R_DH  gen.D.I8_reg.h_reg
+#define R_DL  gen.D.I8_reg.l_reg
+
+/* 16 bit registers */
+#define R_AX  gen.A.I16_reg.x_reg
+#define R_BX  gen.B.I16_reg.x_reg
+#define R_CX  gen.C.I16_reg.x_reg
+#define R_DX  gen.D.I16_reg.x_reg
+
+/* 32 bit extended registers */
+#define R_EAX  gen.A.I32_reg.e_reg
+#define R_EBX  gen.B.I32_reg.e_reg
+#define R_ECX  gen.C.I32_reg.e_reg
+#define R_EDX  gen.D.I32_reg.e_reg
+
+/* special registers */
+#define R_SP  spc.SP.I16_reg.x_reg
+#define R_BP  spc.BP.I16_reg.x_reg
+#define R_SI  spc.SI.I16_reg.x_reg
+#define R_DI  spc.DI.I16_reg.x_reg
+#define R_IP  spc.IP.I16_reg.x_reg
+#define R_FLG spc.FLAGS
+
+/* special registers */
+#define R_SP  spc.SP.I16_reg.x_reg
+#define R_BP  spc.BP.I16_reg.x_reg
+#define R_SI  spc.SI.I16_reg.x_reg
+#define R_DI  spc.DI.I16_reg.x_reg
+#define R_IP  spc.IP.I16_reg.x_reg
+#define R_FLG spc.FLAGS
+
+/* special registers */
+#define R_ESP  spc.SP.I32_reg.e_reg
+#define R_EBP  spc.BP.I32_reg.e_reg
+#define R_ESI  spc.SI.I32_reg.e_reg
+#define R_EDI  spc.DI.I32_reg.e_reg
+#define R_EIP  spc.IP.I32_reg.e_reg
+#define R_EFLG spc.FLAGS
+
+/* segment registers */
+#define R_CS  seg.CS
+#define R_DS  seg.DS
+#define R_SS  seg.SS
+#define R_ES  seg.ES
+#define R_FS  seg.FS
+#define R_GS  seg.GS
+
+/* flag conditions   */
+#define FB_CF 0x0001            /* CARRY flag  */
+#define FB_PF 0x0004            /* PARITY flag */
+#define FB_AF 0x0010            /* AUX  flag   */
+#define FB_ZF 0x0040            /* ZERO flag   */
+#define FB_SF 0x0080            /* SIGN flag   */
+#define FB_TF 0x0100            /* TRAP flag   */
+#define FB_IF 0x0200            /* INTERRUPT ENABLE flag */
+#define FB_DF 0x0400            /* DIR flag    */
+#define FB_OF 0x0800            /* OVERFLOW flag */
+
+/* 80286 and above always have bit#1 set */
+#define F_ALWAYS_ON  (0x0002)   /* flag bits always on */
+
+/*
+ * Define a mask for only those flag bits we will ever pass back 
+ * (via PUSHF) 
+ */
+#define F_MSK (FB_CF|FB_PF|FB_AF|FB_ZF|FB_SF|FB_TF|FB_IF|FB_DF|FB_OF)
+
+/* following bits masked in to a 16bit quantity */
+
+#define F_CF 0x0001             /* CARRY flag  */
+#define F_PF 0x0004             /* PARITY flag */
+#define F_AF 0x0010             /* AUX  flag   */
+#define F_ZF 0x0040             /* ZERO flag   */
+#define F_SF 0x0080             /* SIGN flag   */
+#define F_TF 0x0100             /* TRAP flag   */
+#define F_IF 0x0200             /* INTERRUPT ENABLE flag */
+#define F_DF 0x0400             /* DIR flag    */
+#define F_OF 0x0800             /* OVERFLOW flag */
+
+#define TOGGLE_FLAG(flag)     	(M.x86.R_FLG ^= (flag))
+#define SET_FLAG(flag)        	(M.x86.R_FLG |= (flag))
+#define CLEAR_FLAG(flag)      	(M.x86.R_FLG &= ~(flag))
+#define ACCESS_FLAG(flag)     	(M.x86.R_FLG & (flag))
+#define CLEARALL_FLAG(m)    	(M.x86.R_FLG = 0)
+
+#define CONDITIONAL_SET_FLAG(COND,FLAG) \
+  if (COND) SET_FLAG(FLAG); else CLEAR_FLAG(FLAG)
+
+#define F_PF_CALC 0x010000      /* PARITY flag has been calced    */
+#define F_ZF_CALC 0x020000      /* ZERO flag has been calced      */
+#define F_SF_CALC 0x040000      /* SIGN flag has been calced      */
+
+#define F_ALL_CALC      0xff0000        /* All have been calced   */
+
+/*
+ * Emulator machine state.
+ * Segment usage control.
+ */
+#define SYSMODE_SEG_DS_SS       0x00000001
+#define SYSMODE_SEGOVR_CS       0x00000002
+#define SYSMODE_SEGOVR_DS       0x00000004
+#define SYSMODE_SEGOVR_ES       0x00000008
+#define SYSMODE_SEGOVR_FS       0x00000010
+#define SYSMODE_SEGOVR_GS       0x00000020
+#define SYSMODE_SEGOVR_SS       0x00000040
+#define SYSMODE_PREFIX_REPE     0x00000080
+#define SYSMODE_PREFIX_REPNE    0x00000100
+#define SYSMODE_PREFIX_DATA     0x00000200
+#define SYSMODE_PREFIX_ADDR     0x00000400
+#define SYSMODE_INTR_PENDING    0x10000000
+#define SYSMODE_EXTRN_INTR      0x20000000
+#define SYSMODE_HALTED          0x40000000
+
+#define SYSMODE_SEGMASK (SYSMODE_SEG_DS_SS      | \
+						 SYSMODE_SEGOVR_CS      | \
+						 SYSMODE_SEGOVR_DS      | \
+						 SYSMODE_SEGOVR_ES      | \
+						 SYSMODE_SEGOVR_FS      | \
+						 SYSMODE_SEGOVR_GS      | \
+						 SYSMODE_SEGOVR_SS)
+#define SYSMODE_CLRMASK (SYSMODE_SEG_DS_SS      | \
+						 SYSMODE_SEGOVR_CS      | \
+						 SYSMODE_SEGOVR_DS      | \
+						 SYSMODE_SEGOVR_ES      | \
+						 SYSMODE_SEGOVR_FS      | \
+						 SYSMODE_SEGOVR_GS      | \
+						 SYSMODE_SEGOVR_SS      | \
+						 SYSMODE_PREFIX_DATA    | \
+						 SYSMODE_PREFIX_ADDR)
+
+#define  INTR_SYNCH           0x1
+#define  INTR_ASYNCH          0x2
+#define  INTR_HALTED          0x4
+
+typedef struct {
+    struct i386_general_regs gen;
+    struct i386_special_regs spc;
+    struct i386_segment_regs seg;
+    /*
+     * MODE contains information on:
+     *  REPE prefix             2 bits  repe,repne
+     *  SEGMENT overrides       5 bits  normal,DS,SS,CS,ES
+     *  Delayed flag set        3 bits  (zero, signed, parity)
+     *  reserved                6 bits
+     *  interrupt #             8 bits  instruction raised interrupt
+     *  BIOS video segregs      4 bits  
+     *  Interrupt Pending       1 bits  
+     *  Extern interrupt        1 bits
+     *  Halted                  1 bits
+     */
+    u32 mode;
+    volatile int intr;          /* mask of pending interrupts */
+    int debug;
+#ifdef DEBUG
+    int check;
+    u16 saved_ip;
+    u16 saved_cs;
+    int enc_pos;
+    int enc_str_pos;
+    char decode_buf[32];        /* encoded byte stream  */
+    char decoded_buf[256];      /* disassembled strings */
+#endif
+    u8 intno;
+    u8 __pad[3];
+} X86EMU_regs;
+
+/****************************************************************************
+REMARKS:
+Structure maintaining the emulator machine state.
+
+MEMBERS:
+mem_base		- Base real mode memory for the emulator
+mem_size		- Size of the real mode memory block for the emulator
+private			- private data pointer
+x86			- X86 registers
+****************************************************************************/
+typedef struct {
+    unsigned long mem_base;
+    unsigned long mem_size;
+    void *private;
+    X86EMU_regs x86;
+} X86EMU_sysEnv;
+
+#ifdef END_PACK
+#pragma END_PACK
+#endif
+
+/*----------------------------- Global Variables --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+/* Global emulator machine state.
+ *
+ * We keep it global to avoid pointer dereferences in the code for speed.
+ */
+
+    extern X86EMU_sysEnv _X86EMU_env;
+#define   M             _X86EMU_env
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+/* Function to log information at runtime */
+
+    void printk(const char *fmt, ...)
+        _X_ATTRIBUTE_PRINTF(1, 2);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_REGS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/regs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb24_32.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb24_32.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb24_32.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/*
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _FB24_32_H_
+#define _FB24_32_H_
+
+Bool
+
+fb24_32FinishScreenInit(ScreenPtr pScreen,
+                        void *pbits,
+                        int xsize,
+                        int ysize, int dpix, int dpiy, int width, int bpp);
+
+Bool
+
+fb24_32ScreenInit(ScreenPtr pScreen,
+                  void *pbits,
+                  int xsize, int ysize, int dpix, int dpiy, int width, int bpp);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb24_32.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgprop.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgprop.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgprop.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGPROP_H
+#define CHGPROP_H 1
+
+int SProcXChangeDeviceDontPropagateList(ClientPtr       /* client */
+    );
+
+int ProcXChangeDeviceDontPropagateList(ClientPtr        /* client */
+    );
+
+#endif                          /* CHGPROP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgprop.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/site.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/site.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/site.h	(Revision 52145)
@@ -0,0 +1,126 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+#ifndef SITE_H
+#define SITE_H
+/*
+ * The vendor string identifies the vendor responsible for the
+ * server executable.
+ */
+#ifndef VENDOR_STRING
+#define VENDOR_STRING "The X.Org Foundation"
+#endif
+
+/*
+ * The vendor release number identifies, for the purpose of submitting
+ * traceable bug reports, the release number of software produced
+ * by the vendor.
+ */
+#ifndef VENDOR_RELEASE
+#define VENDOR_RELEASE	6600
+#endif
+
+/*
+ * The following constants are provided solely as a last line of defense.  The
+ * normal build ALWAYS overrides them using a special rule given in
+ * server/dix/Imakefile.  If you want to change either of these constants, 
+ * you should set the DefaultFontPath or DefaultRGBDatabase configuration 
+ * parameters.
+ * DO NOT CHANGE THESE VALUES OR THE DIX IMAKEFILE!
+ */
+#ifndef COMPILEDDEFAULTFONTPATH
+#define COMPILEDDEFAULTFONTPATH	"/usr/share/fonts/X11/misc/"
+#endif
+
+/*
+ * The following constants contain default values for all of the variables 
+ * that can be initialized on the server command line or in the environment.
+ */
+#define COMPILEDDEFAULTFONT	"fixed"
+#define COMPILEDCURSORFONT	"cursor"
+#ifndef COMPILEDDISPLAYCLASS
+#define COMPILEDDISPLAYCLASS	"MIT-unspecified"
+#endif
+#define DEFAULT_TIMEOUT		60      /* seconds */
+#define DEFAULT_KEYBOARD_CLICK 	0
+#define DEFAULT_BELL		50
+#define DEFAULT_BELL_PITCH	400
+#define DEFAULT_BELL_DURATION	100
+#define DEFAULT_AUTOREPEAT	TRUE
+#define DEFAULT_AUTOREPEATS	{\
+        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+
+#define DEFAULT_LEDS		0x0     /* all off */
+#define DEFAULT_LEDS_MASK	0xffffffff      /* 32 */
+#define DEFAULT_INT_RESOLUTION		1000
+#define DEFAULT_INT_MIN_VALUE		0
+#define DEFAULT_INT_MAX_VALUE		100
+#define DEFAULT_INT_DISPLAYED		0
+
+#define DEFAULT_PTR_NUMERATOR	2
+#define DEFAULT_PTR_DENOMINATOR	1
+#define DEFAULT_PTR_THRESHOLD	4
+
+#define DEFAULT_SCREEN_SAVER_TIME (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_INTERVAL (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_BLANKING PreferBlanking
+#define DEFAULT_SCREEN_SAVER_EXPOSURES AllowExposures
+#ifndef DEFAULT_ACCESS_CONTROL
+#define DEFAULT_ACCESS_CONTROL TRUE
+#endif
+
+/* Default logging parameters. */
+#ifndef DEFAULT_LOG_VERBOSITY
+#define DEFAULT_LOG_VERBOSITY		0
+#endif
+#ifndef DEFAULT_LOG_FILE_VERBOSITY
+#define DEFAULT_LOG_FILE_VERBOSITY	3
+#endif
+
+#endif                          /* SITE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/site.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisb.h	(Revision 52145)
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 1997  Metro Link Incorporated
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ *
+ */
+
+#ifndef	_xisb_H_
+#define _xisb_H_
+
+#include <unistd.h>
+
+/******************************************************************************
+ *		Definitions
+ *									structs, typedefs, #defines, enums
+ *****************************************************************************/
+
+typedef struct _XISBuffer {
+    int fd;
+    int trace;
+    int block_duration;
+    ssize_t current;            /* bytes read */
+    ssize_t end;
+    ssize_t buffer_size;
+    unsigned char *buf;
+} XISBuffer;
+
+/******************************************************************************
+ *		Declarations
+ *								variables:	use xisb_LOC in front
+ *											of globals.
+ *											put locals in the .c file.
+ *****************************************************************************/
+extern _X_EXPORT XISBuffer *XisbNew(int fd, ssize_t size);
+extern _X_EXPORT void XisbFree(XISBuffer * b);
+extern _X_EXPORT int XisbRead(XISBuffer * b);
+extern _X_EXPORT ssize_t XisbWrite(XISBuffer * b, unsigned char *msg,
+                                   ssize_t len);
+extern _X_EXPORT void XisbTrace(XISBuffer * b, int trace);
+extern _X_EXPORT void XisbBlockDuration(XISBuffer * b, int block_duration);
+
+/*
+ *	DO NOT PUT ANYTHING AFTER THIS ENDIF
+ */
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BTPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BTPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BTPriv.h	(Revision 52145)
@@ -0,0 +1,20 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "BT.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86BTramdacInfo;
+
+extern xf86BTramdacInfo BTramdacDeviceInfo[];
+
+#ifdef INIT_BT_RAMDAC_INFO
+xf86BTramdacInfo BTramdacDeviceInfo[] = {
+    {"AT&T 20C504"},
+    {"AT&T 20C505"},
+    {"BT485/484"}
+};
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/BTPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xipassivegrab.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xipassivegrab.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xipassivegrab.h	(Revision 52145)
@@ -0,0 +1,40 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIPASSIVEGRAB_H
+#define XIPASSIVEGRAB_H 1
+
+int SProcXIPassiveUngrabDevice(ClientPtr client);
+int ProcXIPassiveUngrabDevice(ClientPtr client);
+void SRepXIPassiveGrabDevice(ClientPtr client, int size,
+                             xXIPassiveGrabDeviceReply * rep);
+int ProcXIPassiveGrabDevice(ClientPtr client);
+int SProcXIPassiveGrabDevice(ClientPtr client);
+
+#endif                          /* XIPASSIVEGRAB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xipassivegrab.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86int10.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86int10.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86int10.h	(Revision 52145)
@@ -0,0 +1,191 @@
+
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+
+#ifndef _XF86INT10_H
+#define _XF86INT10_H
+
+#include <X11/Xmd.h>
+#include <X11/Xdefs.h>
+#include "xf86Pci.h"
+
+#define SEG_ADDR(x) (((x) >> 4) & 0x00F000)
+#define SEG_OFF(x) ((x) & 0x0FFFF)
+
+#define SET_BIOS_SCRATCH     0x1
+#define RESTORE_BIOS_SCRATCH 0x2
+
+/* int10 info structure */
+typedef struct {
+    int entityIndex;
+    uint16_t BIOSseg;
+    uint16_t inb40time;
+    ScrnInfoPtr pScrn;
+    void *cpuRegs;
+    char *BIOSScratch;
+    int Flags;
+    void *private;
+    struct _int10Mem *mem;
+    int num;
+    int ax;
+    int bx;
+    int cx;
+    int dx;
+    int si;
+    int di;
+    int es;
+    int bp;
+    int flags;
+    int stackseg;
+    struct pci_device *dev;
+    struct pci_io_handle *io;
+} xf86Int10InfoRec, *xf86Int10InfoPtr;
+
+typedef struct _int10Mem {
+    uint8_t (*rb) (xf86Int10InfoPtr, int);
+    uint16_t (*rw) (xf86Int10InfoPtr, int);
+    uint32_t (*rl) (xf86Int10InfoPtr, int);
+    void (*wb) (xf86Int10InfoPtr, int, uint8_t);
+    void (*ww) (xf86Int10InfoPtr, int, uint16_t);
+    void (*wl) (xf86Int10InfoPtr, int, uint32_t);
+} int10MemRec, *int10MemPtr;
+
+typedef struct {
+    uint8_t save_msr;
+    uint8_t save_pos102;
+    uint8_t save_vse;
+    uint8_t save_46e8;
+} legacyVGARec, *legacyVGAPtr;
+
+/* OS dependent functions */
+extern _X_EXPORT xf86Int10InfoPtr xf86InitInt10(int entityIndex);
+extern _X_EXPORT xf86Int10InfoPtr xf86ExtendedInitInt10(int entityIndex,
+                                                        int Flags);
+extern _X_EXPORT void xf86FreeInt10(xf86Int10InfoPtr pInt);
+extern _X_EXPORT void *xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num,
+                                           int *off);
+extern _X_EXPORT void xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase,
+                                         int num);
+extern _X_EXPORT void *xf86int10Addr(xf86Int10InfoPtr pInt, uint32_t addr);
+
+/* x86 executor related functions */
+extern _X_EXPORT void xf86ExecX86int10(xf86Int10InfoPtr pInt);
+
+#ifdef _INT10_PRIVATE
+
+#define I_S_DEFAULT_INT_VECT 0xFF065
+#define SYS_SIZE 0x100000
+#define SYS_BIOS 0xF0000
+#if 1
+#define BIOS_SIZE 0x10000
+#else                           /* a bug in DGUX requires this - let's try it */
+#define BIOS_SIZE (0x10000 - 1)
+#endif
+#define LOW_PAGE_SIZE 0x600
+#define V_RAM 0xA0000
+#define VRAM_SIZE 0x20000
+#define V_BIOS_SIZE 0x10000
+#define V_BIOS 0xC0000
+#define BIOS_SCRATCH_OFF 0x449
+#define BIOS_SCRATCH_END 0x466
+#define BIOS_SCRATCH_LEN (BIOS_SCRATCH_END - BIOS_SCRATCH_OFF + 1)
+#define HIGH_MEM V_BIOS
+#define HIGH_MEM_SIZE (SYS_BIOS - HIGH_MEM)
+#define SEG_ADR(type, seg, reg)  type((seg << 4) + (X86_##reg))
+#define SEG_EADR(type, seg, reg) type((seg << 4) + (X86_E##reg))
+
+#define X86_TF_MASK		0x00000100
+#define X86_IF_MASK		0x00000200
+#define X86_IOPL_MASK		0x00003000
+#define X86_NT_MASK		0x00004000
+#define X86_VM_MASK		0x00020000
+#define X86_AC_MASK		0x00040000
+#define X86_VIF_MASK		0x00080000      /* virtual interrupt flag */
+#define X86_VIP_MASK		0x00100000      /* virtual interrupt pending */
+#define X86_ID_MASK		0x00200000
+
+#define MEM_RB(name, addr)      (*name->mem->rb)(name, addr)
+#define MEM_RW(name, addr)      (*name->mem->rw)(name, addr)
+#define MEM_RL(name, addr)      (*name->mem->rl)(name, addr)
+#define MEM_WB(name, addr, val) (*name->mem->wb)(name, addr, val)
+#define MEM_WW(name, addr, val) (*name->mem->ww)(name, addr, val)
+#define MEM_WL(name, addr, val) (*name->mem->wl)(name, addr, val)
+
+/* OS dependent functions */
+extern _X_EXPORT Bool MapCurrentInt10(xf86Int10InfoPtr pInt);
+
+/* x86 executor related functions */
+extern _X_EXPORT Bool xf86Int10ExecSetup(xf86Int10InfoPtr pInt);
+
+/* int.c */
+extern _X_EXPORT xf86Int10InfoPtr Int10Current;
+int int_handler(xf86Int10InfoPtr pInt);
+
+/* helper_exec.c */
+int setup_int(xf86Int10InfoPtr pInt);
+void finish_int(xf86Int10InfoPtr, int sig);
+uint32_t getIntVect(xf86Int10InfoPtr pInt, int num);
+void pushw(xf86Int10InfoPtr pInt, uint16_t val);
+int run_bios_int(int num, xf86Int10InfoPtr pInt);
+void dump_code(xf86Int10InfoPtr pInt);
+void dump_registers(xf86Int10InfoPtr pInt);
+void stack_trace(xf86Int10InfoPtr pInt);
+uint8_t bios_checksum(const uint8_t *start, int size);
+void LockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);
+void UnlockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);
+
+#if defined (_PC)
+extern _X_EXPORT void xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt,
+                                                   Bool save);
+#endif
+int port_rep_inb(xf86Int10InfoPtr pInt,
+                 uint16_t port, uint32_t base, int d_f, uint32_t count);
+int port_rep_inw(xf86Int10InfoPtr pInt,
+                 uint16_t port, uint32_t base, int d_f, uint32_t count);
+int port_rep_inl(xf86Int10InfoPtr pInt,
+                 uint16_t port, uint32_t base, int d_f, uint32_t count);
+int port_rep_outb(xf86Int10InfoPtr pInt,
+                  uint16_t port, uint32_t base, int d_f, uint32_t count);
+int port_rep_outw(xf86Int10InfoPtr pInt,
+                  uint16_t port, uint32_t base, int d_f, uint32_t count);
+int port_rep_outl(xf86Int10InfoPtr pInt,
+                  uint16_t port, uint32_t base, int d_f, uint32_t count);
+
+uint8_t x_inb(uint16_t port);
+uint16_t x_inw(uint16_t port);
+void x_outb(uint16_t port, uint8_t val);
+void x_outw(uint16_t port, uint16_t val);
+uint32_t x_inl(uint16_t port);
+void x_outl(uint16_t port, uint32_t val);
+
+uint8_t Mem_rb(uint32_t addr);
+uint16_t Mem_rw(uint32_t addr);
+uint32_t Mem_rl(uint32_t addr);
+void Mem_wb(uint32_t addr, uint8_t val);
+void Mem_ww(uint32_t addr, uint16_t val);
+void Mem_wl(uint32_t addr, uint32_t val);
+
+/* helper_mem.c */
+void setup_int_vect(xf86Int10InfoPtr pInt);
+int setup_system_bios(void *base_addr);
+void reset_int_vect(xf86Int10InfoPtr pInt);
+void set_return_trap(xf86Int10InfoPtr pInt);
+extern _X_EXPORT void *xf86HandleInt10Options(ScrnInfoPtr pScrn,
+                                              int entityIndex);
+Bool int10skip(const void *options);
+Bool int10_check_bios(int scrnIndex, int codeSeg,
+                      const unsigned char *vbiosMem);
+Bool initPrimary(const void *options);
+extern _X_EXPORT BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr
+                                                      pInt);
+extern _X_EXPORT Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt,
+                                              void *base);
+#ifdef DEBUG
+void dprint(unsigned long start, unsigned long size);
+#endif
+
+#endif                          /* _INT10_PRIVATE */
+#endif                          /* _XF86INT10_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86int10.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBMPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBMPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBMPriv.h	(Revision 52145)
@@ -0,0 +1,27 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "IBM.h"
+
+typedef struct {
+    const char *DeviceName;
+} xf86IBMramdacInfo;
+
+extern xf86IBMramdacInfo IBMramdacDeviceInfo[];
+
+#ifdef INIT_IBM_RAMDAC_INFO
+xf86IBMramdacInfo IBMramdacDeviceInfo[] = {
+    {"IBM 524"},
+    {"IBM 524A"},
+    {"IBM 525"},
+    {"IBM 526"},
+    {"IBM 526DB(DoubleBuffer)"},
+    {"IBM 528"},
+    {"IBM 528A"},
+    {"IBM 624"},
+    {"IBM 624DB(DoubleBuffer)"},
+    {"IBM 640"}
+};
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBMPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/scrnintstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/scrnintstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/scrnintstr.h	(Revision 52145)
@@ -0,0 +1,554 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SCREENINTSTRUCT_H
+#define SCREENINTSTRUCT_H
+
+#include "screenint.h"
+#include "regionstr.h"
+#include "colormap.h"
+#include "cursor.h"
+#include "validate.h"
+#include <X11/Xproto.h>
+#include "dix.h"
+#include "privates.h"
+
+typedef struct _PixmapFormat {
+    unsigned char depth;
+    unsigned char bitsPerPixel;
+    unsigned char scanlinePad;
+} PixmapFormatRec;
+
+typedef struct _Visual {
+    VisualID vid;
+    short class;
+    short bitsPerRGBValue;
+    short ColormapEntries;
+    short nplanes;              /* = log2 (ColormapEntries). This does not
+                                 * imply that the screen has this many planes.
+                                 * it may have more or fewer */
+    unsigned long redMask, greenMask, blueMask;
+    int offsetRed, offsetGreen, offsetBlue;
+} VisualRec;
+
+typedef struct _Depth {
+    unsigned char depth;
+    short numVids;
+    VisualID *vids;             /* block of visual ids for this depth */
+} DepthRec;
+
+typedef struct _ScreenSaverStuff {
+    WindowPtr pWindow;
+    XID wid;
+    char blanked;
+    Bool (*ExternalScreenSaver) (ScreenPtr /*pScreen */ ,
+                                 int /*xstate */ ,
+                                 Bool /*force */ );
+} ScreenSaverStuffRec;
+
+/*
+ *  There is a typedef for each screen function pointer so that code that
+ *  needs to declare a screen function pointer (e.g. in a screen private
+ *  or as a local variable) can easily do so and retain full type checking.
+ */
+
+typedef Bool (*CloseScreenProcPtr) (ScreenPtr /*pScreen */ );
+
+typedef void (*QueryBestSizeProcPtr) (int /*class */ ,
+                                      unsigned short * /*pwidth */ ,
+                                      unsigned short * /*pheight */ ,
+                                      ScreenPtr /*pScreen */ );
+
+typedef Bool (*SaveScreenProcPtr) (ScreenPtr /*pScreen */ ,
+                                   int /*on */ );
+
+typedef void (*GetImageProcPtr) (DrawablePtr /*pDrawable */ ,
+                                 int /*sx */ ,
+                                 int /*sy */ ,
+                                 int /*w */ ,
+                                 int /*h */ ,
+                                 unsigned int /*format */ ,
+                                 unsigned long /*planeMask */ ,
+                                 char * /*pdstLine */ );
+
+typedef void (*GetSpansProcPtr) (DrawablePtr /*pDrawable */ ,
+                                 int /*wMax */ ,
+                                 DDXPointPtr /*ppt */ ,
+                                 int * /*pwidth */ ,
+                                 int /*nspans */ ,
+                                 char * /*pdstStart */ );
+
+typedef void (*SourceValidateProcPtr) (DrawablePtr /*pDrawable */ ,
+                                       int /*x */ ,
+                                       int /*y */ ,
+                                       int /*width */ ,
+                                       int /*height */ ,
+                                       unsigned int /*subWindowMode */ );
+
+typedef Bool (*CreateWindowProcPtr) (WindowPtr /*pWindow */ );
+
+typedef Bool (*DestroyWindowProcPtr) (WindowPtr /*pWindow */ );
+
+typedef Bool (*PositionWindowProcPtr) (WindowPtr /*pWindow */ ,
+                                       int /*x */ ,
+                                       int /*y */ );
+
+typedef Bool (*ChangeWindowAttributesProcPtr) (WindowPtr /*pWindow */ ,
+                                               unsigned long /*mask */ );
+
+typedef Bool (*RealizeWindowProcPtr) (WindowPtr /*pWindow */ );
+
+typedef Bool (*UnrealizeWindowProcPtr) (WindowPtr /*pWindow */ );
+
+typedef void (*RestackWindowProcPtr) (WindowPtr /*pWindow */ ,
+                                      WindowPtr /*pOldNextSib */ );
+
+typedef int (*ValidateTreeProcPtr) (WindowPtr /*pParent */ ,
+                                    WindowPtr /*pChild */ ,
+                                    VTKind /*kind */ );
+
+typedef void (*PostValidateTreeProcPtr) (WindowPtr /*pParent */ ,
+                                         WindowPtr /*pChild */ ,
+                                         VTKind /*kind */ );
+
+typedef void (*WindowExposuresProcPtr) (WindowPtr /*pWindow */ ,
+                                        RegionPtr /*prgn */ ,
+                                        RegionPtr /*other_exposed */ );
+
+typedef void (*CopyWindowProcPtr) (WindowPtr /*pWindow */ ,
+                                   DDXPointRec /*ptOldOrg */ ,
+                                   RegionPtr /*prgnSrc */ );
+
+typedef void (*ClearToBackgroundProcPtr) (WindowPtr /*pWindow */ ,
+                                          int /*x */ ,
+                                          int /*y */ ,
+                                          int /*w */ ,
+                                          int /*h */ ,
+                                          Bool /*generateExposures */ );
+
+typedef void (*ClipNotifyProcPtr) (WindowPtr /*pWindow */ ,
+                                   int /*dx */ ,
+                                   int /*dy */ );
+
+/* pixmap will exist only for the duration of the current rendering operation */
+#define CREATE_PIXMAP_USAGE_SCRATCH                     1
+/* pixmap will be the backing pixmap for a redirected window */
+#define CREATE_PIXMAP_USAGE_BACKING_PIXMAP              2
+/* pixmap will contain a glyph */
+#define CREATE_PIXMAP_USAGE_GLYPH_PICTURE               3
+/* pixmap will be shared */
+#define CREATE_PIXMAP_USAGE_SHARED                      4
+
+typedef PixmapPtr (*CreatePixmapProcPtr) (ScreenPtr /*pScreen */ ,
+                                          int /*width */ ,
+                                          int /*height */ ,
+                                          int /*depth */ ,
+                                          unsigned /*usage_hint */ );
+
+typedef Bool (*DestroyPixmapProcPtr) (PixmapPtr /*pPixmap */ );
+
+typedef Bool (*RealizeFontProcPtr) (ScreenPtr /*pScreen */ ,
+                                    FontPtr /*pFont */ );
+
+typedef Bool (*UnrealizeFontProcPtr) (ScreenPtr /*pScreen */ ,
+                                      FontPtr /*pFont */ );
+
+typedef void (*ConstrainCursorProcPtr) (DeviceIntPtr /*pDev */ ,
+                                        ScreenPtr /*pScreen */ ,
+                                        BoxPtr /*pBox */ );
+
+typedef void (*CursorLimitsProcPtr) (DeviceIntPtr /* pDev */ ,
+                                     ScreenPtr /*pScreen */ ,
+                                     CursorPtr /*pCursor */ ,
+                                     BoxPtr /*pHotBox */ ,
+                                     BoxPtr /*pTopLeftBox */ );
+
+typedef Bool (*DisplayCursorProcPtr) (DeviceIntPtr /* pDev */ ,
+                                      ScreenPtr /*pScreen */ ,
+                                      CursorPtr /*pCursor */ );
+
+typedef Bool (*RealizeCursorProcPtr) (DeviceIntPtr /* pDev */ ,
+                                      ScreenPtr /*pScreen */ ,
+                                      CursorPtr /*pCursor */ );
+
+typedef Bool (*UnrealizeCursorProcPtr) (DeviceIntPtr /* pDev */ ,
+                                        ScreenPtr /*pScreen */ ,
+                                        CursorPtr /*pCursor */ );
+
+typedef void (*RecolorCursorProcPtr) (DeviceIntPtr /* pDev */ ,
+                                      ScreenPtr /*pScreen */ ,
+                                      CursorPtr /*pCursor */ ,
+                                      Bool /*displayed */ );
+
+typedef Bool (*SetCursorPositionProcPtr) (DeviceIntPtr /* pDev */ ,
+                                          ScreenPtr /*pScreen */ ,
+                                          int /*x */ ,
+                                          int /*y */ ,
+                                          Bool /*generateEvent */ );
+
+typedef Bool (*CreateGCProcPtr) (GCPtr /*pGC */ );
+
+typedef Bool (*CreateColormapProcPtr) (ColormapPtr /*pColormap */ );
+
+typedef void (*DestroyColormapProcPtr) (ColormapPtr /*pColormap */ );
+
+typedef void (*InstallColormapProcPtr) (ColormapPtr /*pColormap */ );
+
+typedef void (*UninstallColormapProcPtr) (ColormapPtr /*pColormap */ );
+
+typedef int (*ListInstalledColormapsProcPtr) (ScreenPtr /*pScreen */ ,
+                                              XID * /*pmaps */ );
+
+typedef void (*StoreColorsProcPtr) (ColormapPtr /*pColormap */ ,
+                                    int /*ndef */ ,
+                                    xColorItem * /*pdef */ );
+
+typedef void (*ResolveColorProcPtr) (unsigned short * /*pred */ ,
+                                     unsigned short * /*pgreen */ ,
+                                     unsigned short * /*pblue */ ,
+                                     VisualPtr /*pVisual */ );
+
+typedef RegionPtr (*BitmapToRegionProcPtr) (PixmapPtr /*pPix */ );
+
+typedef void (*SendGraphicsExposeProcPtr) (ClientPtr /*client */ ,
+                                           RegionPtr /*pRgn */ ,
+                                           XID /*drawable */ ,
+                                           int /*major */ ,
+                                           int /*minor */ );
+
+typedef void (*ScreenBlockHandlerProcPtr) (ScreenPtr /*pScreen*/ ,
+                                           void */*pTimeout */ ,
+                                           void */*pReadmask */ );
+
+typedef void (*ScreenWakeupHandlerProcPtr) (ScreenPtr /*pScreen*/ ,
+                                            unsigned long /*result */ ,
+                                            void */*pReadMask */ );
+
+typedef Bool (*CreateScreenResourcesProcPtr) (ScreenPtr /*pScreen */ );
+
+typedef Bool (*ModifyPixmapHeaderProcPtr) (PixmapPtr /*pPixmap */ ,
+                                           int /*width */ ,
+                                           int /*height */ ,
+                                           int /*depth */ ,
+                                           int /*bitsPerPixel */ ,
+                                           int /*devKind */ ,
+                                           void */*pPixData */ );
+
+typedef PixmapPtr (*GetWindowPixmapProcPtr) (WindowPtr /*pWin */ );
+
+typedef void (*SetWindowPixmapProcPtr) (WindowPtr /*pWin */ ,
+                                        PixmapPtr /*pPix */ );
+
+typedef PixmapPtr (*GetScreenPixmapProcPtr) (ScreenPtr /*pScreen */ );
+
+typedef void (*SetScreenPixmapProcPtr) (PixmapPtr /*pPix */ );
+
+typedef void (*MarkWindowProcPtr) (WindowPtr /*pWin */ );
+
+typedef Bool (*MarkOverlappedWindowsProcPtr) (WindowPtr /*parent */ ,
+                                              WindowPtr /*firstChild */ ,
+                                              WindowPtr * /*pLayerWin */ );
+
+typedef int (*ConfigNotifyProcPtr) (WindowPtr /*pWin */ ,
+                                    int /*x */ ,
+                                    int /*y */ ,
+                                    int /*w */ ,
+                                    int /*h */ ,
+                                    int /*bw */ ,
+                                    WindowPtr /*pSib */ );
+
+typedef void (*MoveWindowProcPtr) (WindowPtr /*pWin */ ,
+                                   int /*x */ ,
+                                   int /*y */ ,
+                                   WindowPtr /*pSib */ ,
+                                   VTKind /*kind */ );
+
+typedef void (*ResizeWindowProcPtr) (WindowPtr /*pWin */ ,
+                                     int /*x */ ,
+                                     int /*y */ ,
+                                     unsigned int /*w */ ,
+                                     unsigned int /*h */ ,
+                                     WindowPtr  /*pSib */
+    );
+
+typedef WindowPtr (*GetLayerWindowProcPtr) (WindowPtr   /*pWin */
+    );
+
+typedef void (*HandleExposuresProcPtr) (WindowPtr /*pWin */ );
+
+typedef void (*ReparentWindowProcPtr) (WindowPtr /*pWin */ ,
+                                       WindowPtr /*pPriorParent */ );
+
+typedef void (*SetShapeProcPtr) (WindowPtr /*pWin */ ,
+                                 int /* kind */ );
+
+typedef void (*ChangeBorderWidthProcPtr) (WindowPtr /*pWin */ ,
+                                          unsigned int /*width */ );
+
+typedef void (*MarkUnrealizedWindowProcPtr) (WindowPtr /*pChild */ ,
+                                             WindowPtr /*pWin */ ,
+                                             Bool /*fromConfigure */ );
+
+typedef Bool (*DeviceCursorInitializeProcPtr) (DeviceIntPtr /* pDev */ ,
+                                               ScreenPtr /* pScreen */ );
+
+typedef void (*DeviceCursorCleanupProcPtr) (DeviceIntPtr /* pDev */ ,
+                                            ScreenPtr /* pScreen */ );
+
+typedef void (*ConstrainCursorHarderProcPtr) (DeviceIntPtr, ScreenPtr, int,
+                                              int *, int *);
+
+
+typedef Bool (*SharePixmapBackingProcPtr)(PixmapPtr, ScreenPtr, void **);
+
+typedef Bool (*SetSharedPixmapBackingProcPtr)(PixmapPtr, void *);
+
+typedef Bool (*StartPixmapTrackingProcPtr)(PixmapPtr, PixmapPtr,
+                                           int x, int y);
+
+typedef Bool (*StopPixmapTrackingProcPtr)(PixmapPtr, PixmapPtr);
+
+typedef Bool (*ReplaceScanoutPixmapProcPtr)(DrawablePtr, PixmapPtr, Bool);
+
+typedef WindowPtr (*XYToWindowProcPtr)(ScreenPtr pScreen,
+                                       SpritePtr pSprite, int x, int y);
+
+typedef int (*NameWindowPixmapProcPtr)(WindowPtr, PixmapPtr, CARD32);
+
+typedef struct _Screen {
+    int myNum;                  /* index of this instance in Screens[] */
+    ATOM id;
+    short x, y, width, height;
+    short mmWidth, mmHeight;
+    short numDepths;
+    unsigned char rootDepth;
+    DepthPtr allowedDepths;
+    unsigned long rootVisual;
+    unsigned long defColormap;
+    short minInstalledCmaps, maxInstalledCmaps;
+    char backingStoreSupport, saveUnderSupport;
+    unsigned long whitePixel, blackPixel;
+    GCPtr GCperDepth[MAXFORMATS + 1];
+    /* next field is a stipple to use as default in
+       a GC.  we don't build default tiles of all depths
+       because they are likely to be of a color
+       different from the default fg pixel, so
+       we don't win anything by building
+       a standard one.
+     */
+    PixmapPtr PixmapPerDepth[1];
+    void *devPrivate;
+    short numVisuals;
+    VisualPtr visuals;
+    WindowPtr root;
+    ScreenSaverStuffRec screensaver;
+
+    DevPrivateSetRec    screenSpecificPrivates[PRIVATE_LAST];
+
+    /* Random screen procedures */
+
+    CloseScreenProcPtr CloseScreen;
+    QueryBestSizeProcPtr QueryBestSize;
+    SaveScreenProcPtr SaveScreen;
+    GetImageProcPtr GetImage;
+    GetSpansProcPtr GetSpans;
+    SourceValidateProcPtr SourceValidate;
+
+    /* Window Procedures */
+
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    PositionWindowProcPtr PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    ValidateTreeProcPtr ValidateTree;
+    PostValidateTreeProcPtr PostValidateTree;
+    WindowExposuresProcPtr WindowExposures;
+    CopyWindowProcPtr CopyWindow;
+    ClearToBackgroundProcPtr ClearToBackground;
+    ClipNotifyProcPtr ClipNotify;
+    RestackWindowProcPtr RestackWindow;
+
+    /* Pixmap procedures */
+
+    CreatePixmapProcPtr CreatePixmap;
+    DestroyPixmapProcPtr DestroyPixmap;
+
+    /* Font procedures */
+
+    RealizeFontProcPtr RealizeFont;
+    UnrealizeFontProcPtr UnrealizeFont;
+
+    /* Cursor Procedures */
+
+    ConstrainCursorProcPtr ConstrainCursor;
+    ConstrainCursorHarderProcPtr ConstrainCursorHarder;
+    CursorLimitsProcPtr CursorLimits;
+    DisplayCursorProcPtr DisplayCursor;
+    RealizeCursorProcPtr RealizeCursor;
+    UnrealizeCursorProcPtr UnrealizeCursor;
+    RecolorCursorProcPtr RecolorCursor;
+    SetCursorPositionProcPtr SetCursorPosition;
+
+    /* GC procedures */
+
+    CreateGCProcPtr CreateGC;
+
+    /* Colormap procedures */
+
+    CreateColormapProcPtr CreateColormap;
+    DestroyColormapProcPtr DestroyColormap;
+    InstallColormapProcPtr InstallColormap;
+    UninstallColormapProcPtr UninstallColormap;
+    ListInstalledColormapsProcPtr ListInstalledColormaps;
+    StoreColorsProcPtr StoreColors;
+    ResolveColorProcPtr ResolveColor;
+
+    /* Region procedures */
+
+    BitmapToRegionProcPtr BitmapToRegion;
+    SendGraphicsExposeProcPtr SendGraphicsExpose;
+
+    /* os layer procedures */
+
+    ScreenBlockHandlerProcPtr BlockHandler;
+    ScreenWakeupHandlerProcPtr WakeupHandler;
+
+    /* anybody can get a piece of this array */
+    PrivateRec *devPrivates;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    ModifyPixmapHeaderProcPtr ModifyPixmapHeader;
+
+    GetWindowPixmapProcPtr GetWindowPixmap;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+    GetScreenPixmapProcPtr GetScreenPixmap;
+    SetScreenPixmapProcPtr SetScreenPixmap;
+    NameWindowPixmapProcPtr NameWindowPixmap;
+
+    PixmapPtr pScratchPixmap;   /* scratch pixmap "pool" */
+
+    unsigned int totalPixmapSize;
+
+    MarkWindowProcPtr MarkWindow;
+    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
+    ConfigNotifyProcPtr ConfigNotify;
+    MoveWindowProcPtr MoveWindow;
+    ResizeWindowProcPtr ResizeWindow;
+    GetLayerWindowProcPtr GetLayerWindow;
+    HandleExposuresProcPtr HandleExposures;
+    ReparentWindowProcPtr ReparentWindow;
+
+    SetShapeProcPtr SetShape;
+
+    ChangeBorderWidthProcPtr ChangeBorderWidth;
+    MarkUnrealizedWindowProcPtr MarkUnrealizedWindow;
+
+    /* Device cursor procedures */
+    DeviceCursorInitializeProcPtr DeviceCursorInitialize;
+    DeviceCursorCleanupProcPtr DeviceCursorCleanup;
+
+    /* set it in driver side if X server can copy the framebuffer content.
+     * Meant to be used together with '-background none' option, avoiding
+     * malicious users to steal framebuffer's content if that would be the
+     * default */
+    Bool canDoBGNoneRoot;
+
+    Bool isGPU;
+
+    struct xorg_list unattached_list;
+    struct xorg_list unattached_head;
+
+    ScreenPtr current_master;
+
+    struct xorg_list output_slave_list;
+    struct xorg_list output_head;
+
+    SharePixmapBackingProcPtr SharePixmapBacking;
+    SetSharedPixmapBackingProcPtr SetSharedPixmapBacking;
+
+    StartPixmapTrackingProcPtr StartPixmapTracking;
+    StopPixmapTrackingProcPtr StopPixmapTracking;
+
+    struct xorg_list pixmap_dirty_list;
+    struct xorg_list offload_slave_list;
+    struct xorg_list offload_head;
+
+    ReplaceScanoutPixmapProcPtr ReplaceScanoutPixmap;
+    XYToWindowProcPtr XYToWindow;
+} ScreenRec;
+
+static inline RegionPtr
+BitmapToRegion(ScreenPtr _pScreen, PixmapPtr pPix)
+{
+    return (*(_pScreen)->BitmapToRegion) (pPix);        /* no mi version?! */
+}
+
+typedef struct _ScreenInfo {
+    int imageByteOrder;
+    int bitmapScanlineUnit;
+    int bitmapScanlinePad;
+    int bitmapBitOrder;
+    int numPixmapFormats;
+     PixmapFormatRec formats[MAXFORMATS];
+    int numScreens;
+    ScreenPtr screens[MAXSCREENS];
+    int numGPUScreens;
+    ScreenPtr gpuscreens[MAXGPUSCREENS];
+    int x;                      /* origin */
+    int y;                      /* origin */
+    int width;                  /* total width of all screens together */
+    int height;                 /* total height of all screens together */
+} ScreenInfo;
+
+extern _X_EXPORT ScreenInfo screenInfo;
+
+extern _X_EXPORT void InitOutput(ScreenInfo * /*pScreenInfo */ ,
+                                 int /*argc */ ,
+                                 char ** /*argv */ );
+
+#endif                          /* SCREENINTSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/scrnintstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvpriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvpriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvpriv.h	(Revision 52145)
@@ -0,0 +1,88 @@
+
+/*
+ * Copyright (c) 2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XVPRIV_H_
+#define _XF86XVPRIV_H_
+
+#include "xf86xv.h"
+#include "privates.h"
+
+/*** These are DDX layer privates ***/
+
+extern _X_EXPORT DevPrivateKey XF86XvScreenKey;
+
+typedef struct {
+    DestroyWindowProcPtr DestroyWindow;
+    ClipNotifyProcPtr ClipNotify;
+    WindowExposuresProcPtr WindowExposures;
+    PostValidateTreeProcPtr PostValidateTree;
+    void (*AdjustFrame) (ScrnInfoPtr, int, int);
+    Bool (*EnterVT) (ScrnInfoPtr);
+    void (*LeaveVT) (ScrnInfoPtr);
+    xf86ModeSetProc *ModeSet;
+} XF86XVScreenRec, *XF86XVScreenPtr;
+
+typedef struct {
+    int flags;
+    PutVideoFuncPtr PutVideo;
+    PutStillFuncPtr PutStill;
+    GetVideoFuncPtr GetVideo;
+    GetStillFuncPtr GetStill;
+    StopVideoFuncPtr StopVideo;
+    SetPortAttributeFuncPtr SetPortAttribute;
+    GetPortAttributeFuncPtr GetPortAttribute;
+    QueryBestSizeFuncPtr QueryBestSize;
+    PutImageFuncPtr PutImage;
+    ReputImageFuncPtr ReputImage;
+    QueryImageAttributesFuncPtr QueryImageAttributes;
+    ClipNotifyFuncPtr ClipNotify;
+} XvAdaptorRecPrivate, *XvAdaptorRecPrivatePtr;
+
+typedef struct {
+    ScrnInfoPtr pScrn;
+    DrawablePtr pDraw;
+    unsigned char type;
+    unsigned int subWindowMode;
+    RegionPtr clientClip;
+    RegionPtr ckeyFilled;
+    RegionPtr pCompositeClip;
+    Bool FreeCompositeClip;
+    XvAdaptorRecPrivatePtr AdaptorRec;
+    XvStatus isOn;
+    Bool clipChanged;
+    int vid_x, vid_y, vid_w, vid_h;
+    int drw_x, drw_y, drw_w, drw_h;
+    DevUnion DevPriv;
+} XvPortRecPrivate, *XvPortRecPrivatePtr;
+
+typedef struct _XF86XVWindowRec {
+    XvPortRecPrivatePtr PortRec;
+    struct _XF86XVWindowRec *next;
+} XF86XVWindowRec, *XF86XVWindowPtr;
+
+#endif                          /* _XF86XVPRIV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvpriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu_regs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu_regs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu_regs.h	(Revision 52145)
@@ -0,0 +1,119 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for FPU register definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_FPU_REGS_H
+#define __X86EMU_FPU_REGS_H
+
+#ifdef X86_FPU_SUPPORT
+
+#ifdef PACK
+#pragma PACK
+#endif
+
+/* Basic 8087 register can hold any of the following values: */
+
+union x86_fpu_reg_u {
+    s8 tenbytes[10];
+    double dval;
+    float fval;
+    s16 sval;
+    s32 lval;
+};
+
+struct x86_fpu_reg {
+    union x86_fpu_reg_u reg;
+    char tag;
+};
+
+/*
+ * Since we are not going to worry about the problems of aliasing
+ * registers, every time a register is modified, its result type is
+ * set in the tag fields for that register.  If some operation
+ * attempts to access the type in a way inconsistent with its current
+ * storage format, then we flag the operation.  If common, we'll
+ * attempt the conversion.
+ */
+
+#define  X86_FPU_VALID          0x80
+#define  X86_FPU_REGTYP(r)      ((r) & 0x7F)
+
+#define  X86_FPU_WORD           0x0
+#define  X86_FPU_SHORT          0x1
+#define  X86_FPU_LONG           0x2
+#define  X86_FPU_FLOAT          0x3
+#define  X86_FPU_DOUBLE         0x4
+#define  X86_FPU_LDBL           0x5
+#define  X86_FPU_BSD            0x6
+
+#define  X86_FPU_STKTOP  0
+
+struct x86_fpu_registers {
+    struct x86_fpu_reg x86_fpu_stack[8];
+    int x86_fpu_flags;
+    int x86_fpu_config;         /* rounding modes, etc. */
+    short x86_fpu_tos, x86_fpu_bos;
+};
+
+#ifdef END_PACK
+#pragma END_PACK
+#endif
+
+/*
+ * There are two versions of the following macro.
+ *
+ * One version is for opcode D9, for which there are more than 32
+ * instructions encoded in the second byte of the opcode.
+ *
+ * The other version, deals with all the other 7 i87 opcodes, for
+ * which there are only 32 strings needed to describe the
+ * instructions.
+ */
+
+#endif                          /* X86_FPU_SUPPORT */
+
+#ifdef DEBUG
+#define DECODE_PRINTINSTR32(t,mod,rh,rl)     	\
+	DECODE_PRINTF(t[(mod<<3)+(rh)]);
+#define DECODE_PRINTINSTR256(t,mod,rh,rl)    	\
+	DECODE_PRINTF(t[(mod<<6)+(rh<<3)+(rl)]);
+#else
+#define DECODE_PRINTINSTR32(t,mod,rh,rl)
+#define DECODE_PRINTINSTR256(t,mod,rh,rl)
+#endif
+
+#endif                          /* __X86EMU_FPU_REGS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu_regs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiqueryversion.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiqueryversion.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiqueryversion.h	(Revision 52145)
@@ -0,0 +1,40 @@
+/*
+ * Copyright ¬© 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <X11/extensions/XI2proto.h>
+
+#ifndef QUERYVERSION_H
+#define QUERYVERSION_H 1
+
+int SProcXIQueryVersion(ClientPtr client);
+int ProcXIQueryVersion(ClientPtr client);
+void SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply * rep);
+
+#endif                          /* QUERYVERSION_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiqueryversion.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbsrv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbsrv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbsrv.h	(Revision 52145)
@@ -0,0 +1,886 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBSRV_H_
+#define	_XKBSRV_H_
+
+#define XkbAllocClientMap		SrvXkbAllocClientMap
+#define XkbAllocServerMap		SrvXkbAllocServerMap
+#define XkbChangeTypesOfKey		SrvXkbChangeTypesOfKey
+#define XkbCopyKeyTypes			SrvXkbCopyKeyTypes
+#define XkbFreeClientMap		SrvXkbFreeClientMap
+#define XkbFreeServerMap		SrvXkbFreeServerMap
+#define	XkbKeyTypesForCoreSymbols	SrvXkbKeyTypesForCoreSymbols
+#define	XkbApplyCompatMapToKey		SrvXkbApplyCompatMapToKey
+#define XkbResizeKeyActions		SrvXkbResizeKeyActions
+#define XkbResizeKeySyms		SrvXkbResizeKeySyms
+#define XkbResizeKeyType		SrvXkbResizeKeyType
+#define XkbAllocCompatMap		SrvXkbAllocCompatMap
+#define XkbAllocControls		SrvXkbAllocControls
+#define XkbAllocIndicatorMaps		SrvXkbAllocIndicatorMaps
+#define XkbAllocKeyboard		SrvXkbAllocKeyboard
+#define XkbAllocNames			SrvXkbAllocNames
+#define XkbFreeCompatMap		SrvXkbFreeCompatMap
+#define XkbFreeKeyboard			SrvXkbFreeKeyboard
+#define XkbFreeNames			SrvXkbFreeNames
+#define XkbLatchModifiers		SrvXkbLatchModifiers
+#define XkbLatchGroup			SrvXkbLatchGroup
+#define XkbVirtualModsToReal		SrvXkbVirtualModsToReal
+#define	XkbChangeKeycodeRange		SrvXkbChangeKeycodeRange
+#define	XkbApplyVirtualModChanges	SrvXkbApplyVirtualModChanges
+
+#include <X11/extensions/XKBproto.h>
+#include "xkbstr.h"
+#include "xkbrules.h"
+#include "inputstr.h"
+#include "events.h"
+
+typedef struct _XkbInterest {
+    DeviceIntPtr dev;
+    ClientPtr client;
+    XID resource;
+    struct _XkbInterest *next;
+    CARD16 extDevNotifyMask;
+    CARD16 stateNotifyMask;
+    CARD16 namesNotifyMask;
+    CARD32 ctrlsNotifyMask;
+    CARD8 compatNotifyMask;
+    BOOL bellNotifyMask;
+    BOOL actionMessageMask;
+    CARD16 accessXNotifyMask;
+    CARD32 iStateNotifyMask;
+    CARD32 iMapNotifyMask;
+    CARD16 altSymsNotifyMask;
+    CARD32 autoCtrls;
+    CARD32 autoCtrlValues;
+} XkbInterestRec, *XkbInterestPtr;
+
+typedef struct _XkbRadioGroup {
+    CARD8 flags;
+    CARD8 nMembers;
+    CARD8 dfltDown;
+    CARD8 currentDown;
+    CARD8 members[XkbRGMaxMembers];
+} XkbRadioGroupRec, *XkbRadioGroupPtr;
+
+typedef struct _XkbEventCause {
+    CARD8 kc;
+    CARD8 event;
+    CARD8 mjr;
+    CARD8 mnr;
+    ClientPtr client;
+} XkbEventCauseRec, *XkbEventCausePtr;
+
+#define	XkbSetCauseKey(c,k,e)	{ (c)->kc= (k),(c)->event= (e),\
+				  (c)->mjr= (c)->mnr= 0; \
+				  (c)->client= NULL; }
+#define	XkbSetCauseReq(c,j,n,cl) { (c)->kc= (c)->event= 0,\
+				  (c)->mjr= (j),(c)->mnr= (n);\
+				  (c)->client= (cl); }
+#define	XkbSetCauseCoreReq(c,e,cl) XkbSetCauseReq(c,e,0,cl)
+#define	XkbSetCauseXkbReq(c,e,cl)  XkbSetCauseReq(c,XkbReqCode,e,cl)
+#define	XkbSetCauseUnknown(c)	   XkbSetCauseKey(c,0,0)
+
+#define	_OFF_TIMER		0
+#define	_KRG_WARN_TIMER		1
+#define	_KRG_TIMER		2
+#define	_SK_TIMEOUT_TIMER	3
+#define	_ALL_TIMEOUT_TIMER	4
+
+#define	_BEEP_NONE		0
+#define	_BEEP_FEATURE_ON	1
+#define	_BEEP_FEATURE_OFF	2
+#define	_BEEP_FEATURE_CHANGE	3
+#define	_BEEP_SLOW_WARN		4
+#define	_BEEP_SLOW_PRESS	5
+#define	_BEEP_SLOW_ACCEPT	6
+#define	_BEEP_SLOW_REJECT	7
+#define	_BEEP_SLOW_RELEASE	8
+#define	_BEEP_STICKY_LATCH	9
+#define	_BEEP_STICKY_LOCK	10
+#define	_BEEP_STICKY_UNLOCK	11
+#define	_BEEP_LED_ON		12
+#define	_BEEP_LED_OFF		13
+#define	_BEEP_LED_CHANGE	14
+#define	_BEEP_BOUNCE_REJECT	15
+
+typedef struct _XkbFilter {
+    CARD16 keycode;
+    CARD8 what;
+    CARD8 active;
+    CARD8 filterOthers;
+    CARD32 priv;
+    XkbAction upAction;
+    int (*filter) (struct _XkbSrvInfo * /* xkbi */ ,
+                   struct _XkbFilter * /* filter */ ,
+                   unsigned /* keycode */ ,
+                   XkbAction *  /* action */
+        );
+    struct _XkbFilter *next;
+} XkbFilterRec, *XkbFilterPtr;
+
+typedef struct _XkbSrvInfo {
+    XkbStateRec prev_state;
+    XkbStateRec state;
+    XkbDescPtr desc;
+
+    DeviceIntPtr device;
+    KbdCtrlProcPtr kbdProc;
+
+    XkbRadioGroupPtr radioGroups;
+    CARD8 nRadioGroups;
+    CARD8 clearMods;
+    CARD8 setMods;
+    INT16 groupChange;
+
+    CARD16 dfltPtrDelta;
+
+    double mouseKeysCurve;
+    double mouseKeysCurveFactor;
+    INT16 mouseKeysDX;
+    INT16 mouseKeysDY;
+    CARD8 mouseKeysFlags;
+    Bool mouseKeysAccel;
+    CARD8 mouseKeysCounter;
+
+    CARD8 lockedPtrButtons;
+    CARD8 shiftKeyCount;
+    KeyCode mouseKey;
+    KeyCode inactiveKey;
+    KeyCode slowKey;
+    KeyCode slowKeyEnableKey;
+    KeyCode repeatKey;
+    CARD8 krgTimerActive;
+    CARD8 beepType;
+    CARD8 beepCount;
+
+    CARD32 flags;
+    CARD32 lastPtrEventTime;
+    CARD32 lastShiftEventTime;
+    OsTimerPtr beepTimer;
+    OsTimerPtr mouseKeyTimer;
+    OsTimerPtr slowKeysTimer;
+    OsTimerPtr bounceKeysTimer;
+    OsTimerPtr repeatKeyTimer;
+    OsTimerPtr krgTimer;
+
+    int szFilters;
+    XkbFilterPtr filters;
+} XkbSrvInfoRec, *XkbSrvInfoPtr;
+
+#define	XkbSLI_IsDefault	(1L<<0)
+#define	XkbSLI_HasOwnState	(1L<<1)
+
+typedef struct _XkbSrvLedInfo {
+    CARD16 flags;
+    CARD16 class;
+    CARD16 id;
+    union {
+        KbdFeedbackPtr kf;
+        LedFeedbackPtr lf;
+    } fb;
+
+    CARD32 physIndicators;
+    CARD32 autoState;
+    CARD32 explicitState;
+    CARD32 effectiveState;
+
+    CARD32 mapsPresent;
+    CARD32 namesPresent;
+    XkbIndicatorMapPtr maps;
+    Atom *names;
+
+    CARD32 usesBase;
+    CARD32 usesLatched;
+    CARD32 usesLocked;
+    CARD32 usesEffective;
+    CARD32 usesCompat;
+    CARD32 usesControls;
+
+    CARD32 usedComponents;
+} XkbSrvLedInfoRec, *XkbSrvLedInfoPtr;
+
+/*
+ * Settings for xkbClientFlags field (used by DIX)
+ * These flags _must_ not overlap with XkbPCF_*
+ */
+#define	_XkbClientInitialized		(1<<15)
+
+#define	_XkbWantsDetectableAutoRepeat(c)\
+	((c)->xkbClientFlags&XkbPCF_DetectableAutoRepeatMask)
+
+/*
+ * Settings for flags field
+ */
+#define	_XkbStateNotifyInProgress	(1<<0)
+
+typedef struct {
+    ProcessInputProc processInputProc;
+    /* If processInputProc is set to something different than realInputProc,
+     * UNWRAP and COND_WRAP will not touch processInputProc and update only
+     * realInputProc.  This ensures that
+     *   processInputProc == (frozen ? EnqueueEvent : realInputProc)
+     *
+     * WRAP_PROCESS_INPUT_PROC should only be called during initialization,
+     * since it may destroy this invariant.
+     */
+    ProcessInputProc realInputProc;
+    DeviceUnwrapProc unwrapProc;
+} xkbDeviceInfoRec, *xkbDeviceInfoPtr;
+
+#define WRAP_PROCESS_INPUT_PROC(device, oldprocs, proc, unwrapproc) \
+	device->public.processInputProc = proc; \
+	oldprocs->processInputProc = \
+	oldprocs->realInputProc = device->public.realInputProc; \
+	device->public.realInputProc = proc; \
+	oldprocs->unwrapProc = device->unwrapProc; \
+	device->unwrapProc = unwrapproc;
+
+#define COND_WRAP_PROCESS_INPUT_PROC(device, oldprocs, proc, unwrapproc) \
+	if (device->public.processInputProc == device->public.realInputProc)\
+	    device->public.processInputProc = proc; \
+	oldprocs->processInputProc = \
+	oldprocs->realInputProc = device->public.realInputProc; \
+	device->public.realInputProc = proc; \
+	oldprocs->unwrapProc = device->unwrapProc; \
+	device->unwrapProc = unwrapproc;
+
+#define UNWRAP_PROCESS_INPUT_PROC(device, oldprocs, backupproc) \
+        backupproc = device->public.realInputProc; \
+	if (device->public.processInputProc == device->public.realInputProc)\
+	    device->public.processInputProc = oldprocs->realInputProc; \
+	device->public.realInputProc = oldprocs->realInputProc; \
+	device->unwrapProc = oldprocs->unwrapProc;
+
+extern _X_EXPORT DevPrivateKeyRec xkbDevicePrivateKeyRec;
+
+#define xkbDevicePrivateKey (&xkbDevicePrivateKeyRec)
+
+#define XKBDEVICEINFO(dev) ((xkbDeviceInfoPtr)dixLookupPrivate(&(dev)->devPrivates, xkbDevicePrivateKey))
+
+extern void xkbUnwrapProc(DeviceIntPtr, DeviceHandleProc, void *);
+
+/***====================================================================***/
+
+/***====================================================================***/
+
+#define XkbAX_KRGMask	 (XkbSlowKeysMask|XkbBounceKeysMask)
+#define	XkbAllFilteredEventsMask \
+	(XkbAccessXKeysMask|XkbRepeatKeysMask|XkbMouseKeysAccelMask|XkbAX_KRGMask)
+
+/***====================================================================***/
+
+extern _X_EXPORT int XkbReqCode;
+extern _X_EXPORT int XkbEventBase;
+extern _X_EXPORT int XkbKeyboardErrorCode;
+extern _X_EXPORT const char *XkbBaseDirectory;
+extern _X_EXPORT const char *XkbBinDirectory;
+
+extern _X_EXPORT CARD32 xkbDebugFlags;
+
+#define	_XkbLibError(c,l,d)     /* Epoch fail */
+
+/* "a" is a "unique" numeric identifier that just defines which error
+ * code statement it is. _XkbErrCode2(4, foo) means "this is the 4th error
+ * statement in this function". lovely.
+ */
+#define	_XkbErrCode2(a,b) ((XID)((((unsigned int)(a))<<24)|((b)&0xffffff)))
+#define	_XkbErrCode3(a,b,c)	_XkbErrCode2(a,(((unsigned int)(b))<<16)|(c))
+#define	_XkbErrCode4(a,b,c,d) _XkbErrCode3(a,b,((((unsigned int)(c))<<8)|(d)))
+
+#define	Status		int
+
+extern _X_EXPORT void XkbUseMsg(void
+    );
+
+extern _X_EXPORT int XkbProcessArguments(int /* argc */ ,
+                                         char ** /* argv */ ,
+                                         int    /* i */
+    );
+
+extern _X_EXPORT Bool XkbInitPrivates(void);
+
+extern _X_EXPORT void XkbSetExtension(DeviceIntPtr device,
+                                      ProcessInputProc proc);
+
+extern _X_EXPORT void XkbFreeCompatMap(XkbDescPtr /* xkb */ ,
+                                       unsigned int /* which */ ,
+                                       Bool     /* freeMap */
+    );
+
+extern _X_EXPORT void XkbFreeNames(XkbDescPtr /* xkb */ ,
+                                   unsigned int /* which */ ,
+                                   Bool /* freeMap */
+    );
+
+extern _X_EXPORT int _XkbLookupAnyDevice(DeviceIntPtr *pDev,
+                                         int id,
+                                         ClientPtr client,
+                                         Mask access_mode, int *xkb_err);
+
+extern _X_EXPORT int _XkbLookupKeyboard(DeviceIntPtr *pDev,
+                                        int id,
+                                        ClientPtr client,
+                                        Mask access_mode, int *xkb_err);
+
+extern _X_EXPORT int _XkbLookupBellDevice(DeviceIntPtr *pDev,
+                                          int id,
+                                          ClientPtr client,
+                                          Mask access_mode, int *xkb_err);
+
+extern _X_EXPORT int _XkbLookupLedDevice(DeviceIntPtr *pDev,
+                                         int id,
+                                         ClientPtr client,
+                                         Mask access_mode, int *xkb_err);
+
+extern _X_EXPORT int _XkbLookupButtonDevice(DeviceIntPtr *pDev,
+                                            int id,
+                                            ClientPtr client,
+                                            Mask access_mode, int *xkb_err);
+
+extern _X_EXPORT XkbDescPtr XkbAllocKeyboard(void
+    );
+
+extern _X_EXPORT Status XkbAllocClientMap(XkbDescPtr /* xkb */ ,
+                                          unsigned int /* which */ ,
+                                          unsigned int  /* nTypes */
+    );
+
+extern _X_EXPORT Status XkbAllocServerMap(XkbDescPtr /* xkb */ ,
+                                          unsigned int /* which */ ,
+                                          unsigned int  /* nNewActions */
+    );
+
+extern _X_EXPORT void XkbFreeClientMap(XkbDescPtr /* xkb */ ,
+                                       unsigned int /* what */ ,
+                                       Bool     /* freeMap */
+    );
+
+extern _X_EXPORT void XkbFreeServerMap(XkbDescPtr /* xkb */ ,
+                                       unsigned int /* what */ ,
+                                       Bool     /* freeMap */
+    );
+
+extern _X_EXPORT Status XkbAllocIndicatorMaps(XkbDescPtr        /* xkb */
+    );
+
+extern _X_EXPORT Status XkbAllocCompatMap(XkbDescPtr /* xkb */ ,
+                                          unsigned int /* which */ ,
+                                          unsigned int  /* nInterpret */
+    );
+
+extern _X_EXPORT Status XkbAllocNames(XkbDescPtr /* xkb */ ,
+                                      unsigned int /* which */ ,
+                                      int /* nTotalRG */ ,
+                                      int       /* nTotalAliases */
+    );
+
+extern _X_EXPORT Status XkbAllocControls(XkbDescPtr /* xkb */ ,
+                                         unsigned int   /* which */
+    );
+
+extern _X_EXPORT Status XkbCopyKeyTypes(XkbKeyTypePtr /* from */ ,
+                                        XkbKeyTypePtr /* into */ ,
+                                        int     /* num_types */
+    );
+
+extern _X_EXPORT Status XkbResizeKeyType(XkbDescPtr /* xkb */ ,
+                                         int /* type_ndx */ ,
+                                         int /* map_count */ ,
+                                         Bool /* want_preserve */ ,
+                                         int    /* new_num_lvls */
+    );
+
+extern _X_EXPORT void XkbFreeKeyboard(XkbDescPtr /* xkb */ ,
+                                      unsigned int /* which */ ,
+                                      Bool      /* freeDesc */
+    );
+
+extern _X_EXPORT void XkbFreeComponentNames(XkbComponentNamesPtr /* names */ ,
+                                            Bool        /* freeNames */
+    );
+
+extern _X_EXPORT void XkbSetActionKeyMods(XkbDescPtr /* xkb */ ,
+                                          XkbAction * /* act */ ,
+                                          unsigned int  /* mods */
+    );
+
+extern _X_EXPORT unsigned int XkbMaskForVMask(XkbDescPtr /* xkb */ ,
+                                              unsigned int      /* vmask */
+    );
+
+extern _X_EXPORT Bool XkbVirtualModsToReal(XkbDescPtr /* xkb */ ,
+                                           unsigned int /* virtua_mask */ ,
+                                           unsigned int *       /* mask_rtrn */
+    );
+
+extern _X_EXPORT unsigned int XkbAdjustGroup(int /* group */ ,
+                                             XkbControlsPtr     /* ctrls */
+    );
+
+extern _X_EXPORT KeySym *XkbResizeKeySyms(XkbDescPtr /* xkb */ ,
+                                          int /* key */ ,
+                                          int   /* needed */
+    );
+
+extern _X_EXPORT XkbAction *XkbResizeKeyActions(XkbDescPtr /* xkb */ ,
+                                                int /* key */ ,
+                                                int     /* needed */
+    );
+
+extern _X_EXPORT void XkbUpdateKeyTypesFromCore(DeviceIntPtr /* pXDev */ ,
+                                                KeySymsPtr /* syms */ ,
+                                                KeyCode /* first */ ,
+                                                CARD8 /* num */ ,
+                                                XkbChangesPtr   /* pChanges */
+    );
+
+extern _X_EXPORT void XkbUpdateDescActions(XkbDescPtr /* xkb */ ,
+                                           KeyCode /* first */ ,
+                                           CARD8 /* num */ ,
+                                           XkbChangesPtr        /* changes */
+    );
+
+extern _X_EXPORT void XkbUpdateActions(DeviceIntPtr /* pXDev */ ,
+                                       KeyCode /* first */ ,
+                                       CARD8 /* num */ ,
+                                       XkbChangesPtr /* pChanges */ ,
+                                       unsigned int * /* needChecksRtrn */ ,
+                                       XkbEventCausePtr /* cause */
+    );
+
+extern _X_EXPORT KeySymsPtr XkbGetCoreMap(DeviceIntPtr  /* keybd */
+    );
+
+extern _X_EXPORT void XkbApplyMappingChange(DeviceIntPtr /* pXDev */ ,
+                                            KeySymsPtr /* map */ ,
+                                            KeyCode /* firstKey */ ,
+                                            CARD8 /* num */ ,
+                                            CARD8 * /* modmap */ ,
+                                            ClientPtr   /* client */
+    );
+
+extern _X_EXPORT void XkbSetIndicators(DeviceIntPtr /* pXDev */ ,
+                                       CARD32 /* affect */ ,
+                                       CARD32 /* values */ ,
+                                       XkbEventCausePtr /* cause */
+    );
+
+extern _X_EXPORT void XkbUpdateIndicators(DeviceIntPtr /* keybd */ ,
+                                          CARD32 /* changed */ ,
+                                          Bool /* check_edevs */ ,
+                                          XkbChangesPtr /* pChanges */ ,
+                                          XkbEventCausePtr      /* cause */
+    );
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbAllocSrvLedInfo(DeviceIntPtr /* dev */ ,
+                                                     KbdFeedbackPtr /* kf */ ,
+                                                     LedFeedbackPtr /* lf */ ,
+                                                     unsigned int       /* needed_parts */
+    );
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbCopySrvLedInfo(DeviceIntPtr /* dev */ ,
+                                                    XkbSrvLedInfoPtr /* src */ ,
+                                                    KbdFeedbackPtr /* kf */ ,
+                                                    LedFeedbackPtr      /* lf */
+    );
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbFindSrvLedInfo(DeviceIntPtr /* dev */ ,
+                                                    unsigned int /* class */ ,
+                                                    unsigned int /* id */ ,
+                                                    unsigned int        /* needed_parts */
+    );
+
+extern _X_EXPORT void XkbApplyLedNameChanges(DeviceIntPtr /* dev */ ,
+                                             XkbSrvLedInfoPtr /* sli */ ,
+                                             unsigned int /* changed_names */ ,
+                                             xkbExtensionDeviceNotify * /* ed */
+                                             ,
+                                             XkbChangesPtr /* changes */ ,
+                                             XkbEventCausePtr   /* cause */
+    );
+
+extern _X_EXPORT void XkbApplyLedMapChanges(DeviceIntPtr /* dev */ ,
+                                            XkbSrvLedInfoPtr /* sli */ ,
+                                            unsigned int /* changed_maps */ ,
+                                            xkbExtensionDeviceNotify * /* ed */
+                                            ,
+                                            XkbChangesPtr /* changes */ ,
+                                            XkbEventCausePtr    /* cause */
+    );
+
+extern _X_EXPORT void XkbApplyLedStateChanges(DeviceIntPtr /* dev */ ,
+                                              XkbSrvLedInfoPtr /* sli */ ,
+                                              unsigned int /* changed_leds */ ,
+                                              xkbExtensionDeviceNotify *
+                                              /* ed */ ,
+                                              XkbChangesPtr /* changes */ ,
+                                              XkbEventCausePtr  /* cause */
+    );
+
+extern _X_EXPORT void XkbFlushLedEvents(DeviceIntPtr /* dev */ ,
+                                        DeviceIntPtr /* kbd */ ,
+                                        XkbSrvLedInfoPtr /* sli */ ,
+                                        xkbExtensionDeviceNotify * /* ed */ ,
+                                        XkbChangesPtr /* changes */ ,
+                                        XkbEventCausePtr        /* cause */
+    );
+
+extern _X_EXPORT unsigned int XkbIndicatorsToUpdate(DeviceIntPtr /* dev */ ,
+                                                    unsigned long
+                                                    /* state_changes */ ,
+                                                    Bool        /* enabled_ctrl_changes */
+    );
+
+extern _X_EXPORT void XkbComputeDerivedState(XkbSrvInfoPtr      /* xkbi */
+    );
+
+extern _X_EXPORT void XkbCheckSecondaryEffects(XkbSrvInfoPtr /* xkbi */ ,
+                                               unsigned int /* which */ ,
+                                               XkbChangesPtr /* changes */ ,
+                                               XkbEventCausePtr /* cause */
+    );
+
+extern _X_EXPORT void XkbCheckIndicatorMaps(DeviceIntPtr /* dev */ ,
+                                            XkbSrvLedInfoPtr /* sli */ ,
+                                            unsigned int        /* which */
+    );
+
+extern _X_EXPORT unsigned int XkbStateChangedFlags(XkbStatePtr /* old */ ,
+                                                   XkbStatePtr  /* new */
+    );
+
+extern _X_EXPORT void XkbSendStateNotify(DeviceIntPtr /* kbd */ ,
+                                         xkbStateNotify *       /* pSN */
+    );
+
+extern _X_EXPORT void XkbSendMapNotify(DeviceIntPtr /* kbd */ ,
+                                       xkbMapNotify *   /* ev */
+    );
+
+extern _X_EXPORT int XkbComputeControlsNotify(DeviceIntPtr /* kbd */ ,
+                                              XkbControlsPtr /* old */ ,
+                                              XkbControlsPtr /* new */ ,
+                                              xkbControlsNotify * /* pCN */ ,
+                                              Bool      /* forceCtrlProc */
+    );
+
+extern _X_EXPORT void XkbSendControlsNotify(DeviceIntPtr /* kbd */ ,
+                                            xkbControlsNotify * /* ev */
+    );
+
+extern _X_EXPORT void XkbSendCompatMapNotify(DeviceIntPtr /* kbd */ ,
+                                             xkbCompatMapNotify *       /* ev */
+    );
+
+extern _X_EXPORT void XkbHandleBell(BOOL /* force */ ,
+                                    BOOL /* eventOnly */ ,
+                                    DeviceIntPtr /* kbd */ ,
+                                    CARD8 /* percent */ ,
+                                    void */* ctrl */ ,
+                                    CARD8 /* class */ ,
+                                    Atom /* name */ ,
+                                    WindowPtr /* pWin */ ,
+                                    ClientPtr   /* pClient */
+    );
+
+extern _X_EXPORT void XkbSendAccessXNotify(DeviceIntPtr /* kbd */ ,
+                                           xkbAccessXNotify *   /* pEv */
+    );
+
+extern _X_EXPORT void XkbSendNamesNotify(DeviceIntPtr /* kbd */ ,
+                                         xkbNamesNotify *       /* ev */
+    );
+
+extern _X_EXPORT void XkbSendActionMessage(DeviceIntPtr /* kbd */ ,
+                                           xkbActionMessage *   /* ev */
+    );
+
+extern _X_EXPORT void XkbSendExtensionDeviceNotify(DeviceIntPtr /* kbd */ ,
+                                                   ClientPtr /* client */ ,
+                                                   xkbExtensionDeviceNotify *   /* ev */
+    );
+
+extern _X_EXPORT void XkbSendNotification(DeviceIntPtr /* kbd */ ,
+                                          XkbChangesPtr /* pChanges */ ,
+                                          XkbEventCausePtr      /* cause */
+    );
+
+extern _X_EXPORT void XkbProcessKeyboardEvent(DeviceEvent * /* event */ ,
+                                              DeviceIntPtr      /* keybd */
+    );
+
+extern _X_EXPORT void XkbHandleActions(DeviceIntPtr /* dev */ ,
+                                       DeviceIntPtr /* kbd */ ,
+                                       DeviceEvent *    /* event */
+    );
+
+extern void XkbPushLockedStateToSlaves(DeviceIntPtr /* master */,
+                                       int /* evtype */,
+                                       int /* key */);
+
+extern _X_EXPORT Bool XkbEnableDisableControls(XkbSrvInfoPtr /* xkbi */ ,
+                                               unsigned long /* change */ ,
+                                               unsigned long /* newValues */ ,
+                                               XkbChangesPtr /* changes */ ,
+                                               XkbEventCausePtr /* cause */
+    );
+
+extern _X_EXPORT void AccessXInit(DeviceIntPtr  /* dev */
+    );
+
+extern _X_EXPORT Bool AccessXFilterPressEvent(DeviceEvent * /* event */ ,
+                                              DeviceIntPtr      /* keybd */
+    );
+
+extern _X_EXPORT Bool AccessXFilterReleaseEvent(DeviceEvent * /* event */ ,
+                                                DeviceIntPtr    /* keybd */
+    );
+
+extern _X_EXPORT void AccessXCancelRepeatKey(XkbSrvInfoPtr /* xkbi */ ,
+                                             KeyCode    /* key */
+    );
+
+extern _X_EXPORT void AccessXComputeCurveFactor(XkbSrvInfoPtr /* xkbi */ ,
+                                                XkbControlsPtr  /* ctrls */
+    );
+
+extern _X_EXPORT XkbInterestPtr XkbFindClientResource(DevicePtr /* inDev */ ,
+                                                      ClientPtr /* client */
+    );
+
+extern _X_EXPORT XkbInterestPtr XkbAddClientResource(DevicePtr /* inDev */ ,
+                                                     ClientPtr /* client */ ,
+                                                     XID        /* id */
+    );
+
+extern _X_EXPORT int XkbRemoveResourceClient(DevicePtr /* inDev */ ,
+                                             XID        /* id */
+    );
+
+extern _X_EXPORT int XkbDDXAccessXBeep(DeviceIntPtr /* dev */ ,
+                                       unsigned int /* what */ ,
+                                       unsigned int     /* which */
+    );
+
+extern _X_EXPORT int XkbDDXUsesSoftRepeat(DeviceIntPtr  /* dev */
+    );
+
+extern _X_EXPORT void XkbDDXKeybdCtrlProc(DeviceIntPtr /* dev */ ,
+                                          KeybdCtrl *   /* ctrl */
+    );
+
+extern _X_EXPORT void XkbDDXChangeControls(DeviceIntPtr /* dev */ ,
+                                           XkbControlsPtr /* old */ ,
+                                           XkbControlsPtr       /* new */
+    );
+
+extern _X_EXPORT void XkbDDXUpdateDeviceIndicators(DeviceIntPtr /* dev */ ,
+                                                   XkbSrvLedInfoPtr /* sli */ ,
+                                                   CARD32       /* newState */
+    );
+
+extern _X_EXPORT int XkbDDXTerminateServer(DeviceIntPtr /* dev */ ,
+                                           KeyCode /* key */ ,
+                                           XkbAction *  /* act */
+    );
+
+extern _X_EXPORT int XkbDDXSwitchScreen(DeviceIntPtr /* dev */ ,
+                                        KeyCode /* key */ ,
+                                        XkbAction *     /* act */
+    );
+
+extern _X_EXPORT int XkbDDXPrivate(DeviceIntPtr /* dev */ ,
+                                   KeyCode /* key */ ,
+                                   XkbAction *  /* act */
+    );
+
+extern _X_EXPORT void XkbDisableComputedAutoRepeats(DeviceIntPtr /* pXDev */ ,
+                                                    unsigned int        /* key */
+    );
+
+extern _X_EXPORT void XkbSetRepeatKeys(DeviceIntPtr /* pXDev */ ,
+                                       int /* key */ ,
+                                       int      /* onoff */
+    );
+
+extern _X_EXPORT int XkbLatchModifiers(DeviceIntPtr /* pXDev */ ,
+                                       CARD8 /* mask */ ,
+                                       CARD8    /* latches */
+    );
+
+extern _X_EXPORT int XkbLatchGroup(DeviceIntPtr /* pXDev */ ,
+                                   int  /* group */
+    );
+
+extern _X_EXPORT void XkbClearAllLatchesAndLocks(DeviceIntPtr /* dev */ ,
+                                                 XkbSrvInfoPtr /* xkbi */ ,
+                                                 Bool /* genEv */ ,
+                                                 XkbEventCausePtr       /* cause */
+    );
+
+extern _X_EXPORT void XkbInitRules(XkbRMLVOSet * /* rmlvo   */,
+                                   const char *  /* rules   */,
+                                   const char *  /* model   */,
+                                   const char *  /* layout  */,
+                                   const char *  /* variant */,
+                                   const char *  /* options */
+    ) ;
+
+extern _X_EXPORT void XkbGetRulesDflts(XkbRMLVOSet *    /* rmlvo */
+    );
+
+extern _X_EXPORT void XkbFreeRMLVOSet(XkbRMLVOSet * /* rmlvo */ ,
+                                      Bool      /* freeRMLVO */
+    );
+
+extern _X_EXPORT void XkbSetRulesDflts(XkbRMLVOSet *    /* rmlvo */
+    );
+
+extern _X_EXPORT void XkbDeleteRulesDflts(void
+    );
+
+extern _X_EXPORT void XkbDeleteRulesUsed(void
+    );
+
+extern _X_EXPORT int SProcXkbDispatch(ClientPtr /* client */
+    );
+
+extern _X_EXPORT XkbGeometryPtr XkbLookupNamedGeometry(DeviceIntPtr /* dev */ ,
+                                                       Atom /* name */ ,
+                                                       Bool *   /* shouldFree */
+    );
+
+extern _X_EXPORT void XkbConvertCase(KeySym /* sym */ ,
+                                     KeySym * /* lower */ ,
+                                     KeySym *   /* upper */
+    );
+
+extern _X_EXPORT Status XkbChangeKeycodeRange(XkbDescPtr /* xkb */ ,
+                                              int /* minKC */ ,
+                                              int /* maxKC */ ,
+                                              XkbChangesPtr     /* changes */
+    );
+
+extern _X_EXPORT void XkbFreeSrvLedInfo(XkbSrvLedInfoPtr        /* sli */
+    );
+
+extern _X_EXPORT void XkbFreeInfo(XkbSrvInfoPtr /* xkbi */
+    );
+
+extern _X_EXPORT Status XkbChangeTypesOfKey(XkbDescPtr /* xkb */ ,
+                                            int /* key */ ,
+                                            int /* nGroups */ ,
+                                            unsigned int /* groups */ ,
+                                            int * /* newTypesIn */ ,
+                                            XkbMapChangesPtr    /* changes */
+    );
+
+extern _X_EXPORT int XkbKeyTypesForCoreSymbols(XkbDescPtr /* xkb */ ,
+                                               int /* map_width */ ,
+                                               KeySym * /* core_syms */ ,
+                                               unsigned int /* protected */ ,
+                                               int * /* types_inout */ ,
+                                               KeySym * /* xkb_syms_rtrn */
+    );
+
+extern _X_EXPORT Bool XkbApplyCompatMapToKey(XkbDescPtr /* xkb */ ,
+                                             KeyCode /* key */ ,
+                                             XkbChangesPtr      /* changes */
+    );
+
+extern _X_EXPORT Bool XkbApplyVirtualModChanges(XkbDescPtr /* xkb */ ,
+                                                unsigned int /* changed */ ,
+                                                XkbChangesPtr   /* changes */
+    );
+
+extern _X_EXPORT void XkbSendNewKeyboardNotify(DeviceIntPtr /* kbd */ ,
+                                               xkbNewKeyboardNotify *   /* pNKN */
+    );
+
+extern Bool XkbCopyKeymap(XkbDescPtr /* dst */ ,
+                          XkbDescPtr /* src */ );
+
+extern _X_EXPORT Bool XkbCopyDeviceKeymap(DeviceIntPtr /* dst */,
+					  DeviceIntPtr /* src */);
+
+extern _X_EXPORT Bool XkbDeviceApplyKeymap(DeviceIntPtr /* dst */ ,
+                                           XkbDescPtr /* src */ );
+
+extern void XkbFilterEvents(ClientPtr /* pClient */ ,
+                            int /* nEvents */ ,
+                            xEvent * /* xE */ );
+
+extern int XkbGetEffectiveGroup(XkbSrvInfoPtr /* xkbi */ ,
+                                XkbStatePtr /* xkbstate */ ,
+                                CARD8 /* keycode */ );
+
+extern void XkbMergeLockedPtrBtns(DeviceIntPtr /* master */ );
+
+extern void XkbFakeDeviceButton(DeviceIntPtr /* dev */ ,
+                                int /* press */ ,
+                                int /* button */ );
+
+extern _X_EXPORT void XkbCopyControls(XkbDescPtr /* dst */ ,
+                                      XkbDescPtr /* src */ );
+
+#include "xkbfile.h"
+#include "xkbrules.h"
+
+#define	_XkbListKeycodes	0
+#define	_XkbListTypes		1
+#define	_XkbListCompat		2
+#define	_XkbListSymbols		3
+#define	_XkbListGeometry	4
+#define	_XkbListNumComponents	5
+
+extern _X_EXPORT unsigned int XkbDDXLoadKeymapByNames(DeviceIntPtr /* keybd */ ,
+                                                      XkbComponentNamesPtr
+                                                      /* names */ ,
+                                                      unsigned int /* want */ ,
+                                                      unsigned int /* need */ ,
+                                                      XkbDescPtr *
+                                                      /* finfoRtrn */ ,
+                                                      char *
+                                                      /* keymapNameRtrn */ ,
+                                                      int       /* keymapNameRtrnLen */
+    );
+
+extern _X_EXPORT Bool XkbDDXNamesFromRules(DeviceIntPtr /* keybd */ ,
+                                           const char * /* rules */ ,
+                                           XkbRF_VarDefsPtr /* defs */ ,
+                                           XkbComponentNamesPtr /* names */
+    );
+
+extern _X_EXPORT XkbDescPtr XkbCompileKeymap(DeviceIntPtr /* dev */ ,
+                                             XkbRMLVOSet *      /* rmlvo */
+    );
+
+extern _X_EXPORT XkbDescPtr XkbCompileKeymapFromString(DeviceIntPtr dev,
+						       const char *keymap,
+						       int keymap_length);
+
+#endif                          /* _XKBSRV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xkbsrv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpackYX.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpackYX.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpackYX.h	(Revision 52145)
@@ -0,0 +1,152 @@
+/*
+ * Copyright ¬© 2004 Philip Blundell
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Philip Blundell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Philip Blundell makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * PHILIP BLUNDELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL PHILIP BLUNDELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include    <X11/X.h>
+#include    "scrnintstr.h"
+#include    "windowstr.h"
+#include    "dixfontstr.h"
+#include    "mi.h"
+#include    "regionstr.h"
+#include    "globals.h"
+#include    "gcstruct.h"
+#include    "shadow.h"
+#include    "fb.h"
+
+#if ROTATE == 270
+
+#define WINSTEPX(stride)    (stride)
+#define WINSTART(x,y)       (((pScreen->height - 1) - y) + (x * winStride))
+#define WINSTEPY()	    -1
+
+#elif ROTATE == 90
+
+#define WINSTEPX(stride)    (-stride)
+#define WINSTEPY()	    1
+#define WINSTART(x,y)       (((pScreen->width - 1 - x) * winStride) + y)
+
+#else
+
+#error This rotation is not supported here
+
+#endif
+
+#ifdef __arm__
+#define PREFETCH
+#endif
+
+void
+FUNC(ScreenPtr pScreen, shadowBufPtr pBuf)
+{
+    RegionPtr damage = shadowDamage(pBuf);
+    PixmapPtr pShadow = pBuf->pPixmap;
+    int nbox = RegionNumRects(damage);
+    BoxPtr pbox = RegionRects(damage);
+    FbBits *shaBits;
+    Data *shaBase, *shaLine, *sha;
+    FbStride shaStride, winStride;
+    int shaBpp;
+    _X_UNUSED int shaXoff, shaYoff;
+    int x, y, w, h;
+    Data *winBase, *win, *winLine;
+    CARD32 winSize;
+
+    fbGetDrawable(&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff,
+                  shaYoff);
+    shaBase = (Data *) shaBits;
+    shaStride = shaStride * sizeof(FbBits) / sizeof(Data);
+
+    winBase = (Data *) (*pBuf->window) (pScreen, 0, 0,
+                                        SHADOW_WINDOW_WRITE,
+                                        &winSize, pBuf->closure);
+    winStride = (Data *) (*pBuf->window) (pScreen, 1, 0,
+                                          SHADOW_WINDOW_WRITE,
+                                          &winSize, pBuf->closure) - winBase;
+
+    while (nbox--) {
+        x = pbox->x1;
+        y = pbox->y1;
+        w = (pbox->x2 - pbox->x1);
+        h = pbox->y2 - pbox->y1;
+
+        shaLine = shaBase + (y * shaStride) + x;
+#ifdef PREFETCH
+        __builtin_prefetch(shaLine);
+#endif
+        winLine = winBase + WINSTART(x, y);
+
+        while (h--) {
+            sha = shaLine;
+            win = winLine;
+
+            while (sha < (shaLine + w - 16)) {
+#ifdef PREFETCH
+                __builtin_prefetch(sha + shaStride);
+#endif
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+            }
+
+            while (sha < (shaLine + w)) {
+                *win = *sha++;
+                win += WINSTEPX(winStride);
+            }
+
+            y++;
+            shaLine += shaStride;
+            winLine += WINSTEPY();
+        }
+        pbox++;
+    }                           /*  nbox */
+}

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpackYX.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor.h	(Revision 52145)
@@ -0,0 +1,463 @@
+/*
+ * Copyright ¬© 2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *    Zhigang Gong <zhigang.gong@linux.intel.com>
+ *
+ */
+
+#ifndef GLAMOR_H
+#define GLAMOR_H
+
+#include <scrnintstr.h>
+#include <pixmapstr.h>
+#include <gcstruct.h>
+#include <picturestr.h>
+#include <fb.h>
+#include <fbpict.h>
+#ifdef GLAMOR_FOR_XORG
+#include <xf86xv.h>
+#endif
+
+struct glamor_context;
+
+/*
+ * glamor_pixmap_type : glamor pixmap's type.
+ * @MEMORY: pixmap is in memory.
+ * @TEXTURE_DRM: pixmap is in a texture created from a DRM buffer.
+ * @SEPARATE_TEXTURE: The texture is created from a DRM buffer, but
+ * 		      the format is incompatible, so this type of pixmap
+ * 		      will never fallback to DDX layer.
+ * @DRM_ONLY: pixmap is in a external DRM buffer.
+ * @TEXTURE_ONLY: pixmap is in an internal texture.
+ */
+typedef enum glamor_pixmap_type {
+    GLAMOR_MEMORY,
+    GLAMOR_MEMORY_MAP,
+    GLAMOR_TEXTURE_DRM,
+    GLAMOR_SEPARATE_TEXTURE,
+    GLAMOR_DRM_ONLY,
+    GLAMOR_TEXTURE_ONLY,
+    GLAMOR_TEXTURE_LARGE,
+    GLAMOR_TEXTURE_PACK
+} glamor_pixmap_type_t;
+
+#define GLAMOR_EGL_EXTERNAL_BUFFER 3
+#define GLAMOR_INVERTED_Y_AXIS  	1
+#define GLAMOR_USE_SCREEN		(1 << 1)
+#define GLAMOR_USE_PICTURE_SCREEN 	(1 << 2)
+#define GLAMOR_USE_EGL_SCREEN		(1 << 3)
+#define GLAMOR_NO_DRI3			(1 << 4)
+#define GLAMOR_VALID_FLAGS      (GLAMOR_INVERTED_Y_AXIS  		\
+				 | GLAMOR_USE_SCREEN 			\
+                                 | GLAMOR_USE_PICTURE_SCREEN		\
+				 | GLAMOR_USE_EGL_SCREEN                \
+                                 | GLAMOR_NO_DRI3)
+
+/* @glamor_init: Initialize glamor internal data structure.
+ *
+ * @screen: Current screen pointer.
+ * @flags:  Please refer the flags description above.
+ *
+ * 	@GLAMOR_INVERTED_Y_AXIS:
+ * 	set 1 means the GL env's origin (0,0) is at top-left.
+ * 	EGL/DRM platform is an example need to set this bit.
+ * 	glx platform's origin is at bottom-left thus need to
+ * 	clear this bit.
+ *
+ * 	@GLAMOR_USE_SCREEN:
+ *	If running in an pre-existing X environment, and the
+ * 	gl context is GLX, then you should set this bit and
+ * 	let the glamor to handle all the screen related
+ * 	functions such as GC ops and CreatePixmap/DestroyPixmap.
+ *
+ * 	@GLAMOR_USE_PICTURE_SCREEN:
+ * 	If don't use any other underlying DDX driver to handle
+ * 	the picture related rendering functions, please set this
+ * 	bit on. Otherwise, clear this bit. And then it is the DDX
+ * 	driver's responsibility to determine how/when to jump to
+ * 	glamor's picture compositing path.
+ *
+ * 	@GLAMOR_USE_EGL_SCREEN:
+ * 	If you are using EGL layer, then please set this bit
+ * 	on, otherwise, clear it.
+ *
+ * This function initializes necessary internal data structure
+ * for glamor. And before calling into this function, the OpenGL
+ * environment should be ready. Should be called before any real
+ * glamor rendering or texture allocation functions. And should
+ * be called after the DDX's screen initialization or at the last
+ * step of the DDX's screen initialization.
+ */
+extern _X_EXPORT Bool glamor_init(ScreenPtr screen, unsigned int flags);
+extern _X_EXPORT void glamor_fini(ScreenPtr screen);
+
+/* This function is used to free the glamor private screen's
+ * resources. If the DDX driver is not set GLAMOR_USE_SCREEN,
+ * then, DDX need to call this function at proper stage, if
+ * it is the xorg DDX driver,then it should be called at free
+ * screen stage not the close screen stage. The reason is after
+ * call to this function, the xorg DDX may need to destroy the
+ * screen pixmap which must be a glamor pixmap and requires
+ * the internal data structure still exist at that time.
+ * Otherwise, the glamor internal structure will not be freed.*/
+extern _X_EXPORT Bool glamor_close_screen(ScreenPtr screen);
+
+/* Let glamor to know the screen's fbo. The low level
+ * driver should already assign a tex
+ * to this pixmap through the set_pixmap_texture. */
+extern _X_EXPORT void glamor_set_screen_pixmap(PixmapPtr screen_pixmap,
+                                               PixmapPtr *back_pixmap);
+
+extern _X_EXPORT uint32_t glamor_get_pixmap_texture(PixmapPtr pixmap);
+
+extern _X_EXPORT Bool glamor_glyphs_init(ScreenPtr pScreen);
+
+extern _X_EXPORT void glamor_set_pixmap_texture(PixmapPtr pixmap,
+                                                unsigned int tex);
+
+extern _X_EXPORT void glamor_set_pixmap_type(PixmapPtr pixmap,
+                                             glamor_pixmap_type_t type);
+extern _X_EXPORT void glamor_destroy_textured_pixmap(PixmapPtr pixmap);
+extern _X_EXPORT void glamor_block_handler(ScreenPtr screen);
+
+extern _X_EXPORT PixmapPtr glamor_create_pixmap(ScreenPtr screen, int w, int h,
+                                                int depth, unsigned int usage);
+extern _X_EXPORT Bool glamor_destroy_pixmap(PixmapPtr pixmap);
+
+#define GLAMOR_CREATE_PIXMAP_CPU        0x100
+#define GLAMOR_CREATE_PIXMAP_FIXUP      0x101
+#define GLAMOR_CREATE_FBO_NO_FBO        0x103
+#define GLAMOR_CREATE_PIXMAP_MAP        0x104
+#define GLAMOR_CREATE_NO_LARGE          0x105
+#define GLAMOR_CREATE_PIXMAP_NO_TEXTURE 0x106
+
+/* @glamor_egl_exchange_buffers: Exchange the underlying buffers(KHR image,fbo).
+ *
+ * @front: front pixmap.
+ * @back: back pixmap.
+ *
+ * Used by the DRI2 page flip. This function will exchange the KHR images and
+ * fbos of the two pixmaps.
+ * */
+extern _X_EXPORT void glamor_egl_exchange_buffers(PixmapPtr front,
+                                                  PixmapPtr back);
+
+extern _X_EXPORT void glamor_pixmap_exchange_fbos(PixmapPtr front,
+                                                  PixmapPtr back);
+
+/* The DDX is not supposed to call these three functions */
+extern _X_EXPORT void glamor_enable_dri3(ScreenPtr screen);
+extern _X_EXPORT unsigned int glamor_egl_create_argb8888_based_texture(ScreenPtr
+                                                                       screen,
+                                                                       int w,
+                                                                       int h);
+extern _X_EXPORT int glamor_egl_dri3_fd_name_from_tex(ScreenPtr, PixmapPtr,
+                                                      unsigned int, Bool,
+                                                      CARD16 *, CARD32 *);
+
+/* @glamor_supports_pixmap_import_export: Returns whether
+ * glamor_fd_from_pixmap(), glamor_name_from_pixmap(), and
+ * glamor_pixmap_from_fd() are supported.
+ *
+ * @screen: Current screen pointer.
+ *
+ * To have DRI3 support enabled, glamor and glamor_egl need to be
+ * initialized. glamor also has to be compiled with gbm support.
+ *
+ * The EGL layer needs to have the following extensions working:
+ *
+ * .EGL_KHR_gl_texture_2D_image
+ * .EGL_EXT_image_dma_buf_import
+ * */
+extern _X_EXPORT Bool glamor_supports_pixmap_import_export(ScreenPtr screen);
+
+/* @glamor_fd_from_pixmap: Get a dma-buf fd from a pixmap.
+ *
+ * @screen: Current screen pointer.
+ * @pixmap: The pixmap from which we want the fd.
+ * @stride, @size: Pointers to fill the stride and size of the
+ * 		   buffer associated to the fd.
+ *
+ * the pixmap and the buffer associated by the fd will share the same
+ * content.
+ * Returns the fd on success, -1 on error.
+ * */
+extern _X_EXPORT int glamor_fd_from_pixmap(ScreenPtr screen,
+                                           PixmapPtr pixmap,
+                                           CARD16 *stride, CARD32 *size);
+
+/**
+ * @glamor_name_from_pixmap: Gets a gem name from a pixmap.
+ *
+ * @pixmap: The pixmap from which we want the gem name.
+ *
+ * the pixmap and the buffer associated by the gem name will share the
+ * same content. This function can be used by the DDX to support DRI2,
+ * and needs the same set of buffer export GL extensions as DRI3
+ * support.
+ *
+ * Returns the name on success, -1 on error.
+ * */
+extern _X_EXPORT int glamor_name_from_pixmap(PixmapPtr pixmap,
+                                             CARD16 *stride, CARD32 *size);
+
+/* @glamor_pixmap_from_fd: Creates a pixmap to wrap a dma-buf fd.
+ *
+ * @screen: Current screen pointer.
+ * @fd: The dma-buf fd to import.
+ * @width: The width of the buffer.
+ * @height: The height of the buffer.
+ * @stride: The stride of the buffer.
+ * @depth: The depth of the buffer.
+ * @bpp: The number of bpp of the buffer.
+ *
+ * Returns a valid pixmap if the import succeeded, else NULL.
+ * */
+extern _X_EXPORT PixmapPtr glamor_pixmap_from_fd(ScreenPtr screen,
+                                                 int fd,
+                                                 CARD16 width,
+                                                 CARD16 height,
+                                                 CARD16 stride,
+                                                 CARD8 depth,
+                                                 CARD8 bpp);
+
+#ifdef GLAMOR_FOR_XORG
+
+#define GLAMOR_EGL_MODULE_NAME  "glamoregl"
+
+/* @glamor_egl_init: Initialize EGL environment.
+ *
+ * @scrn: Current screen info pointer.
+ * @fd:   Current drm fd.
+ *
+ * This function creates and intialize EGL contexts.
+ * Should be called from DDX's preInit function.
+ * Return TRUE if success, otherwise return FALSE.
+ * */
+extern _X_EXPORT Bool glamor_egl_init(ScrnInfoPtr scrn, int fd);
+
+extern _X_EXPORT Bool glamor_egl_init_textured_pixmap(ScreenPtr screen);
+
+/* @glamor_egl_create_textured_screen: Create textured screen pixmap.
+ *
+ * @screen: screen pointer to be processed.
+ * @handle: screen pixmap's BO handle.
+ * @stride: screen pixmap's stride in bytes.
+ *
+ * This function is similar with the create_textured_pixmap. As the
+ * screen pixmap is a special, we handle it separately in this function.
+ */
+extern _X_EXPORT Bool glamor_egl_create_textured_screen(ScreenPtr screen,
+                                                        int handle, int stride);
+
+/* @glamor_egl_create_textured_screen_ext:
+ *
+ * extent one parameter to track the pointer of the DDX layer's back pixmap.
+ * We need this pointer during the closing screen stage. As before back to
+ * the DDX's close screen, we have to free all the glamor related resources.
+ */
+extern _X_EXPORT Bool glamor_egl_create_textured_screen_ext(ScreenPtr screen,
+                                                            int handle,
+                                                            int stride,
+                                                            PixmapPtr
+                                                            *back_pixmap);
+
+/*
+ * @glamor_egl_create_textured_pixmap: Try to create a textured pixmap from
+ * 				       a BO handle.
+ *
+ * @pixmap: The pixmap need to be processed.
+ * @handle: The BO's handle attached to this pixmap at DDX layer.
+ * @stride: Stride in bytes for this pixmap.
+ *
+ * This function try to create a texture from the handle and attach
+ * the texture to the pixmap , thus glamor can render to this pixmap
+ * as well. Return true if successful, otherwise return FALSE.
+ */
+extern _X_EXPORT Bool glamor_egl_create_textured_pixmap(PixmapPtr pixmap,
+                                                        int handle, int stride);
+
+/*
+ * @glamor_egl_create_textured_pixmap_from_bo: Try to create a textured pixmap
+ * 					       from a gbm_bo.
+ *
+ * @pixmap: The pixmap need to be processed.
+ * @bo: a pointer on a gbm_bo structure attached to this pixmap at DDX layer.
+ *
+ * This function is similar to glamor_egl_create_textured_pixmap.
+ */
+extern _X_EXPORT Bool
+ glamor_egl_create_textured_pixmap_from_gbm_bo(PixmapPtr pixmap, void *bo);
+
+#endif
+
+extern _X_EXPORT void glamor_egl_screen_init(ScreenPtr screen,
+                                             struct glamor_context *glamor_ctx);
+extern _X_EXPORT void glamor_egl_destroy_textured_pixmap(PixmapPtr pixmap);
+
+extern _X_EXPORT int glamor_create_gc(GCPtr gc);
+
+extern _X_EXPORT void glamor_validate_gc(GCPtr gc, unsigned long changes,
+                                         DrawablePtr drawable);
+
+extern Bool _X_EXPORT glamor_change_window_attributes(WindowPtr pWin, unsigned long mask);
+extern void _X_EXPORT glamor_copy_window(WindowPtr window, DDXPointRec old_origin, RegionPtr src_region);
+
+/* Glamor rendering/drawing functions with XXX_nf.
+ * nf means no fallback within glamor internal if possible. If glamor
+ * fail to accelerate the operation, glamor will return a false, and the
+ * caller need to implement fallback method. Return a true means the
+ * rendering request get done successfully. */
+extern _X_EXPORT Bool glamor_fill_spans_nf(DrawablePtr drawable,
+                                           GCPtr gc,
+                                           int n, DDXPointPtr points,
+                                           int *widths, int sorted);
+
+extern _X_EXPORT Bool glamor_poly_fill_rect_nf(DrawablePtr drawable,
+                                               GCPtr gc,
+                                               int nrect, xRectangle *prect);
+
+extern _X_EXPORT Bool glamor_put_image_nf(DrawablePtr drawable,
+                                          GCPtr gc, int depth, int x, int y,
+                                          int w, int h, int left_pad,
+                                          int image_format, char *bits);
+
+extern _X_EXPORT Bool glamor_copy_n_to_n_nf(DrawablePtr src,
+                                            DrawablePtr dst,
+                                            GCPtr gc,
+                                            BoxPtr box,
+                                            int nbox,
+                                            int dx,
+                                            int dy,
+                                            Bool reverse,
+                                            Bool upsidedown, Pixel bitplane,
+                                            void *closure);
+
+extern _X_EXPORT Bool glamor_composite_nf(CARD8 op,
+                                          PicturePtr source,
+                                          PicturePtr mask,
+                                          PicturePtr dest,
+                                          INT16 x_source,
+                                          INT16 y_source,
+                                          INT16 x_mask,
+                                          INT16 y_mask,
+                                          INT16 x_dest, INT16 y_dest,
+                                          CARD16 width, CARD16 height);
+
+extern _X_EXPORT Bool glamor_trapezoids_nf(CARD8 op,
+                                           PicturePtr src, PicturePtr dst,
+                                           PictFormatPtr mask_format,
+                                           INT16 x_src, INT16 y_src,
+                                           int ntrap, xTrapezoid *traps);
+
+extern _X_EXPORT Bool glamor_glyphs_nf(CARD8 op,
+                                       PicturePtr src,
+                                       PicturePtr dst,
+                                       PictFormatPtr mask_format,
+                                       INT16 x_src,
+                                       INT16 y_src, int nlist,
+                                       GlyphListPtr list, GlyphPtr *glyphs);
+
+extern _X_EXPORT Bool glamor_triangles_nf(CARD8 op,
+                                          PicturePtr pSrc,
+                                          PicturePtr pDst,
+                                          PictFormatPtr maskFormat,
+                                          INT16 xSrc, INT16 ySrc,
+                                          int ntris, xTriangle *tris);
+
+extern _X_EXPORT void glamor_glyph_unrealize(ScreenPtr screen, GlyphPtr glyph);
+
+extern _X_EXPORT Bool glamor_set_spans_nf(DrawablePtr drawable, GCPtr gc,
+                                          char *src, DDXPointPtr points,
+                                          int *widths, int n, int sorted);
+
+extern _X_EXPORT Bool glamor_get_spans_nf(DrawablePtr drawable, int wmax,
+                                          DDXPointPtr points, int *widths,
+                                          int count, char *dst);
+
+extern _X_EXPORT Bool glamor_composite_rects_nf(CARD8 op,
+                                                PicturePtr pDst,
+                                                xRenderColor *color,
+                                                int nRect, xRectangle *rects);
+
+extern _X_EXPORT Bool glamor_get_image_nf(DrawablePtr pDrawable, int x, int y,
+                                          int w, int h, unsigned int format,
+                                          unsigned long planeMask, char *d);
+
+extern _X_EXPORT Bool glamor_add_traps_nf(PicturePtr pPicture,
+                                          INT16 x_off,
+                                          INT16 y_off, int ntrap,
+                                          xTrap *traps);
+
+extern _X_EXPORT Bool glamor_copy_plane_nf(DrawablePtr pSrc, DrawablePtr pDst,
+                                           GCPtr pGC, int srcx, int srcy, int w,
+                                           int h, int dstx, int dsty,
+                                           unsigned long bitPlane,
+                                           RegionPtr *pRegion);
+
+extern _X_EXPORT Bool glamor_image_glyph_blt_nf(DrawablePtr pDrawable,
+                                                GCPtr pGC, int x, int y,
+                                                unsigned int nglyph,
+                                                CharInfoPtr *ppci,
+                                                void *pglyphBase);
+
+extern _X_EXPORT Bool glamor_poly_glyph_blt_nf(DrawablePtr pDrawable, GCPtr pGC,
+                                               int x, int y,
+                                               unsigned int nglyph,
+                                               CharInfoPtr *ppci,
+                                               void *pglyphBase);
+
+extern _X_EXPORT Bool glamor_push_pixels_nf(GCPtr pGC, PixmapPtr pBitmap,
+                                            DrawablePtr pDrawable, int w, int h,
+                                            int x, int y);
+
+extern _X_EXPORT Bool glamor_poly_point_nf(DrawablePtr pDrawable, GCPtr pGC,
+                                           int mode, int npt, DDXPointPtr ppt);
+
+extern _X_EXPORT Bool glamor_poly_segment_nf(DrawablePtr pDrawable, GCPtr pGC,
+                                             int nseg, xSegment *pSeg);
+
+extern _X_EXPORT Bool glamor_poly_lines_nf(DrawablePtr drawable, GCPtr gc,
+                                           int mode, int n, DDXPointPtr points);
+
+extern _X_EXPORT Bool glamor_poly_text8_nf(DrawablePtr drawable, GCPtr gc,
+                                           int x, int y, int count, char *chars, int *final_pos);
+
+extern _X_EXPORT Bool glamor_poly_text16_nf(DrawablePtr drawable, GCPtr gc,
+                                            int x, int y, int count, unsigned short *chars, int *final_pos);
+
+extern _X_EXPORT Bool glamor_image_text8_nf(DrawablePtr drawable, GCPtr gc,
+                                            int x, int y, int count, char *chars);
+
+extern _X_EXPORT Bool glamor_image_text16_nf(DrawablePtr drawable, GCPtr gc,
+                                             int x, int y, int count, unsigned short *chars);
+
+#define HAS_GLAMOR_TEXT 1
+
+#ifdef GLAMOR_FOR_XORG
+extern _X_EXPORT XF86VideoAdaptorPtr glamor_xv_init(ScreenPtr pScreen,
+                                                    int num_texture_ports);
+#endif
+
+#endif                          /* GLAMOR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sleepuntil.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sleepuntil.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sleepuntil.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2001 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from the
+ * XFree86 Project.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _SLEEPUNTIL_H_
+#define _SLEEPUNTIL_H_ 1
+
+#include "dix.h"
+
+extern int ClientSleepUntil(ClientPtr client,
+                            TimeStamp *revive,
+                            void (*notifyFunc) (ClientPtr /* client */ ,
+                                                void *    /* closure */
+                            ), void *Closure);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sleepuntil.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dpmsproc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dpmsproc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dpmsproc.h	(Revision 52145)
@@ -0,0 +1,15 @@
+/* Prototypes for functions that the DDX must provide */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DPMSPROC_H_
+#define _DPMSPROC_H_
+
+#include "dixstruct.h"
+
+int _X_EXPORT DPMSSet(ClientPtr client, int level);
+Bool _X_EXPORT DPMSSupported(void);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dpmsproc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Sbus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Sbus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Sbus.h	(Revision 52145)
@@ -0,0 +1,69 @@
+/*
+ * Platform specific SBUS and OpenPROM access declarations.
+ *
+ * Copyright (C) 2000 Jakub Jelinek (jakub@redhat.com)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * JAKUB JELINEK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_SBUS_H
+#define _XF86_SBUS_H
+
+#if defined(linux)
+#include <asm/types.h>
+#include <linux/fb.h>
+#include <asm/fbio.h>
+#include <asm/openpromio.h>
+#elif defined(SVR4)
+#include <sys/fbio.h>
+#include <sys/openpromio.h>
+#elif defined(__OpenBSD__) && defined(__sparc64__)
+/* XXX */
+#elif defined(CSRG_BASED)
+#if defined(__FreeBSD__)
+#include <sys/types.h>
+#include <sys/fbio.h>
+#include <dev/ofw/openpromio.h>
+#else
+#include <machine/fbio.h>
+#endif
+#else
+#include <sun/fbio.h>
+#endif
+
+#ifndef FBTYPE_SUNGP3
+#define FBTYPE_SUNGP3 -1
+#endif
+#ifndef FBTYPE_MDICOLOR
+#define FBTYPE_MDICOLOR -1
+#endif
+#ifndef FBTYPE_SUNLEO
+#define FBTYPE_SUNLEO -1
+#endif
+#ifndef FBTYPE_TCXCOLOR
+#define FBTYPE_TCXCOLOR -1
+#endif
+#ifndef FBTYPE_CREATOR
+#define FBTYPE_CREATOR -1
+#endif
+
+#endif                          /* _XF86_SBUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Sbus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/int10Defines.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/int10Defines.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/int10Defines.h	(Revision 52145)
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2000-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _INT10DEFINES_H_
+#define _INT10DEFINES_H_ 1
+
+#ifdef _VM86_LINUX
+
+#include <asm/vm86.h>
+
+#define CPU_R(type,name,num) \
+	(((type *)&(((struct vm86_struct *)REG->cpuRegs)->regs.name))[num])
+#define CPU_RD(name,num) CPU_R(CARD32,name,num)
+#define CPU_RW(name,num) CPU_R(CARD16,name,num)
+#define CPU_RB(name,num) CPU_R(CARD8,name,num)
+
+#define X86_EAX CPU_RD(eax,0)
+#define X86_EBX CPU_RD(ebx,0)
+#define X86_ECX CPU_RD(ecx,0)
+#define X86_EDX CPU_RD(edx,0)
+#define X86_ESI CPU_RD(esi,0)
+#define X86_EDI CPU_RD(edi,0)
+#define X86_EBP CPU_RD(ebp,0)
+#define X86_EIP CPU_RD(eip,0)
+#define X86_ESP CPU_RD(esp,0)
+#define X86_EFLAGS CPU_RD(eflags,0)
+
+#define X86_FLAGS CPU_RW(eflags,0)
+#define X86_AX CPU_RW(eax,0)
+#define X86_BX CPU_RW(ebx,0)
+#define X86_CX CPU_RW(ecx,0)
+#define X86_DX CPU_RW(edx,0)
+#define X86_SI CPU_RW(esi,0)
+#define X86_DI CPU_RW(edi,0)
+#define X86_BP CPU_RW(ebp,0)
+#define X86_IP CPU_RW(eip,0)
+#define X86_SP CPU_RW(esp,0)
+#define X86_CS CPU_RW(cs,0)
+#define X86_DS CPU_RW(ds,0)
+#define X86_ES CPU_RW(es,0)
+#define X86_SS CPU_RW(ss,0)
+#define X86_FS CPU_RW(fs,0)
+#define X86_GS CPU_RW(gs,0)
+
+#define X86_AL CPU_RB(eax,0)
+#define X86_BL CPU_RB(ebx,0)
+#define X86_CL CPU_RB(ecx,0)
+#define X86_DL CPU_RB(edx,0)
+
+#define X86_AH CPU_RB(eax,1)
+#define X86_BH CPU_RB(ebx,1)
+#define X86_CH CPU_RB(ecx,1)
+#define X86_DH CPU_RB(edx,1)
+
+#elif defined(_X86EMU)
+
+#include "xf86x86emu.h"
+
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/int10Defines.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size_get.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size_get.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size_get.h	(Revision 52145)
@@ -0,0 +1,93 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_SIZE_GET_H_ )
+#define _INDIRECT_SIZE_GET_H_
+
+/**
+ * \file
+ * Prototypes for functions used to determine the number of data elements in
+ * various GLX protocol messages.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#include <X11/Xfuncproto.h>
+
+#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#define PURE __attribute__((pure))
+#else
+#define PURE
+#endif
+
+#if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#define FASTCALL __attribute__((fastcall))
+#else
+#define FASTCALL
+#endif
+
+extern _X_INTERNAL PURE FASTCALL GLint __glGetBooleanv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetDoublev_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetFloatv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetIntegerv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetLightfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetLightiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetMaterialfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetMaterialiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexEnvfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexEnviv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexGendv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexGenfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexGeniv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexLevelParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetTexLevelParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetPointerv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glGetColorTableParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glGetColorTableParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glGetConvolutionParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glGetConvolutionParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetHistogramParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetHistogramParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetMinmaxParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetMinmaxParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryObjectiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryObjectuiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetQueryiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glGetProgramivARB_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glGetFramebufferAttachmentParameteriv_size(GLenum);
+
+#undef PURE
+#undef FASTCALL
+
+#endif                          /* !defined( _INDIRECT_SIZE_GET_H_ ) */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size_get.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetclientpointer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetclientpointer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetclientpointer.h	(Revision 52145)
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETCPTR_H
+#define SETCPTR_H 1
+
+int SProcXISetClientPointer(ClientPtr /* client */ );
+int ProcXISetClientPointer(ClientPtr /* client */ );
+
+#endif                          /* SETCPTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetclientpointer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-keyboard.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-keyboard.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-keyboard.h	(Revision 52145)
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux keyboard driver.  \see lnx-keyboard.c */
+
+#ifndef _LNX_KEYBOARD_H_
+#define _LNX_KEYBOARD_H_
+
+extern void *kbdLinuxCreatePrivate(DeviceIntPtr pKeyboard);
+extern void kbdLinuxDestroyPrivate(void *private);
+
+extern void kbdLinuxInit(DevicePtr pDev);
+extern void kbdLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int kbdLinuxOn(DevicePtr pDev);
+extern void kbdLinuxOff(DevicePtr pDev);
+
+extern void kbdLinuxVTPreSwitch(void *p);
+extern void kbdLinuxVTPostSwitch(void *p);
+extern int kbdLinuxVTSwitch(void *p, int vt,
+                            dmxVTSwitchReturnProcPtr switch_return,
+                            void *switch_return_data);
+
+extern void kbdLinuxRead(DevicePtr pDev,
+                         dmxMotionProcPtr motion,
+                         dmxEnqueueProcPtr enqueue,
+                         dmxCheckSpecialProcPtr checkspecial,
+                         DMXBlockType block);
+
+extern void kbdLinuxCtrl(DevicePtr pDev, KeybdCtrl * ctrl);
+extern void kbdLinuxBell(DevicePtr pDev, int percent,
+                         int volume, int pitch, int duration);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/lnx-keyboard.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvisuals.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvisuals.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvisuals.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLX_VISUALS_H
+#define _GLX_VISUALS_H
+
+int glxVisualsMatch(__GLXvisualConfig * v1, __GLXvisualConfig * v2);
+
+VisualID glxMatchGLXVisualInConfigList(__GLXvisualConfig * pGlxVisual,
+                                       __GLXvisualConfig * configs,
+                                       int nconfigs);
+
+VisualID glxMatchVisualInConfigList(ScreenPtr pScreen, VisualPtr pVisual,
+                                    __GLXvisualConfig * configs, int nconfigs);
+
+VisualPtr glxMatchVisual(ScreenPtr pScreen, VisualPtr pVisual,
+                         ScreenPtr pMatchScreen);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxvisuals.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiter.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiter.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiter.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2009 Tiago Vignatti
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __XF86VGAARBITER_H
+#define __XF86VGAARBITER_H
+
+#include "screenint.h"
+#include "misc.h"
+#include "xf86.h"
+
+/* Functions */
+extern void xf86VGAarbiterInit(void);
+extern void xf86VGAarbiterFini(void);
+void xf86VGAarbiterScrnInit(ScrnInfoPtr pScrn);
+extern Bool xf86VGAarbiterWrapFunctions(void);
+extern void xf86VGAarbiterLock(ScrnInfoPtr pScrn);
+extern void xf86VGAarbiterUnlock(ScrnInfoPtr pScrn);
+
+/* allow a driver to remove itself from arbiter - really should be
+ * done in the kernel though */
+extern _X_EXPORT void xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn, int rsrc);
+
+/* DRI and arbiter are really not possible together,
+ * you really want to remove the card from arbitration if you can */
+extern _X_EXPORT Bool xf86VGAarbiterAllowDRI(ScreenPtr pScreen);
+
+#endif                          /* __XF86VGAARBITER_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86VGAarbiter.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86PciInfo.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86PciInfo.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86PciInfo.h	(Revision 52145)
@@ -0,0 +1,732 @@
+
+/*
+ * Copyright (c) 1995-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains macros for the PCI Vendor and Device IDs for video
+ * cards plus a few other things that are needed in drivers or elsewhere.
+ * This information is used in several ways:
+ *   1. It is used by drivers and/or other code.
+ *   2. It is used by the pciid2c.pl script to determine what vendor data to
+ *      include in the pcidata module that the X server loads.
+ *   3. A side-effect of 2. affects how config-generation works for
+ *      otherwise "unknown" cards.
+ *
+ * Don't add entries here for vendors that don't make video cards,
+ * or for non-video devices unless they're needed by a driver or elsewhere.
+ * A comprehensive set of PCI vendor, device and subsystem data is
+ * auto-generated from the ../etc/pci.ids file using the pciids2c.pl script,
+ * and is used in scanpci utility.  Don't modify the pci.ids file.  If 
+ * new/corrected entries are required, add them to ../etc/extrapci.ids.
+ */
+
+#ifndef _XF86_PCIINFO_H
+#define _XF86_PCIINFO_H
+
+#warning "xf86PciInfo.h is deprecated.  For greater compatibility, drivers should include necessary PCI IDs locally rather than relying on this file from xorg-server."
+
+/* PCI Pseudo Vendor */
+#define PCI_VENDOR_GENERIC		0x00FF
+
+#define PCI_VENDOR_REAL3D		0x003D
+#define PCI_VENDOR_COMPAQ		0x0E11
+#define PCI_VENDOR_ATI			0x1002
+#define PCI_VENDOR_AVANCE		0x1005
+#define PCI_VENDOR_TSENG		0x100C
+#define PCI_VENDOR_NS			0x100B
+#define PCI_VENDOR_WEITEK		0x100E
+#define PCI_VENDOR_VIDEOLOGIC		0x1010
+#define PCI_VENDOR_DIGITAL		0x1011
+#define PCI_VENDOR_CIRRUS		0x1013
+#define PCI_VENDOR_AMD			0x1022
+#define PCI_VENDOR_TRIDENT		0x1023
+#define PCI_VENDOR_ALI			0x1025
+#define PCI_VENDOR_DELL			0x1028
+#define PCI_VENDOR_MATROX		0x102B
+#define PCI_VENDOR_CHIPSTECH		0x102C
+#define PCI_VENDOR_MIRO			0x1031
+#define PCI_VENDOR_NEC			0x1033
+#define PCI_VENDOR_SIS			0x1039
+#define PCI_VENDOR_HP			0x103C
+#define PCI_VENDOR_SGS			0x104A
+#define PCI_VENDOR_TI			0x104C
+#define PCI_VENDOR_SONY			0x104D
+#define PCI_VENDOR_OAK			0x104E
+#define PCI_VENDOR_MOTOROLA		0x1057
+#define PCI_VENDOR_NUMNINE		0x105D
+#define PCI_VENDOR_CYRIX		0x1078
+#define PCI_VENDOR_SUN			0x108E
+#define PCI_VENDOR_DIAMOND		0x1092
+#define PCI_VENDOR_BROOKTREE		0x109E
+#define PCI_VENDOR_NEOMAGIC		0x10C8
+#define PCI_VENDOR_NVIDIA		0x10DE
+#define PCI_VENDOR_IMS			0x10E0
+#define PCI_VENDOR_INTEGRAPHICS 	0x10EA
+#define PCI_VENDOR_ALLIANCE		0x1142
+#define PCI_VENDOR_RENDITION		0x1163
+#define PCI_VENDOR_3DFX			0x121A
+#define PCI_VENDOR_SMI			0x126F
+#define PCI_VENDOR_TRITECH		0x1292
+#define PCI_VENDOR_NVIDIA_SGS		0x12D2
+#define PCI_VENDOR_VMWARE		0x15AD
+#define PCI_VENDOR_AST			0x1A03
+#define PCI_VENDOR_3DLABS		0x3D3D
+#define PCI_VENDOR_AVANCE_2		0x4005
+#define PCI_VENDOR_HERCULES		0x4843
+#define PCI_VENDOR_S3			0x5333
+#define PCI_VENDOR_INTEL		0x8086
+#define PCI_VENDOR_ARK			0xEDD8
+
+/* Generic */
+#define PCI_CHIP_VGA			0x0000
+#define PCI_CHIP_8514			0x0001
+
+/* Real 3D */
+#define PCI_CHIP_I740_PCI		0x00D1
+
+/* Compaq */
+#define PCI_CHIP_QV1280			0x3033
+
+/* ATI */
+#define PCI_CHIP_RV380_3150             0x3150
+#define PCI_CHIP_RV380_3151             0x3151
+#define PCI_CHIP_RV380_3152             0x3152
+#define PCI_CHIP_RV380_3153             0x3153
+#define PCI_CHIP_RV380_3154             0x3154
+#define PCI_CHIP_RV380_3156             0x3156
+#define PCI_CHIP_RV380_3E50             0x3E50
+#define PCI_CHIP_RV380_3E51             0x3E51
+#define PCI_CHIP_RV380_3E52             0x3E52
+#define PCI_CHIP_RV380_3E53             0x3E53
+#define PCI_CHIP_RV380_3E54             0x3E54
+#define PCI_CHIP_RV380_3E56             0x3E56
+#define PCI_CHIP_RS100_4136		0x4136
+#define PCI_CHIP_RS200_4137		0x4137
+#define PCI_CHIP_R300_AD		0x4144
+#define PCI_CHIP_R300_AE		0x4145
+#define PCI_CHIP_R300_AF		0x4146
+#define PCI_CHIP_R300_AG		0x4147
+#define PCI_CHIP_R350_AH                0x4148
+#define PCI_CHIP_R350_AI                0x4149
+#define PCI_CHIP_R350_AJ                0x414A
+#define PCI_CHIP_R350_AK                0x414B
+#define PCI_CHIP_RV350_AP               0x4150
+#define PCI_CHIP_RV350_AQ               0x4151
+#define PCI_CHIP_RV360_AR               0x4152
+#define PCI_CHIP_RV350_AS               0x4153
+#define PCI_CHIP_RV350_AT               0x4154
+#define PCI_CHIP_RV350_4155             0x4155
+#define PCI_CHIP_RV350_AV               0x4156
+#define PCI_CHIP_MACH32			0x4158
+#define PCI_CHIP_RS250_4237		0x4237
+#define PCI_CHIP_R200_BB		0x4242
+#define PCI_CHIP_R200_BC		0x4243
+#define PCI_CHIP_RS100_4336		0x4336
+#define PCI_CHIP_RS200_4337		0x4337
+#define PCI_CHIP_MACH64CT		0x4354
+#define PCI_CHIP_MACH64CX		0x4358
+#define PCI_CHIP_RS250_4437		0x4437
+#define PCI_CHIP_MACH64ET		0x4554
+#define PCI_CHIP_MACH64GB		0x4742
+#define PCI_CHIP_MACH64GD		0x4744
+#define PCI_CHIP_MACH64GI		0x4749
+#define PCI_CHIP_MACH64GL		0x474C
+#define PCI_CHIP_MACH64GM		0x474D
+#define PCI_CHIP_MACH64GN		0x474E
+#define PCI_CHIP_MACH64GO		0x474F
+#define PCI_CHIP_MACH64GP		0x4750
+#define PCI_CHIP_MACH64GQ		0x4751
+#define PCI_CHIP_MACH64GR		0x4752
+#define PCI_CHIP_MACH64GS		0x4753
+#define PCI_CHIP_MACH64GT		0x4754
+#define PCI_CHIP_MACH64GU		0x4755
+#define PCI_CHIP_MACH64GV		0x4756
+#define PCI_CHIP_MACH64GW		0x4757
+#define PCI_CHIP_MACH64GX		0x4758
+#define PCI_CHIP_MACH64GY		0x4759
+#define PCI_CHIP_MACH64GZ		0x475A
+#define PCI_CHIP_RV250_Id		0x4964
+#define PCI_CHIP_RV250_Ie		0x4965
+#define PCI_CHIP_RV250_If		0x4966
+#define PCI_CHIP_RV250_Ig		0x4967
+#define PCI_CHIP_R420_JH                0x4A48
+#define PCI_CHIP_R420_JI                0x4A49
+#define PCI_CHIP_R420_JJ                0x4A4A
+#define PCI_CHIP_R420_JK                0x4A4B
+#define PCI_CHIP_R420_JL                0x4A4C
+#define PCI_CHIP_R420_JM                0x4A4D
+#define PCI_CHIP_R420_JN                0x4A4E
+#define PCI_CHIP_R420_4A4F              0x4A4F
+#define PCI_CHIP_R420_JP                0x4A50
+#define PCI_CHIP_R420_4A54              0x4A54
+#define PCI_CHIP_R481_4B49              0x4B49
+#define PCI_CHIP_R481_4B4A              0x4B4A
+#define PCI_CHIP_R481_4B4B              0x4B4B
+#define PCI_CHIP_R481_4B4C              0x4B4C
+#define PCI_CHIP_MACH64LB		0x4C42
+#define PCI_CHIP_MACH64LD		0x4C44
+#define PCI_CHIP_RAGE128LE		0x4C45
+#define PCI_CHIP_RAGE128LF		0x4C46
+#define PCI_CHIP_MACH64LG		0x4C47
+#define PCI_CHIP_MACH64LI		0x4C49
+#define PCI_CHIP_MACH64LM		0x4C4D
+#define PCI_CHIP_MACH64LN		0x4C4E
+#define PCI_CHIP_MACH64LP		0x4C50
+#define PCI_CHIP_MACH64LQ		0x4C51
+#define PCI_CHIP_MACH64LR		0x4C52
+#define PCI_CHIP_MACH64LS		0x4C53
+#define PCI_CHIP_RADEON_LW		0x4C57
+#define PCI_CHIP_RADEON_LX		0x4C58
+#define PCI_CHIP_RADEON_LY		0x4C59
+#define PCI_CHIP_RADEON_LZ		0x4C5A
+#define PCI_CHIP_RV250_Ld		0x4C64
+#define PCI_CHIP_RV250_Le		0x4C65
+#define PCI_CHIP_RV250_Lf		0x4C66
+#define PCI_CHIP_RV250_Lg		0x4C67
+#define PCI_CHIP_RV250_Ln		0x4C6E
+#define PCI_CHIP_RAGE128MF		0x4D46
+#define PCI_CHIP_RAGE128ML		0x4D4C
+#define PCI_CHIP_R300_ND		0x4E44
+#define PCI_CHIP_R300_NE		0x4E45
+#define PCI_CHIP_R300_NF		0x4E46
+#define PCI_CHIP_R300_NG		0x4E47
+#define PCI_CHIP_R350_NH                0x4E48
+#define PCI_CHIP_R350_NI                0x4E49
+#define PCI_CHIP_R360_NJ                0x4E4A
+#define PCI_CHIP_R350_NK                0x4E4B
+#define PCI_CHIP_RV350_NP               0x4E50
+#define PCI_CHIP_RV350_NQ               0x4E51
+#define PCI_CHIP_RV350_NR               0x4E52
+#define PCI_CHIP_RV350_NS               0x4E53
+#define PCI_CHIP_RV350_NT               0x4E54
+#define PCI_CHIP_RV350_NV               0x4E56
+#define PCI_CHIP_RAGE128PA		0x5041
+#define PCI_CHIP_RAGE128PB		0x5042
+#define PCI_CHIP_RAGE128PC		0x5043
+#define PCI_CHIP_RAGE128PD		0x5044
+#define PCI_CHIP_RAGE128PE		0x5045
+#define PCI_CHIP_RAGE128PF		0x5046
+#define PCI_CHIP_RAGE128PG		0x5047
+#define PCI_CHIP_RAGE128PH		0x5048
+#define PCI_CHIP_RAGE128PI		0x5049
+#define PCI_CHIP_RAGE128PJ		0x504A
+#define PCI_CHIP_RAGE128PK		0x504B
+#define PCI_CHIP_RAGE128PL		0x504C
+#define PCI_CHIP_RAGE128PM		0x504D
+#define PCI_CHIP_RAGE128PN		0x504E
+#define PCI_CHIP_RAGE128PO		0x504F
+#define PCI_CHIP_RAGE128PP		0x5050
+#define PCI_CHIP_RAGE128PQ		0x5051
+#define PCI_CHIP_RAGE128PR		0x5052
+#define PCI_CHIP_RAGE128PS		0x5053
+#define PCI_CHIP_RAGE128PT		0x5054
+#define PCI_CHIP_RAGE128PU		0x5055
+#define PCI_CHIP_RAGE128PV		0x5056
+#define PCI_CHIP_RAGE128PW		0x5057
+#define PCI_CHIP_RAGE128PX		0x5058
+#define PCI_CHIP_RADEON_QD		0x5144
+#define PCI_CHIP_RADEON_QE		0x5145
+#define PCI_CHIP_RADEON_QF		0x5146
+#define PCI_CHIP_RADEON_QG		0x5147
+#define PCI_CHIP_R200_QH		0x5148
+#define PCI_CHIP_R200_QI		0x5149
+#define PCI_CHIP_R200_QJ		0x514A
+#define PCI_CHIP_R200_QK		0x514B
+#define PCI_CHIP_R200_QL		0x514C
+#define PCI_CHIP_R200_QM		0x514D
+#define PCI_CHIP_R200_QN		0x514E
+#define PCI_CHIP_R200_QO		0x514F
+#define PCI_CHIP_RV200_QW		0x5157
+#define PCI_CHIP_RV200_QX		0x5158
+#define PCI_CHIP_RV100_QY		0x5159
+#define PCI_CHIP_RV100_QZ		0x515A
+#define PCI_CHIP_RN50_515E		0x515E
+#define PCI_CHIP_RAGE128RE		0x5245
+#define PCI_CHIP_RAGE128RF		0x5246
+#define PCI_CHIP_RAGE128RG		0x5247
+#define PCI_CHIP_RAGE128RK		0x524B
+#define PCI_CHIP_RAGE128RL		0x524C
+#define PCI_CHIP_RAGE128SE		0x5345
+#define PCI_CHIP_RAGE128SF		0x5346
+#define PCI_CHIP_RAGE128SG		0x5347
+#define PCI_CHIP_RAGE128SH		0x5348
+#define PCI_CHIP_RAGE128SK		0x534B
+#define PCI_CHIP_RAGE128SL		0x534C
+#define PCI_CHIP_RAGE128SM		0x534D
+#define PCI_CHIP_RAGE128SN		0x534E
+#define PCI_CHIP_RAGE128TF		0x5446
+#define PCI_CHIP_RAGE128TL		0x544C
+#define PCI_CHIP_RAGE128TR		0x5452
+#define PCI_CHIP_RAGE128TS		0x5453
+#define PCI_CHIP_RAGE128TT		0x5454
+#define PCI_CHIP_RAGE128TU		0x5455
+#define PCI_CHIP_RV370_5460             0x5460
+#define PCI_CHIP_RV370_5461             0x5461
+#define PCI_CHIP_RV370_5462             0x5462
+#define PCI_CHIP_RV370_5463             0x5463
+#define PCI_CHIP_RV370_5464             0x5464
+#define PCI_CHIP_RV370_5465             0x5465
+#define PCI_CHIP_RV370_5466             0x5466
+#define PCI_CHIP_RV370_5467             0x5467
+#define PCI_CHIP_R423_UH                0x5548
+#define PCI_CHIP_R423_UI                0x5549
+#define PCI_CHIP_R423_UJ                0x554A
+#define PCI_CHIP_R423_UK                0x554B
+#define PCI_CHIP_R430_554C              0x554C
+#define PCI_CHIP_R430_554D              0x554D
+#define PCI_CHIP_R430_554E              0x554E
+#define PCI_CHIP_R430_554F              0x554F
+#define PCI_CHIP_R423_5550              0x5550
+#define PCI_CHIP_R423_UQ                0x5551
+#define PCI_CHIP_R423_UR                0x5552
+#define PCI_CHIP_R423_UT                0x5554
+#define PCI_CHIP_RV410_564A             0x564A
+#define PCI_CHIP_RV410_564B             0x564B
+#define PCI_CHIP_RV410_564F             0x564F
+#define PCI_CHIP_RV410_5652             0x5652
+#define PCI_CHIP_RV410_5653             0x5653
+#define PCI_CHIP_MACH64VT		0x5654
+#define PCI_CHIP_MACH64VU		0x5655
+#define PCI_CHIP_MACH64VV		0x5656
+#define PCI_CHIP_RS300_5834		0x5834
+#define PCI_CHIP_RS300_5835		0x5835
+#define PCI_CHIP_RS300_5836		0x5836
+#define PCI_CHIP_RS300_5837		0x5837
+#define PCI_CHIP_RS480_5954             0x5954
+#define PCI_CHIP_RS480_5955             0x5955
+#define PCI_CHIP_RV280_5960		0x5960
+#define PCI_CHIP_RV280_5961		0x5961
+#define PCI_CHIP_RV280_5962		0x5962
+#define PCI_CHIP_RV280_5964		0x5964
+#define PCI_CHIP_RV280_5965 		0x5965
+#define PCI_CHIP_RN50_5969		0x5969
+#define PCI_CHIP_RS482_5974             0x5974
+#define PCI_CHIP_RS482_5975             0x5975
+#define PCI_CHIP_RS400_5A41             0x5A41
+#define PCI_CHIP_RS400_5A42             0x5A42
+#define PCI_CHIP_RC410_5A61             0x5A61
+#define PCI_CHIP_RC410_5A62             0x5A62
+#define PCI_CHIP_RV370_5B60             0x5B60
+#define PCI_CHIP_RV370_5B61             0x5B61
+#define PCI_CHIP_RV370_5B62             0x5B62
+#define PCI_CHIP_RV370_5B63             0x5B63
+#define PCI_CHIP_RV370_5B64             0x5B64
+#define PCI_CHIP_RV370_5B65             0x5B65
+#define PCI_CHIP_RV370_5B66             0x5B66
+#define PCI_CHIP_RV370_5B67             0x5B67
+#define PCI_CHIP_RV280_5C61		0x5C61
+#define PCI_CHIP_RV280_5C63		0x5C63
+#define PCI_CHIP_R430_5D48              0x5D48
+#define PCI_CHIP_R430_5D49              0x5D49
+#define PCI_CHIP_R430_5D4A              0x5D4A
+#define PCI_CHIP_R480_5D4C              0x5D4C
+#define PCI_CHIP_R480_5D4D              0x5D4D
+#define PCI_CHIP_R480_5D4E              0x5D4E
+#define PCI_CHIP_R480_5D4F              0x5D4F
+#define PCI_CHIP_R480_5D50              0x5D50
+#define PCI_CHIP_R480_5D52              0x5D52
+#define PCI_CHIP_R423_5D57              0x5D57
+#define PCI_CHIP_RV410_5E48             0x5E48
+#define PCI_CHIP_RV410_5E4A             0x5E4A
+#define PCI_CHIP_RV410_5E4B             0x5E4B
+#define PCI_CHIP_RV410_5E4C             0x5E4C
+#define PCI_CHIP_RV410_5E4D             0x5E4D
+#define PCI_CHIP_RV410_5E4F             0x5E4F
+#define PCI_CHIP_RS350_7834             0x7834
+#define PCI_CHIP_RS350_7835             0x7835
+
+/* ASPEED Technology (AST) */
+#define PCI_CHIP_AST2000		0x2000
+
+/* Avance Logic */
+#define PCI_CHIP_ALG2064		0x2064
+#define PCI_CHIP_ALG2301		0x2301
+#define PCI_CHIP_ALG2501		0x2501
+
+/* Tseng */
+#define PCI_CHIP_ET4000_W32P_A		0x3202
+#define PCI_CHIP_ET4000_W32P_B		0x3205
+#define PCI_CHIP_ET4000_W32P_D		0x3206
+#define PCI_CHIP_ET4000_W32P_C		0x3207
+#define PCI_CHIP_ET6000			0x3208
+#define PCI_CHIP_ET6300			0x4702
+
+/* Weitek */
+#define PCI_CHIP_P9000			0x9001
+#define PCI_CHIP_P9100			0x9100
+
+/* Digital */
+#define PCI_CHIP_DC21050		0x0001
+#define PCI_CHIP_DEC21030		0x0004
+#define PCI_CHIP_TGA2			0x000D
+
+/* Cirrus Logic */
+#define PCI_CHIP_GD7548			0x0038
+#define PCI_CHIP_GD7555			0x0040
+#define PCI_CHIP_GD5430			0x00A0
+#define PCI_CHIP_GD5434_4		0x00A4
+#define PCI_CHIP_GD5434_8		0x00A8
+#define PCI_CHIP_GD5436			0x00AC
+#define PCI_CHIP_GD5446			0x00B8
+#define PCI_CHIP_GD5480			0x00BC
+#define PCI_CHIP_GD5462			0x00D0
+#define PCI_CHIP_GD5464			0x00D4
+#define PCI_CHIP_GD5464BD		0x00D5
+#define PCI_CHIP_GD5465			0x00D6
+#define PCI_CHIP_6729			0x1100
+#define PCI_CHIP_6832			0x1110
+#define PCI_CHIP_GD7542			0x1200
+#define PCI_CHIP_GD7543			0x1202
+#define PCI_CHIP_GD7541			0x1204
+
+/* AMD */
+#define PCI_CHIP_AMD761			0x700E
+
+/* Trident */
+#define PCI_CHIP_2100			0x2100
+#define PCI_CHIP_8400			0x8400
+#define PCI_CHIP_8420			0x8420
+#define PCI_CHIP_8500			0x8500
+#define PCI_CHIP_8520			0x8520
+#define PCI_CHIP_8600			0x8600
+#define PCI_CHIP_8620			0x8620
+#define PCI_CHIP_8820			0x8820
+#define PCI_CHIP_9320			0x9320
+#define PCI_CHIP_9388			0x9388
+#define PCI_CHIP_9397			0x9397
+#define PCI_CHIP_939A			0x939A
+#define PCI_CHIP_9420			0x9420
+#define PCI_CHIP_9440			0x9440
+#define PCI_CHIP_9520			0x9520
+#define PCI_CHIP_9525			0x9525
+#define PCI_CHIP_9540			0x9540
+#define PCI_CHIP_9660			0x9660
+#define PCI_CHIP_9750			0x9750
+#define PCI_CHIP_9850			0x9850
+#define PCI_CHIP_9880			0x9880
+#define PCI_CHIP_9910			0x9910
+
+/* ALI */
+#define PCI_CHIP_M1435			0x1435
+
+/* Matrox */
+#define PCI_CHIP_MGA2085		0x0518
+#define PCI_CHIP_MGA2064		0x0519
+#define PCI_CHIP_MGA1064		0x051A
+#define PCI_CHIP_MGA2164		0x051B
+#define PCI_CHIP_MGA2164_AGP		0x051F
+#define PCI_CHIP_MGAG200_PCI		0x0520
+#define PCI_CHIP_MGAG200		0x0521
+#define PCI_CHIP_MGAG400		0x0525
+#define PCI_CHIP_MGAG550		0x2527
+#define PCI_CHIP_IMPRESSION		0x0D10
+#define PCI_CHIP_MGAG100_PCI		0x1000
+#define PCI_CHIP_MGAG100		0x1001
+
+#define PCI_CARD_G400_TH		0x2179
+#define PCI_CARD_MILL_G200_SD		0xFF00
+#define PCI_CARD_PROD_G100_SD		0xFF01
+#define PCI_CARD_MYST_G200_SD		0xFF02
+#define PCI_CARD_MILL_G200_SG		0xFF03
+#define PCI_CARD_MARV_G200_SD		0xFF04
+
+/* Chips & Tech */
+#define PCI_CHIP_65545			0x00D8
+#define PCI_CHIP_65548			0x00DC
+#define PCI_CHIP_65550			0x00E0
+#define PCI_CHIP_65554			0x00E4
+#define PCI_CHIP_65555			0x00E5
+#define PCI_CHIP_68554			0x00F4
+#define PCI_CHIP_69000			0x00C0
+#define PCI_CHIP_69030			0x0C30
+
+/* Miro */
+#define PCI_CHIP_ZR36050		0x5601
+
+/* NEC */
+#define PCI_CHIP_POWER_VR		0x0046
+
+/* SiS */
+#define PCI_CHIP_SG86C201		0x0001
+#define PCI_CHIP_SG86C202		0x0002
+#define PCI_CHIP_SG85C503		0x0008
+#define PCI_CHIP_SIS5597		0x0200
+/* Agregado por Carlos Duclos & Manuel Jander */
+#define PCI_CHIP_SIS82C204		0x0204
+#define PCI_CHIP_SG86C205		0x0205
+#define PCI_CHIP_SG86C215		0x0215
+#define PCI_CHIP_SG86C225		0x0225
+#define PCI_CHIP_85C501			0x0406
+#define PCI_CHIP_85C496			0x0496
+#define PCI_CHIP_85C601			0x0601
+#define PCI_CHIP_85C5107		0x5107
+#define PCI_CHIP_85C5511		0x5511
+#define PCI_CHIP_85C5513		0x5513
+#define PCI_CHIP_SIS5571		0x5571
+#define PCI_CHIP_SIS5597_2		0x5597
+#define PCI_CHIP_SIS530			0x6306
+#define PCI_CHIP_SIS6326		0x6326
+#define PCI_CHIP_SIS7001		0x7001
+#define PCI_CHIP_SIS300			0x0300
+#define PCI_CHIP_SIS315H		0x0310
+#define PCI_CHIP_SIS315PRO		0x0325
+#define PCI_CHIP_SIS330			0x0330
+#define PCI_CHIP_SIS630			0x6300
+#define PCI_CHIP_SIS540			0x5300
+#define PCI_CHIP_SIS550			0x5315
+#define PCI_CHIP_SIS650			0x6325
+#define PCI_CHIP_SIS730			0x7300
+
+/* Hewlett-Packard */
+#define PCI_CHIP_ELROY			0x1054
+#define PCI_CHIP_ZX1_SBA		0x1229
+#define PCI_CHIP_ZX1_IOC		0x122A
+#define PCI_CHIP_ZX1_LBA		0x122E  /* a.k.a. Mercury */
+#define PCI_CHIP_ZX1_AGP8		0x12B4  /* a.k.a. QuickSilver */
+#define PCI_CHIP_ZX2_LBA		0x12EE
+#define PCI_CHIP_ZX2_SBA		0x4030
+#define PCI_CHIP_ZX2_IOC		0x4031
+#define PCI_CHIP_ZX2_PCIE		0x4037
+
+/* SGS */
+#define PCI_CHIP_STG2000		0x0008
+#define PCI_CHIP_STG1764		0x0009
+#define PCI_CHIP_KYROII			0x0010
+
+/* Texas Instruments */
+#define PCI_CHIP_TI_PERMEDIA		0x3D04
+#define PCI_CHIP_TI_PERMEDIA2		0x3D07
+
+/* Oak */
+#define PCI_CHIP_OTI107			0x0107
+
+/* Number Nine */
+#define PCI_CHIP_I128			0x2309
+#define PCI_CHIP_I128_2			0x2339
+#define PCI_CHIP_I128_T2R		0x493D
+#define PCI_CHIP_I128_T2R4		0x5348
+
+/* Sun */
+#define PCI_CHIP_EBUS			0x1000
+#define PCI_CHIP_HAPPY_MEAL		0x1001
+#define PCI_CHIP_SIMBA			0x5000
+#define PCI_CHIP_PSYCHO			0x8000
+#define PCI_CHIP_SCHIZO			0x8001
+#define PCI_CHIP_SABRE			0xA000
+#define PCI_CHIP_HUMMINGBIRD		0xA001
+
+/* BrookTree */
+#define PCI_CHIP_BT848			0x0350
+#define PCI_CHIP_BT849			0x0351
+
+/* NVIDIA */
+#define PCI_CHIP_NV1			0x0008
+#define PCI_CHIP_DAC64			0x0009
+#define PCI_CHIP_TNT			0x0020
+#define PCI_CHIP_TNT2			0x0028
+#define PCI_CHIP_UTNT2			0x0029
+#define PCI_CHIP_VTNT2			0x002C
+#define PCI_CHIP_UVTNT2			0x002D
+#define PCI_CHIP_ITNT2			0x00A0
+#define PCI_CHIP_GEFORCE_256		0x0100
+#define PCI_CHIP_GEFORCE_DDR		0x0101
+#define PCI_CHIP_QUADRO			0x0103
+#define PCI_CHIP_GEFORCE2_MX		0x0110
+#define PCI_CHIP_GEFORCE2_MX_100	0x0111
+#define PCI_CHIP_GEFORCE2_GO		0x0112
+#define PCI_CHIP_QUADRO2_MXR		0x0113
+#define PCI_CHIP_GEFORCE2_GTS		0x0150
+#define PCI_CHIP_GEFORCE2_TI		0x0151
+#define PCI_CHIP_GEFORCE2_ULTRA		0x0152
+#define PCI_CHIP_QUADRO2_PRO		0x0153
+#define PCI_CHIP_GEFORCE4_MX_460	0x0170
+#define PCI_CHIP_GEFORCE4_MX_440	0x0171
+#define PCI_CHIP_GEFORCE4_MX_420	0x0172
+#define PCI_CHIP_GEFORCE4_440_GO	0x0174
+#define PCI_CHIP_GEFORCE4_420_GO	0x0175
+#define PCI_CHIP_GEFORCE4_420_GO_M32	0x0176
+#define PCI_CHIP_QUADRO4_500XGL		0x0178
+#define PCI_CHIP_GEFORCE4_440_GO_M64	0x0179
+#define PCI_CHIP_QUADRO4_200		0x017A
+#define PCI_CHIP_QUADRO4_550XGL		0x017B
+#define PCI_CHIP_QUADRO4_500_GOGL	0x017C
+#define PCI_CHIP_IGEFORCE2		0x01A0
+#define PCI_CHIP_GEFORCE3		0x0200
+#define PCI_CHIP_GEFORCE3_TI_200	0x0201
+#define PCI_CHIP_GEFORCE3_TI_500	0x0202
+#define PCI_CHIP_QUADRO_DCC		0x0203
+#define PCI_CHIP_GEFORCE4_TI_4600	0x0250
+#define PCI_CHIP_GEFORCE4_TI_4400	0x0251
+#define PCI_CHIP_GEFORCE4_TI_4200	0x0253
+#define PCI_CHIP_QUADRO4_900XGL		0x0258
+#define PCI_CHIP_QUADRO4_750XGL		0x0259
+#define PCI_CHIP_QUADRO4_700XGL		0x025B
+
+/* NVIDIA & SGS */
+#define PCI_CHIP_RIVA128		0x0018
+
+/* IMS */
+#define PCI_CHIP_IMSTT128		0x9128
+#define PCI_CHIP_IMSTT3D		0x9135
+
+/* Alliance Semiconductor */
+#define PCI_CHIP_AP6410			0x3210
+#define PCI_CHIP_AP6422			0x6422
+#define PCI_CHIP_AT24			0x6424
+#define PCI_CHIP_AT3D			0x643D
+
+/* 3dfx Interactive */
+#define PCI_CHIP_VOODOO_GRAPHICS	0x0001
+#define PCI_CHIP_VOODOO2		0x0002
+#define PCI_CHIP_BANSHEE		0x0003
+#define PCI_CHIP_VOODOO3		0x0005
+#define PCI_CHIP_VOODOO5		0x0009
+
+#define PCI_CARD_VOODOO3_2000		0x0036
+#define PCI_CARD_VOODOO3_3000		0x003A
+
+/* Rendition */
+#define PCI_CHIP_V1000			0x0001
+#define PCI_CHIP_V2x00			0x2000
+
+/* 3Dlabs */
+#define PCI_CHIP_300SX			0x0001
+#define PCI_CHIP_500TX			0x0002
+#define PCI_CHIP_DELTA			0x0003
+#define PCI_CHIP_PERMEDIA		0x0004
+#define PCI_CHIP_MX			0x0006
+#define PCI_CHIP_PERMEDIA2		0x0007
+#define PCI_CHIP_GAMMA			0x0008
+#define PCI_CHIP_PERMEDIA2V		0x0009
+#define PCI_CHIP_PERMEDIA3		0x000A
+#define PCI_CHIP_PERMEDIA4		0x000C
+#define PCI_CHIP_R4			0x000D
+#define PCI_CHIP_GAMMA2			0x000E
+#define PCI_CHIP_R4ALT			0x0011
+
+/* S3 */
+#define PCI_CHIP_PLATO			0x0551
+#define PCI_CHIP_VIRGE			0x5631
+#define PCI_CHIP_TRIO			0x8811
+#define PCI_CHIP_AURORA64VP		0x8812
+#define PCI_CHIP_TRIO64UVP		0x8814
+#define PCI_CHIP_VIRGE_VX		0x883D
+#define PCI_CHIP_868			0x8880
+#define PCI_CHIP_928			0x88B0
+#define PCI_CHIP_864_0			0x88C0
+#define PCI_CHIP_864_1			0x88C1
+#define PCI_CHIP_964_0			0x88D0
+#define PCI_CHIP_964_1			0x88D1
+#define PCI_CHIP_968			0x88F0
+#define PCI_CHIP_TRIO64V2_DXGX		0x8901
+#define PCI_CHIP_PLATO_PX		0x8902
+#define PCI_CHIP_Trio3D			0x8904
+#define PCI_CHIP_VIRGE_DXGX		0x8A01
+#define PCI_CHIP_VIRGE_GX2		0x8A10
+#define PCI_CHIP_Trio3D_2X		0x8A13
+#define PCI_CHIP_SAVAGE3D		0x8A20
+#define PCI_CHIP_SAVAGE3D_MV		0x8A21
+#define PCI_CHIP_SAVAGE4		0x8A22
+#define PCI_CHIP_PROSAVAGE_PM		0x8A25
+#define PCI_CHIP_PROSAVAGE_KM		0x8A26
+#define PCI_CHIP_VIRGE_MX		0x8C01
+#define PCI_CHIP_VIRGE_MXPLUS		0x8C02
+#define PCI_CHIP_VIRGE_MXP		0x8C03
+#define PCI_CHIP_SAVAGE_MX_MV		0x8C10
+#define PCI_CHIP_SAVAGE_MX		0x8C11
+#define PCI_CHIP_SAVAGE_IX_MV		0x8C12
+#define PCI_CHIP_SAVAGE_IX		0x8C13
+#define PCI_CHIP_SUPSAV_MX128		0x8C22
+#define PCI_CHIP_SUPSAV_MX64		0x8C24
+#define PCI_CHIP_SUPSAV_MX64C		0x8C26
+#define PCI_CHIP_SUPSAV_IX128SDR	0x8C2A
+#define PCI_CHIP_SUPSAV_IX128DDR	0x8C2B
+#define PCI_CHIP_SUPSAV_IX64SDR		0x8C2C
+#define PCI_CHIP_SUPSAV_IX64DDR		0x8C2D
+#define PCI_CHIP_SUPSAV_IXCSDR		0x8C2E
+#define PCI_CHIP_SUPSAV_IXCDDR		0x8C2F
+#define PCI_CHIP_S3TWISTER_P		0x8D01
+#define PCI_CHIP_S3TWISTER_K		0x8D02
+#define PCI_CHIP_PROSAVAGE_DDR		0x8D03
+#define PCI_CHIP_PROSAVAGE_DDRK		0x8D04
+#define PCI_CHIP_SAVAGE2000		0x9102
+
+/* ARK Logic */
+#define PCI_CHIP_1000PV			0xA091
+#define PCI_CHIP_2000PV			0xA099
+#define PCI_CHIP_2000MT			0xA0A1
+#define PCI_CHIP_2000MI			0xA0A9
+
+/* Tritech Microelectronics */
+#define PCI_CHIP_TR25202		0xFC02
+
+/* Neomagic */
+#define PCI_CHIP_NM2070			0x0001
+#define PCI_CHIP_NM2090			0x0002
+#define PCI_CHIP_NM2093			0x0003
+#define PCI_CHIP_NM2097			0x0083
+#define PCI_CHIP_NM2160			0x0004
+#define PCI_CHIP_NM2200			0x0005
+#define PCI_CHIP_NM2230			0x0025
+#define PCI_CHIP_NM2360			0x0006
+#define PCI_CHIP_NM2380			0x0016
+
+/* Intel */
+#define PCI_CHIP_I815_BRIDGE		0x1130
+#define PCI_CHIP_I815			0x1132
+#define PCI_CHIP_82801_P2P		0x244E
+#define PCI_CHIP_845_G_BRIDGE		0x2560
+#define PCI_CHIP_845_G			0x2562
+#define PCI_CHIP_I830_M_BRIDGE		0x3575
+#define PCI_CHIP_I830_M			0x3577
+#define PCI_CHIP_I810_BRIDGE		0x7120
+#define PCI_CHIP_I810			0x7121
+#define PCI_CHIP_I810_DC100_BRIDGE	0x7122
+#define PCI_CHIP_I810_DC100		0x7123
+#define PCI_CHIP_I810_E_BRIDGE		0x7124
+#define PCI_CHIP_I810_E			0x7125
+#define PCI_CHIP_I740_AGP		0x7800
+#define PCI_CHIP_460GX_PXB		0x84CB
+#define PCI_CHIP_460GX_SAC		0x84E0
+#define PCI_CHIP_460GX_GXB_2		0x84E2  /* PCI function 2 */
+#define PCI_CHIP_460GX_WXB		0x84E6
+#define PCI_CHIP_460GX_GXB_1		0x84EA  /* PCI function 1 */
+
+/* Silicon Motion Inc. */
+#define PCI_CHIP_SMI910			0x0910
+#define PCI_CHIP_SMI810			0x0810
+#define PCI_CHIP_SMI820			0x0820
+#define PCI_CHIP_SMI710			0x0710
+#define PCI_CHIP_SMI712			0x0712
+#define PCI_CHIP_SMI720			0x0720
+#define PCI_CHIP_SMI731			0x0730
+
+/* VMware */
+#define PCI_CHIP_VMWARE0405		0x0405
+#define PCI_CHIP_VMWARE0710		0x0710
+
+#endif                          /* _XF86_PCIINFO_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86PciInfo.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Axp.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Axp.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Axp.h	(Revision 52145)
@@ -0,0 +1,33 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_AXP_H_
+#define _XF86_AXP_H_
+
+typedef enum {
+    SYS_NONE,
+    TSUNAMI,
+    LCA,
+    APECS,
+    T2,
+    T2_GAMMA,
+    CIA,
+    MCPCIA,
+    JENSEN,
+    POLARIS,
+    PYXIS,
+    PYXIS_CIA,
+    IRONGATE
+} axpDevice;
+
+typedef struct {
+    axpDevice id;
+    unsigned long hae_thresh;
+    unsigned long hae_mask;
+    unsigned long size;
+} axpParams;
+
+extern axpParams xf86AXPParams[];
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Axp.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_font.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_font.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_font.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+ * Copyright ¬© 2014 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _GLAMOR_FONT_H_
+#define _GLAMOR_FONT_H_
+
+typedef struct {
+    Bool        realized;
+    CharInfoPtr default_char;
+    CARD8       default_row;
+    CARD8       default_col;
+
+    GLuint      texture_id;
+
+    CARD16      glyph_width_bytes;
+    CARD16      glyph_width_pixels;
+    CARD16      glyph_height;
+
+} glamor_font_t;
+
+glamor_font_t *
+glamor_font_get(ScreenPtr screen, FontPtr font);
+
+Bool
+glamor_font_init(ScreenPtr screen);
+
+void
+glamor_fini_glyph_shader(ScreenPtr screen);
+
+#endif /* _GLAMOR_FONT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_font.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpict.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpict.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpict.h	(Revision 52145)
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ *  This file provides access to the externally visible RENDER support
+ *  functions, global variables and macros for DMX.
+ *  
+ *  FIXME: Move function definitions for non-externally visible function
+ *  to .c file. */
+
+#ifndef DMXPICT_H
+#define DMXPICT_H
+
+/** Picture private structure */
+typedef struct _dmxPictPriv {
+    Picture pict;               /**< Picture ID from back-end server */
+    Mask savedMask;             /**< Mask of picture attributes saved for
+				 *   lazy window creation. */
+} dmxPictPrivRec, *dmxPictPrivPtr;
+
+/** Glyph Set private structure */
+typedef struct _dmxGlyphPriv {
+    GlyphSet *glyphSets;  /**< Glyph Set IDs from back-end server */
+} dmxGlyphPrivRec, *dmxGlyphPrivPtr;
+
+extern void dmxInitRender(void);
+extern void dmxResetRender(void);
+
+extern Bool dmxPictureInit(ScreenPtr pScreen,
+                           PictFormatPtr formats, int nformats);
+
+extern void dmxCreatePictureList(WindowPtr pWindow);
+extern Bool dmxDestroyPictureList(WindowPtr pWindow);
+
+extern int dmxCreatePicture(PicturePtr pPicture);
+extern void dmxDestroyPicture(PicturePtr pPicture);
+extern int dmxChangePictureClip(PicturePtr pPicture, int clipType,
+                                void *value, int n);
+extern void dmxDestroyPictureClip(PicturePtr pPicture);
+extern void dmxChangePicture(PicturePtr pPicture, Mask mask);
+extern void dmxValidatePicture(PicturePtr pPicture, Mask mask);
+extern void dmxComposite(CARD8 op,
+                         PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
+                         INT16 xSrc, INT16 ySrc,
+                         INT16 xMask, INT16 yMask,
+                         INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+extern void dmxGlyphs(CARD8 op,
+                      PicturePtr pSrc, PicturePtr pDst,
+                      PictFormatPtr maskFormat,
+                      INT16 xSrc, INT16 ySrc,
+                      int nlists, GlyphListPtr lists, GlyphPtr * glyphs);
+extern void dmxCompositeRects(CARD8 op,
+                              PicturePtr pDst,
+                              xRenderColor * color,
+                              int nRect, xRectangle *rects);
+extern Bool dmxInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+extern void dmxCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+extern void dmxUpdateIndexed(ScreenPtr pScreen, PictFormatPtr pFormat,
+                             int ndef, xColorItem * pdef);
+extern void dmxTrapezoids(CARD8 op,
+                          PicturePtr pSrc, PicturePtr pDst,
+                          PictFormatPtr maskFormat,
+                          INT16 xSrc, INT16 ySrc,
+                          int ntrap, xTrapezoid * traps);
+extern void dmxTriangles(CARD8 op,
+                         PicturePtr pSrc, PicturePtr pDst,
+                         PictFormatPtr maskFormat,
+                         INT16 xSrc, INT16 ySrc, int ntri, xTriangle * tris);
+
+extern int dmxBECreateGlyphSet(int idx, GlyphSetPtr glyphSet);
+extern Bool dmxBEFreeGlyphSet(ScreenPtr pScreen, GlyphSetPtr glyphSet);
+extern int dmxBECreatePicture(PicturePtr pPicture);
+extern Bool dmxBEFreePicture(PicturePtr pPicture);
+
+/** Get the picture private data given a picture pointer */
+#define DMX_GET_PICT_PRIV(_pPict)					\
+    (dmxPictPrivPtr)dixLookupPrivate(&(_pPict)->devPrivates, dmxPictPrivateKey)
+
+/** Set the glyphset private data given a glyphset pointer */
+#define DMX_SET_GLYPH_PRIV(_pGlyph, _pPriv)				\
+    GlyphSetSetPrivate((_pGlyph), dmxGlyphSetPrivateKey, (_pPriv))
+/** Get the glyphset private data given a glyphset pointer */
+#define DMX_GET_GLYPH_PRIV(_pGlyph)					\
+    (dmxGlyphPrivPtr)GlyphSetGetPrivate((_pGlyph), dmxGlyphSetPrivateKey)
+
+#endif                          /* DMXPICT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxpict.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_table.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_table.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_table.h	(Revision 52145)
@@ -0,0 +1,106 @@
+/*
+ * (C) Copyright IBM Corporation 2005, 2006
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/**
+ * \file indirect_table.h
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#ifndef INDIRECT_TABLE_H
+#define INDIRECT_TABLE_H
+
+#include <inttypes.h>
+
+/**
+ */
+struct __glXDispatchInfo {
+    /**
+     * Number of significant bits in the protocol opcode.  Opcodes with values
+     * larger than ((1 << bits) - 1) are invalid.
+     */
+    unsigned bits;
+
+    /**
+     */
+    const int_fast16_t *dispatch_tree;
+
+    /**
+     * Array of protocol decode and dispatch functions index by the opcode
+     * search tree (i.e., \c dispatch_tree).  The first element in each pair
+     * is the non-byte-swapped version, and the second element is the
+     * byte-swapped version.
+     */
+    const void *(*dispatch_functions)[2];
+
+    /**
+     * Pointer to size validation data.  This table is indexed with the same
+     * value as ::dispatch_functions.
+     *
+     * The first element in the pair is the size, in bytes, of the fixed-size
+     * portion of the protocol.
+     *
+     * For opcodes that have a variable-size portion, the second value is an
+     * index in \c size_func_table to calculate that size.  If there is no
+     * variable-size portion, this index will be ~0.
+     *
+     * \note
+     * If size checking is not to be performed on this type of protocol
+     * data, this pointer will be \c NULL.
+     */
+    const int_fast16_t(*size_table)[2];
+
+    /**
+     * Array of functions used to calculate the variable-size portion of
+     * protocol messages.  Indexed by the second element of the entries
+     * in \c ::size_table.
+     *
+     * \note
+     * If size checking is not to be performed on this type of protocol
+     * data, this pointer will be \c NULL.
+     */
+    const gl_proto_size_func *size_func_table;
+};
+
+/**
+ * Sentinel value for an empty leaf in the \c dispatch_tree.
+ */
+#define EMPTY_LEAF         INT_FAST16_MIN
+
+/**
+ * Declare the index \c x as a leaf index.
+ */
+#define LEAF(x)            -x
+
+/**
+ * Determine if an index is a leaf index.
+ */
+#define IS_LEAF_INDEX(x)   ((x) <= 0)
+
+extern const struct __glXDispatchInfo Single_dispatch_info;
+extern const struct __glXDispatchInfo Render_dispatch_info;
+extern const struct __glXDispatchInfo VendorPriv_dispatch_info;
+
+#endif                          /* INDIRECT_TABLE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_table.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipoly.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipoly.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipoly.h	(Revision 52145)
@@ -0,0 +1,193 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/*
+ *     fill.h
+ *
+ *     Created by Brian Kelleher; Oct 1985
+ *
+ *     Include file for filled polygon routines.
+ *
+ *     These are the data structures needed to scan
+ *     convert regions.  Two different scan conversion
+ *     methods are available -- the even-odd method, and
+ *     the winding number method.
+ *     The even-odd rule states that a point is inside
+ *     the polygon if a ray drawn from that point in any
+ *     direction will pass through an odd number of
+ *     path segments.
+ *     By the winding number rule, a point is decided
+ *     to be inside the polygon if a ray drawn from that
+ *     point in any direction passes through a different
+ *     number of clockwise and counter-clockwise path
+ *     segments.
+ *
+ *     These data structures are adapted somewhat from
+ *     the algorithm in (Foley/Van Dam) for scan converting
+ *     polygons.
+ *     The basic algorithm is to start at the top (smallest y)
+ *     of the polygon, stepping down to the bottom of
+ *     the polygon by incrementing the y coordinate.  We
+ *     keep a list of edges which the current scanline crosses,
+ *     sorted by x.  This list is called the Active Edge Table (AET)
+ *     As we change the y-coordinate, we update each entry in 
+ *     in the active edge table to reflect the edges new xcoord.
+ *     This list must be sorted at each scanline in case
+ *     two edges intersect.
+ *     We also keep a data structure known as the Edge Table (ET),
+ *     which keeps track of all the edges which the current
+ *     scanline has not yet reached.  The ET is basically a
+ *     list of ScanLineList structures containing a list of
+ *     edges which are entered at a given scanline.  There is one
+ *     ScanLineList per scanline at which an edge is entered.
+ *     When we enter a new edge, we move it from the ET to the AET.
+ *
+ *     From the AET, we can implement the even-odd rule as in
+ *     (Foley/Van Dam).
+ *     The winding number rule is a little trickier.  We also
+ *     keep the EdgeTableEntries in the AET linked by the
+ *     nextWETE (winding EdgeTableEntry) link.  This allows
+ *     the edges to be linked just as before for updating
+ *     purposes, but only uses the edges linked by the nextWETE
+ *     link as edges representing spans of the polygon to
+ *     drawn (as with the even-odd rule).
+ */
+
+/*
+ * for the winding number rule
+ */
+#define CLOCKWISE          1
+#define COUNTERCLOCKWISE  -1
+
+typedef struct _EdgeTableEntry {
+    int ymax;                   /* ycoord at which we exit this edge. */
+    BRESINFO bres;              /* Bresenham info to run the edge     */
+    struct _EdgeTableEntry *next;       /* next in the list     */
+    struct _EdgeTableEntry *back;       /* for insertion sort   */
+    struct _EdgeTableEntry *nextWETE;   /* for winding num rule */
+    int ClockWise;              /* flag for winding number rule       */
+} EdgeTableEntry;
+
+typedef struct _ScanLineList {
+    int scanline;               /* the scanline represented */
+    EdgeTableEntry *edgelist;   /* header node              */
+    struct _ScanLineList *next; /* next in the list       */
+} ScanLineList;
+
+typedef struct {
+    int ymax;                   /* ymax for the polygon     */
+    int ymin;                   /* ymin for the polygon     */
+    ScanLineList scanlines;     /* header node              */
+} EdgeTable;
+
+/*
+ * Here is a struct to help with storage allocation
+ * so we can allocate a big chunk at a time, and then take
+ * pieces from this heap when we need to.
+ */
+#define SLLSPERBLOCK 25
+
+typedef struct _ScanLineListBlock {
+    ScanLineList SLLs[SLLSPERBLOCK];
+    struct _ScanLineListBlock *next;
+} ScanLineListBlock;
+
+/*
+ * number of points to buffer before sending them off
+ * to scanlines() :  Must be an even number
+ */
+#define NUMPTSTOBUFFER 200
+
+/*
+ *
+ *     a few macros for the inner loops of the fill code where
+ *     performance considerations don't allow a procedure call.
+ *
+ *     Evaluate the given edge at the given scanline.
+ *     If the edge has expired, then we leave it and fix up
+ *     the active edge table; otherwise, we increment the
+ *     x value to be ready for the next scanline.
+ *     The winding number rule is in effect, so we must notify
+ *     the caller when the edge has been removed so he
+ *     can reorder the Winding Active Edge Table.
+ */
+#define EVALUATEEDGEWINDING(pAET, pPrevAET, y, fixWAET) { \
+   if (pAET->ymax == y) {          /* leaving this edge */ \
+      pPrevAET->next = pAET->next; \
+      pAET = pPrevAET->next; \
+      fixWAET = 1; \
+      if (pAET) \
+         pAET->back = pPrevAET; \
+   } \
+   else { \
+      BRESINCRPGONSTRUCT(pAET->bres); \
+      pPrevAET = pAET; \
+      pAET = pAET->next; \
+   } \
+}
+
+/*
+ *     Evaluate the given edge at the given scanline.
+ *     If the edge has expired, then we leave it and fix up
+ *     the active edge table; otherwise, we increment the
+ *     x value to be ready for the next scanline.
+ *     The even-odd rule is in effect.
+ */
+#define EVALUATEEDGEEVENODD(pAET, pPrevAET, y) { \
+   if (pAET->ymax == y) {          /* leaving this edge */ \
+      pPrevAET->next = pAET->next; \
+      pAET = pPrevAET->next; \
+      if (pAET) \
+         pAET->back = pPrevAET; \
+   } \
+   else { \
+      BRESINCRPGONSTRUCT(pAET->bres); \
+      pPrevAET = pAET; \
+      pAET = pAET->next; \
+   } \
+}
+
+/* mipolyutil.c */
+
+extern _X_EXPORT Bool miCreateETandAET(int /*count */ ,
+                                       DDXPointPtr /*pts */ ,
+                                       EdgeTable * /*ET*/,
+                                       EdgeTableEntry * /*AET*/,
+                                       EdgeTableEntry * /*pETEs */ ,
+                                       ScanLineListBlock *      /*pSLLBlock */
+    );
+
+extern _X_EXPORT void miloadAET(EdgeTableEntry * /*AET*/, EdgeTableEntry *      /*ETEs */
+    );
+
+extern _X_EXPORT void micomputeWAET(EdgeTableEntry * /*AET*/);
+
+extern _X_EXPORT int miInsertionSort(EdgeTableEntry * /*AET*/);
+
+extern _X_EXPORT void miFreeStorage(ScanLineListBlock * /*pSLLBlock */
+    );

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipoly.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdev.h	(Revision 52145)
@@ -0,0 +1,52 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEV_H
+#define GRABDEV_H 1
+
+int SProcXGrabDevice(ClientPtr  /* client */
+    );
+
+int ProcXGrabDevice(ClientPtr   /* client */
+    );
+
+int CreateMaskFromList(ClientPtr /* client */ ,
+                       XEventClass * /* list */ ,
+                       int /* count */ ,
+                       struct tmask /* mask */ [],
+                       DeviceIntPtr /* dev */ ,
+                       int      /* req */
+    );
+
+void SRepXGrabDevice(ClientPtr /* client */ ,
+                     int /* size */ ,
+                     xGrabDeviceReply * /* rep */
+    );
+
+#endif                          /* GRABDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/listdev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/listdev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/listdev.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef LISTDEV_H
+#define LISTDEV_H 1
+
+#define VPC	20              /* Max # valuators per chunk */
+
+int SProcXListInputDevices(ClientPtr    /* client */
+    );
+
+int ProcXListInputDevices(ClientPtr     /* client */
+    );
+
+void SRepXListInputDevices(ClientPtr /* client */ ,
+                           int /* size */ ,
+                           xListInputDevicesReply *     /* rep */
+    );
+
+#endif                          /* LISTDEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/listdev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Extensions.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Extensions.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Extensions.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+ * Copyright ¬© 2011 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef XF86EXTENSIONS_H
+#define XF86EXTENSIONS_H
+
+#include "extnsionst.h"
+
+#ifdef XF86DRI
+extern _X_EXPORT Bool noXFree86DRIExtension;
+extern void XFree86DRIExtensionInit(void);
+#endif
+
+#ifdef DRI2
+#include <X11/extensions/dri2proto.h>
+extern _X_EXPORT Bool noDRI2Extension;
+extern void DRI2ExtensionInit(void);
+#endif
+
+#ifdef XF86VIDMODE
+#include <X11/extensions/xf86vmproto.h>
+extern _X_EXPORT Bool noXFree86VidModeExtension;
+extern void XFree86VidModeExtensionInit(void);
+#endif
+
+#ifdef XFreeXDGA
+#include <X11/extensions/xf86dgaproto.h>
+extern _X_EXPORT Bool noXFree86DGAExtension;
+extern void XFree86DGAExtensionInit(void);
+extern void XFree86DGARegister(void);
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Extensions.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geext.h	(Revision 52145)
@@ -0,0 +1,81 @@
+/*
+
+Copyright 2007 Peter Hutterer <peter@cs.unisa.edu.au>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of the author shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from the author.
+
+*/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GEEXT_H_
+#define _GEEXT_H_
+#include <X11/extensions/geproto.h>
+
+/** Struct to keep information about registered extensions */
+typedef struct _GEExtension {
+    /** Event swapping routine */
+    void (*evswap) (xGenericEvent *from, xGenericEvent *to);
+} GEExtension, *GEExtensionPtr;
+
+/* All registered extensions and their handling functions. */
+extern _X_EXPORT GEExtension GEExtensions[MAXEXTENSIONS];
+
+/* Typecast to generic event */
+#define GEV(ev) ((xGenericEvent*)(ev))
+/* Returns the extension offset from the event */
+#define GEEXT(ev) (GEV(ev)->extension)
+
+/* Return zero-based extension offset (offset - 128). Only for use in arrays */
+#define GEEXTIDX(ev) (GEEXT(ev) & 0x7F)
+/* True if mask is set for extension on window */
+#define GEMaskIsSet(pWin, extension, mask) \
+    ((pWin)->optional && \
+     (pWin)->optional->geMasks && \
+     ((pWin)->optional->geMasks->eventMasks[(extension) & 0x7F] & (mask)))
+
+/* Returns first client */
+#define GECLIENT(pWin) \
+    (((pWin)->optional) ? (pWin)->optional->geMasks->geClients : NULL)
+
+/* Returns the event_fill for the given event */
+#define GEEventFill(ev) \
+    GEExtensions[GEEXTIDX(ev)].evfill
+
+#define GEIsType(ev, ext, ev_type) \
+        ((GEV(ev)->type == GenericEvent) &&  \
+         GEEXT(ev) == (ext) && \
+         GEV(ev)->evtype == (ev_type))
+
+/* Interface for other extensions */
+extern _X_EXPORT void GERegisterExtension(int extension,
+                                          void (*ev_dispatch) (xGenericEvent
+                                                               *from,
+                                                               xGenericEvent
+                                                               *to));
+
+extern _X_EXPORT void GEInitEvent(xGenericEvent *ev, int extension);
+
+#endif                          /* _GEEXT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa.h	(Revision 52145)
@@ -0,0 +1,820 @@
+/*
+ *
+ * Copyright (C) 2000 Keith Packard
+ *               2004 Eric Anholt
+ *               2005 Zack Rusin
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission. Copyright holders make no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/** @file
+ * This is the header containing the public API of EXA for exa drivers.
+ */
+
+#ifndef EXA_H
+#define EXA_H
+
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "gcstruct.h"
+#include "picturestr.h"
+#include "fb.h"
+
+#define EXA_VERSION_MAJOR   2
+#define EXA_VERSION_MINOR   6
+#define EXA_VERSION_RELEASE 0
+
+typedef struct _ExaOffscreenArea ExaOffscreenArea;
+
+typedef void (*ExaOffscreenSaveProc) (ScreenPtr pScreen,
+                                      ExaOffscreenArea * area);
+
+typedef enum _ExaOffscreenState {
+    ExaOffscreenAvail,
+    ExaOffscreenRemovable,
+    ExaOffscreenLocked
+} ExaOffscreenState;
+
+struct _ExaOffscreenArea {
+    int base_offset;            /* allocation base */
+    int offset;                 /* aligned offset */
+    int size;                   /* total allocation size */
+    unsigned last_use;
+    void *privData;
+
+    ExaOffscreenSaveProc save;
+
+    ExaOffscreenState state;
+
+    ExaOffscreenArea *next;
+
+    unsigned eviction_cost;
+
+    ExaOffscreenArea *prev;     /* Double-linked list for defragmentation */
+    int align;                  /* required alignment */
+};
+
+/**
+ * The ExaDriver structure is allocated through exaDriverAlloc(), and then
+ * fllled in by drivers.
+ */
+typedef struct _ExaDriver {
+    /**
+     * exa_major and exa_minor should be set by the driver to the version of
+     * EXA which the driver was compiled for (or configures itself at runtime
+     * to support).  This allows EXA to extend the structure for new features
+     * without breaking ABI for drivers compiled against older versions.
+     */
+    int exa_major, exa_minor;
+
+    /**
+     * memoryBase is the address of the beginning of framebuffer memory.
+     * The visible screen should be within memoryBase to memoryBase +
+     * memorySize.
+     */
+    CARD8 *memoryBase;
+
+    /**
+     * offScreenBase is the offset from memoryBase of the beginning of the area
+     * to be managed by EXA's linear offscreen memory manager.
+     *
+     * In XFree86 DDX drivers, this is probably:
+     *   (pScrn->displayWidth * cpp * pScrn->virtualY)
+     */
+    unsigned long offScreenBase;
+
+    /**
+     * memorySize is the length (in bytes) of framebuffer memory beginning
+     * from memoryBase.
+     *
+     * The offscreen memory manager will manage the area beginning at
+     * (memoryBase + offScreenBase), with a length of (memorySize -
+     * offScreenBase)
+     *
+     * In XFree86 DDX drivers, this is probably (pScrn->videoRam * 1024)
+     */
+    unsigned long memorySize;
+
+    /**
+     * pixmapOffsetAlign is the byte alignment necessary for pixmap offsets
+     * within framebuffer.
+     *
+     * Hardware typically has a required alignment of offsets, which may or may
+     * not be a power of two.  EXA will ensure that pixmaps managed by the
+     * offscreen memory manager meet this alignment requirement.
+     */
+    int pixmapOffsetAlign;
+
+    /**
+     * pixmapPitchAlign is the byte alignment necessary for pixmap pitches
+     * within the framebuffer.
+     *
+     * Hardware typically has a required alignment of pitches for acceleration.
+     * For 3D hardware, Composite acceleration often requires that source and
+     * mask pixmaps (textures) have a power-of-two pitch, which can be demanded
+     * using EXA_OFFSCREEN_ALIGN_POT.  These pitch requirements only apply to
+     * pixmaps managed by the offscreen memory manager.  Thus, it is up to the
+     * driver to ensure that the visible screen has an appropriate pitch for
+     * acceleration.
+     */
+    int pixmapPitchAlign;
+
+    /**
+     * The flags field is bitfield of boolean values controlling EXA's behavior.
+     *
+     * The flags in clude EXA_OFFSCREEN_PIXMAPS, EXA_OFFSCREEN_ALIGN_POT, and
+     * EXA_TWO_BITBLT_DIRECTIONS.
+     */
+    int flags;
+
+    /** @{ */
+    /**
+     * maxX controls the X coordinate limitation for rendering from the card.
+     * The driver should never receive a request for rendering beyond maxX
+     * in the X direction from the origin of a pixmap.
+     */
+    int maxX;
+
+    /**
+     * maxY controls the Y coordinate limitation for rendering from the card.
+     * The driver should never receive a request for rendering beyond maxY
+     * in the Y direction from the origin of a pixmap.
+     */
+    int maxY;
+    /** @} */
+
+    /* private */
+    ExaOffscreenArea *offScreenAreas;
+    Bool needsSync;
+    int lastMarker;
+
+    /** @name Solid
+     * @{
+     */
+    /**
+     * PrepareSolid() sets up the driver for doing a solid fill.
+     * @param pPixmap Destination pixmap
+     * @param alu raster operation
+     * @param planemask write mask for the fill
+     * @param fg "foreground" color for the fill
+     *
+     * This call should set up the driver for doing a series of solid fills
+     * through the Solid() call.  The alu raster op is one of the GX*
+     * graphics functions listed in X.h, and typically maps to a similar
+     * single-byte "ROP" setting in all hardware.  The planemask controls
+     * which bits of the destination should be affected, and will only represent
+     * the bits up to the depth of pPixmap.  The fg is the pixel value of the
+     * foreground color referred to in ROP descriptions.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareSolid() call is required of all drivers, but it may fail for any
+     * reason.  Failure results in a fallback to software rendering.
+     */
+    Bool (*PrepareSolid) (PixmapPtr pPixmap,
+                          int alu, Pixel planemask, Pixel fg);
+
+    /**
+     * Solid() performs a solid fill set up in the last PrepareSolid() call.
+     *
+     * @param pPixmap destination pixmap
+     * @param x1 left coordinate
+     * @param y1 top coordinate
+     * @param x2 right coordinate
+     * @param y2 bottom coordinate
+     *
+     * Performs the fill set up by the last PrepareSolid() call, covering the
+     * area from (x1,y1) to (x2,y2) in pPixmap.  Note that the coordinates are
+     * in the coordinate space of the destination pixmap, so the driver will
+     * need to set up the hardware's offset and pitch for the destination
+     * coordinates according to the pixmap's offset and pitch within
+     * framebuffer.  This likely means using exaGetPixmapOffset() and
+     * exaGetPixmapPitch().
+     *
+     * This call is required if PrepareSolid() ever succeeds.
+     */
+    void (*Solid) (PixmapPtr pPixmap, int x1, int y1, int x2, int y2);
+
+    /**
+     * DoneSolid() finishes a set of solid fills.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneSolid() call is called at the end of a series of consecutive
+     * Solid() calls following a successful PrepareSolid().  This allows drivers
+     * to finish up emitting drawing commands that were buffered, or clean up
+     * state from PrepareSolid().
+     *
+     * This call is required if PrepareSolid() ever succeeds.
+     */
+    void (*DoneSolid) (PixmapPtr pPixmap);
+    /** @} */
+
+    /** @name Copy
+     * @{
+     */
+    /**
+     * PrepareCopy() sets up the driver for doing a copy within video 
+     * memory.
+     *
+     * @param pSrcPixmap source pixmap
+     * @param pDstPixmap destination pixmap
+     * @param dx X copy direction
+     * @param dy Y copy direction
+     * @param alu raster operation
+     * @param planemask write mask for the fill
+     *
+     * This call should set up the driver for doing a series of copies from the
+     * the pSrcPixmap to the pDstPixmap.  The dx flag will be positive if the
+     * hardware should do the copy from the left to the right, and dy will be
+     * positive if the copy should be done from the top to the bottom.  This
+     * is to deal with self-overlapping copies when pSrcPixmap == pDstPixmap.
+     * If your hardware can only support blits that are (left to right, top to
+     * bottom) or (right to left, bottom to top), then you should set
+     * #EXA_TWO_BITBLT_DIRECTIONS, and EXA will break down Copy operations to
+     * ones that meet those requirements.  The alu raster op is one of the GX*
+     * graphics functions listed in X.h, and typically maps to a similar
+     * single-byte "ROP" setting in all hardware.  The planemask controls which
+     * bits of the destination should be affected, and will only represent the
+     * bits up to the depth of pPixmap.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareCopy() call is required of all drivers, but it may fail for any
+     * reason.  Failure results in a fallback to software rendering.
+     */
+    Bool (*PrepareCopy) (PixmapPtr pSrcPixmap,
+                         PixmapPtr pDstPixmap,
+                         int dx, int dy, int alu, Pixel planemask);
+
+    /**
+     * Copy() performs a copy set up in the last PrepareCopy call.
+     *
+     * @param pDstPixmap destination pixmap
+     * @param srcX source X coordinate
+     * @param srcY source Y coordinate
+     * @param dstX destination X coordinate
+     * @param dstY destination Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied.
+     *
+     * Performs the copy set up by the last PrepareCopy() call, copying the
+     * rectangle from (srcX, srcY) to (srcX + width, srcY + width) in the source
+     * pixmap to the same-sized rectangle at (dstX, dstY) in the destination
+     * pixmap.  Those rectangles may overlap in memory, if
+     * pSrcPixmap == pDstPixmap.  Note that this call does not receive the
+     * pSrcPixmap as an argument -- if it's needed in this function, it should
+     * be stored in the driver private during PrepareCopy().  As with Solid(),
+     * the coordinates are in the coordinate space of each pixmap, so the driver
+     * will need to set up source and destination pitches and offsets from those
+     * pixmaps, probably using exaGetPixmapOffset() and exaGetPixmapPitch().
+     *
+     * This call is required if PrepareCopy ever succeeds.
+     */
+    void (*Copy) (PixmapPtr pDstPixmap,
+                  int srcX,
+                  int srcY, int dstX, int dstY, int width, int height);
+
+    /**
+     * DoneCopy() finishes a set of copies.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneCopy() call is called at the end of a series of consecutive
+     * Copy() calls following a successful PrepareCopy().  This allows drivers
+     * to finish up emitting drawing commands that were buffered, or clean up
+     * state from PrepareCopy().
+     *
+     * This call is required if PrepareCopy() ever succeeds.
+     */
+    void (*DoneCopy) (PixmapPtr pDstPixmap);
+    /** @} */
+
+    /** @name Composite
+     * @{
+     */
+    /**
+     * CheckComposite() checks to see if a composite operation could be
+     * accelerated.
+     *
+     * @param op Render operation
+     * @param pSrcPicture source Picture
+     * @param pMaskPicture mask picture
+     * @param pDstPicture destination Picture
+     *
+     * The CheckComposite() call checks if the driver could handle acceleration
+     * of op with the given source, mask, and destination pictures.  This allows
+     * drivers to check source and destination formats, supported operations,
+     * transformations, and component alpha state, and send operations it can't
+     * support to software rendering early on.  This avoids costly pixmap
+     * migration to the wrong places when the driver can't accelerate
+     * operations.  Note that because migration hasn't happened, the driver
+     * can't know during CheckComposite() what the offsets and pitches of the
+     * pixmaps are going to be.
+     *
+     * See PrepareComposite() for more details on likely issues that drivers
+     * will have in accelerating Composite operations.
+     *
+     * The CheckComposite() call is recommended if PrepareComposite() is
+     * implemented, but is not required.
+     */
+    Bool (*CheckComposite) (int op,
+                            PicturePtr pSrcPicture,
+                            PicturePtr pMaskPicture, PicturePtr pDstPicture);
+
+    /**
+     * PrepareComposite() sets up the driver for doing a Composite operation
+     * described in the Render extension protocol spec.
+     *
+     * @param op Render operation
+     * @param pSrcPicture source Picture
+     * @param pMaskPicture mask picture
+     * @param pDstPicture destination Picture
+     * @param pSrc source pixmap
+     * @param pMask mask pixmap
+     * @param pDst destination pixmap
+     *
+     * This call should set up the driver for doing a series of Composite
+     * operations, as described in the Render protocol spec, with the given
+     * pSrcPicture, pMaskPicture, and pDstPicture.  The pSrc, pMask, and
+     * pDst are the pixmaps containing the pixel data, and should be used for
+     * setting the offset and pitch used for the coordinate spaces for each of
+     * the Pictures.
+     *
+     * Notes on interpreting Picture structures:
+     * - The Picture structures will always have a valid pDrawable.
+     * - The Picture structures will never have alphaMap set.
+     * - The mask Picture (and therefore pMask) may be NULL, in which case the
+     *   operation is simply src OP dst instead of src IN mask OP dst, and
+     *   mask coordinates should be ignored.
+     * - pMarkPicture may have componentAlpha set, which greatly changes
+     *   the behavior of the Composite operation.  componentAlpha has no effect
+     *   when set on pSrcPicture or pDstPicture.
+     * - The source and mask Pictures may have a transformation set
+     *   (Picture->transform != NULL), which means that the source coordinates
+     *   should be transformed by that transformation, resulting in scaling,
+     *   rotation, etc.  The PictureTransformPoint() call can transform
+     *   coordinates for you.  Transforms have no effect on Pictures when used
+     *   as a destination.
+     * - The source and mask pictures may have a filter set.  PictFilterNearest
+     *   and PictFilterBilinear are defined in the Render protocol, but others
+     *   may be encountered, and must be handled correctly (usually by
+     *   PrepareComposite failing, and falling back to software).  Filters have
+     *   no effect on Pictures when used as a destination.
+     * - The source and mask Pictures may have repeating set, which must be
+     *   respected.  Many chipsets will be unable to support repeating on
+     *   pixmaps that have a width or height that is not a power of two.
+     *
+     * If your hardware can't support source pictures (textures) with
+     * non-power-of-two pitches, you should set #EXA_OFFSCREEN_ALIGN_POT.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareComposite() call is not required.  However, it is highly
+     * recommended for performance of antialiased font rendering and performance
+     * of cairo applications.  Failure results in a fallback to software
+     * rendering.
+     */
+    Bool (*PrepareComposite) (int op,
+                              PicturePtr pSrcPicture,
+                              PicturePtr pMaskPicture,
+                              PicturePtr pDstPicture,
+                              PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst);
+
+    /**
+     * Composite() performs a Composite operation set up in the last
+     * PrepareComposite() call.
+     *
+     * @param pDstPixmap destination pixmap
+     * @param srcX source X coordinate
+     * @param srcY source Y coordinate
+     * @param maskX source X coordinate
+     * @param maskY source Y coordinate
+     * @param dstX destination X coordinate
+     * @param dstY destination Y coordinate
+     * @param width destination rectangle width
+     * @param height destination rectangle height
+     *
+     * Performs the Composite operation set up by the last PrepareComposite()
+     * call, to the rectangle from (dstX, dstY) to (dstX + width, dstY + height)
+     * in the destination Pixmap.  Note that if a transformation was set on
+     * the source or mask Pictures, the source rectangles may not be the same
+     * size as the destination rectangles and filtering.  Getting the coordinate
+     * transformation right at the subpixel level can be tricky, and rendercheck
+     * can test this for you.
+     *
+     * This call is required if PrepareComposite() ever succeeds.
+     */
+    void (*Composite) (PixmapPtr pDst,
+                       int srcX,
+                       int srcY,
+                       int maskX,
+                       int maskY, int dstX, int dstY, int width, int height);
+
+    /**
+     * DoneComposite() finishes a set of Composite operations.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneComposite() call is called at the end of a series of consecutive
+     * Composite() calls following a successful PrepareComposite().  This allows
+     * drivers to finish up emitting drawing commands that were buffered, or
+     * clean up state from PrepareComposite().
+     *
+     * This call is required if PrepareComposite() ever succeeds.
+     */
+    void (*DoneComposite) (PixmapPtr pDst);
+    /** @} */
+
+    /**
+     * UploadToScreen() loads a rectangle of data from src into pDst.
+     *
+     * @param pDst destination pixmap
+     * @param x destination X coordinate.
+     * @param y destination Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied
+     * @param src pointer to the beginning of the source data
+     * @param src_pitch pitch (in bytes) of the lines of source data.
+     *
+     * UploadToScreen() copies data in system memory beginning at src (with
+     * pitch src_pitch) into the destination pixmap from (x, y) to
+     * (x + width, y + height).  This is typically done with hostdata uploads,
+     * where the CPU sets up a blit command on the hardware with instructions
+     * that the blit data will be fed through some sort of aperture on the card.
+     *
+     * If UploadToScreen() is performed asynchronously, it is up to the driver
+     * to call exaMarkSync().  This is in contrast to most other acceleration
+     * calls in EXA.
+     *
+     * UploadToScreen() can aid in pixmap migration, but is most important for
+     * the performance of exaGlyphs() (antialiased font drawing) by allowing
+     * pipelining of data uploads, avoiding a sync of the card after each glyph.
+     * 
+     * @return TRUE if the driver successfully uploaded the data.  FALSE
+     * indicates that EXA should fall back to doing the upload in software.
+     *
+     * UploadToScreen() is not required, but is recommended if Composite
+     * acceleration is supported.
+     */
+    Bool (*UploadToScreen) (PixmapPtr pDst,
+                            int x,
+                            int y, int w, int h, char *src, int src_pitch);
+
+    /**
+     * UploadToScratch() is no longer used and will be removed next time the EXA
+     * major version needs to be bumped.
+     */
+    Bool (*UploadToScratch) (PixmapPtr pSrc, PixmapPtr pDst);
+
+    /**
+     * DownloadFromScreen() loads a rectangle of data from pSrc into dst
+     *
+     * @param pSrc source pixmap
+     * @param x source X coordinate.
+     * @param y source Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied
+     * @param dst pointer to the beginning of the destination data
+     * @param dst_pitch pitch (in bytes) of the lines of destination data.
+     *
+     * DownloadFromScreen() copies data from offscreen memory in pSrc from
+     * (x, y) to (x + width, y + height), to system memory starting at
+     * dst (with pitch dst_pitch).  This would usually be done
+     * using scatter-gather DMA, supported by a DRM call, or by blitting to AGP
+     * and then synchronously reading from AGP.  Because the implementation
+     * might be synchronous, EXA leaves it up to the driver to call
+     * exaMarkSync() if DownloadFromScreen() was asynchronous.  This is in
+     * contrast to most other acceleration calls in EXA.
+     *
+     * DownloadFromScreen() can aid in the largest bottleneck in pixmap
+     * migration, which is the read from framebuffer when evicting pixmaps from
+     * framebuffer memory.  Thus, it is highly recommended, even though
+     * implementations are typically complicated.
+     * 
+     * @return TRUE if the driver successfully downloaded the data.  FALSE
+     * indicates that EXA should fall back to doing the download in software.
+     *
+     * DownloadFromScreen() is not required, but is highly recommended.
+     */
+    Bool (*DownloadFromScreen) (PixmapPtr pSrc,
+                                int x, int y,
+                                int w, int h, char *dst, int dst_pitch);
+
+    /**
+     * MarkSync() requests that the driver mark a synchronization point,
+     * returning an driver-defined integer marker which could be requested for
+     * synchronization to later in WaitMarker().  This might be used in the
+     * future to avoid waiting for full hardware stalls before accessing pixmap
+     * data with the CPU, but is not important in the current incarnation of
+     * EXA.
+     *
+     * Note that drivers should call exaMarkSync() when they have done some
+     * acceleration, rather than their own MarkSync() handler, as otherwise EXA
+     * will be unaware of the driver's acceleration and not sync to it during
+     * fallbacks.
+     *
+     * MarkSync() is optional.
+     */
+    int (*MarkSync) (ScreenPtr pScreen);
+
+    /**
+     * WaitMarker() waits for all rendering before the given marker to have
+     * completed.  If the driver does not implement MarkSync(), marker is
+     * meaningless, and all rendering by the hardware should be completed before
+     * WaitMarker() returns.
+     *
+     * Note that drivers should call exaWaitSync() to wait for all acceleration
+     * to finish, as otherwise EXA will be unaware of the driver having
+     * synchronized, resulting in excessive WaitMarker() calls.
+     *
+     * WaitMarker() is required of all drivers.
+     */
+    void (*WaitMarker) (ScreenPtr pScreen, int marker);
+
+    /** @{ */
+    /**
+     * PrepareAccess() is called before CPU access to an offscreen pixmap.
+     *
+     * @param pPix the pixmap being accessed
+     * @param index the index of the pixmap being accessed.
+     *
+     * PrepareAccess() will be called before CPU access to an offscreen pixmap.
+     * This can be used to set up hardware surfaces for byteswapping or
+     * untiling, or to adjust the pixmap's devPrivate.ptr for the purpose of
+     * making CPU access use a different aperture.
+     *
+     * The index is one of #EXA_PREPARE_DEST, #EXA_PREPARE_SRC,
+     * #EXA_PREPARE_MASK, #EXA_PREPARE_AUX_DEST, #EXA_PREPARE_AUX_SRC, or
+     * #EXA_PREPARE_AUX_MASK. Since only up to #EXA_NUM_PREPARE_INDICES pixmaps
+     * will have PrepareAccess() called on them per operation, drivers can have
+     * a small, statically-allocated space to maintain state for PrepareAccess()
+     * and FinishAccess() in.  Note that PrepareAccess() is only called once per
+     * pixmap and operation, regardless of whether the pixmap is used as a
+     * destination and/or source, and the index may not reflect the usage.
+     *
+     * PrepareAccess() may fail.  An example might be the case of hardware that
+     * can set up 1 or 2 surfaces for CPU access, but not 3.  If PrepareAccess()
+     * fails, EXA will migrate the pixmap to system memory.
+     * DownloadFromScreen() must be implemented and must not fail if a driver
+     * wishes to fail in PrepareAccess().  PrepareAccess() must not fail when
+     * pPix is the visible screen, because the visible screen can not be
+     * migrated.
+     *
+     * @return TRUE if PrepareAccess() successfully prepared the pixmap for CPU
+     * drawing.
+     * @return FALSE if PrepareAccess() is unsuccessful and EXA should use
+     * DownloadFromScreen() to migate the pixmap out.
+     */
+    Bool (*PrepareAccess) (PixmapPtr pPix, int index);
+
+    /**
+     * FinishAccess() is called after CPU access to an offscreen pixmap.
+     *
+     * @param pPix the pixmap being accessed
+     * @param index the index of the pixmap being accessed.
+     *
+     * FinishAccess() will be called after finishing CPU access of an offscreen
+     * pixmap set up by PrepareAccess().  Note that the FinishAccess() will not be
+     * called if PrepareAccess() failed and the pixmap was migrated out.
+     */
+    void (*FinishAccess) (PixmapPtr pPix, int index);
+
+    /**
+     * PixmapIsOffscreen() is an optional driver replacement to
+     * exaPixmapHasGpuCopy(). Set to NULL if you want the standard behaviour
+     * of exaPixmapHasGpuCopy().
+     *
+     * @param pPix the pixmap
+     * @return TRUE if the given drawable is in framebuffer memory.
+     *
+     * exaPixmapHasGpuCopy() is used to determine if a pixmap is in offscreen
+     * memory, meaning that acceleration could probably be done to it, and that it
+     * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
+     * with the CPU.
+     *
+     *
+     */
+    Bool (*PixmapIsOffscreen) (PixmapPtr pPix);
+
+        /** @name PrepareAccess() and FinishAccess() indices
+	 * @{
+	 */
+        /**
+	 * EXA_PREPARE_DEST is the index for a pixmap that may be drawn to or
+	 * read from.
+	 */
+#define EXA_PREPARE_DEST	0
+        /**
+	 * EXA_PREPARE_SRC is the index for a pixmap that may be read from
+	 */
+#define EXA_PREPARE_SRC		1
+        /**
+	 * EXA_PREPARE_SRC is the index for a second pixmap that may be read
+	 * from.
+	 */
+#define EXA_PREPARE_MASK	2
+        /**
+	 * EXA_PREPARE_AUX* are additional indices for other purposes, e.g.
+	 * separate alpha maps with Composite operations.
+	 */
+#define EXA_PREPARE_AUX_DEST	3
+#define EXA_PREPARE_AUX_SRC	4
+#define EXA_PREPARE_AUX_MASK	5
+#define EXA_NUM_PREPARE_INDICES	6
+        /** @} */
+
+    /**
+     * maxPitchPixels controls the pitch limitation for rendering from
+     * the card.
+     * The driver should never receive a request for rendering a pixmap
+     * that has a pitch (in pixels) beyond maxPitchPixels.
+     *
+     * Setting this field is optional -- if your hardware doesn't have
+     * a pitch limitation in pixels, don't set this. If neither this value
+     * nor maxPitchBytes is set, then maxPitchPixels is set to maxX.
+     * If set, it must not be smaller than maxX.
+     *
+     * @sa maxPitchBytes
+     */
+    int maxPitchPixels;
+
+    /**
+     * maxPitchBytes controls the pitch limitation for rendering from
+     * the card.
+     * The driver should never receive a request for rendering a pixmap
+     * that has a pitch (in bytes) beyond maxPitchBytes.
+     *
+     * Setting this field is optional -- if your hardware doesn't have
+     * a pitch limitation in bytes, don't set this.
+     * If set, it must not be smaller than maxX * 4.
+     * There's no default value for maxPitchBytes.
+     *
+     * @sa maxPitchPixels
+     */
+    int maxPitchBytes;
+
+    /* Hooks to allow driver to its own pixmap memory management */
+    void *(*CreatePixmap) (ScreenPtr pScreen, int size, int align);
+    void (*DestroyPixmap) (ScreenPtr pScreen, void *driverPriv);
+    /**
+     * Returning a pixmap with non-NULL devPrivate.ptr implies a pixmap which is
+     * not offscreen, which will never be accelerated and Prepare/FinishAccess won't
+     * be called.
+     */
+    Bool (*ModifyPixmapHeader) (PixmapPtr pPixmap, int width, int height,
+                                int depth, int bitsPerPixel, int devKind,
+                                void *pPixData);
+
+    /* hooks for drivers with tiling support:
+     * driver MUST fill out new_fb_pitch with valid pitch of pixmap
+     */
+    void *(*CreatePixmap2) (ScreenPtr pScreen, int width, int height,
+                            int depth, int usage_hint, int bitsPerPixel,
+                            int *new_fb_pitch);
+    /** @} */
+    Bool (*SharePixmapBacking)(PixmapPtr pPixmap, ScreenPtr slave, void **handle_p);
+
+    Bool (*SetSharedPixmapBacking)(PixmapPtr pPixmap, void *handle);
+
+} ExaDriverRec, *ExaDriverPtr;
+
+/** @name EXA driver flags
+ * @{
+ */
+/**
+ * EXA_OFFSCREEN_PIXMAPS indicates to EXA that the driver can support 
+ * offscreen pixmaps.
+ */
+#define EXA_OFFSCREEN_PIXMAPS		(1 << 0)
+
+/**
+ * EXA_OFFSCREEN_ALIGN_POT indicates to EXA that the driver needs pixmaps
+ * to have a power-of-two pitch.
+ */
+#define EXA_OFFSCREEN_ALIGN_POT		(1 << 1)
+
+/**
+ * EXA_TWO_BITBLT_DIRECTIONS indicates to EXA that the driver can only
+ * support copies that are (left-to-right, top-to-bottom) or
+ * (right-to-left, bottom-to-top).
+ */
+#define EXA_TWO_BITBLT_DIRECTIONS	(1 << 2)
+
+/**
+ * EXA_HANDLES_PIXMAPS indicates to EXA that the driver can handle
+ * all pixmap addressing and migration.
+ */
+#define EXA_HANDLES_PIXMAPS             (1 << 3)
+
+/**
+ * EXA_SUPPORTS_PREPARE_AUX indicates to EXA that the driver can handle the
+ * EXA_PREPARE_AUX* indices in the Prepare/FinishAccess hooks. If there are no
+ * such hooks, this flag has no effect.
+ */
+#define EXA_SUPPORTS_PREPARE_AUX        (1 << 4)
+
+/**
+ * EXA_SUPPORTS_OFFSCREEN_OVERLAPS indicates to EXA that the driver Copy hooks
+ * can handle the source and destination occupying overlapping offscreen memory
+ * areas. This allows the offscreen memory defragmentation code to defragment
+ * areas where the defragmented position overlaps the fragmented position.
+ *
+ * Typically this is supported by traditional 2D engines but not by 3D engines.
+ */
+#define EXA_SUPPORTS_OFFSCREEN_OVERLAPS (1 << 5)
+
+/**
+ * EXA_MIXED_PIXMAPS will hide unacceleratable pixmaps from drivers and manage the
+ * problem known software fallbacks like trapezoids. This only migrates pixmaps one way
+ * into a driver pixmap and then pins it.
+ */
+#define EXA_MIXED_PIXMAPS (1 << 6)
+
+/** @} */
+
+/* in exa.c */
+extern _X_EXPORT ExaDriverPtr exaDriverAlloc(void);
+
+extern _X_EXPORT Bool
+ exaDriverInit(ScreenPtr pScreen, ExaDriverPtr pScreenInfo);
+
+extern _X_EXPORT void
+ exaDriverFini(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ exaMarkSync(ScreenPtr pScreen);
+extern _X_EXPORT void
+ exaWaitSync(ScreenPtr pScreen);
+
+extern _X_EXPORT unsigned long
+ exaGetPixmapOffset(PixmapPtr pPix);
+
+extern _X_EXPORT unsigned long
+ exaGetPixmapPitch(PixmapPtr pPix);
+
+extern _X_EXPORT unsigned long
+ exaGetPixmapSize(PixmapPtr pPix);
+
+extern _X_EXPORT void *exaGetPixmapDriverPrivate(PixmapPtr p);
+
+/* in exa_offscreen.c */
+extern _X_EXPORT ExaOffscreenArea *exaOffscreenAlloc(ScreenPtr pScreen,
+                                                     int size, int align,
+                                                     Bool locked,
+                                                     ExaOffscreenSaveProc save,
+                                                     void *privData);
+
+extern _X_EXPORT ExaOffscreenArea *exaOffscreenFree(ScreenPtr pScreen,
+                                                    ExaOffscreenArea * area);
+
+extern _X_EXPORT void
+ ExaOffscreenMarkUsed(PixmapPtr pPixmap);
+
+extern _X_EXPORT void
+ exaEnableDisableFBAccess(ScreenPtr pScreen, Bool enable);
+
+extern _X_EXPORT Bool
+ exaDrawableIsOffscreen(DrawablePtr pDrawable);
+
+/* in exa.c */
+extern _X_EXPORT void
+ exaMoveInPixmap(PixmapPtr pPixmap);
+
+extern _X_EXPORT void
+ exaMoveOutPixmap(PixmapPtr pPixmap);
+
+/* in exa_unaccel.c */
+extern _X_EXPORT CARD32
+ exaGetPixmapFirstPixel(PixmapPtr pPixmap);
+
+/**
+ * Returns TRUE if the given planemask covers all the significant bits in the
+ * pixel values for pDrawable.
+ */
+#define EXA_PM_IS_SOLID(_pDrawable, _pm) \
+	(((_pm) & FbFullMask((_pDrawable)->depth)) == \
+	 FbFullMask((_pDrawable)->depth))
+
+#endif                          /* EXA_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/devbell.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/devbell.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/devbell.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DEVBELL_H
+#define DEVBELL_H 1
+
+int SProcXDeviceBell(ClientPtr  /* client */
+    );
+
+int ProcXDeviceBell(ClientPtr   /* client */
+    );
+
+#endif                          /* DEVBELL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/devbell.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa_priv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa_priv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa_priv.h	(Revision 52145)
@@ -0,0 +1,748 @@
+/*
+ *
+ * Copyright (C) 2000 Keith Packard, member of The XFree86 Project, Inc.
+ *               2005 Zack Rusin, Trolltech
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef EXAPRIV_H
+#define EXAPRIV_H
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "exa.h"
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#ifdef MITSHM
+#include "shmint.h"
+#endif
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "servermd.h"
+#include "colormapst.h"
+#include "gcstruct.h"
+#include "input.h"
+#include "mipointer.h"
+#include "mi.h"
+#include "dix.h"
+#include "fb.h"
+#include "fboverlay.h"
+#include "fbpict.h"
+#include "glyphstr.h"
+#include "damage.h"
+
+#define DEBUG_TRACE_FALL	0
+#define DEBUG_MIGRATE		0
+#define DEBUG_PIXMAP		0
+#define DEBUG_OFFSCREEN		0
+#define DEBUG_GLYPH_CACHE	0
+
+#if DEBUG_TRACE_FALL
+#define EXA_FALLBACK(x)     					\
+do {								\
+	ErrorF("EXA fallback at %s: ", __FUNCTION__);		\
+	ErrorF x;						\
+} while (0)
+
+char
+ exaDrawableLocation(DrawablePtr pDrawable);
+#else
+#define EXA_FALLBACK(x)
+#endif
+
+#if DEBUG_PIXMAP
+#define DBG_PIXMAP(a) ErrorF a
+#else
+#define DBG_PIXMAP(a)
+#endif
+
+#ifndef EXA_MAX_FB
+#define EXA_MAX_FB   FB_OVERLAY_MAX
+#endif
+
+#ifdef DEBUG
+#define EXA_FatalErrorDebug(x) FatalError x
+#define EXA_FatalErrorDebugWithRet(x, ret) FatalError x
+#else
+#define EXA_FatalErrorDebug(x) ErrorF x
+#define EXA_FatalErrorDebugWithRet(x, ret) \
+do { \
+    ErrorF x; \
+    return ret; \
+} while (0)
+#endif
+
+/**
+ * This is the list of migration heuristics supported by EXA.  See
+ * exaDoMigration() for what their implementations do.
+ */
+enum ExaMigrationHeuristic {
+    ExaMigrationGreedy,
+    ExaMigrationAlways,
+    ExaMigrationSmart
+};
+
+typedef struct {
+    unsigned char sha1[20];
+} ExaCachedGlyphRec, *ExaCachedGlyphPtr;
+
+typedef struct {
+    /* The identity of the cache, statically configured at initialization */
+    unsigned int format;
+    int glyphWidth;
+    int glyphHeight;
+
+    int size;                   /* Size of cache; eventually this should be dynamically determined */
+
+    /* Hash table mapping from glyph sha1 to position in the glyph; we use
+     * open addressing with a hash table size determined based on size and large
+     * enough so that we always have a good amount of free space, so we can
+     * use linear probing. (Linear probing is preferrable to double hashing
+     * here because it allows us to easily remove entries.)
+     */
+    int *hashEntries;
+    int hashSize;
+
+    ExaCachedGlyphPtr glyphs;
+    int glyphCount;             /* Current number of glyphs */
+
+    PicturePtr picture;         /* Where the glyphs of the cache are stored */
+    int yOffset;                /* y location within the picture where the cache starts */
+    int columns;                /* Number of columns the glyphs are layed out in */
+    int evictionPosition;       /* Next random position to evict a glyph */
+} ExaGlyphCacheRec, *ExaGlyphCachePtr;
+
+#define EXA_NUM_GLYPH_CACHES 4
+
+#define EXA_FALLBACK_COPYWINDOW (1 << 0)
+#define EXA_ACCEL_COPYWINDOW (1 << 1)
+
+typedef struct _ExaMigrationRec {
+    Bool as_dst;
+    Bool as_src;
+    PixmapPtr pPix;
+    RegionPtr pReg;
+} ExaMigrationRec, *ExaMigrationPtr;
+
+typedef void (*EnableDisableFBAccessProcPtr) (ScreenPtr, Bool);
+typedef struct {
+    ExaDriverPtr info;
+    ScreenBlockHandlerProcPtr SavedBlockHandler;
+    ScreenWakeupHandlerProcPtr SavedWakeupHandler;
+    CreateGCProcPtr SavedCreateGC;
+    CloseScreenProcPtr SavedCloseScreen;
+    GetImageProcPtr SavedGetImage;
+    GetSpansProcPtr SavedGetSpans;
+    CreatePixmapProcPtr SavedCreatePixmap;
+    DestroyPixmapProcPtr SavedDestroyPixmap;
+    CopyWindowProcPtr SavedCopyWindow;
+    ChangeWindowAttributesProcPtr SavedChangeWindowAttributes;
+    BitmapToRegionProcPtr SavedBitmapToRegion;
+    CreateScreenResourcesProcPtr SavedCreateScreenResources;
+    ModifyPixmapHeaderProcPtr SavedModifyPixmapHeader;
+    SharePixmapBackingProcPtr SavedSharePixmapBacking;
+    SetSharedPixmapBackingProcPtr SavedSetSharedPixmapBacking;
+    SourceValidateProcPtr SavedSourceValidate;
+    CompositeProcPtr SavedComposite;
+    TrianglesProcPtr SavedTriangles;
+    GlyphsProcPtr SavedGlyphs;
+    TrapezoidsProcPtr SavedTrapezoids;
+    AddTrapsProcPtr SavedAddTraps;
+    void (*do_migration) (ExaMigrationPtr pixmaps, int npixmaps,
+                          Bool can_accel);
+    Bool (*pixmap_has_gpu_copy) (PixmapPtr pPixmap);
+    void (*do_move_in_pixmap) (PixmapPtr pPixmap);
+    void (*do_move_out_pixmap) (PixmapPtr pPixmap);
+    void (*prepare_access_reg) (PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+    Bool swappedOut;
+    enum ExaMigrationHeuristic migration;
+    Bool checkDirtyCorrectness;
+    unsigned disableFbCount;
+    Bool optimize_migration;
+    unsigned offScreenCounter;
+    unsigned numOffscreenAvailable;
+    CARD32 lastDefragment;
+    CARD32 nextDefragment;
+    PixmapPtr deferred_mixed_pixmap;
+
+    /* Reference counting for accessed pixmaps */
+    struct {
+        PixmapPtr pixmap;
+        int count;
+        Bool retval;
+    } access[EXA_NUM_PREPARE_INDICES];
+
+    /* Holds information on fallbacks that cannot be relayed otherwise. */
+    unsigned int fallback_flags;
+    unsigned int fallback_counter;
+
+    ExaGlyphCacheRec glyphCaches[EXA_NUM_GLYPH_CACHES];
+
+    /**
+     * Regions affected by fallback composite source / mask operations.
+     */
+
+    RegionRec srcReg;
+    RegionRec maskReg;
+    PixmapPtr srcPix;
+    PixmapPtr maskPix;
+
+    DevPrivateKeyRec pixmapPrivateKeyRec;
+    DevPrivateKeyRec gcPrivateKeyRec;
+} ExaScreenPrivRec, *ExaScreenPrivPtr;
+
+/*
+ * This is the only completely portable way to
+ * compute this info.
+ */
+#ifndef BitsPerPixel
+#define BitsPerPixel(d) (\
+    PixmapWidthPaddingInfo[d].notPower2 ? \
+    (PixmapWidthPaddingInfo[d].bytesPerPixel * 8) : \
+    ((1 << PixmapWidthPaddingInfo[d].padBytesLog2) * 8 / \
+    (PixmapWidthPaddingInfo[d].padRoundUp+1)))
+#endif
+
+extern DevPrivateKeyRec exaScreenPrivateKeyRec;
+
+#define exaScreenPrivateKey (&exaScreenPrivateKeyRec)
+
+#define ExaGetScreenPriv(s) ((ExaScreenPrivPtr)dixGetPrivate(&(s)->devPrivates, exaScreenPrivateKey))
+#define ExaScreenPriv(s)	ExaScreenPrivPtr    pExaScr = ExaGetScreenPriv(s)
+
+#define ExaGetGCPriv(gc) ((ExaGCPrivPtr)dixGetPrivateAddr(&(gc)->devPrivates, &ExaGetScreenPriv(gc->pScreen)->gcPrivateKeyRec))
+#define ExaGCPriv(gc) ExaGCPrivPtr pExaGC = ExaGetGCPriv(gc)
+
+/*
+ * Some macros to deal with function wrapping.
+ */
+#define wrap(priv, real, mem, func) {\
+    priv->Saved##mem = real->mem; \
+    real->mem = func; \
+}
+
+#define unwrap(priv, real, mem) {\
+    real->mem = priv->Saved##mem; \
+}
+
+#ifdef HAVE_TYPEOF
+#define swap(priv, real, mem) {\
+    typeof(real->mem) tmp = priv->Saved##mem; \
+    priv->Saved##mem = real->mem; \
+    real->mem = tmp; \
+}
+#else
+#define swap(priv, real, mem) {\
+    void *tmp = priv->Saved##mem; \
+    priv->Saved##mem = real->mem; \
+    real->mem = tmp; \
+}
+#endif
+
+#define EXA_PRE_FALLBACK(_screen_) \
+    ExaScreenPriv(_screen_); \
+    pExaScr->fallback_counter++;
+
+#define EXA_POST_FALLBACK(_screen_) \
+    pExaScr->fallback_counter--;
+
+#define EXA_PRE_FALLBACK_GC(_gc_) \
+    ExaScreenPriv(_gc_->pScreen); \
+    ExaGCPriv(_gc_); \
+    pExaScr->fallback_counter++; \
+    swap(pExaGC, _gc_, ops);
+
+#define EXA_POST_FALLBACK_GC(_gc_) \
+    pExaScr->fallback_counter--; \
+    swap(pExaGC, _gc_, ops);
+
+/** Align an offset to an arbitrary alignment */
+#define EXA_ALIGN(offset, align) (((offset) + (align) - 1) - \
+	(((offset) + (align) - 1) % (align)))
+/** Align an offset to a power-of-two alignment */
+#define EXA_ALIGN2(offset, align) (((offset) + (align) - 1) & ~((align) - 1))
+
+#define EXA_PIXMAP_SCORE_MOVE_IN    10
+#define EXA_PIXMAP_SCORE_MAX	    20
+#define EXA_PIXMAP_SCORE_MOVE_OUT   -10
+#define EXA_PIXMAP_SCORE_MIN	    -20
+#define EXA_PIXMAP_SCORE_PINNED	    1000
+#define EXA_PIXMAP_SCORE_INIT	    1001
+
+#define ExaGetPixmapPriv(p) ((ExaPixmapPrivPtr)dixGetPrivateAddr(&(p)->devPrivates, &ExaGetScreenPriv((p)->drawable.pScreen)->pixmapPrivateKeyRec))
+#define ExaPixmapPriv(p)	ExaPixmapPrivPtr pExaPixmap = ExaGetPixmapPriv(p)
+
+#define EXA_RANGE_PITCH (1 << 0)
+#define EXA_RANGE_WIDTH (1 << 1)
+#define EXA_RANGE_HEIGHT (1 << 2)
+
+typedef struct {
+    ExaOffscreenArea *area;
+    int score;                  /**< score for the move-in vs move-out heuristic */
+    Bool use_gpu_copy;
+
+    CARD8 *sys_ptr;             /**< pointer to pixmap data in system memory */
+    int sys_pitch;              /**< pitch of pixmap in system memory */
+
+    CARD8 *fb_ptr;              /**< pointer to pixmap data in framebuffer memory */
+    int fb_pitch;               /**< pitch of pixmap in framebuffer memory */
+    unsigned int fb_size;       /**< size of pixmap in framebuffer memory */
+
+    /**
+     * Holds information about whether this pixmap can be used for
+     * acceleration (== 0) or not (> 0).
+     *
+     * Contains a OR'ed combination of the following values:
+     * EXA_RANGE_PITCH - set if the pixmap's pitch is out of range
+     * EXA_RANGE_WIDTH - set if the pixmap's width is out of range
+     * EXA_RANGE_HEIGHT - set if the pixmap's height is out of range
+     */
+    unsigned int accel_blocked;
+
+    /**
+     * The damage record contains the areas of the pixmap's current location
+     * (framebuffer or system) that have been damaged compared to the other
+     * location.
+     */
+    DamagePtr pDamage;
+    /**
+     * The valid regions mark the valid bits (at least, as they're derived from
+     * damage, which may be overreported) of a pixmap's system and FB copies.
+     */
+    RegionRec validSys, validFB;
+    /**
+     * Driver private storage per EXA pixmap
+     */
+    void *driverPriv;
+} ExaPixmapPrivRec, *ExaPixmapPrivPtr;
+
+typedef struct {
+    /* GC values from the layer below. */
+    const GCOps *Savedops;
+    const GCFuncs *Savedfuncs;
+} ExaGCPrivRec, *ExaGCPrivPtr;
+
+typedef struct {
+    PicturePtr pDst;
+    INT16 xSrc;
+    INT16 ySrc;
+    INT16 xMask;
+    INT16 yMask;
+    INT16 xDst;
+    INT16 yDst;
+    INT16 width;
+    INT16 height;
+} ExaCompositeRectRec, *ExaCompositeRectPtr;
+
+/**
+ * exaDDXDriverInit must be implemented by the DDX using EXA, and is the place
+ * to set EXA options or hook in screen functions to handle using EXA as the AA.
+  */
+void exaDDXDriverInit(ScreenPtr pScreen);
+
+/* exa_unaccel.c */
+void
+ exaPrepareAccessGC(GCPtr pGC);
+
+void
+ exaFinishAccessGC(GCPtr pGC);
+
+void
+
+ExaCheckFillSpans(DrawablePtr pDrawable, GCPtr pGC, int nspans,
+                  DDXPointPtr ppt, int *pwidth, int fSorted);
+
+void
+
+ExaCheckSetSpans(DrawablePtr pDrawable, GCPtr pGC, char *psrc,
+                 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+
+void
+
+ExaCheckPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth,
+                 int x, int y, int w, int h, int leftPad, int format,
+                 char *bits);
+
+void
+
+ExaCheckCopyNtoN(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                 BoxPtr pbox, int nbox, int dx, int dy, Bool reverse,
+                 Bool upsidedown, Pixel bitplane, void *closure);
+
+RegionPtr
+
+ExaCheckCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                 int srcx, int srcy, int w, int h, int dstx, int dsty);
+
+RegionPtr
+
+ExaCheckCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                  int srcx, int srcy, int w, int h, int dstx, int dsty,
+                  unsigned long bitPlane);
+
+void
+
+ExaCheckPolyPoint(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
+                  DDXPointPtr pptInit);
+
+void
+
+ExaCheckPolylines(DrawablePtr pDrawable, GCPtr pGC,
+                  int mode, int npt, DDXPointPtr ppt);
+
+void
+
+ExaCheckPolySegment(DrawablePtr pDrawable, GCPtr pGC,
+                    int nsegInit, xSegment * pSegInit);
+
+void
+ ExaCheckPolyArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * pArcs);
+
+void
+
+ExaCheckPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
+                     int nrect, xRectangle *prect);
+
+void
+
+ExaCheckImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+                      int x, int y, unsigned int nglyph,
+                      CharInfoPtr * ppci, void *pglyphBase);
+
+void
+
+ExaCheckPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+                     int x, int y, unsigned int nglyph,
+                     CharInfoPtr * ppci, void *pglyphBase);
+
+void
+
+ExaCheckPushPixels(GCPtr pGC, PixmapPtr pBitmap,
+                   DrawablePtr pDrawable, int w, int h, int x, int y);
+
+void
+ ExaCheckCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+void
+
+ExaCheckGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
+                 unsigned int format, unsigned long planeMask, char *d);
+
+void
+
+ExaCheckGetSpans(DrawablePtr pDrawable,
+                 int wMax,
+                 DDXPointPtr ppt, int *pwidth, int nspans, char *pdstStart);
+
+void
+
+ExaCheckAddTraps(PicturePtr pPicture,
+                 INT16 x_off, INT16 y_off, int ntrap, xTrap * traps);
+
+/* exa_accel.c */
+
+static _X_INLINE Bool
+exaGCReadsDestination(DrawablePtr pDrawable, unsigned long planemask,
+                      unsigned int fillStyle, unsigned char alu,
+                      unsigned int clientClipType)
+{
+    return ((alu != GXcopy && alu != GXclear && alu != GXset &&
+             alu != GXcopyInverted) || fillStyle == FillStippled ||
+            clientClipType != CT_NONE ||
+            !EXA_PM_IS_SOLID(pDrawable, planemask));
+}
+
+void
+ exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+Bool
+
+exaFillRegionTiled(DrawablePtr pDrawable, RegionPtr pRegion, PixmapPtr pTile,
+                   DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
+                   unsigned int clientClipType);
+
+void
+
+exaGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
+            unsigned int format, unsigned long planeMask, char *d);
+
+RegionPtr
+
+exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
+            int srcx, int srcy, int width, int height, int dstx, int dsty);
+
+Bool
+
+exaHWCopyNtoN(DrawablePtr pSrcDrawable,
+              DrawablePtr pDstDrawable,
+              GCPtr pGC,
+              BoxPtr pbox,
+              int nbox, int dx, int dy, Bool reverse, Bool upsidedown);
+
+void
+
+exaCopyNtoN(DrawablePtr pSrcDrawable,
+            DrawablePtr pDstDrawable,
+            GCPtr pGC,
+            BoxPtr pbox,
+            int nbox,
+            int dx,
+            int dy,
+            Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern const GCOps exaOps;
+
+void
+
+ExaCheckComposite(CARD8 op,
+                  PicturePtr pSrc,
+                  PicturePtr pMask,
+                  PicturePtr pDst,
+                  INT16 xSrc,
+                  INT16 ySrc,
+                  INT16 xMask,
+                  INT16 yMask,
+                  INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+void
+
+ExaCheckGlyphs(CARD8 op,
+               PicturePtr pSrc,
+               PicturePtr pDst,
+               PictFormatPtr maskFormat,
+               INT16 xSrc,
+               INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+/* exa_offscreen.c */
+void
+ ExaOffscreenSwapOut(ScreenPtr pScreen);
+
+void
+ ExaOffscreenSwapIn(ScreenPtr pScreen);
+
+ExaOffscreenArea *ExaOffscreenDefragment(ScreenPtr pScreen);
+
+Bool
+ exaOffscreenInit(ScreenPtr pScreen);
+
+void
+ ExaOffscreenFini(ScreenPtr pScreen);
+
+/* exa.c */
+Bool
+ ExaDoPrepareAccess(PixmapPtr pPixmap, int index);
+
+void
+ exaPrepareAccess(DrawablePtr pDrawable, int index);
+
+void
+ exaFinishAccess(DrawablePtr pDrawable, int index);
+
+void
+ exaDestroyPixmap(PixmapPtr pPixmap);
+
+void
+ exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2);
+
+void
+
+exaGetDrawableDeltas(DrawablePtr pDrawable, PixmapPtr pPixmap,
+                     int *xp, int *yp);
+
+Bool
+ exaPixmapHasGpuCopy(PixmapPtr p);
+
+PixmapPtr
+ exaGetOffscreenPixmap(DrawablePtr pDrawable, int *xp, int *yp);
+
+PixmapPtr
+ exaGetDrawablePixmap(DrawablePtr pDrawable);
+
+void
+
+exaSetFbPitch(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
+              int w, int h, int bpp);
+
+void
+
+exaSetAccelBlock(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
+                 int w, int h, int bpp);
+
+void
+ exaDoMigration(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+Bool
+ exaPixmapIsPinned(PixmapPtr pPix);
+
+extern const GCFuncs exaGCFuncs;
+
+/* exa_classic.c */
+PixmapPtr
+
+exaCreatePixmap_classic(ScreenPtr pScreen, int w, int h, int depth,
+                        unsigned usage_hint);
+
+Bool
+
+exaModifyPixmapHeader_classic(PixmapPtr pPixmap, int width, int height,
+                              int depth, int bitsPerPixel, int devKind,
+                              void *pPixData);
+
+Bool
+ exaDestroyPixmap_classic(PixmapPtr pPixmap);
+
+Bool
+ exaPixmapHasGpuCopy_classic(PixmapPtr pPixmap);
+
+/* exa_driver.c */
+PixmapPtr
+
+exaCreatePixmap_driver(ScreenPtr pScreen, int w, int h, int depth,
+                       unsigned usage_hint);
+
+Bool
+
+exaModifyPixmapHeader_driver(PixmapPtr pPixmap, int width, int height,
+                             int depth, int bitsPerPixel, int devKind,
+                             void *pPixData);
+
+Bool
+ exaDestroyPixmap_driver(PixmapPtr pPixmap);
+
+Bool
+ exaPixmapHasGpuCopy_driver(PixmapPtr pPixmap);
+
+/* exa_mixed.c */
+PixmapPtr
+
+exaCreatePixmap_mixed(ScreenPtr pScreen, int w, int h, int depth,
+                      unsigned usage_hint);
+
+Bool
+
+exaModifyPixmapHeader_mixed(PixmapPtr pPixmap, int width, int height, int depth,
+                            int bitsPerPixel, int devKind, void *pPixData);
+
+Bool
+ exaDestroyPixmap_mixed(PixmapPtr pPixmap);
+
+Bool
+ exaPixmapHasGpuCopy_mixed(PixmapPtr pPixmap);
+
+/* exa_migration_mixed.c */
+void
+ exaCreateDriverPixmap_mixed(PixmapPtr pPixmap);
+
+void
+ exaDoMigration_mixed(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+void
+ exaMoveInPixmap_mixed(PixmapPtr pPixmap);
+
+void
+ exaDamageReport_mixed(DamagePtr pDamage, RegionPtr pRegion, void *closure);
+
+void
+ exaPrepareAccessReg_mixed(PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+Bool
+exaSetSharedPixmapBacking_mixed(PixmapPtr pPixmap, void *handle);
+Bool
+exaSharePixmapBacking_mixed(PixmapPtr pPixmap, ScreenPtr slave, void **handle_p);
+
+/* exa_render.c */
+Bool
+ exaOpReadsDestination(CARD8 op);
+
+void
+
+exaComposite(CARD8 op,
+             PicturePtr pSrc,
+             PicturePtr pMask,
+             PicturePtr pDst,
+             INT16 xSrc,
+             INT16 ySrc,
+             INT16 xMask,
+             INT16 yMask, INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+void
+
+exaCompositeRects(CARD8 op,
+                  PicturePtr Src,
+                  PicturePtr pMask,
+                  PicturePtr pDst, int nrect, ExaCompositeRectPtr rects);
+
+void
+
+exaTrapezoids(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+              PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
+              int ntrap, xTrapezoid * traps);
+
+void
+
+exaTriangles(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+             PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
+             int ntri, xTriangle * tris);
+
+/* exa_glyph.c */
+void
+ exaGlyphsInit(ScreenPtr pScreen);
+
+void
+ exaGlyphsFini(ScreenPtr pScreen);
+
+void
+
+exaGlyphs(CARD8 op,
+          PicturePtr pSrc,
+          PicturePtr pDst,
+          PictFormatPtr maskFormat,
+          INT16 xSrc,
+          INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+/* exa_migration_classic.c */
+void
+ exaCopyDirtyToSys(ExaMigrationPtr migrate);
+
+void
+ exaCopyDirtyToFb(ExaMigrationPtr migrate);
+
+void
+ exaDoMigration_classic(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+void
+ exaPixmapSave(ScreenPtr pScreen, ExaOffscreenArea * area);
+
+void
+ exaMoveOutPixmap_classic(PixmapPtr pPixmap);
+
+void
+ exaMoveInPixmap_classic(PixmapPtr pPixmap);
+
+void
+ exaPrepareAccessReg_classic(PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+#endif                          /* EXAPRIV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/exa_priv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present_priv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present_priv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present_priv.h	(Revision 52145)
@@ -0,0 +1,303 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _PRESENT_PRIV_H_
+#define _PRESENT_PRIV_H_
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "misc.h"
+#include "list.h"
+#include "windowstr.h"
+#include "dixstruct.h"
+#include "present.h"
+#include <syncsdk.h>
+#include <syncsrv.h>
+#include <xfixes.h>
+#include <randrstr.h>
+
+extern int present_request;
+
+extern DevPrivateKeyRec present_screen_private_key;
+
+typedef struct present_fence *present_fence_ptr;
+
+typedef struct present_notify present_notify_rec, *present_notify_ptr;
+
+struct present_notify {
+    struct xorg_list    window_list;
+    WindowPtr           window;
+    CARD32              serial;
+};
+
+struct present_vblank {
+    struct xorg_list    window_list;
+    struct xorg_list    event_queue;
+    ScreenPtr           screen;
+    WindowPtr           window;
+    PixmapPtr           pixmap;
+    RegionPtr           valid;
+    RegionPtr           update;
+    RRCrtcPtr           crtc;
+    uint32_t            serial;
+    int16_t             x_off;
+    int16_t             y_off;
+    CARD16              kind;
+    uint64_t            event_id;
+    uint64_t            target_msc;
+    uint64_t            msc_offset;
+    present_fence_ptr   idle_fence;
+    present_fence_ptr   wait_fence;
+    present_notify_ptr  notifies;
+    int                 num_notifies;
+    Bool                queued;         /* on present_exec_queue */
+    Bool                flip;           /* planning on using flip */
+    Bool                flip_ready;     /* wants to flip, but waiting for previous flip or unflip */
+    Bool                sync_flip;      /* do flip synchronous to vblank */
+    Bool                abort_flip;     /* aborting this flip */
+};
+
+typedef struct present_screen_priv {
+    CloseScreenProcPtr          CloseScreen;
+    ConfigNotifyProcPtr         ConfigNotify;
+    DestroyWindowProcPtr        DestroyWindow;
+    ClipNotifyProcPtr           ClipNotify;
+
+    present_vblank_ptr          flip_pending;
+    uint64_t                    unflip_event_id;
+
+    uint32_t                    fake_interval;
+
+    /* Currently active flipped pixmap and fence */
+    RRCrtcPtr                   flip_crtc;
+    WindowPtr                   flip_window;
+    uint32_t                    flip_serial;
+    PixmapPtr                   flip_pixmap;
+    present_fence_ptr           flip_idle_fence;
+
+    present_screen_info_ptr     info;
+} present_screen_priv_rec, *present_screen_priv_ptr;
+
+#define wrap(priv,real,mem,func) {\
+    priv->mem = real->mem; \
+    real->mem = func; \
+}
+
+#define unwrap(priv,real,mem) {\
+    real->mem = priv->mem; \
+}
+
+static inline present_screen_priv_ptr
+present_screen_priv(ScreenPtr screen)
+{
+    return (present_screen_priv_ptr)dixLookupPrivate(&(screen)->devPrivates, &present_screen_private_key);
+}
+
+/*
+ * Each window has a list of clients and event masks
+ */
+typedef struct present_event *present_event_ptr;
+
+typedef struct present_event {
+    present_event_ptr next;
+    ClientPtr client;
+    WindowPtr window;
+    XID id;
+    int mask;
+} present_event_rec;
+
+typedef struct present_window_priv {
+    present_event_ptr      events;
+    RRCrtcPtr              crtc;        /* Last reported CRTC from get_ust_msc */
+    uint64_t               msc_offset;
+    uint64_t               msc;         /* Last reported MSC from the current crtc */
+    struct xorg_list       vblank;
+    struct xorg_list       notifies;
+} present_window_priv_rec, *present_window_priv_ptr;
+
+extern DevPrivateKeyRec present_window_private_key;
+
+static inline present_window_priv_ptr
+present_window_priv(WindowPtr window)
+{
+    return (present_window_priv_ptr)dixGetPrivate(&(window)->devPrivates, &present_window_private_key);
+}
+
+present_window_priv_ptr
+present_get_window_priv(WindowPtr window, Bool create);
+
+extern RESTYPE present_event_type;
+
+/*
+ * present.c
+ */
+int
+present_pixmap(WindowPtr window,
+               PixmapPtr pixmap,
+               CARD32 serial,
+               RegionPtr valid,
+               RegionPtr update,
+               int16_t x_off,
+               int16_t y_off,
+               RRCrtcPtr target_crtc,
+               SyncFence *wait_fence,
+               SyncFence *idle_fence,
+               uint32_t options,
+               uint64_t target_msc,
+               uint64_t divisor,
+               uint64_t remainder,
+               present_notify_ptr notifies,
+               int num_notifies);
+
+int
+present_notify_msc(WindowPtr window,
+                   CARD32 serial,
+                   uint64_t target_msc,
+                   uint64_t divisor,
+                   uint64_t remainder);
+
+void
+present_abort_vblank(ScreenPtr screen, RRCrtcPtr crtc, uint64_t event_id, uint64_t msc);
+
+void
+present_vblank_destroy(present_vblank_ptr vblank);
+
+void
+present_flip_destroy(ScreenPtr screen);
+
+void
+present_check_flip_window(WindowPtr window);
+
+RRCrtcPtr
+present_get_crtc(WindowPtr window);
+
+uint32_t
+present_query_capabilities(RRCrtcPtr crtc);
+
+Bool
+present_init(void);
+
+/*
+ * present_event.c
+ */
+
+void
+present_free_events(WindowPtr window);
+
+void
+present_send_config_notify(WindowPtr window, int x, int y, int w, int h, int bw, WindowPtr sibling);
+
+void
+present_send_complete_notify(WindowPtr window, CARD8 kind, CARD8 mode, CARD32 serial, uint64_t ust, uint64_t msc);
+
+void
+present_send_idle_notify(WindowPtr window, CARD32 serial, PixmapPtr pixmap, present_fence_ptr idle_fence);
+
+int
+present_select_input(ClientPtr client,
+                     CARD32 eid,
+                     WindowPtr window,
+                     CARD32 event_mask);
+
+Bool
+present_event_init(void);
+
+/*
+ * present_fake.c
+ */
+int
+present_fake_get_ust_msc(ScreenPtr screen, uint64_t *ust, uint64_t *msc);
+
+int
+present_fake_queue_vblank(ScreenPtr screen, uint64_t event_id, uint64_t msc);
+
+void
+present_fake_abort_vblank(ScreenPtr screen, uint64_t event_id, uint64_t msc);
+
+void
+present_fake_screen_init(ScreenPtr screen);
+
+void
+present_fake_queue_init(void);
+
+/*
+ * present_fence.c
+ */
+struct present_fence *
+present_fence_create(SyncFence *sync_fence);
+
+void
+present_fence_destroy(struct present_fence *present_fence);
+
+void
+present_fence_set_triggered(struct present_fence *present_fence);
+
+Bool
+present_fence_check_triggered(struct present_fence *present_fence);
+
+void
+present_fence_set_callback(struct present_fence *present_fence,
+                           void (*callback)(void *param),
+                           void *param);
+
+XID
+present_fence_id(struct present_fence *present_fence);
+
+/*
+ * present_notify.c
+ */
+void
+present_clear_window_notifies(WindowPtr window);
+
+void
+present_free_window_notify(present_notify_ptr notify);
+
+int
+present_add_window_notify(present_notify_ptr notify);
+
+int
+present_create_notifies(ClientPtr client, int num_notifies, xPresentNotify *x_notifies, present_notify_ptr *p_notifies);
+
+void
+present_destroy_notifies(present_notify_ptr notifies, int num_notifies);
+
+/*
+ * present_redirect.c
+ */
+
+WindowPtr
+present_redirect(ClientPtr client, WindowPtr target);
+
+/*
+ * present_request.c
+ */
+int
+proc_present_dispatch(ClientPtr client);
+
+int
+sproc_present_dispatch(ClientPtr client);
+
+/*
+ * present_screen.c
+ */
+
+#endif /*  _PRESENT_PRIV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present_priv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fourcc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fourcc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fourcc.h	(Revision 52145)
@@ -0,0 +1,159 @@
+
+/*
+ * Copyright (c) 2000-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+   This header file contains listings of STANDARD guids for video formats.
+   Please do not place non-registered, or incomplete entries in this file.
+   A list of some popular fourcc's are at: http://www.webartz.com/fourcc/
+   For an explanation of fourcc <-> guid mappings see RFC2361.
+*/
+
+#ifndef _XF86_FOURCC_H_
+#define _XF86_FOURCC_H_ 1
+
+#define FOURCC_YUY2 0x32595559
+#define XVIMAGE_YUY2 \
+   { \
+	FOURCC_YUY2, \
+        XvYUV, \
+	LSBFirst, \
+	{'Y','U','Y','2', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	16, \
+	XvPacked, \
+	1, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 1, 1, \
+	{'Y','U','Y','V', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_YV12 0x32315659
+#define XVIMAGE_YV12 \
+   { \
+	FOURCC_YV12, \
+        XvYUV, \
+	LSBFirst, \
+	{'Y','V','1','2', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	12, \
+	XvPlanar, \
+	3, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 2, 2, \
+	{'Y','V','U', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_I420 0x30323449
+#define XVIMAGE_I420 \
+   { \
+	FOURCC_I420, \
+        XvYUV, \
+	LSBFirst, \
+	{'I','4','2','0', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	12, \
+	XvPlanar, \
+	3, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 2, 2, \
+	{'Y','U','V', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_UYVY 0x59565955
+#define XVIMAGE_UYVY \
+   { \
+	FOURCC_UYVY, \
+        XvYUV, \
+	LSBFirst, \
+	{'U','Y','V','Y', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	16, \
+	XvPacked, \
+	1, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 1, 1, \
+	{'U','Y','V','Y', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_IA44 0x34344149
+#define XVIMAGE_IA44 \
+   { \
+        FOURCC_IA44, \
+        XvYUV, \
+        LSBFirst, \
+        {'I','A','4','4', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        8, \
+        XvPacked, \
+        1, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 1, 1, \
+        1, 1, 1, \
+        {'A','I', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+#define FOURCC_AI44 0x34344941
+#define XVIMAGE_AI44 \
+   { \
+        FOURCC_AI44, \
+        XvYUV, \
+        LSBFirst, \
+        {'A','I','4','4', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        8, \
+        XvPacked, \
+        1, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 1, 1, \
+        1, 1, 1, \
+        {'I','A', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+#endif                          /* _XF86_FOURCC_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fourcc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixesint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixesint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixesint.h	(Revision 52145)
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2010 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright ¬© 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XFIXESINT_H_
+#define _XFIXESINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/xfixesproto.h>
+#include "windowstr.h"
+#include "selection.h"
+#include "xfixes.h"
+
+extern int XFixesEventBase;
+
+typedef struct _XFixesClient {
+    CARD32 major_version;
+    CARD32 minor_version;
+} XFixesClientRec, *XFixesClientPtr;
+
+#define GetXFixesClient(pClient) ((XFixesClientPtr)dixLookupPrivate(&(pClient)->devPrivates, XFixesClientPrivateKey))
+
+extern int (*ProcXFixesVector[XFixesNumberRequests]) (ClientPtr);
+
+/* Save set */
+int
+ ProcXFixesChangeSaveSet(ClientPtr client);
+
+int
+ SProcXFixesChangeSaveSet(ClientPtr client);
+
+/* Selection events */
+int
+ ProcXFixesSelectSelectionInput(ClientPtr client);
+
+int
+ SProcXFixesSelectSelectionInput(ClientPtr client);
+
+void
+
+SXFixesSelectionNotifyEvent(xXFixesSelectionNotifyEvent * from,
+                            xXFixesSelectionNotifyEvent * to);
+Bool
+ XFixesSelectionInit(void);
+
+/* Cursor notification */
+Bool
+ XFixesCursorInit(void);
+
+int
+ ProcXFixesSelectCursorInput(ClientPtr client);
+
+int
+ SProcXFixesSelectCursorInput(ClientPtr client);
+
+void
+
+SXFixesCursorNotifyEvent(xXFixesCursorNotifyEvent * from,
+                         xXFixesCursorNotifyEvent * to);
+
+int
+ ProcXFixesGetCursorImage(ClientPtr client);
+
+int
+ SProcXFixesGetCursorImage(ClientPtr client);
+
+/* Cursor names (Version 2) */
+
+int
+ ProcXFixesSetCursorName(ClientPtr client);
+
+int
+ SProcXFixesSetCursorName(ClientPtr client);
+
+int
+ ProcXFixesGetCursorName(ClientPtr client);
+
+int
+ SProcXFixesGetCursorName(ClientPtr client);
+
+int
+ ProcXFixesGetCursorImageAndName(ClientPtr client);
+
+int
+ SProcXFixesGetCursorImageAndName(ClientPtr client);
+
+/* Cursor replacement (Version 2) */
+
+int
+ ProcXFixesChangeCursor(ClientPtr client);
+
+int
+ SProcXFixesChangeCursor(ClientPtr client);
+
+int
+ ProcXFixesChangeCursorByName(ClientPtr client);
+
+int
+ SProcXFixesChangeCursorByName(ClientPtr client);
+
+/* Region objects (Version 2* */
+Bool
+ XFixesRegionInit(void);
+
+int
+ ProcXFixesCreateRegion(ClientPtr client);
+
+int
+ SProcXFixesCreateRegion(ClientPtr client);
+
+int
+ ProcXFixesCreateRegionFromBitmap(ClientPtr client);
+
+int
+ SProcXFixesCreateRegionFromBitmap(ClientPtr client);
+
+int
+ ProcXFixesCreateRegionFromWindow(ClientPtr client);
+
+int
+ SProcXFixesCreateRegionFromWindow(ClientPtr client);
+
+int
+ ProcXFixesCreateRegionFromGC(ClientPtr client);
+
+int
+ SProcXFixesCreateRegionFromGC(ClientPtr client);
+
+int
+ ProcXFixesCreateRegionFromPicture(ClientPtr client);
+
+int
+ SProcXFixesCreateRegionFromPicture(ClientPtr client);
+
+int
+ ProcXFixesDestroyRegion(ClientPtr client);
+
+int
+ SProcXFixesDestroyRegion(ClientPtr client);
+
+int
+ ProcXFixesSetRegion(ClientPtr client);
+
+int
+ SProcXFixesSetRegion(ClientPtr client);
+
+int
+ ProcXFixesCopyRegion(ClientPtr client);
+
+int
+ SProcXFixesCopyRegion(ClientPtr client);
+
+int
+ ProcXFixesCombineRegion(ClientPtr client);
+
+int
+ SProcXFixesCombineRegion(ClientPtr client);
+
+int
+ ProcXFixesInvertRegion(ClientPtr client);
+
+int
+ SProcXFixesInvertRegion(ClientPtr client);
+
+int
+ ProcXFixesTranslateRegion(ClientPtr client);
+
+int
+ SProcXFixesTranslateRegion(ClientPtr client);
+
+int
+ ProcXFixesRegionExtents(ClientPtr client);
+
+int
+ SProcXFixesRegionExtents(ClientPtr client);
+
+int
+ ProcXFixesFetchRegion(ClientPtr client);
+
+int
+ SProcXFixesFetchRegion(ClientPtr client);
+
+int
+ ProcXFixesSetGCClipRegion(ClientPtr client);
+
+int
+ SProcXFixesSetGCClipRegion(ClientPtr client);
+
+int
+ ProcXFixesSetWindowShapeRegion(ClientPtr client);
+
+int
+ SProcXFixesSetWindowShapeRegion(ClientPtr client);
+
+int
+ ProcXFixesSetPictureClipRegion(ClientPtr client);
+
+int
+ SProcXFixesSetPictureClipRegion(ClientPtr client);
+
+int
+ ProcXFixesExpandRegion(ClientPtr client);
+
+int
+ SProcXFixesExpandRegion(ClientPtr client);
+
+int
+ PanoramiXFixesSetGCClipRegion(ClientPtr client);
+
+int
+ PanoramiXFixesSetWindowShapeRegion(ClientPtr client);
+
+int
+ PanoramiXFixesSetPictureClipRegion(ClientPtr client);
+
+/* Cursor Visibility (Version 4) */
+
+int
+ ProcXFixesHideCursor(ClientPtr client);
+
+int
+ SProcXFixesHideCursor(ClientPtr client);
+
+int
+ ProcXFixesShowCursor(ClientPtr client);
+
+int
+ SProcXFixesShowCursor(ClientPtr client);
+
+/* Version 5 */
+
+int
+ ProcXFixesCreatePointerBarrier(ClientPtr client);
+
+int
+ SProcXFixesCreatePointerBarrier(ClientPtr client);
+
+int
+ ProcXFixesDestroyPointerBarrier(ClientPtr client);
+
+int
+ SProcXFixesDestroyPointerBarrier(ClientPtr client);
+
+/* Xinerama */
+#ifdef PANORAMIX
+extern int (*PanoramiXSaveXFixesVector[XFixesNumberRequests]) (ClientPtr);
+void PanoramiXFixesInit(void);
+void PanoramiXFixesReset(void);
+#endif
+
+#endif                          /* _XFIXESINT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xfixesint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessCommon.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessCommon.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessCommon.h	(Revision 52145)
@@ -0,0 +1,284 @@
+/*
+ * Common internal rootless definitions and code
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ * Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdint.h>
+#ifndef _ROOTLESSCOMMON_H
+#define _ROOTLESSCOMMON_H
+
+#include "misc.h"
+#include "rootless.h"
+#include "fb.h"
+
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+// Debug output, or not.
+#ifdef ROOTLESSDEBUG
+#define RL_DEBUG_MSG ErrorF
+#else
+#define RL_DEBUG_MSG(a, ...)
+#endif
+
+// Global variables
+extern DevPrivateKeyRec rootlessGCPrivateKeyRec;
+
+#define rootlessGCPrivateKey (&rootlessGCPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessScreenPrivateKeyRec;
+
+#define rootlessScreenPrivateKey (&rootlessScreenPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessWindowPrivateKeyRec;
+
+#define rootlessWindowPrivateKey (&rootlessWindowPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessWindowOldPixmapPrivateKeyRec;
+
+#define rootlessWindowOldPixmapPrivateKey (&rootlessWindowOldPixmapPrivateKeyRec)
+
+// RootlessGCRec: private per-gc data
+typedef struct {
+    GCFuncs *originalFuncs;
+    GCOps *originalOps;
+} RootlessGCRec;
+
+// RootlessScreenRec: per-screen private data
+typedef struct _RootlessScreenRec {
+    // Rootless implementation functions
+    RootlessFrameProcsPtr imp;
+
+    // Wrapped screen functions
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    CloseScreenProcPtr CloseScreen;
+
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    MoveWindowProcPtr MoveWindow;
+    ResizeWindowProcPtr ResizeWindow;
+    RestackWindowProcPtr RestackWindow;
+    ReparentWindowProcPtr ReparentWindow;
+    ChangeBorderWidthProcPtr ChangeBorderWidth;
+    PositionWindowProcPtr PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+
+    CreateGCProcPtr CreateGC;
+    CopyWindowProcPtr CopyWindow;
+    GetImageProcPtr GetImage;
+    SourceValidateProcPtr SourceValidate;
+
+    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
+    ValidateTreeProcPtr ValidateTree;
+
+    SetShapeProcPtr SetShape;
+
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+
+    InstallColormapProcPtr InstallColormap;
+    UninstallColormapProcPtr UninstallColormap;
+    StoreColorsProcPtr StoreColors;
+
+    void *pixmap_data;
+    unsigned int pixmap_data_size;
+
+    ColormapPtr colormap;
+
+    void *redisplay_timer;
+    unsigned int redisplay_timer_set:1;
+    unsigned int redisplay_queued:1;
+    unsigned int redisplay_expired:1;
+    unsigned int colormap_changed:1;
+} RootlessScreenRec, *RootlessScreenPtr;
+
+// "Definition of the Porting Layer for the X11 Sample Server" says
+// unwrap and rewrap of screen functions is unnecessary, but
+// screen->CreateGC changes after a call to cfbCreateGC.
+
+#define SCREEN_UNWRAP(screen, fn) \
+    screen->fn = SCREENREC(screen)->fn;
+
+#define SCREEN_WRAP(screen, fn) \
+    SCREENREC(screen)->fn = screen->fn; \
+    screen->fn = Rootless##fn
+
+// Accessors for screen and window privates
+
+#define SCREENREC(pScreen) ((RootlessScreenRec *) \
+    dixLookupPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey))
+
+#define SETSCREENREC(pScreen, v) \
+    dixSetPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey, v)
+
+#define WINREC(pWin) ((RootlessWindowRec *) \
+    dixLookupPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey))
+
+#define SETWINREC(pWin, v) \
+    dixSetPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey, v)
+
+// Call a rootless implementation function.
+// Many rootless implementation functions are allowed to be NULL.
+#define CallFrameProc(pScreen, proc, params)            \
+    if (SCREENREC(pScreen)->frameProcs.proc) {          \
+        RL_DEBUG_MSG("calling frame proc " #proc " ");  \
+        SCREENREC(pScreen)->frameProcs.proc params;     \
+    }
+
+// BoxRec manipulators
+// Copied from shadowfb
+
+#define TRIM_BOX(box, pGC) { \
+    BoxPtr extents = &pGC->pCompositeClip->extents;\
+    if(box.x1 < extents->x1) box.x1 = extents->x1; \
+    if(box.x2 > extents->x2) box.x2 = extents->x2; \
+    if(box.y1 < extents->y1) box.y1 = extents->y1; \
+    if(box.y2 > extents->y2) box.y2 = extents->y2; \
+}
+
+#define TRANSLATE_BOX(box, pDraw) { \
+    box.x1 += pDraw->x; \
+    box.x2 += pDraw->x; \
+    box.y1 += pDraw->y; \
+    box.y2 += pDraw->y; \
+}
+
+#define TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC) { \
+    TRANSLATE_BOX(box, pDraw); \
+    TRIM_BOX(box, pGC); \
+}
+
+#define BOX_NOT_EMPTY(box) \
+    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))
+
+// HUGE_ROOT and NORMAL_ROOT
+// We don't want to clip windows to the edge of the screen.
+// HUGE_ROOT temporarily makes the root window really big.
+// This is needed as a wrapper around any function that calls
+// SetWinSize or SetBorderSize which clip a window against its
+// parents, including the root.
+
+extern RegionRec rootlessHugeRoot;
+
+#define HUGE_ROOT(pWin)                         \
+    do {                                        \
+        WindowPtr w = pWin;                     \
+        while (w->parent)                       \
+            w = w->parent;                      \
+        saveRoot = w->winSize;                  \
+        w->winSize = rootlessHugeRoot;          \
+    } while (0)
+
+#define NORMAL_ROOT(pWin)                       \
+    do {                                        \
+        WindowPtr w = pWin;                     \
+        while (w->parent)                       \
+            w = w->parent;                      \
+        w->winSize = saveRoot;                  \
+    } while (0)
+
+// Returns TRUE if this window is a top-level window (i.e. child of the root)
+// The root is not a top-level window.
+#define IsTopLevel(pWin) \
+    ((pWin)  &&  (pWin)->parent  &&  !(pWin)->parent->parent)
+
+// Returns TRUE if this window is a root window
+#define IsRoot(pWin) \
+    ((pWin) == (pWin)->drawable.pScreen->root)
+
+/*
+ * SetPixmapBaseToScreen
+ *  Move the given pixmap's base address to where pixel (0, 0)
+ *  would be if the pixmap's actual data started at (x, y).
+ *  Can't access the bits before the first word of the drawable's data in
+ *  rootless mode, so make sure our base address is always 32-bit aligned.
+ */
+#define SetPixmapBaseToScreen(pix, _x, _y) {                                \
+    PixmapPtr   _pPix = (PixmapPtr) (pix);                                  \
+    _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -              \
+                            ((int)(_x) * _pPix->drawable.bitsPerPixel/8 +   \
+                             (int)(_y) * _pPix->devKind);                   \
+    if (_pPix->drawable.bitsPerPixel != FB_UNIT) {                          \
+        size_t _diff = ((size_t) _pPix->devPrivate.ptr) &               \
+                         (FB_UNIT / CHAR_BIT - 1);                          \
+        _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -          \
+                                _diff;                                      \
+        _pPix->drawable.x = _diff /                                         \
+                            (_pPix->drawable.bitsPerPixel / CHAR_BIT);      \
+    }                                                                       \
+}
+
+// Returns TRUE if this window is visible inside a frame
+// (e.g. it is visible and has a top-level or root parent)
+Bool IsFramedWindow(WindowPtr pWin);
+
+// Routines that cause regions to get redrawn.
+// DamageRegion and DamageRect are in global coordinates.
+// DamageBox is in window-local coordinates.
+void RootlessDamageRegion(WindowPtr pWindow, RegionPtr pRegion);
+void RootlessDamageRect(WindowPtr pWindow, int x, int y, int w, int h);
+void RootlessDamageBox(WindowPtr pWindow, BoxPtr pBox);
+void RootlessRedisplay(WindowPtr pWindow);
+void RootlessRedisplayScreen(ScreenPtr pScreen);
+
+void RootlessQueueRedisplay(ScreenPtr pScreen);
+
+/* Return the colormap currently installed on the given screen. */
+ColormapPtr RootlessGetColormap(ScreenPtr pScreen);
+
+/* Convert colormap to ARGB. */
+Bool RootlessResolveColormap(ScreenPtr pScreen, int first_color,
+                             int n_colors, uint32_t * colors);
+
+void RootlessFlushWindowColormap(WindowPtr pWin);
+void RootlessFlushScreenColormaps(ScreenPtr pScreen);
+
+// Move a window to its proper location on the screen.
+void RootlessRepositionWindow(WindowPtr pWin);
+
+// Move the window to it's correct place in the physical stacking order.
+void RootlessReorderWindow(WindowPtr pWin);
+
+void RootlessScreenExpose(ScreenPtr pScreen);
+void RootlessHideAllWindows(void);
+void RootlessShowAllWindows(void);
+void RootlessUpdateRooted(Bool state);
+
+void RootlessEnableRoot(ScreenPtr pScreen);
+void RootlessDisableRoot(ScreenPtr pScreen);
+
+void RootlessSetPixmapOfAncestors(WindowPtr pWin);
+
+#endif                          /* _ROOTLESSCOMMON_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rootlessCommon.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Modes.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Modes.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Modes.h	(Revision 52145)
@@ -0,0 +1,117 @@
+/*
+ * Copyright ¬© 2006 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *
+ */
+
+#ifndef _XF86MODES_H_
+#define _XF86MODES_H_
+
+#include <stddef.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "xf86.h"
+#include "xorgVersion.h"
+#include "edid.h"
+#include "xf86Parser.h"
+
+extern _X_EXPORT double xf86ModeHSync(const DisplayModeRec * mode);
+extern _X_EXPORT double xf86ModeVRefresh(const DisplayModeRec * mode);
+extern _X_EXPORT unsigned int xf86ModeBandwidth(DisplayModePtr mode, int depth);
+
+extern _X_EXPORT int
+ xf86ModeWidth(const DisplayModeRec * mode, Rotation rotation);
+
+extern _X_EXPORT int
+ xf86ModeHeight(const DisplayModeRec * mode, Rotation rotation);
+
+extern _X_EXPORT DisplayModePtr xf86DuplicateMode(const DisplayModeRec * pMode);
+extern _X_EXPORT DisplayModePtr xf86DuplicateModes(ScrnInfoPtr pScrn,
+                                                   DisplayModePtr modeList);
+extern _X_EXPORT void xf86SetModeDefaultName(DisplayModePtr mode);
+extern _X_EXPORT void xf86SetModeCrtc(DisplayModePtr p, int adjustFlags);
+extern _X_EXPORT Bool xf86ModesEqual(const DisplayModeRec * pMode1,
+                                     const DisplayModeRec * pMode2);
+extern _X_EXPORT void xf86PrintModeline(int scrnIndex, DisplayModePtr mode);
+extern _X_EXPORT DisplayModePtr xf86ModesAdd(DisplayModePtr modes,
+                                             DisplayModePtr new);
+
+extern _X_EXPORT DisplayModePtr xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC);
+extern _X_EXPORT DisplayModePtr xf86CVTMode(int HDisplay, int VDisplay,
+                                            float VRefresh, Bool Reduced,
+                                            Bool Interlaced);
+extern _X_EXPORT DisplayModePtr xf86GTFMode(int h_pixels, int v_lines,
+                                            float freq, int interlaced,
+                                            int margins);
+
+extern _X_EXPORT Bool
+ xf86ModeIsReduced(const DisplayModeRec * mode);
+
+extern _X_EXPORT void
+ xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList, int flags);
+
+extern _X_EXPORT void
+
+xf86ValidateModesClocks(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+                        int *min, int *max, int n_ranges);
+
+extern _X_EXPORT void
+
+xf86ValidateModesSize(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+                      int maxX, int maxY, int maxPitch);
+
+extern _X_EXPORT void
+ xf86ValidateModesSync(ScrnInfoPtr pScrn, DisplayModePtr modeList, MonPtr mon);
+
+extern _X_EXPORT void
+
+xf86ValidateModesBandwidth(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+                           unsigned int bandwidth, int depth);
+
+extern _X_EXPORT void
+ xf86ValidateModesReducedBlanking(ScrnInfoPtr pScrn, DisplayModePtr modeList);
+
+extern _X_EXPORT void
+
+xf86PruneInvalidModes(ScrnInfoPtr pScrn, DisplayModePtr * modeList,
+                      Bool verbose);
+
+extern _X_EXPORT DisplayModePtr xf86PruneDuplicateModes(DisplayModePtr modes);
+
+extern _X_EXPORT void
+ xf86ValidateModesUserConfig(ScrnInfoPtr pScrn, DisplayModePtr modeList);
+
+extern _X_EXPORT DisplayModePtr
+xf86GetMonitorModes(ScrnInfoPtr pScrn, XF86ConfMonitorPtr conf_monitor);
+
+extern _X_EXPORT DisplayModePtr xf86GetDefaultModes(void);
+
+extern _X_EXPORT void
+xf86SaveModeContents(DisplayModePtr intern, const DisplayModeRec *mode);
+
+extern _X_EXPORT void
+ xf86DDCApplyQuirks(int scrnIndex, xf86MonPtr DDC);
+
+#endif                          /* _XF86MODES_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Modes.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extinit.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extinit.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extinit.h	(Revision 52145)
@@ -0,0 +1,189 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/*
+ * Copyright (C) 1994-2003 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+ * of the Software, and to permit persons to whom the Software is furnished to do
+ * so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FIT-
+ * NESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall not
+ * be used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from the XFree86 Project.
+ */
+
+#ifndef EXTINIT_H
+#define EXTINIT_H
+
+#include "extnsionst.h"
+
+#ifdef COMPOSITE
+extern _X_EXPORT Bool noCompositeExtension;
+extern void CompositeExtensionInit(void);
+#endif
+
+#ifdef DAMAGE
+extern _X_EXPORT Bool noDamageExtension;
+extern void DamageExtensionInit(void);
+#endif
+
+#if defined(DBE)
+extern _X_EXPORT Bool noDbeExtension;
+extern void DbeExtensionInit(void);
+#endif
+
+#if defined(DPMSExtension)
+#include <X11/extensions/dpmsconst.h>
+extern _X_EXPORT Bool noDPMSExtension;
+extern void DPMSExtensionInit(void);
+#endif
+
+extern Bool noGEExtension;
+extern void GEExtensionInit(void);
+
+#ifdef GLXEXT
+extern _X_EXPORT Bool noGlxExtension;
+#endif
+
+#ifdef PANORAMIX
+#include <X11/extensions/panoramiXproto.h>
+extern _X_EXPORT Bool noPanoramiXExtension;
+extern void PanoramiXExtensionInit(void);
+#endif
+
+#ifdef RANDR
+extern _X_EXPORT Bool noRRExtension;
+extern void RRExtensionInit(void);
+#endif
+
+#if defined(XRECORD)
+extern void RecordExtensionInit(void);
+#endif
+
+extern _X_EXPORT Bool noRenderExtension;
+extern void RenderExtensionInit(void);
+
+#if defined(RES)
+#include <X11/extensions/XResproto.h>
+extern _X_EXPORT Bool noResExtension;
+extern void ResExtensionInit(void);
+#endif
+
+#if defined(SCREENSAVER)
+#include <X11/extensions/saver.h>
+extern _X_EXPORT Bool noScreenSaverExtension;
+extern void ScreenSaverExtensionInit(void);
+#endif
+
+#include <X11/extensions/shapeproto.h>
+extern void ShapeExtensionInit(void);
+
+#ifdef MITSHM
+#include <X11/extensions/shm.h>
+#include <X11/extensions/shmproto.h>
+extern _X_EXPORT Bool noMITShmExtension;
+extern void ShmExtensionInit(void);
+#endif
+
+extern void SyncExtensionInit(void);
+
+extern void XCMiscExtensionInit(void);
+
+#ifdef XCSECURITY
+#include <X11/extensions/secur.h>
+#include "securitysrv.h"
+extern _X_EXPORT Bool noSecurityExtension;
+extern void SecurityExtensionInit(void);
+#endif
+
+#ifdef XF86BIGFONT
+#include <X11/extensions/xf86bigfproto.h>
+extern _X_EXPORT Bool noXFree86BigfontExtension;
+extern void XFree86BigfontExtensionInit(void);
+#endif
+
+extern void BigReqExtensionInit(void);
+
+extern _X_EXPORT Bool noXFixesExtension;
+extern void XFixesExtensionInit(void);
+
+extern void XInputExtensionInit(void);
+extern _X_EXPORT void AssignTypeAndName(DeviceIntPtr dev,
+                                        Atom type,
+                                        const char *name);
+
+#include <X11/extensions/XKB.h>
+extern void XkbExtensionInit(void);
+
+#if defined(XSELINUX)
+#include "xselinux.h"
+extern _X_EXPORT Bool noSELinuxExtension;
+extern void SELinuxExtensionInit(void);
+#endif
+
+#ifdef XTEST
+#include <X11/extensions/xtestconst.h>
+#include <X11/extensions/xtestproto.h>
+extern void XTestExtensionInit(void);
+#endif
+
+#ifdef INXQUARTZ
+extern _X_EXPORT Bool noPseudoramiXExtension;
+extern void PseudoramiXExtensionInit(void);
+#endif
+
+#if defined(XV)
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/XvMC.h>
+extern _X_EXPORT Bool noXvExtension;
+extern void XvExtensionInit(void);
+extern void XvMCExtensionInit(void);
+#endif
+
+#if defined(DRI3)
+#include <X11/extensions/dri3proto.h>
+extern void dri3_extension_init(void);
+#endif
+
+#if defined(PRESENT)
+#include <X11/extensions/presentproto.h>
+#include "presentext.h"
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extinit.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Privstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Privstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Privstr.h	(Revision 52145)
@@ -0,0 +1,170 @@
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the private XFree86 data structures/types.
+ * None of the data structures here should be used by video drivers.
+ */
+
+#ifndef _XF86PRIVSTR_H
+#define _XF86PRIVSTR_H
+
+#include "xf86str.h"
+
+typedef enum {
+    LogNone,
+    LogFlush,
+    LogSync
+} Log;
+
+typedef enum {
+    XF86_GlxVisualsMinimal,
+    XF86_GlxVisualsTypical,
+    XF86_GlxVisualsAll,
+} XF86_GlxVisuals;
+
+/*
+ * xf86InfoRec contains global parameters which the video drivers never
+ * need to access.  Global parameters which the video drivers do need
+ * should be individual globals.
+ */
+
+typedef struct {
+    int consoleFd;
+    int vtno;
+
+    /* event handler part */
+    int lastEventTime;
+    Bool vtRequestsPending;
+#ifdef sun
+    int vtPendingNum;
+#endif
+    Bool dontVTSwitch;
+    Bool autoVTSwitch;
+    Bool ShareVTs;
+    Bool dontZap;
+    Bool dontZoom;
+    Bool notrapSignals;         /* don't exit cleanly - die at fault */
+    Bool caughtSignal;
+
+    /* graphics part */
+    ScreenPtr currentScreen;
+#if defined(CSRG_BASED) || defined(__FreeBSD_kernel__)
+    int consType;               /* Which console driver? */
+#endif
+
+    /* Other things */
+    Bool allowMouseOpenFail;
+    Bool vidModeEnabled;        /* VidMode extension enabled */
+    Bool vidModeAllowNonLocal;  /* allow non-local VidMode
+                                 * connections */
+    Bool miscModInDevEnabled;   /* Allow input devices to be
+                                 * changed */
+    Bool miscModInDevAllowNonLocal;
+    Bool useSIGIO;              /* Use SIGIO for handling
+                                   input device events */
+    Pix24Flags pixmap24;
+    MessageType pix24From;
+    Bool pmFlag;
+    Log log;
+    Bool disableRandR;
+    MessageType randRFrom;
+    Bool aiglx;
+    MessageType aiglxFrom;
+    XF86_GlxVisuals glxVisuals;
+    MessageType glxVisualsFrom;
+
+    Bool useDefaultFontPath;
+    MessageType useDefaultFontPathFrom;
+    Bool ignoreABI;
+
+    Bool forceInputDevices;     /* force xorg.conf or built-in input devices */
+    Bool autoAddDevices;        /* Whether to succeed NIDR, or ignore. */
+    Bool autoEnableDevices;     /* Whether to enable, or let the client
+                                 * control. */
+
+    Bool dri2;
+    MessageType dri2From;
+
+    Bool autoAddGPU;
+} xf86InfoRec, *xf86InfoPtr;
+
+#ifdef DPMSExtension
+/* Private info for DPMS */
+typedef struct {
+    CloseScreenProcPtr CloseScreen;
+    Bool Enabled;
+    int Flags;
+} DPMSRec, *DPMSPtr;
+#endif
+
+#ifdef XF86VIDMODE
+/* Private info for Video Mode Extentsion */
+typedef struct {
+    DisplayModePtr First;
+    DisplayModePtr Next;
+    int Flags;
+    CloseScreenProcPtr CloseScreen;
+} VidModeRec, *VidModePtr;
+#endif
+
+/* Information for root window properties. */
+typedef struct _RootWinProp {
+    struct _RootWinProp *next;
+    const char *name;
+    Atom type;
+    short format;
+    long size;
+    void *data;
+} RootWinProp, *RootWinPropPtr;
+
+/* ISC's cc can't handle ~ of UL constants, so explicitly type cast them. */
+#define XLED1   ((unsigned long) 0x00000001)
+#define XLED2   ((unsigned long) 0x00000002)
+#define XLED3   ((unsigned long) 0x00000004)
+#define XLED4	((unsigned long) 0x00000008)
+#define XCAPS   ((unsigned long) 0x20000000)
+#define XNUM    ((unsigned long) 0x40000000)
+#define XSCR    ((unsigned long) 0x80000000)
+#define XCOMP	((unsigned long) 0x00008000)
+
+/* BSD console driver types (consType) */
+#if defined(CSRG_BASED) || defined(__FreeBSD_kernel__)
+#define PCCONS		   0
+#define CODRV011	   1
+#define CODRV01X	   2
+#define SYSCONS		   8
+#define PCVT		  16
+#define WSCONS		  32
+#endif
+
+/* Root window property to tell clients whether our VT is currently active.
+ * Name chosen to match the "XFree86_VT" property. */
+#define HAS_VT_ATOM_NAME "XFree86_has_VT"
+
+#endif                          /* _XF86PRIVSTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Privstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xorgVersion.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xorgVersion.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xorgVersion.h	(Revision 52145)
@@ -0,0 +1,49 @@
+
+/*
+ * Copyright (c) 2004, X.Org Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef XORG_VERSION_H
+#define XORG_VERSION_H
+
+#ifndef XORG_VERSION_CURRENT
+#error
+#endif
+
+#define XORG_VERSION_NUMERIC(major,minor,patch,snap,dummy) \
+	(((major) * 10000000) + ((minor) * 100000) + ((patch) * 1000) + snap)
+
+#define XORG_GET_MAJOR_VERSION(vers)	((vers) / 10000000)
+#define XORG_GET_MINOR_VERSION(vers)	(((vers) % 10000000) / 100000)
+#define XORG_GET_PATCH_VERSION(vers)	(((vers) % 100000) / 1000)
+#define XORG_GET_SNAP_VERSION(vers)	((vers) % 1000)
+
+#define XORG_VERSION_MAJOR	XORG_GET_MAJOR_VERSION(XORG_VERSION_CURRENT)
+#define XORG_VERSION_MINOR	XORG_GET_MINOR_VERSION(XORG_VERSION_CURRENT)
+#define XORG_VERSION_PATCH	XORG_GET_PATCH_VERSION(XORG_VERSION_CURRENT)
+#define XORG_VERSION_SNAP	XORG_GET_SNAP_VERSION(XORG_VERSION_CURRENT)
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xorgVersion.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/resource.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/resource.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/resource.h	(Revision 52145)
@@ -0,0 +1,287 @@
+/***********************************************************
+
+Copyright 1987, 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef RESOURCE_H
+#define RESOURCE_H 1
+#include "misc.h"
+#include "dixaccess.h"
+
+/*****************************************************************
+ * STUFF FOR RESOURCES 
+ *****************************************************************/
+
+/* classes for Resource routines */
+
+typedef uint32_t RESTYPE;
+
+#define RC_VANILLA	((RESTYPE)0)
+#define RC_CACHED	((RESTYPE)1<<31)
+#define RC_DRAWABLE	((RESTYPE)1<<30)
+/*  Use class RC_NEVERRETAIN for resources that should not be retained
+ *  regardless of the close down mode when the client dies.  (A client's
+ *  event selections on objects that it doesn't own are good candidates.)
+ *  Extensions can use this too!
+ */
+#define RC_NEVERRETAIN	((RESTYPE)1<<29)
+#define RC_LASTPREDEF	RC_NEVERRETAIN
+#define RC_ANY		(~(RESTYPE)0)
+
+/* types for Resource routines */
+
+#define RT_WINDOW	((RESTYPE)1|RC_DRAWABLE)
+#define RT_PIXMAP	((RESTYPE)2|RC_DRAWABLE)
+#define RT_GC		((RESTYPE)3)
+#undef RT_FONT
+#undef RT_CURSOR
+#define RT_FONT		((RESTYPE)4)
+#define RT_CURSOR	((RESTYPE)5)
+#define RT_COLORMAP	((RESTYPE)6)
+#define RT_CMAPENTRY	((RESTYPE)7)
+#define RT_OTHERCLIENT	((RESTYPE)8|RC_NEVERRETAIN)
+#define RT_PASSIVEGRAB	((RESTYPE)9|RC_NEVERRETAIN)
+#define RT_LASTPREDEF	((RESTYPE)9)
+#define RT_NONE		((RESTYPE)0)
+
+/* bits and fields within a resource id */
+#define RESOURCE_AND_CLIENT_COUNT   29  /* 29 bits for XIDs */
+#if MAXCLIENTS == 64
+#define RESOURCE_CLIENT_BITS	6
+#endif
+#if MAXCLIENTS == 128
+#define RESOURCE_CLIENT_BITS	7
+#endif
+#if MAXCLIENTS == 256
+#define RESOURCE_CLIENT_BITS	8
+#endif
+#if MAXCLIENTS == 512
+#define RESOURCE_CLIENT_BITS	9
+#endif
+/* client field offset */
+#define CLIENTOFFSET	    (RESOURCE_AND_CLIENT_COUNT - RESOURCE_CLIENT_BITS)
+/* resource field */
+#define RESOURCE_ID_MASK	((1 << CLIENTOFFSET) - 1)
+/* client field */
+#define RESOURCE_CLIENT_MASK	(((1 << RESOURCE_CLIENT_BITS) - 1) << CLIENTOFFSET)
+/* extract the client mask from an XID */
+#define CLIENT_BITS(id) ((id) & RESOURCE_CLIENT_MASK)
+/* extract the client id from an XID */
+#define CLIENT_ID(id) ((int)(CLIENT_BITS(id) >> CLIENTOFFSET))
+#define SERVER_BIT		(Mask)0x40000000        /* use illegal bit */
+
+#ifdef INVALID
+#undef INVALID                  /* needed on HP/UX */
+#endif
+
+/* Invalid resource id */
+#define INVALID	(0)
+
+#define BAD_RESOURCE 0xe0000000
+
+#define rClient(obj) (clients[CLIENT_ID((obj)->resource)])
+
+/* Resource state callback */
+extern _X_EXPORT CallbackListPtr ResourceStateCallback;
+
+typedef enum { ResourceStateAdding,
+    ResourceStateFreeing
+} ResourceState;
+
+typedef struct {
+    ResourceState state;
+    XID id;
+    RESTYPE type;
+    void *value;
+} ResourceStateInfoRec;
+
+typedef int (*DeleteType) (void */*value */ ,
+                           XID /*id */ );
+
+typedef void (*FindResType) (void */*value */ ,
+                             XID /*id */ ,
+                             void */*cdata */ );
+
+typedef void (*FindAllRes) (void */*value */ ,
+                            XID /*id */ ,
+                            RESTYPE /*type */ ,
+                            void */*cdata */ );
+
+typedef Bool (*FindComplexResType) (void */*value */ ,
+                                    XID /*id */ ,
+                                    void */*cdata */ );
+
+/* Structure for estimating resource memory usage. Memory usage
+ * consists of space allocated for the resource itself and of
+ * references to other resources. Currently the most important use for
+ * this structure is to estimate pixmap usage of different resources
+ * more accurately. */
+typedef struct {
+    /* Size of resource itself. Zero if not implemented. */
+    unsigned long resourceSize;
+    /* Size attributed to pixmap references from the resource. */
+    unsigned long pixmapRefSize;
+    /* Number of references to this resource; typically 1 */
+    unsigned long refCnt;
+} ResourceSizeRec, *ResourceSizePtr;
+
+typedef void (*SizeType)(void */*value*/,
+                         XID /*id*/,
+                         ResourceSizePtr /*size*/);
+
+extern _X_EXPORT RESTYPE CreateNewResourceType(DeleteType /*deleteFunc */ ,
+                                               const char * /*name */ );
+
+typedef void (*FindTypeSubResources)(void */* value */,
+                                     FindAllRes /* func */,
+                                     void */* cdata */);
+
+extern _X_EXPORT SizeType GetResourceTypeSizeFunc(
+    RESTYPE /*type*/);
+
+extern _X_EXPORT void SetResourceTypeFindSubResFunc(
+    RESTYPE /*type*/, FindTypeSubResources /*findFunc*/);
+
+extern _X_EXPORT void SetResourceTypeSizeFunc(
+    RESTYPE /*type*/, SizeType /*sizeFunc*/);
+
+extern _X_EXPORT void SetResourceTypeErrorValue(
+    RESTYPE /*type*/, int /*errorValue*/);
+
+extern _X_EXPORT RESTYPE CreateNewResourceClass(void);
+
+extern _X_EXPORT Bool InitClientResources(ClientPtr /*client */ );
+
+extern _X_EXPORT XID FakeClientID(int /*client */ );
+
+/* Quartz support on Mac OS X uses the CarbonCore
+   framework whose AddResource function conflicts here. */
+#ifdef __APPLE__
+#define AddResource Darwin_X_AddResource
+#endif
+extern _X_EXPORT Bool AddResource(XID /*id */ ,
+                                  RESTYPE /*type */ ,
+                                  void */*value */ );
+
+extern _X_EXPORT void FreeResource(XID /*id */ ,
+                                   RESTYPE /*skipDeleteFuncType */ );
+
+extern _X_EXPORT void FreeResourceByType(XID /*id */ ,
+                                         RESTYPE /*type */ ,
+                                         Bool /*skipFree */ );
+
+extern _X_EXPORT Bool ChangeResourceValue(XID /*id */ ,
+                                          RESTYPE /*rtype */ ,
+                                          void */*value */ );
+
+extern _X_EXPORT void FindClientResourcesByType(ClientPtr /*client */ ,
+                                                RESTYPE /*type */ ,
+                                                FindResType /*func */ ,
+                                                void */*cdata */ );
+
+extern _X_EXPORT void FindAllClientResources(ClientPtr /*client */ ,
+                                             FindAllRes /*func */ ,
+                                             void */*cdata */ );
+
+/** @brief Iterate through all subresources of a resource.
+
+    @note The XID argument provided to the FindAllRes function
+          may be 0 for subresources that don't have an XID */
+extern _X_EXPORT void FindSubResources(void */*resource*/,
+                                       RESTYPE /*type*/,
+                                       FindAllRes /*func*/,
+                                       void */*cdata*/);
+
+extern _X_EXPORT void FreeClientNeverRetainResources(ClientPtr /*client */ );
+
+extern _X_EXPORT void FreeClientResources(ClientPtr /*client */ );
+
+extern _X_EXPORT void FreeAllResources(void);
+
+extern _X_EXPORT Bool LegalNewID(XID /*id */ ,
+                                 ClientPtr /*client */ );
+
+extern _X_EXPORT void *LookupClientResourceComplex(ClientPtr client,
+                                                     RESTYPE type,
+                                                     FindComplexResType func,
+                                                     void *cdata);
+
+extern _X_EXPORT int dixLookupResourceByType(void **result,
+                                             XID id,
+                                             RESTYPE rtype,
+                                             ClientPtr client,
+                                             Mask access_mode);
+
+extern _X_EXPORT int dixLookupResourceByClass(void **result,
+                                              XID id,
+                                              RESTYPE rclass,
+                                              ClientPtr client,
+                                              Mask access_mode);
+
+extern _X_EXPORT void GetXIDRange(int /*client */ ,
+                                  Bool /*server */ ,
+                                  XID * /*minp */ ,
+                                  XID * /*maxp */ );
+
+extern _X_EXPORT unsigned int GetXIDList(ClientPtr /*client */ ,
+                                         unsigned int /*count */ ,
+                                         XID * /*pids */ );
+
+extern _X_EXPORT RESTYPE lastResourceType;
+extern _X_EXPORT RESTYPE TypeMask;
+
+/** @brief A hashing function to be used for hashing resource IDs
+
+    @param id The resource ID to hash
+    @param numBits The number of bits in the resulting hash. Must be >=0.
+
+    @note This function is really only for handling
+    INITHASHSIZE..MAXHASHSIZE bit hashes, but will handle any number
+    of bits by either masking numBits lower bits of the ID or by
+    providing at most MAXHASHSIZE hashes.
+*/
+extern _X_EXPORT int HashResourceID(XID id,
+                                    int numBits);
+
+#endif /* RESOURCE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/resource.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxfbconfig.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxfbconfig.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxfbconfig.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLXFBCONFIG_H
+
+#include <GL/glxint.h>
+
+int AreFBConfigsMatch(__GLXFBConfig * c1, __GLXFBConfig * c2);
+__GLXFBConfig *FindMatchingFBConfig(__GLXFBConfig * c, __GLXFBConfig * configs,
+                                    int nconfigs);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxfbconfig.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getkmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getkmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getkmap.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETKMAP_H
+#define GETKMAP_H 1
+
+int SProcXGetDeviceKeyMapping(ClientPtr /* client */
+    );
+
+int ProcXGetDeviceKeyMapping(ClientPtr  /* client */
+    );
+
+void SRepXGetDeviceKeyMapping(ClientPtr /* client */ ,
+                              int /* size */ ,
+                              xGetDeviceKeyMappingReply *       /* rep */
+    );
+
+#endif                          /* GETKMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getkmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfctl.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfctl.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfctl.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETFCTL_H
+#define GETFCTL_H 1
+
+int SProcXGetFeedbackControl(ClientPtr  /* client */
+    );
+
+int ProcXGetFeedbackControl(ClientPtr   /* client */
+    );
+
+void SRepXGetFeedbackControl(ClientPtr /* client */ ,
+                             int /* size */ ,
+                             xGetFeedbackControlReply * /* rep */
+    );
+
+#endif                          /* GETFCTL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getfctl.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcmap.h	(Revision 52145)
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2002-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Header file for colormap support.  \see dmxcmap.c. */
+
+#ifndef DMXCMAP_H
+#define DMXCMAP_H
+
+#include "colormapst.h"
+
+/** Colormap private area. */
+typedef struct _dmxColormapPriv {
+    Colormap cmap;
+} dmxColormapPrivRec, *dmxColormapPrivPtr;
+
+extern Bool dmxCreateColormap(ColormapPtr pColormap);
+extern void dmxDestroyColormap(ColormapPtr pColormap);
+extern void dmxInstallColormap(ColormapPtr pColormap);
+extern void dmxStoreColors(ColormapPtr pColormap, int ndef, xColorItem * pdef);
+
+extern Bool dmxCreateDefColormap(ScreenPtr pScreen);
+
+extern Bool dmxBECreateColormap(ColormapPtr pColormap);
+extern Bool dmxBEFreeColormap(ColormapPtr pColormap);
+
+/** Set colormap private structure. */
+#define DMX_SET_COLORMAP_PRIV(_pCMap, _pCMapPriv)			\
+    dixSetPrivate(&(_pCMap)->devPrivates, dmxColormapPrivateKey, _pCMapPriv)
+
+/** Get colormap private structure. */
+#define DMX_GET_COLORMAP_PRIV(_pCMap) (dmxColormapPrivPtr)		\
+    dixLookupPrivate(&(_pCMap)->devPrivates, dmxColormapPrivateKey)
+
+#endif                          /* DMXCMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprop.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprop.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprop.h	(Revision 52145)
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2002,2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for property support.  \see dmxprop.c */
+
+#ifndef _DMXPROP_H_
+#define _DMXPROP_H_
+extern int dmxPropertyDisplay(DMXScreenInfo * dmxScreen);
+extern void dmxPropertyWindow(DMXScreenInfo * dmxScreen);
+extern void *dmxPropertyIterate(DMXScreenInfo * start,
+                                void *(*f) (DMXScreenInfo * dmxScreen,
+                                            void *closure), void *closure);
+extern int dmxPropertySameDisplay(DMXScreenInfo * dmxScreen, const char *name);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxprop.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86CursorPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86CursorPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86CursorPriv.h	(Revision 52145)
@@ -0,0 +1,50 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86CURSORPRIV_H
+#define _XF86CURSORPRIV_H
+
+#include "xf86Cursor.h"
+#include "mipointrst.h"
+
+typedef struct {
+    Bool SWCursor;
+    Bool isUp;
+    Bool showTransparent;
+    short HotX;
+    short HotY;
+    short x;
+    short y;
+    CursorPtr CurrentCursor, CursorToRestore;
+    xf86CursorInfoPtr CursorInfoPtr;
+    CloseScreenProcPtr CloseScreen;
+    RecolorCursorProcPtr RecolorCursor;
+    InstallColormapProcPtr InstallColormap;
+    QueryBestSizeProcPtr QueryBestSize;
+    miPointerSpriteFuncPtr spriteFuncs;
+    Bool PalettedCursor;
+    ColormapPtr pInstalledMap;
+    Bool (*SwitchMode) (ScrnInfoPtr, DisplayModePtr);
+    xf86EnableDisableFBAccessProc *EnableDisableFBAccess;
+    CursorPtr SavedCursor;
+
+    /* Number of requests to force HW cursor */
+    int ForceHWCursorCount;
+    Bool HWCursorForced;
+
+    void *transparentData;
+} xf86CursorScreenRec, *xf86CursorScreenPtr;
+
+Bool xf86SetCursor(ScreenPtr pScreen, CursorPtr pCurs, int x, int y);
+void xf86SetTransparentCursor(ScreenPtr pScreen);
+void xf86MoveCursor(ScreenPtr pScreen, int x, int y);
+void xf86RecolorCursor(ScreenPtr pScreen, CursorPtr pCurs, Bool displayed);
+Bool xf86InitHardwareCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr);
+
+extern _X_EXPORT DevPrivateKeyRec xf86CursorScreenKeyRec;
+
+#define xf86CursorScreenKey (&xf86CursorScreenKeyRec)
+
+#endif                          /* _XF86CURSORPRIV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86CursorPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncstr.h	(Revision 52145)
@@ -0,0 +1,98 @@
+/*
+ * Copyright ¬© 2010 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _MISYNCSTR_H_
+#define _MISYNCSTR_H_
+
+#include "dix.h"
+#include "misync.h"
+#include "scrnintstr.h"
+#include <X11/extensions/syncconst.h>
+
+#define CARD64 XSyncValue       /* XXX temporary! need real 64 bit values for Alpha */
+
+/* Sync object types */
+#define SYNC_COUNTER		0
+#define SYNC_FENCE		1
+
+typedef struct _SyncObject {
+    ClientPtr client;           /* Owning client. 0 for system counters */
+    struct _SyncTriggerList *pTriglist; /* list of triggers */
+    XID id;                     /* resource ID */
+    unsigned char type;         /* SYNC_* */
+    Bool beingDestroyed;        /* in process of going away */
+} SyncObject;
+
+typedef struct _SyncCounter {
+    SyncObject sync;            /* Common sync object data */
+    CARD64 value;               /* counter value */
+    struct _SysCounterInfo *pSysCounterInfo;    /* NULL if not a system counter */
+} SyncCounter;
+
+struct _SyncFence {
+    SyncObject sync;            /* Common sync object data */
+    ScreenPtr pScreen;          /* Screen of this fence object */
+    SyncFenceFuncsRec funcs;    /* Funcs for performing ops on fence */
+    Bool triggered;             /* fence state */
+    PrivateRec *devPrivates;    /* driver-specific per-fence data */
+};
+
+struct _SyncTrigger {
+    SyncObject *pSync;
+    CARD64 wait_value;          /* wait value */
+    unsigned int value_type;    /* Absolute or Relative */
+    unsigned int test_type;     /* transition or Comparision type */
+    CARD64 test_value;          /* trigger event threshold value */
+    Bool (*CheckTrigger) (struct _SyncTrigger * /*pTrigger */ ,
+                          CARD64        /*newval */
+        );
+    void (*TriggerFired) (struct _SyncTrigger * /*pTrigger */
+        );
+    void (*CounterDestroyed) (struct _SyncTrigger *     /*pTrigger */
+        );
+};
+
+typedef struct _SyncTriggerList {
+    SyncTrigger *pTrigger;
+    struct _SyncTriggerList *next;
+} SyncTriggerList;
+
+extern DevPrivateKeyRec miSyncScreenPrivateKey;
+
+#define SYNC_SCREEN_PRIV(pScreen) 				\
+    (SyncScreenPrivPtr) dixLookupPrivate(&pScreen->devPrivates,	\
+					 &miSyncScreenPrivateKey)
+
+typedef struct _syncScreenPriv {
+    /* Wrappable sync-specific screen functions */
+    SyncScreenFuncsRec funcs;
+
+    /* Wrapped screen functions */
+    CloseScreenProcPtr CloseScreen;
+} SyncScreenPrivRec, *SyncScreenPrivPtr;
+
+#endif                          /* _MISYNCSTR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/c2p_core.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/c2p_core.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/c2p_core.h	(Revision 52145)
@@ -0,0 +1,187 @@
+/*
+ *  Fast C2P (Chunky-to-Planar) Conversion
+ *
+ *  NOTES:
+ *    - This code was inspired by Scout's C2P tutorial
+ *    - It assumes to run on a big endian system
+ *
+ *  Copyright ¬© 2003-2008 Geert Uytterhoeven
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a
+ *  copy of this software and associated documentation files (the "Software"),
+ *  to deal in the Software without restriction, including without limitation
+ *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ *  Software is furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice (including the next
+ *  paragraph) shall be included in all copies or substantial portions of the
+ *  Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ *  DEALINGS IN THE SOFTWARE.
+ */
+
+
+    /*
+     *  Basic transpose step
+     */
+
+static inline void _transp(CARD32 d[], unsigned int i1, unsigned int i2,
+                           unsigned int shift, CARD32 mask)
+{
+    CARD32 t = (d[i1] ^ (d[i2] >> shift)) & mask;
+
+    d[i1] ^= t;
+    d[i2] ^= t << shift;
+}
+
+
+static inline void c2p_unsupported(void) {
+    BUG_WARN(1);
+}
+
+static inline CARD32 get_mask(unsigned int n)
+{
+    switch (n) {
+    case 1:
+        return 0x55555555;
+
+    case 2:
+        return 0x33333333;
+
+    case 4:
+        return 0x0f0f0f0f;
+
+    case 8:
+        return 0x00ff00ff;
+
+    case 16:
+        return 0x0000ffff;
+    }
+
+    c2p_unsupported();
+    return 0;
+}
+
+
+    /*
+     *  Transpose operations on 8 32-bit words
+     */
+
+static inline void transp8(CARD32 d[], unsigned int n, unsigned int m)
+{
+    CARD32 mask = get_mask(n);
+
+    switch (m) {
+    case 1:
+        /* First n x 1 block */
+        _transp(d, 0, 1, n, mask);
+        /* Second n x 1 block */
+        _transp(d, 2, 3, n, mask);
+        /* Third n x 1 block */
+        _transp(d, 4, 5, n, mask);
+        /* Fourth n x 1 block */
+        _transp(d, 6, 7, n, mask);
+        return;
+
+    case 2:
+        /* First n x 2 block */
+        _transp(d, 0, 2, n, mask);
+        _transp(d, 1, 3, n, mask);
+        /* Second n x 2 block */
+        _transp(d, 4, 6, n, mask);
+        _transp(d, 5, 7, n, mask);
+        return;
+
+    case 4:
+        /* Single n x 4 block */
+        _transp(d, 0, 4, n, mask);
+        _transp(d, 1, 5, n, mask);
+        _transp(d, 2, 6, n, mask);
+        _transp(d, 3, 7, n, mask);
+        return;
+    }
+
+    c2p_unsupported();
+}
+
+
+    /*
+     *  Transpose operations on 4 32-bit words
+     */
+
+static inline void transp4(CARD32 d[], unsigned int n, unsigned int m)
+{
+    CARD32 mask = get_mask(n);
+
+    switch (m) {
+    case 1:
+        /* First n x 1 block */
+        _transp(d, 0, 1, n, mask);
+        /* Second n x 1 block */
+        _transp(d, 2, 3, n, mask);
+        return;
+
+    case 2:
+        /* Single n x 2 block */
+        _transp(d, 0, 2, n, mask);
+        _transp(d, 1, 3, n, mask);
+        return;
+    }
+
+    c2p_unsupported();
+}
+
+
+    /*
+     *  Transpose operations on 4 32-bit words (reverse order)
+     */
+
+static inline void transp4x(CARD32 d[], unsigned int n, unsigned int m)
+{
+    CARD32 mask = get_mask(n);
+
+    switch (m) {
+    case 2:
+        /* Single n x 2 block */
+        _transp(d, 2, 0, n, mask);
+        _transp(d, 3, 1, n, mask);
+        return;
+    }
+
+    c2p_unsupported();
+}
+
+
+    /*
+     *  Transpose operations on 2 32-bit words
+     */
+
+static inline void transp2(CARD32 d[], unsigned int n)
+{
+    CARD32 mask = get_mask(n);
+
+    /* Single n x 1 block */
+    _transp(d, 0, 1, n, mask);
+    return;
+}
+
+
+    /*
+     *  Transpose operations on 2 32-bit words (reverse order)
+     */
+
+static inline void transp2x(CARD32 d[], unsigned int n)
+{
+    CARD32 mask = get_mask(n);
+
+    /* Single n x 1 block */
+    _transp(d, 1, 0, n, mask);
+    return;
+}

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/c2p_core.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/privates.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/privates.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/privates.h	(Revision 52145)
@@ -0,0 +1,361 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef PRIVATES_H
+#define PRIVATES_H 1
+
+#include <X11/Xdefs.h>
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include "misc.h"
+
+/*****************************************************************
+ * STUFF FOR PRIVATES
+ *****************************************************************/
+
+typedef struct _Private PrivateRec, *PrivatePtr;
+
+typedef enum {
+    /* XSELinux uses the same private keys for numerous objects */
+    PRIVATE_XSELINUX,
+
+    /* Otherwise, you get a private in just the requested structure
+     */
+    /* These can have objects created before all of the keys are registered */
+    PRIVATE_SCREEN,
+    PRIVATE_EXTENSION,
+    PRIVATE_COLORMAP,
+    PRIVATE_DEVICE,
+
+    /* These cannot have any objects before all relevant keys are registered */
+    PRIVATE_CLIENT,
+    PRIVATE_PROPERTY,
+    PRIVATE_SELECTION,
+    PRIVATE_WINDOW,
+    PRIVATE_PIXMAP,
+    PRIVATE_GC,
+    PRIVATE_CURSOR,
+    PRIVATE_CURSOR_BITS,
+
+    /* extension privates */
+    PRIVATE_DAMAGE,
+    PRIVATE_GLYPH,
+    PRIVATE_GLYPHSET,
+    PRIVATE_PICTURE,
+    PRIVATE_SYNC_FENCE,
+
+    /* last private type */
+    PRIVATE_LAST,
+} DevPrivateType;
+
+typedef struct _DevPrivateKeyRec {
+    int offset;
+    int size;
+    Bool initialized;
+    Bool allocated;
+    DevPrivateType type;
+    struct _DevPrivateKeyRec *next;
+} DevPrivateKeyRec, *DevPrivateKey;
+
+typedef struct _DevPrivateSetRec {
+    DevPrivateKey key;
+    unsigned offset;
+    int created;
+    int allocated;
+} DevPrivateSetRec, *DevPrivateSetPtr;
+
+typedef struct _DevScreenPrivateKeyRec {
+    DevPrivateKeyRec screenKey;
+} DevScreenPrivateKeyRec, *DevScreenPrivateKey;
+
+/*
+ * Let drivers know how to initialize private keys
+ */
+
+#define HAS_DEVPRIVATEKEYREC		1
+#define HAS_DIXREGISTERPRIVATEKEY	1
+
+/*
+ * Register a new private index for the private type.
+ *
+ * This initializes the specified key and optionally requests pre-allocated
+ * private space for your driver/module. If you request no extra space, you
+ * may set and get a single pointer value using this private key. Otherwise,
+ * you can get the address of the extra space and store whatever data you like
+ * there.
+ *
+ * You may call dixRegisterPrivateKey more than once on the same key, but the
+ * size and type must match or the server will abort.
+ *
+ * dixRegisterPrivateKey returns FALSE if it fails to allocate memory
+ * during its operation.
+ */
+extern _X_EXPORT Bool
+ dixRegisterPrivateKey(DevPrivateKey key, DevPrivateType type, unsigned size);
+
+/*
+ * Check whether a private key has been registered
+ */
+static inline Bool
+dixPrivateKeyRegistered(DevPrivateKey key)
+{
+    return key->initialized;
+}
+
+/*
+ * Get the address of the private storage.
+ *
+ * For keys with pre-defined storage, this gets the base of that storage
+ * Otherwise, it returns the place where the private pointer is stored.
+ */
+static inline void *
+dixGetPrivateAddr(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert(key->initialized);
+    return (char *) (*privates) + key->offset;
+}
+
+/*
+ * Fetch a private pointer stored in the object
+ *
+ * Returns the pointer stored with dixSetPrivate.
+ * This must only be used with keys that have
+ * no pre-defined storage
+ */
+static inline void *
+dixGetPrivate(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert(key->size == 0);
+    return *(void **) dixGetPrivateAddr(privates, key);
+}
+
+/*
+ * Associate 'val' with 'key' in 'privates' so that later calls to
+ * dixLookupPrivate(privates, key) will return 'val'.
+ */
+static inline void
+dixSetPrivate(PrivatePtr *privates, const DevPrivateKey key, void *val)
+{
+    assert(key->size == 0);
+    *(void **) dixGetPrivateAddr(privates, key) = val;
+}
+
+#include "dix.h"
+#include "resource.h"
+
+/*
+ * Lookup a pointer to the private record.
+ *
+ * For privates with defined storage, return the address of the
+ * storage. For privates without defined storage, return the pointer
+ * contents
+ */
+static inline void *
+dixLookupPrivate(PrivatePtr *privates, const DevPrivateKey key)
+{
+    if (key->size)
+        return dixGetPrivateAddr(privates, key);
+    else
+        return dixGetPrivate(privates, key);
+}
+
+/*
+ * Look up the address of the pointer to the storage
+ *
+ * This returns the place where the private pointer is stored,
+ * which is only valid for privates without predefined storage.
+ */
+static inline void **
+dixLookupPrivateAddr(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert(key->size == 0);
+    return (void **) dixGetPrivateAddr(privates, key);
+}
+
+extern _X_EXPORT Bool
+
+dixRegisterScreenPrivateKey(DevScreenPrivateKey key, ScreenPtr pScreen,
+                            DevPrivateType type, unsigned size);
+
+extern _X_EXPORT DevPrivateKey
+ _dixGetScreenPrivateKey(const DevScreenPrivateKey key, ScreenPtr pScreen);
+
+static inline void *
+dixGetScreenPrivateAddr(PrivatePtr *privates, const DevScreenPrivateKey key,
+                        ScreenPtr pScreen)
+{
+    return dixGetPrivateAddr(privates, _dixGetScreenPrivateKey(key, pScreen));
+}
+
+static inline void *
+dixGetScreenPrivate(PrivatePtr *privates, const DevScreenPrivateKey key,
+                    ScreenPtr pScreen)
+{
+    return dixGetPrivate(privates, _dixGetScreenPrivateKey(key, pScreen));
+}
+
+static inline void
+dixSetScreenPrivate(PrivatePtr *privates, const DevScreenPrivateKey key,
+                    ScreenPtr pScreen, void *val)
+{
+    dixSetPrivate(privates, _dixGetScreenPrivateKey(key, pScreen), val);
+}
+
+static inline void *
+dixLookupScreenPrivate(PrivatePtr *privates, const DevScreenPrivateKey key,
+                       ScreenPtr pScreen)
+{
+    return dixLookupPrivate(privates, _dixGetScreenPrivateKey(key, pScreen));
+}
+
+static inline void **
+dixLookupScreenPrivateAddr(PrivatePtr *privates, const DevScreenPrivateKey key,
+                           ScreenPtr pScreen)
+{
+    return dixLookupPrivateAddr(privates,
+                                _dixGetScreenPrivateKey(key, pScreen));
+}
+
+/*
+ * These functions relate to allocations related to a specific screen;
+ * space will only be available for objects allocated for use on that
+ * screen. As such, only objects which are related directly to a specific
+ * screen are candidates for allocation this way, this includes
+ * windows, pixmaps, gcs, pictures and colormaps. This key is
+ * used just like any other key using dixGetPrivate and friends.
+ *
+ * This is distinctly different from the ScreenPrivateKeys above which
+ * allocate space in global objects like cursor bits for a specific
+ * screen, allowing multiple screen-related chunks of storage in a
+ * single global object.
+ */
+
+#define HAVE_SCREEN_SPECIFIC_PRIVATE_KEYS       1
+
+extern _X_EXPORT Bool
+dixRegisterScreenSpecificPrivateKey(ScreenPtr pScreen, DevPrivateKey key,
+                                    DevPrivateType type, unsigned size);
+
+/* Clean up screen-specific privates before CloseScreen */
+extern void
+dixFreeScreenSpecificPrivates(ScreenPtr pScreen);
+
+/* Initialize screen-specific privates in AddScreen */
+extern void
+dixInitScreenSpecificPrivates(ScreenPtr pScreen);
+
+extern _X_EXPORT void *
+_dixAllocateScreenObjectWithPrivates(ScreenPtr pScreen,
+                                     unsigned size,
+                                     unsigned clear,
+                                     unsigned offset,
+                                     DevPrivateType type);
+
+#define dixAllocateScreenObjectWithPrivates(s, t, type) _dixAllocateScreenObjectWithPrivates(s, sizeof(t), sizeof(t), offsetof(t, devPrivates), type)
+
+extern _X_EXPORT int
+dixScreenSpecificPrivatesSize(ScreenPtr pScreen, DevPrivateType type);
+
+extern _X_EXPORT void
+_dixInitScreenPrivates(ScreenPtr pScreen, PrivatePtr *privates, void *addr, DevPrivateType type);
+
+#define dixInitScreenPrivates(s, o, v, type) _dixInitScreenPrivates(s, &(o)->devPrivates, (v), type);
+
+/*
+ * Allocates private data separately from main object.
+ *
+ * For objects created during server initialization, this allows those
+ * privates to be re-allocated as new private keys are registered.
+ *
+ * This includes screens, the serverClient, default colormaps and
+ * extensions entries.
+ */
+extern _X_EXPORT Bool
+ dixAllocatePrivates(PrivatePtr *privates, DevPrivateType type);
+
+/*
+ * Frees separately allocated private data
+ */
+extern _X_EXPORT void
+ dixFreePrivates(PrivatePtr privates, DevPrivateType type);
+
+/*
+ * Initialize privates by zeroing them
+ */
+extern _X_EXPORT void
+_dixInitPrivates(PrivatePtr *privates, void *addr, DevPrivateType type);
+
+#define dixInitPrivates(o, v, type) _dixInitPrivates(&(o)->devPrivates, (v), type);
+
+/*
+ * Clean up privates
+ */
+extern _X_EXPORT void
+ _dixFiniPrivates(PrivatePtr privates, DevPrivateType type);
+
+#define dixFiniPrivates(o,t)	_dixFiniPrivates((o)->devPrivates,t)
+
+/*
+ * Allocates private data at object creation time. Required
+ * for almost all objects, except for the list described
+ * above for dixAllocatePrivates.
+ */
+extern _X_EXPORT void *_dixAllocateObjectWithPrivates(unsigned size,
+                                                      unsigned clear,
+                                                      unsigned offset,
+                                                      DevPrivateType type);
+
+#define dixAllocateObjectWithPrivates(t, type) (t *) _dixAllocateObjectWithPrivates(sizeof(t), sizeof(t), offsetof(t, devPrivates), type)
+
+extern _X_EXPORT void
+
+_dixFreeObjectWithPrivates(void *object, PrivatePtr privates,
+                           DevPrivateType type);
+
+#define dixFreeObjectWithPrivates(o,t) _dixFreeObjectWithPrivates(o, (o)->devPrivates, t)
+
+/*
+ * Return size of privates for the specified type
+ */
+extern _X_EXPORT int
+ dixPrivatesSize(DevPrivateType type);
+
+/*
+ * Dump out private stats to ErrorF
+ */
+extern void
+ dixPrivateUsage(void);
+
+/*
+ * Resets the privates subsystem.  dixResetPrivates is called from the main loop
+ * before each server generation.  This function must only be called by main().
+ */
+extern _X_EXPORT void
+ dixResetPrivates(void);
+
+/*
+ * Looks up the offset where the devPrivates field is located.
+ *
+ * Returns -1 if the specified resource has no dev privates.
+ * The position of the devPrivates field varies by structure
+ * and calling code might only know the resource type, not the
+ * structure definition.
+ */
+extern _X_EXPORT int
+ dixLookupPrivateOffset(RESTYPE type);
+
+/*
+ * Convenience macro for adding an offset to an object pointer
+ * when making a call to one of the devPrivates functions
+ */
+#define DEVPRIV_AT(ptr, offset) ((PrivatePtr *)((char *)(ptr) + offset))
+
+#endif                          /* PRIVATES_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/privates.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpack.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpack.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpack.h	(Revision 52145)
@@ -0,0 +1,194 @@
+/*
+ *
+ * Copyright ¬© 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * Thanks to Daniel Chemko <dchemko@intrinsyc.com> for making the 90 and 180
+ * orientations work.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdlib.h>
+
+#include    <X11/X.h>
+#include    "scrnintstr.h"
+#include    "windowstr.h"
+#include    <X11/fonts/font.h>
+#include    "dixfontstr.h"
+#include    <X11/fonts/fontstruct.h>
+#include    "mi.h"
+#include    "regionstr.h"
+#include    "globals.h"
+#include    "gcstruct.h"
+#include    "shadow.h"
+#include    "fb.h"
+
+#define DANDEBUG         0
+
+#if ROTATE == 270
+
+#define SCRLEFT(x,y,w,h)    (pScreen->height - ((y) + (h)))
+#define SCRY(x,y,w,h)	    (x)
+#define SCRWIDTH(x,y,w,h)   (h)
+#define FIRSTSHA(x,y,w,h)   (((y) + (h) - 1) * shaStride + (x))
+#define STEPDOWN(x,y,w,h)   ((w)--)
+#define NEXTY(x,y,w,h)	    ((x)++)
+#define SHASTEPX(stride)    -(stride)
+#define SHASTEPY(stride)    (1)
+
+#elif ROTATE == 90
+
+#define SCRLEFT(x,y,w,h)    (y)
+#define SCRY(x,y,w,h)	    (pScreen->width - ((x) + (w)) - 1)
+#define SCRWIDTH(x,y,w,h)   (h)
+#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x + w - 1))
+#define STEPDOWN(x,y,w,h)   ((w)--)
+#define NEXTY(x,y,w,h)	    ((void)(x))
+#define SHASTEPX(stride)    (stride)
+#define SHASTEPY(stride)    (-1)
+
+#elif ROTATE == 180
+
+#define SCRLEFT(x,y,w,h)    (pScreen->width - ((x) + (w)))
+#define SCRY(x,y,w,h)	    (pScreen->height - ((y) + (h)) - 1)
+#define SCRWIDTH(x,y,w,h)   (w)
+#define FIRSTSHA(x,y,w,h)   ((y + h - 1) * shaStride + (x + w - 1))
+#define STEPDOWN(x,y,w,h)   ((h)--)
+#define NEXTY(x,y,w,h)	    ((void)(y))
+#define SHASTEPX(stride)    (-1)
+#define SHASTEPY(stride)    -(stride)
+
+#else
+
+#define SCRLEFT(x,y,w,h)    (x)
+#define SCRY(x,y,w,h)	    (y)
+#define SCRWIDTH(x,y,w,h)   (w)
+#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x))
+#define STEPDOWN(x,y,w,h)   ((h)--)
+#define NEXTY(x,y,w,h)	    ((y)++)
+#define SHASTEPX(stride)    (1)
+#define SHASTEPY(stride)    (stride)
+
+#endif
+
+void
+FUNC(ScreenPtr pScreen, shadowBufPtr pBuf)
+{
+    RegionPtr damage = shadowDamage(pBuf);
+    PixmapPtr pShadow = pBuf->pPixmap;
+    int nbox = RegionNumRects(damage);
+    BoxPtr pbox = RegionRects(damage);
+    FbBits *shaBits;
+    Data *shaBase, *shaLine, *sha;
+    FbStride shaStride;
+    int scrBase, scrLine, scr;
+    int shaBpp;
+    _X_UNUSED int shaXoff, shaYoff;
+    int x, y, w, h, width;
+    int i;
+    Data *winBase = NULL, *win;
+    CARD32 winSize;
+
+    fbGetDrawable(&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff,
+                  shaYoff);
+    shaBase = (Data *) shaBits;
+    shaStride = shaStride * sizeof(FbBits) / sizeof(Data);
+#if (DANDEBUG > 1)
+    ErrorF
+        ("-> Entering Shadow Update:\r\n   |- Origins: pShadow=%x, pScreen=%x, damage=%x\r\n   |- Metrics: shaStride=%d, shaBase=%x, shaBpp=%d\r\n   |                                                     \n",
+         pShadow, pScreen, damage, shaStride, shaBase, shaBpp);
+#endif
+    while (nbox--) {
+        x = pbox->x1;
+        y = pbox->y1;
+        w = (pbox->x2 - pbox->x1);
+        h = pbox->y2 - pbox->y1;
+
+#if (DANDEBUG > 2)
+        ErrorF
+            ("   |-> Redrawing box - Metrics: X=%d, Y=%d, Width=%d, Height=%d\n",
+             x, y, w, h);
+#endif
+        scrLine = SCRLEFT(x, y, w, h);
+        shaLine = shaBase + FIRSTSHA(x, y, w, h);
+
+        while (STEPDOWN(x, y, w, h)) {
+            winSize = 0;
+            scrBase = 0;
+            width = SCRWIDTH(x, y, w, h);
+            scr = scrLine;
+            sha = shaLine;
+#if (DANDEBUG > 3)
+            ErrorF("   |   |-> StepDown - Metrics: width=%d, scr=%x, sha=%x\n",
+                   width, scr, sha);
+#endif
+            while (width) {
+                /*  how much remains in this window */
+                i = scrBase + winSize - scr;
+                if (i <= 0 || scr < scrBase) {
+                    winBase = (Data *) (*pBuf->window) (pScreen,
+                                                        SCRY(x, y, w, h),
+                                                        scr * sizeof(Data),
+                                                        SHADOW_WINDOW_WRITE,
+                                                        &winSize,
+                                                        pBuf->closure);
+                    if (!winBase)
+                        return;
+                    scrBase = scr;
+                    winSize /= sizeof(Data);
+                    i = winSize;
+#if(DANDEBUG > 4)
+                    ErrorF
+                        ("   |   |   |-> Starting New Line - Metrics: winBase=%x, scrBase=%x, winSize=%d\r\n   |   |   |   Xstride=%d, Ystride=%d, w=%d h=%d\n",
+                         winBase, scrBase, winSize, SHASTEPX(shaStride),
+                         SHASTEPY(shaStride), w, h);
+#endif
+                }
+                win = winBase + (scr - scrBase);
+                if (i > width)
+                    i = width;
+                width -= i;
+                scr += i;
+#if(DANDEBUG > 5)
+                ErrorF
+                    ("   |   |   |-> Writing Line - Metrics: win=%x, sha=%x\n",
+                     win, sha);
+#endif
+                while (i--) {
+#if(DANDEBUG > 6)
+                    ErrorF
+                        ("   |   |   |-> Writing Pixel - Metrics: win=%x, sha=%d, remaining=%d\n",
+                         win, sha, i);
+#endif
+                    *win++ = *sha;
+                    sha += SHASTEPX(shaStride);
+                }               /*  i */
+            }                   /*  width */
+            shaLine += SHASTEPY(shaStride);
+            NEXTY(x, y, w, h);
+        }                       /*  STEPDOWN */
+        pbox++;
+    }                           /*  nbox */
+}

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shrotpack.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcmds.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcmds.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcmds.h	(Revision 52145)
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2011 Apple Inc.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __GLX_cmds_h__
+#define __GLX_cmds_h__
+
+extern int __glXBindSwapBarrierSGIX(__GLXclientState * cl, GLbyte * pc);
+extern int __glXCreateContextWithConfigSGIX(__GLXclientState * cl, GLbyte * pc);
+extern int __glXJoinSwapGroupSGIX(__GLXclientState * cl, GLbyte * pc);
+extern int __glXMakeCurrentReadSGI(__GLXclientState * cl, GLbyte * pc);
+extern int __glXQueryMaxSwapBarriersSGIX(__GLXclientState * cl, GLbyte * pc);
+
+#endif                          /* !__GLX_cmds_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcmds.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcommon.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcommon.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcommon.h	(Revision 52145)
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2002,2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to functions used by backend and console input devices.
+ * \see dmxcommon.c \see dmxbackend.c \see dmxconsole.c */
+
+#ifndef _DMXCOMMON_H_
+#define _DMXCOMMON_H_
+
+#define DMX_COMMON_OTHER                    \
+    Display                 *display;       \
+    Window                  window;         \
+    DMXScreenInfo           *be;            \
+    DMXLocalInputInfoPtr    dmxLocal;       \
+    int                     initPointerX;   \
+    int                     initPointerY;   \
+    long                    eventMask;      \
+    KeybdCtrl               kctrl;          \
+    PtrCtrl                 mctrl;          \
+    int                     kctrlset;       \
+    int                     mctrlset;       \
+    KeybdCtrl               savedKctrl;     \
+    XModifierKeymap         *savedModMap;   \
+    int                     stateSaved
+
+#define DMX_COMMON_XKB                      \
+    DMX_COMMON_OTHER;                       \
+    XkbDescPtr              xkb;            \
+    XkbIndicatorRec         savedIndicators
+
+#define DMX_COMMON_PRIVATE                  \
+    DMX_COMMON_XKB;                         \
+    XDevice                 *xi
+
+#define GETONLYPRIVFROMPRIVATE                                          \
+    myPrivate            *priv     = private
+
+#define GETPRIVFROMPRIVATE                                              \
+    GETONLYPRIVFROMPRIVATE;                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[priv->dmxLocal->inputIdx]
+
+#define GETDMXLOCALFROMPDEVICE                                          \
+    DevicePtr            pDev      = &pDevice->public;                  \
+    DMXLocalInputInfoPtr dmxLocal  = pDev->devicePrivate
+
+#define GETDMXINPUTFROMPRIV                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[priv->dmxLocal->inputIdx]
+
+#define GETDMXINPUTFROMPDEVICE                                          \
+    GETDMXLOCALFROMPDEVICE;                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[dmxLocal->inputIdx]
+
+#define GETDMXLOCALFROMPDEV                                             \
+    DMXLocalInputInfoPtr dmxLocal  = pDev->devicePrivate
+
+#define GETDMXINPUTFROMPDEV                                             \
+    GETDMXLOCALFROMPDEV;                                                \
+    DMXInputInfo         *dmxInput = &dmxInputs[dmxLocal->inputIdx]
+
+#define GETPRIVFROMPDEV                                                 \
+    GETDMXLOCALFROMPDEV;                                                \
+    myPrivate            *priv     = dmxLocal->private
+
+#define DMX_KEYBOARD_EVENT_MASK                                         \
+    (KeyPressMask | KeyReleaseMask | KeymapStateMask)
+
+#define DMX_POINTER_EVENT_MASK                                          \
+    (ButtonPressMask | ButtonReleaseMask | PointerMotionMask)
+
+extern void dmxCommonKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxCommonKbdGetMap(DevicePtr pDev,
+                               KeySymsPtr pKeySyms, CARD8 *pModMap);
+extern void dmxCommonKbdCtrl(DevicePtr pDev, KeybdCtrl * ctrl);
+extern void dmxCommonKbdBell(DevicePtr pDev, int percent,
+                             int volume, int pitch, int duration);
+extern int dmxCommonKbdOn(DevicePtr pDev);
+extern void dmxCommonKbdOff(DevicePtr pDev);
+extern void dmxCommonMouGetMap(DevicePtr pDev,
+                               unsigned char *map, int *nButtons);
+extern void dmxCommonMouCtrl(DevicePtr pDev, PtrCtrl * ctrl);
+extern int dmxCommonMouOn(DevicePtr pDev);
+extern void dmxCommonMouOff(DevicePtr pDev);
+extern int dmxFindPointerScreen(int x, int y);
+
+extern int dmxCommonOthOn(DevicePtr pDev);
+extern void dmxCommonOthOff(DevicePtr pDev);
+extern void dmxCommonOthGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+
+                                /* helper functions */
+extern void *dmxCommonCopyPrivate(DeviceIntPtr pDevice);
+extern void dmxCommonSaveState(void *private);
+extern void dmxCommonRestoreState(void *private);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxcommon.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3.h	(Revision 52145)
@@ -0,0 +1,77 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _DRI3_H_
+#define _DRI3_H_
+
+#include <xorg-server.h>
+
+#ifdef DRI3
+
+#include <X11/extensions/dri3proto.h>
+#include <randrstr.h>
+
+#define DRI3_SCREEN_INFO_VERSION        1
+
+typedef int (*dri3_open_proc)(ScreenPtr screen,
+                              RRProviderPtr provider,
+                              int *fd);
+
+typedef int (*dri3_open_client_proc)(ClientPtr client,
+                                     ScreenPtr screen,
+                                     RRProviderPtr provider,
+                                     int *fd);
+
+typedef PixmapPtr (*dri3_pixmap_from_fd_proc) (ScreenPtr screen,
+                                               int fd,
+                                               CARD16 width,
+                                               CARD16 height,
+                                               CARD16 stride,
+                                               CARD8 depth,
+                                               CARD8 bpp);
+
+typedef int (*dri3_fd_from_pixmap_proc) (ScreenPtr screen,
+                                         PixmapPtr pixmap,
+                                         CARD16 *stride,
+                                         CARD32 *size);
+
+typedef struct dri3_screen_info {
+    uint32_t                    version;
+
+    dri3_open_proc              open;
+    dri3_pixmap_from_fd_proc    pixmap_from_fd;
+    dri3_fd_from_pixmap_proc    fd_from_pixmap;
+
+    /* Version 1 */
+    dri3_open_client_proc       open_client;
+
+} dri3_screen_info_rec, *dri3_screen_info_ptr;
+
+extern _X_EXPORT Bool
+dri3_screen_init(ScreenPtr screen, dri3_screen_info_ptr info);
+
+extern _X_EXPORT int
+dri3_send_open_reply(ClientPtr client, int fd);
+
+#endif
+
+#endif /* _DRI3_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misync.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misync.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misync.h	(Revision 52145)
@@ -0,0 +1,100 @@
+/*
+ * Copyright ¬© 2010 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _MISYNC_H_
+#define _MISYNC_H_
+
+typedef struct _SyncFence SyncFence;
+typedef struct _SyncTrigger SyncTrigger;
+
+typedef void (*SyncScreenCreateFenceFunc) (ScreenPtr pScreen,
+                                           SyncFence * pFence,
+                                           Bool initially_triggered);
+typedef void (*SyncScreenDestroyFenceFunc) (ScreenPtr pScreen,
+                                            SyncFence * pFence);
+
+typedef struct _syncScreenFuncs {
+    SyncScreenCreateFenceFunc CreateFence;
+    SyncScreenDestroyFenceFunc DestroyFence;
+} SyncScreenFuncsRec, *SyncScreenFuncsPtr;
+
+
+extern _X_EXPORT void
+miSyncScreenCreateFence(ScreenPtr pScreen, SyncFence * pFence,
+                        Bool initially_triggered);
+extern _X_EXPORT void
+ miSyncScreenDestroyFence(ScreenPtr pScreen, SyncFence * pFence);
+
+typedef void (*SyncFenceSetTriggeredFunc) (SyncFence * pFence);
+typedef void (*SyncFenceResetFunc) (SyncFence * pFence);
+typedef Bool (*SyncFenceCheckTriggeredFunc) (SyncFence * pFence);
+typedef void (*SyncFenceAddTriggerFunc) (SyncTrigger * pTrigger);
+typedef void (*SyncFenceDeleteTriggerFunc) (SyncTrigger * pTrigger);
+
+typedef struct _syncFenceFuncs {
+    SyncFenceSetTriggeredFunc SetTriggered;
+    SyncFenceResetFunc Reset;
+    SyncFenceCheckTriggeredFunc CheckTriggered;
+    SyncFenceAddTriggerFunc AddTrigger;
+    SyncFenceDeleteTriggerFunc DeleteTrigger;
+} SyncFenceFuncsRec, *SyncFenceFuncsPtr;
+
+extern _X_EXPORT void
+
+miSyncInitFence(ScreenPtr pScreen, SyncFence * pFence,
+                Bool initially_triggered);
+extern _X_EXPORT void
+ miSyncDestroyFence(SyncFence * pFence);
+extern _X_EXPORT void
+ miSyncTriggerFence(SyncFence * pFence);
+
+extern _X_EXPORT SyncScreenFuncsPtr miSyncGetScreenFuncs(ScreenPtr pScreen);
+extern _X_EXPORT Bool
+ miSyncSetup(ScreenPtr pScreen);
+
+Bool
+miSyncFenceCheckTriggered(SyncFence * pFence);
+
+void
+miSyncFenceSetTriggered(SyncFence * pFence);
+
+void
+miSyncFenceReset(SyncFence * pFence);
+
+void
+miSyncFenceAddTrigger(SyncTrigger * pTrigger);
+
+void
+miSyncFenceDeleteTrigger(SyncTrigger * pTrigger);
+
+int
+miSyncInitFenceFromFD(DrawablePtr pDraw, SyncFence *pFence, int fd, BOOL initially_triggered);
+
+int
+miSyncFDFromFence(DrawablePtr pDraw, SyncFence *pFence);
+
+#endif                          /* _MISYNC_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misync.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h	(Revision 52145)
@@ -0,0 +1,657 @@
+/*
+ * edid.h: defines to parse an EDID block 
+ *
+ * This file contains all information to interpret a standard EDIC block 
+ * transmitted by a display device via DDC (Display Data Channel). So far 
+ * there is no information to deal with optional EDID blocks.  
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ */
+
+#ifndef _EDID_H_
+#define _EDID_H_
+
+#include <X11/Xmd.h>
+
+#ifndef _X_EXPORT
+#include <X11/Xfuncproto.h>
+#endif
+
+/* read complete EDID record */
+#define EDID1_LEN 128
+#define BITS_PER_BYTE 9
+#define NUM BITS_PER_BYTE*EDID1_LEN
+#define HEADER 6
+
+#define STD_TIMINGS 8
+#define DET_TIMINGS 4
+
+#ifdef _PARSE_EDID_
+
+/* header: 0x00 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x00  */
+#define HEADER_SECTION 0
+#define HEADER_LENGTH 8
+
+/* vendor section */
+#define VENDOR_SECTION (HEADER_SECTION + HEADER_LENGTH)
+#define V_MANUFACTURER 0
+#define V_PROD_ID (V_MANUFACTURER + 2)
+#define V_SERIAL (V_PROD_ID + 2)
+#define V_WEEK (V_SERIAL + 4)
+#define V_YEAR (V_WEEK + 1)
+#define VENDOR_LENGTH (V_YEAR + 1)
+
+/* EDID version */
+#define VERSION_SECTION (VENDOR_SECTION + VENDOR_LENGTH)
+#define V_VERSION 0
+#define V_REVISION (V_VERSION + 1)
+#define VERSION_LENGTH (V_REVISION + 1)
+
+/* display information */
+#define DISPLAY_SECTION (VERSION_SECTION + VERSION_LENGTH)
+#define D_INPUT 0
+#define D_HSIZE (D_INPUT + 1)
+#define D_VSIZE (D_HSIZE + 1)
+#define D_GAMMA (D_VSIZE + 1)
+#define FEAT_S (D_GAMMA + 1)
+#define D_RG_LOW (FEAT_S + 1)
+#define D_BW_LOW (D_RG_LOW + 1)
+#define D_REDX (D_BW_LOW + 1)
+#define D_REDY (D_REDX + 1)
+#define D_GREENX (D_REDY + 1)
+#define D_GREENY (D_GREENX + 1)
+#define D_BLUEX (D_GREENY + 1)
+#define D_BLUEY (D_BLUEX + 1)
+#define D_WHITEX (D_BLUEY + 1)
+#define D_WHITEY (D_WHITEX + 1)
+#define DISPLAY_LENGTH (D_WHITEY + 1)
+
+/* supported VESA and other standard timings */
+#define ESTABLISHED_TIMING_SECTION (DISPLAY_SECTION + DISPLAY_LENGTH)
+#define E_T1 0
+#define E_T2 (E_T1 + 1)
+#define E_TMANU (E_T2 + 1)
+#define E_TIMING_LENGTH (E_TMANU + 1)
+
+/* non predefined standard timings supported by display */
+#define STD_TIMING_SECTION (ESTABLISHED_TIMING_SECTION + E_TIMING_LENGTH)
+#define STD_TIMING_INFO_LEN 2
+#define STD_TIMING_INFO_NUM STD_TIMINGS
+#define STD_TIMING_LENGTH (STD_TIMING_INFO_LEN * STD_TIMING_INFO_NUM)
+
+/* detailed timing info of non standard timings */
+#define DET_TIMING_SECTION (STD_TIMING_SECTION + STD_TIMING_LENGTH)
+#define DET_TIMING_INFO_LEN 18
+#define MONITOR_DESC_LEN DET_TIMING_INFO_LEN
+#define DET_TIMING_INFO_NUM DET_TIMINGS
+#define DET_TIMING_LENGTH (DET_TIMING_INFO_LEN * DET_TIMING_INFO_NUM)
+
+/* number of EDID sections to follow */
+#define NO_EDID (DET_TIMING_SECTION + DET_TIMING_LENGTH)
+/* one byte checksum */
+#define CHECKSUM (NO_EDID + 1)
+
+#if (CHECKSUM != (EDID1_LEN - 1))
+#error "EDID1 length != 128!"
+#endif
+
+#define SECTION(x,y) (Uchar *)(x + y)
+#define GET_ARRAY(y) ((Uchar *)(c + y))
+#define GET(y) *(Uchar *)(c + y)
+
+/* extract information from vendor section */
+#define _PROD_ID(x) x[0] + (x[1] << 8);
+#define PROD_ID _PROD_ID(GET_ARRAY(V_PROD_ID))
+#define _SERIAL_NO(x) x[0] + (x[1] << 8) + (x[2] << 16) + (x[3] << 24)
+#define SERIAL_NO _SERIAL_NO(GET_ARRAY(V_SERIAL))
+#define _YEAR(x) (x & 0xFF) + 1990
+#define YEAR _YEAR(GET(V_YEAR))
+#define WEEK GET(V_WEEK) & 0xFF
+#define _L1(x) ((x[0] & 0x7C) >> 2) + '@'
+#define _L2(x) ((x[0] & 0x03) << 3) + ((x[1] & 0xE0) >> 5) + '@'
+#define _L3(x) (x[1] & 0x1F) + '@';
+#define L1 _L1(GET_ARRAY(V_MANUFACTURER))
+#define L2 _L2(GET_ARRAY(V_MANUFACTURER))
+#define L3 _L3(GET_ARRAY(V_MANUFACTURER))
+
+/* extract information from version section */
+#define VERSION GET(V_VERSION)
+#define REVISION GET(V_REVISION)
+
+/* extract information from display section */
+#define _INPUT_TYPE(x) ((x & 0x80) >> 7)
+#define INPUT_TYPE _INPUT_TYPE(GET(D_INPUT))
+#define _INPUT_VOLTAGE(x) ((x & 0x60) >> 5)
+#define INPUT_VOLTAGE _INPUT_VOLTAGE(GET(D_INPUT))
+#define _SETUP(x) ((x & 0x10) >> 4)
+#define SETUP _SETUP(GET(D_INPUT))
+#define _SYNC(x) (x  & 0x0F)
+#define SYNC _SYNC(GET(D_INPUT))
+#define _DFP(x) (x & 0x01)
+#define DFP _DFP(GET(D_INPUT))
+#define _BPC(x) ((x & 0x70) >> 4)
+#define BPC _BPC(GET(D_INPUT))
+#define _DIGITAL_INTERFACE(x) (x & 0x0F)
+#define DIGITAL_INTERFACE _DIGITAL_INTERFACE(GET(D_INPUT))
+#define _GAMMA(x) (x == 0xff ? 0.0 : ((x + 100.0)/100.0))
+#define GAMMA _GAMMA(GET(D_GAMMA))
+#define HSIZE_MAX GET(D_HSIZE)
+#define VSIZE_MAX GET(D_VSIZE)
+#define _DPMS(x) ((x & 0xE0) >> 5)
+#define DPMS _DPMS(GET(FEAT_S))
+#define _DISPLAY_TYPE(x) ((x & 0x18) >> 3)
+#define DISPLAY_TYPE _DISPLAY_TYPE(GET(FEAT_S))
+#define _MSC(x) (x & 0x7)
+#define MSC _MSC(GET(FEAT_S))
+
+/* color characteristics */
+#define CC_L(x,y) ((x & (0x03 << y)) >> y)
+#define CC_H(x) (x << 2)
+#define I_CC(x,y,z) CC_H(y) | CC_L(x,z)
+#define F_CC(x) ((x)/1024.0)
+#define REDX F_CC(I_CC((GET(D_RG_LOW)),(GET(D_REDX)),6))
+#define REDY F_CC(I_CC((GET(D_RG_LOW)),(GET(D_REDY)),4))
+#define GREENX F_CC(I_CC((GET(D_RG_LOW)),(GET(D_GREENX)),2))
+#define GREENY F_CC(I_CC((GET(D_RG_LOW)),(GET(D_GREENY)),0))
+#define BLUEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_BLUEX)),6))
+#define BLUEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_BLUEY)),4))
+#define WHITEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEX)),2))
+#define WHITEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEY)),0))
+
+/* extract information from standard timing section */
+#define T1 GET(E_T1)
+#define T2 GET(E_T2)
+#define T_MANU GET(E_TMANU)
+
+/* extract information from estabished timing section */
+#define _VALID_TIMING(x) !(((x[0] == 0x01) && (x[1] == 0x01)) \
+                        || ((x[0] == 0x00) && (x[1] == 0x00)) \
+                        || ((x[0] == 0x20) && (x[1] == 0x20)) )
+#define VALID_TIMING _VALID_TIMING(c)
+#define _HSIZE1(x) ((x[0] + 31) * 8)
+#define HSIZE1 _HSIZE1(c)
+#define RATIO(x) ((x[1] & 0xC0) >> 6)
+#define RATIO1_1 0
+/* EDID Ver. 1.3 redefined this */
+#define RATIO16_10 RATIO1_1
+#define RATIO4_3 1
+#define RATIO5_4 2
+#define RATIO16_9 3
+#define _VSIZE1(x,y,r) switch(RATIO(x)){ \
+  case RATIO1_1: y =  ((v->version > 1 || v->revision > 2) \
+		       ? (_HSIZE1(x) * 10) / 16 : _HSIZE1(x)); break; \
+  case RATIO4_3: y = _HSIZE1(x) * 3 / 4; break; \
+  case RATIO5_4: y = _HSIZE1(x) * 4 / 5; break; \
+  case RATIO16_9: y = _HSIZE1(x) * 9 / 16; break; \
+  }
+#define VSIZE1(x) _VSIZE1(c,x,v)
+#define _REFRESH_R(x) (x[1] & 0x3F) + 60
+#define REFRESH_R  _REFRESH_R(c)
+#define _ID_LOW(x) x[0]
+#define ID_LOW _ID_LOW(c)
+#define _ID_HIGH(x) (x[1] << 8)
+#define ID_HIGH _ID_HIGH(c)
+#define STD_TIMING_ID (ID_LOW | ID_HIGH)
+#define _NEXT_STD_TIMING(x)  (x = (x + STD_TIMING_INFO_LEN))
+#define NEXT_STD_TIMING _NEXT_STD_TIMING(c)
+
+/* EDID Ver. >= 1.2 */
+/**
+ * Returns true if the pointer is the start of a monitor descriptor block
+ * instead of a detailed timing descriptor.
+ *
+ * Checking the reserved pad fields for zeroes fails on some monitors with
+ * broken empty ASCII strings.  Only the first two bytes are reliable.
+ */
+#define _IS_MONITOR_DESC(x) (x[0] == 0 && x[1] == 0)
+#define IS_MONITOR_DESC _IS_MONITOR_DESC(c)
+#define _PIXEL_CLOCK(x) (x[0] + (x[1] << 8)) * 10000
+#define PIXEL_CLOCK _PIXEL_CLOCK(c)
+#define _H_ACTIVE(x) (x[2] + ((x[4] & 0xF0) << 4))
+#define H_ACTIVE _H_ACTIVE(c)
+#define _H_BLANK(x) (x[3] + ((x[4] & 0x0F) << 8))
+#define H_BLANK _H_BLANK(c)
+#define _V_ACTIVE(x) (x[5] + ((x[7] & 0xF0) << 4))
+#define V_ACTIVE _V_ACTIVE(c)
+#define _V_BLANK(x) (x[6] + ((x[7] & 0x0F) << 8))
+#define V_BLANK _V_BLANK(c)
+#define _H_SYNC_OFF(x) (x[8] + ((x[11] & 0xC0) << 2))
+#define H_SYNC_OFF _H_SYNC_OFF(c)
+#define _H_SYNC_WIDTH(x) (x[9] + ((x[11] & 0x30) << 4))
+#define H_SYNC_WIDTH _H_SYNC_WIDTH(c)
+#define _V_SYNC_OFF(x) ((x[10] >> 4) + ((x[11] & 0x0C) << 2))
+#define V_SYNC_OFF _V_SYNC_OFF(c)
+#define _V_SYNC_WIDTH(x) ((x[10] & 0x0F) + ((x[11] & 0x03) << 4))
+#define V_SYNC_WIDTH _V_SYNC_WIDTH(c)
+#define _H_SIZE(x) (x[12] + ((x[14] & 0xF0) << 4))
+#define H_SIZE _H_SIZE(c)
+#define _V_SIZE(x) (x[13] + ((x[14] & 0x0F) << 8))
+#define V_SIZE _V_SIZE(c)
+#define _H_BORDER(x) (x[15])
+#define H_BORDER _H_BORDER(c)
+#define _V_BORDER(x) (x[16])
+#define V_BORDER _V_BORDER(c)
+#define _INTERLACED(x) ((x[17] & 0x80) >> 7)
+#define INTERLACED _INTERLACED(c)
+#define _STEREO(x) ((x[17] & 0x60) >> 5)
+#define STEREO _STEREO(c)
+#define _STEREO1(x) (x[17] & 0x1)
+#define STEREO1 _STEREO(c)
+#define _SYNC_T(x) ((x[17] & 0x18) >> 3)
+#define SYNC_T _SYNC_T(c)
+#define _MISC(x) ((x[17] & 0x06) >> 1)
+#define MISC _MISC(c)
+
+#define _MONITOR_DESC_TYPE(x) x[3]
+#define MONITOR_DESC_TYPE _MONITOR_DESC_TYPE(c)
+#define SERIAL_NUMBER 0xFF
+#define ASCII_STR 0xFE
+#define MONITOR_RANGES 0xFD
+#define _MIN_V_OFFSET(x) ((!!(x[4] & 0x01)) * 255)
+#define _MAX_V_OFFSET(x) ((!!(x[4] & 0x02)) * 255)
+#define _MIN_H_OFFSET(x) ((!!(x[4] & 0x04)) * 255)
+#define _MAX_H_OFFSET(x) ((!!(x[4] & 0x08)) * 255)
+#define _MIN_V(x) x[5]
+#define MIN_V (_MIN_V(c) + _MIN_V_OFFSET(c))
+#define _MAX_V(x) x[6]
+#define MAX_V (_MAX_V(c) + _MAX_V_OFFSET(c))
+#define _MIN_H(x) x[7]
+#define MIN_H (_MIN_H(c) + _MIN_H_OFFSET(c))
+#define _MAX_H(x) x[8]
+#define MAX_H (_MAX_H(c) + _MAX_H_OFFSET(c))
+#define _MAX_CLOCK(x) x[9]
+#define MAX_CLOCK _MAX_CLOCK(c)
+#define _HAVE_2ND_GTF(x) (x[10] == 0x02)
+#define HAVE_2ND_GTF _HAVE_2ND_GTF(c)
+#define _F_2ND_GTF(x) (x[12] * 2)
+#define F_2ND_GTF _F_2ND_GTF(c)
+#define _C_2ND_GTF(x) (x[13] / 2)
+#define C_2ND_GTF _C_2ND_GTF(c)
+#define _M_2ND_GTF(x) (x[14] + (x[15] << 8))
+#define M_2ND_GTF _M_2ND_GTF(c)
+#define _K_2ND_GTF(x) (x[16])
+#define K_2ND_GTF _K_2ND_GTF(c)
+#define _J_2ND_GTF(x) (x[17] / 2)
+#define J_2ND_GTF _J_2ND_GTF(c)
+#define _HAVE_CVT(x) (x[10] == 0x04)
+#define HAVE_CVT _HAVE_CVT(c)
+#define _MAX_CLOCK_KHZ(x) (x[12] >> 2)
+#define MAX_CLOCK_KHZ (MAX_CLOCK * 10000) - (_MAX_CLOCK_KHZ(c) * 250)
+#define _MAXWIDTH(x) ((x[13] == 0 ? 0 : x[13] + ((x[12] & 0x03) << 8)) * 8)
+#define MAXWIDTH _MAXWIDTH(c)
+#define _SUPPORTED_ASPECT(x) x[14]
+#define SUPPORTED_ASPECT _SUPPORTED_ASPECT(c)
+#define  SUPPORTED_ASPECT_4_3   0x80
+#define  SUPPORTED_ASPECT_16_9  0x40
+#define  SUPPORTED_ASPECT_16_10 0x20
+#define  SUPPORTED_ASPECT_5_4   0x10
+#define  SUPPORTED_ASPECT_15_9  0x08
+#define _PREFERRED_ASPECT(x) ((x[15] & 0xe0) >> 5)
+#define PREFERRED_ASPECT _PREFERRED_ASPECT(c)
+#define  PREFERRED_ASPECT_4_3   0
+#define  PREFERRED_ASPECT_16_9  1
+#define  PREFERRED_ASPECT_16_10 2
+#define  PREFERRED_ASPECT_5_4   3
+#define  PREFERRED_ASPECT_15_9  4
+#define _SUPPORTED_BLANKING(x) ((x[15] & 0x18) >> 3)
+#define SUPPORTED_BLANKING _SUPPORTED_BLANKING(c)
+#define  CVT_STANDARD 0x01
+#define  CVT_REDUCED  0x02
+#define _SUPPORTED_SCALING(x) ((x[16] & 0xf0) >> 4)
+#define SUPPORTED_SCALING _SUPPORTED_SCALING(c)
+#define  SCALING_HSHRINK  0x08
+#define  SCALING_HSTRETCH 0x04
+#define  SCALING_VSHRINK  0x02
+#define  SCALING_VSTRETCH 0x01
+#define _PREFERRED_REFRESH(x) x[17]
+#define PREFERRED_REFRESH _PREFERRED_REFRESH(c)
+
+#define MONITOR_NAME 0xFC
+#define ADD_COLOR_POINT 0xFB
+#define WHITEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEX)),2))
+#define WHITEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEY)),0))
+#define _WHITEX_ADD(x,y) F_CC(I_CC(((*(x + y))),(*(x + y + 1)),2))
+#define _WHITEY_ADD(x,y) F_CC(I_CC(((*(x + y))),(*(x + y + 2)),0))
+#define _WHITE_INDEX1(x) x[5]
+#define WHITE_INDEX1 _WHITE_INDEX1(c)
+#define _WHITE_INDEX2(x) x[10]
+#define WHITE_INDEX2 _WHITE_INDEX2(c)
+#define WHITEX1 _WHITEX_ADD(c,6)
+#define WHITEY1 _WHITEY_ADD(c,6)
+#define WHITEX2 _WHITEX_ADD(c,12)
+#define WHITEY2 _WHITEY_ADD(c,12)
+#define _WHITE_GAMMA1(x) _GAMMA(x[9])
+#define WHITE_GAMMA1 _WHITE_GAMMA1(c)
+#define _WHITE_GAMMA2(x) _GAMMA(x[14])
+#define WHITE_GAMMA2 _WHITE_GAMMA2(c)
+#define ADD_STD_TIMINGS 0xFA
+#define COLOR_MANAGEMENT_DATA 0xF9
+#define CVT_3BYTE_DATA 0xF8
+#define ADD_EST_TIMINGS 0xF7
+#define ADD_DUMMY 0x10
+
+#define _NEXT_DT_MD_SECTION(x) (x = (x + DET_TIMING_INFO_LEN))
+#define NEXT_DT_MD_SECTION _NEXT_DT_MD_SECTION(c)
+
+#endif                          /* _PARSE_EDID_ */
+
+/* input type */
+#define DIGITAL(x) x
+
+/* DFP */
+#define DFP1(x) x
+
+/* input voltage level */
+#define V070 0                  /* 0.700V/0.300V */
+#define V071 1                  /* 0.714V/0.286V */
+#define V100 2                  /* 1.000V/0.400V */
+#define V007 3                  /* 0.700V/0.000V */
+
+/* Signal level setup */
+#define SIG_SETUP(x) (x)
+
+/* sync characteristics */
+#define SEP_SYNC(x) (x & 0x08)
+#define COMP_SYNC(x) (x & 0x04)
+#define SYNC_O_GREEN(x) (x & 0x02)
+#define SYNC_SERR(x) (x & 0x01)
+
+/* DPMS features */
+#define DPMS_STANDBY(x) (x & 0x04)
+#define DPMS_SUSPEND(x) (x & 0x02)
+#define DPMS_OFF(x) (x & 0x01)
+
+/* display type, analog */
+#define DISP_MONO 0
+#define DISP_RGB 1
+#define DISP_MULTCOLOR 2
+
+/* display color encodings, digital */
+#define DISP_YCRCB444 0x01
+#define DISP_YCRCB422 0x02
+
+/* Msc stuff EDID Ver > 1.1 */
+#define STD_COLOR_SPACE(x) (x & 0x4)
+#define PREFERRED_TIMING_MODE(x) (x & 0x2)
+#define GFT_SUPPORTED(x) (x & 0x1)
+#define GTF_SUPPORTED(x) (x & 0x1)
+#define CVT_SUPPORTED(x) (x & 0x1)
+
+/* detailed timing misc */
+#define IS_INTERLACED(x)  (x)
+#define IS_STEREO(x)  (x)
+#define IS_RIGHT_STEREO(x) (x & 0x01)
+#define IS_LEFT_STEREO(x) (x & 0x02)
+#define IS_4WAY_STEREO(x) (x & 0x03)
+#define IS_RIGHT_ON_SYNC(x) IS_RIGHT_STEREO(x)
+#define IS_LEFT_ON_SYNC(x) IS_LEFT_STEREO(x)
+
+typedef unsigned int Uint;
+typedef unsigned char Uchar;
+
+struct vendor {
+    char name[4];
+    int prod_id;
+    Uint serial;
+    int week;
+    int year;
+};
+
+struct edid_version {
+    int version;
+    int revision;
+};
+
+struct disp_features {
+    unsigned int input_type:1;
+    unsigned int input_voltage:2;
+    unsigned int input_setup:1;
+    unsigned int input_sync:5;
+    unsigned int input_dfp:1;
+    unsigned int input_bpc:3;
+    unsigned int input_interface:4;
+    /* 15 bit hole */
+    int hsize;
+    int vsize;
+    float gamma;
+    unsigned int dpms:3;
+    unsigned int display_type:2;
+    unsigned int msc:3;
+    float redx;
+    float redy;
+    float greenx;
+    float greeny;
+    float bluex;
+    float bluey;
+    float whitex;
+    float whitey;
+};
+
+struct established_timings {
+    Uchar t1;
+    Uchar t2;
+    Uchar t_manu;
+};
+
+struct std_timings {
+    int hsize;
+    int vsize;
+    int refresh;
+    CARD16 id;
+};
+
+struct detailed_timings {
+    int clock;
+    int h_active;
+    int h_blanking;
+    int v_active;
+    int v_blanking;
+    int h_sync_off;
+    int h_sync_width;
+    int v_sync_off;
+    int v_sync_width;
+    int h_size;
+    int v_size;
+    int h_border;
+    int v_border;
+    unsigned int interlaced:1;
+    unsigned int stereo:2;
+    unsigned int sync:2;
+    unsigned int misc:2;
+    unsigned int stereo_1:1;
+};
+
+#define DT 0
+#define DS_SERIAL 0xFF
+#define DS_ASCII_STR 0xFE
+#define DS_NAME 0xFC
+#define DS_RANGES 0xFD
+#define DS_WHITE_P 0xFB
+#define DS_STD_TIMINGS 0xFA
+#define DS_CMD 0xF9
+#define DS_CVT 0xF8
+#define DS_EST_III 0xF7
+#define DS_DUMMY 0x10
+#define DS_UNKOWN 0x100         /* type is an int */
+#define DS_VENDOR 0x101
+#define DS_VENDOR_MAX 0x110
+
+struct monitor_ranges {
+    int min_v;
+    int max_v;
+    int min_h;
+    int max_h;
+    int max_clock;              /* in mhz */
+    int gtf_2nd_f;
+    int gtf_2nd_c;
+    int gtf_2nd_m;
+    int gtf_2nd_k;
+    int gtf_2nd_j;
+    int max_clock_khz;
+    int maxwidth;               /* in pixels */
+    char supported_aspect;
+    char preferred_aspect;
+    char supported_blanking;
+    char supported_scaling;
+    int preferred_refresh;      /* in hz */
+};
+
+struct whitePoints {
+    int index;
+    float white_x;
+    float white_y;
+    float white_gamma;
+};
+
+struct cvt_timings {
+    int width;
+    int height;
+    int rate;
+    int rates;
+};
+
+/*
+ * Be careful when adding new sections; this structure can't grow, it's
+ * embedded in the middle of xf86Monitor which is ABI.  Sizes below are
+ * in bytes, for ILP32 systems.  If all else fails just copy the section
+ * literally like serial and friends.
+ */
+struct detailed_monitor_section {
+    int type;
+    union {
+        struct detailed_timings d_timings;      /* 56 */
+        Uchar serial[13];
+        Uchar ascii_data[13];
+        Uchar name[13];
+        struct monitor_ranges ranges;   /* 56 */
+        struct std_timings std_t[5];    /* 80 */
+        struct whitePoints wp[2];       /* 32 */
+        /* color management data */
+        struct cvt_timings cvt[4];      /* 64 */
+        Uchar est_iii[6];       /* 6 */
+    } section;                  /* max: 80 */
+};
+
+/* flags */
+#define MONITOR_EDID_COMPLETE_RAWDATA	0x01
+/* old, don't use */
+#define EDID_COMPLETE_RAWDATA		0x01
+#define MONITOR_DISPLAYID		0x02
+
+/*
+ * For DisplayID devices, only the scrnIndex, flags, and rawData fields
+ * are meaningful.  For EDID, they all are.
+ */
+typedef struct {
+    int scrnIndex;
+    struct vendor vendor;
+    struct edid_version ver;
+    struct disp_features features;
+    struct established_timings timings1;
+    struct std_timings timings2[8];
+    struct detailed_monitor_section det_mon[4];
+    unsigned long flags;
+    int no_sections;
+    Uchar *rawData;
+} xf86Monitor, *xf86MonPtr;
+
+extern _X_EXPORT xf86MonPtr ConfiguredMonitor;
+
+#define EXT_TAG 0
+#define EXT_REV 1
+#define CEA_EXT   0x02
+#define VTB_EXT   0x10
+#define DI_EXT    0x40
+#define LS_EXT    0x50
+#define MI_EXT    0x60
+
+#define CEA_EXT_MIN_DATA_OFFSET 4
+#define CEA_EXT_MAX_DATA_OFFSET 127
+#define CEA_EXT_DET_TIMING_NUM 6
+
+#define IEEE_ID_HDMI    0x000C03
+#define CEA_AUDIO_BLK   1
+#define CEA_VIDEO_BLK   2
+#define CEA_VENDOR_BLK  3
+#define CEA_SPEAKER_ALLOC_BLK 4
+#define CEA_VESA_DTC_BLK 5
+#define VENDOR_SUPPORT_AI(x) ((x) >> 7)
+#define VENDOR_SUPPORT_DC_48bit(x)  ( ( (x) >> 6) & 0x01)
+#define VENDOR_SUPPORT_DC_36bit(x)  ( ( (x) >> 5) & 0x01)
+#define VENDOR_SUPPORT_DC_30bit(x)  ( ( (x) >> 4) & 0x01)
+#define VENDOR_SUPPORT_DC_Y444(x)   ( ( (x) >> 3) & 0x01)
+#define VENDOR_LATENCY_PRESENT(x)     ( (x) >> 7)
+#define VENDOR_LATENCY_PRESENT_I(x) ( ( (x) >> 6) & 0x01)
+#define HDMI_MAX_TMDS_UNIT   (5000)
+
+struct cea_video_block {
+    Uchar video_code;
+};
+
+struct cea_audio_block_descriptor {
+    Uchar audio_code[3];
+};
+
+struct cea_audio_block {
+    struct cea_audio_block_descriptor descriptor[10];
+};
+
+struct cea_vendor_block_hdmi {
+    __extension__ Uchar portB:4;
+    __extension__ Uchar portA:4;
+    __extension__ Uchar portD:4;
+    __extension__ Uchar portC:4;
+    Uchar support_flags;
+    Uchar max_tmds_clock;
+    Uchar latency_present;
+    Uchar video_latency;
+    Uchar audio_latency;
+    Uchar interlaced_video_latency;
+    Uchar interlaced_audio_latency;
+};
+
+struct cea_vendor_block {
+    unsigned char ieee_id[3];
+    union {
+        struct cea_vendor_block_hdmi hdmi;
+        /* any other vendor blocks we know about */
+    } dummy;
+};
+
+struct cea_speaker_block {
+    __extension__ Uchar FLR:1;
+    __extension__ Uchar LFE:1;
+    __extension__ Uchar FC:1;
+    __extension__ Uchar RLR:1;
+    __extension__ Uchar RC:1;
+    __extension__ Uchar FLRC:1;
+    __extension__ Uchar RLRC:1;
+    __extension__ Uchar FLRW:1;
+    __extension__ Uchar FLRH:1;
+    __extension__ Uchar TC:1;
+    __extension__ Uchar FCH:1;
+    __extension__ Uchar Resv:5;
+    Uchar ResvByte;
+};
+
+struct cea_data_block {
+    __extension__ Uchar len:5;
+    __extension__ Uchar tag:3;
+    union {
+        struct cea_video_block video;
+        struct cea_audio_block audio;
+        struct cea_vendor_block vendor;
+        struct cea_speaker_block speaker;
+    } u;
+};
+
+struct cea_ext_body {
+    Uchar tag;
+    Uchar rev;
+    Uchar dt_offset;
+    Uchar flags;
+    struct cea_data_block data_collection;
+};
+
+#endif                          /* _EDID_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/edid.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Bus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Bus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Bus.h	(Revision 52145)
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the bus-related data structures/types.
+ * Everything contained here is private to xf86Bus.c.  In particular the
+ * video drivers must not include this file.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_BUS_H
+#define _XF86_BUS_H
+
+#include "xf86pciBus.h"
+#if defined(__sparc__) || defined(__sparc)
+#include "xf86sbusBus.h"
+#endif
+#include "xf86platformBus.h"
+
+typedef struct {
+    DriverPtr driver;
+    int chipset;
+    int entityProp;
+    EntityProc entityInit;
+    EntityProc entityEnter;
+    EntityProc entityLeave;
+    void *private;
+    Bool active;
+    Bool inUse;
+    BusRec bus;
+    int lastScrnFlag;
+    DevUnion *entityPrivates;
+    int numInstances;
+    GDevPtr *devices;
+} EntityRec, *EntityPtr;
+
+#define ACCEL_IS_SHARABLE 0x100
+#define IS_SHARED_ACCEL 0x200
+#define SA_PRIM_INIT_DONE 0x400
+
+extern EntityPtr *xf86Entities;
+extern int xf86NumEntities;
+extern BusRec primaryBus;
+
+int xf86AllocateEntity(void);
+BusType StringToBusType(const char *busID, const char **retID);
+
+#endif                          /* _XF86_BUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Bus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_program.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_program.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_program.h	(Revision 52145)
@@ -0,0 +1,94 @@
+/*
+ * Copyright ¬© 2014 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _GLAMOR_PROGRAM_H_
+#define _GLAMOR_PROGRAM_H_
+
+typedef enum {
+    glamor_program_location_none = 0,
+    glamor_program_location_fg = 1,
+    glamor_program_location_bg = 2,
+    glamor_program_location_fill = 4,
+    glamor_program_location_font = 8,
+} glamor_program_location;
+
+typedef enum {
+    glamor_program_flag_none = 0,
+} glamor_program_flag;
+
+typedef struct _glamor_program glamor_program;
+
+typedef Bool (*glamor_use) (PixmapPtr pixmap, GCPtr gc, glamor_program *prog, void *arg);
+
+typedef struct {
+    const char                          *name;
+    const int                           version;
+    const char                          *vs_vars;
+    const char                          *vs_exec;
+    const char                          *fs_vars;
+    const char                          *fs_exec;
+    const glamor_program_location       locations;
+    const glamor_program_flag           flags;
+    const char                          *source_name;
+    glamor_use                          use;
+} glamor_facet;
+
+struct _glamor_program {
+    GLint                       prog;
+    GLint                       failed;
+    GLint                       matrix_uniform;
+    GLint                       fg_uniform;
+    GLint                       bg_uniform;
+    GLint                       fill_size_uniform;
+    GLint                       fill_offset_uniform;
+    GLint                       font_uniform;
+    glamor_program_location     locations;
+    glamor_program_flag         flags;
+    glamor_use                  prim_use;
+    glamor_use                  fill_use;
+};
+
+typedef struct {
+    glamor_program      progs[4];
+} glamor_program_fill;
+
+extern const glamor_facet glamor_fill_solid;
+
+Bool
+glamor_build_program(ScreenPtr          screen,
+                     glamor_program     *prog,
+                     const glamor_facet *prim,
+                     const glamor_facet *fill);
+
+Bool
+glamor_use_program(PixmapPtr            pixmap,
+                   GCPtr                gc,
+                   glamor_program       *prog,
+                   void                 *arg);
+
+glamor_program *
+glamor_use_program_fill(PixmapPtr               pixmap,
+                        GCPtr                   gc,
+                        glamor_program_fill     *program_fill,
+                        const glamor_facet      *prim);
+
+#endif /* _GLAMOR_PROGRAM_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_program.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Parser.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Parser.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Parser.h	(Revision 52145)
@@ -0,0 +1,480 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* 
+ * This file contains the external interfaces for the XFree86 configuration
+ * file parser.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86Parser_h_
+#define _xf86Parser_h_
+
+#include <X11/Xdefs.h>
+#include "xf86Optrec.h"
+#include "list.h"
+
+#define HAVE_PARSER_DECLS
+
+typedef struct {
+    char *file_logfile;
+    char *file_modulepath;
+    char *file_fontpath;
+    char *file_comment;
+    char *file_xkbdir;
+} XF86ConfFilesRec, *XF86ConfFilesPtr;
+
+/* Values for load_type */
+#define XF86_LOAD_MODULE	0
+#define XF86_LOAD_DRIVER	1
+#define XF86_DISABLE_MODULE	2
+
+typedef struct {
+    GenericListRec list;
+    int load_type;
+    const char *load_name;
+    XF86OptionPtr load_opt;
+    char *load_comment;
+    int ignore;
+} XF86LoadRec, *XF86LoadPtr;
+
+typedef struct {
+    XF86LoadPtr mod_load_lst;
+    XF86LoadPtr mod_disable_lst;
+    char *mod_comment;
+} XF86ConfModuleRec, *XF86ConfModulePtr;
+
+#define CONF_IMPLICIT_KEYBOARD	"Implicit Core Keyboard"
+
+#define CONF_IMPLICIT_POINTER	"Implicit Core Pointer"
+
+#define XF86CONF_PHSYNC    0x0001
+#define XF86CONF_NHSYNC    0x0002
+#define XF86CONF_PVSYNC    0x0004
+#define XF86CONF_NVSYNC    0x0008
+#define XF86CONF_INTERLACE 0x0010
+#define XF86CONF_DBLSCAN   0x0020
+#define XF86CONF_CSYNC     0x0040
+#define XF86CONF_PCSYNC    0x0080
+#define XF86CONF_NCSYNC    0x0100
+#define XF86CONF_HSKEW     0x0200       /* hskew provided */
+#define XF86CONF_BCAST     0x0400
+#define XF86CONF_VSCAN     0x1000
+
+typedef struct {
+    GenericListRec list;
+    const char *ml_identifier;
+    int ml_clock;
+    int ml_hdisplay;
+    int ml_hsyncstart;
+    int ml_hsyncend;
+    int ml_htotal;
+    int ml_vdisplay;
+    int ml_vsyncstart;
+    int ml_vsyncend;
+    int ml_vtotal;
+    int ml_vscan;
+    int ml_flags;
+    int ml_hskew;
+    char *ml_comment;
+} XF86ConfModeLineRec, *XF86ConfModeLinePtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *vp_identifier;
+    XF86OptionPtr vp_option_lst;
+    char *vp_comment;
+} XF86ConfVideoPortRec, *XF86ConfVideoPortPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *va_identifier;
+    const char *va_vendor;
+    const char *va_board;
+    const char *va_busid;
+    const char *va_driver;
+    XF86OptionPtr va_option_lst;
+    XF86ConfVideoPortPtr va_port_lst;
+    const char *va_fwdref;
+    char *va_comment;
+} XF86ConfVideoAdaptorRec, *XF86ConfVideoAdaptorPtr;
+
+#define CONF_MAX_HSYNC 8
+#define CONF_MAX_VREFRESH 8
+
+typedef struct {
+    float hi, lo;
+} parser_range;
+
+typedef struct {
+    int red, green, blue;
+} parser_rgb;
+
+typedef struct {
+    GenericListRec list;
+    const char *modes_identifier;
+    XF86ConfModeLinePtr mon_modeline_lst;
+    char *modes_comment;
+} XF86ConfModesRec, *XF86ConfModesPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *ml_modes_str;
+    XF86ConfModesPtr ml_modes;
+} XF86ConfModesLinkRec, *XF86ConfModesLinkPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *mon_identifier;
+    const char *mon_vendor;
+    char *mon_modelname;
+    int mon_width;              /* in mm */
+    int mon_height;             /* in mm */
+    XF86ConfModeLinePtr mon_modeline_lst;
+    int mon_n_hsync;
+    parser_range mon_hsync[CONF_MAX_HSYNC];
+    int mon_n_vrefresh;
+    parser_range mon_vrefresh[CONF_MAX_VREFRESH];
+    float mon_gamma_red;
+    float mon_gamma_green;
+    float mon_gamma_blue;
+    XF86OptionPtr mon_option_lst;
+    XF86ConfModesLinkPtr mon_modes_sect_lst;
+    char *mon_comment;
+} XF86ConfMonitorRec, *XF86ConfMonitorPtr;
+
+#define CONF_MAXDACSPEEDS 4
+#define CONF_MAXCLOCKS    128
+
+typedef struct {
+    GenericListRec list;
+    const char *dev_identifier;
+    const char *dev_vendor;
+    const char *dev_board;
+    const char *dev_chipset;
+    const char *dev_busid;
+    const char *dev_card;
+    const char *dev_driver;
+    const char *dev_ramdac;
+    int dev_dacSpeeds[CONF_MAXDACSPEEDS];
+    int dev_videoram;
+    int dev_textclockfreq;
+    unsigned long dev_bios_base;
+    unsigned long dev_mem_base;
+    unsigned long dev_io_base;
+    const char *dev_clockchip;
+    int dev_clocks;
+    int dev_clock[CONF_MAXCLOCKS];
+    int dev_chipid;
+    int dev_chiprev;
+    int dev_irq;
+    int dev_screen;
+    XF86OptionPtr dev_option_lst;
+    char *dev_comment;
+    char *match_seat;
+} XF86ConfDeviceRec, *XF86ConfDevicePtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *mode_name;
+} XF86ModeRec, *XF86ModePtr;
+
+typedef struct {
+    GenericListRec list;
+    int disp_frameX0;
+    int disp_frameY0;
+    int disp_virtualX;
+    int disp_virtualY;
+    int disp_depth;
+    int disp_bpp;
+    const char *disp_visual;
+    parser_rgb disp_weight;
+    parser_rgb disp_black;
+    parser_rgb disp_white;
+    XF86ModePtr disp_mode_lst;
+    XF86OptionPtr disp_option_lst;
+    char *disp_comment;
+} XF86ConfDisplayRec, *XF86ConfDisplayPtr;
+
+typedef struct {
+    XF86OptionPtr flg_option_lst;
+    char *flg_comment;
+} XF86ConfFlagsRec, *XF86ConfFlagsPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *al_adaptor_str;
+    XF86ConfVideoAdaptorPtr al_adaptor;
+} XF86ConfAdaptorLinkRec, *XF86ConfAdaptorLinkPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *scrn_identifier;
+    const char *scrn_obso_driver;
+    int scrn_defaultdepth;
+    int scrn_defaultbpp;
+    int scrn_defaultfbbpp;
+    const char *scrn_monitor_str;
+    XF86ConfMonitorPtr scrn_monitor;
+    const char *scrn_device_str;
+    XF86ConfDevicePtr scrn_device;
+    XF86ConfAdaptorLinkPtr scrn_adaptor_lst;
+    XF86ConfDisplayPtr scrn_display_lst;
+    XF86OptionPtr scrn_option_lst;
+    char *scrn_comment;
+    int scrn_virtualX, scrn_virtualY;
+    char *match_seat;
+} XF86ConfScreenRec, *XF86ConfScreenPtr;
+
+typedef struct {
+    GenericListRec list;
+    char *inp_identifier;
+    char *inp_driver;
+    XF86OptionPtr inp_option_lst;
+    char *inp_comment;
+} XF86ConfInputRec, *XF86ConfInputPtr;
+
+typedef struct {
+    GenericListRec list;
+    XF86ConfInputPtr iref_inputdev;
+    char *iref_inputdev_str;
+    XF86OptionPtr iref_option_lst;
+} XF86ConfInputrefRec, *XF86ConfInputrefPtr;
+
+typedef struct {
+    Bool set;
+    Bool val;
+} xf86TriState;
+
+typedef struct {
+    struct xorg_list entry;
+    char **values;
+} xf86MatchGroup;
+
+typedef struct {
+    GenericListRec list;
+    char *identifier;
+    char *driver;
+    struct xorg_list match_product;
+    struct xorg_list match_vendor;
+    struct xorg_list match_device;
+    struct xorg_list match_os;
+    struct xorg_list match_pnpid;
+    struct xorg_list match_usbid;
+    struct xorg_list match_driver;
+    struct xorg_list match_tag;
+    struct xorg_list match_layout;
+    xf86TriState is_keyboard;
+    xf86TriState is_pointer;
+    xf86TriState is_joystick;
+    xf86TriState is_tablet;
+    xf86TriState is_touchpad;
+    xf86TriState is_touchscreen;
+    XF86OptionPtr option_lst;
+    char *comment;
+} XF86ConfInputClassRec, *XF86ConfInputClassPtr;
+
+typedef struct {
+    GenericListRec list;
+    char *identifier;
+    char *driver;
+    struct xorg_list match_driver;
+    char *comment;
+} XF86ConfOutputClassRec, *XF86ConfOutputClassPtr;
+
+/* Values for adj_where */
+#define CONF_ADJ_OBSOLETE	-1
+#define CONF_ADJ_ABSOLUTE	0
+#define CONF_ADJ_RIGHTOF	1
+#define CONF_ADJ_LEFTOF		2
+#define CONF_ADJ_ABOVE		3
+#define CONF_ADJ_BELOW		4
+#define CONF_ADJ_RELATIVE	5
+
+typedef struct {
+    GenericListRec list;
+    int adj_scrnum;
+    XF86ConfScreenPtr adj_screen;
+    const char *adj_screen_str;
+    XF86ConfScreenPtr adj_top;
+    const char *adj_top_str;
+    XF86ConfScreenPtr adj_bottom;
+    const char *adj_bottom_str;
+    XF86ConfScreenPtr adj_left;
+    const char *adj_left_str;
+    XF86ConfScreenPtr adj_right;
+    const char *adj_right_str;
+    int adj_where;
+    int adj_x;
+    int adj_y;
+    const char *adj_refscreen;
+} XF86ConfAdjacencyRec, *XF86ConfAdjacencyPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *inactive_device_str;
+    XF86ConfDevicePtr inactive_device;
+} XF86ConfInactiveRec, *XF86ConfInactivePtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *lay_identifier;
+    XF86ConfAdjacencyPtr lay_adjacency_lst;
+    XF86ConfInactivePtr lay_inactive_lst;
+    XF86ConfInputrefPtr lay_input_lst;
+    XF86OptionPtr lay_option_lst;
+    char *match_seat;
+    char *lay_comment;
+} XF86ConfLayoutRec, *XF86ConfLayoutPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *vs_name;
+    const char *vs_identifier;
+    XF86OptionPtr vs_option_lst;
+    char *vs_comment;
+} XF86ConfVendSubRec, *XF86ConfVendSubPtr;
+
+typedef struct {
+    GenericListRec list;
+    const char *vnd_identifier;
+    XF86OptionPtr vnd_option_lst;
+    XF86ConfVendSubPtr vnd_sub_lst;
+    char *vnd_comment;
+} XF86ConfVendorRec, *XF86ConfVendorPtr;
+
+typedef struct {
+    const char *dri_group_name;
+    int dri_group;
+    int dri_mode;
+    char *dri_comment;
+} XF86ConfDRIRec, *XF86ConfDRIPtr;
+
+typedef struct {
+    XF86OptionPtr ext_option_lst;
+    char *extensions_comment;
+} XF86ConfExtensionsRec, *XF86ConfExtensionsPtr;
+
+typedef struct {
+    XF86ConfFilesPtr conf_files;
+    XF86ConfModulePtr conf_modules;
+    XF86ConfFlagsPtr conf_flags;
+    XF86ConfVideoAdaptorPtr conf_videoadaptor_lst;
+    XF86ConfModesPtr conf_modes_lst;
+    XF86ConfMonitorPtr conf_monitor_lst;
+    XF86ConfDevicePtr conf_device_lst;
+    XF86ConfScreenPtr conf_screen_lst;
+    XF86ConfInputPtr conf_input_lst;
+    XF86ConfInputClassPtr conf_inputclass_lst;
+    XF86ConfOutputClassPtr conf_outputclass_lst;
+    XF86ConfLayoutPtr conf_layout_lst;
+    XF86ConfVendorPtr conf_vendor_lst;
+    XF86ConfDRIPtr conf_dri;
+    XF86ConfExtensionsPtr conf_extensions;
+    char *conf_comment;
+} XF86ConfigRec, *XF86ConfigPtr;
+
+typedef struct {
+    int token;                  /* id of the token */
+    const char *name;           /* pointer to the LOWERCASED name */
+} xf86ConfigSymTabRec, *xf86ConfigSymTabPtr;
+
+/*
+ * prototypes for public functions
+ */
+extern void xf86initConfigFiles(void);
+extern char *xf86openConfigFile(const char *path, const char *cmdline,
+                                const char *projroot);
+extern char *xf86openConfigDirFiles(const char *path, const char *cmdline,
+                                    const char *projroot);
+extern void xf86setBuiltinConfig(const char *config[]);
+extern XF86ConfigPtr xf86readConfigFile(void);
+extern void xf86closeConfigFile(void);
+extern void xf86freeConfig(XF86ConfigPtr p);
+extern int xf86writeConfigFile(const char *, XF86ConfigPtr);
+extern _X_EXPORT XF86ConfDevicePtr xf86findDevice(const char *ident,
+                                                  XF86ConfDevicePtr p);
+extern _X_EXPORT XF86ConfLayoutPtr xf86findLayout(const char *name,
+                                                  XF86ConfLayoutPtr list);
+extern _X_EXPORT XF86ConfMonitorPtr xf86findMonitor(const char *ident,
+                                                    XF86ConfMonitorPtr p);
+extern _X_EXPORT XF86ConfModesPtr xf86findModes(const char *ident,
+                                                XF86ConfModesPtr p);
+extern _X_EXPORT XF86ConfModeLinePtr xf86findModeLine(const char *ident,
+                                                      XF86ConfModeLinePtr p);
+extern _X_EXPORT XF86ConfScreenPtr xf86findScreen(const char *ident,
+                                                  XF86ConfScreenPtr p);
+extern _X_EXPORT XF86ConfInputPtr xf86findInput(const char *ident,
+                                                XF86ConfInputPtr p);
+extern _X_EXPORT XF86ConfInputPtr xf86findInputByDriver(const char *driver,
+                                                        XF86ConfInputPtr p);
+extern _X_EXPORT XF86ConfVideoAdaptorPtr xf86findVideoAdaptor(const char *ident,
+                                                              XF86ConfVideoAdaptorPtr
+                                                              p);
+extern int xf86layoutAddInputDevices(XF86ConfigPtr config,
+                                     XF86ConfLayoutPtr layout);
+
+extern _X_EXPORT GenericListPtr xf86addListItem(GenericListPtr head,
+                                                GenericListPtr c_new);
+extern _X_EXPORT int xf86itemNotSublist(GenericListPtr list_1,
+                                        GenericListPtr list_2);
+
+extern _X_EXPORT int xf86pathIsAbsolute(const char *path);
+extern _X_EXPORT int xf86pathIsSafe(const char *path);
+extern _X_EXPORT char *xf86addComment(char *cur, const char *add);
+extern _X_EXPORT Bool xf86getBoolValue(Bool *val, const char *str);
+
+#endif                          /* _xf86Parser_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Parser.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/osdep.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/osdep.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/osdep.h	(Revision 52145)
@@ -0,0 +1,257 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _OSDEP_H_
+#define _OSDEP_H_ 1
+
+#if defined(XDMCP) || defined(HASXDMAUTH)
+#include <X11/Xdmcp.h>
+#endif
+
+#ifdef _POSIX_SOURCE
+#include <limits.h>
+#else
+#define _POSIX_SOURCE
+#include <limits.h>
+#undef _POSIX_SOURCE
+#endif
+
+#ifndef OPEN_MAX
+#ifdef SVR4
+#define OPEN_MAX 256
+#else
+#include <sys/param.h>
+#ifndef OPEN_MAX
+#if defined(NOFILE) && !defined(NOFILES_MAX)
+#define OPEN_MAX NOFILE
+#else
+#if !defined(WIN32)
+#define OPEN_MAX NOFILES_MAX
+#else
+#define OPEN_MAX 256
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#include <X11/Xpoll.h>
+
+/*
+ * MAXSOCKS is used only for initialising MaxClients when no other method
+ * like sysconf(_SC_OPEN_MAX) is not supported.
+ */
+
+#if OPEN_MAX <= 256
+#define MAXSOCKS (OPEN_MAX - 1)
+#else
+#define MAXSOCKS 256
+#endif
+
+/* MAXSELECT is the number of fds that select() can handle */
+#define MAXSELECT (sizeof(fd_set) * NBBY)
+
+#include <stddef.h>
+
+#if defined(XDMCP) || defined(HASXDMAUTH)
+typedef Bool (*ValidatorFunc) (ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
+typedef Bool (*GeneratorFunc) (ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
+typedef Bool (*AddAuthorFunc) (unsigned name_length, const char *name,
+                               unsigned data_length, char *data);
+#endif
+
+typedef struct _connectionInput *ConnectionInputPtr;
+typedef struct _connectionOutput *ConnectionOutputPtr;
+
+struct _osComm;
+
+#define AuthInitArgs void
+typedef void (*AuthInitFunc) (AuthInitArgs);
+
+#define AuthAddCArgs unsigned short data_length, const char *data, XID id
+typedef int (*AuthAddCFunc) (AuthAddCArgs);
+
+#define AuthCheckArgs unsigned short data_length, const char *data, ClientPtr client, const char **reason
+typedef XID (*AuthCheckFunc) (AuthCheckArgs);
+
+#define AuthFromIDArgs XID id, unsigned short *data_lenp, char **datap
+typedef int (*AuthFromIDFunc) (AuthFromIDArgs);
+
+#define AuthGenCArgs unsigned data_length, const char *data, XID id, unsigned *data_length_return, char **data_return
+typedef XID (*AuthGenCFunc) (AuthGenCArgs);
+
+#define AuthRemCArgs unsigned short data_length, const char *data
+typedef int (*AuthRemCFunc) (AuthRemCArgs);
+
+#define AuthRstCArgs void
+typedef int (*AuthRstCFunc) (AuthRstCArgs);
+
+#define AuthToIDArgs unsigned short data_length, char *data
+typedef XID (*AuthToIDFunc) (AuthToIDArgs);
+
+typedef void (*OsCloseFunc) (ClientPtr);
+
+typedef int (*OsFlushFunc) (ClientPtr who, struct _osComm * oc, char *extraBuf,
+                            int extraCount);
+
+typedef struct _osComm {
+    int fd;
+    ConnectionInputPtr input;
+    ConnectionOutputPtr output;
+    XID auth_id;                /* authorization id */
+    CARD32 conn_time;           /* timestamp if not established, else 0  */
+    struct _XtransConnInfo *trans_conn; /* transport connection object */
+} OsCommRec, *OsCommPtr;
+
+extern int FlushClient(ClientPtr /*who */ ,
+                       OsCommPtr /*oc */ ,
+                       const void * /*extraBuf */ ,
+                       int      /*extraCount */
+    );
+
+extern void FreeOsBuffers(OsCommPtr     /*oc */
+    );
+
+#include "dix.h"
+
+extern fd_set AllSockets;
+extern fd_set AllClients;
+extern fd_set LastSelectMask;
+extern fd_set WellKnownConnections;
+extern fd_set EnabledDevices;
+extern fd_set ClientsWithInput;
+extern fd_set ClientsWriteBlocked;
+extern fd_set OutputPending;
+extern fd_set IgnoredClientsWithInput;
+
+#ifndef WIN32
+extern int *ConnectionTranslation;
+#else
+extern int GetConnectionTranslation(int conn);
+extern void SetConnectionTranslation(int conn, int client);
+extern void ClearConnectionTranslation(void);
+#endif
+
+extern Bool NewOutputPending;
+extern Bool AnyClientsWriteBlocked;
+
+extern WorkQueuePtr workQueue;
+
+/* in WaitFor.c */
+#ifdef WIN32
+typedef long int fd_mask;
+#endif
+#define ffs mffs
+extern int mffs(fd_mask);
+
+/* in access.c */
+extern Bool ComputeLocalClient(ClientPtr client);
+
+/* in auth.c */
+extern void GenerateRandomData(int len, char *buf);
+
+/* in mitauth.c */
+extern XID MitCheckCookie(AuthCheckArgs);
+extern XID MitGenerateCookie(AuthGenCArgs);
+extern XID MitToID(AuthToIDArgs);
+extern int MitAddCookie(AuthAddCArgs);
+extern int MitFromID(AuthFromIDArgs);
+extern int MitRemoveCookie(AuthRemCArgs);
+extern int MitResetCookie(AuthRstCArgs);
+
+/* in xdmauth.c */
+#ifdef HASXDMAUTH
+extern XID XdmCheckCookie(AuthCheckArgs);
+extern XID XdmToID(AuthToIDArgs);
+extern int XdmAddCookie(AuthAddCArgs);
+extern int XdmFromID(AuthFromIDArgs);
+extern int XdmRemoveCookie(AuthRemCArgs);
+extern int XdmResetCookie(AuthRstCArgs);
+#endif
+
+/* in rpcauth.c */
+#ifdef SECURE_RPC
+extern void SecureRPCInit(AuthInitArgs);
+extern XID SecureRPCCheck(AuthCheckArgs);
+extern XID SecureRPCToID(AuthToIDArgs);
+extern int SecureRPCAdd(AuthAddCArgs);
+extern int SecureRPCFromID(AuthFromIDArgs);
+extern int SecureRPCRemove(AuthRemCArgs);
+extern int SecureRPCReset(AuthRstCArgs);
+#endif
+
+#ifdef XDMCP
+/* in xdmcp.c */
+extern void XdmcpUseMsg(void);
+extern int XdmcpOptions(int argc, char **argv, int i);
+extern void XdmcpRegisterConnection(int type, const char *address, int addrlen);
+extern void XdmcpRegisterAuthorizations(void);
+extern void XdmcpRegisterAuthorization(const char *name, int namelen);
+extern void XdmcpInit(void);
+extern void XdmcpReset(void);
+extern void XdmcpOpenDisplay(int sock);
+extern void XdmcpCloseDisplay(int sock);
+extern void XdmcpRegisterAuthentication(const char *name,
+                                        int namelen,
+                                        const char *data,
+                                        int datalen,
+                                        ValidatorFunc Validator,
+                                        GeneratorFunc Generator,
+                                        AddAuthorFunc AddAuth);
+
+struct sockaddr_in;
+extern void XdmcpRegisterBroadcastAddress(const struct sockaddr_in *addr);
+#endif
+
+#ifdef HASXDMAUTH
+extern void XdmAuthenticationInit(const char *cookie, int cookie_length);
+#endif
+
+#endif                          /* _OSDEP_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/osdep.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compiler.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compiler.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compiler.h	(Revision 52145)
@@ -0,0 +1,1749 @@
+/*
+ * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Thomas Roell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Thomas Roell makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _COMPILER_H
+
+#define _COMPILER_H
+
+#if defined(__SUNPRO_C)
+#define DO_PROTOTYPES
+#endif
+
+/* Map Sun compiler platform defines to gcc-style used in the code */
+#if defined(__amd64) && !defined(__amd64__)
+#define __amd64__
+#endif
+#if defined(__i386) && !defined(__i386__)
+#define __i386__
+#endif
+#if defined(__sparc) && !defined(__sparc__)
+#define __sparc__
+#endif
+#if defined(__sparcv9) && !defined(__sparc64__)
+#define __sparc64__
+#endif
+
+#ifndef _X_EXPORT
+#include <X11/Xfuncproto.h>
+#endif
+
+#include <pixman.h>             /* for uint*_t types */
+
+/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
+#ifndef __inline__
+#if defined(__GNUC__)
+    /* gcc has __inline__ */
+#elif defined(__HIGHC__)
+#define __inline__ _Inline
+#else
+#define __inline__ /**/
+#endif
+#endif                          /* __inline__ */
+#ifndef __inline
+#if defined(__GNUC__)
+    /* gcc has __inline */
+#elif defined(__HIGHC__)
+#define __inline _Inline
+#else
+#define __inline /**/
+#endif
+#endif                          /* __inline */
+/* Support gcc's __FUNCTION__ for people using other compilers */
+#if !defined(__GNUC__) && !defined(__FUNCTION__)
+#define __FUNCTION__ __func__   /* C99 */
+#endif
+#if defined(NO_INLINE) || defined(DO_PROTOTYPES)
+#if !defined(__arm__)
+#if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) && !defined(__nds32__) \
+      && !(defined(__alpha__) && defined(linux)) \
+      && !(defined(__ia64__) && defined(linux)) \
+      && !(defined(__mips64) && defined(linux)) \
+
+extern _X_EXPORT void outb(unsigned short, unsigned char);
+extern _X_EXPORT void outw(unsigned short, unsigned short);
+extern _X_EXPORT void outl(unsigned short, unsigned int);
+extern _X_EXPORT unsigned int inb(unsigned short);
+extern _X_EXPORT unsigned int inw(unsigned short);
+extern _X_EXPORT unsigned int inl(unsigned short);
+
+#else                           /* __sparc__,  __arm32__, __alpha__, __nds32__ */
+extern _X_EXPORT void outb(unsigned long, unsigned char);
+extern _X_EXPORT void outw(unsigned long, unsigned short);
+extern _X_EXPORT void outl(unsigned long, unsigned int);
+extern _X_EXPORT unsigned int inb(unsigned long);
+extern _X_EXPORT unsigned int inw(unsigned long);
+extern _X_EXPORT unsigned int inl(unsigned long);
+
+#ifdef __SUNPRO_C
+extern _X_EXPORT unsigned char  xf86ReadMmio8    (void *, unsigned long);
+extern _X_EXPORT unsigned short xf86ReadMmio16Be (void *, unsigned long);
+extern _X_EXPORT unsigned short xf86ReadMmio16Le (void *, unsigned long);
+extern _X_EXPORT unsigned int   xf86ReadMmio32Be (void *, unsigned long);
+extern _X_EXPORT unsigned int   xf86ReadMmio32Le (void *, unsigned long);
+extern _X_EXPORT void xf86WriteMmio8    (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio16Be (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio16Le (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio32Be (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio32Le (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio8NB    (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio16BeNB (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio16LeNB (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio32BeNB (void *, unsigned long, unsigned int);
+extern _X_EXPORT void xf86WriteMmio32LeNB (void *, unsigned long, unsigned int);
+#endif                          /* _SUNPRO_C */
+#endif                          /* __sparc__,  __arm32__, __alpha__, __nds32__ */
+#endif                          /* __arm__ */
+
+#if defined(__powerpc__) && !defined(__OpenBSD__)
+extern unsigned long ldq_u(unsigned long *);
+extern unsigned long ldl_u(unsigned int *);
+extern unsigned long ldw_u(unsigned short *);
+extern void stq_u(unsigned long, unsigned long *);
+extern void stl_u(unsigned long, unsigned int *);
+extern void stw_u(unsigned long, unsigned short *);
+extern void mem_barrier(void);
+extern void write_mem_barrier(void);
+extern void stl_brx(unsigned long, volatile unsigned char *, int);
+extern void stw_brx(unsigned short, volatile unsigned char *, int);
+extern unsigned long ldl_brx(volatile unsigned char *, int);
+extern unsigned short ldw_brx(volatile unsigned char *, int);
+#endif                          /* __powerpc__ && !__OpenBSD */
+
+#endif                          /* NO_INLINE || DO_PROTOTYPES */
+
+#ifndef NO_INLINE
+#ifdef __GNUC__
+#ifdef __i386__
+
+#ifdef __SSE__
+#define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
+#else
+#define write_mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
+#endif
+
+#ifdef __SSE2__
+#define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
+#else
+#define mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
+#endif
+
+#elif defined __alpha__
+
+#define mem_barrier() __asm__ __volatile__ ("mb" : : : "memory")
+#define write_mem_barrier() __asm__ __volatile__ ("wmb" : : : "memory")
+
+#elif defined __amd64__
+
+#define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
+#define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
+
+#elif defined __ia64__
+
+#ifndef __INTEL_COMPILER
+#define mem_barrier()        __asm__ __volatile__ ("mf" : : : "memory")
+#define write_mem_barrier()  __asm__ __volatile__ ("mf" : : : "memory")
+#else
+#include "ia64intrin.h"
+#define mem_barrier() __mf()
+#define write_mem_barrier() __mf()
+#endif
+
+#elif defined __mips__
+     /* Note: sync instruction requires MIPS II instruction set */
+#define mem_barrier()		\
+	__asm__ __volatile__(		\
+		".set   push\n\t"	\
+		".set   noreorder\n\t"	\
+		".set   mips2\n\t"	\
+		"sync\n\t"		\
+		".set   pop"		\
+		: /* no output */	\
+		: /* no input */	\
+		: "memory")
+#define write_mem_barrier() mem_barrier()
+
+#elif defined __powerpc__
+
+#if defined(linux) && defined(__powerpc64__)
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#include <asm/memory.h>
+#endif
+#endif                          /* defined(linux) && defined(__powerpc64__) */
+
+#ifndef eieio                   /* We deal with arch-specific eieio() routines above... */
+#define eieio() __asm__ __volatile__ ("eieio" ::: "memory")
+#endif                          /* eieio */
+#define mem_barrier()	eieio()
+#define write_mem_barrier()	eieio()
+
+#elif defined __sparc__
+
+#define barrier() __asm__ __volatile__ (".word 0x8143e00a" : : : "memory")
+#define mem_barrier()           /* XXX: nop for now */
+#define write_mem_barrier()     /* XXX: nop for now */
+#endif
+#endif                          /* __GNUC__ */
+#endif                          /* NO_INLINE */
+
+#ifndef mem_barrier
+#define mem_barrier()           /* NOP */
+#endif
+
+#ifndef write_mem_barrier
+#define write_mem_barrier()     /* NOP */
+#endif
+
+#ifndef NO_INLINE
+#ifdef __GNUC__
+
+/* Define some packed structures to use with unaligned accesses */
+
+struct __una_u64 {
+    uint64_t x __attribute__ ((packed));
+};
+struct __una_u32 {
+    uint32_t x __attribute__ ((packed));
+};
+struct __una_u16 {
+    uint16_t x __attribute__ ((packed));
+};
+
+/* Elemental unaligned loads */
+
+static __inline__ uint64_t
+ldq_u(uint64_t * p)
+{
+    const struct __una_u64 *ptr = (const struct __una_u64 *) p;
+
+    return ptr->x;
+}
+
+static __inline__ uint32_t
+ldl_u(uint32_t * p)
+{
+    const struct __una_u32 *ptr = (const struct __una_u32 *) p;
+
+    return ptr->x;
+}
+
+static __inline__ uint16_t
+ldw_u(uint16_t * p)
+{
+    const struct __una_u16 *ptr = (const struct __una_u16 *) p;
+
+    return ptr->x;
+}
+
+/* Elemental unaligned stores */
+
+static __inline__ void
+stq_u(uint64_t val, uint64_t * p)
+{
+    struct __una_u64 *ptr = (struct __una_u64 *) p;
+
+    ptr->x = val;
+}
+
+static __inline__ void
+stl_u(uint32_t val, uint32_t * p)
+{
+    struct __una_u32 *ptr = (struct __una_u32 *) p;
+
+    ptr->x = val;
+}
+
+static __inline__ void
+stw_u(uint16_t val, uint16_t * p)
+{
+    struct __una_u16 *ptr = (struct __una_u16 *) p;
+
+    ptr->x = val;
+}
+#else                           /* !__GNUC__ */
+
+#include <string.h>             /* needed for memmove */
+
+static __inline__ uint64_t
+ldq_u(uint64_t * p)
+{
+    uint64_t ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
+}
+
+static __inline__ uint32_t
+ldl_u(uint32_t * p)
+{
+    uint32_t ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
+}
+
+static __inline__ uint16_t
+ldw_u(uint16_t * p)
+{
+    uint16_t ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
+}
+
+static __inline__ void
+stq_u(uint64_t val, uint64_t * p)
+{
+    uint64_t tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
+}
+
+static __inline__ void
+stl_u(uint32_t val, uint32_t * p)
+{
+    uint32_t tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
+}
+
+static __inline__ void
+stw_u(uint16_t val, uint16_t * p)
+{
+    uint16_t tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
+}
+
+#endif                          /* __GNUC__ */
+#endif                          /* NO_INLINE */
+
+#ifndef NO_INLINE
+#ifdef __GNUC__
+#if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && (defined(__alpha__))
+
+#ifdef linux
+/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern _X_EXPORT void _outb(unsigned char val, unsigned long port);
+extern _X_EXPORT void _outw(unsigned short val, unsigned long port);
+extern _X_EXPORT void _outl(unsigned int val, unsigned long port);
+extern _X_EXPORT unsigned int _inb(unsigned long port);
+extern _X_EXPORT unsigned int _inw(unsigned long port);
+extern _X_EXPORT unsigned int _inl(unsigned long port);
+
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+    _outb(val, port);
+}
+
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+    _outw(val, port);
+}
+
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+    _outl(val, port);
+}
+
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+    return _inb(port);
+}
+
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+    return _inw(port);
+}
+
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+    return _inl(port);
+}
+
+#endif                          /* linux */
+
+#if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
+      && !defined(DO_PROTOTYPES)
+
+/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
+/*  inx/outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern _X_EXPORT void outb(unsigned int port, unsigned char val);
+extern _X_EXPORT void outw(unsigned int port, unsigned short val);
+extern _X_EXPORT void outl(unsigned int port, unsigned int val);
+extern _X_EXPORT unsigned char inb(unsigned int port);
+extern _X_EXPORT unsigned short inw(unsigned int port);
+extern _X_EXPORT unsigned int inl(unsigned int port);
+
+#endif                          /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
+
+#if defined(__NetBSD__)
+#include <machine/pio.h>
+#endif                          /* __NetBSD__ */
+
+#elif (defined(linux) || defined(__FreeBSD__)) && defined(__amd64__)
+
+#include <inttypes.h>
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+    __asm__ __volatile__("outb %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+    __asm__ __volatile__("outw %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+    __asm__ __volatile__("outl %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+    unsigned char ret;
+    __asm__ __volatile__("inb %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+    unsigned short ret;
+    __asm__ __volatile__("inw %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("inl %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+#elif (defined(linux) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)
+
+#ifndef ASI_PL
+#define ASI_PL 0x88
+#endif
+
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(port), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(port), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
+                         :"r"(val), "r"(port), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("lduba [%1] %2, %0":"=r"(ret)
+                         :"r"(port), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("lduha [%1] %2, %0":"=r"(ret)
+                         :"r"(port), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("lda [%1] %2, %0":"=r"(ret)
+                         :"r"(port), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned char ret;
+
+    __asm__ __volatile__("lduba [%1] %2, %0":"=r"(ret)
+                         :"r"(addr), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned short ret;
+
+    __asm__ __volatile__("lduh [%1], %0":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned short ret;
+
+    __asm__ __volatile__("lduha [%1] %2, %0":"=r"(ret)
+                         :"r"(addr), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned int ret;
+
+    __asm__ __volatile__("ld [%1], %0":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned int ret;
+
+    __asm__ __volatile__("lda [%1] %2, %0":"=r"(ret)
+                         :"r"(addr), "i"(ASI_PL));
+
+    return ret;
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+               const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("sth %0, [%1]":        /* No outputs */
+                         :"r"(val), "r"(addr));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("st %0, [%1]": /* No outputs */
+                         :"r"(val), "r"(addr));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
+                 const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("stba %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio16BeNB(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("sth %0, [%1]":        /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+xf86WriteMmio16LeNB(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("stha %0, [%1] %2":    /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio32BeNB(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("st %0, [%1]": /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+xf86WriteMmio32LeNB(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("sta %0, [%1] %2":     /* No outputs */
+                         :"r"(val), "r"(addr), "i"(ASI_PL));
+}
+
+#elif defined(__mips__) || (defined(__arm32__) && !defined(__linux__))
+#if defined(__arm32__) || defined(__mips64)
+#define PORT_SIZE long
+#else
+#define PORT_SIZE short
+#endif
+
+_X_EXPORT unsigned int IOPortBase;      /* Memory mapped I/O port area */
+
+static __inline__ void
+outb(unsigned PORT_SIZE port, unsigned char val)
+{
+    *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
+        val;
+}
+
+static __inline__ void
+outw(unsigned PORT_SIZE port, unsigned short val)
+{
+    *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
+        val;
+}
+
+static __inline__ void
+outl(unsigned PORT_SIZE port, unsigned int val)
+{
+    *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)) + IOPortBase) =
+        val;
+}
+
+static __inline__ unsigned int
+inb(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)) +
+                                        IOPortBase);
+}
+
+static __inline__ unsigned int
+inw(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)) +
+                                         IOPortBase);
+}
+
+static __inline__ unsigned int
+inl(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)) +
+                                       IOPortBase);
+}
+
+#if defined(__mips__)
+#ifdef linux                    /* don't mess with other OSs */
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned int ret;
+
+    __asm__ __volatile__("lw %0, 0(%1)":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("sw %0, 0(%1)":        /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+#endif
+#endif                          /* !linux */
+#endif                          /* __mips__ */
+
+#elif (defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)) && defined(__powerpc__)
+
+#ifndef MAP_FAILED
+#define MAP_FAILED ((void *)-1)
+#endif
+
+extern _X_EXPORT volatile unsigned char *ioBase;
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+    register unsigned char val;
+    __asm__ __volatile__("lbzx %0,%1,%2\n\t" "eieio":"=r"(val)
+                         :"b"(base), "r"(offset),
+                         "m"(*((volatile unsigned char *) base + offset)));
+    return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+    register unsigned short val;
+    __asm__ __volatile__("lhzx %0,%1,%2\n\t" "eieio":"=r"(val)
+                         :"b"(base), "r"(offset),
+                         "m"(*((volatile unsigned char *) base + offset)));
+    return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+    register unsigned short val;
+    __asm__ __volatile__("lhbrx %0,%1,%2\n\t" "eieio":"=r"(val)
+                         :"b"(base), "r"(offset),
+                         "m"(*((volatile unsigned char *) base + offset)));
+    return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+    register unsigned int val;
+    __asm__ __volatile__("lwzx %0,%1,%2\n\t" "eieio":"=r"(val)
+                         :"b"(base), "r"(offset),
+                         "m"(*((volatile unsigned char *) base + offset)));
+    return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+    register unsigned int val;
+    __asm__ __volatile__("lwbrx %0,%1,%2\n\t" "eieio":"=r"(val)
+                         :"b"(base), "r"(offset),
+                         "m"(*((volatile unsigned char *) base + offset)));
+    return val;
+}
+
+static __inline__ void
+xf86WriteMmioNB8(__volatile__ void *base, const unsigned long offset,
+                 const unsigned char val)
+{
+    __asm__
+        __volatile__("stbx %1,%2,%3\n\t":"=m"
+                     (*((volatile unsigned char *) base + offset))
+                     :"r"(val), "b"(base), "r"(offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Le(__volatile__ void *base, const unsigned long offset,
+                    const unsigned short val)
+{
+    __asm__
+        __volatile__("sthbrx %1,%2,%3\n\t":"=m"
+                     (*((volatile unsigned char *) base + offset))
+                     :"r"(val), "b"(base), "r"(offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Be(__volatile__ void *base, const unsigned long offset,
+                    const unsigned short val)
+{
+    __asm__
+        __volatile__("sthx %1,%2,%3\n\t":"=m"
+                     (*((volatile unsigned char *) base + offset))
+                     :"r"(val), "b"(base), "r"(offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Le(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    __asm__
+        __volatile__("stwbrx %1,%2,%3\n\t":"=m"
+                     (*((volatile unsigned char *) base + offset))
+                     :"r"(val), "b"(base), "r"(offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Be(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    __asm__
+        __volatile__("stwx %1,%2,%3\n\t":"=m"
+                     (*((volatile unsigned char *) base + offset))
+                     :"r"(val), "b"(base), "r"(offset));
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+               const unsigned char val)
+{
+    xf86WriteMmioNB8(base, offset, val);
+    eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+    xf86WriteMmioNB16Le(base, offset, val);
+    eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+    xf86WriteMmioNB16Be(base, offset, val);
+    eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    xf86WriteMmioNB32Le(base, offset, val);
+    eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    xf86WriteMmioNB32Be(base, offset, val);
+    eieio();
+}
+
+static __inline__ void
+outb(unsigned short port, unsigned char value)
+{
+    if (ioBase == MAP_FAILED)
+        return;
+    xf86WriteMmio8((void *) ioBase, port, value);
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short value)
+{
+    if (ioBase == MAP_FAILED)
+        return;
+    xf86WriteMmio16Le((void *) ioBase, port, value);
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int value)
+{
+    if (ioBase == MAP_FAILED)
+        return;
+    xf86WriteMmio32Le((void *) ioBase, port, value);
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+    if (ioBase == MAP_FAILED)
+        return 0;
+    return xf86ReadMmio8((void *) ioBase, port);
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+    if (ioBase == MAP_FAILED)
+        return 0;
+    return xf86ReadMmio16Le((void *) ioBase, port);
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+    if (ioBase == MAP_FAILED)
+        return 0;
+    return xf86ReadMmio32Le((void *) ioBase, port);
+}
+
+#elif defined(__arm__) && defined(__linux__)
+
+/* for Linux on ARM, we use the LIBC inx/outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+#include <sys/io.h>
+
+static __inline__ void
+xf_outb(unsigned short port, unsigned char val)
+{
+    outb(val, port);
+}
+
+static __inline__ void
+xf_outw(unsigned short port, unsigned short val)
+{
+    outw(val, port);
+}
+
+static __inline__ void
+xf_outl(unsigned short port, unsigned int val)
+{
+    outl(val, port);
+}
+
+#define outb xf_outb
+#define outw xf_outw
+#define outl xf_outl
+
+#elif defined(__nds32__)
+
+/*
+ * Assume all port access are aligned.  We need to revise this implementation
+ * if there is unaligned port access.  For ldq_u, ldl_u, ldw_u, stq_u, stl_u and
+ * stw_u, they are assumed unaligned.
+ */
+
+#define barrier()               /* no barrier */
+
+#define PORT_SIZE long
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+    return *(volatile unsigned char *) ((unsigned char *) base + offset);
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+               const unsigned int val)
+{
+    *(volatile unsigned char *) ((unsigned char *) base + offset) = val;
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
+                 const unsigned int val)
+{
+    *(volatile unsigned char *) ((unsigned char *) base + offset) = val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Swap(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned short ret;
+
+    __asm__ __volatile__("lhi %0, [%1];\n\t" "wsbh %0, %0;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16(__volatile__ void *base, const unsigned long offset)
+{
+    return *(volatile unsigned short *) ((char *) base + offset);
+}
+
+static __inline__ void
+xf86WriteMmio16Swap(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "shi %0, [%1];\n\t":        /* No outputs */
+                         :"r"(val), "r"(addr));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16(__volatile__ void *base, const unsigned long offset,
+                const unsigned int val)
+{
+    *(volatile unsigned short *) ((unsigned char *) base + offset) = val;
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16SwapNB(__volatile__ void *base, const unsigned long offset,
+                      const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "shi %0, [%1];\n\t":        /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+xf86WriteMmio16NB(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    *(volatile unsigned short *) ((unsigned char *) base + offset) = val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Swap(__volatile__ void *base, const unsigned long offset)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+    unsigned int ret;
+
+    __asm__ __volatile__("lwi %0, [%1];\n\t"
+                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32(__volatile__ void *base, const unsigned long offset)
+{
+    return *(volatile unsigned int *) ((unsigned char *) base + offset);
+}
+
+static __inline__ void
+xf86WriteMmio32Swap(__volatile__ void *base, const unsigned long offset,
+                    const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "swi %0, [%1];\n\t":        /* No outputs */
+                         :"r"(val), "r"(addr));
+
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32(__volatile__ void *base, const unsigned long offset,
+                const unsigned int val)
+{
+    *(volatile unsigned int *) ((unsigned char *) base + offset) = val;
+    barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32SwapNB(__volatile__ void *base, const unsigned long offset,
+                      const unsigned int val)
+{
+    unsigned long addr = ((unsigned long) base) + offset;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "swi %0, [%1];\n\t":        /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+xf86WriteMmio32NB(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+    *(volatile unsigned int *) ((unsigned char *) base + offset) = val;
+}
+
+#if defined(NDS32_MMIO_SWAP)
+static __inline__ void
+outb(unsigned PORT_SIZE port, unsigned char val)
+{
+    xf86WriteMmio8(IOPortBase, port, val);
+}
+
+static __inline__ void
+outw(unsigned PORT_SIZE port, unsigned short val)
+{
+    xf86WriteMmio16Swap(IOPortBase, port, val);
+}
+
+static __inline__ void
+outl(unsigned PORT_SIZE port, unsigned int val)
+{
+    xf86WriteMmio32Swap(IOPortBase, port, val);
+}
+
+static __inline__ unsigned int
+inb(unsigned PORT_SIZE port)
+{
+    return xf86ReadMmio8(IOPortBase, port);
+}
+
+static __inline__ unsigned int
+inw(unsigned PORT_SIZE port)
+{
+    return xf86ReadMmio16Swap(IOPortBase, port);
+}
+
+static __inline__ unsigned int
+inl(unsigned PORT_SIZE port)
+{
+    return xf86ReadMmio32Swap(IOPortBase, port);
+}
+
+static __inline__ unsigned long
+ldq_u(unsigned long *p)
+{
+    unsigned long addr = (unsigned long) p;
+    unsigned int ret;
+
+    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t"
+                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned long
+ldl_u(unsigned int *p)
+{
+    unsigned long addr = (unsigned long) p;
+    unsigned int ret;
+
+    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t"
+                         "wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ void
+stq_u(unsigned long val, unsigned long *p)
+{
+    unsigned long addr = (unsigned long) p;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "smw.bi %0, [%1], %0, 0;\n\t":      /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+stl_u(unsigned long val, unsigned int *p)
+{
+    unsigned long addr = (unsigned long) p;
+
+    __asm__ __volatile__("wsbh %0, %0;\n\t" "rotri %0, %0, 16;\n\t" "smw.bi %0, [%1], %0, 0;\n\t":      /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+#else                           /* !NDS32_MMIO_SWAP */
+static __inline__ void
+outb(unsigned PORT_SIZE port, unsigned char val)
+{
+    *(volatile unsigned char *) (((unsigned PORT_SIZE) (port))) = val;
+    barrier();
+}
+
+static __inline__ void
+outw(unsigned PORT_SIZE port, unsigned short val)
+{
+    *(volatile unsigned short *) (((unsigned PORT_SIZE) (port))) = val;
+    barrier();
+}
+
+static __inline__ void
+outl(unsigned PORT_SIZE port, unsigned int val)
+{
+    *(volatile unsigned int *) (((unsigned PORT_SIZE) (port))) = val;
+    barrier();
+}
+
+static __inline__ unsigned int
+inb(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned char *) (((unsigned PORT_SIZE) (port)));
+}
+
+static __inline__ unsigned int
+inw(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned short *) (((unsigned PORT_SIZE) (port)));
+}
+
+static __inline__ unsigned int
+inl(unsigned PORT_SIZE port)
+{
+    return *(volatile unsigned int *) (((unsigned PORT_SIZE) (port)));
+}
+
+static __inline__ unsigned long
+ldq_u(unsigned long *p)
+{
+    unsigned long addr = (unsigned long) p;
+    unsigned int ret;
+
+    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ unsigned long
+ldl_u(unsigned int *p)
+{
+    unsigned long addr = (unsigned long) p;
+    unsigned int ret;
+
+    __asm__ __volatile__("lmw.bi %0, [%1], %0, 0;\n\t":"=r"(ret)
+                         :"r"(addr));
+
+    return ret;
+}
+
+static __inline__ void
+stq_u(unsigned long val, unsigned long *p)
+{
+    unsigned long addr = (unsigned long) p;
+
+    __asm__ __volatile__("smw.bi %0, [%1], %0, 0;\n\t": /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+
+static __inline__ void
+stl_u(unsigned long val, unsigned int *p)
+{
+    unsigned long addr = (unsigned long) p;
+
+    __asm__ __volatile__("smw.bi %0, [%1], %0, 0;\n\t": /* No outputs */
+                         :"r"(val), "r"(addr));
+}
+#endif                          /* NDS32_MMIO_SWAP */
+
+#if (((X_BYTE_ORDER == X_BIG_ENDIAN) && !defined(NDS32_MMIO_SWAP)) || ((X_BYTE_ORDER != X_BIG_ENDIAN) && defined(NDS32_MMIO_SWAP)))
+#define ldw_u(p)	((*(unsigned char *)(p)) << 8 | \
+			(*((unsigned char *)(p)+1)))
+#define stw_u(v,p)	(*(unsigned char *)(p)) = ((v) >> 8); \
+				(*((unsigned char *)(p)+1)) = (v)
+#else
+#define ldw_u(p)	((*(unsigned char *)(p)) | \
+			(*((unsigned char *)(p)+1)<<8))
+#define stw_u(v,p)	(*(unsigned char *)(p)) = (v); \
+				(*((unsigned char *)(p)+1)) = ((v) >> 8)
+#endif
+
+#define mem_barrier()           /* XXX: nop for now */
+#define write_mem_barrier()     /* XXX: nop for now */
+
+#else                           /* ix86 */
+
+#if !defined(__SUNPRO_C)
+#if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && \
+    !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && \
+    !defined(__m32r__) && !defined(__aarch64__) && !defined(__arc__) && \
+    !defined(__xtensa__)
+#ifdef GCCUSESGAS
+
+/*
+ * If gcc uses gas rather than the native assembler, the syntax of these
+ * inlines has to be different.		DHD
+ */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+    __asm__ __volatile__("outb %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+    __asm__ __volatile__("outw %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+    __asm__ __volatile__("outl %0,%1"::"a"(val), "d"(port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+    unsigned char ret;
+    __asm__ __volatile__("inb %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+    unsigned short ret;
+    __asm__ __volatile__("inw %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("inl %1,%0":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+#else                           /* GCCUSESGAS */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+    __asm__ __volatile__("out%B0 (%1)"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+    __asm__ __volatile__("out%W0 (%1)"::"a"(val), "d"(port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+    __asm__ __volatile__("out%L0 (%1)"::"a"(val), "d"(port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+    unsigned char ret;
+    __asm__ __volatile__("in%B0 (%1)":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+    unsigned short ret;
+    __asm__ __volatile__("in%W0 (%1)":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+    unsigned int ret;
+    __asm__ __volatile__("in%L0 (%1)":"=a"(ret):"d"(port));
+
+    return ret;
+}
+
+#endif                          /* GCCUSESGAS */
+
+#else                           /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) && !defined(__arc__) */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+    return 0;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+    return 0;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+    return 0;
+}
+
+#endif                          /* FAKEIT */
+#endif                          /* __SUNPRO_C */
+
+#endif                          /* ix86 */
+
+#else                           /* !GNUC */
+#if defined(__STDC__) && (__STDC__ == 1)
+#ifndef asm
+#define asm __asm
+#endif
+#endif
+#if !defined(__SUNPRO_C)
+#include <sys/inline.h>
+#endif
+#if !defined(__HIGHC__) && !defined(__SUNPRO_C) || \
+	defined(__USLC__)
+#pragma asm partial_optimization outl
+#pragma asm partial_optimization outw
+#pragma asm partial_optimization outb
+#pragma asm partial_optimization inl
+#pragma asm partial_optimization inw
+#pragma asm partial_optimization inb
+#endif
+#endif                          /* __GNUC__ */
+
+#endif                          /* NO_INLINE */
+
+#ifdef __alpha__
+/* entry points for Mmio memory access routines */
+extern _X_EXPORT int (*xf86ReadMmio8) (void *, unsigned long);
+extern _X_EXPORT int (*xf86ReadMmio16) (void *, unsigned long);
+
+#ifndef STANDALONE_MMIO
+extern _X_EXPORT int (*xf86ReadMmio32) (void *, unsigned long);
+#else
+/* Some DRI 3D drivers need MMIO_IN32. */
+static __inline__ int
+xf86ReadMmio32(void *Base, unsigned long Offset)
+{
+    mem_barrier();
+    return *(volatile unsigned int *) ((unsigned long) Base + (Offset));
+}
+#endif
+extern _X_EXPORT void (*xf86WriteMmio8) (int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmio16) (int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmio32) (int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB8) (int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB16) (int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB32) (int, void *, unsigned long);
+extern _X_EXPORT void xf86SlowBCopyFromBus(unsigned char *, unsigned char *,
+                                           int);
+extern _X_EXPORT void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);
+
+/* Some macros to hide the system dependencies for MMIO accesses */
+/* Changed to kill noise generated by gcc's -Wcast-align */
+#define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
+#define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
+#ifndef STANDALONE_MMIO
+#define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
+#else
+#define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
+#endif
+
+#define MMIO_OUT32(base, offset, val) \
+    do { \
+	write_mem_barrier(); \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
+    } while (0)
+#define MMIO_ONB32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+
+#define MMIO_OUT8(base, offset, val) \
+    (*xf86WriteMmio8)((CARD8)(val), base, offset)
+#define MMIO_OUT16(base, offset, val) \
+    (*xf86WriteMmio16)((CARD16)(val), base, offset)
+#define MMIO_ONB8(base, offset, val) \
+    (*xf86WriteMmioNB8)((CARD8)(val), base, offset)
+#define MMIO_ONB16(base, offset, val) \
+    (*xf86WriteMmioNB16)((CARD16)(val), base, offset)
+#define MMIO_MOVE32(base, offset, val) \
+    MMIO_OUT32(base, offset, val)
+
+#elif defined(__powerpc__)
+ /* 
+  * we provide byteswapping and no byteswapping functions here
+  * with byteswapping as default, 
+  * drivers that don't need byteswapping should define PPC_MMIO_IS_BE 
+  */
+#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmioNB8(base, offset, (CARD8)(val))
+
+#if defined(PPC_MMIO_IS_BE)     /* No byteswapping */
+#define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+    xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+    xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+    xf86WriteMmioNB16Be(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+    xf86WriteMmioNB32Be(base, offset, (CARD32)(val))
+#else                           /* byteswapping is the default */
+#define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
+#endif
+
+#define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+#elif defined(__sparc__) || defined(sparc) || defined(__sparc)
+ /*
+  * Like powerpc, we provide byteswapping and no byteswapping functions
+  * here with byteswapping as default, drivers that don't need byteswapping
+  * should define SPARC_MMIO_IS_BE (perhaps create a generic macro so that we
+  * do not need to use PPC_MMIO_IS_BE and the sparc one in all the same places
+  * of drivers?).
+  */
+#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmio8NB(base, offset, (CARD8)(val))
+
+#if defined(SPARC_MMIO_IS_BE)   /* No byteswapping */
+#define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
+#else                           /* byteswapping is the default */
+#define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
+#endif
+
+#define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+#elif defined(__nds32__)
+ /*
+  * we provide byteswapping and no byteswapping functions here
+  * with no byteswapping as default; when endianness of CPU core
+  * and I/O devices don't match, byte swapping is necessary
+  * drivers that need byteswapping should define NDS32_MMIO_SWAP
+  */
+#define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmioNB8(base, offset, (CARD8)(val))
+
+#if defined(NDS32_MMIO_SWAP)    /* byteswapping */
+#define MMIO_IN16(base, offset) xf86ReadMmio16Swap(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32Swap(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+    xf86WriteMmio16Swap(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+    xf86WriteMmio32Swap(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+    xf86WriteMmioNB16Swap(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+    xf86WriteMmioNB32Swap(base, offset, (CARD32)(val))
+#else                           /* no byteswapping is the default */
+#define MMIO_IN16(base, offset) xf86ReadMmio16(base, offset)
+#define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
+#define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16(base, offset, (CARD16)(val))
+#define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32(base, offset, (CARD32)(val))
+#define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmioNB16(base, offset, (CARD16)(val))
+#define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmioNB32(base, offset, (CARD32)(val))
+#endif
+
+#define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32(base, offset, (CARD32)(val))
+
+#ifdef N1213_HC                 /* for NDS32 N1213 hardcore */
+static __inline__ void
+nds32_flush_icache(char *addr)
+{
+    __asm__ volatile ("isync %0;"
+                      "msync;"
+                      "isb;"
+                      "cctl %0,L1I_VA_INVAL;" "isb;"::"r" (addr):"memory");
+}
+#else
+static __inline__ void
+nds32_flush_icache(char *addr)
+{
+    __asm__ volatile ("isync %0;" "isb;"::"r" (addr):"memory");
+}
+#endif
+
+#else                           /* !__alpha__ && !__powerpc__ && !__sparc__ */
+
+#define MMIO_IN8(base, offset) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset))
+#define MMIO_IN16(base, offset) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset))
+#define MMIO_IN32(base, offset) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
+#define MMIO_OUT8(base, offset, val) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset)) = (val)
+#define MMIO_OUT16(base, offset, val) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#define MMIO_OUT32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val)
+#define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val)
+#define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val)
+
+#define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
+
+#endif                          /* __alpha__ */
+
+/*
+ * With Intel, the version in os-support/misc/SlowBcopy.s is used.
+ * This avoids port I/O during the copy (which causes problems with
+ * some hardware).
+ */
+#ifdef __alpha__
+#define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
+#define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
+#else                           /* __alpha__ */
+#define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
+#define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
+#endif                          /* __alpha__ */
+
+#endif                          /* _COMPILER_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compiler.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miline.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miline.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miline.h	(Revision 52145)
@@ -0,0 +1,172 @@
+
+/*
+
+Copyright 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+#ifndef MILINE_H
+
+#include "screenint.h"
+#include "privates.h"
+
+/*
+ * Public definitions used for configuring basic pixelization aspects
+ * of the sample implementation line-drawing routines provided in
+ * {mfb,mi,cfb*} at run-time.
+ */
+
+#define XDECREASING	4
+#define YDECREASING	2
+#define YMAJOR		1
+
+#define OCTANT1		(1 << (YDECREASING))
+#define OCTANT2		(1 << (YDECREASING|YMAJOR))
+#define OCTANT3		(1 << (XDECREASING|YDECREASING|YMAJOR))
+#define OCTANT4		(1 << (XDECREASING|YDECREASING))
+#define OCTANT5		(1 << (XDECREASING))
+#define OCTANT6		(1 << (XDECREASING|YMAJOR))
+#define OCTANT7		(1 << (YMAJOR))
+#define OCTANT8		(1 << (0))
+
+#define XMAJOROCTANTS		(OCTANT1 | OCTANT4 | OCTANT5 | OCTANT8)
+
+#define DEFAULTZEROLINEBIAS	(OCTANT2 | OCTANT3 | OCTANT4 | OCTANT5)
+
+/*
+ * Devices can configure the rendering of routines in mi, mfb, and cfb*
+ * by specifying a thin line bias to be applied to a particular screen
+ * using the following function.  The bias parameter is an OR'ing of
+ * the appropriate OCTANT constants defined above to indicate which
+ * octants to bias a line to prefer an axial step when the Bresenham
+ * error term is exactly zero.  The octants are mapped as follows:
+ *
+ *   \    |    /
+ *    \ 3 | 2 /
+ *     \  |  /
+ *    4 \ | / 1
+ *       \|/
+ *   -----------
+ *       /|\
+ *    5 / | \ 8
+ *     /  |  \
+ *    / 6 | 7 \
+ *   /    |    \
+ *
+ * For more information, see "Ambiguities in Incremental Line Rastering,"
+ * Jack E. Bresenham, IEEE CG&A, May 1987.
+ */
+
+extern _X_EXPORT void miSetZeroLineBias(ScreenPtr /* pScreen */ ,
+                                        unsigned int    /* bias */
+    );
+
+/*
+ * Private definitions needed for drawing thin (zero width) lines
+ * Used by the mi, mfb, and all cfb* components.
+ */
+
+#define X_AXIS	0
+#define Y_AXIS	1
+
+#define OUT_LEFT  0x08
+#define OUT_RIGHT 0x04
+#define OUT_ABOVE 0x02
+#define OUT_BELOW 0x01
+
+#define OUTCODES(_result, _x, _y, _pbox) \
+    if	    ( (_x) <  (_pbox)->x1) (_result) |= OUT_LEFT; \
+    else if ( (_x) >= (_pbox)->x2) (_result) |= OUT_RIGHT; \
+    if	    ( (_y) <  (_pbox)->y1) (_result) |= OUT_ABOVE; \
+    else if ( (_y) >= (_pbox)->y2) (_result) |= OUT_BELOW;
+
+#define MIOUTCODES(outcode, x, y, xmin, ymin, xmax, ymax) \
+{\
+     if (x < xmin) outcode |= OUT_LEFT;\
+     if (x > xmax) outcode |= OUT_RIGHT;\
+     if (y < ymin) outcode |= OUT_ABOVE;\
+     if (y > ymax) outcode |= OUT_BELOW;\
+}
+
+#define SWAPINT(i, j) \
+{  int _t = i;  i = j;  j = _t; }
+
+#define SWAPPT(i, j) \
+{  DDXPointRec _t; _t = i;  i = j; j = _t; }
+
+#define SWAPINT_PAIR(x1, y1, x2, y2)\
+{   int t = x1;  x1 = x2;  x2 = t;\
+        t = y1;  y1 = y2;  y2 = t;\
+}
+
+#define miGetZeroLineBias(_pScreen) ((unsigned long) (unsigned long*)\
+    dixLookupPrivate(&(_pScreen)->devPrivates, miZeroLineScreenKey))
+
+#define CalcLineDeltas(_x1,_y1,_x2,_y2,_adx,_ady,_sx,_sy,_SX,_SY,_octant) \
+    (_octant) = 0;				\
+    (_sx) = (_SX);				\
+    if (((_adx) = (_x2) - (_x1)) < 0) {		\
+	(_adx) = -(_adx);			\
+	(_sx = -(_sx));				\
+	(_octant) |= XDECREASING;		\
+    }						\
+    (_sy) = (_SY);				\
+    if (((_ady) = (_y2) - (_y1)) < 0) {		\
+	(_ady) = -(_ady);			\
+	(_sy = -(_sy));				\
+	(_octant) |= YDECREASING;		\
+    }
+
+#define SetYMajorOctant(_octant)	((_octant) |= YMAJOR)
+
+#define FIXUP_ERROR(_e, _octant, _bias) \
+    (_e) -= (((_bias) >> (_octant)) & 1)
+
+#define IsXMajorOctant(_octant)		(!((_octant) & YMAJOR))
+#define IsYMajorOctant(_octant)		((_octant) & YMAJOR)
+#define IsXDecreasingOctant(_octant)	((_octant) & XDECREASING)
+#define IsYDecreasingOctant(_octant)	((_octant) & YDECREASING)
+
+extern _X_EXPORT DevPrivateKeyRec miZeroLineScreenKeyRec;
+
+#define miZeroLineScreenKey (&miZeroLineScreenKeyRec)
+
+extern _X_EXPORT int miZeroClipLine(int /*xmin */ ,
+                                    int /*ymin */ ,
+                                    int /*xmax */ ,
+                                    int /*ymax */ ,
+                                    int * /*new_x1 */ ,
+                                    int * /*new_y1 */ ,
+                                    int * /*new_x2 */ ,
+                                    int * /*new_y2 */ ,
+                                    unsigned int /*adx */ ,
+                                    unsigned int /*ady */ ,
+                                    int * /*pt1_clipped */ ,
+                                    int * /*pt2_clipped */ ,
+                                    int /*octant */ ,
+                                    unsigned int /*bias */ ,
+                                    int /*oc1 */ ,
+                                    int /*oc2 */
+    );
+
+#endif                          /* MILINE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miline.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damage.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damage.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damage.h	(Revision 52145)
@@ -0,0 +1,115 @@
+/*
+ * Copyright ¬© 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGE_H_
+#define _DAMAGE_H_
+
+typedef struct _damage *DamagePtr;
+
+typedef enum _damageReportLevel {
+    DamageReportRawRegion,
+    DamageReportDeltaRegion,
+    DamageReportBoundingBox,
+    DamageReportNonEmpty,
+    DamageReportNone
+} DamageReportLevel;
+
+typedef void (*DamageReportFunc) (DamagePtr pDamage, RegionPtr pRegion,
+                                  void *closure);
+typedef void (*DamageDestroyFunc) (DamagePtr pDamage, void *closure);
+
+typedef void (*DamageScreenCreateFunc) (DamagePtr);
+typedef void (*DamageScreenRegisterFunc) (DrawablePtr, DamagePtr);
+typedef void (*DamageScreenUnregisterFunc) (DrawablePtr, DamagePtr);
+typedef void (*DamageScreenDestroyFunc) (DamagePtr);
+
+typedef struct _damageScreenFuncs {
+    DamageScreenCreateFunc Create;
+    DamageScreenRegisterFunc Register;
+    DamageScreenUnregisterFunc Unregister;
+    DamageScreenDestroyFunc Destroy;
+} DamageScreenFuncsRec, *DamageScreenFuncsPtr;
+
+extern _X_EXPORT void miDamageCreate(DamagePtr);
+extern _X_EXPORT void miDamageRegister(DrawablePtr, DamagePtr);
+extern _X_EXPORT void miDamageUnregister(DrawablePtr, DamagePtr);
+extern _X_EXPORT void miDamageDestroy(DamagePtr);
+
+extern _X_EXPORT Bool
+ DamageSetup(ScreenPtr pScreen);
+
+extern _X_EXPORT DamagePtr
+DamageCreate(DamageReportFunc damageReport,
+             DamageDestroyFunc damageDestroy,
+             DamageReportLevel damageLevel,
+             Bool isInternal, ScreenPtr pScreen, void *closure);
+
+extern _X_EXPORT void
+ DamageDrawInternal(ScreenPtr pScreen, Bool enable);
+
+extern _X_EXPORT void
+ DamageRegister(DrawablePtr pDrawable, DamagePtr pDamage);
+
+extern _X_EXPORT void
+ DamageUnregister(DamagePtr pDamage);
+
+extern _X_EXPORT void
+ DamageDestroy(DamagePtr pDamage);
+
+extern _X_EXPORT Bool
+ DamageSubtract(DamagePtr pDamage, const RegionPtr pRegion);
+
+extern _X_EXPORT void
+ DamageEmpty(DamagePtr pDamage);
+
+extern _X_EXPORT RegionPtr
+ DamageRegion(DamagePtr pDamage);
+
+extern _X_EXPORT RegionPtr
+ DamagePendingRegion(DamagePtr pDamage);
+
+/* In case of rendering, call this before the submitting the commands. */
+extern _X_EXPORT void
+ DamageRegionAppend(DrawablePtr pDrawable, RegionPtr pRegion);
+
+/* Call this directly after the rendering operation has been submitted. */
+extern _X_EXPORT void
+ DamageRegionProcessPending(DrawablePtr pDrawable);
+
+/* Call this when you create a new Damage and you wish to send an initial damage message (to it). */
+extern _X_EXPORT void
+ DamageReportDamage(DamagePtr pDamage, RegionPtr pDamageRegion);
+
+/* Avoid using this call, it only exists for API compatibility. */
+extern _X_EXPORT void
+ DamageDamageRegion(DrawablePtr pDrawable, const RegionPtr pRegion);
+
+extern _X_EXPORT void
+ DamageSetReportAfterOp(DamagePtr pDamage, Bool reportAfter);
+
+extern _X_EXPORT DamageScreenFuncsPtr DamageGetScreenFuncs(ScreenPtr);
+
+#endif                          /* _DAMAGE_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damage.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getvers.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getvers.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getvers.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETVERS_H
+#define GETVERS_H 1
+
+int SProcXGetExtensionVersion(ClientPtr /* client */
+    );
+
+int ProcXGetExtensionVersion(ClientPtr  /* client */
+    );
+
+void SRepXGetExtensionVersion(ClientPtr /* client */ ,
+                              int /* size */ ,
+                              xGetExtensionVersionReply *       /* rep */
+    );
+
+#endif                          /* GETVERS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getvers.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dgaproc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dgaproc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dgaproc.h	(Revision 52145)
@@ -0,0 +1,110 @@
+
+#ifndef __DGAPROC_H
+#define __DGAPROC_H
+
+#include <X11/Xproto.h>
+#include "pixmap.h"
+
+#define DGA_CONCURRENT_ACCESS	0x00000001
+#define DGA_FILL_RECT		0x00000002
+#define DGA_BLIT_RECT		0x00000004
+#define DGA_BLIT_RECT_TRANS	0x00000008
+#define DGA_PIXMAP_AVAILABLE	0x00000010
+
+#define DGA_INTERLACED		0x00010000
+#define DGA_DOUBLESCAN		0x00020000
+
+#define DGA_FLIP_IMMEDIATE	0x00000001
+#define DGA_FLIP_RETRACE	0x00000002
+
+#define DGA_COMPLETED		0x00000000
+#define DGA_PENDING		0x00000001
+
+#define DGA_NEED_ROOT		0x00000001
+
+typedef struct {
+    int num;                    /* A unique identifier for the mode (num > 0) */
+    const char *name;           /* name of mode given in the XF86Config */
+    int VSync_num;
+    int VSync_den;
+    int flags;                  /* DGA_CONCURRENT_ACCESS, etc... */
+    int imageWidth;             /* linear accessible portion (pixels) */
+    int imageHeight;
+    int pixmapWidth;            /* Xlib accessible portion (pixels) */
+    int pixmapHeight;           /* both fields ignored if no concurrent access */
+    int bytesPerScanline;
+    int byteOrder;              /* MSBFirst, LSBFirst */
+    int depth;
+    int bitsPerPixel;
+    unsigned long red_mask;
+    unsigned long green_mask;
+    unsigned long blue_mask;
+    short visualClass;
+    int viewportWidth;
+    int viewportHeight;
+    int xViewportStep;          /* viewport position granularity */
+    int yViewportStep;
+    int maxViewportX;           /* max viewport origin */
+    int maxViewportY;
+    int viewportFlags;          /* types of page flipping possible */
+    int offset;
+    int reserved1;
+    int reserved2;
+} XDGAModeRec, *XDGAModePtr;
+
+/* DDX interface */
+
+extern _X_EXPORT int
+ DGASetMode(int Index, int num, XDGAModePtr mode, PixmapPtr *pPix);
+
+extern _X_EXPORT void
+ DGASetInputMode(int Index, Bool keyboard, Bool mouse);
+
+extern _X_EXPORT void
+ DGASelectInput(int Index, ClientPtr client, long mask);
+
+extern _X_EXPORT Bool DGAAvailable(int Index);
+extern _X_EXPORT Bool DGAScreenAvailable(ScreenPtr pScreen);
+extern _X_EXPORT Bool DGAActive(int Index);
+extern _X_EXPORT void DGAShutdown(void);
+extern _X_EXPORT void DGAInstallCmap(ColormapPtr cmap);
+extern _X_EXPORT int DGAGetViewportStatus(int Index);
+extern _X_EXPORT int DGASync(int Index);
+
+extern _X_EXPORT int
+ DGAFillRect(int Index, int x, int y, int w, int h, unsigned long color);
+
+extern _X_EXPORT int
+ DGABlitRect(int Index, int srcx, int srcy, int w, int h, int dstx, int dsty);
+
+extern _X_EXPORT int
+
+DGABlitTransRect(int Index,
+                 int srcx, int srcy,
+                 int w, int h, int dstx, int dsty, unsigned long color);
+
+extern _X_EXPORT int
+ DGASetViewport(int Index, int x, int y, int mode);
+
+extern _X_EXPORT int DGAGetModes(int Index);
+extern _X_EXPORT int DGAGetOldDGAMode(int Index);
+
+extern _X_EXPORT int DGAGetModeInfo(int Index, XDGAModePtr mode, int num);
+
+extern _X_EXPORT Bool DGAVTSwitch(void);
+extern _X_EXPORT Bool DGAStealButtonEvent(DeviceIntPtr dev, int Index,
+                                          int button, int is_down);
+extern _X_EXPORT Bool DGAStealMotionEvent(DeviceIntPtr dev, int Index, int dx,
+                                          int dy);
+extern _X_EXPORT Bool DGAStealKeyEvent(DeviceIntPtr dev, int Index,
+                                       int key_code, int is_down);
+
+extern _X_EXPORT Bool DGAOpenFramebuffer(int Index, char **name,
+                                         unsigned char **mem, int *size,
+                                         int *offset, int *flags);
+extern _X_EXPORT void DGACloseFramebuffer(int Index);
+extern _X_EXPORT Bool DGAChangePixmapMode(int Index, int *x, int *y, int mode);
+extern _X_EXPORT int DGACreateColormap(int Index, ClientPtr client, int id,
+                                       int mode, int alloc);
+
+#endif                          /* __DGAPROC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dgaproc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present.h	(Revision 52145)
@@ -0,0 +1,127 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _PRESENT_H_
+#define _PRESENT_H_
+
+#include <X11/extensions/presentproto.h>
+#include "randrstr.h"
+#include "presentext.h"
+
+typedef struct present_vblank present_vblank_rec, *present_vblank_ptr;
+
+/* Return the current CRTC for 'window'.
+ */
+typedef RRCrtcPtr (*present_get_crtc_ptr) (WindowPtr window);
+
+/* Return the current ust/msc for 'crtc'
+ */
+typedef int (*present_get_ust_msc_ptr) (RRCrtcPtr crtc, uint64_t *ust, uint64_t *msc);
+
+/* Queue callback on 'crtc' for time 'msc'. Call present_event_notify with 'event_id'
+ * at or after 'msc'. Return false if it didn't happen (which might occur if 'crtc'
+ * is not currently generating vblanks).
+ */
+typedef Bool (*present_queue_vblank_ptr) (RRCrtcPtr crtc,
+                                          uint64_t event_id,
+                                          uint64_t msc);
+
+/* Abort pending vblank. The extension is no longer interested in
+ * 'event_id' which was to be notified at 'msc'. If possible, the
+ * driver is free to de-queue the notification.
+ */
+typedef void (*present_abort_vblank_ptr) (RRCrtcPtr crtc, uint64_t event_id, uint64_t msc);
+
+/* Flush pending drawing on 'window' to the hardware.
+ */
+typedef void (*present_flush_ptr) (WindowPtr window);
+
+/* Check if 'pixmap' is suitable for flipping to 'window'.
+ */
+typedef Bool (*present_check_flip_ptr) (RRCrtcPtr crtc, WindowPtr window, PixmapPtr pixmap, Bool sync_flip);
+
+/* Flip pixmap, return false if it didn't happen.
+ *
+ * 'crtc' is to be used for any necessary synchronization.
+ *
+ * 'sync_flip' requests that the flip be performed at the next
+ * vertical blank interval to avoid tearing artifacts. If false, the
+ * flip should be performed as soon as possible.
+ *
+ * present_event_notify should be called with 'event_id' when the flip
+ * occurs
+ */
+typedef Bool (*present_flip_ptr) (RRCrtcPtr crtc,
+                                  uint64_t event_id,
+                                  uint64_t target_msc,
+                                  PixmapPtr pixmap,
+                                  Bool sync_flip);
+
+/* "unflip" back to the regular screen scanout buffer
+ *
+ * present_event_notify should be called with 'event_id' when the unflip occurs.
+ */
+typedef void (*present_unflip_ptr) (ScreenPtr screen,
+                                    uint64_t event_id);
+
+#define PRESENT_SCREEN_INFO_VERSION        0
+
+typedef struct present_screen_info {
+    uint32_t                            version;
+
+    present_get_crtc_ptr                get_crtc;
+    present_get_ust_msc_ptr             get_ust_msc;
+    present_queue_vblank_ptr            queue_vblank;
+    present_abort_vblank_ptr            abort_vblank;
+    present_flush_ptr                   flush;
+    uint32_t                            capabilities;
+    present_check_flip_ptr              check_flip;
+    present_flip_ptr                    flip;
+    present_unflip_ptr                  unflip;
+
+} present_screen_info_rec, *present_screen_info_ptr;
+
+/*
+ * Called when 'event_id' occurs. 'ust' and 'msc' indicate when the
+ * event actually happened
+ */
+extern _X_EXPORT void
+present_event_notify(uint64_t event_id, uint64_t ust, uint64_t msc);
+
+/* 'crtc' has been turned off, so any pending events will never occur.
+ */
+extern _X_EXPORT void
+present_event_abandon(RRCrtcPtr crtc);
+
+extern _X_EXPORT Bool
+present_screen_init(ScreenPtr screen, present_screen_info_ptr info);
+
+typedef void (*present_complete_notify_proc)(WindowPtr window,
+                                             CARD8 mode,
+                                             CARD32 serial,
+                                             uint64_t ust,
+                                             uint64_t msc);
+
+extern _X_EXPORT void
+present_register_complete_notify(present_complete_notify_proc proc);
+
+#endif /* _PRESENT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/present.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxserver.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxserver.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxserver.h	(Revision 52145)
@@ -0,0 +1,242 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GLX_server_h_
+#define _GLX_server_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include <X11/Xmd.h>
+#include <misc.h>
+#include <dixstruct.h>
+#include <pixmapstr.h>
+#include <gcstruct.h>
+#include <extnsionst.h>
+#include <resource.h>
+#include <scrnintstr.h>
+
+#include <GL/gl.h>
+#include <GL/glext.h>
+#include <GL/glxproto.h>
+
+/*
+** GLX resources.
+*/
+typedef XID GLXContextID;
+typedef XID GLXPixmap;
+typedef XID GLXDrawable;
+
+typedef struct __GLXclientStateRec __GLXclientState;
+typedef struct __GLXdrawable __GLXdrawable;
+typedef struct __GLXcontext __GLXcontext;
+
+#include "glxscreens.h"
+#include "glxdrawable.h"
+#include "glxcontext.h"
+
+#ifndef True
+#define True 1
+#endif
+#ifndef False
+#define False 0
+#endif
+
+extern __GLXscreen *glxGetScreen(ScreenPtr pScreen);
+extern __GLXclientState *glxGetClient(ClientPtr pClient);
+
+/************************************************************************/
+
+void GlxSetVisualConfigs(int nconfigs, void *configs, void **privates);
+
+void __glXScreenInitVisuals(__GLXscreen * screen);
+
+/*
+** The last context used (from the server's persective) is cached.
+*/
+extern __GLXcontext *__glXForceCurrent(__GLXclientState *, GLXContextTag,
+                                       int *);
+
+int __glXError(int error);
+
+/************************************************************************/
+
+typedef struct __GLXprovider __GLXprovider;
+struct __GLXprovider {
+    __GLXscreen *(*screenProbe) (ScreenPtr pScreen);
+    const char *name;
+    __GLXprovider *next;
+};
+extern __GLXprovider __glXDRISWRastProvider;
+
+void GlxPushProvider(__GLXprovider * provider);
+
+enum {
+    GLX_MINIMAL_VISUALS,
+    GLX_TYPICAL_VISUALS,
+    GLX_ALL_VISUALS
+};
+
+void __glXsetEnterLeaveServerFuncs(void (*enter) (GLboolean),
+                                   void (*leave) (GLboolean));
+void __glXenterServer(GLboolean rendering);
+void __glXleaveServer(GLboolean rendering);
+
+void glxSuspendClients(void);
+void glxResumeClients(void);
+
+typedef void (*glx_func_ptr)(void);
+typedef glx_func_ptr (*glx_gpa_proc)(const char *);
+void __glXsetGetProcAddress(glx_gpa_proc get_proc_address);
+void *__glGetProcAddress(const char *);
+
+void
+__glXsendSwapEvent(__GLXdrawable *drawable, int type, CARD64 ust,
+                   CARD64 msc, CARD32 sbc);
+
+#if PRESENT
+void
+__glXregisterPresentCompleteNotify(void);
+#endif
+
+/*
+** State kept per client.
+*/
+struct __GLXclientStateRec {
+    /*
+     ** Whether this structure is currently being used to support a client.
+     */
+    Bool inUse;
+
+    /*
+     ** Buffer for returned data.
+     */
+    GLbyte *returnBuf;
+    GLint returnBufSize;
+
+    /*
+     ** Keep track of large rendering commands, which span multiple requests.
+     */
+    GLint largeCmdBytesSoFar;   /* bytes received so far        */
+    GLint largeCmdBytesTotal;   /* total bytes expected         */
+    GLint largeCmdRequestsSoFar;        /* requests received so far     */
+    GLint largeCmdRequestsTotal;        /* total requests expected      */
+    GLbyte *largeCmdBuf;
+    GLint largeCmdBufSize;
+
+    /* Back pointer to X client record */
+    ClientPtr client;
+
+    char *GLClientextensions;
+};
+
+/************************************************************************/
+
+/*
+** Dispatch tables.
+*/
+typedef void (*__GLXdispatchRenderProcPtr) (GLbyte *);
+typedef int (*__GLXdispatchSingleProcPtr) (__GLXclientState *, GLbyte *);
+typedef int (*__GLXdispatchVendorPrivProcPtr) (__GLXclientState *, GLbyte *);
+
+/*
+ * Dispatch for GLX commands.
+ */
+typedef int (*__GLXprocPtr) (__GLXclientState *, char *pc);
+
+/*
+ * Tables for computing the size of each rendering command.
+ */
+typedef int (*gl_proto_size_func) (const GLbyte *, Bool);
+
+typedef struct {
+    int bytes;
+    gl_proto_size_func varsize;
+} __GLXrenderSizeData;
+
+/************************************************************************/
+
+/*
+** X resources.
+*/
+extern RESTYPE __glXContextRes;
+extern RESTYPE __glXClientRes;
+extern RESTYPE __glXPixmapRes;
+extern RESTYPE __glXDrawableRes;
+
+/************************************************************************/
+
+/*
+** Prototypes.
+*/
+
+extern char *__glXcombine_strings(const char *, const char *);
+
+/*
+** Routines for sending swapped replies.
+*/
+
+extern void __glXSwapMakeCurrentReply(ClientPtr client,
+                                      xGLXMakeCurrentReply * reply);
+extern void __glXSwapIsDirectReply(ClientPtr client, xGLXIsDirectReply * reply);
+extern void __glXSwapQueryVersionReply(ClientPtr client,
+                                       xGLXQueryVersionReply * reply);
+extern void __glXSwapQueryContextInfoEXTReply(ClientPtr client,
+                                              xGLXQueryContextInfoEXTReply *
+                                              reply, int *buf);
+extern void __glXSwapGetDrawableAttributesReply(ClientPtr client,
+                                                xGLXGetDrawableAttributesReply *
+                                                reply, CARD32 *buf);
+extern void glxSwapQueryExtensionsStringReply(ClientPtr client,
+                                              xGLXQueryExtensionsStringReply *
+                                              reply, char *buf);
+extern void glxSwapQueryServerStringReply(ClientPtr client,
+                                          xGLXQueryServerStringReply * reply,
+                                          char *buf);
+
+/*
+ * Routines for computing the size of variably-sized rendering commands.
+ */
+
+extern int __glXTypeSize(GLenum enm);
+extern int __glXImageSize(GLenum format, GLenum type,
+                          GLenum target, GLsizei w, GLsizei h, GLsizei d,
+                          GLint imageHeight, GLint rowLength, GLint skipImages,
+                          GLint skipRows, GLint alignment);
+
+extern unsigned glxMajorVersion;
+extern unsigned glxMinorVersion;
+
+extern int __glXEventBase;
+
+#endif                          /* !__GLX_server_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxserver.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSlib.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSlib.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSlib.h	(Revision 52145)
@@ -0,0 +1,371 @@
+/*
+ * Copyright 1990, 1991 by Thomas Roell, Dinkelscherben, Germany
+ * Copyright 1992 by David Dawes <dawes@XFree86.org>
+ * Copyright 1992 by Jim Tsillas <jtsilla@damon.ccs.northeastern.edu>
+ * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
+ * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
+ * Copyright 1992 by Orest Zborowski <obz@eskimo.com>
+ * Copyright 1993 by Vrije Universiteit, The Netherlands
+ * Copyright 1993 by David Wexelblat <dwex@XFree86.org>
+ * Copyright 1994, 1996 by Holger Veit <Holger.Veit@gmd.de>
+ * Copyright 1997 by Takis Psarogiannakopoulos <takis@dpmms.cam.ac.uk>
+ * Copyright 1994-2003 by The XFree86 Project, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holders 
+ * not be used in advertising or publicity pertaining to distribution of 
+ * the software without specific, written prior permission.  The above listed
+ * copyright holders make no representations about the suitability of this 
+ * software for any purpose.  It is provided "as is" without express or 
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD 
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDERS BE 
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING 
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * The ARM32 code here carries the following copyright:
+ *
+ * Copyright 1997
+ * Digital Equipment Corporation. All rights reserved.
+ * This software is furnished under license and may be used and copied only in 
+ * accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * this software in source and/or binary form. No title or ownership is
+ * transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and retain
+ *    this copyright notice and list of conditions as they appear in the
+ *    source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of Digital 
+ *    Equipment Corporation. Neither the "Digital Equipment Corporation"
+ *    name nor any trademark or logo of Digital Equipment Corporation may be
+ *    used to endorse or promote products derived from this software without
+ *    the prior written permission of Digital Equipment Corporation.
+ *
+ * 3) This software is provided "AS-IS" and any express or implied warranties,
+ *    including but not limited to, any implied warranties of merchantability,
+ *    fitness for a particular purpose, or non-infringement are disclaimed.
+ *    In no event shall DIGITAL be liable for any damages whatsoever, and in
+ *    particular, DIGITAL shall not be liable for special, indirect,
+ *    consequential, or incidental damages or damages for lost profits, loss
+ *    of revenue or loss of use, whether such damages arise in contract, 
+ *    negligence, tort, under statute, in equity, at law or otherwise, even
+ *    if advised of the possibility of such damage. 
+ *
+ */
+
+/*
+ * This is private, and should not be included by any drivers.  Drivers
+ * may include xf86_OSproc.h to get prototypes for public interfaces.
+ */
+
+#ifndef _XF86_OSLIB_H
+#define _XF86_OSLIB_H
+
+#include <X11/Xos.h>
+#include <X11/Xfuncproto.h>
+
+#include <stdio.h>
+#include <ctype.h>
+#include <stddef.h>
+
+/**************************************************************************/
+/* SYSV386 (SVR3, SVR4), including Solaris                                */
+/**************************************************************************/
+#if (defined(SYSV) || defined(SVR4)) && \
+    (defined(sun) || defined(__i386__))
+#include <sys/ioctl.h>
+#include <signal.h>
+#include <termio.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <errno.h>
+
+#if defined(_NEED_SYSI86)
+#if !(defined (sun) && defined (SVR4))
+#include <sys/immu.h>
+#include <sys/region.h>
+#include <sys/proc.h>
+#endif
+#include <sys/tss.h>
+#include <sys/sysi86.h>
+#if defined(SVR4) && !defined(sun)
+#include <sys/seg.h>
+#endif                          /* SVR4 && !sun */
+/* V86SC_IOPL was moved to <sys/sysi86.h> on Solaris 7 and later */
+#if !defined(V86SC_IOPL)        /* Solaris 7 or later? */
+#include <sys/v86.h>            /* Nope */
+#endif
+#if defined(sun) && (defined (__i386__) || defined(__i386) || defined(__x86))  && defined (SVR4)
+#include <sys/psw.h>
+#endif
+#endif                          /* _NEED_SYSI86 */
+
+#if defined(HAS_SVR3_MMAPDRV)
+#include <sys/sysmacros.h>
+#if !defined(_NEED_SYSI86)
+#include <sys/immu.h>
+#include <sys/region.h>
+#endif
+#include <sys/mmap.h>           /* MMAP driver header */
+#endif
+
+#if !defined(sun) || defined(HAVE_SYS_VT_H)
+#define HAS_USL_VTS
+#endif
+#if !defined(sun)
+#include <sys/emap.h>
+#endif
+#if   defined(HAS_USL_VTS)
+#if !defined(sun)
+#include <sys/at_ansi.h>
+#endif
+#include <sys/kd.h>
+#include <sys/vt.h>
+#endif
+
+#if defined(sun)
+#include <sys/fbio.h>
+#include <sys/kbd.h>
+#include <sys/kbio.h>
+
+/* undefine symbols from <sys/kbd.h> we don't need that conflict with enum
+   definitions in parser/xf86tokens.h */
+#undef STRING
+#undef LEFTALT
+#undef RIGHTALT
+
+#define LED_CAP LED_CAPS_LOCK
+#define LED_NUM LED_NUM_LOCK
+#define LED_SCR LED_SCROLL_LOCK
+#define LED_COMP LED_COMPOSE
+#endif                          /* sun */
+
+#if !defined(VT_ACKACQ)
+#define VT_ACKACQ 2
+#endif                          /* !VT_ACKACQ */
+
+#if defined(SVR4)
+#include <sys/mman.h>
+#if !(defined(sun) && defined (SVR4))
+#define DEV_MEM "/dev/pmem"
+#endif
+#define CLEARDTR_SUPPORT
+#define POSIX_TTY
+#endif                          /* SVR4 */
+
+#endif                          /* (SYSV || SVR4) */
+
+/**************************************************************************/
+/* Linux or Glibc-based system                                            */
+/**************************************************************************/
+#if defined(__linux__) || defined(__GLIBC__) || defined(__CYGWIN__)
+#include <sys/ioctl.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <assert.h>
+
+#ifdef __linux__
+#include <termio.h>
+#else                           /* __GLIBC__ */
+#include <termios.h>
+#endif
+#ifdef __sparc__
+#include <sys/param.h>
+#endif
+
+#include <errno.h>
+
+#include <sys/stat.h>
+
+#include <sys/mman.h>
+#ifdef __linux__
+#define HAS_USL_VTS
+#include <sys/kd.h>
+#include <sys/vt.h>
+#define LDGMAP GIO_SCRNMAP
+#define LDSMAP PIO_SCRNMAP
+#define LDNMAP LDSMAP
+#define CLEARDTR_SUPPORT
+#endif
+
+#define POSIX_TTY
+
+#endif                          /* __linux__ || __GLIBC__ */
+
+/**************************************************************************/
+/* 386BSD and derivatives,  BSD/386                                       */
+/**************************************************************************/
+
+#if defined(__386BSD__) && (defined(__FreeBSD__) || defined(__NetBSD__))
+#undef __386BSD__
+#endif
+
+#ifdef CSRG_BASED
+#include <sys/ioctl.h>
+#include <signal.h>
+
+#include <termios.h>
+#define termio termios
+#define POSIX_TTY
+
+#include <errno.h>
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+
+#endif                          /* CSRG_BASED */
+
+/**************************************************************************/
+/* Kernel of *BSD                                                         */
+/**************************************************************************/
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
+ defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+
+#include <sys/param.h>
+#if defined(__FreeBSD_version) && !defined(__FreeBSD_kernel_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+
+#if !defined(LINKKIT)
+  /* Don't need this stuff for the Link Kit */
+#ifdef SYSCONS_SUPPORT
+#define COMPAT_SYSCONS
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#if defined(__DragonFly__)  || (__FreeBSD_kernel_version >= 410000)
+#include <sys/consio.h>
+#include <sys/kbio.h>
+#else
+#include <machine/console.h>
+#endif                          /* FreeBSD 4.1 RELEASE or lator */
+#else
+#include <sys/console.h>
+#endif
+#endif                          /* SYSCONS_SUPPORT */
+#if defined(PCVT_SUPPORT) && !defined(__NetBSD__) && !defined(__OpenBSD__)
+#if !defined(SYSCONS_SUPPORT)
+      /* no syscons, so include pcvt specific header file */
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#include <machine/pcvt_ioctl.h>
+#else
+#include <sys/pcvt_ioctl.h>
+#endif                          /* __FreeBSD_kernel__ */
+#else                           /* pcvt and syscons: hard-code the ID magic */
+#define VGAPCVTID _IOWR('V',113, struct pcvtid)
+struct pcvtid {
+    char name[16];
+    int rmajor, rminor;
+};
+#endif                          /* PCVT_SUPPORT && SYSCONS_SUPPORT */
+#endif                          /* PCVT_SUPPORT */
+#ifdef WSCONS_SUPPORT
+#include <dev/wscons/wsconsio.h>
+#include <dev/wscons/wsdisplay_usl_io.h>
+#endif                          /* WSCONS_SUPPORT */
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#include <sys/mouse.h>
+#endif
+    /* Include these definitions in case ioctl_pc.h didn't get included */
+#ifndef CONSOLE_X_MODE_ON
+#define CONSOLE_X_MODE_ON _IO('t',121)
+#endif
+#ifndef CONSOLE_X_MODE_OFF
+#define CONSOLE_X_MODE_OFF _IO('t',122)
+#endif
+#ifndef CONSOLE_X_BELL
+#define CONSOLE_X_BELL _IOW('t',123,int[2])
+#endif
+#ifndef CONSOLE_X_TV_ON
+#define CONSOLE_X_TV_ON _IOW('t',155,int)
+#define XMODE_RGB   0
+#define XMODE_NTSC  1
+#define XMODE_PAL   2
+#define XMODE_SECAM 3
+#endif
+#ifndef CONSOLE_X_TV_OFF
+#define CONSOLE_X_TV_OFF _IO('t',156)
+#endif
+#ifndef CONSOLE_GET_LINEAR_INFO
+#define CONSOLE_GET_LINEAR_INFO         _IOR('t',157,struct map_info)
+#endif
+#ifndef CONSOLE_GET_IO_INFO
+#define CONSOLE_GET_IO_INFO             _IOR('t',158,struct map_info)
+#endif
+#ifndef CONSOLE_GET_MEM_INFO
+#define CONSOLE_GET_MEM_INFO            _IOR('t',159,struct map_info)
+#endif
+#endif                          /* !LINKKIT */
+
+#if defined(USE_I386_IOPL) || defined(USE_AMD64_IOPL)
+#include <machine/sysarch.h>
+#endif
+
+#define CLEARDTR_SUPPORT
+
+#endif                          /* __FreeBSD__ || __NetBSD__ || __OpenBSD__ || __DragonFly__ */
+
+/**************************************************************************/
+/* IRIX                                                                   */
+/**************************************************************************/
+
+/**************************************************************************/
+/* Generic                                                                */
+/**************************************************************************/
+
+#include <sys/wait.h>           /* May need to adjust this for other OSs */
+
+/* For PATH_MAX */
+#include "misc.h"
+
+/* 
+ * Hack originally for ISC 2.2 POSIX headers, but may apply elsewhere,
+ * and it's safe, so just do it.
+ */
+#if !defined(O_NDELAY) && defined(O_NONBLOCK)
+#define O_NDELAY O_NONBLOCK
+#endif                          /* !O_NDELAY && O_NONBLOCK */
+
+#if !defined(MAXHOSTNAMELEN)
+#define MAXHOSTNAMELEN 32
+#endif                          /* !MAXHOSTNAMELEN */
+
+#if defined(_POSIX_SOURCE)
+#include <limits.h>
+#else
+#define _POSIX_SOURCE
+#include <limits.h>
+#undef _POSIX_SOURCE
+#endif                          /* _POSIX_SOURCE */
+
+#ifndef DEV_MEM
+#define DEV_MEM "/dev/mem"
+#endif
+
+#ifndef MAP_FAILED
+#define MAP_FAILED ((void *)-1)
+#endif
+
+#define SYSCALL(call) while(((call) == -1) && (errno == EINTR))
+
+#define XF86_OS_PRIVS
+#include "xf86_OSproc.h"
+
+#ifndef NO_COMPILER_H
+#include "compiler.h"
+#endif
+
+#endif                          /* _XF86_OSLIB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86_OSlib.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxscrinit.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxscrinit.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxscrinit.h	(Revision 52145)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *   David H. Dawes <dawes@xfree86.org>
+ *
+ */
+
+/** \file
+ * Interface for screen initialization.  \see dmxscrinit.c */
+
+#ifndef DMXSCRINIT_H
+#define DMXSCRINIT_H
+
+#include "scrnintstr.h"
+
+extern Bool dmxScreenInit(ScreenPtr pScreen, int argc, char *argv[]);
+
+extern void dmxBEScreenInit(ScreenPtr pScreen);
+extern void dmxBECloseScreen(ScreenPtr pScreen);
+
+#endif                          /* DMXSCRINIT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxscrinit.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86str.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86str.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86str.h	(Revision 52145)
@@ -0,0 +1,900 @@
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the public XFree86 data structures/types.
+ * Any data structures that video drivers need to access should go here.
+ */
+
+#ifndef _XF86STR_H
+#define _XF86STR_H
+
+#include "misc.h"
+#include "input.h"
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "colormapst.h"
+#include "xf86Module.h"
+#include "xf86Opt.h"
+
+/**
+ * Integer type that is of the size of the addressable memory (machine size).
+ * On most platforms \c uintptr_t will suffice.  However, on some mixed
+ * 32-bit / 64-bit platforms, such as 32-bit binaries on 64-bit PowerPC, this
+ * must be 64-bits.
+ */
+#include <inttypes.h>
+#if defined(__powerpc__)
+typedef uint64_t memType;
+#else
+typedef uintptr_t memType;
+#endif
+
+/* Video mode flags */
+
+typedef enum {
+    V_PHSYNC = 0x0001,
+    V_NHSYNC = 0x0002,
+    V_PVSYNC = 0x0004,
+    V_NVSYNC = 0x0008,
+    V_INTERLACE = 0x0010,
+    V_DBLSCAN = 0x0020,
+    V_CSYNC = 0x0040,
+    V_PCSYNC = 0x0080,
+    V_NCSYNC = 0x0100,
+    V_HSKEW = 0x0200,           /* hskew provided */
+    V_BCAST = 0x0400,
+    V_PIXMUX = 0x1000,
+    V_DBLCLK = 0x2000,
+    V_CLKDIV2 = 0x4000
+} ModeFlags;
+
+typedef enum {
+    INTERLACE_HALVE_V = 0x0001  /* Halve V values for interlacing */
+} CrtcAdjustFlags;
+
+/* Flags passed to ChipValidMode() */
+typedef enum {
+    MODECHECK_INITIAL = 0,
+    MODECHECK_FINAL = 1
+} ModeCheckFlags;
+
+/* These are possible return values for xf86CheckMode() and ValidMode() */
+typedef enum {
+    MODE_OK = 0,                /* Mode OK */
+    MODE_HSYNC,                 /* hsync out of range */
+    MODE_VSYNC,                 /* vsync out of range */
+    MODE_H_ILLEGAL,             /* mode has illegal horizontal timings */
+    MODE_V_ILLEGAL,             /* mode has illegal horizontal timings */
+    MODE_BAD_WIDTH,             /* requires an unsupported linepitch */
+    MODE_NOMODE,                /* no mode with a maching name */
+    MODE_NO_INTERLACE,          /* interlaced mode not supported */
+    MODE_NO_DBLESCAN,           /* doublescan mode not supported */
+    MODE_NO_VSCAN,              /* multiscan mode not supported */
+    MODE_MEM,                   /* insufficient video memory */
+    MODE_VIRTUAL_X,             /* mode width too large for specified virtual size */
+    MODE_VIRTUAL_Y,             /* mode height too large for specified virtual size */
+    MODE_MEM_VIRT,              /* insufficient video memory given virtual size */
+    MODE_NOCLOCK,               /* no fixed clock available */
+    MODE_CLOCK_HIGH,            /* clock required is too high */
+    MODE_CLOCK_LOW,             /* clock required is too low */
+    MODE_CLOCK_RANGE,           /* clock/mode isn't in a ClockRange */
+    MODE_BAD_HVALUE,            /* horizontal timing was out of range */
+    MODE_BAD_VVALUE,            /* vertical timing was out of range */
+    MODE_BAD_VSCAN,             /* VScan value out of range */
+    MODE_HSYNC_NARROW,          /* horizontal sync too narrow */
+    MODE_HSYNC_WIDE,            /* horizontal sync too wide */
+    MODE_HBLANK_NARROW,         /* horizontal blanking too narrow */
+    MODE_HBLANK_WIDE,           /* horizontal blanking too wide */
+    MODE_VSYNC_NARROW,          /* vertical sync too narrow */
+    MODE_VSYNC_WIDE,            /* vertical sync too wide */
+    MODE_VBLANK_NARROW,         /* vertical blanking too narrow */
+    MODE_VBLANK_WIDE,           /* vertical blanking too wide */
+    MODE_PANEL,                 /* exceeds panel dimensions */
+    MODE_INTERLACE_WIDTH,       /* width too large for interlaced mode */
+    MODE_ONE_WIDTH,             /* only one width is supported */
+    MODE_ONE_HEIGHT,            /* only one height is supported */
+    MODE_ONE_SIZE,              /* only one resolution is supported */
+    MODE_NO_REDUCED,            /* monitor doesn't accept reduced blanking */
+    MODE_BANDWIDTH,             /* mode requires too much memory bandwidth */
+    MODE_BAD = -2,              /* unspecified reason */
+    MODE_ERROR = -1             /* error condition */
+} ModeStatus;
+
+/*
+ * The mode sets are, from best to worst: USERDEF, DRIVER, and DEFAULT/BUILTIN.
+ * Preferred will bubble a mode to the top within a set.
+ */
+#define M_T_BUILTIN 0x01        /* built-in mode */
+#define M_T_CLOCK_C (0x02 | M_T_BUILTIN)        /* built-in mode - configure clock */
+#define M_T_CRTC_C  (0x04 | M_T_BUILTIN)        /* built-in mode - configure CRTC  */
+#define M_T_CLOCK_CRTC_C  (M_T_CLOCK_C | M_T_CRTC_C)
+                               /* built-in mode - configure CRTC and clock */
+#define M_T_PREFERRED 0x08      /* preferred mode within a set */
+#define M_T_DEFAULT 0x10        /* (VESA) default modes */
+#define M_T_USERDEF 0x20        /* One of the modes from the config file */
+#define M_T_DRIVER  0x40        /* Supplied by the driver (EDID, etc) */
+#define M_T_USERPREF 0x80       /* mode preferred by the user config */
+
+/* Video mode */
+typedef struct _DisplayModeRec {
+    struct _DisplayModeRec *prev;
+    struct _DisplayModeRec *next;
+    const char *name;           /* identifier for the mode */
+    ModeStatus status;
+    int type;
+
+    /* These are the values that the user sees/provides */
+    int Clock;                  /* pixel clock freq (kHz) */
+    int HDisplay;               /* horizontal timing */
+    int HSyncStart;
+    int HSyncEnd;
+    int HTotal;
+    int HSkew;
+    int VDisplay;               /* vertical timing */
+    int VSyncStart;
+    int VSyncEnd;
+    int VTotal;
+    int VScan;
+    int Flags;
+
+    /* These are the values the hardware uses */
+    int ClockIndex;
+    int SynthClock;             /* Actual clock freq to
+                                 * be programmed  (kHz) */
+    int CrtcHDisplay;
+    int CrtcHBlankStart;
+    int CrtcHSyncStart;
+    int CrtcHSyncEnd;
+    int CrtcHBlankEnd;
+    int CrtcHTotal;
+    int CrtcHSkew;
+    int CrtcVDisplay;
+    int CrtcVBlankStart;
+    int CrtcVSyncStart;
+    int CrtcVSyncEnd;
+    int CrtcVBlankEnd;
+    int CrtcVTotal;
+    Bool CrtcHAdjusted;
+    Bool CrtcVAdjusted;
+    int PrivSize;
+    INT32 *Private;
+    int PrivFlags;
+
+    float HSync, VRefresh;
+} DisplayModeRec, *DisplayModePtr;
+
+/* The monitor description */
+
+#define MAX_HSYNC 8
+#define MAX_VREFRESH 8
+
+typedef struct {
+    float hi, lo;
+} range;
+
+typedef struct {
+    CARD32 red, green, blue;
+} rgb;
+
+typedef struct {
+    float red, green, blue;
+} Gamma;
+
+/* The permitted gamma range is 1 / GAMMA_MAX <= g <= GAMMA_MAX */
+#define GAMMA_MAX	10.0
+#define GAMMA_MIN	(1.0 / GAMMA_MAX)
+#define GAMMA_ZERO	(GAMMA_MIN / 100.0)
+
+typedef struct {
+    const char *id;
+    const char *vendor;
+    const char *model;
+    int nHsync;
+    range hsync[MAX_HSYNC];
+    int nVrefresh;
+    range vrefresh[MAX_VREFRESH];
+    DisplayModePtr Modes;       /* Start of the monitor's mode list */
+    DisplayModePtr Last;        /* End of the monitor's mode list */
+    Gamma gamma;                /* Gamma of the monitor */
+    int widthmm;
+    int heightmm;
+    void *options;
+    void *DDC;
+    Bool reducedblanking;       /* Allow CVT reduced blanking modes? */
+    int maxPixClock;            /* in kHz, like mode->Clock */
+} MonRec, *MonPtr;
+
+/* the list of clock ranges */
+typedef struct x_ClockRange {
+    struct x_ClockRange *next;
+    int minClock;               /* (kHz) */
+    int maxClock;               /* (kHz) */
+    int clockIndex;             /* -1 for programmable clocks */
+    Bool interlaceAllowed;
+    Bool doubleScanAllowed;
+    int ClockMulFactor;
+    int ClockDivFactor;
+    int PrivFlags;
+} ClockRange, *ClockRangePtr;
+
+/*
+ * The driverFunc. xorgDriverFuncOp specifies the action driver should
+ * perform. If requested option is not supported function should return
+ * FALSE. pointer can be used to pass arguments to the function or
+ * to return data to the caller.
+ */
+typedef struct _ScrnInfoRec *ScrnInfoPtr;
+
+/* do not change order */
+typedef enum {
+    RR_GET_INFO,
+    RR_SET_CONFIG,
+    RR_GET_MODE_MM,
+    GET_REQUIRED_HW_INTERFACES = 10,
+    SUPPORTS_SERVER_FDS = 11,
+} xorgDriverFuncOp;
+
+typedef Bool xorgDriverFuncProc(ScrnInfoPtr, xorgDriverFuncOp, void *);
+
+/* RR_GET_INFO, RR_SET_CONFIG */
+typedef struct {
+    int rotation;
+    int rate;
+    int width;
+    int height;
+} xorgRRConfig;
+
+typedef union {
+    short RRRotations;
+    xorgRRConfig RRConfig;
+} xorgRRRotation, *xorgRRRotationPtr;
+
+/* RR_GET_MODE_MM */
+typedef struct {
+    DisplayModePtr mode;
+    int virtX;
+    int virtY;
+    int mmWidth;
+    int mmHeight;
+} xorgRRModeMM, *xorgRRModeMMPtr;
+
+/* GET_REQUIRED_HW_INTERFACES */
+#define HW_IO 1
+#define HW_MMIO 2
+#define HW_SKIP_CONSOLE 4
+#define NEED_IO_ENABLED(x) (x & HW_IO)
+
+typedef CARD32 xorgHWFlags;
+
+/*
+ * The driver list struct.  This contains the information required for each
+ * driver before a ScrnInfoRec has been allocated.
+ */
+struct _DriverRec;
+
+typedef struct {
+    int driverVersion;
+    const char *driverName;
+    void (*Identify) (int flags);
+    Bool (*Probe) (struct _DriverRec * drv, int flags);
+    const OptionInfoRec *(*AvailableOptions) (int chipid, int bustype);
+    void *module;
+    int refCount;
+} DriverRec1;
+
+struct _SymTabRec;
+struct _PciChipsets;
+
+struct pci_device;
+struct xf86_platform_device;
+
+typedef struct _DriverRec {
+    int driverVersion;
+    const char *driverName;
+    void (*Identify) (int flags);
+    Bool (*Probe) (struct _DriverRec * drv, int flags);
+    const OptionInfoRec *(*AvailableOptions) (int chipid, int bustype);
+    void *module;
+    int refCount;
+    xorgDriverFuncProc *driverFunc;
+
+    const struct pci_id_match *supported_devices;
+    Bool (*PciProbe) (struct _DriverRec * drv, int entity_num,
+                      struct pci_device * dev, intptr_t match_data);
+    Bool (*platformProbe) (struct _DriverRec * drv, int entity_num, int flags,
+                           struct xf86_platform_device * dev, intptr_t match_data);
+} DriverRec, *DriverPtr;
+
+/*
+ * platform probe flags
+ */
+#define PLATFORM_PROBE_GPU_SCREEN 1
+
+/*
+ *  AddDriver flags
+ */
+#define HaveDriverFuncs 1
+
+/*
+ * These are the private bus types.  New types can be added here.  Types
+ * required for the public interface should be added to xf86str.h, with
+ * function prototypes added to xf86.h.
+ */
+
+/* Tolerate prior #include <linux/input.h> */
+#if defined(linux)
+#undef BUS_NONE
+#undef BUS_PCI
+#undef BUS_SBUS
+#undef BUS_PLATFORM
+#undef BUS_last
+#endif
+
+typedef enum {
+    BUS_NONE,
+    BUS_PCI,
+    BUS_SBUS,
+    BUS_PLATFORM,
+    BUS_last                    /* Keep last */
+} BusType;
+
+typedef struct {
+    int fbNum;
+} SbusBusId;
+
+typedef struct _bus {
+    BusType type;
+    union {
+        struct pci_device *pci;
+        SbusBusId sbus;
+        struct xf86_platform_device *plat;
+    } id;
+} BusRec, *BusPtr;
+
+#define MAXCLOCKS   128
+typedef enum {
+    DAC_BPP8 = 0,
+    DAC_BPP16,
+    DAC_BPP24,
+    DAC_BPP32,
+    MAXDACSPEEDS
+} DacSpeedIndex;
+
+typedef struct {
+    const char *identifier;
+    const char *vendor;
+    const char *board;
+    const char *chipset;
+    const char *ramdac;
+    const char *driver;
+    struct _confscreenrec *myScreenSection;
+    Bool claimed;
+    int dacSpeeds[MAXDACSPEEDS];
+    int numclocks;
+    int clock[MAXCLOCKS];
+    const char *clockchip;
+    const char *busID;
+    Bool active;
+    Bool inUse;
+    int videoRam;
+    int textClockFreq;
+    unsigned long BiosBase;     /* Base address of video BIOS */
+    unsigned long MemBase;      /* Frame buffer base address */
+    unsigned long IOBase;
+    int chipID;
+    int chipRev;
+    void *options;
+    int irq;
+    int screen;                 /* For multi-CRTC cards */
+} GDevRec, *GDevPtr;
+
+typedef struct {
+    int frameX0;
+    int frameY0;
+    int virtualX;
+    int virtualY;
+    int depth;
+    int fbbpp;
+    rgb weight;
+    rgb blackColour;
+    rgb whiteColour;
+    int defaultVisual;
+    const char **modes;
+    void *options;
+} DispRec, *DispPtr;
+
+typedef struct _confxvportrec {
+    const char *identifier;
+    void *options;
+} confXvPortRec, *confXvPortPtr;
+
+typedef struct _confxvadaptrec {
+    const char *identifier;
+    int numports;
+    confXvPortPtr ports;
+    void *options;
+} confXvAdaptorRec, *confXvAdaptorPtr;
+
+typedef struct _confscreenrec {
+    const char *id;
+    int screennum;
+    int defaultdepth;
+    int defaultbpp;
+    int defaultfbbpp;
+    MonPtr monitor;
+    GDevPtr device;
+    int numdisplays;
+    DispPtr displays;
+    int numxvadaptors;
+    confXvAdaptorPtr xvadaptors;
+    void *options;
+} confScreenRec, *confScreenPtr;
+
+typedef enum {
+    PosObsolete = -1,
+    PosAbsolute = 0,
+    PosRightOf,
+    PosLeftOf,
+    PosAbove,
+    PosBelow,
+    PosRelative
+} PositionType;
+
+typedef struct _screenlayoutrec {
+    confScreenPtr screen;
+    const char *topname;
+    confScreenPtr top;
+    const char *bottomname;
+    confScreenPtr bottom;
+    const char *leftname;
+    confScreenPtr left;
+    const char *rightname;
+    confScreenPtr right;
+    PositionType where;
+    int x;
+    int y;
+    const char *refname;
+    confScreenPtr refscreen;
+} screenLayoutRec, *screenLayoutPtr;
+
+typedef struct _InputInfoRec InputInfoRec;
+
+typedef struct _serverlayoutrec {
+    const char *id;
+    screenLayoutPtr screens;
+    GDevPtr inactives;
+    InputInfoRec **inputs;      /* NULL terminated */
+    void *options;
+} serverLayoutRec, *serverLayoutPtr;
+
+typedef struct _confdribufferrec {
+    int count;
+    int size;
+    enum {
+        XF86DRI_WC_HINT = 0x0001        /* Placeholder: not implemented */
+    } flags;
+} confDRIBufferRec, *confDRIBufferPtr;
+
+typedef struct _confdrirec {
+    int group;
+    int mode;
+    int bufs_count;
+    confDRIBufferRec *bufs;
+} confDRIRec, *confDRIPtr;
+
+/* These values should be adjusted when new fields are added to ScrnInfoRec */
+#define NUM_RESERVED_INTS		16
+#define NUM_RESERVED_POINTERS		14
+#define NUM_RESERVED_FUNCS		10
+
+typedef void *(*funcPointer) (void);
+
+/* flags for depth 24 pixmap options */
+typedef enum {
+    Pix24DontCare = 0,
+    Pix24Use24,
+    Pix24Use32
+} Pix24Flags;
+
+/* Power management events: so far we only support APM */
+
+typedef enum {
+    XF86_APM_UNKNOWN = -1,
+    XF86_APM_SYS_STANDBY,
+    XF86_APM_SYS_SUSPEND,
+    XF86_APM_CRITICAL_SUSPEND,
+    XF86_APM_USER_STANDBY,
+    XF86_APM_USER_SUSPEND,
+    XF86_APM_STANDBY_RESUME,
+    XF86_APM_NORMAL_RESUME,
+    XF86_APM_CRITICAL_RESUME,
+    XF86_APM_LOW_BATTERY,
+    XF86_APM_POWER_STATUS_CHANGE,
+    XF86_APM_UPDATE_TIME,
+    XF86_APM_CAPABILITY_CHANGED,
+    XF86_APM_STANDBY_FAILED,
+    XF86_APM_SUSPEND_FAILED
+} pmEvent;
+
+typedef enum {
+    PM_WAIT,
+    PM_CONTINUE,
+    PM_FAILED,
+    PM_NONE
+} pmWait;
+
+typedef struct _PciChipsets {
+    /**
+     * Key used to match this device with its name in an array of
+     * \c SymTabRec.
+     */
+    int numChipset;
+
+    /**
+     * This value is quirky.  Depending on the driver, it can take on one of
+     * three meanings.  In drivers that have exactly one vendor ID (e.g.,
+     * radeon, mga, i810) the low 16-bits are the device ID.
+     *
+     * In drivers that can have multiple vendor IDs (e.g., the glint driver
+     * can have either 3dlabs' ID or TI's ID, the i740 driver can have either
+     * Intel's ID or Real3D's ID, etc.) the low 16-bits are the device ID and
+     * the high 16-bits are the vendor ID.
+     *
+     * In drivers that don't have a specific vendor (e.g., vga) contains the
+     * device ID for either the generic VGA or generic 8514 devices.  This
+     * turns out to be the same as the subclass and programming interface
+     * value (e.g., the full 24-bit class for the VGA device is 0x030000 (or 
+     * 0x000101) and for 8514 is 0x030001).
+     */
+    int PCIid;
+
+/* dummy place holders for drivers to build against old/new servers */
+#define RES_UNDEFINED NULL
+#define RES_EXCLUSIVE_VGA NULL
+#define RES_SHARED_VGA NULL
+    void *dummy;
+} PciChipsets;
+
+/* Entity properties */
+typedef void (*EntityProc) (int entityIndex, void *private);
+
+typedef struct _entityInfo {
+    int index;
+    BusRec location;
+    int chipset;
+    Bool active;
+    GDevPtr device;
+    DriverPtr driver;
+} EntityInfoRec, *EntityInfoPtr;
+
+/* DGA */
+
+typedef struct {
+    int num;                    /* A unique identifier for the mode (num > 0) */
+    DisplayModePtr mode;
+    int flags;                  /* DGA_CONCURRENT_ACCESS, etc... */
+    int imageWidth;             /* linear accessible portion (pixels) */
+    int imageHeight;
+    int pixmapWidth;            /* Xlib accessible portion (pixels) */
+    int pixmapHeight;           /* both fields ignored if no concurrent access */
+    int bytesPerScanline;
+    int byteOrder;              /* MSBFirst, LSBFirst */
+    int depth;
+    int bitsPerPixel;
+    unsigned long red_mask;
+    unsigned long green_mask;
+    unsigned long blue_mask;
+    short visualClass;
+    int viewportWidth;
+    int viewportHeight;
+    int xViewportStep;          /* viewport position granularity */
+    int yViewportStep;
+    int maxViewportX;           /* max viewport origin */
+    int maxViewportY;
+    int viewportFlags;          /* types of page flipping possible */
+    int offset;                 /* offset into physical memory */
+    unsigned char *address;     /* server's mapped framebuffer */
+    int reserved1;
+    int reserved2;
+} DGAModeRec, *DGAModePtr;
+
+typedef struct {
+    DGAModePtr mode;
+    PixmapPtr pPix;
+} DGADeviceRec, *DGADevicePtr;
+
+/*
+ * Flags for driver Probe() functions.
+ */
+#define PROBE_DEFAULT	  0x00
+#define PROBE_DETECT	  0x01
+#define PROBE_TRYHARD	  0x02
+
+/*
+ * Driver entry point types
+ */
+
+typedef Bool xf86ProbeProc(DriverPtr, int);
+typedef Bool xf86PreInitProc(ScrnInfoPtr, int);
+typedef Bool xf86ScreenInitProc(ScreenPtr, int, char **);
+typedef Bool xf86SwitchModeProc(ScrnInfoPtr, DisplayModePtr);
+typedef void xf86AdjustFrameProc(ScrnInfoPtr, int, int);
+typedef Bool xf86EnterVTProc(ScrnInfoPtr);
+typedef void xf86LeaveVTProc(ScrnInfoPtr);
+typedef void xf86FreeScreenProc(ScrnInfoPtr);
+typedef ModeStatus xf86ValidModeProc(ScrnInfoPtr, DisplayModePtr, Bool, int);
+typedef void xf86EnableDisableFBAccessProc(ScrnInfoPtr, Bool);
+typedef int xf86SetDGAModeProc(ScrnInfoPtr, int, DGADevicePtr);
+typedef int xf86ChangeGammaProc(ScrnInfoPtr, Gamma);
+typedef void xf86PointerMovedProc(ScrnInfoPtr, int, int);
+typedef Bool xf86PMEventProc(ScrnInfoPtr, pmEvent, Bool);
+typedef void xf86DPMSSetProc(ScrnInfoPtr, int, int);
+typedef void xf86LoadPaletteProc(ScrnInfoPtr, int, int *, LOCO *, VisualPtr);
+typedef void xf86SetOverscanProc(ScrnInfoPtr, int);
+typedef void xf86ModeSetProc(ScrnInfoPtr);
+
+/*
+ * ScrnInfoRec
+ *
+ * There is one of these for each screen, and it holds all the screen-specific
+ * information.
+ *
+ * Note: the size and layout must be kept the same across versions.  New
+ * fields are to be added in place of the "reserved*" fields.  No fields
+ * are to be dependent on compile-time defines.
+ */
+
+typedef struct _ScrnInfoRec {
+    int driverVersion;
+    const char *driverName;     /* canonical name used in */
+    /* the config file */
+    ScreenPtr pScreen;          /* Pointer to the ScreenRec */
+    int scrnIndex;              /* Number of this screen */
+    Bool configured;            /* Is this screen valid */
+    int origIndex;              /* initial number assigned to
+                                 * this screen before
+                                 * finalising the number of
+                                 * available screens */
+
+    /* Display-wide screenInfo values needed by this screen */
+    int imageByteOrder;
+    int bitmapScanlineUnit;
+    int bitmapScanlinePad;
+    int bitmapBitOrder;
+    int numFormats;
+    PixmapFormatRec formats[MAXFORMATS];
+    PixmapFormatRec fbFormat;
+
+    int bitsPerPixel;           /* fb bpp */
+    Pix24Flags pixmap24;        /* pixmap pref for depth 24 */
+    int depth;                  /* depth of default visual */
+    MessageType depthFrom;      /* set from config? */
+    MessageType bitsPerPixelFrom;       /* set from config? */
+    rgb weight;                 /* r/g/b weights */
+    rgb mask;                   /* rgb masks */
+    rgb offset;                 /* rgb offsets */
+    int rgbBits;                /* Number of bits in r/g/b */
+    Gamma gamma;                /* Gamma of the monitor */
+    int defaultVisual;          /* default visual class */
+    int maxHValue;              /* max horizontal timing */
+    int maxVValue;              /* max vertical timing value */
+    int virtualX;               /* Virtual width */
+    int virtualY;               /* Virtual height */
+    int xInc;                   /* Horizontal timing increment */
+    MessageType virtualFrom;    /* set from config? */
+    int displayWidth;           /* memory pitch */
+    int frameX0;                /* viewport position */
+    int frameY0;
+    int frameX1;
+    int frameY1;
+    int zoomLocked;             /* Disallow mode changes */
+    DisplayModePtr modePool;    /* list of compatible modes */
+    DisplayModePtr modes;       /* list of actual modes */
+    DisplayModePtr currentMode; /* current mode
+                                 * This was previously
+                                 * overloaded with the modes
+                                 * field, which is a pointer
+                                 * into a circular list */
+    confScreenPtr confScreen;   /* Screen config info */
+    MonPtr monitor;             /* Monitor information */
+    DispPtr display;            /* Display information */
+    int *entityList;            /* List of device entities */
+    int numEntities;
+    int widthmm;                /* physical display dimensions
+                                 * in mm */
+    int heightmm;
+    int xDpi;                   /* width DPI */
+    int yDpi;                   /* height DPI */
+    const char *name;           /* Name to prefix messages */
+    void *driverPrivate;        /* Driver private area */
+    DevUnion *privates;         /* Other privates can hook in
+                                 * here */
+    DriverPtr drv;              /* xf86DriverList[] entry */
+    void *module;               /* Pointer to module head */
+    int colorKey;
+    int overlayFlags;
+
+    /* Some of these may be moved out of here into the driver private area */
+
+    const char *chipset;        /* chipset name */
+    const char *ramdac;         /* ramdac name */
+    const char *clockchip;      /* clock name */
+    Bool progClock;             /* clock is programmable */
+    int numClocks;              /* number of clocks */
+    int clock[MAXCLOCKS];       /* list of clock frequencies */
+    int videoRam;               /* amount of video ram (kb) */
+    unsigned long biosBase;     /* Base address of video BIOS */
+    unsigned long memPhysBase;  /* Physical address of FB */
+    unsigned long fbOffset;     /* Offset of FB in the above */
+    int memClk;                 /* memory clock */
+    int textClockFreq;          /* clock of text mode */
+    Bool flipPixels;            /* swap default black/white */
+    void *options;
+
+    int chipID;
+    int chipRev;
+
+    /* Allow screens to be enabled/disabled individually */
+    Bool vtSema;
+
+    /* hw cursor moves at SIGIO time */
+    Bool silkenMouse;
+
+    /* Storage for clockRanges and adjustFlags for use with the VidMode ext */
+    ClockRangePtr clockRanges;
+    int adjustFlags;
+
+    /*
+     * These can be used when the minor ABI version is incremented.
+     * The NUM_* parameters must be reduced appropriately to keep the
+     * structure size and alignment unchanged.
+     */
+    int reservedInt[NUM_RESERVED_INTS];
+
+    int *entityInstanceList;
+    struct pci_device *vgaDev;
+
+    void *reservedPtr[NUM_RESERVED_POINTERS];
+
+    /*
+     * Driver entry points.
+     *
+     */
+
+    xf86ProbeProc *Probe;
+    xf86PreInitProc *PreInit;
+    xf86ScreenInitProc *ScreenInit;
+    xf86SwitchModeProc *SwitchMode;
+    xf86AdjustFrameProc *AdjustFrame;
+    xf86EnterVTProc *EnterVT;
+    xf86LeaveVTProc *LeaveVT;
+    xf86FreeScreenProc *FreeScreen;
+    xf86ValidModeProc *ValidMode;
+    xf86EnableDisableFBAccessProc *EnableDisableFBAccess;
+    xf86SetDGAModeProc *SetDGAMode;
+    xf86ChangeGammaProc *ChangeGamma;
+    xf86PointerMovedProc *PointerMoved;
+    xf86PMEventProc *PMEvent;
+    xf86DPMSSetProc *DPMSSet;
+    xf86LoadPaletteProc *LoadPalette;
+    xf86SetOverscanProc *SetOverscan;
+    xorgDriverFuncProc *DriverFunc;
+    xf86ModeSetProc *ModeSet;
+
+    /*
+     * This can be used when the minor ABI version is incremented.
+     * The NUM_* parameter must be reduced appropriately to keep the
+     * structure size and alignment unchanged.
+     */
+    funcPointer reservedFuncs[NUM_RESERVED_FUNCS];
+
+    Bool is_gpu;
+    uint32_t capabilities;
+} ScrnInfoRec;
+
+typedef struct {
+    Bool (*OpenFramebuffer) (ScrnInfoPtr pScrn,
+                             char **name,
+                             unsigned char **mem,
+                             int *size, int *offset, int *extra);
+    void (*CloseFramebuffer) (ScrnInfoPtr pScrn);
+    Bool (*SetMode) (ScrnInfoPtr pScrn, DGAModePtr pMode);
+    void (*SetViewport) (ScrnInfoPtr pScrn, int x, int y, int flags);
+    int (*GetViewport) (ScrnInfoPtr pScrn);
+    void (*Sync) (ScrnInfoPtr);
+    void (*FillRect) (ScrnInfoPtr pScrn,
+                      int x, int y, int w, int h, unsigned long color);
+    void (*BlitRect) (ScrnInfoPtr pScrn,
+                      int srcx, int srcy, int w, int h, int dstx, int dsty);
+    void (*BlitTransRect) (ScrnInfoPtr pScrn,
+                           int srcx, int srcy,
+                           int w, int h,
+                           int dstx, int dsty, unsigned long color);
+} DGAFunctionRec, *DGAFunctionPtr;
+
+typedef struct _SymTabRec {
+    int token;                  /* id of the token */
+    const char *name;           /* token name */
+} SymTabRec, *SymTabPtr;
+
+/* flags for xf86LookupMode */
+typedef enum {
+    LOOKUP_DEFAULT = 0,         /* Use default mode lookup method */
+    LOOKUP_BEST_REFRESH,        /* Pick modes with best refresh */
+    LOOKUP_CLOSEST_CLOCK,       /* Pick modes with the closest clock */
+    LOOKUP_LIST_ORDER,          /* Pick first useful mode in list */
+    LOOKUP_CLKDIV2 = 0x0100,    /* Allow half clocks */
+    LOOKUP_OPTIONAL_TOLERANCES = 0x0200 /* Allow missing hsync/vrefresh */
+} LookupModeFlags;
+
+#define NoDepth24Support	0x00
+#define Support24bppFb		0x01    /* 24bpp framebuffer supported */
+#define Support32bppFb		0x02    /* 32bpp framebuffer supported */
+#define SupportConvert24to32	0x04    /* Can convert 24bpp pixmap to 32bpp */
+#define SupportConvert32to24	0x08    /* Can convert 32bpp pixmap to 24bpp */
+#define PreferConvert24to32	0x10    /* prefer 24bpp pixmap to 32bpp conv */
+#define PreferConvert32to24	0x20    /* prefer 32bpp pixmap to 24bpp conv */
+
+/* For DPMS */
+typedef void (*DPMSSetProcPtr) (ScrnInfoPtr, int, int);
+
+/* Input handler proc */
+typedef void (*InputHandlerProc) (int fd, void *data);
+
+/* These are used by xf86GetClocks */
+#define CLK_REG_SAVE		-1
+#define CLK_REG_RESTORE		-2
+
+/*
+ * misc constants
+ */
+#define INTERLACE_REFRESH_WEIGHT	1.5
+#define SYNC_TOLERANCE		0.01    /* 1 percent */
+#define CLOCK_TOLERANCE		2000    /* Clock matching tolerance (2MHz) */
+
+#define OVERLAY_8_32_DUALFB	0x00000001
+#define OVERLAY_8_24_DUALFB	0x00000002
+#define OVERLAY_8_16_DUALFB	0x00000004
+#define OVERLAY_8_32_PLANAR	0x00000008
+
+/* Values of xf86Info.mouseFlags */
+#define MF_CLEAR_DTR       1
+#define MF_CLEAR_RTS       2
+
+/* Action Events */
+typedef enum {
+    ACTION_TERMINATE = 0,       /* Terminate Server */
+    ACTION_NEXT_MODE = 10,      /* Switch to next video mode */
+    ACTION_PREV_MODE,
+    ACTION_SWITCHSCREEN = 100,  /* VT switch */
+    ACTION_SWITCHSCREEN_NEXT,
+    ACTION_SWITCHSCREEN_PREV,
+} ActionEvent;
+
+#endif                          /* _XF86STR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86str.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadow.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadow.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadow.h	(Revision 52145)
@@ -0,0 +1,171 @@
+/*
+ *
+ * Copyright ¬© 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _SHADOW_H_
+#define _SHADOW_H_
+
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+#include "damage.h"
+#include "damagestr.h"
+typedef struct _shadowBuf *shadowBufPtr;
+
+typedef void (*ShadowUpdateProc) (ScreenPtr pScreen, shadowBufPtr pBuf);
+
+#define SHADOW_WINDOW_RELOCATE 1
+#define SHADOW_WINDOW_READ 2
+#define SHADOW_WINDOW_WRITE 4
+
+typedef void *(*ShadowWindowProc) (ScreenPtr pScreen,
+                                   CARD32 row,
+                                   CARD32 offset,
+                                   int mode, CARD32 *size, void *closure);
+
+/* BC hack: do not move the damage member.  see shadow.c for explanation. */
+typedef struct _shadowBuf {
+    DamagePtr pDamage;
+    ShadowUpdateProc update;
+    ShadowWindowProc window;
+    RegionRec damage;
+    PixmapPtr pPixmap;
+    void *closure;
+    int randr;
+
+    /* screen wrappers */
+    GetImageProcPtr GetImage;
+    CloseScreenProcPtr CloseScreen;
+} shadowBufRec;
+
+/* Match defines from randr extension */
+#define SHADOW_ROTATE_0	    1
+#define SHADOW_ROTATE_90    2
+#define SHADOW_ROTATE_180   4
+#define SHADOW_ROTATE_270   8
+#define SHADOW_ROTATE_ALL   (SHADOW_ROTATE_0|SHADOW_ROTATE_90|\
+			     SHADOW_ROTATE_180|SHADOW_ROTATE_270)
+#define SHADOW_REFLECT_X    16
+#define SHADOW_REFLECT_Y    32
+#define SHADOW_REFLECT_ALL  (SHADOW_REFLECT_X|SHADOW_REFLECT_Y)
+
+extern _X_EXPORT DevPrivateKey shadowScrPrivateKey;
+
+#define shadowGetBuf(pScr) ((shadowBufPtr) \
+    dixLookupPrivate(&(pScr)->devPrivates, shadowScrPrivateKey))
+#define shadowBuf(pScr)            shadowBufPtr pBuf = shadowGetBuf(pScr)
+#define shadowDamage(pBuf)  DamageRegion(pBuf->pDamage)
+
+extern _X_EXPORT Bool
+ shadowSetup(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+
+shadowAdd(ScreenPtr pScreen,
+          PixmapPtr pPixmap,
+          ShadowUpdateProc update,
+          ShadowWindowProc window, int randr, void *closure);
+
+extern _X_EXPORT void
+ shadowRemove(ScreenPtr pScreen, PixmapPtr pPixmap);
+
+extern _X_EXPORT Bool
+
+shadowInit(ScreenPtr pScreen, ShadowUpdateProc update, ShadowWindowProc window);
+
+extern _X_EXPORT void *shadowAlloc(int width, int height, int bpp);
+
+extern _X_EXPORT void
+ shadowUpdateAfb4(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateAfb8(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateIplan2p4(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateIplan2p8(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdatePacked(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdatePlanar4(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdatePlanar4x8(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotatePacked(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate8_90(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16_90(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16_90YX(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate32_90(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate8_180(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16_180(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate32_180(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate8_270(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16_270(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16_270YX(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate32_270(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate8(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate16(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+ shadowUpdateRotate32(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+typedef void (*shadowUpdateProc) (ScreenPtr, shadowBufPtr);
+
+extern _X_EXPORT shadowUpdateProc shadowUpdatePackedWeak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4Weak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4x8Weak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdateRotatePackedWeak(void);
+
+#endif                          /* _SHADOW_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/shadow.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpriv.h	(Revision 52145)
@@ -0,0 +1,263 @@
+/*
+ * copyed from from linux kernel 2.2.4
+ * removed internal stuff (#ifdef __KERNEL__)
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <asm/types.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAJOR	29
+
+#define FB_MODES_SHIFT		5       /* 32 modes per framebuffer */
+#define FB_NUM_MINORS		256     /* 256 Minors               */
+#define FB_MAX			(FB_NUM_MINORS / (1 << FB_MODES_SHIFT))
+#define GET_FB_IDX(node)	(MINOR(node) >> FB_MODES_SHIFT)
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611
+
+#define FB_TYPE_PACKED_PIXELS		0       /* Packed Pixels        */
+#define FB_TYPE_PLANES			1       /* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2       /* Interleaved planes   */
+#define FB_TYPE_TEXT			3       /* Text/attributes      */
+
+#define FB_AUX_TEXT_MDA		0       /* Monochrome text */
+#define FB_AUX_TEXT_CGA		1       /* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2       /* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3       /* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4       /* other MGAs:      text, attr,  6 reserved bytes */
+
+#define FB_VISUAL_MONO01		0       /* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1       /* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2       /* True color   */
+#define FB_VISUAL_PSEUDOCOLOR		3       /* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4       /* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5       /* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0       /* no hardware accelerator      */
+#define FB_ACCEL_ATARIBLITT	1       /* Atari Blitter                */
+#define FB_ACCEL_AMIGABLITT	2       /* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3       /* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4       /* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5       /* Cybervision64/3D (S3 ViRGE)  */
+#define FB_ACCEL_ATI_MACH64GX	6       /* ATI Mach 64GX family         */
+#define FB_ACCEL_DEC_TGA	7       /* DEC 21030 TGA                */
+#define FB_ACCEL_ATI_MACH64CT	8       /* ATI Mach 64CT family         */
+#define FB_ACCEL_ATI_MACH64VT	9       /* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10      /* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11      /* Sun Creator/Creator3D        */
+#define FB_ACCEL_SUN_CGSIX	12      /* Sun cg6                      */
+#define FB_ACCEL_SUN_LEO	13      /* Sun leo/zx                   */
+#define FB_ACCEL_IMS_TWINTURBO	14      /* IMS Twin Turbo               */
+#define FB_ACCEL_3DLABS_PERMEDIA2 15    /* 3Dlabs Permedia 2            */
+#define FB_ACCEL_MATROX_MGA2064W 16     /* Matrox MGA2064W (Millenium)  */
+#define FB_ACCEL_MATROX_MGA1064SG 17    /* Matrox MGA1064SG (Mystique)  */
+#define FB_ACCEL_MATROX_MGA2164W 18     /* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19 /* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20      /* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21      /* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22      /* Sun cgfourteen                */
+#define FB_ACCEL_SUN_BWTWO	23      /* Sun bwtwo                     */
+#define FB_ACCEL_SUN_CGTHREE	24      /* Sun cgthree                   */
+#define FB_ACCEL_SUN_TCX	25      /* Sun tcx                       */
+#define FB_ACCEL_MATROX_MGAG400	26      /* Matrox G400                  */
+#define FB_ACCEL_NV3		27      /* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28      /* nVidia RIVA TNT              */
+#define FB_ACCEL_NV5		29      /* nVidia RIVA TNT2             */
+#define FB_ACCEL_CT_6555x	30      /* C&T 6555x                    */
+#define FB_ACCEL_3DFX_BANSHEE	31      /* 3Dfx Banshee                 */
+#define FB_ACCEL_ATI_RAGE128	32      /* ATI Rage128 family           */
+
+struct fb_fix_screeninfo {
+    char id[16];                /* identification string eg "TT Builtin" */
+    char *smem_start;           /* Start of frame buffer mem */
+    /* (physical address) */
+    __u32 smem_len;             /* Length of frame buffer mem */
+    __u32 type;                 /* see FB_TYPE_*                */
+    __u32 type_aux;             /* Interleave for interleaved Planes */
+    __u32 visual;               /* see FB_VISUAL_*              */
+    __u16 xpanstep;             /* zero if no hardware panning  */
+    __u16 ypanstep;             /* zero if no hardware panning  */
+    __u16 ywrapstep;            /* zero if no hardware ywrap    */
+    __u32 line_length;          /* length of a line in bytes    */
+    char *mmio_start;           /* Start of Memory Mapped I/O   */
+    /* (physical address) */
+    __u32 mmio_len;             /* Length of Memory Mapped I/O  */
+    __u32 accel;                /* Type of acceleration available */
+    __u16 reserved[3];          /* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified. This implies
+ * big-endian byte order if bits_per_pixel is greater than 8.
+ */
+struct fb_bitfield {
+    __u32 offset;               /* beginning of bitfield        */
+    __u32 length;               /* length of bitfield           */
+    __u32 msb_right;            /* != 0 : Most significant bit is */
+    /* right */
+};
+
+#define FB_NONSTD_HAM		1       /* Hold-And-Modify (HAM)        */
+
+#define FB_ACTIVATE_NOW		0       /* set values immediately (or vbl) */
+#define FB_ACTIVATE_NXTOPEN	1       /* activate on next open        */
+#define FB_ACTIVATE_TEST	2       /* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+                                        /* values                       */
+#define FB_ACTIVATE_VBL	       16       /* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32       /* change colormap on vbl       */
+#define FB_ACTIVATE_ALL	       64       /* change all VCs on this fb    */
+
+#define FB_ACCELF_TEXT		1       /* text mode acceleration */
+
+#define FB_SYNC_HOR_HIGH_ACT	1       /* horizontal sync high active  */
+#define FB_SYNC_VERT_HIGH_ACT	2       /* vertical sync high active    */
+#define FB_SYNC_EXT		4       /* external sync                */
+#define FB_SYNC_COMP_HIGH_ACT	8       /* composite sync high active   */
+#define FB_SYNC_BROADCAST	16      /* broadcast video timings      */
+                                        /* vtotal = 144d/288n/576i => PAL  */
+                                        /* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32      /* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0       /* non interlaced */
+#define FB_VMODE_INTERLACED	1       /* interlaced   */
+#define FB_VMODE_DOUBLE		2       /* double scan */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256     /* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512     /* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512     /* don't update x/yoffset       */
+
+struct fb_var_screeninfo {
+    __u32 xres;                 /* visible resolution           */
+    __u32 yres;
+    __u32 xres_virtual;         /* virtual resolution           */
+    __u32 yres_virtual;
+    __u32 xoffset;              /* offset from virtual to visible */
+    __u32 yoffset;              /* resolution                   */
+
+    __u32 bits_per_pixel;       /* guess what                   */
+    __u32 grayscale;            /* != 0 Graylevels instead of colors */
+
+    struct fb_bitfield red;     /* bitfield in fb mem if true color, */
+    struct fb_bitfield green;   /* else only length is significant */
+    struct fb_bitfield blue;
+    struct fb_bitfield transp;  /* transparency                 */
+
+    __u32 nonstd;               /* != 0 Non standard pixel format */
+
+    __u32 activate;             /* see FB_ACTIVATE_*            */
+
+    __u32 height;               /* height of picture in mm    */
+    __u32 width;                /* width of picture in mm     */
+
+    __u32 accel_flags;          /* acceleration flags (hints)   */
+
+    /* Timing: All values in pixclocks, except pixclock (of course) */
+    __u32 pixclock;             /* pixel clock in ps (pico seconds) */
+    __u32 left_margin;          /* time from sync to picture    */
+    __u32 right_margin;         /* time from picture to sync    */
+    __u32 upper_margin;         /* time from sync to picture    */
+    __u32 lower_margin;
+    __u32 hsync_len;            /* length of horizontal sync    */
+    __u32 vsync_len;            /* length of vertical sync      */
+    __u32 sync;                 /* see FB_SYNC_*                */
+    __u32 vmode;                /* see FB_VMODE_*               */
+    __u32 reserved[6];          /* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+    __u32 start;                /* First entry  */
+    __u32 len;                  /* Number of entries */
+    __u16 *red;                 /* Red values   */
+    __u16 *green;
+    __u16 *blue;
+    __u16 *transp;              /* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+    __u32 console;
+    __u32 framebuffer;
+};
+
+struct fb_monspecs {
+    __u32 hfmin;                /* hfreq lower limit (Hz) */
+    __u32 hfmax;                /* hfreq upper limit (Hz) */
+    __u16 vfmin;                /* vfreq lower limit (Hz) */
+    __u16 vfmax;                /* vfreq upper limit (Hz) */
+    unsigned dpms:1;            /* supports DPMS */
+};
+
+#if 1
+
+#define FBCMD_GET_CURRENTPAR	0xDEAD0005
+#define FBCMD_SET_CURRENTPAR	0xDEAD8005
+
+#endif
+
+#if 1                           /* Preliminary */
+
+   /*
+    *    Hardware Cursor
+    */
+
+#define FBIOGET_FCURSORINFO     0x4607
+#define FBIOGET_VCURSORINFO     0x4608
+#define FBIOPUT_VCURSORINFO     0x4609
+#define FBIOGET_CURSORSTATE     0x460A
+#define FBIOPUT_CURSORSTATE     0x460B
+
+struct fb_fix_cursorinfo {
+    __u16 crsr_width;           /* width and height of the cursor in */
+    __u16 crsr_height;          /* pixels (zero if no cursor)   */
+    __u16 crsr_xsize;           /* cursor size in display pixels */
+    __u16 crsr_ysize;
+    __u16 crsr_color1;          /* colormap entry for cursor color1 */
+    __u16 crsr_color2;          /* colormap entry for cursor color2 */
+};
+
+struct fb_var_cursorinfo {
+    __u16 width;
+    __u16 height;
+    __u16 xspot;
+    __u16 yspot;
+    __u8 data[1];               /* field with [height][width]        */
+};
+
+struct fb_cursorstate {
+    __s16 xoffset;
+    __s16 yoffset;
+    __u16 mode;
+};
+
+#define FB_CURSOR_OFF		0
+#define FB_CURSOR_ON		1
+#define FB_CURSOR_FLASH		2
+
+#endif                          /* Preliminary */
+
+#endif                          /* _LINUX_FB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbpriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvmc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvmc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvmc.h	(Revision 52145)
@@ -0,0 +1,141 @@
+
+/*
+ * Copyright (c) 2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XVMC_H
+#define _XF86XVMC_H
+
+#include "xvmcext.h"
+#include "xf86xv.h"
+
+typedef struct {
+    int num_xvimages;
+    int *xvimage_ids;           /* reference the subpictures in the XF86MCAdaptorRec */
+} XF86MCImageIDList;
+
+typedef struct {
+    int surface_type_id;        /* Driver generated.  Must be unique on the port */
+    int chroma_format;
+    int color_description;      /* no longer used */
+    unsigned short max_width;
+    unsigned short max_height;
+    unsigned short subpicture_max_width;
+    unsigned short subpicture_max_height;
+    int mc_type;
+    int flags;
+    XF86MCImageIDList *compatible_subpictures;  /* can be null, if none */
+} XF86MCSurfaceInfoRec, *XF86MCSurfaceInfoPtr;
+
+/*
+   xf86XvMCCreateContextProc 
+
+   DIX will fill everything out in the context except the driver_priv.
+   The port_priv holds the private data specified for the port when
+   Xv was initialized by the driver.
+   The driver may store whatever it wants in driver_priv and edit
+   the width, height and flags.  If the driver wants to return something
+   to the client it can allocate space in priv and specify the number
+   of 32 bit words in num_priv.  This must be dynamically allocated
+   space because DIX will free it after it passes it to the client.
+*/
+
+typedef int (*xf86XvMCCreateContextProcPtr) (ScrnInfoPtr pScrn,
+                                             XvMCContextPtr context,
+                                             int *num_priv, CARD32 **priv);
+
+typedef void (*xf86XvMCDestroyContextProcPtr) (ScrnInfoPtr pScrn,
+                                               XvMCContextPtr context);
+
+/*
+   xf86XvMCCreateSurfaceProc 
+
+   DIX will fill everything out in the surface except the driver_priv.
+   The driver may store whatever it wants in driver_priv.  The driver
+   may pass data back to the client in the same manner as the
+   xf86XvMCCreateContextProc.
+*/
+
+typedef int (*xf86XvMCCreateSurfaceProcPtr) (ScrnInfoPtr pScrn,
+                                             XvMCSurfacePtr surface,
+                                             int *num_priv, CARD32 **priv);
+
+typedef void (*xf86XvMCDestroySurfaceProcPtr) (ScrnInfoPtr pScrn,
+                                               XvMCSurfacePtr surface);
+
+/*
+   xf86XvMCCreateSubpictureProc 
+
+   DIX will fill everything out in the subpicture except the driver_priv,
+   num_palette_entries, entry_bytes and component_order.  The driver may
+   store whatever it wants in driver_priv and edit the width and height.
+   If it is a paletted subpicture the driver needs to fill out the
+   num_palette_entries, entry_bytes and component_order.  These are
+   not communicated to the client until the time the surface is
+   created.
+
+   The driver may pass data back to the client in the same manner as the
+   xf86XvMCCreateContextProc.
+*/
+
+typedef int (*xf86XvMCCreateSubpictureProcPtr) (ScrnInfoPtr pScrn,
+                                                XvMCSubpicturePtr subpicture,
+                                                int *num_priv, CARD32 **priv);
+
+typedef void (*xf86XvMCDestroySubpictureProcPtr) (ScrnInfoPtr pScrn,
+                                                  XvMCSubpicturePtr subpicture);
+
+typedef struct {
+    const char *name;
+    int num_surfaces;
+    XF86MCSurfaceInfoPtr *surfaces;
+    int num_subpictures;
+    XF86ImagePtr *subpictures;
+    xf86XvMCCreateContextProcPtr CreateContext;
+    xf86XvMCDestroyContextProcPtr DestroyContext;
+    xf86XvMCCreateSurfaceProcPtr CreateSurface;
+    xf86XvMCDestroySurfaceProcPtr DestroySurface;
+    xf86XvMCCreateSubpictureProcPtr CreateSubpicture;
+    xf86XvMCDestroySubpictureProcPtr DestroySubpicture;
+} XF86MCAdaptorRec, *XF86MCAdaptorPtr;
+
+/* 
+   xf86XvMCScreenInit 
+
+   Unlike Xv, the adaptor data is not copied from this structure.
+   This structure's data is used so it must stick around for the
+   life of the server.  Note that it's an array of pointers not
+   an array of structures.
+*/
+
+extern _X_EXPORT Bool xf86XvMCScreenInit(ScreenPtr pScreen,
+                                         int num_adaptors,
+                                         XF86MCAdaptorPtr * adaptors);
+
+extern _X_EXPORT XF86MCAdaptorPtr xf86XvMCCreateAdaptorRec(void);
+extern _X_EXPORT void xf86XvMCDestroyAdaptorRec(XF86MCAdaptorPtr adaptor);
+
+#endif                          /* _XF86XVMC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86xvmc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hashtable.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hashtable.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hashtable.h	(Revision 52145)
@@ -0,0 +1,137 @@
+#ifndef HASHTABLE_H
+#define HASHTABLE_H 1
+
+#include <dix-config.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xdefs.h>
+#include "list.h"
+
+/** @brief A hashing function.
+
+  @param[in/out] cdata  Opaque data that can be passed to HtInit that will
+                        eventually end up here
+  @param[in] ptr        The data to be hashed. The size of the data, if
+                        needed, can be configured via a record that can be
+                        passed via cdata.
+  @param[in] numBits    The number of bits this hash needs to have in the
+                        resulting hash
+
+  @return  A numBits-bit hash of the data
+*/
+typedef unsigned (*HashFunc)(void * cdata, const void * ptr, int numBits);
+
+/** @brief A comparison function for hashed keys.
+
+  @param[in/out] cdata  Opaque data that ca be passed to Htinit that will
+                        eventually end up here
+  @param[in] l          The left side data to be compared
+  @param[in] r          The right side data to be compared
+
+  @return -1 if l < r, 0 if l == r, 1 if l > r
+*/
+typedef int (*HashCompareFunc)(void * cdata, const void * l, const void * r);
+
+struct HashTableRec;
+
+typedef struct HashTableRec *HashTable;
+
+/** @brief  A configuration for HtGenericHash */
+typedef struct {
+    int             keySize;
+} HtGenericHashSetupRec, *HtGenericHashSetupPtr;
+
+/** @brief  ht_create initalizes a hash table for a certain hash table
+            configuration
+
+    @param[out] ht       The hash table structure to initialize
+    @param[in] keySize   The key size in bytes
+    @param[in] dataSize  The data size in bytes
+    @param[in] hash      The hash function to use for hashing keys
+    @param[in] compare   The comparison function for hashing keys
+    @param[in] cdata     Opaque data that will be passed to hash and
+                         comparison functions
+*/
+extern _X_EXPORT HashTable ht_create(int             keySize,
+                                     int             dataSize,
+                                     HashFunc        hash,
+                                     HashCompareFunc compare,
+                                     void            *cdata);
+/** @brief  HtDestruct deinitializes the structure. It does not free the
+            memory allocated to HashTableRec
+*/
+extern _X_EXPORT void ht_destroy(HashTable ht);
+
+/** @brief  Adds a new key to the hash table. The key will be copied
+            and a pointer to the value will be returned. The data will
+            be initialized with zeroes.
+
+  @param[in/out] ht  The hash table
+  @param[key] key    The key. The contents of the key will be copied.
+
+  @return On error NULL is returned, otherwise a pointer to the data
+          associated with the newly inserted key.
+
+  @note  If dataSize is 0, a pointer to the end of the key may be returned
+         to avoid returning NULL. Obviously the data pointed cannot be
+         modified, as implied by dataSize being 0.
+*/
+extern _X_EXPORT void *ht_add(HashTable ht, const void *key);
+
+/** @brief  Removes a key from the hash table along with its
+            associated data, which will be free'd.
+*/
+extern _X_EXPORT void ht_remove(HashTable ht, const void *key);
+
+/** @brief  Finds the associated data of a key from the hash table.
+
+   @return  If the key cannot be found, the function returns NULL.
+            Otherwise it returns a pointer to the data associated
+            with the key.
+
+   @note  If dataSize == 0, this function may return NULL
+          even if the key has been inserted! If dataSize == NULL,
+          use HtMember instead to determine if a key has been
+          inserted.
+*/
+extern _X_EXPORT void *ht_find(HashTable ht, const void *key);
+
+/** @brief  A generic hash function */
+extern _X_EXPORT unsigned ht_generic_hash(void *cdata,
+                                          const void *ptr,
+                                          int numBits);
+
+/** @brief  A generic comparison function. It compares data byte-wise. */
+extern _X_EXPORT int ht_generic_compare(void *cdata,
+                                        const void *l,
+                                        const void *r);
+
+/** @brief  A debugging function that dumps the distribution of the
+            hash table: for each bucket, list the number of elements
+            contained within. */
+extern _X_EXPORT void ht_dump_distribution(HashTable ht);
+
+/** @brief  A debugging function that dumps the contents of the hash
+            table: for each bucket, list the elements contained
+            within. */
+extern _X_EXPORT void ht_dump_contents(HashTable ht,
+                                       void (*print_key)(void *opaque, void *key),
+                                       void (*print_value)(void *opaque, void *value),
+                                       void* opaque);
+
+/** @brief  A hashing function to be used for hashing resource IDs when
+            used with HashTables. It makes no use of cdata, so that can
+            be NULL. It uses HashXID underneath, and should HashXID be
+            unable to hash the value, it switches into using the generic
+            hash function. */
+extern _X_EXPORT unsigned ht_resourceid_hash(void *cdata,
+                                             const void * data,
+                                             int numBits);
+
+/** @brief  A comparison function to be used for comparing resource
+            IDs when used with HashTables. It makes no use of cdata,
+            so that can be NULL. */
+extern _X_EXPORT int ht_resourceid_compare(void *cdata,
+                                           const void *a,
+                                           const void *b);
+
+#endif // HASHTABLE_H

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/hashtable.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ptrveloc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ptrveloc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ptrveloc.h	(Revision 52145)
@@ -0,0 +1,144 @@
+/*
+ *
+ * Copyright ¬© 2006-2011 Simon Thum             simon dot thum at gmx dot de
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef POINTERVELOCITY_H
+#define POINTERVELOCITY_H
+
+#include <input.h>
+
+/* constants for acceleration profiles */
+
+#define AccelProfileNone -1
+#define AccelProfileClassic  0
+#define AccelProfileDeviceSpecific 1
+#define AccelProfilePolynomial 2
+#define AccelProfileSmoothLinear 3
+#define AccelProfileSimple 4
+#define AccelProfilePower 5
+#define AccelProfileLinear 6
+#define AccelProfileSmoothLimited 7
+#define AccelProfileLAST AccelProfileSmoothLimited
+
+/* fwd */
+struct _DeviceVelocityRec;
+
+/**
+ * profile
+ * returns actual acceleration depending on velocity, acceleration control,...
+ */
+typedef double (*PointerAccelerationProfileFunc)
+ (DeviceIntPtr dev, struct _DeviceVelocityRec * vel,
+  double velocity, double threshold, double accelCoeff);
+
+/**
+ * a motion history, with just enough information to
+ * calc mean velocity and decide which motion was along
+ * a more or less straight line
+ */
+typedef struct _MotionTracker {
+    double dx, dy;              /* accumulated delta for each axis */
+    int time;                   /* time of creation */
+    int dir;                    /* initial direction bitfield */
+} MotionTracker, *MotionTrackerPtr;
+
+/**
+ * Contains all data needed to implement mouse ballistics
+ */
+typedef struct _DeviceVelocityRec {
+    MotionTrackerPtr tracker;
+    int num_tracker;
+    int cur_tracker;            /* current index */
+    double velocity;            /* velocity as guessed by algorithm */
+    double last_velocity;       /* previous velocity estimate */
+    double last_dx;             /* last time-difference */
+    double last_dy;             /* phase of last/current estimate */
+    double corr_mul;            /* config: multiply this into velocity */
+    double const_acceleration;  /* config: (recipr.) const deceleration */
+    double min_acceleration;    /* config: minimum acceleration */
+    short reset_time;           /* config: reset non-visible state after # ms */
+    short use_softening;        /* config: use softening of mouse values */
+    double max_rel_diff;        /* config: max. relative difference */
+    double max_diff;            /* config: max. difference */
+    int initial_range;          /* config: max. offset used as initial velocity */
+    Bool average_accel;         /* config: average acceleration over velocity */
+    PointerAccelerationProfileFunc Profile;
+    PointerAccelerationProfileFunc deviceSpecificProfile;
+    void *profile_private;      /* extended data, see  SetAccelerationProfile() */
+    struct {                    /* to be able to query this information */
+        int profile_number;
+    } statistics;
+} DeviceVelocityRec, *DeviceVelocityPtr;
+
+/**
+ * contains the run-time data for the predictable scheme, that is, a
+ * DeviceVelocityPtr and the property handlers.
+ */
+typedef struct _PredictableAccelSchemeRec {
+    DeviceVelocityPtr vel;
+    long *prop_handlers;
+    int num_prop_handlers;
+} PredictableAccelSchemeRec, *PredictableAccelSchemePtr;
+
+extern _X_EXPORT void
+InitVelocityData(DeviceVelocityPtr vel);
+
+extern _X_EXPORT void
+InitTrackers(DeviceVelocityPtr vel, int ntracker);
+
+extern _X_EXPORT BOOL
+ProcessVelocityData2D(DeviceVelocityPtr vel, double dx, double dy, int time);
+
+extern _X_EXPORT double
+BasicComputeAcceleration(DeviceIntPtr dev, DeviceVelocityPtr vel,
+                         double velocity, double threshold, double acc);
+
+extern _X_EXPORT void
+FreeVelocityData(DeviceVelocityPtr vel);
+
+extern _X_EXPORT int
+SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
+
+extern _X_EXPORT DeviceVelocityPtr
+GetDevicePredictableAccelData(DeviceIntPtr dev);
+
+extern _X_EXPORT void
+SetDeviceSpecificAccelerationProfile(DeviceVelocityPtr vel,
+                                     PointerAccelerationProfileFunc profile);
+
+extern _X_INTERNAL void
+AccelerationDefaultCleanup(DeviceIntPtr dev);
+
+extern _X_INTERNAL Bool
+InitPredictableAccelerationScheme(DeviceIntPtr dev,
+                                  struct _ValuatorAccelerationRec *protoScheme);
+
+extern _X_INTERNAL void
+acceleratePointerPredictable(DeviceIntPtr dev, ValuatorMask *val,
+                             CARD32 evtime);
+
+extern _X_INTERNAL void
+acceleratePointerLightweight(DeviceIntPtr dev, ValuatorMask *val,
+                             CARD32 evtime);
+
+#endif                          /* POINTERVELOCITY_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ptrveloc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmap.h	(Revision 52145)
@@ -0,0 +1,131 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PIXMAP_H
+#define PIXMAP_H
+
+#include "misc.h"
+#include "screenint.h"
+#include "regionstr.h"
+
+/* types for Drawable */
+#define DRAWABLE_WINDOW 0
+#define DRAWABLE_PIXMAP 1
+#define UNDRAWABLE_WINDOW 2
+
+/* corresponding type masks for dixLookupDrawable() */
+#define M_DRAWABLE_WINDOW	(1<<0)
+#define M_DRAWABLE_PIXMAP	(1<<1)
+#define M_UNDRAWABLE_WINDOW	(1<<2)
+#define M_ANY			(-1)
+#define M_WINDOW	(M_DRAWABLE_WINDOW|M_UNDRAWABLE_WINDOW)
+#define M_DRAWABLE	(M_DRAWABLE_WINDOW|M_DRAWABLE_PIXMAP)
+#define M_UNDRAWABLE	(M_UNDRAWABLE_WINDOW)
+
+/* flags to PaintWindow() */
+#define PW_BACKGROUND 0
+#define PW_BORDER 1
+
+#define NullPixmap ((PixmapPtr)0)
+
+typedef struct _Drawable *DrawablePtr;
+typedef struct _Pixmap *PixmapPtr;
+
+typedef struct _PixmapDirtyUpdate *PixmapDirtyUpdatePtr;
+
+typedef union _PixUnion {
+    PixmapPtr pixmap;
+    unsigned long pixel;
+} PixUnion;
+
+#define SamePixUnion(a,b,isPixel)\
+    ((isPixel) ? (a).pixel == (b).pixel : (a).pixmap == (b).pixmap)
+
+#define EqualPixUnion(as, a, bs, b)				\
+    ((as) == (bs) && (SamePixUnion (a, b, as)))
+
+#define OnScreenDrawable(type) \
+	(type == DRAWABLE_WINDOW)
+
+#define WindowDrawable(type) \
+	((type == DRAWABLE_WINDOW) || (type == UNDRAWABLE_WINDOW))
+
+extern _X_EXPORT PixmapPtr GetScratchPixmapHeader(ScreenPtr /*pScreen */ ,
+                                                  int /*width */ ,
+                                                  int /*height */ ,
+                                                  int /*depth */ ,
+                                                  int /*bitsPerPixel */ ,
+                                                  int /*devKind */ ,
+                                                  void */*pPixData */ );
+
+extern _X_EXPORT void FreeScratchPixmapHeader(PixmapPtr /*pPixmap */ );
+
+extern _X_EXPORT Bool CreateScratchPixmapsForScreen(ScreenPtr /*pScreen */ );
+
+extern _X_EXPORT void FreeScratchPixmapsForScreen(ScreenPtr /*pScreen */ );
+
+extern _X_EXPORT PixmapPtr AllocatePixmap(ScreenPtr /*pScreen */ ,
+                                          int /*pixDataSize */ );
+
+extern _X_EXPORT void FreePixmap(PixmapPtr /*pPixmap */ );
+
+extern _X_EXPORT PixmapPtr
+PixmapShareToSlave(PixmapPtr pixmap, ScreenPtr slave);
+
+extern _X_EXPORT Bool
+PixmapStartDirtyTracking(PixmapPtr src,
+                         PixmapPtr slave_dst,
+                         int x, int y);
+
+extern _X_EXPORT Bool
+PixmapStopDirtyTracking(PixmapPtr src, PixmapPtr slave_dst);
+
+/* helper function, drivers can do this themselves if they can do it more
+   efficently */
+extern _X_EXPORT Bool
+PixmapSyncDirtyHelper(PixmapDirtyUpdatePtr dirty, RegionPtr dirty_region);
+
+#endif                          /* PIXMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dispatch.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dispatch.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dispatch.h	(Revision 52145)
@@ -0,0 +1,145 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/*
+ * This prototypes the dispatch.c module (except for functions declared in
+ * global headers), plus related dispatch procedures from devices.c, events.c,
+ * extension.c, property.c. 
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DISPATCH_H
+#define DISPATCH_H 1
+
+int ProcAllocColor(ClientPtr /* client */ );
+int ProcAllocColorCells(ClientPtr /* client */ );
+int ProcAllocColorPlanes(ClientPtr /* client */ );
+int ProcAllocNamedColor(ClientPtr /* client */ );
+int ProcBell(ClientPtr /* client */ );
+int ProcChangeAccessControl(ClientPtr /* client */ );
+int ProcChangeCloseDownMode(ClientPtr /* client */ );
+int ProcChangeGC(ClientPtr /* client */ );
+int ProcChangeHosts(ClientPtr /* client */ );
+int ProcChangeKeyboardControl(ClientPtr /* client */ );
+int ProcChangeKeyboardMapping(ClientPtr /* client */ );
+int ProcChangePointerControl(ClientPtr /* client */ );
+int ProcChangeProperty(ClientPtr /* client */ );
+int ProcChangeSaveSet(ClientPtr /* client */ );
+int ProcChangeWindowAttributes(ClientPtr /* client */ );
+int ProcCirculateWindow(ClientPtr /* client */ );
+int ProcClearToBackground(ClientPtr /* client */ );
+int ProcCloseFont(ClientPtr /* client */ );
+int ProcConfigureWindow(ClientPtr /* client */ );
+int ProcConvertSelection(ClientPtr /* client */ );
+int ProcCopyArea(ClientPtr /* client */ );
+int ProcCopyColormapAndFree(ClientPtr /* client */ );
+int ProcCopyGC(ClientPtr /* client */ );
+int ProcCopyPlane(ClientPtr /* client */ );
+int ProcCreateColormap(ClientPtr /* client */ );
+int ProcCreateCursor(ClientPtr /* client */ );
+int ProcCreateGC(ClientPtr /* client */ );
+int ProcCreateGlyphCursor(ClientPtr /* client */ );
+int ProcCreatePixmap(ClientPtr /* client */ );
+int ProcCreateWindow(ClientPtr /* client */ );
+int ProcDeleteProperty(ClientPtr /* client */ );
+int ProcDestroySubwindows(ClientPtr /* client */ );
+int ProcDestroyWindow(ClientPtr /* client */ );
+int ProcEstablishConnection(ClientPtr /* client */ );
+int ProcFillPoly(ClientPtr /* client */ );
+int ProcForceScreenSaver(ClientPtr /* client */ );
+int ProcFreeColormap(ClientPtr /* client */ );
+int ProcFreeColors(ClientPtr /* client */ );
+int ProcFreeCursor(ClientPtr /* client */ );
+int ProcFreeGC(ClientPtr /* client */ );
+int ProcFreePixmap(ClientPtr /* client */ );
+int ProcGetAtomName(ClientPtr /* client */ );
+int ProcGetFontPath(ClientPtr /* client */ );
+int ProcGetGeometry(ClientPtr /* client */ );
+int ProcGetImage(ClientPtr /* client */ );
+int ProcGetKeyboardControl(ClientPtr /* client */ );
+int ProcGetKeyboardMapping(ClientPtr /* client */ );
+int ProcGetModifierMapping(ClientPtr /* client */ );
+int ProcGetMotionEvents(ClientPtr /* client */ );
+int ProcGetPointerControl(ClientPtr /* client */ );
+int ProcGetPointerMapping(ClientPtr /* client */ );
+int ProcGetProperty(ClientPtr /* client */ );
+int ProcGetScreenSaver(ClientPtr /* client */ );
+int ProcGetSelectionOwner(ClientPtr /* client */ );
+int ProcGetWindowAttributes(ClientPtr /* client */ );
+int ProcGrabServer(ClientPtr /* client */ );
+int ProcImageText16(ClientPtr /* client */ );
+int ProcImageText8(ClientPtr /* client */ );
+int ProcInitialConnection(ClientPtr /* client */ );
+int ProcInstallColormap(ClientPtr /* client */ );
+int ProcInternAtom(ClientPtr /* client */ );
+int ProcKillClient(ClientPtr /* client */ );
+int ProcListExtensions(ClientPtr /* client */ );
+int ProcListFonts(ClientPtr /* client */ );
+int ProcListFontsWithInfo(ClientPtr /* client */ );
+int ProcListHosts(ClientPtr /* client */ );
+int ProcListInstalledColormaps(ClientPtr /* client */ );
+int ProcListProperties(ClientPtr /* client */ );
+int ProcLookupColor(ClientPtr /* client */ );
+int ProcMapSubwindows(ClientPtr /* client */ );
+int ProcMapWindow(ClientPtr /* client */ );
+int ProcNoOperation(ClientPtr /* client */ );
+int ProcOpenFont(ClientPtr /* client */ );
+int ProcPolyArc(ClientPtr /* client */ );
+int ProcPolyFillArc(ClientPtr /* client */ );
+int ProcPolyFillRectangle(ClientPtr /* client */ );
+int ProcPolyLine(ClientPtr /* client */ );
+int ProcPolyPoint(ClientPtr /* client */ );
+int ProcPolyRectangle(ClientPtr /* client */ );
+int ProcPolySegment(ClientPtr /* client */ );
+int ProcPolyText(ClientPtr /* client */ );
+int ProcPutImage(ClientPtr /* client */ );
+int ProcQueryBestSize(ClientPtr /* client */ );
+int ProcQueryColors(ClientPtr /* client */ );
+int ProcQueryExtension(ClientPtr /* client */ );
+int ProcQueryFont(ClientPtr /* client */ );
+int ProcQueryKeymap(ClientPtr /* client */ );
+int ProcQueryTextExtents(ClientPtr /* client */ );
+int ProcQueryTree(ClientPtr /* client */ );
+int ProcReparentWindow(ClientPtr /* client */ );
+int ProcRotateProperties(ClientPtr /* client */ );
+int ProcSetClipRectangles(ClientPtr /* client */ );
+int ProcSetDashes(ClientPtr /* client */ );
+int ProcSetFontPath(ClientPtr /* client */ );
+int ProcSetModifierMapping(ClientPtr /* client */ );
+int ProcSetPointerMapping(ClientPtr /* client */ );
+int ProcSetScreenSaver(ClientPtr /* client */ );
+int ProcSetSelectionOwner(ClientPtr /* client */ );
+int ProcStoreColors(ClientPtr /* client */ );
+int ProcStoreNamedColor(ClientPtr /* client */ );
+int ProcTranslateCoords(ClientPtr /* client */ );
+int ProcUngrabServer(ClientPtr /* client */ );
+int ProcUninstallColormap(ClientPtr /* client */ );
+int ProcUnmapSubwindows(ClientPtr /* client */ );
+int ProcUnmapWindow(ClientPtr /* client */ );
+
+#endif                          /* DISPATCH_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dispatch.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension_string.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension_string.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension_string.h	(Revision 52145)
@@ -0,0 +1,74 @@
+/*
+ * (C) Copyright IBM Corporation 2002-2006
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file extension_string.h
+ * Routines to manage the GLX extension string and GLX version for AIGLX
+ * drivers.  This code is loosely based on src/glx/x11/glxextensions.c from
+ * Mesa.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#ifndef GLX_EXTENSION_STRING_H
+#define GLX_EXTENSION_STRING_H
+
+enum {
+/*   GLX_ARB_get_proc_address is implemented on the client. */
+    ARB_create_context_bit = 0,
+    ARB_create_context_profile_bit,
+    ARB_create_context_robustness_bit,
+    ARB_fbconfig_float_bit,
+    ARB_framebuffer_sRGB_bit,
+    ARB_multisample_bit,
+    EXT_create_context_es2_profile_bit,
+    EXT_import_context_bit,
+    EXT_texture_from_pixmap_bit,
+    EXT_visual_info_bit,
+    EXT_visual_rating_bit,
+    MESA_copy_sub_buffer_bit,
+    OML_swap_method_bit,
+    SGI_make_current_read_bit,
+    SGI_swap_control_bit,
+    SGI_video_sync_bit,
+    SGIS_multisample_bit,
+    SGIX_fbconfig_bit,
+    SGIX_pbuffer_bit,
+    SGIX_visual_select_group_bit,
+    INTEL_swap_event_bit,
+    __NUM_GLX_EXTS,
+};
+
+/* For extensions which have identical ARB and EXT implementation
+ * in GLX area, use one enabling bit for both. */
+#define EXT_framebuffer_sRGB_bit ARB_framebuffer_sRGB_bit
+
+#define __GLX_EXT_BYTES ((__NUM_GLX_EXTS + 7) / 8)
+
+extern int __glXGetExtensionString(const unsigned char *enable_bits,
+                                   char *buffer);
+extern void __glXEnableExtension(unsigned char *enable_bits, const char *ext);
+extern void __glXInitExtensionEnableBits(unsigned char *enable_bits);
+
+#endif                          /* GLX_EXTENSION_STRING_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension_string.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86sbusBus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86sbusBus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86sbusBus.h	(Revision 52145)
@@ -0,0 +1,111 @@
+/*
+ * SBUS bus-specific declarations
+ *
+ * Copyright (C) 2000 Jakub Jelinek (jakub@redhat.com)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * JAKUB JELINEK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XF86_SBUSBUS_H
+#define _XF86_SBUSBUS_H
+
+#include "xf86str.h"
+
+#define SBUS_DEVICE_BW2		0x0001
+#define SBUS_DEVICE_CG2		0x0002
+#define SBUS_DEVICE_CG3		0x0003
+#define SBUS_DEVICE_CG4		0x0004
+#define SBUS_DEVICE_CG6		0x0005
+#define SBUS_DEVICE_CG8		0x0006
+#define SBUS_DEVICE_CG12	0x0007
+#define SBUS_DEVICE_CG14	0x0008
+#define SBUS_DEVICE_LEO		0x0009
+#define SBUS_DEVICE_TCX		0x000a
+#define SBUS_DEVICE_FFB		0x000b
+#define SBUS_DEVICE_GT		0x000c
+#define SBUS_DEVICE_MGX		0x000d
+
+typedef struct sbus_prom_node {
+    int node;
+    /* Because of misdesigned openpromio */
+    int cookie[2];
+} sbusPromNode, *sbusPromNodePtr;
+
+typedef struct sbus_device {
+    int devId;
+    int fbNum;
+    int fd;
+    int width, height;
+    sbusPromNode node;
+    const char *descr;
+    const char *device;
+} sbusDevice, *sbusDevicePtr;
+
+struct sbus_devtable {
+    int devId;
+    int fbType;
+    const char *promName;
+    const char *driverName;
+    const char *descr;
+};
+
+extern _X_EXPORT void xf86SbusProbe(void);
+extern _X_EXPORT sbusDevicePtr *xf86SbusInfo;
+extern _X_EXPORT struct sbus_devtable sbusDeviceTable[];
+
+extern _X_EXPORT int xf86MatchSbusInstances(const char *driverName,
+                                            int sbusDevId, GDevPtr * devList,
+                                            int numDevs, DriverPtr drvp,
+                                            int **foundEntities);
+extern _X_EXPORT sbusDevicePtr xf86GetSbusInfoForEntity(int entityIndex);
+extern _X_EXPORT int xf86GetEntityForSbusInfo(sbusDevicePtr psdp);
+extern _X_EXPORT void xf86SbusUseBuiltinMode(ScrnInfoPtr pScrn,
+                                             sbusDevicePtr psdp);
+extern _X_EXPORT void *xf86MapSbusMem(sbusDevicePtr psdp,
+                                        unsigned long offset,
+                                        unsigned long size);
+extern _X_EXPORT void xf86UnmapSbusMem(sbusDevicePtr psdp, void *addr,
+                                       unsigned long size);
+extern _X_EXPORT void xf86SbusHideOsHwCursor(sbusDevicePtr psdp);
+extern _X_EXPORT void xf86SbusSetOsHwCursorCmap(sbusDevicePtr psdp, int bg,
+                                                int fg);
+extern _X_EXPORT Bool xf86SbusHandleColormaps(ScreenPtr pScreen,
+                                              sbusDevicePtr psdp);
+
+extern _X_EXPORT int promRootNode;
+
+extern _X_EXPORT int promGetSibling(int node);
+extern _X_EXPORT int promGetChild(int node);
+extern _X_EXPORT char *promGetProperty(const char *prop, int *lenp);
+extern _X_EXPORT int promGetBool(const char *prop);
+
+extern _X_EXPORT int sparcPromInit(void);
+extern _X_EXPORT void sparcPromClose(void);
+extern _X_EXPORT char *sparcPromGetProperty(sbusPromNodePtr pnode,
+                                            const char *prop, int *lenp);
+extern _X_EXPORT int sparcPromGetBool(sbusPromNodePtr pnode, const char *prop);
+extern _X_EXPORT void sparcPromAssignNodes(void);
+extern _X_EXPORT char *sparcPromNode2Pathname(sbusPromNodePtr pnode);
+extern _X_EXPORT int sparcPromPathname2Node(const char *pathName);
+extern _X_EXPORT char *sparcDriverName(void);
+
+extern Bool xf86SbusConfigure(void *busData, sbusDevicePtr sBus);
+extern void xf86SbusConfigureNewDev(void *busData, sbusDevicePtr sBus,
+                                    GDevRec * GDev);
+
+#endif                          /* _XF86_SBUSBUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86sbusBus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointer.h	(Revision 52145)
@@ -0,0 +1,124 @@
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef MIPOINTER_H
+#define MIPOINTER_H
+
+#include "cursor.h"
+#include "input.h"
+#include "privates.h"
+
+typedef struct _miPointerSpriteFuncRec {
+    Bool (*RealizeCursor) (DeviceIntPtr /* pDev */ ,
+                           ScreenPtr /* pScr */ ,
+                           CursorPtr    /* pCurs */
+        );
+    Bool (*UnrealizeCursor) (DeviceIntPtr /* pDev */ ,
+                             ScreenPtr /* pScr */ ,
+                             CursorPtr  /* pCurs */
+        );
+    void (*SetCursor) (DeviceIntPtr /* pDev */ ,
+                       ScreenPtr /* pScr */ ,
+                       CursorPtr /* pCurs */ ,
+                       int /* x */ ,
+                       int      /* y */
+        );
+    void (*MoveCursor) (DeviceIntPtr /* pDev */ ,
+                        ScreenPtr /* pScr */ ,
+                        int /* x */ ,
+                        int     /* y */
+        );
+    Bool (*DeviceCursorInitialize) (DeviceIntPtr /* pDev */ ,
+                                    ScreenPtr   /* pScr */
+        );
+    void (*DeviceCursorCleanup) (DeviceIntPtr /* pDev */ ,
+                                 ScreenPtr      /* pScr */
+        );
+} miPointerSpriteFuncRec, *miPointerSpriteFuncPtr;
+
+typedef struct _miPointerScreenFuncRec {
+    Bool (*CursorOffScreen) (ScreenPtr * /* ppScr */ ,
+                             int * /* px */ ,
+                             int *      /* py */
+        );
+    void (*CrossScreen) (ScreenPtr /* pScr */ ,
+                         int    /* entering */
+        );
+    void (*WarpCursor) (DeviceIntPtr /*pDev */ ,
+                        ScreenPtr /* pScr */ ,
+                        int /* x */ ,
+                        int     /* y */
+        );
+} miPointerScreenFuncRec, *miPointerScreenFuncPtr;
+
+extern _X_EXPORT Bool miDCInitialize(ScreenPtr /*pScreen */ ,
+                                     miPointerScreenFuncPtr     /*screenFuncs */
+    );
+
+extern _X_EXPORT Bool miPointerInitialize(ScreenPtr /*pScreen */ ,
+                                          miPointerSpriteFuncPtr
+                                          /*spriteFuncs */ ,
+                                          miPointerScreenFuncPtr
+                                          /*screenFuncs */ ,
+                                          Bool  /*waitForUpdate */
+    );
+
+extern _X_EXPORT void miPointerWarpCursor(DeviceIntPtr /*pDev */ ,
+                                          ScreenPtr /*pScreen */ ,
+                                          int /*x */ ,
+                                          int   /*y */
+    );
+
+extern _X_EXPORT ScreenPtr
+miPointerGetScreen(DeviceIntPtr pDev);
+extern _X_EXPORT void
+miPointerSetScreen(DeviceIntPtr pDev, int screen_num, int x, int y);
+
+/* Returns the current cursor position. */
+extern _X_EXPORT void
+miPointerGetPosition(DeviceIntPtr pDev, int *x, int *y);
+
+/* Moves the cursor to the specified position.  May clip the co-ordinates:
+ * x and y are modified in-place. */
+extern _X_EXPORT ScreenPtr
+miPointerSetPosition(DeviceIntPtr pDev, int mode, double *x, double *y,
+                     int *nevents, InternalEvent *events);
+
+extern _X_EXPORT void
+miPointerUpdateSprite(DeviceIntPtr pDev);
+
+/* Sets whether the sprite should be updated immediately on pointer moves */
+extern _X_EXPORT Bool
+miPointerSetWaitForUpdate(ScreenPtr pScreen, Bool wait);
+
+extern _X_EXPORT DevPrivateKeyRec miPointerPrivKeyRec;
+
+#define miPointerPrivKey (&miPointerPrivKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec miPointerScreenKeyRec;
+
+#define miPointerScreenKey (&miPointerScreenKeyRec)
+
+#endif                          /* MIPOINTER_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipointer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loader.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loader.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loader.h	(Revision 52145)
@@ -0,0 +1,77 @@
+/*
+ * Copyright 1995-1998 by Metro Link, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Metro Link, Inc. not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Metro Link, Inc. makes no
+ * representations about the suitability of this software for any purpose.
+ *  It is provided "as is" without express or implied warranty.
+ *
+ * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LOADER_H
+#define _LOADER_H
+
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xmd.h>
+
+/* Compiled-in version information */
+typedef struct {
+    int xf86Version;
+    int ansicVersion;
+    int videodrvVersion;
+    int xinputVersion;
+    int extensionVersion;
+    int fontVersion;
+} ModuleVersions;
+extern const ModuleVersions LoaderVersionInfo;
+
+extern unsigned long LoaderOptions;
+
+/* Internal Functions */
+void *LoaderOpen(const char *, int *, int *);
+void *LoaderSymbolFromModule(void *, const char *);
+
+#endif                          /* _LOADER_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/loader.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geint.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GEINT_H_
+#define _GEINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/geproto.h>
+
+extern _X_EXPORT DevPrivateKeyRec GEClientPrivateKeyRec;
+
+#define GEClientPrivateKey (&GEClientPrivateKeyRec)
+
+typedef struct _GEClientInfo {
+    CARD32 major_version;
+    CARD32 minor_version;
+} GEClientInfoRec, *GEClientInfoPtr;
+
+#define GEGetClient(pClient)    ((GEClientInfoPtr)(dixLookupPrivate(&((pClient)->devPrivates), GEClientPrivateKey)))
+
+extern _X_EXPORT int (*ProcGEVector[ /*GENumRequests */ ]) (ClientPtr);
+extern _X_EXPORT int (*SProcGEVector[ /*GENumRequests */ ]) (ClientPtr);
+
+#endif                          /* _GEINT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/geint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_asm.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_asm.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_asm.h	(Revision 52145)
@@ -0,0 +1,1053 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		Watcom C++ 10.6 or later
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Inline assembler versions of the primitive operand
+*				functions for faster performance. At the moment this is
+*				x86 inline assembler, but these functions could be replaced
+*				with native inline assembler for each supported processor
+*				platform.
+*
+****************************************************************************/
+
+#ifndef	__X86EMU_PRIM_ASM_H
+#define	__X86EMU_PRIM_ASM_H
+
+#ifdef	__WATCOMC__
+
+#ifndef	VALIDATE
+#define	__HAVE_INLINE_ASSEMBLER__
+#endif
+
+u32 get_flags_asm(void);
+
+#pragma aux get_flags_asm =			\
+	"pushf"                         \
+	"pop	eax"                  	\
+	value [eax]                     \
+	modify exact [eax];
+
+u16 aaa_word_asm(u32 * flags, u16 d);
+
+#pragma aux aaa_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aaa"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16 aas_word_asm(u32 * flags, u16 d);
+
+#pragma aux aas_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aas"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16 aad_word_asm(u32 * flags, u16 d);
+
+#pragma aux aad_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aad"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16 aam_word_asm(u32 * flags, u8 d);
+
+#pragma aux aam_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aam"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u8 adc_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux adc_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 adc_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux adc_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 adc_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux adc_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 add_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux add_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 add_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux add_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 add_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux add_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 and_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux and_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 and_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux and_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 and_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux and_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 cmp_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux cmp_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 cmp_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux cmp_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 cmp_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux cmp_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 daa_byte_asm(u32 * flags, u8 d);
+
+#pragma aux daa_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"daa"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u8 das_byte_asm(u32 * flags, u8 d);
+
+#pragma aux das_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"das"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u8 dec_byte_asm(u32 * flags, u8 d);
+
+#pragma aux dec_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16 dec_word_asm(u32 * flags, u16 d);
+
+#pragma aux dec_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32 dec_long_asm(u32 * flags, u32 d);
+
+#pragma aux dec_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8 inc_byte_asm(u32 * flags, u8 d);
+
+#pragma aux inc_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16 inc_word_asm(u32 * flags, u16 d);
+
+#pragma aux inc_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32 inc_long_asm(u32 * flags, u32 d);
+
+#pragma aux inc_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8 or_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux or_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	al,bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 or_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux or_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	ax,bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 or_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux or_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	eax,ebx"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 neg_byte_asm(u32 * flags, u8 d);
+
+#pragma aux neg_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16 neg_word_asm(u32 * flags, u16 d);
+
+#pragma aux neg_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32 neg_long_asm(u32 * flags, u32 d);
+
+#pragma aux neg_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8 not_byte_asm(u32 * flags, u8 d);
+
+#pragma aux not_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16 not_word_asm(u32 * flags, u16 d);
+
+#pragma aux not_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32 not_long_asm(u32 * flags, u32 d);
+
+#pragma aux not_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8 rcl_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux rcl_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 rcl_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux rcl_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 rcl_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux rcl_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 rcr_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux rcr_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 rcr_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux rcr_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 rcr_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux rcr_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 rol_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux rol_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 rol_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux rol_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 rol_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux rol_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 ror_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux ror_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 ror_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux ror_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 ror_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux ror_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 shl_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux shl_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 shl_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux shl_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 shl_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux shl_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 shr_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux shr_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 shr_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux shr_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 shr_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux shr_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8 sar_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux sar_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16 sar_word_asm(u32 * flags, u16 d, u8 s);
+
+#pragma aux sar_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32 sar_long_asm(u32 * flags, u32 d, u8 s);
+
+#pragma aux sar_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u16 shld_word_asm(u32 * flags, u16 d, u16 fill, u8 s);
+
+#pragma aux shld_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shld	ax,dx,cl"               \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [dx] [cl]       \
+	value [ax]                      \
+	modify exact [ax dx cl];
+
+u32 shld_long_asm(u32 * flags, u32 d, u32 fill, u8 s);
+
+#pragma aux shld_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shld	eax,edx,cl"             \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [edx] [cl]     \
+	value [eax]                     \
+	modify exact [eax edx cl];
+
+u16 shrd_word_asm(u32 * flags, u16 d, u16 fill, u8 s);
+
+#pragma aux shrd_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shrd	ax,dx,cl"               \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [dx] [cl]       \
+	value [ax]                      \
+	modify exact [ax dx cl];
+
+u32 shrd_long_asm(u32 * flags, u32 d, u32 fill, u8 s);
+
+#pragma aux shrd_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shrd	eax,edx,cl"             \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [edx] [cl]     \
+	value [eax]                     \
+	modify exact [eax edx cl];
+
+u8 sbb_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux sbb_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 sbb_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux sbb_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 sbb_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux sbb_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8 sub_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux sub_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 sub_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux sub_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 sub_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux sub_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+void test_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux test_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	modify exact [al bl];
+
+void test_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux test_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	modify exact [ax bx];
+
+void test_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux test_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	modify exact [eax ebx];
+
+u8 xor_byte_asm(u32 * flags, u8 d, u8 s);
+
+#pragma aux xor_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16 xor_word_asm(u32 * flags, u16 d, u16 s);
+
+#pragma aux xor_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32 xor_long_asm(u32 * flags, u32 d, u32 s);
+
+#pragma aux xor_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+void imul_byte_asm(u32 * flags, u16 * ax, u8 d, u8 s);
+
+#pragma aux imul_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	parm [edi] [esi] [al] [bl]      \
+	modify exact [esi ax bl];
+
+void imul_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 d, u16 s);
+
+#pragma aux imul_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [bx]\
+	modify exact [esi edi ax bx dx];
+
+void imul_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 d, u32 s);
+
+#pragma aux imul_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [ebx] \
+	modify exact [esi edi eax ebx edx];
+
+void mul_byte_asm(u32 * flags, u16 * ax, u8 d, u8 s);
+
+#pragma aux mul_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	parm [edi] [esi] [al] [bl]      \
+	modify exact [esi ax bl];
+
+void mul_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 d, u16 s);
+
+#pragma aux mul_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [bx]\
+	modify exact [esi edi ax bx dx];
+
+void mul_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 d, u32 s);
+
+#pragma aux mul_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [ebx] \
+	modify exact [esi edi eax ebx edx];
+
+void idiv_byte_asm(u32 * flags, u8 * al, u8 * ah, u16 d, u8 s);
+
+#pragma aux idiv_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],al"				\
+	"mov	[ecx],ah"				\
+	parm [edi] [esi] [ecx] [ax] [bl]\
+	modify exact [esi edi ax bl];
+
+void idiv_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 dlo, u16 dhi, u16 s);
+
+#pragma aux idiv_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
+	modify exact [esi edi ax dx bx];
+
+void idiv_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 dlo, u32 dhi, u32 s);
+
+#pragma aux idiv_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [edx] [ebx]\
+	modify exact [esi edi eax edx ebx];
+
+void div_byte_asm(u32 * flags, u8 * al, u8 * ah, u16 d, u8 s);
+
+#pragma aux div_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],al"				\
+	"mov	[ecx],ah"				\
+	parm [edi] [esi] [ecx] [ax] [bl]\
+	modify exact [esi edi ax bl];
+
+void div_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 dlo, u16 dhi, u16 s);
+
+#pragma aux div_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
+	modify exact [esi edi ax dx bx];
+
+void div_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 dlo, u32 dhi, u32 s);
+
+#pragma aux div_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [edx] [ebx]\
+	modify exact [esi edi eax edx ebx];
+
+#endif
+
+#endif                          /* __X86EMU_PRIM_ASM_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_asm.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbbits.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbbits.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbbits.h	(Revision 52145)
@@ -0,0 +1,875 @@
+/*
+ * Copyright ¬© 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This file defines functions for drawing some primitives using
+ * underlying datatypes instead of masks
+ */
+
+#define isClipped(c,ul,lr)  (((c) | ((c) - (ul)) | ((lr) - (c))) & 0x80008000)
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifdef BITSMUL
+#define MUL BITSMUL
+#else
+#define MUL 1
+#endif
+
+#ifdef BITSSTORE
+#define STORE(b,x)  BITSSTORE(b,x)
+#else
+#define STORE(b,x)  WRITE((b), (x))
+#endif
+
+#ifdef BITSRROP
+#define RROP(b,a,x)	BITSRROP(b,a,x)
+#else
+#define RROP(b,a,x)	WRITE((b), FbDoRRop (READ(b), (a), (x)))
+#endif
+
+#ifdef BITSUNIT
+#define UNIT BITSUNIT
+#define USE_SOLID
+#else
+#define UNIT BITS
+#endif
+
+/*
+ * Define the following before including this file:
+ *
+ *  BRESSOLID	name of function for drawing a solid segment
+ *  BRESDASH	name of function for drawing a dashed segment
+ *  DOTS	name of function for drawing dots
+ *  ARC		name of function for drawing a solid arc
+ *  BITS	type of underlying unit
+ */
+
+#ifdef BRESSOLID
+void
+BRESSOLID(DrawablePtr pDrawable,
+          GCPtr pGC,
+          int dashOffset,
+          int signdx,
+          int signdy, int axis, int x1, int y1, int e, int e1, int e3, int len)
+{
+    FbBits *dst;
+    FbStride dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
+    UNIT *bits;
+    FbStride bitsStride;
+    FbStride majorStep, minorStep;
+    BITS xor = (BITS) pPriv->xor;
+
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bits =
+        ((UNIT *) (dst + ((y1 + dstYoff) * dstStride))) + (x1 + dstXoff) * MUL;
+    bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    if (signdy < 0)
+        bitsStride = -bitsStride;
+    if (axis == X_AXIS) {
+        majorStep = signdx * MUL;
+        minorStep = bitsStride;
+    }
+    else {
+        majorStep = bitsStride;
+        minorStep = signdx * MUL;
+    }
+    while (len--) {
+        STORE(bits, xor);
+        bits += majorStep;
+        e += e1;
+        if (e >= 0) {
+            bits += minorStep;
+            e += e3;
+        }
+    }
+
+    fbFinishAccess(pDrawable);
+}
+#endif
+
+#ifdef BRESDASH
+void
+BRESDASH(DrawablePtr pDrawable,
+         GCPtr pGC,
+         int dashOffset,
+         int signdx,
+         int signdy, int axis, int x1, int y1, int e, int e1, int e3, int len)
+{
+    FbBits *dst;
+    FbStride dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+    FbGCPrivPtr pPriv = fbGetGCPrivate(pGC);
+    UNIT *bits;
+    FbStride bitsStride;
+    FbStride majorStep, minorStep;
+    BITS xorfg, xorbg;
+
+    FbDashDeclare;
+    int dashlen;
+    Bool even;
+    Bool doOdd;
+
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    doOdd = pGC->lineStyle == LineDoubleDash;
+    xorfg = (BITS) pPriv->xor;
+    xorbg = (BITS) pPriv->bgxor;
+
+    FbDashInit(pGC, pPriv, dashOffset, dashlen, even);
+
+    bits =
+        ((UNIT *) (dst + ((y1 + dstYoff) * dstStride))) + (x1 + dstXoff) * MUL;
+    bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    if (signdy < 0)
+        bitsStride = -bitsStride;
+    if (axis == X_AXIS) {
+        majorStep = signdx * MUL;
+        minorStep = bitsStride;
+    }
+    else {
+        majorStep = bitsStride;
+        minorStep = signdx * MUL;
+    }
+    if (dashlen >= len)
+        dashlen = len;
+    if (doOdd) {
+        if (!even)
+            goto doubleOdd;
+        for (;;) {
+            len -= dashlen;
+            while (dashlen--) {
+                STORE(bits, xorfg);
+                bits += majorStep;
+                if ((e += e1) >= 0) {
+                    e += e3;
+                    bits += minorStep;
+                }
+            }
+            if (!len)
+                break;
+
+            FbDashNextEven(dashlen);
+
+            if (dashlen >= len)
+                dashlen = len;
+ doubleOdd:
+            len -= dashlen;
+            while (dashlen--) {
+                STORE(bits, xorbg);
+                bits += majorStep;
+                if ((e += e1) >= 0) {
+                    e += e3;
+                    bits += minorStep;
+                }
+            }
+            if (!len)
+                break;
+
+            FbDashNextOdd(dashlen);
+
+            if (dashlen >= len)
+                dashlen = len;
+        }
+    }
+    else {
+        if (!even)
+            goto onOffOdd;
+        for (;;) {
+            len -= dashlen;
+            while (dashlen--) {
+                STORE(bits, xorfg);
+                bits += majorStep;
+                if ((e += e1) >= 0) {
+                    e += e3;
+                    bits += minorStep;
+                }
+            }
+            if (!len)
+                break;
+
+            FbDashNextEven(dashlen);
+
+            if (dashlen >= len)
+                dashlen = len;
+ onOffOdd:
+            len -= dashlen;
+            while (dashlen--) {
+                bits += majorStep;
+                if ((e += e1) >= 0) {
+                    e += e3;
+                    bits += minorStep;
+                }
+            }
+            if (!len)
+                break;
+
+            FbDashNextOdd(dashlen);
+
+            if (dashlen >= len)
+                dashlen = len;
+        }
+    }
+
+    fbFinishAccess(pDrawable);
+}
+#endif
+
+#ifdef DOTS
+void
+DOTS(FbBits * dst,
+     FbStride dstStride,
+     int dstBpp,
+     BoxPtr pBox,
+     xPoint * ptsOrig,
+     int npt, int xorg, int yorg, int xoff, int yoff, FbBits and, FbBits xor)
+{
+    INT32 *pts = (INT32 *) ptsOrig;
+    UNIT *bits = (UNIT *) dst;
+    UNIT *point;
+    BITS bxor = (BITS) xor;
+    BITS band = (BITS) and;
+    FbStride bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    INT32 ul, lr;
+    INT32 pt;
+
+    ul = coordToInt(pBox->x1 - xorg, pBox->y1 - yorg);
+    lr = coordToInt(pBox->x2 - xorg - 1, pBox->y2 - yorg - 1);
+
+    bits += bitsStride * (yorg + yoff) + (xorg + xoff) * MUL;
+
+    if (and == 0) {
+        while (npt--) {
+            pt = *pts++;
+            if (!isClipped(pt, ul, lr)) {
+                point = bits + intToY(pt) * bitsStride + intToX(pt) * MUL;
+                STORE(point, bxor);
+            }
+        }
+    }
+    else {
+        while (npt--) {
+            pt = *pts++;
+            if (!isClipped(pt, ul, lr)) {
+                point = bits + intToY(pt) * bitsStride + intToX(pt) * MUL;
+                RROP(point, band, bxor);
+            }
+        }
+    }
+}
+#endif
+
+#ifdef ARC
+
+#define ARCCOPY(d)  STORE(d,xorBits)
+#define ARCRROP(d)  RROP(d,andBits,xorBits)
+
+void
+ARC(FbBits * dst,
+    FbStride dstStride,
+    int dstBpp, xArc * arc, int drawX, int drawY, FbBits and, FbBits xor)
+{
+    UNIT *bits;
+    FbStride bitsStride;
+    miZeroArcRec info;
+    Bool do360;
+    int x;
+    UNIT *yorgp, *yorgop;
+    BITS andBits, xorBits;
+    int yoffset, dyoffset;
+    int y, a, b, d, mask;
+    int k1, k3, dx, dy;
+
+    bits = (UNIT *) dst;
+    bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    andBits = (BITS) and;
+    xorBits = (BITS) xor;
+    do360 = miZeroArcSetup(arc, &info, TRUE);
+    yorgp = bits + ((info.yorg + drawY) * bitsStride);
+    yorgop = bits + ((info.yorgo + drawY) * bitsStride);
+    info.xorg = (info.xorg + drawX) * MUL;
+    info.xorgo = (info.xorgo + drawX) * MUL;
+    MIARCSETUP();
+    yoffset = y ? bitsStride : 0;
+    dyoffset = 0;
+    mask = info.initialMask;
+
+    if (!(arc->width & 1)) {
+        if (andBits == 0) {
+            if (mask & 2)
+                ARCCOPY(yorgp + info.xorgo);
+            if (mask & 8)
+                ARCCOPY(yorgop + info.xorgo);
+        }
+        else {
+            if (mask & 2)
+                ARCRROP(yorgp + info.xorgo);
+            if (mask & 8)
+                ARCRROP(yorgop + info.xorgo);
+        }
+    }
+    if (!info.end.x || !info.end.y) {
+        mask = info.end.mask;
+        info.end = info.altend;
+    }
+    if (do360 && (arc->width == arc->height) && !(arc->width & 1)) {
+        int xoffset = bitsStride;
+        UNIT *yorghb = yorgp + (info.h * bitsStride) + info.xorg;
+        UNIT *yorgohb = yorghb - info.h * MUL;
+
+        yorgp += info.xorg;
+        yorgop += info.xorg;
+        yorghb += info.h * MUL;
+        while (1) {
+            if (andBits == 0) {
+                ARCCOPY(yorgp + yoffset + x * MUL);
+                ARCCOPY(yorgp + yoffset - x * MUL);
+                ARCCOPY(yorgop - yoffset - x * MUL);
+                ARCCOPY(yorgop - yoffset + x * MUL);
+            }
+            else {
+                ARCRROP(yorgp + yoffset + x * MUL);
+                ARCRROP(yorgp + yoffset - x * MUL);
+                ARCRROP(yorgop - yoffset - x * MUL);
+                ARCRROP(yorgop - yoffset + x * MUL);
+            }
+            if (a < 0)
+                break;
+            if (andBits == 0) {
+                ARCCOPY(yorghb - xoffset - y * MUL);
+                ARCCOPY(yorgohb - xoffset + y * MUL);
+                ARCCOPY(yorgohb + xoffset + y * MUL);
+                ARCCOPY(yorghb + xoffset - y * MUL);
+            }
+            else {
+                ARCRROP(yorghb - xoffset - y * MUL);
+                ARCRROP(yorgohb - xoffset + y * MUL);
+                ARCRROP(yorgohb + xoffset + y * MUL);
+                ARCRROP(yorghb + xoffset - y * MUL);
+            }
+            xoffset += bitsStride;
+            MIARCCIRCLESTEP(yoffset += bitsStride;
+                );
+        }
+        yorgp -= info.xorg;
+        yorgop -= info.xorg;
+        x = info.w;
+        yoffset = info.h * bitsStride;
+    }
+    else if (do360) {
+        while (y < info.h || x < info.w) {
+            MIARCOCTANTSHIFT(dyoffset = bitsStride;
+                );
+            if (andBits == 0) {
+                ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+                ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+                ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+                ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+            }
+            else {
+                ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+                ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+                ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+                ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+            }
+            MIARCSTEP(yoffset += dyoffset;
+                      , yoffset += bitsStride;
+                );
+        }
+    }
+    else {
+        while (y < info.h || x < info.w) {
+            MIARCOCTANTSHIFT(dyoffset = bitsStride;
+                );
+            if ((x == info.start.x) || (y == info.start.y)) {
+                mask = info.start.mask;
+                info.start = info.altstart;
+            }
+            if (andBits == 0) {
+                if (mask & 1)
+                    ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+                if (mask & 2)
+                    ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+                if (mask & 4)
+                    ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+                if (mask & 8)
+                    ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+            }
+            else {
+                if (mask & 1)
+                    ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+                if (mask & 2)
+                    ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+                if (mask & 4)
+                    ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+                if (mask & 8)
+                    ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+            }
+            if ((x == info.end.x) || (y == info.end.y)) {
+                mask = info.end.mask;
+                info.end = info.altend;
+            }
+            MIARCSTEP(yoffset += dyoffset;
+                      , yoffset += bitsStride;
+                );
+        }
+    }
+    if ((x == info.start.x) || (y == info.start.y))
+        mask = info.start.mask;
+    if (andBits == 0) {
+        if (mask & 1)
+            ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+        if (mask & 4)
+            ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+        if (arc->height & 1) {
+            if (mask & 2)
+                ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+            if (mask & 8)
+                ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+        }
+    }
+    else {
+        if (mask & 1)
+            ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+        if (mask & 4)
+            ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+        if (arc->height & 1) {
+            if (mask & 2)
+                ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+            if (mask & 8)
+                ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+        }
+    }
+}
+
+#undef ARCCOPY
+#undef ARCRROP
+#endif
+
+#ifdef GLYPH
+#if BITMAP_BIT_ORDER == LSBFirst
+#define WRITE_ADDR1(n)	    (n)
+#define WRITE_ADDR2(n)	    (n)
+#define WRITE_ADDR4(n)	    (n)
+#else
+#define WRITE_ADDR1(n)	    ((n) ^ 3)
+#define WRITE_ADDR2(n)	    ((n) ^ 2)
+#define WRITE_ADDR4(n)	    ((n))
+#endif
+
+#define WRITE1(d,n,fg)	    WRITE(d + WRITE_ADDR1(n), (BITS) (fg))
+
+#ifdef BITS2
+#define WRITE2(d,n,fg)	    WRITE((BITS2 *) &((d)[WRITE_ADDR2(n)]), (BITS2) (fg))
+#else
+#define WRITE2(d,n,fg)	    (WRITE1(d,n,fg), WRITE1(d,(n)+1,fg))
+#endif
+
+#ifdef BITS4
+#define WRITE4(d,n,fg)	    WRITE((BITS4 *) &((d)[WRITE_ADDR4(n)]), (BITS4) (fg))
+#else
+#define WRITE4(d,n,fg)	    (WRITE2(d,n,fg), WRITE2(d,(n)+2,fg))
+#endif
+
+void
+GLYPH(FbBits * dstBits,
+      FbStride dstStride,
+      int dstBpp, FbStip * stipple, FbBits fg, int x, int height)
+{
+    int lshift;
+    FbStip bits;
+    BITS *dstLine;
+    BITS *dst;
+    int n;
+    int shift;
+
+    dstLine = (BITS *) dstBits;
+    dstLine += x & ~3;
+    dstStride *= (sizeof(FbBits) / sizeof(BITS));
+    shift = x & 3;
+    lshift = 4 - shift;
+    while (height--) {
+        bits = *stipple++;
+        dst = (BITS *) dstLine;
+        n = lshift;
+        while (bits) {
+            switch (FbStipMoveLsb(FbLeftStipBits(bits, n), 4, n)) {
+            case 0:
+                break;
+            case 1:
+                WRITE1(dst, 0, fg);
+                break;
+            case 2:
+                WRITE1(dst, 1, fg);
+                break;
+            case 3:
+                WRITE2(dst, 0, fg);
+                break;
+            case 4:
+                WRITE1(dst, 2, fg);
+                break;
+            case 5:
+                WRITE1(dst, 0, fg);
+                WRITE1(dst, 2, fg);
+                break;
+            case 6:
+                WRITE1(dst, 1, fg);
+                WRITE1(dst, 2, fg);
+                break;
+            case 7:
+                WRITE2(dst, 0, fg);
+                WRITE1(dst, 2, fg);
+                break;
+            case 8:
+                WRITE1(dst, 3, fg);
+                break;
+            case 9:
+                WRITE1(dst, 0, fg);
+                WRITE1(dst, 3, fg);
+                break;
+            case 10:
+                WRITE1(dst, 1, fg);
+                WRITE1(dst, 3, fg);
+                break;
+            case 11:
+                WRITE2(dst, 0, fg);
+                WRITE1(dst, 3, fg);
+                break;
+            case 12:
+                WRITE2(dst, 2, fg);
+                break;
+            case 13:
+                WRITE1(dst, 0, fg);
+                WRITE2(dst, 2, fg);
+                break;
+            case 14:
+                WRITE1(dst, 1, fg);
+                WRITE2(dst, 2, fg);
+                break;
+            case 15:
+                WRITE4(dst, 0, fg);
+                break;
+            }
+            bits = FbStipLeft(bits, n);
+            n = 4;
+            dst += 4;
+        }
+        dstLine += dstStride;
+    }
+}
+
+#undef WRITE_ADDR1
+#undef WRITE_ADDR2
+#undef WRITE_ADDR4
+#undef WRITE1
+#undef WRITE2
+#undef WRITE4
+
+#endif
+
+#ifdef POLYLINE
+void
+POLYLINE(DrawablePtr pDrawable,
+         GCPtr pGC, int mode, int npt, DDXPointPtr ptsOrig)
+{
+    INT32 *pts = (INT32 *) ptsOrig;
+    int xoff = pDrawable->x;
+    int yoff = pDrawable->y;
+    unsigned int bias = miGetZeroLineBias(pDrawable->pScreen);
+    BoxPtr pBox = RegionExtents(fbGetCompositeClip(pGC));
+
+    FbBits *dst;
+    int dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+
+    UNIT *bits, *bitsBase;
+    FbStride bitsStride;
+    BITS xor = fbGetGCPrivate(pGC)->xor;
+    BITS and = fbGetGCPrivate(pGC)->and;
+    int dashoffset = 0;
+
+    INT32 ul, lr;
+    INT32 pt1, pt2;
+
+    int e, e1, e3, len;
+    int stepmajor, stepminor;
+    int octant;
+
+    if (mode == CoordModePrevious)
+        fbFixCoordModePrevious(npt, ptsOrig);
+
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    bitsBase =
+        ((UNIT *) dst) + (yoff + dstYoff) * bitsStride + (xoff + dstXoff) * MUL;
+    ul = coordToInt(pBox->x1 - xoff, pBox->y1 - yoff);
+    lr = coordToInt(pBox->x2 - xoff - 1, pBox->y2 - yoff - 1);
+
+    pt1 = *pts++;
+    npt--;
+    pt2 = *pts++;
+    npt--;
+    for (;;) {
+        if (isClipped(pt1, ul, lr) | isClipped(pt2, ul, lr)) {
+            fbSegment(pDrawable, pGC,
+                      intToX(pt1) + xoff, intToY(pt1) + yoff,
+                      intToX(pt2) + xoff, intToY(pt2) + yoff,
+                      npt == 0 && pGC->capStyle != CapNotLast, &dashoffset);
+            if (!npt) {
+                fbFinishAccess(pDrawable);
+                return;
+            }
+            pt1 = pt2;
+            pt2 = *pts++;
+            npt--;
+        }
+        else {
+            bits = bitsBase + intToY(pt1) * bitsStride + intToX(pt1) * MUL;
+            for (;;) {
+                CalcLineDeltas(intToX(pt1), intToY(pt1),
+                               intToX(pt2), intToY(pt2),
+                               len, e1, stepmajor, stepminor, 1, bitsStride,
+                               octant);
+                stepmajor *= MUL;
+                if (len < e1) {
+                    e3 = len;
+                    len = e1;
+                    e1 = e3;
+
+                    e3 = stepminor;
+                    stepminor = stepmajor;
+                    stepmajor = e3;
+                    SetYMajorOctant(octant);
+                }
+                e = -len;
+                e1 <<= 1;
+                e3 = e << 1;
+                FIXUP_ERROR(e, octant, bias);
+                if (and == 0) {
+                    while (len--) {
+                        STORE(bits, xor);
+                        bits += stepmajor;
+                        e += e1;
+                        if (e >= 0) {
+                            bits += stepminor;
+                            e += e3;
+                        }
+                    }
+                }
+                else {
+                    while (len--) {
+                        RROP(bits, and, xor);
+                        bits += stepmajor;
+                        e += e1;
+                        if (e >= 0) {
+                            bits += stepminor;
+                            e += e3;
+                        }
+                    }
+                }
+                if (!npt) {
+                    if (pGC->capStyle != CapNotLast &&
+                        pt2 != *((INT32 *) ptsOrig)) {
+                        RROP(bits, and, xor);
+                    }
+                    fbFinishAccess(pDrawable);
+                    return;
+                }
+                pt1 = pt2;
+                pt2 = *pts++;
+                --npt;
+                if (isClipped(pt2, ul, lr))
+                    break;
+            }
+        }
+    }
+
+    fbFinishAccess(pDrawable);
+}
+#endif
+
+#ifdef POLYSEGMENT
+void
+POLYSEGMENT(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg)
+{
+    INT32 *pts = (INT32 *) pseg;
+    int xoff = pDrawable->x;
+    int yoff = pDrawable->y;
+    unsigned int bias = miGetZeroLineBias(pDrawable->pScreen);
+    BoxPtr pBox = RegionExtents(fbGetCompositeClip(pGC));
+
+    FbBits *dst;
+    int dstStride;
+    int dstBpp;
+    int dstXoff, dstYoff;
+
+    UNIT *bits, *bitsBase;
+    FbStride bitsStride;
+    FbBits xorBits = fbGetGCPrivate(pGC)->xor;
+    FbBits andBits = fbGetGCPrivate(pGC)->and;
+    BITS xor = xorBits;
+    BITS and = andBits;
+    int dashoffset = 0;
+
+    INT32 ul, lr;
+    INT32 pt1, pt2;
+
+    int e, e1, e3, len;
+    int stepmajor, stepminor;
+    int octant;
+    Bool capNotLast;
+
+    fbGetDrawable(pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bitsStride = dstStride * (sizeof(FbBits) / sizeof(UNIT));
+    bitsBase =
+        ((UNIT *) dst) + (yoff + dstYoff) * bitsStride + (xoff + dstXoff) * MUL;
+    ul = coordToInt(pBox->x1 - xoff, pBox->y1 - yoff);
+    lr = coordToInt(pBox->x2 - xoff - 1, pBox->y2 - yoff - 1);
+
+    capNotLast = pGC->capStyle == CapNotLast;
+
+    while (nseg--) {
+        pt1 = *pts++;
+        pt2 = *pts++;
+        if (isClipped(pt1, ul, lr) | isClipped(pt2, ul, lr)) {
+            fbSegment(pDrawable, pGC,
+                      intToX(pt1) + xoff, intToY(pt1) + yoff,
+                      intToX(pt2) + xoff, intToY(pt2) + yoff,
+                      !capNotLast, &dashoffset);
+        }
+        else {
+            CalcLineDeltas(intToX(pt1), intToY(pt1),
+                           intToX(pt2), intToY(pt2),
+                           len, e1, stepmajor, stepminor, 1, bitsStride,
+                           octant);
+            if (e1 == 0 && len > 3
+#if MUL != 1
+                && FbCheck24Pix(and) && FbCheck24Pix(xor)
+#endif
+                ) {
+                int x1, x2;
+                FbBits *dstLine;
+                int dstX, width;
+                FbBits startmask, endmask;
+                int nmiddle;
+
+                if (stepmajor < 0) {
+                    x1 = intToX(pt2);
+                    x2 = intToX(pt1) + 1;
+                    if (capNotLast)
+                        x1++;
+                }
+                else {
+                    x1 = intToX(pt1);
+                    x2 = intToX(pt2);
+                    if (!capNotLast)
+                        x2++;
+                }
+                dstX = (x1 + xoff + dstXoff) * (sizeof(UNIT) * 8 * MUL);
+                width = (x2 - x1) * (sizeof(UNIT) * 8 * MUL);
+
+                dstLine = dst + (intToY(pt1) + yoff + dstYoff) * dstStride;
+                dstLine += dstX >> FB_SHIFT;
+                dstX &= FB_MASK;
+                FbMaskBits(dstX, width, startmask, nmiddle, endmask);
+                if (startmask) {
+                    WRITE(dstLine,
+                          FbDoMaskRRop(READ(dstLine), andBits, xorBits,
+                                       startmask));
+                    dstLine++;
+                }
+                if (!andBits)
+                    while (nmiddle--)
+                        WRITE(dstLine++, xorBits);
+                else
+                    while (nmiddle--) {
+                        WRITE(dstLine,
+                              FbDoRRop(READ(dstLine), andBits, xorBits));
+                        dstLine++;
+                    }
+                if (endmask)
+                    WRITE(dstLine,
+                          FbDoMaskRRop(READ(dstLine), andBits, xorBits,
+                                       endmask));
+            }
+            else {
+                stepmajor *= MUL;
+                bits = bitsBase + intToY(pt1) * bitsStride + intToX(pt1) * MUL;
+                if (len < e1) {
+                    e3 = len;
+                    len = e1;
+                    e1 = e3;
+
+                    e3 = stepminor;
+                    stepminor = stepmajor;
+                    stepmajor = e3;
+                    SetYMajorOctant(octant);
+                }
+                e = -len;
+                e1 <<= 1;
+                e3 = e << 1;
+                FIXUP_ERROR(e, octant, bias);
+                if (!capNotLast)
+                    len++;
+                if (and == 0) {
+                    while (len--) {
+                        STORE(bits, xor);
+                        bits += stepmajor;
+                        e += e1;
+                        if (e >= 0) {
+                            bits += stepminor;
+                            e += e3;
+                        }
+                    }
+                }
+                else {
+                    while (len--) {
+                        RROP(bits, and, xor);
+                        bits += stepmajor;
+                        e += e1;
+                        if (e >= 0) {
+                            bits += stepminor;
+                            e += e3;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    fbFinishAccess(pDrawable);
+}
+#endif
+
+#undef MUL
+#undef STORE
+#undef RROP
+#undef UNIT
+#undef USE_SOLID
+
+#undef isClipped

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fbbits.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncshm.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncshm.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncshm.h	(Revision 52145)
@@ -0,0 +1,28 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _MISYNCSHM_H_
+#define _MISYNCSHM_H_
+
+extern _X_EXPORT Bool miSyncShmScreenInit(ScreenPtr pScreen);
+
+#endif /* _MISYNCSHM_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/misyncshm.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selectev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selectev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selectev.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SELECTEV_H
+#define SELECTEV_H 1
+
+int SProcXSelectExtensionEvent(ClientPtr        /* client */
+    );
+
+int ProcXSelectExtensionEvent(ClientPtr /* client */
+    );
+
+#endif                          /* SELECTEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/selectev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxext.h	(Revision 52145)
@@ -0,0 +1,66 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _glxext_h_
+#define _glxext_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+/* doing #include <GL/glx.h> & #include <GL/glxext.h> could cause problems
+ * with overlapping definitions, so let's use the easy way
+ */
+#ifndef GLX_RGBA_FLOAT_BIT_ARB
+#define GLX_RGBA_FLOAT_BIT_ARB             0x00000004
+#endif
+#ifndef GLX_RGBA_FLOAT_TYPE_ARB
+#define GLX_RGBA_FLOAT_TYPE_ARB            0x20B9
+#endif
+#ifndef GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT
+#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT    0x00000008
+#endif
+#ifndef GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT
+#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT   0x20B1
+#endif
+
+extern GLboolean __glXFreeContext(__GLXcontext * glxc);
+extern void __glXFlushContextCache(void);
+
+extern Bool __glXAddContext(__GLXcontext * cx);
+extern void __glXErrorCallBack(GLenum code);
+extern void __glXClearErrorOccured(void);
+extern GLboolean __glXErrorOccured(void);
+extern void __glXResetLargeCommandStatus(__GLXclientState *);
+
+extern const char GLServerVersion[];
+extern int DoGetString(__GLXclientState * cl, GLbyte * pc, GLboolean need_swap);
+
+#endif                          /* _glxext_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2int.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2int.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2int.h	(Revision 52145)
@@ -0,0 +1,26 @@
+/*
+ * Copyright ¬© 2011 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+extern Bool DRI2ModuleSetup(void);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri2int.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vidmodeproc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vidmodeproc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vidmodeproc.h	(Revision 52145)
@@ -0,0 +1,84 @@
+
+/* Prototypes for DGA functions that the DDX must provide */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _VIDMODEPROC_H_
+#define _VIDMODEPROC_H_
+
+typedef enum {
+    VIDMODE_H_DISPLAY,
+    VIDMODE_H_SYNCSTART,
+    VIDMODE_H_SYNCEND,
+    VIDMODE_H_TOTAL,
+    VIDMODE_H_SKEW,
+    VIDMODE_V_DISPLAY,
+    VIDMODE_V_SYNCSTART,
+    VIDMODE_V_SYNCEND,
+    VIDMODE_V_TOTAL,
+    VIDMODE_FLAGS,
+    VIDMODE_CLOCK
+} VidModeSelectMode;
+
+typedef enum {
+    VIDMODE_MON_VENDOR,
+    VIDMODE_MON_MODEL,
+    VIDMODE_MON_NHSYNC,
+    VIDMODE_MON_NVREFRESH,
+    VIDMODE_MON_HSYNC_LO,
+    VIDMODE_MON_HSYNC_HI,
+    VIDMODE_MON_VREFRESH_LO,
+    VIDMODE_MON_VREFRESH_HI
+} VidModeSelectMonitor;
+
+typedef union {
+    const void *ptr;
+    int i;
+    float f;
+} vidMonitorValue;
+
+extern Bool VidModeExtensionInit(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool VidModeAvailable(int scrnIndex);
+extern _X_EXPORT Bool VidModeGetCurrentModeline(int scrnIndex, void **mode,
+                                                int *dotClock);
+extern _X_EXPORT Bool VidModeGetFirstModeline(int scrnIndex, void **mode,
+                                              int *dotClock);
+extern _X_EXPORT Bool VidModeGetNextModeline(int scrnIndex, void **mode,
+                                             int *dotClock);
+extern _X_EXPORT Bool VidModeDeleteModeline(int scrnIndex, void *mode);
+extern _X_EXPORT Bool VidModeZoomViewport(int scrnIndex, int zoom);
+extern _X_EXPORT Bool VidModeGetViewPort(int scrnIndex, int *x, int *y);
+extern _X_EXPORT Bool VidModeSetViewPort(int scrnIndex, int x, int y);
+extern _X_EXPORT Bool VidModeSwitchMode(int scrnIndex, void *mode);
+extern _X_EXPORT Bool VidModeLockZoom(int scrnIndex, Bool lock);
+extern _X_EXPORT Bool VidModeGetMonitor(int scrnIndex, void **monitor);
+extern _X_EXPORT int VidModeGetNumOfClocks(int scrnIndex, Bool *progClock);
+extern _X_EXPORT Bool VidModeGetClocks(int scrnIndex, int *Clocks);
+extern _X_EXPORT ModeStatus VidModeCheckModeForMonitor(int scrnIndex,
+                                                       void *mode);
+extern _X_EXPORT ModeStatus VidModeCheckModeForDriver(int scrnIndex,
+                                                      void *mode);
+extern _X_EXPORT void VidModeSetCrtcForMode(int scrnIndex, void *mode);
+extern _X_EXPORT Bool VidModeAddModeline(int scrnIndex, void *mode);
+extern _X_EXPORT int VidModeGetDotClock(int scrnIndex, int Clock);
+extern _X_EXPORT int VidModeGetNumOfModes(int scrnIndex);
+extern _X_EXPORT Bool VidModeSetGamma(int scrnIndex, float red, float green,
+                                      float blue);
+extern _X_EXPORT Bool VidModeGetGamma(int scrnIndex, float *red, float *green,
+                                      float *blue);
+extern _X_EXPORT void *VidModeCreateMode(void);
+extern _X_EXPORT void VidModeCopyMode(void *modefrom, void *modeto);
+extern _X_EXPORT int VidModeGetModeValue(void *mode, int valtyp);
+extern _X_EXPORT void VidModeSetModeValue(void *mode, int valtyp, int val);
+extern _X_EXPORT vidMonitorValue VidModeGetMonitorValue(void *monitor,
+                                                        int valtyp, int indx);
+extern _X_EXPORT Bool VidModeSetGammaRamp(int, int, CARD16 *, CARD16 *,
+                                          CARD16 *);
+extern _X_EXPORT Bool VidModeGetGammaRamp(int, int, CARD16 *, CARD16 *,
+                                          CARD16 *);
+extern _X_EXPORT int VidModeGetGammaRampSize(int scrnIndex);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/vidmodeproc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevb.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEVB_H
+#define GRABDEVB_H 1
+
+int SProcXGrabDeviceButton(ClientPtr    /* client */
+    );
+
+int ProcXGrabDeviceButton(ClientPtr     /* client */
+    );
+
+#endif                          /* GRABDEVB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxvisual.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxvisual.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxvisual.h	(Revision 52145)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for visual support.  \see dmxvisual.c */
+
+#ifndef DMXVISUAL_H
+#define DMXVISUAL_H
+
+#include "scrnintstr.h"
+
+extern Visual *dmxLookupVisual(ScreenPtr pScreen, VisualPtr pVisual);
+extern Visual *dmxLookupVisualFromID(ScreenPtr pScreen, VisualID vid);
+extern Colormap dmxColormapFromDefaultVisual(ScreenPtr pScreen,
+                                             Visual * visual);
+
+#endif                          /* DMXVISUAL_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxvisual.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optionstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optionstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optionstr.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/*
+ * Copyright ¬© 2011 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef XF86OPTIONSTR_H
+#define XF86OPTIONSTR_H
+#include "list.h"
+
+/*
+ * All options are stored using this data type.
+ */
+typedef struct _XF86OptionRec {
+    GenericListRec list;
+    const char *opt_name;
+    const char *opt_val;
+    int opt_used;
+    const char *opt_comment;
+} XF86OptionRec;
+
+typedef struct _InputOption *XF86OptionPtr;
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Optionstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/os.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/os.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/os.h	(Revision 52145)
@@ -0,0 +1,692 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef OS_H
+#define OS_H
+
+#include "misc.h"
+#include <stdarg.h>
+#include <stdint.h>
+#include <string.h>
+
+#define SCREEN_SAVER_ON   0
+#define SCREEN_SAVER_OFF  1
+#define SCREEN_SAVER_FORCER 2
+#define SCREEN_SAVER_CYCLE  3
+
+#ifndef MAX_REQUEST_SIZE
+#define MAX_REQUEST_SIZE 65535
+#endif
+#ifndef MAX_BIG_REQUEST_SIZE
+#define MAX_BIG_REQUEST_SIZE 4194303
+#endif
+
+typedef struct _FontPathRec *FontPathPtr;
+typedef struct _NewClientRec *NewClientPtr;
+
+#ifndef xalloc
+#define xnfalloc(size) XNFalloc((unsigned long)(size))
+#define xnfcalloc(_num, _size) XNFcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xnfrealloc(ptr, size) XNFrealloc((void *)(ptr), (unsigned long)(size))
+
+#define xalloc(size) Xalloc((unsigned long)(size))
+#define xcalloc(_num, _size) Xcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xrealloc(ptr, size) Xrealloc((void *)(ptr), (unsigned long)(size))
+#define xfree(ptr) Xfree((void *)(ptr))
+#define xstrdup(s) Xstrdup(s)
+#define xnfstrdup(s) XNFstrdup(s)
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#ifdef DDXBEFORERESET
+extern void ddxBeforeReset(void);
+#endif
+
+#ifdef DDXOSVERRORF
+extern _X_EXPORT void (*OsVendorVErrorFProc) (const char *,
+                                              va_list args)
+_X_ATTRIBUTE_PRINTF(1, 0);
+#endif
+
+extern _X_EXPORT int WaitForSomething(int *     /*pClientsReady */
+    );
+
+extern _X_EXPORT int ReadRequestFromClient(ClientPtr /*client */ );
+
+#if XTRANS_SEND_FDS
+extern _X_EXPORT int ReadFdFromClient(ClientPtr client);
+
+extern _X_EXPORT int WriteFdToClient(ClientPtr client, int fd, Bool do_close);
+#endif
+
+extern _X_EXPORT Bool InsertFakeRequest(ClientPtr /*client */ ,
+                                        char * /*data */ ,
+                                        int /*count */ );
+
+extern _X_EXPORT void ResetCurrentRequest(ClientPtr /*client */ );
+
+extern _X_EXPORT void FlushAllOutput(void);
+
+extern _X_EXPORT void FlushIfCriticalOutputPending(void);
+
+extern _X_EXPORT void SetCriticalOutputPending(void);
+
+extern _X_EXPORT int WriteToClient(ClientPtr /*who */ , int /*count */ ,
+                                   const void * /*buf */ );
+
+extern _X_EXPORT void ResetOsBuffers(void);
+
+extern _X_EXPORT void InitConnectionLimits(void);
+
+extern _X_EXPORT void NotifyParentProcess(void);
+
+extern _X_EXPORT void CreateWellKnownSockets(void);
+
+extern _X_EXPORT void ResetWellKnownSockets(void);
+
+extern _X_EXPORT void CloseWellKnownConnections(void);
+
+extern _X_EXPORT XID AuthorizationIDOfClient(ClientPtr /*client */ );
+
+extern _X_EXPORT const char *ClientAuthorized(ClientPtr /*client */ ,
+                                              unsigned int /*proto_n */ ,
+                                              char * /*auth_proto */ ,
+                                              unsigned int /*string_n */ ,
+                                              char * /*auth_string */ );
+
+extern _X_EXPORT Bool EstablishNewConnections(ClientPtr /*clientUnused */ ,
+                                              void */*closure */ );
+
+extern _X_EXPORT void CheckConnections(void);
+
+extern _X_EXPORT void CloseDownConnection(ClientPtr /*client */ );
+
+extern _X_EXPORT void AddGeneralSocket(int /*fd */ );
+
+extern _X_EXPORT void RemoveGeneralSocket(int /*fd */ );
+
+extern _X_EXPORT void AddEnabledDevice(int /*fd */ );
+
+extern _X_EXPORT void RemoveEnabledDevice(int /*fd */ );
+
+extern _X_EXPORT int OnlyListenToOneClient(ClientPtr /*client */ );
+
+extern _X_EXPORT void ListenToAllClients(void);
+
+extern _X_EXPORT void IgnoreClient(ClientPtr /*client */ );
+
+extern _X_EXPORT void AttendClient(ClientPtr /*client */ );
+
+extern _X_EXPORT void MakeClientGrabImpervious(ClientPtr /*client */ );
+
+extern _X_EXPORT void MakeClientGrabPervious(ClientPtr /*client */ );
+
+extern _X_EXPORT void ListenOnOpenFD(int /* fd */ , int /* noxauth */ );
+
+extern _X_EXPORT Bool AddClientOnOpenFD(int /* fd */ );
+
+extern _X_EXPORT CARD32 GetTimeInMillis(void);
+extern _X_EXPORT CARD64 GetTimeInMicros(void);
+
+extern _X_EXPORT void AdjustWaitForDelay(void */*waitTime */ ,
+                                         unsigned long /*newdelay */ );
+
+typedef struct _OsTimerRec *OsTimerPtr;
+
+typedef CARD32 (*OsTimerCallback) (OsTimerPtr /* timer */ ,
+                                   CARD32 /* time */ ,
+                                   void */* arg */ );
+
+extern _X_EXPORT void TimerInit(void);
+
+extern _X_EXPORT Bool TimerForce(OsTimerPtr /* timer */ );
+
+#define TimerAbsolute (1<<0)
+#define TimerForceOld (1<<1)
+
+extern _X_EXPORT OsTimerPtr TimerSet(OsTimerPtr /* timer */ ,
+                                     int /* flags */ ,
+                                     CARD32 /* millis */ ,
+                                     OsTimerCallback /* func */ ,
+                                     void */* arg */ );
+
+extern _X_EXPORT void TimerCheck(void);
+extern _X_EXPORT void TimerCancel(OsTimerPtr /* pTimer */ );
+extern _X_EXPORT void TimerFree(OsTimerPtr /* pTimer */ );
+
+extern _X_EXPORT void SetScreenSaverTimer(void);
+extern _X_EXPORT void FreeScreenSaverTimer(void);
+
+extern _X_EXPORT void AutoResetServer(int /*sig */ );
+
+extern _X_EXPORT void GiveUp(int /*sig */ );
+
+extern _X_EXPORT void UseMsg(void);
+
+extern _X_EXPORT void ProcessCommandLine(int /*argc */ , char * /*argv */ []);
+
+extern _X_EXPORT int set_font_authorizations(char ** /* authorizations */ ,
+                                             int * /*authlen */ ,
+                                             void */* client */ );
+
+#ifndef _HAVE_XALLOC_DECLS
+#define _HAVE_XALLOC_DECLS
+
+/*
+ * Use malloc(3) instead.
+ */
+extern _X_EXPORT void *
+Xalloc(unsigned long /*amount */ ) _X_DEPRECATED;
+
+/*
+ * Use calloc(3) instead
+ */
+extern _X_EXPORT void *
+Xcalloc(unsigned long /*amount */ ) _X_DEPRECATED;
+
+/*
+ * Use realloc(3) instead
+ */
+extern _X_EXPORT void *
+Xrealloc(void * /*ptr */ , unsigned long /*amount */ )
+ _X_DEPRECATED;
+
+/*
+ * Use free(3) instead
+ */
+extern _X_EXPORT void
+Xfree(void * /*ptr */ )
+    _X_DEPRECATED;
+
+#endif
+
+/*
+ * This function malloc(3)s buffer, terminating the server if there is not
+ * enough memory.
+ */
+extern _X_EXPORT void *
+XNFalloc(unsigned long /*amount */ );
+
+/*
+ * This function calloc(3)s buffer, terminating the server if there is not
+ * enough memory.
+ */
+extern _X_EXPORT void *
+XNFcalloc(unsigned long /*amount */ );
+
+/*
+ * This function realloc(3)s passed buffer, terminating the server if there is
+ * not enough memory.
+ */
+extern _X_EXPORT void *
+XNFrealloc(void * /*ptr */ , unsigned long /*amount */ );
+
+/*
+ * This function strdup(3)s passed string. The only difference from the library
+ * function that it is safe to pass NULL, as NULL will be returned.
+ */
+extern _X_EXPORT char *
+Xstrdup(const char *s);
+
+/*
+ * This function strdup(3)s passed string, terminating the server if there is
+ * not enough memory. If NULL is passed to this function, NULL is returned.
+ */
+extern _X_EXPORT char *
+XNFstrdup(const char *s);
+
+/* Include new X*asprintf API */
+#include "Xprintf.h"
+
+/* Older api deprecated in favor of the asprintf versions */
+extern _X_EXPORT char *
+Xprintf(const char *fmt, ...)
+_X_ATTRIBUTE_PRINTF(1, 2)
+    _X_DEPRECATED;
+extern _X_EXPORT char *
+Xvprintf(const char *fmt, va_list va)
+_X_ATTRIBUTE_PRINTF(1, 0)
+    _X_DEPRECATED;
+extern _X_EXPORT char *
+XNFprintf(const char *fmt, ...)
+_X_ATTRIBUTE_PRINTF(1, 2)
+    _X_DEPRECATED;
+extern _X_EXPORT char *
+XNFvprintf(const char *fmt, va_list va)
+_X_ATTRIBUTE_PRINTF(1, 0)
+    _X_DEPRECATED;
+
+typedef void (*OsSigHandlerPtr) (int /* sig */ );
+typedef int (*OsSigWrapperPtr) (int /* sig */ );
+
+extern _X_EXPORT OsSigHandlerPtr
+OsSignal(int /* sig */ , OsSigHandlerPtr /* handler */ );
+extern _X_EXPORT OsSigWrapperPtr
+OsRegisterSigWrapper(OsSigWrapperPtr newWrap);
+
+extern _X_EXPORT int auditTrailLevel;
+
+extern _X_EXPORT void
+LockServer(void);
+extern _X_EXPORT void
+UnlockServer(void);
+
+extern _X_EXPORT int
+OsLookupColor(int /*screen */ ,
+              char * /*name */ ,
+              unsigned /*len */ ,
+              unsigned short * /*pred */ ,
+              unsigned short * /*pgreen */ ,
+              unsigned short * /*pblue */ );
+
+extern _X_EXPORT void
+OsInit(void);
+
+extern _X_EXPORT void
+OsCleanup(Bool);
+
+extern _X_EXPORT void
+OsVendorFatalError(const char *f, va_list args)
+_X_ATTRIBUTE_PRINTF(1, 0);
+
+extern _X_EXPORT void
+OsVendorInit(void);
+
+extern _X_EXPORT void
+OsBlockSignals(void);
+
+extern _X_EXPORT void
+OsReleaseSignals(void);
+
+extern _X_EXPORT int
+OsBlockSIGIO(void);
+
+extern _X_EXPORT void
+OsReleaseSIGIO(void);
+
+extern void
+OsResetSignals(void);
+
+extern _X_EXPORT void
+OsAbort(void)
+    _X_NORETURN;
+
+#if !defined(WIN32)
+extern _X_EXPORT int
+System(const char *);
+extern _X_EXPORT void *
+Popen(const char *, const char *);
+extern _X_EXPORT int
+Pclose(void *);
+extern _X_EXPORT void *
+Fopen(const char *, const char *);
+extern _X_EXPORT int
+Fclose(void *);
+#else
+
+extern const char *
+Win32TempDir(void);
+
+extern int
+System(const char *cmdline);
+
+#define Fopen(a,b) fopen(a,b)
+#define Fclose(a) fclose(a)
+#endif
+
+extern _X_EXPORT void
+CheckUserParameters(int argc, char **argv, char **envp);
+extern _X_EXPORT void
+CheckUserAuthorization(void);
+
+extern _X_EXPORT int
+AddHost(ClientPtr /*client */ ,
+        int /*family */ ,
+        unsigned /*length */ ,
+        const void * /*pAddr */ );
+
+extern _X_EXPORT Bool
+ForEachHostInFamily(int /*family */ ,
+                    Bool (* /*func */ )(
+                                           unsigned char * /* addr */ ,
+                                           short /* len */ ,
+                                           void */* closure */ ),
+                    void */*closure */ );
+
+extern _X_EXPORT int
+RemoveHost(ClientPtr /*client */ ,
+           int /*family */ ,
+           unsigned /*length */ ,
+           void */*pAddr */ );
+
+extern _X_EXPORT int
+GetHosts(void ** /*data */ ,
+         int * /*pnHosts */ ,
+         int * /*pLen */ ,
+         BOOL * /*pEnabled */ );
+
+typedef struct sockaddr *sockaddrPtr;
+
+extern _X_EXPORT int
+InvalidHost(sockaddrPtr /*saddr */ , int /*len */ , ClientPtr client);
+
+extern _X_EXPORT int
+LocalClientCred(ClientPtr, int *, int *);
+
+#define LCC_UID_SET	(1 << 0)
+#define LCC_GID_SET	(1 << 1)
+#define LCC_PID_SET	(1 << 2)
+#define LCC_ZID_SET	(1 << 3)
+
+typedef struct {
+    int fieldsSet;              /* Bit mask of fields set */
+    int euid;                   /* Effective uid */
+    int egid;                   /* Primary effective group id */
+    int nSuppGids;              /* Number of supplementary group ids */
+    int *pSuppGids;             /* Array of supplementary group ids */
+    int pid;                    /* Process id */
+    int zoneid;                 /* Only set on Solaris 10 & later */
+} LocalClientCredRec;
+
+extern _X_EXPORT int
+GetLocalClientCreds(ClientPtr, LocalClientCredRec **);
+extern _X_EXPORT void
+FreeLocalClientCreds(LocalClientCredRec *);
+
+extern _X_EXPORT int
+ChangeAccessControl(ClientPtr /*client */ , int /*fEnabled */ );
+
+extern _X_EXPORT int
+GetAccessControl(void);
+
+extern _X_EXPORT void
+AddLocalHosts(void);
+
+extern _X_EXPORT void
+ResetHosts(const char *display);
+
+extern _X_EXPORT void
+EnableLocalHost(void);
+
+extern _X_EXPORT void
+DisableLocalHost(void);
+
+extern _X_EXPORT void
+AccessUsingXdmcp(void);
+
+extern _X_EXPORT void
+DefineSelf(int /*fd */ );
+
+#if XDMCP
+extern _X_EXPORT void
+AugmentSelf(void */*from */ , int /*len */ );
+
+extern _X_EXPORT void
+RegisterAuthorizations(void);
+#endif
+
+extern _X_EXPORT void
+InitAuthorization(const char * /*filename */ );
+
+/* extern int LoadAuthorization(void); */
+
+extern _X_EXPORT int
+AuthorizationFromID(XID id,
+                    unsigned short *name_lenp,
+                    const char **namep,
+                    unsigned short *data_lenp, char **datap);
+
+extern _X_EXPORT XID
+CheckAuthorization(unsigned int /*namelength */ ,
+                   const char * /*name */ ,
+                   unsigned int /*datalength */ ,
+                   const char * /*data */ ,
+                   ClientPtr /*client */ ,
+                   const char **        /*reason */
+    );
+
+extern _X_EXPORT void
+ResetAuthorization(void);
+
+extern _X_EXPORT int
+RemoveAuthorization(unsigned short name_length,
+                    const char *name,
+                    unsigned short data_length, const char *data);
+
+extern _X_EXPORT int
+AddAuthorization(unsigned int /*name_length */ ,
+                 const char * /*name */ ,
+                 unsigned int /*data_length */ ,
+                 char * /*data */ );
+
+#ifdef XCSECURITY
+extern _X_EXPORT XID
+GenerateAuthorization(unsigned int /* name_length */ ,
+                      const char * /* name */ ,
+                      unsigned int /* data_length */ ,
+                      const char * /* data */ ,
+                      unsigned int * /* data_length_return */ ,
+                      char ** /* data_return */ );
+#endif
+
+extern _X_EXPORT int
+ddxProcessArgument(int /*argc */ , char * /*argv */ [], int /*i */ );
+
+extern _X_EXPORT void
+ddxUseMsg(void);
+
+/* stuff for ReplyCallback */
+extern _X_EXPORT CallbackListPtr ReplyCallback;
+typedef struct {
+    ClientPtr client;
+    const void *replyData;
+    unsigned long dataLenBytes; /* actual bytes from replyData + pad bytes */
+    unsigned long bytesRemaining;
+    Bool startOfReply;
+    unsigned long padBytes;     /* pad bytes from zeroed array */
+} ReplyInfoRec;
+
+/* stuff for FlushCallback */
+extern _X_EXPORT CallbackListPtr FlushCallback;
+
+enum ExitCode {
+    EXIT_NO_ERROR = 0,
+    EXIT_ERR_ABORT = 1,
+    EXIT_ERR_CONFIGURE = 2,
+    EXIT_ERR_DRIVERS = 3,
+};
+
+extern _X_EXPORT void
+AbortDDX(enum ExitCode error);
+extern _X_EXPORT void
+ddxGiveUp(enum ExitCode error);
+extern _X_EXPORT int
+TimeSinceLastInputEvent(void);
+
+/* strcasecmp.c */
+#ifndef HAVE_STRCASECMP
+#define strcasecmp xstrcasecmp
+extern _X_EXPORT int
+xstrcasecmp(const char *s1, const char *s2);
+#endif
+
+#ifndef HAVE_STRNCASECMP
+#define strncasecmp xstrncasecmp
+extern _X_EXPORT int
+xstrncasecmp(const char *s1, const char *s2, size_t n);
+#endif
+
+#ifndef HAVE_STRCASESTR
+#define strcasestr xstrcasestr
+extern _X_EXPORT char *
+xstrcasestr(const char *s, const char *find);
+#endif
+
+#ifndef HAVE_STRLCPY
+extern _X_EXPORT size_t
+strlcpy(char *dst, const char *src, size_t siz);
+extern _X_EXPORT size_t
+strlcat(char *dst, const char *src, size_t siz);
+#endif
+
+#ifndef HAVE_STRNDUP
+extern _X_EXPORT char *
+strndup(const char *str, size_t n);
+#endif
+
+/* Logging. */
+typedef enum _LogParameter {
+    XLOG_FLUSH,
+    XLOG_SYNC,
+    XLOG_VERBOSITY,
+    XLOG_FILE_VERBOSITY
+} LogParameter;
+
+/* Flags for log messages. */
+typedef enum {
+    X_PROBED,                   /* Value was probed */
+    X_CONFIG,                   /* Value was given in the config file */
+    X_DEFAULT,                  /* Value is a default */
+    X_CMDLINE,                  /* Value was given on the command line */
+    X_NOTICE,                   /* Notice */
+    X_ERROR,                    /* Error message */
+    X_WARNING,                  /* Warning message */
+    X_INFO,                     /* Informational message */
+    X_NONE,                     /* No prefix */
+    X_NOT_IMPLEMENTED,          /* Not implemented */
+    X_DEBUG,                    /* Debug message */
+    X_UNKNOWN = -1              /* unknown -- this must always be last */
+} MessageType;
+
+extern _X_EXPORT const char *
+LogInit(const char *fname, const char *backup);
+extern _X_EXPORT void
+LogClose(enum ExitCode error);
+extern _X_EXPORT Bool
+LogSetParameter(LogParameter param, int value);
+extern _X_EXPORT void
+LogVWrite(int verb, const char *f, va_list args)
+_X_ATTRIBUTE_PRINTF(2, 0);
+extern _X_EXPORT void
+LogWrite(int verb, const char *f, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT void
+LogVMessageVerb(MessageType type, int verb, const char *format, va_list args)
+_X_ATTRIBUTE_PRINTF(3, 0);
+extern _X_EXPORT void
+LogMessageVerb(MessageType type, int verb, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(3, 4);
+extern _X_EXPORT void
+LogMessage(MessageType type, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(2, 3);
+extern _X_EXPORT void
+LogMessageVerbSigSafe(MessageType type, int verb, const char *format, ...)
+_X_ATTRIBUTE_PRINTF(3, 4);
+extern _X_EXPORT void
+LogVMessageVerbSigSafe(MessageType type, int verb, const char *format, va_list args)
+_X_ATTRIBUTE_PRINTF(3, 0);
+
+extern _X_EXPORT void
+LogVHdrMessageVerb(MessageType type, int verb,
+                   const char *msg_format, va_list msg_args,
+                   const char *hdr_format, va_list hdr_args)
+_X_ATTRIBUTE_PRINTF(3, 0)
+_X_ATTRIBUTE_PRINTF(5, 0);
+extern _X_EXPORT void
+LogHdrMessageVerb(MessageType type, int verb,
+                  const char *msg_format, va_list msg_args,
+                  const char *hdr_format, ...)
+_X_ATTRIBUTE_PRINTF(3, 0)
+_X_ATTRIBUTE_PRINTF(5, 6);
+extern _X_EXPORT void
+LogHdrMessage(MessageType type, const char *msg_format,
+              va_list msg_args, const char *hdr_format, ...)
+_X_ATTRIBUTE_PRINTF(2, 0)
+_X_ATTRIBUTE_PRINTF(4, 5);
+
+extern _X_EXPORT void
+FreeAuditTimer(void);
+extern _X_EXPORT void
+AuditF(const char *f, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+extern _X_EXPORT void
+VAuditF(const char *f, va_list args)
+_X_ATTRIBUTE_PRINTF(1, 0);
+extern _X_EXPORT void
+FatalError(const char *f, ...)
+_X_ATTRIBUTE_PRINTF(1, 2)
+    _X_NORETURN;
+
+#ifdef DEBUG
+#define DebugF ErrorF
+#else
+#define DebugF(...)             /* */
+#endif
+
+extern _X_EXPORT void
+VErrorF(const char *f, va_list args)
+_X_ATTRIBUTE_PRINTF(1, 0);
+extern _X_EXPORT void
+ErrorF(const char *f, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+extern _X_EXPORT void
+VErrorFSigSafe(const char *f, va_list args)
+_X_ATTRIBUTE_PRINTF(1, 0);
+extern _X_EXPORT void
+ErrorFSigSafe(const char *f, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+extern _X_EXPORT void
+LogPrintMarkers(void);
+
+extern _X_EXPORT void
+xorg_backtrace(void);
+
+extern _X_EXPORT int
+os_move_fd(int fd);
+
+#endif                          /* OS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/os.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgcops.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgcops.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgcops.h	(Revision 52145)
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for gcops support.  \see dmxgcops.c */
+
+#ifndef DMXGCOPS_H
+#define DMXGCOPS_H
+
+extern void dmxFillSpans(DrawablePtr pDrawable, GCPtr pGC,
+                         int nInit, DDXPointPtr pptInit, int *pwidthInit,
+                         int fSorted);
+extern void dmxSetSpans(DrawablePtr pDrawable, GCPtr pGC,
+                        char *psrc, DDXPointPtr ppt, int *pwidth, int nspans,
+                        int fSorted);
+extern void dmxPutImage(DrawablePtr pDrawable, GCPtr pGC,
+                        int depth, int x, int y, int w, int h,
+                        int leftPad, int format, char *pBits);
+extern RegionPtr dmxCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                             int srcx, int srcy, int w, int h,
+                             int dstx, int dsty);
+extern RegionPtr dmxCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                              int srcx, int srcy, int width, int height,
+                              int dstx, int dsty, unsigned long bitPlane);
+extern void dmxPolyPoint(DrawablePtr pDrawable, GCPtr pGC,
+                         int mode, int npt, DDXPointPtr pptInit);
+extern void dmxPolylines(DrawablePtr pDrawable, GCPtr pGC,
+                         int mode, int npt, DDXPointPtr pptInit);
+extern void dmxPolySegment(DrawablePtr pDrawable, GCPtr pGC,
+                           int nseg, xSegment * pSegs);
+extern void dmxPolyRectangle(DrawablePtr pDrawable, GCPtr pGC,
+                             int nrects, xRectangle *pRects);
+extern void dmxPolyArc(DrawablePtr pDrawable, GCPtr pGC,
+                       int narcs, xArc * parcs);
+extern void dmxFillPolygon(DrawablePtr pDrawable, GCPtr pGC,
+                           int shape, int mode, int count, DDXPointPtr pPts);
+extern void dmxPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
+                            int nrectFill, xRectangle *prectInit);
+extern void dmxPolyFillArc(DrawablePtr pDrawable, GCPtr pGC,
+                           int narcs, xArc * parcs);
+extern int dmxPolyText8(DrawablePtr pDrawable, GCPtr pGC,
+                        int x, int y, int count, char *chars);
+extern int dmxPolyText16(DrawablePtr pDrawable, GCPtr pGC,
+                         int x, int y, int count, unsigned short *chars);
+extern void dmxImageText8(DrawablePtr pDrawable, GCPtr pGC,
+                          int x, int y, int count, char *chars);
+extern void dmxImageText16(DrawablePtr pDrawable, GCPtr pGC,
+                           int x, int y, int count, unsigned short *chars);
+extern void dmxImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+                             int x, int y, unsigned int nglyph,
+                             CharInfoPtr * ppci, void *pglyphBase);
+extern void dmxPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+                            int x, int y, unsigned int nglyph,
+                            CharInfoPtr * ppci, void *pglyphBase);
+extern void dmxPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst,
+                          int w, int h, int x, int y);
+
+extern void dmxGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
+                        unsigned int format, unsigned long planeMask,
+                        char *pdstLine);
+extern void dmxGetSpans(DrawablePtr pDrawable, int wMax,
+                        DDXPointPtr ppt, int *pwidth, int nspans,
+                        char *pdstStart);
+
+#endif                          /* DMXGCOPS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxgcops.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipict.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipict.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipict.h	(Revision 52145)
@@ -0,0 +1,160 @@
+/*
+ *
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _MIPICT_H_
+#define _MIPICT_H_
+
+#include "picturestr.h"
+
+#define MI_MAX_INDEXED	256     /* XXX depth must be <= 8 */
+
+#if MI_MAX_INDEXED <= 256
+typedef CARD8 miIndexType;
+#endif
+
+typedef struct _miIndexed {
+    Bool color;
+    CARD32 rgba[MI_MAX_INDEXED];
+    miIndexType ent[32768];
+} miIndexedRec, *miIndexedPtr;
+
+#define miCvtR8G8B8to15(s) ((((s) >> 3) & 0x001f) | \
+			     (((s) >> 6) & 0x03e0) | \
+			     (((s) >> 9) & 0x7c00))
+#define miIndexToEnt15(mif,rgb15) ((mif)->ent[rgb15])
+#define miIndexToEnt24(mif,rgb24) miIndexToEnt15(mif,miCvtR8G8B8to15(rgb24))
+
+#define miIndexToEntY24(mif,rgb24) ((mif)->ent[CvtR8G8B8toY15(rgb24)])
+
+extern _X_EXPORT int
+ miCreatePicture(PicturePtr pPicture);
+
+extern _X_EXPORT void
+ miDestroyPicture(PicturePtr pPicture);
+
+extern _X_EXPORT void
+ miDestroyPictureClip(PicturePtr pPicture);
+
+extern _X_EXPORT int
+ miChangePictureClip(PicturePtr pPicture, int type, void *value, int n);
+
+extern _X_EXPORT void
+ miChangePicture(PicturePtr pPicture, Mask mask);
+
+extern _X_EXPORT void
+ miValidatePicture(PicturePtr pPicture, Mask mask);
+
+extern _X_EXPORT int
+ miChangePictureTransform(PicturePtr pPicture, PictTransform * transform);
+
+extern _X_EXPORT int
+
+miChangePictureFilter(PicturePtr pPicture,
+                      int filter, xFixed * params, int nparams);
+
+extern _X_EXPORT void
+ miCompositeSourceValidate(PicturePtr pPicture);
+
+extern _X_EXPORT Bool
+
+miComputeCompositeRegion(RegionPtr pRegion,
+                         PicturePtr pSrc,
+                         PicturePtr pMask,
+                         PicturePtr pDst,
+                         INT16 xSrc,
+                         INT16 ySrc,
+                         INT16 xMask,
+                         INT16 yMask,
+                         INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+extern _X_EXPORT Bool
+ miPictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats);
+
+extern _X_EXPORT Bool
+ miRealizeGlyph(ScreenPtr pScreen, GlyphPtr glyph);
+
+extern _X_EXPORT void
+ miUnrealizeGlyph(ScreenPtr pScreen, GlyphPtr glyph);
+
+extern _X_EXPORT void
+
+miGlyphs(CARD8 op,
+         PicturePtr pSrc,
+         PicturePtr pDst,
+         PictFormatPtr maskFormat,
+         INT16 xSrc,
+         INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr * glyphs);
+
+extern _X_EXPORT void
+ miRenderColorToPixel(PictFormatPtr pPict, xRenderColor * color, CARD32 *pixel);
+
+extern _X_EXPORT void
+ miRenderPixelToColor(PictFormatPtr pPict, CARD32 pixel, xRenderColor * color);
+
+extern _X_EXPORT Bool
+ miIsSolidAlpha(PicturePtr pSrc);
+
+extern _X_EXPORT void
+
+miCompositeRects(CARD8 op,
+                 PicturePtr pDst,
+                 xRenderColor * color, int nRect, xRectangle *rects);
+
+extern _X_EXPORT void
+
+miTriStrip(CARD8 op,
+           PicturePtr pSrc,
+           PicturePtr pDst,
+           PictFormatPtr maskFormat,
+           INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points);
+
+extern _X_EXPORT void
+
+miTriFan(CARD8 op,
+         PicturePtr pSrc,
+         PicturePtr pDst,
+         PictFormatPtr maskFormat,
+         INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points);
+
+extern _X_EXPORT void
+ miTrapezoidBounds(int ntrap, xTrapezoid * traps, BoxPtr box);
+
+extern _X_EXPORT void
+ miPointFixedBounds(int npoint, xPointFixed * points, BoxPtr bounds);
+
+extern _X_EXPORT void
+ miTriangleBounds(int ntri, xTriangle * tris, BoxPtr bounds);
+
+extern _X_EXPORT Bool
+ miInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+
+extern _X_EXPORT void
+ miCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+
+extern _X_EXPORT void
+
+miUpdateIndexed(ScreenPtr pScreen,
+                PictFormatPtr pFormat, int ndef, xColorItem * pdef);
+
+#endif                          /* _MIPICT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/mipict.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xwayland.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xwayland.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xwayland.h	(Revision 52145)
@@ -0,0 +1,181 @@
+/*
+ * Copyright ¬© 2014 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef XWAYLAND_H
+#define XWAYLAND_H
+
+#include <dix-config.h>
+#include <xorg-server.h>
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <wayland-client.h>
+
+#include <X11/X.h>
+
+#include <fb.h>
+#include <input.h>
+#include <dix.h>
+#include <randrstr.h>
+#include <exevents.h>
+
+struct xwl_screen {
+    int width;
+    int height;
+    int depth;
+    ScreenPtr screen;
+    WindowPtr pointer_limbo_window;
+    int expecting_event;
+
+    int wm_fd;
+    int listen_fds[5];
+    int listen_fd_count;
+    int rootless;
+    int glamor;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    CloseScreenProcPtr CloseScreen;
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    XYToWindowProcPtr XYToWindow;
+
+    struct xorg_list output_list;
+    struct xorg_list seat_list;
+    struct xorg_list damage_window_list;
+
+    int wayland_fd;
+    struct wl_display *display;
+    struct wl_registry *registry;
+    struct wl_registry *input_registry;
+    struct wl_compositor *compositor;
+    struct wl_shm *shm;
+    struct wl_shell *shell;
+
+    uint32_t serial;
+
+#define XWL_FORMAT_ARGB8888 (1 << 0)
+#define XWL_FORMAT_XRGB8888 (1 << 1)
+#define XWL_FORMAT_RGB565   (1 << 2)
+
+    int prepare_read;
+
+    char *device_name;
+    int drm_fd;
+    int fd_render_node;
+    struct wl_drm *drm;
+    uint32_t formats;
+    uint32_t capabilities;
+    void *egl_display, *egl_context;
+    struct gbm_device *gbm;
+    struct glamor_context *glamor_ctx;
+};
+
+struct xwl_window {
+    struct xwl_screen *xwl_screen;
+    struct wl_surface *surface;
+    struct wl_shell_surface *shell_surface;
+    WindowPtr window;
+    DamagePtr damage;
+    struct xorg_list link_damage;
+};
+
+#define MODIFIER_META 0x01
+
+struct xwl_seat {
+    DeviceIntPtr pointer;
+    DeviceIntPtr keyboard;
+    struct xwl_screen *xwl_screen;
+    struct wl_seat *seat;
+    struct wl_pointer *wl_pointer;
+    struct wl_keyboard *wl_keyboard;
+    struct wl_array keys;
+    struct wl_surface *cursor;
+    struct xwl_window *focus_window;
+    uint32_t id;
+    uint32_t pointer_enter_serial;
+    struct xorg_list link;
+    CursorPtr x_cursor;
+
+    wl_fixed_t horizontal_scroll;
+    wl_fixed_t vertical_scroll;
+    uint32_t scroll_time;
+
+    size_t keymap_size;
+    char *keymap;
+    struct wl_surface *keyboard_focus;
+};
+
+struct xwl_output {
+    struct xorg_list link;
+    struct wl_output *output;
+    struct xwl_screen *xwl_screen;
+    RROutputPtr randr_output;
+    RRCrtcPtr randr_crtc;
+    int32_t x, y, width, height;
+    Rotation rotation;
+};
+
+struct xwl_pixmap;
+
+Bool xwl_screen_init_cursor(struct xwl_screen *xwl_screen);
+
+struct xwl_screen *xwl_screen_get(ScreenPtr screen);
+
+void xwl_seat_set_cursor(struct xwl_seat *xwl_seat);
+
+void xwl_seat_destroy(struct xwl_seat *xwl_seat);
+
+Bool xwl_screen_init_output(struct xwl_screen *xwl_screen);
+
+struct xwl_output *xwl_output_create(struct xwl_screen *xwl_screen,
+                                     uint32_t id);
+
+void xwl_output_destroy(struct xwl_output *xwl_output);
+
+RRModePtr xwayland_cvt(int HDisplay, int VDisplay,
+                       float VRefresh, Bool Reduced, Bool Interlaced);
+
+void xwl_pixmap_set_private(PixmapPtr pixmap, struct xwl_pixmap *xwl_pixmap);
+struct xwl_pixmap *xwl_pixmap_get(PixmapPtr pixmap);
+
+
+Bool xwl_shm_create_screen_resources(ScreenPtr screen);
+PixmapPtr xwl_shm_create_pixmap(ScreenPtr screen, int width, int height,
+                                int depth, unsigned int hint);
+Bool xwl_shm_destroy_pixmap(PixmapPtr pixmap);
+struct wl_buffer *xwl_shm_pixmap_get_wl_buffer(PixmapPtr pixmap);
+
+
+Bool xwl_glamor_init(struct xwl_screen *xwl_screen);
+
+Bool xwl_screen_init_glamor(struct xwl_screen *xwl_screen,
+                         uint32_t id, uint32_t version);
+struct wl_buffer *xwl_glamor_pixmap_get_wl_buffer(PixmapPtr pixmap);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xwayland.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_x86_gcc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_x86_gcc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_x86_gcc.h	(Revision 52145)
@@ -0,0 +1,77 @@
+/****************************************************************************
+*
+* Inline helpers for x86emu
+*
+* Copyright (C) 2008 Bart Trojanowski, Symbio Technologies, LLC
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:     GNU C
+* Environment:  GCC on i386 or x86-64
+* Developer:    Bart Trojanowski
+*
+* Description:  This file defines a few x86 macros that can be used by the
+*               emulator to execute native instructions.
+*
+*               For PIC vs non-PIC code refer to:
+*               http://sam.zoy.org/blog/2007-04-13-shlib-with-non-pic-code-have-inline-assembly-and-pic-mix-well
+*
+****************************************************************************/
+#ifndef __X86EMU_PRIM_X86_GCC_H
+#define __X86EMU_PRIM_X86_GCC_H
+
+#include "x86emu/types.h"
+
+#if !defined(__GNUC__) || !(defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__))
+#error This file is intended to be used by gcc on i386 or x86-64 system
+#endif
+
+#if defined(__PIC__) && defined(__i386__)
+
+#define X86EMU_HAS_HW_CPUID 1
+static inline void
+hw_cpuid(u32 * a, u32 * b, u32 * c, u32 * d)
+{
+    __asm__ __volatile__("pushl %%ebx      \n\t"
+                         "cpuid            \n\t"
+                         "movl %%ebx, %1   \n\t"
+                         "popl %%ebx       \n\t":"=a"(*a), "=r"(*b),
+                         "=c"(*c), "=d"(*d)
+                         :"a"(*a), "c"(*c)
+                         :"cc");
+}
+
+#else                           /* ! (__PIC__ && __i386__) */
+
+#define x86EMU_HAS_HW_CPUID 1
+static inline void
+hw_cpuid(u32 * a, u32 * b, u32 * c, u32 * d)
+{
+    __asm__ __volatile__("cpuid":"=a"(*a), "=b"(*b), "=c"(*c), "=d"(*d)
+                         :"a"(*a), "c"(*c)
+                         :"cc");
+}
+
+#endif                          /* __PIC__ && __i386__ */
+
+#endif                          /* __X86EMU_PRIM_X86_GCC_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/prim_x86_gcc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86i2c.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86i2c.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86i2c.h	(Revision 52145)
@@ -0,0 +1,117 @@
+/* 
+ *  Copyright (C) 1998 Itai Nahshon, Michael Schimek
+ */
+
+#ifndef _XF86I2C_H
+#define _XF86I2C_H
+
+#include "regionstr.h"
+#include "xf86.h"
+
+typedef unsigned char I2CByte;
+typedef unsigned short I2CSlaveAddr;
+
+typedef struct _I2CBusRec *I2CBusPtr;
+typedef struct _I2CDevRec *I2CDevPtr;
+
+/* I2C masters have to register themselves */
+
+typedef struct _I2CBusRec {
+    char *BusName;
+    int scrnIndex;
+    ScrnInfoPtr pScrn;
+
+    void (*I2CUDelay) (I2CBusPtr b, int usec);
+
+    void (*I2CPutBits) (I2CBusPtr b, int scl, int sda);
+    void (*I2CGetBits) (I2CBusPtr b, int *scl, int *sda);
+
+    /* Look at the generic routines to see how these functions should behave. */
+
+    Bool (*I2CStart) (I2CBusPtr b, int timeout);
+    Bool (*I2CAddress) (I2CDevPtr d, I2CSlaveAddr);
+    void (*I2CStop) (I2CDevPtr d);
+    Bool (*I2CPutByte) (I2CDevPtr d, I2CByte data);
+    Bool (*I2CGetByte) (I2CDevPtr d, I2CByte * data, Bool);
+
+    DevUnion DriverPrivate;
+
+    int HoldTime;               /* 1 / bus clock frequency, 5 or 2 usec */
+
+    int BitTimeout;             /* usec */
+    int ByteTimeout;            /* usec */
+    int AcknTimeout;            /* usec */
+    int StartTimeout;           /* usec */
+    int RiseFallTime;           /* usec */
+
+    I2CDevPtr FirstDev;
+    I2CBusPtr NextBus;
+    Bool (*I2CWriteRead) (I2CDevPtr d, I2CByte * WriteBuffer, int nWrite,
+                          I2CByte * ReadBuffer, int nRead);
+} I2CBusRec;
+
+#define CreateI2CBusRec		xf86CreateI2CBusRec
+extern _X_EXPORT I2CBusPtr xf86CreateI2CBusRec(void);
+
+#define DestroyI2CBusRec	xf86DestroyI2CBusRec
+extern _X_EXPORT void xf86DestroyI2CBusRec(I2CBusPtr pI2CBus, Bool unalloc,
+                                           Bool devs_too);
+#define I2CBusInit		xf86I2CBusInit
+extern _X_EXPORT Bool xf86I2CBusInit(I2CBusPtr pI2CBus);
+
+extern _X_EXPORT I2CBusPtr xf86I2CFindBus(int scrnIndex, char *name);
+extern _X_EXPORT int xf86I2CGetScreenBuses(int scrnIndex,
+                                           I2CBusPtr ** pppI2CBus);
+
+/* I2C slave devices */
+
+typedef struct _I2CDevRec {
+    const char *DevName;
+
+    int BitTimeout;             /* usec */
+    int ByteTimeout;            /* usec */
+    int AcknTimeout;            /* usec */
+    int StartTimeout;           /* usec */
+
+    I2CSlaveAddr SlaveAddr;
+    I2CBusPtr pI2CBus;
+    I2CDevPtr NextDev;
+    DevUnion DriverPrivate;
+} I2CDevRec;
+
+#define CreateI2CDevRec		xf86CreateI2CDevRec
+extern _X_EXPORT I2CDevPtr xf86CreateI2CDevRec(void);
+extern _X_EXPORT void xf86DestroyI2CDevRec(I2CDevPtr pI2CDev, Bool unalloc);
+
+#define I2CDevInit		xf86I2CDevInit
+extern _X_EXPORT Bool xf86I2CDevInit(I2CDevPtr pI2CDev);
+extern _X_EXPORT I2CDevPtr xf86I2CFindDev(I2CBusPtr, I2CSlaveAddr);
+
+/* See descriptions of these functions in xf86i2c.c */
+
+#define I2CProbeAddress		xf86I2CProbeAddress
+extern _X_EXPORT Bool xf86I2CProbeAddress(I2CBusPtr pI2CBus, I2CSlaveAddr);
+
+#define		I2C_WriteRead xf86I2CWriteRead
+extern _X_EXPORT Bool xf86I2CWriteRead(I2CDevPtr d, I2CByte * WriteBuffer,
+                                       int nWrite, I2CByte * ReadBuffer,
+                                       int nRead);
+#define 	xf86I2CRead(d, rb, nr) xf86I2CWriteRead(d, NULL, 0, rb, nr)
+
+extern _X_EXPORT Bool xf86I2CReadStatus(I2CDevPtr d, I2CByte * pbyte);
+extern _X_EXPORT Bool xf86I2CReadByte(I2CDevPtr d, I2CByte subaddr,
+                                      I2CByte * pbyte);
+extern _X_EXPORT Bool xf86I2CReadBytes(I2CDevPtr d, I2CByte subaddr,
+                                       I2CByte * pbyte, int n);
+extern _X_EXPORT Bool xf86I2CReadWord(I2CDevPtr d, I2CByte subaddr,
+                                      unsigned short *pword);
+#define 	xf86I2CWrite(d, wb, nw) xf86I2CWriteRead(d, wb, nw, NULL, 0)
+extern _X_EXPORT Bool xf86I2CWriteByte(I2CDevPtr d, I2CByte subaddr,
+                                       I2CByte byte);
+extern _X_EXPORT Bool xf86I2CWriteBytes(I2CDevPtr d, I2CByte subaddr,
+                                        I2CByte * WriteBuffer, int nWrite);
+extern _X_EXPORT Bool xf86I2CWriteWord(I2CDevPtr d, I2CByte subaddr,
+                                       unsigned short word);
+extern _X_EXPORT Bool xf86I2CWriteVec(I2CDevPtr d, I2CByte * vec, int nValues);
+
+#endif /*_XF86I2C_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86i2c.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/memrange.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/memrange.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/memrange.h	(Revision 52145)
@@ -0,0 +1,72 @@
+/*
+ * Memory range attribute operations, peformed on /dev/mem
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _MEMRANGE_H
+#define _MEMRANGE_H
+
+/* Memory range attributes */
+#define MDF_UNCACHEABLE		(1<<0)  /* region not cached */
+#define MDF_WRITECOMBINE	(1<<1)  /* region supports "write combine"
+                                         * action */
+#define MDF_WRITETHROUGH	(1<<2)  /* write-through cached */
+#define MDF_WRITEBACK		(1<<3)  /* write-back cached */
+#define MDF_WRITEPROTECT	(1<<4)  /* read-only region */
+#define MDF_ATTRMASK		(0x00ffffff)
+
+#define MDF_FIXBASE		(1<<24) /* fixed base */
+#define MDF_FIXLEN		(1<<25) /* fixed length */
+#define MDF_FIRMWARE		(1<<26) /* set by firmware (XXX not useful?) */
+#define MDF_ACTIVE		(1<<27) /* currently active */
+#define MDF_BOGUS		(1<<28) /* we don't like it */
+#define MDF_FIXACTIVE		(1<<29) /* can't be turned off */
+#define MDF_BUSY		(1<<30) /* range is in use */
+
+struct mem_range_desc {
+    u_int64_t mr_base;
+    u_int64_t mr_len;
+    int mr_flags;
+    char mr_owner[8];
+};
+
+struct mem_range_op {
+    struct mem_range_desc *mo_desc;
+    int mo_arg[2];
+#define MEMRANGE_SET_UPDATE	0
+#define MEMRANGE_SET_REMOVE	1
+    /* XXX want a flag that says "set and undo when I exit" */
+};
+
+#define MEMRANGE_GET	_IOWR('m', 50, struct mem_range_op)
+#define MEMRANGE_SET	_IOW('m', 51, struct mem_range_op)
+
+#ifdef _KERNEL
+
+struct mem_range_softc;
+struct mem_range_ops {
+    void (*init) __P((struct mem_range_softc * sc));
+    int (*set)
+        __P((struct mem_range_softc * sc, struct mem_range_desc * mrd,
+             int *arg));
+    void (*initAP) __P((struct mem_range_softc * sc));
+};
+
+struct mem_range_softc {
+    struct mem_range_ops *mr_op;
+    int mr_cap;
+    int mr_ndesc;
+    struct mem_range_desc *mr_desc;
+};
+
+extern struct mem_range_softc mem_range_softc;
+
+extern int mem_range_attr_get __P((struct mem_range_desc * mrd, int *arg));
+extern int mem_range_attr_set __P((struct mem_range_desc * mrd, int *arg));
+extern void mem_range_AP_init __P((void));
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/memrange.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setfocus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setfocus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setfocus.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETFOCUS_H
+#define SETFOCUS_H 1
+
+int SProcXSetDeviceFocus(ClientPtr      /* client */
+    );
+
+int ProcXSetDeviceFocus(ClientPtr       /* client */
+    );
+
+#endif                          /* SETFOCUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setfocus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda8425.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda8425.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda8425.h	(Revision 52145)
@@ -0,0 +1,44 @@
+#ifndef __TDA8425_H__
+#define __TDA8425_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+    I2CDevRec d;
+
+    int mux;
+    int stereo;
+    int v_left;
+    int v_right;
+    int bass;
+    int treble;
+    int src_sel;
+    Bool mute;
+} TDA8425Rec, *TDA8425Ptr;
+
+#define TDA8425_ADDR_1   0x82
+
+/* the third parameter is meant to force detection of tda8425.
+   This is because tda8425 is write-only and complete implementation
+   of I2C protocol is not always available. Besides address there is no good
+   way to autodetect it so we have to _know_ it is there anyway */
+
+#define xf86_Detect_tda8425	Detect_tda8425
+extern _X_EXPORT TDA8425Ptr Detect_tda8425(I2CBusPtr b, I2CSlaveAddr addr,
+                                           Bool force);
+#define xf86_tda8425_init	tda8425_init
+extern _X_EXPORT Bool tda8425_init(TDA8425Ptr t);
+
+#define xf86_tda8425_setaudio	tda8425_setaudio
+extern _X_EXPORT void tda8425_setaudio(TDA8425Ptr t);
+
+#define xf86_tda8425_mute	tda8425_mute
+extern _X_EXPORT void tda8425_mute(TDA8425Ptr t, Bool mute);
+
+#define TDA8425SymbolsList  \
+		"Detect_tda8425", \
+		"tda8425_init", \
+		"tda8425_setaudio", \
+		"tda8425_mute"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/tda8425.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetdevfocus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetdevfocus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetdevfocus.h	(Revision 52145)
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XISETDEVFOCUS_H
+#define XISETDEVFOCUS_H 1
+
+int SProcXISetFocus(ClientPtr client);
+int ProcXISetFocus(ClientPtr client);
+
+int SProcXIGetFocus(ClientPtr client);
+int ProcXIGetFocus(ClientPtr client);
+
+void SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply * rep);
+#endif                          /* XISETDEVFOCUS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xisetdevfocus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Priv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Priv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Priv.h	(Revision 52145)
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains declarations for private XFree86 functions and variables,
+ * and definitions of private macros.
+ *
+ * "private" means not available to video drivers.
+ */
+
+#ifndef _XF86PRIV_H
+#define _XF86PRIV_H
+
+#include "xf86Privstr.h"
+#include "propertyst.h"
+#include "input.h"
+
+/*
+ * Parameters set ONLY from the command line options
+ * The global state of these things is held in xf86InfoRec (when appropriate).
+ */
+extern _X_EXPORT const char *xf86ConfigFile;
+extern _X_EXPORT const char *xf86ConfigDir;
+extern _X_EXPORT Bool xf86AllowMouseOpenFail;
+
+#ifdef XF86VIDMODE
+extern _X_EXPORT Bool xf86VidModeDisabled;
+extern _X_EXPORT Bool xf86VidModeAllowNonLocal;
+#endif
+extern _X_EXPORT Bool xf86fpFlag;
+extern _X_EXPORT Bool xf86sFlag;
+extern _X_EXPORT Bool xf86bsEnableFlag;
+extern _X_EXPORT Bool xf86bsDisableFlag;
+extern _X_EXPORT Bool xf86silkenMouseDisableFlag;
+extern _X_EXPORT Bool xf86xkbdirFlag;
+
+#ifdef HAVE_ACPI
+extern _X_EXPORT Bool xf86acpiDisableFlag;
+#endif
+extern _X_EXPORT char *xf86LayoutName;
+extern _X_EXPORT char *xf86ScreenName;
+extern _X_EXPORT char *xf86PointerName;
+extern _X_EXPORT char *xf86KeyboardName;
+extern _X_EXPORT int xf86FbBpp;
+extern _X_EXPORT int xf86Depth;
+extern _X_EXPORT Pix24Flags xf86Pix24;
+extern _X_EXPORT rgb xf86Weight;
+extern _X_EXPORT Bool xf86FlipPixels;
+extern _X_EXPORT Gamma xf86Gamma;
+extern _X_EXPORT const char *xf86ServerName;
+
+/* Other parameters */
+
+extern _X_EXPORT xf86InfoRec xf86Info;
+extern _X_EXPORT const char *xf86ModulePath;
+extern _X_EXPORT MessageType xf86ModPathFrom;
+extern _X_EXPORT const char *xf86LogFile;
+extern _X_EXPORT MessageType xf86LogFileFrom;
+extern _X_EXPORT Bool xf86LogFileWasOpened;
+extern _X_EXPORT serverLayoutRec xf86ConfigLayout;
+
+extern _X_EXPORT DriverPtr *xf86DriverList;
+extern _X_EXPORT int xf86NumDrivers;
+extern _X_EXPORT Bool xf86Resetting;
+extern _X_EXPORT Bool xf86Initialising;
+extern _X_EXPORT int xf86NumScreens;
+extern _X_EXPORT const char *xf86VisualNames[];
+extern _X_EXPORT int xf86Verbose;       /* verbosity level */
+extern _X_EXPORT int xf86LogVerbose;    /* log file verbosity level */
+
+extern _X_EXPORT RootWinPropPtr *xf86RegisteredPropertiesTable;
+
+extern ScrnInfoPtr *xf86GPUScreens;      /* List of pointers to ScrnInfoRecs */
+extern int xf86NumGPUScreens;
+#ifndef DEFAULT_VERBOSE
+#define DEFAULT_VERBOSE		0
+#endif
+#ifndef DEFAULT_LOG_VERBOSE
+#define DEFAULT_LOG_VERBOSE	3
+#endif
+#ifndef DEFAULT_DPI
+#define DEFAULT_DPI		96
+#endif
+
+/* Function Prototypes */
+#ifndef _NO_XF86_PROTOTYPES
+
+/* xf86Bus.c */
+extern _X_EXPORT Bool xf86BusConfig(void);
+extern _X_EXPORT void xf86BusProbe(void);
+extern _X_EXPORT void xf86AccessEnter(void);
+extern _X_EXPORT void xf86AccessLeave(void);
+extern _X_EXPORT void xf86PostProbe(void);
+extern _X_EXPORT void xf86ClearEntityListForScreen(ScrnInfoPtr pScrn);
+extern _X_EXPORT void xf86AddDevToEntity(int entityIndex, GDevPtr dev);
+extern _X_EXPORT void xf86RemoveDevFromEntity(int entityIndex, GDevPtr dev);
+
+/* xf86Config.c */
+
+extern _X_EXPORT Bool xf86PathIsSafe(const char *path);
+
+/* xf86DefaultModes */
+
+extern _X_EXPORT const DisplayModeRec xf86DefaultModes[];
+extern _X_EXPORT const int xf86NumDefaultModes;
+
+/* xf86Configure.c */
+extern _X_EXPORT void
+DoConfigure(void)
+    _X_NORETURN;
+extern _X_EXPORT void
+DoShowOptions(void)
+    _X_NORETURN;
+
+/* xf86Events.c */
+
+extern _X_EXPORT void
+xf86Wakeup(void *blockData, int err, void *pReadmask);
+extern _X_HIDDEN int
+xf86SigWrapper(int signo);
+extern _X_EXPORT void
+xf86HandlePMEvents(int fd, void *data);
+extern _X_EXPORT int (*xf86PMGetEventFromOs) (int fd, pmEvent * events,
+                                              int num);
+extern _X_EXPORT pmWait (*xf86PMConfirmEventToOs) (int fd, pmEvent event);
+
+/* xf86Helper.c */
+extern _X_EXPORT void
+xf86LogInit(void);
+extern _X_EXPORT void
+xf86CloseLog(enum ExitCode error);
+
+/* xf86Init.c */
+extern _X_EXPORT Bool
+xf86LoadModules(const char **list, void **optlist);
+extern _X_EXPORT int
+xf86SetVerbosity(int verb);
+extern _X_EXPORT int
+xf86SetLogVerbosity(int verb);
+extern _X_EXPORT Bool
+xf86CallDriverProbe(struct _DriverRec *drv, Bool detect_only);
+extern _X_EXPORT Bool
+xf86PrivsElevated(void);
+
+#endif                          /* _NO_XF86_PROTOTYPES */
+
+#endif                          /* _XF86PRIV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86Priv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscstruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscstruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscstruct.h	(Revision 52145)
@@ -0,0 +1,65 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISCSTRUCT_H
+#define MISCSTRUCT_H 1
+
+#include "misc.h"
+#include <X11/Xprotostr.h>
+#include <pixman.h>
+
+typedef xPoint DDXPointRec;
+
+typedef struct pixman_box16 BoxRec;
+
+typedef union _DevUnion {
+    void *ptr;
+    long val;
+    unsigned long uval;
+    void *(*fptr) (void);
+} DevUnion;
+
+#endif                          /* MISCSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/miscstruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/presentext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/presentext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/presentext.h	(Revision 52145)
@@ -0,0 +1,29 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _PRESENTEXT_H_
+#define _PRESENTEXT_H_
+
+extern _X_EXPORT void
+present_extension_init(void);
+
+#endif /* _PRESENTEXT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/presentext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdricommon.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdricommon.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdricommon.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/*
+ * Copyright ¬© 2008 Red Hat, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef _GLX_dri_common_h
+#define _GLX_dri_common_h
+
+typedef struct __GLXDRIconfig __GLXDRIconfig;
+struct __GLXDRIconfig {
+    __GLXconfig config;
+    const __DRIconfig *driConfig;
+};
+
+__GLXconfig *glxConvertConfigs(const __DRIcoreExtension * core,
+                               const __DRIconfig ** configs,
+                               unsigned int drawableType);
+
+extern const __DRIsystemTimeExtension systemTimeExtension;
+
+void *glxProbeDriver(const char *name,
+                     void **coreExt, const char *coreName, int coreVersion,
+                     void **renderExt, const char *renderName,
+                     int renderVersion);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdricommon.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdix.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdix.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdix.h	(Revision 52145)
@@ -0,0 +1,267 @@
+/***********************************************************
+Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
+and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the names of Digital or MIT not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef XVDIX_H
+#define XVDIX_H
+/*
+** File: 
+**
+**   xvdix.h --- Xv device independent header file
+**
+** Author: 
+**
+**   David Carver (Digital Workstation Engineering/Project Athena)
+**
+** Revisions:
+**
+**   29.08.91 Carver
+**     - removed UnrealizeWindow wrapper unrealizing windows no longer 
+**       preempts video
+**
+**   11.06.91 Carver
+**     - changed SetPortControl to SetPortAttribute
+**     - changed GetPortControl to GetPortAttribute
+**     - changed QueryBestSize
+**
+**   15.05.91 Carver
+**     - version 2.0 upgrade
+**
+**   24.01.91 Carver
+**     - version 1.4 upgrade
+**
+*/
+
+#include "scrnintstr.h"
+#include <X11/extensions/Xvproto.h>
+
+extern _X_EXPORT unsigned long XvExtensionGeneration;
+extern _X_EXPORT unsigned long XvScreenGeneration;
+extern _X_EXPORT unsigned long XvResourceGeneration;
+
+extern _X_EXPORT int XvReqCode;
+extern _X_EXPORT int XvEventBase;
+extern _X_EXPORT int XvErrorBase;
+
+extern _X_EXPORT RESTYPE XvRTPort;
+extern _X_EXPORT RESTYPE XvRTEncoding;
+extern _X_EXPORT RESTYPE XvRTGrab;
+extern _X_EXPORT RESTYPE XvRTVideoNotify;
+extern _X_EXPORT RESTYPE XvRTVideoNotifyList;
+extern _X_EXPORT RESTYPE XvRTPortNotify;
+
+typedef struct {
+    int numerator;
+    int denominator;
+} XvRationalRec, *XvRationalPtr;
+
+typedef struct {
+    char depth;
+    unsigned long visual;
+} XvFormatRec, *XvFormatPtr;
+
+typedef struct {
+    unsigned long id;
+    ClientPtr client;
+} XvGrabRec, *XvGrabPtr;
+
+typedef struct _XvVideoNotifyRec {
+    struct _XvVideoNotifyRec *next;
+    ClientPtr client;
+    unsigned long id;
+    unsigned long mask;
+} XvVideoNotifyRec, *XvVideoNotifyPtr;
+
+typedef struct _XvPortNotifyRec {
+    struct _XvPortNotifyRec *next;
+    ClientPtr client;
+    unsigned long id;
+} XvPortNotifyRec, *XvPortNotifyPtr;
+
+typedef struct {
+    int id;
+    ScreenPtr pScreen;
+    char *name;
+    unsigned short width, height;
+    XvRationalRec rate;
+} XvEncodingRec, *XvEncodingPtr;
+
+typedef struct _XvAttributeRec {
+    int flags;
+    int min_value;
+    int max_value;
+    char *name;
+} XvAttributeRec, *XvAttributePtr;
+
+typedef struct {
+    int id;
+    int type;
+    int byte_order;
+    char guid[16];
+    int bits_per_pixel;
+    int format;
+    int num_planes;
+
+    /* for RGB formats only */
+    int depth;
+    unsigned int red_mask;
+    unsigned int green_mask;
+    unsigned int blue_mask;
+
+    /* for YUV formats only */
+    unsigned int y_sample_bits;
+    unsigned int u_sample_bits;
+    unsigned int v_sample_bits;
+    unsigned int horz_y_period;
+    unsigned int horz_u_period;
+    unsigned int horz_v_period;
+    unsigned int vert_y_period;
+    unsigned int vert_u_period;
+    unsigned int vert_v_period;
+    char component_order[32];
+    int scanline_order;
+} XvImageRec, *XvImagePtr;
+
+typedef struct {
+    unsigned long base_id;
+    unsigned char type;
+    char *name;
+    int nEncodings;
+    XvEncodingPtr pEncodings;
+    int nFormats;
+    XvFormatPtr pFormats;
+    int nAttributes;
+    XvAttributePtr pAttributes;
+    int nImages;
+    XvImagePtr pImages;
+    int nPorts;
+    struct _XvPortRec *pPorts;
+    ScreenPtr pScreen;
+    int (*ddAllocatePort) (unsigned long, struct _XvPortRec *,
+                           struct _XvPortRec **);
+    int (*ddFreePort) (struct _XvPortRec *);
+    int (*ddPutVideo) (ClientPtr, DrawablePtr, struct _XvPortRec *, GCPtr,
+                       INT16, INT16, CARD16, CARD16,
+                       INT16, INT16, CARD16, CARD16);
+    int (*ddPutStill) (ClientPtr, DrawablePtr, struct _XvPortRec *, GCPtr,
+                       INT16, INT16, CARD16, CARD16,
+                       INT16, INT16, CARD16, CARD16);
+    int (*ddGetVideo) (ClientPtr, DrawablePtr, struct _XvPortRec *, GCPtr,
+                       INT16, INT16, CARD16, CARD16,
+                       INT16, INT16, CARD16, CARD16);
+    int (*ddGetStill) (ClientPtr, DrawablePtr, struct _XvPortRec *, GCPtr,
+                       INT16, INT16, CARD16, CARD16,
+                       INT16, INT16, CARD16, CARD16);
+    int (*ddStopVideo) (ClientPtr, struct _XvPortRec *, DrawablePtr);
+    int (*ddSetPortAttribute) (ClientPtr, struct _XvPortRec *, Atom, INT32);
+    int (*ddGetPortAttribute) (ClientPtr, struct _XvPortRec *, Atom, INT32 *);
+    int (*ddQueryBestSize) (ClientPtr, struct _XvPortRec *, CARD8,
+                            CARD16, CARD16, CARD16, CARD16,
+                            unsigned int *, unsigned int *);
+    int (*ddPutImage) (ClientPtr, DrawablePtr, struct _XvPortRec *, GCPtr,
+                       INT16, INT16, CARD16, CARD16,
+                       INT16, INT16, CARD16, CARD16,
+                       XvImagePtr, unsigned char *, Bool, CARD16, CARD16);
+    int (*ddQueryImageAttributes) (ClientPtr, struct _XvPortRec *, XvImagePtr,
+                                   CARD16 *, CARD16 *, int *, int *);
+    DevUnion devPriv;
+} XvAdaptorRec, *XvAdaptorPtr;
+
+typedef struct _XvPortRec {
+    unsigned long id;
+    XvAdaptorPtr pAdaptor;
+    XvPortNotifyPtr pNotify;
+    DrawablePtr pDraw;
+    ClientPtr client;
+    XvGrabRec grab;
+    TimeStamp time;
+    DevUnion devPriv;
+} XvPortRec, *XvPortPtr;
+
+#define VALIDATE_XV_PORT(portID, pPort, mode)\
+    {\
+	int rc = dixLookupResourceByType((void **)&(pPort), portID,\
+	                                 XvRTPort, client, mode);\
+	if (rc != Success)\
+	    return rc;\
+    }
+
+typedef struct {
+    int version, revision;
+    int nAdaptors;
+    XvAdaptorPtr pAdaptors;
+    DestroyWindowProcPtr DestroyWindow;
+    DestroyPixmapProcPtr DestroyPixmap;
+    CloseScreenProcPtr CloseScreen;
+    Bool (*ddCloseScreen) (ScreenPtr);
+    int (*ddQueryAdaptors) (ScreenPtr, XvAdaptorPtr *, int *);
+    DevUnion devPriv;
+} XvScreenRec, *XvScreenPtr;
+
+#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = ((XvScreenPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, XvScreenKey))->field)
+
+#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
+    ((pScreen)->field = wrapper)
+
+/* Errors */
+
+#define _XvBadPort (XvBadPort+XvErrorBase)
+#define _XvBadEncoding (XvBadEncoding+XvErrorBase)
+
+extern _X_EXPORT int ProcXvDispatch(ClientPtr);
+extern _X_EXPORT int SProcXvDispatch(ClientPtr);
+
+extern _X_EXPORT int XvScreenInit(ScreenPtr);
+extern _X_EXPORT DevPrivateKey XvGetScreenKey(void);
+extern _X_EXPORT unsigned long XvGetRTPort(void);
+extern _X_EXPORT int XvdiSendPortNotify(XvPortPtr, Atom, INT32);
+extern _X_EXPORT int XvdiVideoStopped(XvPortPtr, int);
+
+extern _X_EXPORT int XvdiPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+                                  INT16, INT16, CARD16, CARD16,
+                                  INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+                                  INT16, INT16, CARD16, CARD16,
+                                  INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+                                  INT16, INT16, CARD16, CARD16,
+                                  INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+                                  INT16, INT16, CARD16, CARD16,
+                                  INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+                                  INT16, INT16, CARD16, CARD16,
+                                  INT16, INT16, CARD16, CARD16,
+                                  XvImagePtr, unsigned char *, Bool,
+                                  CARD16, CARD16);
+extern _X_EXPORT int XvdiSelectVideoNotify(ClientPtr, DrawablePtr, BOOL);
+extern _X_EXPORT int XvdiSelectPortNotify(ClientPtr, XvPortPtr, BOOL);
+extern _X_EXPORT int XvdiSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
+extern _X_EXPORT int XvdiGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32 *);
+extern _X_EXPORT int XvdiStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiPreemptVideo(ClientPtr, XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiMatchPort(XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiGrabPort(ClientPtr, XvPortPtr, Time, int *);
+extern _X_EXPORT int XvdiUngrabPort(ClientPtr, XvPortPtr, Time);
+#endif                          /* XVDIX_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xvdix.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micmap.h	(Revision 52145)
@@ -0,0 +1,67 @@
+
+#include "colormapst.h"
+
+#ifndef _MICMAP_H_
+#define _MICMAP_H_
+
+#define GetInstalledmiColormap(s) \
+    ((ColormapPtr) dixLookupPrivate(&(s)->devPrivates, micmapScrPrivateKey))
+#define SetInstalledmiColormap(s,c) \
+    (dixSetPrivate(&(s)->devPrivates, micmapScrPrivateKey, c))
+
+extern _X_EXPORT DevPrivateKeyRec micmapScrPrivateKeyRec;
+
+#define micmapScrPrivateKey (&micmapScrPrivateKeyRec)
+
+typedef Bool (*miInitVisualsProcPtr) (VisualPtr *, DepthPtr *, int *, int *,
+                                      int *, VisualID *, unsigned long, int,
+                                      int);
+
+extern _X_EXPORT int miListInstalledColormaps(ScreenPtr pScreen,
+                                              Colormap * pmaps);
+extern _X_EXPORT void miInstallColormap(ColormapPtr pmap);
+extern _X_EXPORT void miUninstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void miResolveColor(unsigned short *, unsigned short *,
+                                     unsigned short *, VisualPtr);
+extern _X_EXPORT Bool miInitializeColormap(ColormapPtr);
+extern _X_EXPORT int miExpandDirectColors(ColormapPtr, int, xColorItem *,
+                                          xColorItem *);
+extern _X_EXPORT Bool miCreateDefColormap(ScreenPtr);
+extern _X_EXPORT void miClearVisualTypes(void);
+extern _X_EXPORT Bool miSetVisualTypes(int, int, int, int);
+extern _X_EXPORT Bool miSetPixmapDepths(void);
+extern _X_EXPORT Bool miSetVisualTypesAndMasks(int depth, int visuals,
+                                               int bitsPerRGB, int preferredCVC,
+                                               Pixel redMask, Pixel greenMask,
+                                               Pixel blueMask);
+extern _X_EXPORT int miGetDefaultVisualMask(int);
+extern _X_EXPORT Bool miInitVisuals(VisualPtr *, DepthPtr *, int *, int *,
+                                    int *, VisualID *, unsigned long, int, int);
+
+#define MAX_PSEUDO_DEPTH	10
+#define MIN_TRUE_DEPTH		6
+
+#define StaticGrayMask	(1 << StaticGray)
+#define GrayScaleMask	(1 << GrayScale)
+#define StaticColorMask	(1 << StaticColor)
+#define PseudoColorMask	(1 << PseudoColor)
+#define TrueColorMask	(1 << TrueColor)
+#define DirectColorMask	(1 << DirectColor)
+
+#define ALL_VISUALS	(StaticGrayMask|\
+			 GrayScaleMask|\
+			 StaticColorMask|\
+			 PseudoColorMask|\
+			 TrueColorMask|\
+			 DirectColorMask)
+
+#define LARGE_VISUALS	(TrueColorMask|\
+			 DirectColorMask)
+
+#define SMALL_VISUALS	(StaticGrayMask|\
+			 GrayScaleMask|\
+			 StaticColorMask|\
+			 PseudoColorMask)
+
+#endif                          /* _MICMAP_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/micmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86DDC.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86DDC.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86DDC.h	(Revision 52145)
@@ -0,0 +1,103 @@
+
+/* xf86DDC.h
+ *
+ * This file contains all information to interpret a standard EDIC block 
+ * transmitted by a display device via DDC (Display Data Channel). So far 
+ * there is no information to deal with optional EDID blocks.  
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ */
+
+#ifndef XF86_DDC_H
+#define XF86_DDC_H
+
+#include "edid.h"
+#include "xf86i2c.h"
+#include "xf86str.h"
+
+/* speed up / slow down */
+typedef enum {
+    DDC_SLOW,
+    DDC_FAST
+} xf86ddcSpeed;
+
+typedef void (*DDC1SetSpeedProc) (ScrnInfoPtr, xf86ddcSpeed);
+
+extern _X_EXPORT xf86MonPtr xf86DoEDID_DDC1(ScrnInfoPtr pScrn,
+                                            DDC1SetSpeedProc DDC1SetSpeed,
+                                            unsigned
+                                            int (*DDC1Read) (ScrnInfoPtr)
+    );
+
+extern _X_EXPORT xf86MonPtr xf86DoEDID_DDC2(ScrnInfoPtr pScrn, I2CBusPtr pBus);
+
+extern _X_EXPORT xf86MonPtr xf86DoEEDID(ScrnInfoPtr pScrn, I2CBusPtr pBus, Bool);
+
+extern _X_EXPORT xf86MonPtr xf86PrintEDID(xf86MonPtr monPtr);
+
+extern _X_EXPORT xf86MonPtr xf86InterpretEDID(int screenIndex, Uchar * block);
+
+extern _X_EXPORT xf86MonPtr xf86InterpretEEDID(int screenIndex, Uchar * block);
+
+extern _X_EXPORT void
+ xf86EdidMonitorSet(int scrnIndex, MonPtr Monitor, xf86MonPtr DDC);
+
+extern _X_EXPORT Bool xf86SetDDCproperties(ScrnInfoPtr pScreen, xf86MonPtr DDC);
+
+extern _X_EXPORT Bool
+ xf86MonitorIsHDMI(xf86MonPtr mon);
+
+extern _X_EXPORT xf86MonPtr xf86DoDisplayID(ScrnInfoPtr pScrn, I2CBusPtr pBus);
+
+extern _X_EXPORT void
+ xf86DisplayIDMonitorSet(int scrnIndex, MonPtr mon, xf86MonPtr DDC);
+
+extern _X_EXPORT DisplayModePtr
+FindDMTMode(int hsize, int vsize, int refresh, Bool rb);
+
+extern _X_EXPORT const DisplayModeRec DMTModes[];
+
+/*
+ * Quirks to work around broken EDID data from various monitors.
+ */
+typedef enum {
+    DDC_QUIRK_NONE = 0,
+    /* First detailed mode is bogus, prefer largest mode at 60hz */
+    DDC_QUIRK_PREFER_LARGE_60 = 1 << 0,
+    /* 135MHz clock is too high, drop a bit */
+    DDC_QUIRK_135_CLOCK_TOO_HIGH = 1 << 1,
+    /* Prefer the largest mode at 75 Hz */
+    DDC_QUIRK_PREFER_LARGE_75 = 1 << 2,
+    /* Convert detailed timing's horizontal from units of cm to mm */
+    DDC_QUIRK_DETAILED_H_IN_CM = 1 << 3,
+    /* Convert detailed timing's vertical from units of cm to mm */
+    DDC_QUIRK_DETAILED_V_IN_CM = 1 << 4,
+    /* Detailed timing descriptors have bogus size values, so just take the
+     * maximum size and use that.
+     */
+    DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE = 1 << 5,
+    /* Monitor forgot to set the first detailed is preferred bit. */
+    DDC_QUIRK_FIRST_DETAILED_PREFERRED = 1 << 6,
+    /* use +hsync +vsync for detailed mode */
+    DDC_QUIRK_DETAILED_SYNC_PP = 1 << 7,
+    /* Force single-link DVI bandwidth limit */
+    DDC_QUIRK_DVI_SINGLE_LINK = 1 << 8,
+} ddc_quirk_t;
+
+typedef void (*handle_detailed_fn) (struct detailed_monitor_section *, void *);
+
+void xf86ForEachDetailedBlock(xf86MonPtr mon, handle_detailed_fn, void *data);
+
+ddc_quirk_t xf86DDCDetectQuirks(int scrnIndex, xf86MonPtr DDC, Bool verbose);
+
+void xf86DetTimingApplyQuirks(struct detailed_monitor_section *det_mon,
+                              ddc_quirk_t quirks, int hsize, int vsize);
+
+typedef void (*handle_video_fn) (struct cea_video_block *, void *);
+
+void xf86ForEachVideoBlock(xf86MonPtr, handle_video_fn, void *);
+
+struct cea_data_block *xf86MonitorFindHDMIBlock(xf86MonPtr mon);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86DDC.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBM.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBM.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBM.h	(Revision 52145)
@@ -0,0 +1,418 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT RamDacHelperRecPtr IBMramdacProbe(ScrnInfoPtr pScrn,
+                                                   RamDacSupportedInfoRecPtr
+                                                   ramdacs);
+extern _X_EXPORT void IBMramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec,
+                                    RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdacRestore(ScrnInfoPtr pScrn,
+                                       RamDacRecPtr RamDacRec,
+                                       RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac526SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac640SetBpp(ScrnInfoPtr pScrn,
+                                         RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT unsigned long IBMramdac526CalculateMNPCForClock(unsigned long
+                                                                 RefClock,
+                                                                 unsigned long
+                                                                 ReqClock,
+                                                                 char
+                                                                 IsPixClock,
+                                                                 unsigned long
+                                                                 MinClock,
+                                                                 unsigned long
+                                                                 MaxClock,
+                                                                 unsigned long
+                                                                 *rM,
+                                                                 unsigned long
+                                                                 *rN,
+                                                                 unsigned long
+                                                                 *rP,
+                                                                 unsigned long
+                                                                 *rC);
+extern _X_EXPORT unsigned long IBMramdac640CalculateMNPCForClock(unsigned long
+                                                                 RefClock,
+                                                                 unsigned long
+                                                                 ReqClock,
+                                                                 char
+                                                                 IsPixClock,
+                                                                 unsigned long
+                                                                 MinClock,
+                                                                 unsigned long
+                                                                 MaxClock,
+                                                                 unsigned long
+                                                                 *rM,
+                                                                 unsigned long
+                                                                 *rN,
+                                                                 unsigned long
+                                                                 *rP,
+                                                                 unsigned long
+                                                                 *rC);
+extern _X_EXPORT void IBMramdac526HWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void IBMramdac640HWCursorInit(xf86CursorInfoPtr infoPtr);
+
+typedef void IBMramdac526SetBppProc(ScrnInfoPtr, RamDacRegRecPtr);
+extern _X_EXPORT IBMramdac526SetBppProc *IBMramdac526SetBppWeak(void);
+
+#define IBM524_RAMDAC		((VENDOR_IBM << 16) | 0x00)
+#define IBM524A_RAMDAC		((VENDOR_IBM << 16) | 0x01)
+#define IBM525_RAMDAC		((VENDOR_IBM << 16) | 0x02)
+#define IBM526_RAMDAC		((VENDOR_IBM << 16) | 0x03)
+#define IBM526DB_RAMDAC		((VENDOR_IBM << 16) | 0x04)
+#define IBM528_RAMDAC		((VENDOR_IBM << 16) | 0x05)
+#define IBM528A_RAMDAC		((VENDOR_IBM << 16) | 0x06)
+#define IBM624_RAMDAC		((VENDOR_IBM << 16) | 0x07)
+#define IBM624DB_RAMDAC		((VENDOR_IBM << 16) | 0x08)
+#define IBM640_RAMDAC		((VENDOR_IBM << 16) | 0x09)
+
+/*
+ * IBM Ramdac registers
+ */
+
+#define IBMRGB_REF_FREQ_1       14.31818
+#define IBMRGB_REF_FREQ_2       50.00000
+
+#define IBMRGB_rev		0x00
+#define IBMRGB_id		0x01
+#define IBMRGB_misc_clock	0x02
+#define IBMRGB_sync		0x03
+#define IBMRGB_hsync_pos	0x04
+#define IBMRGB_pwr_mgmt		0x05
+#define IBMRGB_dac_op		0x06
+#define IBMRGB_pal_ctrl		0x07
+#define IBMRGB_sysclk		0x08    /* not RGB525 */
+#define IBMRGB_pix_fmt		0x0a
+#define IBMRGB_8bpp		0x0b
+#define IBMRGB_16bpp		0x0c
+#define IBMRGB_24bpp		0x0d
+#define IBMRGB_32bpp		0x0e
+#define IBMRGB_pll_ctrl1	0x10
+#define IBMRGB_pll_ctrl2	0x11
+#define IBMRGB_pll_ref_div_fix	0x14
+#define IBMRGB_sysclk_ref_div	0x15    /* not RGB525 */
+#define IBMRGB_sysclk_vco_div	0x16    /* not RGB525 */
+/* #define IBMRGB_f0		0x20 */
+
+#define IBMRGB_sysclk_n		0x15
+#define IBMRGB_sysclk_m		0x16
+#define IBMRGB_sysclk_p		0x17
+#define IBMRGB_sysclk_c		0x18
+
+#define IBMRGB_m0		0x20
+#define IBMRGB_n0		0x21
+#define IBMRGB_p0		0x22
+#define IBMRGB_c0		0x23
+#define IBMRGB_m1		0x24
+#define IBMRGB_n1		0x25
+#define IBMRGB_p1		0x26
+#define IBMRGB_c1		0x27
+#define IBMRGB_m2		0x28
+#define IBMRGB_n2		0x29
+#define IBMRGB_p2		0x2a
+#define IBMRGB_c2		0x2b
+#define IBMRGB_m3		0x2c
+#define IBMRGB_n3		0x2d
+#define IBMRGB_p3		0x2e
+#define IBMRGB_c3		0x2f
+
+#define IBMRGB_curs		0x30
+#define IBMRGB_curs_xl		0x31
+#define IBMRGB_curs_xh		0x32
+#define IBMRGB_curs_yl		0x33
+#define IBMRGB_curs_yh		0x34
+#define IBMRGB_curs_hot_x	0x35
+#define IBMRGB_curs_hot_y	0x36
+#define IBMRGB_curs_col1_r	0x40
+#define IBMRGB_curs_col1_g	0x41
+#define IBMRGB_curs_col1_b	0x42
+#define IBMRGB_curs_col2_r	0x43
+#define IBMRGB_curs_col2_g	0x44
+#define IBMRGB_curs_col2_b	0x45
+#define IBMRGB_curs_col3_r	0x46
+#define IBMRGB_curs_col3_g	0x47
+#define IBMRGB_curs_col3_b	0x48
+#define IBMRGB_border_col_r	0x60
+#define IBMRGB_border_col_g	0x61
+#define IBMRGB_botder_col_b	0x62
+#define IBMRGB_key		0x68
+#define IBMRGB_key_mask		0x6C
+#define IBMRGB_misc1		0x70
+#define IBMRGB_misc2		0x71
+#define IBMRGB_misc3		0x72
+#define IBMRGB_misc4		0x73    /* not RGB525 */
+#define IBMRGB_key_control	0x78
+#define IBMRGB_dac_sense	0x82
+#define IBMRGB_misr_r		0x84
+#define IBMRGB_misr_g		0x86
+#define IBMRGB_misr_b		0x88
+#define IBMRGB_pll_vco_div_in	0x8e
+#define IBMRGB_pll_ref_div_in	0x8f
+#define IBMRGB_vram_mask_0	0x90
+#define IBMRGB_vram_mask_1	0x91
+#define IBMRGB_vram_mask_2	0x92
+#define IBMRGB_vram_mask_3	0x93
+#define IBMRGB_curs_array	0x100
+
+/* Constants rgb525.h */
+
+/* RGB525_REVISION_LEVEL */
+#define RGB525_PRODUCT_REV_LEVEL        0xf0
+
+/* RGB525_ID */
+#define RGB525_PRODUCT_ID               0x01
+
+/* RGB525_MISC_CTRL_1 */
+#define MISR_CNTL_ENABLE                0x80
+#define VMSK_CNTL_ENABLE                0x40
+#define PADR_RDMT_RDADDR                0x0
+#define PADR_RDMT_PAL_STATE             0x20
+#define SENS_DSAB_DISABLE               0x10
+#define SENS_SEL_BIT3                   0x0
+#define SENS_SEL_BIT7                   0x08
+#define VRAM_SIZE_32                    0x0
+#define VRAM_SIZE_64                    0x01
+
+/* RGB525_MISC_CTRL_2 */
+#define PCLK_SEL_LCLK                   0x0
+#define PCLK_SEL_PLL                    0x40
+#define PCLK_SEL_EXT                    0x80
+#define INTL_MODE_ENABLE                0x20
+#define BLANK_CNTL_ENABLE               0x10
+#define COL_RES_6BIT                    0x0
+#define COL_RES_8BIT                    0x04
+#define PORT_SEL_VGA                    0x0
+#define PORT_SEL_VRAM                   0x01
+
+/* RGB525_MISC_CTRL_3 */
+#define SWAP_RB                         0x80
+#define SWAP_WORD_LOHI                  0x0
+#define SWAP_WORD_HILO                  0x10
+#define SWAP_NIB_HILO                   0x0
+#define SWAP_NIB_LOHI                   0x02
+
+/* RGB525_MISC_CLK_CTRL */
+#define DDOT_CLK_ENABLE                 0x0
+#define DDOT_CLK_DISABLE                0x80
+#define SCLK_ENABLE                     0x0
+#define SCLK_DISABLE                    0x40
+#define B24P_DDOT_PLL                   0x0
+#define B24P_DDOT_SCLK                  0x20
+#define DDOT_DIV_PLL_1                  0x0
+#define DDOT_DIV_PLL_2                  0x02
+#define DDOT_DIV_PLL_4                  0x04
+#define DDOT_DIV_PLL_8                  0x06
+#define DDOT_DIV_PLL_16                 0x08
+#define PLL_DISABLE                     0x0
+#define PLL_ENABLE                      0x01
+
+/* RGB525_SYNC_CTRL */
+#define DLY_CNTL_ADD                    0x0
+#define DLY_SYNC_NOADD                  0x80
+#define CSYN_INVT_DISABLE               0x0
+#define CSYN_INVT_ENABLE                0x40
+#define VSYN_INVT_DISABLE               0x0
+#define VSYN_INVT_ENABLE                0x20
+#define HSYN_INVT_DISABLE               0x0
+#define HSYN_INVT_ENABLE                0x10
+#define VSYN_CNTL_NORMAL                0x0
+#define VSYN_CNTL_HIGH                  0x04
+#define VSYN_CNTL_LOW                   0x08
+#define VSYN_CNTL_DISABLE               0x0C
+#define HSYN_CNTL_NORMAL                0x0
+#define HSYN_CNTL_HIGH                  0x01
+#define HSYN_CNTL_LOW                   0x02
+#define HSYN_CNTL_DISABLE               0x03
+
+/* RGB525_HSYNC_CTRL */
+#define HSYN_POS(n)                     (n)
+
+/* RGB525_POWER_MANAGEMENT */
+#define SCLK_PWR_NORMAL                 0x0
+#define SCLK_PWR_DISABLE                0x10
+#define DDOT_PWR_NORMAL                 0x0
+#define DDOT_PWR_DISABLE                0x08
+#define SYNC_PWR_NORMAL                 0x0
+#define SYNC_PWR_DISABLE                0x04
+#define ICLK_PWR_NORMAL                 0x0
+#define ICLK_PWR_DISABLE                0x02
+#define DAC_PWR_NORMAL                  0x0
+#define DAC_PWR_DISABLE                 0x01
+
+/* RGB525_DAC_OPERATION */
+#define SOG_DISABLE                     0x0
+#define SOG_ENABLE                      0x08
+#define BRB_NORMAL                      0x0
+#define BRB_ALWAYS                      0x04
+#define DSR_DAC_SLOW                    0x02
+#define DSR_DAC_FAST                    0x0
+#define DPE_DISABLE                     0x0
+#define DPE_ENABLE                      0x01
+
+/* RGB525_PALETTE_CTRL */
+#define SIXBIT_LINEAR_ENABLE            0x0
+#define SIXBIT_LINEAR_DISABLE           0x80
+#define PALETTE_PARITION(n)             (n)
+
+/* RGB525_PIXEL_FORMAT */
+#define PIXEL_FORMAT_4BPP               0x02
+#define PIXEL_FORMAT_8BPP               0x03
+#define PIXEL_FORMAT_16BPP              0x04
+#define PIXEL_FORMAT_24BPP              0x05
+#define PIXEL_FORMAT_32BPP              0x06
+
+/* RGB525_8BPP_CTRL */
+#define B8_DCOL_INDIRECT                0x0
+#define B8_DCOL_DIRECT                  0x01
+
+/* RGB525_16BPP_CTRL */
+#define B16_DCOL_INDIRECT               0x0
+#define B16_DCOL_DYNAMIC                0x40
+#define B16_DCOL_DIRECT                 0xC0
+#define B16_POL_FORCE_BYPASS            0x0
+#define B16_POL_FORCE_LOOKUP            0x20
+#define B16_ZIB                         0x0
+#define B16_LINEAR                      0x04
+#define B16_555                         0x0
+#define B16_565                         0x02
+#define B16_SPARSE                      0x0
+#define B16_CONTIGUOUS                  0x01
+
+/* RGB525_24BPP_CTRL */
+#define B24_DCOL_INDIRECT               0x0
+#define B24_DCOL_DIRECT                 0x01
+
+/* RGB525_32BPP_CTRL */
+#define B32_POL_FORCE_BYPASS            0x0
+#define B32_POL_FORCE_LOOKUP            0x04
+#define B32_DCOL_INDIRECT               0x0
+#define B32_DCOL_DYNAMIC                0x01
+#define B32_DCOL_DIRECT                 0x03
+
+/* RGB525_PLL_CTRL_1 */
+#define REF_SRC_REFCLK                  0x0
+#define REF_SRC_EXTCLK                  0x10
+#define PLL_EXT_FS_3_0                  0x0
+#define PLL_EXT_FS_2_0                  0x01
+#define PLL_CNTL2_3_0                   0x02
+#define PLL_CNTL2_2_0                   0x03
+
+/* RGB525_PLL_CTRL_2 */
+#define PLL_INT_FS_3_0(n)               (n)
+#define PLL_INT_FS_2_0(n)               (n)
+
+/* RGB525_PLL_REF_DIV_COUNT */
+#define REF_DIV_COUNT(n)                (n)
+
+/* RGB525_F0 - RGB525_F15 */
+#define VCO_DIV_COUNT(n)                (n)
+
+/* RGB525_PLL_REFCLK values */
+#define RGB525_PLL_REFCLK_MHz(n)        ((n)/2)
+
+/* RGB525_CURSOR_CONTROL */
+#define SMLC_PART_0                     0x0
+#define SMLC_PART_1                     0x40
+#define SMLC_PART_2                     0x80
+#define SMLC_PART_3                     0xC0
+#define PIX_ORDER_RL                    0x0
+#define PIX_ORDER_LR                    0x20
+#define LOC_READ_LAST                   0x0
+#define LOC_READ_ACTUAL                 0x10
+#define UPDT_CNTL_DELAYED               0x0
+#define UPDT_CNTL_IMMEDIATE             0x08
+#define CURSOR_SIZE_32                  0x0
+#define CURSOR_SIZE_64                  0x40
+#define CURSOR_MODE_OFF                 0x0
+#define CURSOR_MODE_3_COLOR             0x01
+#define CURSOR_MODE_2_COLOR_HL          0x02
+#define CURSOR_MODE_2_COLOR             0x03
+
+/* RGB525_REVISION_LEVEL */
+#define REVISION_LEVEL                  0xF0    /* predefined */
+
+/* RGB525_ID */
+#define ID_CODE                         0x01    /* predefined */
+
+/* MISR status */
+#define RGB525_MISR_DONE                0x01
+
+/* the IBMRGB640 is rather different from the rest of the RAMDACs,
+   so we define a completely new set of register names for it */
+#define RGB640_SER_07_00		0x02
+#define RGB640_SER_15_08		0x03
+#define RGB640_SER_23_16		0x04
+#define RGB640_SER_31_24		0x05
+#define RGB640_SER_WID_03_00		0x06
+#define RGB640_SER_WID_07_04		0x07
+#define RGB640_SER_MODE			0x08
+#define		IBM640_SER_2_1	0x00
+#define		IBM640_SER_4_1	0x01
+#define		IBM640_SER_8_1	0x02
+#define		IBM640_SER_16_1	0x03
+#define		IBM640_SER_16_3	0x05
+#define		IBM640_SER_5_1	0x06
+#define RGB640_PIXEL_INTERLEAVE		0x09
+#define RGB640_MISC_CONF		0x0a
+#define		IBM640_PCLK		0x00
+#define		IBM640_PCLK_2		0x40
+#define		IBM640_PCLK_4		0x80
+#define		IBM640_PCLK_8		0xc0
+#define		IBM640_PSIZE10		0x10
+#define		IBM640_LCI		0x08
+#define		IBM640_WIDCTL_MASK	0x07
+#define RGB640_VGA_CONTROL		0x0b
+#define 	IBM640_RDBK	0x04
+#define 	IBM640_PSIZE8	0x02
+#define		IBM640_VRAM	0x01
+#define RGB640_DAC_CONTROL		0x0d
+#define		IBM640_MONO	0x08
+#define		IBM640_DACENBL	0x04
+#define		IBM640_SHUNT	0x02
+#define		IBM640_SLOWSLEW	0x01
+#define RGB640_OUTPUT_CONTROL		0x0e
+#define		IBM640_RDAI	0x04
+#define		IBM640_WDAI	0x02
+#define		IBM640_WATCTL	0x01
+#define RGB640_SYNC_CONTROL		0x0f
+#define		IBM640_PWR	0x20
+#define		IBM640_VSP	0x10
+#define		IBM640_HSP	0x08
+#define		IBM640_CSE	0x04
+#define		IBM640_CSG	0x02
+#define		IBM640_BPE	0x01
+#define RGB640_PLL_N			0x10
+#define RGB640_PLL_M			0x11
+#define RGB640_PLL_P			0x12
+#define RGB640_PLL_CTL			0x13
+#define 	IBM640_PLL_EN	0x04
+#define		IBM640_PLL_HIGH	0x10
+#define		IBM640_PLL_LOW	0x01
+#define RGB640_AUX_PLL_CTL		0x17
+#define		IBM640_AUXPLL	0x04
+#define		IBM640_AUX_HI	0x02
+#define		IBM640_AUX_LO	0x01
+#define RGB640_CHROMA_KEY0		0x20
+#define RGB640_CHROMA_MASK0		0x21
+#define RGB640_CURS_X_LOW		0x40
+#define RGB640_CURS_X_HIGH		0x41
+#define RGB640_CURS_Y_LOW		0x42
+#define RGB640_CURS_Y_HIGH		0x43
+#define RGB640_CURS_OFFSETX		0x44
+#define RGB640_CURS_OFFSETY		0x45
+#define RGB640_CURSOR_CONTROL		0x4B
+#define		IBM640_CURS_OFF		0x00
+#define		IBM640_CURS_MODE0	0x01
+#define		IBM640_CURS_MODE1	0x02
+#define		IBM640_CURS_MODE2	0x03
+#define		IBM640_CURS_ADV		0x04
+#define RGB640_CROSSHAIR_CONTROL	0x57
+#define RGB640_VRAM_MASK0		0xf0
+#define RGB640_VRAM_MASK1		0xf1
+#define RGB640_VRAM_MASK2		0xf2
+#define RGB640_DIAGS			0xfa
+#define RGB640_CURS_WRITE		0x1000
+#define RGB640_CURS_COL0		0x4800
+#define RGB640_CURS_COL1		0x4801
+#define RGB640_CURS_COL2		0x4802
+#define RGB640_CURS_COL3		0x4803

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/IBM.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rgb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rgb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rgb.h	(Revision 52145)
@@ -0,0 +1,52 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef RGB_H
+#define RGB_H
+typedef struct _RGB {
+    unsigned short red, green, blue;
+} RGB;
+#endif                          /* RGB_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/rgb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxbyteorder.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxbyteorder.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxbyteorder.h	(Revision 52145)
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright IBM Corporation 2006, 2007
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, THE AUTHORS, AND/OR THEIR SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file glxbyteorder.h
+ * Platform glue for handling byte-ordering issues in GLX protocol.
+ * 
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+#if !defined(__GLXBYTEORDER_H__)
+#define __GLXBYTEORDER_H__
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#if HAVE_BYTESWAP_H
+#include <byteswap.h>
+#elif defined(USE_SYS_ENDIAN_H)
+#include <sys/endian.h>
+#elif defined(__APPLE__)
+#include <libkern/OSByteOrder.h>
+#define bswap_16 OSSwapInt16
+#define bswap_32 OSSwapInt32
+#define bswap_64 OSSwapInt64
+#else
+#define	bswap_16(value)  \
+ 	((((value) & 0xff) << 8) | ((value) >> 8))
+
+#define	bswap_32(value)	\
+ 	(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
+ 	(uint32_t)bswap_16((uint16_t)((value) >> 16)))
+
+#define	bswap_64(value)	\
+ 	(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
+ 	    << 32) | \
+ 	(uint64_t)bswap_32((uint32_t)((value) >> 32)))
+#endif
+
+#endif                          /* !defined(__GLXBYTEORDER_H__) */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxbyteorder.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinit.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinit.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinit.h	(Revision 52145)
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for initialization.  \see dmxinit.c */
+
+#ifndef DMXINIT_H
+#define DMXINIT_H
+
+#include "scrnintstr.h"
+
+extern Bool dmxOpenDisplay(DMXScreenInfo * dmxScreen);
+extern void dmxSetErrorHandler(DMXScreenInfo * dmxScreen);
+extern void dmxCheckForWM(DMXScreenInfo * dmxScreen);
+extern void dmxGetScreenAttribs(DMXScreenInfo * dmxScreen);
+extern Bool dmxGetVisualInfo(DMXScreenInfo * dmxScreen);
+extern void dmxGetColormaps(DMXScreenInfo * dmxScreen);
+extern void dmxGetPixmapFormats(DMXScreenInfo * dmxScreen);
+
+#endif                          /* DMXINIT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinit.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getbmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getbmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getbmap.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETBMAP_H
+#define GETBMAP_H 1
+
+int SProcXGetDeviceButtonMapping(ClientPtr      /* client */
+    );
+
+int ProcXGetDeviceButtonMapping(ClientPtr       /* client */
+    );
+
+void SRepXGetDeviceButtonMapping(ClientPtr /* client */ ,
+                                 int /* size */ ,
+                                 xGetDeviceButtonMappingReply * /* rep */
+    );
+
+#endif                          /* GETBMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/getbmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinux.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinux.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinux.h	(Revision 52145)
@@ -0,0 +1,139 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XSELINUX_H
+#define _XSELINUX_H
+
+/* Extension info */
+#define SELINUX_EXTENSION_NAME		"SELinux"
+#define SELINUX_MAJOR_VERSION		1
+#define SELINUX_MINOR_VERSION		1
+#define SELinuxNumberEvents		0
+#define SELinuxNumberErrors		0
+
+/* Extension protocol */
+#define X_SELinuxQueryVersion			0
+#define X_SELinuxSetDeviceCreateContext		1
+#define X_SELinuxGetDeviceCreateContext		2
+#define X_SELinuxSetDeviceContext		3
+#define X_SELinuxGetDeviceContext		4
+#define X_SELinuxSetDrawableCreateContext	5
+#define X_SELinuxGetDrawableCreateContext	6
+#define X_SELinuxGetDrawableContext		7
+#define X_SELinuxSetPropertyCreateContext	8
+#define X_SELinuxGetPropertyCreateContext	9
+#define X_SELinuxSetPropertyUseContext		10
+#define X_SELinuxGetPropertyUseContext		11
+#define X_SELinuxGetPropertyContext		12
+#define X_SELinuxGetPropertyDataContext		13
+#define X_SELinuxListProperties			14
+#define X_SELinuxSetSelectionCreateContext	15
+#define X_SELinuxGetSelectionCreateContext	16
+#define X_SELinuxSetSelectionUseContext		17
+#define X_SELinuxGetSelectionUseContext		18
+#define X_SELinuxGetSelectionContext		19
+#define X_SELinuxGetSelectionDataContext	20
+#define X_SELinuxListSelections			21
+#define X_SELinuxGetClientContext		22
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+    CARD8 client_major;
+    CARD8 client_minor;
+} SELinuxQueryVersionReq;
+
+typedef struct {
+    CARD8 type;
+    CARD8 pad1;
+    CARD16 sequenceNumber;
+    CARD32 length;
+    CARD16 server_major;
+    CARD16 server_minor;
+    CARD32 pad2;
+    CARD32 pad3;
+    CARD32 pad4;
+    CARD32 pad5;
+    CARD32 pad6;
+} SELinuxQueryVersionReply;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+    CARD32 context_len;
+} SELinuxSetCreateContextReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+} SELinuxGetCreateContextReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+    CARD32 id;
+    CARD32 context_len;
+} SELinuxSetContextReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+    CARD32 id;
+} SELinuxGetContextReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 SELinuxReqType;
+    CARD16 length;
+    CARD32 window;
+    CARD32 property;
+} SELinuxGetPropertyContextReq;
+
+typedef struct {
+    CARD8 type;
+    CARD8 pad1;
+    CARD16 sequenceNumber;
+    CARD32 length;
+    CARD32 context_len;
+    CARD32 pad2;
+    CARD32 pad3;
+    CARD32 pad4;
+    CARD32 pad5;
+    CARD32 pad6;
+} SELinuxGetContextReply;
+
+typedef struct {
+    CARD8 type;
+    CARD8 pad1;
+    CARD16 sequenceNumber;
+    CARD32 length;
+    CARD32 count;
+    CARD32 pad2;
+    CARD32 pad3;
+    CARD32 pad4;
+    CARD32 pad5;
+    CARD32 pad6;
+} SELinuxListItemsReply;
+
+#endif                          /* _XSELINUX_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinux.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/midbe.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/midbe.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/midbe.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/******************************************************************************
+ * Copyright (c) 1994, 1995  Hewlett-Packard Company
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Hewlett-Packard
+ * Company shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Hewlett-Packard Company.
+ * 
+ *     Header file for users of machine-independent DBE code
+ *
+ *****************************************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef MIDBE_H
+#define MIDBE_H
+
+#include "privates.h"
+
+/* EXTERNS */
+
+extern Bool miDbeInit(ScreenPtr pScreen, DbeScreenPrivPtr pDbeScreenPriv);
+
+extern DevPrivateKeyRec dbeScreenPrivKeyRec;
+
+#define dbeScreenPrivKey (&dbeScreenPrivKeyRec)
+
+extern DevPrivateKeyRec dbeWindowPrivKeyRec;
+
+#define dbeWindowPrivKey (&dbeWindowPrivKeyRec)
+
+extern RESTYPE dbeDrawableResType;
+extern RESTYPE dbeWindowPrivResType;
+
+#endif                          /* MIDBE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/midbe.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Configint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Configint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Configint.h	(Revision 52145)
@@ -0,0 +1,212 @@
+/*
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* 
+ * These definitions are used through out the configuration file parser, but
+ * they should not be visible outside of the parser.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _Configint_h_
+#define _Configint_h_
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include "xf86Parser.h"
+
+typedef enum { PARSE_DECIMAL, PARSE_OCTAL, PARSE_HEX } ParserNumType;
+
+typedef struct {
+    int num;                    /* returned number */
+    char *str;                  /* private copy of the return-string */
+    double realnum;             /* returned number as a real */
+    ParserNumType numType;      /* used to enforce correct number formatting */
+} LexRec, *LexPtr;
+
+extern LexRec xf86_lex_val;
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#include "configProcs.h"
+#include <stdlib.h>
+
+#define TestFree(a) if (a) { free ((void *) a); a = NULL; }
+
+#define parsePrologue(typeptr,typerec) typeptr ptr; \
+if( (ptr=calloc(1,sizeof(typerec))) == NULL ) { return NULL; }
+
+#define HANDLE_RETURN(f,func)\
+if ((ptr->f=func) == NULL)\
+{\
+	CLEANUP (ptr);\
+	return NULL;\
+}
+
+#define HANDLE_LIST(field,func,type)\
+{\
+type p = func ();\
+if (p == NULL)\
+{\
+	CLEANUP (ptr);\
+	return NULL;\
+}\
+else\
+{\
+	ptr->field = (type) xf86addListItem ((glp) ptr->field, (glp) p);\
+}\
+}
+
+#define Error(...) do { \
+		xf86parseError (__VA_ARGS__); CLEANUP (ptr); return NULL; \
+		   } while (0)
+
+/* 
+ * These are defines for error messages to promote consistency.
+ * error messages are preceded by the line number, section and file name,
+ * so these messages should be about the specific keyword and syntax in error.
+ * To help limit namespace polution, end each with _MSG.
+ * limit messages to 70 characters if possible.
+ */
+
+#define BAD_OPTION_MSG \
+"The Option keyword requires 1 or 2 quoted strings to follow it."
+#define INVALID_KEYWORD_MSG \
+"\"%s\" is not a valid keyword in this section."
+#define INVALID_SECTION_MSG \
+"\"%s\" is not a valid section name."
+#define UNEXPECTED_EOF_MSG \
+"Unexpected EOF. Missing EndSection keyword?"
+#define QUOTE_MSG \
+"The %s keyword requires a quoted string to follow it."
+#define NUMBER_MSG \
+"The %s keyword requires a number to follow it."
+#define POSITIVE_INT_MSG \
+"The %s keyword requires a positive integer to follow it."
+#define BOOL_MSG \
+"The %s keyword requires a boolean to follow it."
+#define ZAXISMAPPING_MSG \
+"The ZAxisMapping keyword requires 2 positive numbers or X or Y to follow it."
+#define DACSPEED_MSG \
+"The DacSpeed keyword must be followed by a list of up to %d numbers."
+#define DISPLAYSIZE_MSG \
+"The DisplaySize keyword must be followed by the width and height in mm."
+#define HORIZSYNC_MSG \
+"The HorizSync keyword must be followed by a list of numbers or ranges."
+#define VERTREFRESH_MSG \
+"The VertRefresh keyword must be followed by a list of numbers or ranges."
+#define VIEWPORT_MSG \
+"The Viewport keyword must be followed by an X and Y value."
+#define VIRTUAL_MSG \
+"The Virtual keyword must be followed by a width and height value."
+#define WEIGHT_MSG \
+"The Weight keyword must be followed by red, green and blue values."
+#define BLACK_MSG \
+"The Black keyword must be followed by red, green and blue values."
+#define WHITE_MSG \
+"The White keyword must be followed by red, green and blue values."
+#define SCREEN_MSG \
+"The Screen keyword must be followed by an optional number, a screen name\n" \
+"\tin quotes, and optional position/layout information."
+#define INVALID_SCR_MSG \
+"Invalid Screen line."
+#define INPUTDEV_MSG \
+"The InputDevice keyword must be followed by an input device name in quotes."
+#define INACTIVE_MSG \
+"The Inactive keyword must be followed by a Device name in quotes."
+#define UNDEFINED_SCREEN_MSG \
+"Undefined Screen \"%s\" referenced by ServerLayout \"%s\"."
+#define UNDEFINED_MODES_MSG \
+"Undefined Modes Section \"%s\" referenced by Monitor \"%s\"."
+#define UNDEFINED_DEVICE_MSG \
+"Undefined Device \"%s\" referenced by Screen \"%s\"."
+#define UNDEFINED_ADAPTOR_MSG \
+"Undefined VideoAdaptor \"%s\" referenced by Screen \"%s\"."
+#define ADAPTOR_REF_TWICE_MSG \
+"VideoAdaptor \"%s\" already referenced by Screen \"%s\"."
+#define UNDEFINED_DEVICE_LAY_MSG \
+"Undefined Device \"%s\" referenced by ServerLayout \"%s\"."
+#define UNDEFINED_INPUT_MSG \
+"Undefined InputDevice \"%s\" referenced by ServerLayout \"%s\"."
+#define NO_IDENT_MSG \
+"This section must have an Identifier line."
+#define ONLY_ONE_MSG \
+"This section must have only one of either %s line."
+#define UNDEFINED_INPUTDRIVER_MSG \
+"InputDevice section \"%s\" must have a Driver line."
+#define INVALID_GAMMA_MSG \
+"gamma correction value(s) expected\n either one value or three r/g/b values."
+#define GROUP_MSG \
+"The Group keyword must be followed by either a group name in quotes or\n" \
+"\ta numerical group id."
+#define MULTIPLE_MSG \
+"Multiple \"%s\" lines."
+#define MUST_BE_OCTAL_MSG \
+"The number \"%d\" given in this section must be in octal (0xxx) format."
+
+/* Warning messages */
+#define OBSOLETE_MSG \
+"Ignoring obsolete keyword \"%s\"."
+
+#endif                          /* _Configint_h_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/Configint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigetclientpointer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigetclientpointer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigetclientpointer.h	(Revision 52145)
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETCPTR_H
+#define GETCPTR_H 1
+int SProcXIGetClientPointer(ClientPtr /* client */ );
+int ProcXIGetClientPointer(ClientPtr /* client */ );
+void SRepXIGetClientPointer(ClientPtr /* client */ ,
+                            int /* size */ ,
+                            xXIGetClientPointerReply * /* rep */ );
+
+#endif                          /* GETCPTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xigetclientpointer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_priv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_priv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_priv.h	(Revision 52145)
@@ -0,0 +1,1056 @@
+/*
+ * Copyright ¬© 2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *
+ */
+#ifndef GLAMOR_PRIV_H
+#define GLAMOR_PRIV_H
+
+#include "dix-config.h"
+
+#include <xorg-server.h>
+#include "glamor.h"
+
+#include <epoxy/gl.h>
+#if GLAMOR_HAS_GBM
+#define MESA_EGL_NO_X11_HEADERS
+#include <epoxy/egl.h>
+#endif
+
+#define GLAMOR_DEFAULT_PRECISION  \
+    "#ifdef GL_ES\n"              \
+    "precision mediump float;\n"  \
+    "#endif\n"
+
+#ifdef RENDER
+#include "glyphstr.h"
+#endif
+
+#include "glamor_debug.h"
+#include "glamor_context.h"
+#include "glamor_program.h"
+
+#include <list.h>
+
+struct glamor_pixmap_private;
+
+typedef struct glamor_composite_shader {
+    GLuint prog;
+    GLint dest_to_dest_uniform_location;
+    GLint dest_to_source_uniform_location;
+    GLint dest_to_mask_uniform_location;
+    GLint source_uniform_location;
+    GLint mask_uniform_location;
+    GLint source_wh;
+    GLint mask_wh;
+    GLint source_repeat_mode;
+    GLint mask_repeat_mode;
+    union {
+        float source_solid_color[4];
+        struct {
+            struct glamor_pixmap_private *source_priv;
+            PicturePtr source;
+        };
+    };
+
+    union {
+        float mask_solid_color[4];
+        struct {
+            struct glamor_pixmap_private *mask_priv;
+            PicturePtr mask;
+        };
+    };
+} glamor_composite_shader;
+
+enum shader_source {
+    SHADER_SOURCE_SOLID,
+    SHADER_SOURCE_TEXTURE,
+    SHADER_SOURCE_TEXTURE_ALPHA,
+    SHADER_SOURCE_COUNT,
+};
+
+enum shader_mask {
+    SHADER_MASK_NONE,
+    SHADER_MASK_SOLID,
+    SHADER_MASK_TEXTURE,
+    SHADER_MASK_TEXTURE_ALPHA,
+    SHADER_MASK_COUNT,
+};
+
+enum shader_in {
+    SHADER_IN_SOURCE_ONLY,
+    SHADER_IN_NORMAL,
+    SHADER_IN_CA_SOURCE,
+    SHADER_IN_CA_ALPHA,
+    SHADER_IN_COUNT,
+};
+
+struct shader_key {
+    enum shader_source source;
+    enum shader_mask mask;
+    enum shader_in in;
+};
+
+struct blendinfo {
+    Bool dest_alpha;
+    Bool source_alpha;
+    GLenum source_blend;
+    GLenum dest_blend;
+};
+
+typedef struct {
+    INT16 x_src;
+    INT16 y_src;
+    INT16 x_mask;
+    INT16 y_mask;
+    INT16 x_dst;
+    INT16 y_dst;
+    INT16 width;
+    INT16 height;
+} glamor_composite_rect_t;
+
+enum glamor_vertex_type {
+    GLAMOR_VERTEX_POS,
+    GLAMOR_VERTEX_SOURCE,
+    GLAMOR_VERTEX_MASK
+};
+
+enum gradient_shader {
+    SHADER_GRADIENT_LINEAR,
+    SHADER_GRADIENT_RADIAL,
+    SHADER_GRADIENT_CONICAL,
+    SHADER_GRADIENT_COUNT,
+};
+
+struct glamor_screen_private;
+struct glamor_pixmap_private;
+
+enum glamor_gl_flavor {
+    GLAMOR_GL_DESKTOP,          // OPENGL API
+    GLAMOR_GL_ES2               // OPENGL ES2.0 API
+};
+
+#define GLAMOR_NUM_GLYPH_CACHE_FORMATS 2
+
+#define GLAMOR_COMPOSITE_VBO_VERT_CNT (64*1024)
+
+typedef struct {
+    PicturePtr picture;         /* Where the glyphs of the cache are stored */
+    GlyphPtr *glyphs;
+    uint16_t count;
+    uint16_t evict;
+} glamor_glyph_cache_t;
+
+struct glamor_saved_procs {
+    CloseScreenProcPtr close_screen;
+    CreateScreenResourcesProcPtr create_screen_resources;
+    CreateGCProcPtr create_gc;
+    CreatePixmapProcPtr create_pixmap;
+    DestroyPixmapProcPtr destroy_pixmap;
+    GetSpansProcPtr get_spans;
+    GetImageProcPtr get_image;
+    CompositeProcPtr composite;
+    CompositeRectsProcPtr composite_rects;
+    TrapezoidsProcPtr trapezoids;
+    GlyphsProcPtr glyphs;
+    ChangeWindowAttributesProcPtr change_window_attributes;
+    CopyWindowProcPtr copy_window;
+    BitmapToRegionProcPtr bitmap_to_region;
+    TrianglesProcPtr triangles;
+    AddTrapsProcPtr addtraps;
+    CreatePictureProcPtr create_picture;
+    DestroyPictureProcPtr destroy_picture;
+    UnrealizeGlyphProcPtr unrealize_glyph;
+    SetWindowPixmapProcPtr set_window_pixmap;
+};
+
+#define CACHE_FORMAT_COUNT 3
+
+#define CACHE_BUCKET_WCOUNT 4
+#define CACHE_BUCKET_HCOUNT 4
+
+#define GLAMOR_TICK_AFTER(t0, t1) 	\
+	(((int)(t1) - (int)(t0)) < 0)
+
+#define IDLE_STATE 0
+#define RENDER_STATE 1
+#define BLIT_STATE 2
+#define RENDER_IDEL_MAX 32
+
+typedef struct glamor_screen_private {
+    Bool yInverted;
+    unsigned int tick;
+    enum glamor_gl_flavor gl_flavor;
+    int glsl_version;
+    int has_pack_invert;
+    int has_fbo_blit;
+    int has_map_buffer_range;
+    int has_buffer_storage;
+    int has_khr_debug;
+    int max_fbo_size;
+
+    struct xorg_list
+        fbo_cache[CACHE_FORMAT_COUNT][CACHE_BUCKET_WCOUNT][CACHE_BUCKET_HCOUNT];
+    unsigned long fbo_cache_watermark;
+
+    /* glamor_solid */
+    GLint solid_prog;
+    GLint solid_color_uniform_location;
+
+    /* glamor point shader */
+    glamor_program point_prog;
+
+    /* glamor spans shaders */
+    glamor_program_fill fill_spans_program;
+
+    /* glamor rect shaders */
+    glamor_program_fill poly_fill_rect_program;
+
+    /* glamor glyphblt shaders */
+    glamor_program_fill poly_glyph_blt_progs;
+
+    /* glamor text shaders */
+    glamor_program_fill poly_text_progs;
+    glamor_program      te_text_prog;
+    glamor_program      image_text_prog;
+
+    /* vertext/elment_index buffer object for render */
+    GLuint vbo, ebo;
+    /** Next offset within the VBO that glamor_get_vbo_space() will use. */
+    int vbo_offset;
+    int vbo_size;
+    /**
+     * Pointer to glamor_get_vbo_space()'s current VBO mapping.
+     *
+     * Note that this is not necessarily equal to the pointer returned
+     * by glamor_get_vbo_space(), so it can't be used in place of that.
+     */
+    char *vb;
+    int vb_stride;
+    Bool has_source_coords, has_mask_coords;
+    int render_nr_verts;
+    glamor_composite_shader composite_shader[SHADER_SOURCE_COUNT]
+        [SHADER_MASK_COUNT]
+        [SHADER_IN_COUNT];
+    glamor_glyph_cache_t glyphCaches[GLAMOR_NUM_GLYPH_CACHE_FORMATS];
+    Bool glyph_cache_initialized;
+
+    /* shaders to restore a texture to another texture. */
+    GLint finish_access_prog[2];
+    GLint finish_access_revert[2];
+    GLint finish_access_swap_rb[2];
+
+    /* glamor_tile */
+    GLint tile_prog;
+    GLint tile_wh;
+
+    /* glamor gradient, 0 for small nstops, 1 for
+       large nstops and 2 for dynamic generate. */
+    GLint gradient_prog[SHADER_GRADIENT_COUNT][3];
+    int linear_max_nstops;
+    int radial_max_nstops;
+
+    /* glamor trapezoid shader. */
+    GLint trapezoid_prog;
+
+    PixmapPtr *back_pixmap;
+    int screen_fbo;
+    struct glamor_saved_procs saved_procs;
+    char delayed_fallback_string[GLAMOR_DELAYED_STRING_MAX + 1];
+    int delayed_fallback_pending;
+    int flags;
+    int state;
+    unsigned int render_idle_cnt;
+    ScreenPtr screen;
+    int dri3_enabled;
+
+    /* xv */
+    GLint xv_prog;
+
+    struct glamor_context ctx;
+} glamor_screen_private;
+
+typedef enum glamor_access {
+    GLAMOR_ACCESS_RO,
+    GLAMOR_ACCESS_RW,
+} glamor_access_t;
+
+enum glamor_fbo_state {
+    /** There is no storage attached to the pixmap. */
+    GLAMOR_FBO_UNATTACHED,
+    /**
+     * The pixmap has FBO storage attached, but devPrivate.ptr doesn't
+     * point at anything.
+     */
+    GLAMOR_FBO_NORMAL,
+    /**
+     * The FBO is present and can be accessed as a linear memory
+     * mapping through devPrivate.ptr.
+     */
+    GLAMOR_FBO_DOWNLOADED,
+};
+
+/* glamor_pixmap_fbo:
+ * @list:    to be used to link to the cache pool list.
+ * @expire:  when push to cache pool list, set a expire count.
+ * 	     will be freed when glamor_priv->tick is equal or
+ * 	     larger than this expire count in block handler.
+ * @pbo_valid: The pbo has a valid copy of the pixmap's data.
+ * @tex:     attached texture.
+ * @fb:      attached fbo.
+ * @pbo:     attached pbo.
+ * @width:   width of this fbo.
+ * @height:  height of this fbo.
+ * @format:  internal format of this fbo's texture.
+ * @type:    internal type of this fbo's texture.
+ * @glamor_priv: point to glamor private data.
+ */
+typedef struct glamor_pixmap_fbo {
+    struct xorg_list list;
+    unsigned int expire;
+    unsigned char pbo_valid;
+    GLuint tex;
+    GLuint fb;
+    GLuint pbo;
+    int width;
+    int height;
+    GLenum format;
+    GLenum type;
+    glamor_screen_private *glamor_priv;
+} glamor_pixmap_fbo;
+
+/*
+ * glamor_pixmap_private - glamor pixmap's private structure.
+ * @gl_tex:  The pixmap is in a gl texture originally.
+ * @is_picture: The drawable is attached to a picture.
+ * @pict_format: the corresponding picture's format.
+ * @pixmap: The corresponding pixmap's pointer.
+ *
+ * For GLAMOR_TEXTURE_LARGE, nbox should larger than 1.
+ * And the box and fbo will both have nbox elements.
+ * and box[i] store the relatively coords in this pixmap
+ * of the fbo[i]. The reason why use boxes not region to
+ * represent this structure is we may need to use overlapped
+ * boxes for one pixmap for some special reason.
+ *
+ * pixmap
+ * ******************
+ * *  fbo0 * fbo1   *
+ * *       *        *
+ * ******************
+ * *  fbo2 * fbo3   *
+ * *       *        *
+ * ******************
+ *
+ * Let's assume the texture has size of 1024x1024
+ * box[0] = {0,0,1024,1024}
+ * box[1] = {1024,0,2048,2048}
+ * ...
+ *
+ * For GLAMOR_TEXTURE_ATLAS nbox should be 1. And box
+ * and fbo both has one elements, and the box store
+ * the relatively coords in the fbo of this pixmap:
+ *
+ * fbo
+ * ******************
+ * *   pixmap       *
+ * *   *********    *
+ * *   *       *    *
+ * *   *********    *
+ * *                *
+ * ******************
+ *
+ * Assume the pixmap is at the (100,100) relatively to
+ * the fbo's origin.
+ * box[0]={100, 100, 1124, 1124};
+ *
+ * Considering large pixmap is not a normal case, to keep
+ * it simple, I designe it as the following way.
+ * When deal with a large pixmap, it split the working
+ * rectangle into serval boxes, and each box fit into a
+ * corresponding fbo. And then the rendering function will
+ * loop from the left-top box to the right-bottom box,
+ * each time, we will set current box and current fbo
+ * to the box and fbo elements. Thus the inner routines
+ * can handle it as normal, only the coords calculation need
+ * to aware of it's large pixmap.
+ *
+ * Currently, we haven't implemented the atlas pixmap.
+ *
+ **/
+
+typedef struct glamor_pixmap_clipped_regions {
+    int block_idx;
+    RegionPtr region;
+} glamor_pixmap_clipped_regions;
+
+#define SET_PIXMAP_FBO_CURRENT(priv, idx) 				\
+  do {									\
+	if (priv->type == GLAMOR_TEXTURE_LARGE) {			\
+		(priv)->large.base.fbo = priv->large.fbo_array[idx]; 	\
+		(priv)->large.box = priv->large.box_array[idx]; 	\
+	}								\
+  } while(0)
+
+typedef struct glamor_pixmap_private_base {
+    glamor_pixmap_type_t type;
+    enum glamor_fbo_state gl_fbo;
+    /**
+     * If devPrivate.ptr is non-NULL (meaning we're within
+     * glamor_prepare_access), determies whether we should re-upload
+     * that data on glamor_finish_access().
+     */
+    glamor_access_t map_access;
+    unsigned char is_picture:1;
+    unsigned char gl_tex:1;
+    glamor_pixmap_fbo *fbo;
+    PixmapPtr pixmap;
+    BoxRec box;
+    int drm_stride;
+    glamor_screen_private *glamor_priv;
+    PicturePtr picture;
+#if GLAMOR_HAS_GBM
+    EGLImageKHR image;
+#endif
+} glamor_pixmap_private_base_t;
+
+/*
+ * @base.fbo: current fbo.
+ * @box: current fbo's coords in the whole pixmap.
+ * @block_w: block width of this large pixmap.
+ * @block_h: block height of this large pixmap.
+ * @block_wcnt: block count in one block row.
+ * @block_hcnt: block count in one block column.
+ * @nbox: total block count.
+ * @box_array: contains each block's corresponding box.
+ * @fbo_array: contains each block's fbo pointer.
+ *
+ **/
+typedef struct glamor_pixmap_private_large {
+    union {
+        glamor_pixmap_type_t type;
+        glamor_pixmap_private_base_t base;
+    };
+    BoxRec box;
+    int block_w;
+    int block_h;
+    int block_wcnt;
+    int block_hcnt;
+    int nbox;
+    BoxPtr box_array;
+    glamor_pixmap_fbo **fbo_array;
+} glamor_pixmap_private_large_t;
+
+/*
+ * @box: the relative coords in the corresponding fbo.
+ */
+typedef struct glamor_pixmap_private_atlas {
+    union {
+        glamor_pixmap_type_t type;
+        glamor_pixmap_private_base_t base;
+    };
+    BoxRec box;
+} glamor_pixmap_private_atlas_t;
+
+typedef struct glamor_pixmap_private {
+    union {
+        glamor_pixmap_type_t type;
+        glamor_pixmap_private_base_t base;
+        glamor_pixmap_private_large_t large;
+        glamor_pixmap_private_atlas_t atlas;
+    };
+} glamor_pixmap_private;
+
+static inline glamor_pixmap_fbo *
+glamor_pixmap_fbo_at(glamor_pixmap_private *priv, int x, int y)
+{
+    if (priv->type == GLAMOR_TEXTURE_LARGE) {
+        assert(x < priv->large.block_wcnt);
+        assert(y < priv->large.block_hcnt);
+        return priv->large.fbo_array[y * priv->large.block_wcnt + x];
+    }
+    assert (x == 0);
+    assert (y == 0);
+    return priv->base.fbo;
+}
+
+static inline BoxPtr
+glamor_pixmap_box_at(glamor_pixmap_private *priv, int x, int y)
+{
+    if (priv->type == GLAMOR_TEXTURE_LARGE) {
+        assert(x < priv->large.block_wcnt);
+        assert(y < priv->large.block_hcnt);
+        return &priv->large.box_array[y * priv->large.block_wcnt + x];
+    }
+    assert (x == 0);
+    assert (y == 0);
+    return &priv->base.box;
+}
+
+static inline int
+glamor_pixmap_wcnt(glamor_pixmap_private *priv)
+{
+    if (priv->type == GLAMOR_TEXTURE_LARGE)
+        return priv->large.block_wcnt;
+    return 1;
+}
+
+static inline int
+glamor_pixmap_hcnt(glamor_pixmap_private *priv)
+{
+    if (priv->type == GLAMOR_TEXTURE_LARGE)
+        return priv->large.block_hcnt;
+    return 1;
+}
+
+#define glamor_pixmap_loop(priv, x, y)                  \
+    for (y = 0; y < glamor_pixmap_hcnt(priv); y++)      \
+        for (x = 0; x < glamor_pixmap_wcnt(priv); x++)
+
+/* 
+ * Pixmap dynamic status, used by dynamic upload feature.
+ *
+ * GLAMOR_NONE:  initial status, don't need to do anything.
+ * GLAMOR_UPLOAD_PENDING: marked as need to be uploaded to gl texture.
+ * GLAMOR_UPLOAD_DONE: the pixmap has been uploaded successfully.
+ * GLAMOR_UPLOAD_FAILED: fail to upload the pixmap.
+ *
+ * */
+typedef enum glamor_pixmap_status {
+    GLAMOR_NONE,
+    GLAMOR_UPLOAD_PENDING,
+    GLAMOR_UPLOAD_DONE,
+    GLAMOR_UPLOAD_FAILED
+} glamor_pixmap_status_t;
+
+extern DevPrivateKey glamor_screen_private_key;
+extern DevPrivateKey glamor_pixmap_private_key;
+static inline glamor_screen_private *
+glamor_get_screen_private(ScreenPtr screen)
+{
+    return (glamor_screen_private *)
+        dixLookupPrivate(&screen->devPrivates, glamor_screen_private_key);
+}
+
+static inline void
+glamor_set_screen_private(ScreenPtr screen, glamor_screen_private *priv)
+{
+    dixSetPrivate(&screen->devPrivates, glamor_screen_private_key, priv);
+}
+
+static inline glamor_pixmap_private *
+glamor_get_pixmap_private(PixmapPtr pixmap)
+{
+    glamor_pixmap_private *priv;
+
+    priv = dixLookupPrivate(&pixmap->devPrivates, glamor_pixmap_private_key);
+    if (!priv) {
+        glamor_set_pixmap_type(pixmap, GLAMOR_MEMORY);
+        priv = dixLookupPrivate(&pixmap->devPrivates,
+                                glamor_pixmap_private_key);
+    }
+    return priv;
+}
+
+void glamor_set_pixmap_private(PixmapPtr pixmap, glamor_pixmap_private *priv);
+
+/**
+ * Returns TRUE if the given planemask covers all the significant bits in the
+ * pixel values for pDrawable.
+ */
+static inline Bool
+glamor_pm_is_solid(DrawablePtr drawable, unsigned long planemask)
+{
+    return (planemask & FbFullMask(drawable->depth)) ==
+        FbFullMask(drawable->depth);
+}
+
+extern int glamor_debug_level;
+
+/* glamor.c */
+PixmapPtr glamor_get_drawable_pixmap(DrawablePtr drawable);
+
+glamor_pixmap_fbo *glamor_pixmap_detach_fbo(glamor_pixmap_private *
+                                            pixmap_priv);
+void glamor_pixmap_attach_fbo(PixmapPtr pixmap, glamor_pixmap_fbo *fbo);
+glamor_pixmap_fbo *glamor_create_fbo_from_tex(glamor_screen_private *
+                                              glamor_priv, int w, int h,
+                                              GLenum format, GLint tex,
+                                              int flag);
+glamor_pixmap_fbo *glamor_create_fbo(glamor_screen_private *glamor_priv, int w,
+                                     int h, GLenum format, int flag);
+void glamor_destroy_fbo(glamor_pixmap_fbo *fbo);
+void glamor_pixmap_destroy_fbo(glamor_pixmap_private *priv);
+void glamor_purge_fbo(glamor_pixmap_fbo *fbo);
+
+void glamor_init_pixmap_fbo(ScreenPtr screen);
+void glamor_fini_pixmap_fbo(ScreenPtr screen);
+Bool glamor_pixmap_fbo_fixup(ScreenPtr screen, PixmapPtr pixmap);
+void glamor_fbo_expire(glamor_screen_private *glamor_priv);
+
+glamor_pixmap_fbo *glamor_create_fbo_array(glamor_screen_private *glamor_priv,
+                                           int w, int h, GLenum format,
+                                           int flag, int block_w, int block_h,
+                                           glamor_pixmap_private *);
+
+/* glamor_copyarea.c */
+RegionPtr
+
+glamor_copy_area(DrawablePtr src, DrawablePtr dst, GCPtr gc,
+                 int srcx, int srcy, int width, int height, int dstx, int dsty);
+void glamor_copy_n_to_n(DrawablePtr src, DrawablePtr dst, GCPtr gc,
+                        BoxPtr box, int nbox, int dx, int dy, Bool reverse,
+                        Bool upsidedown, Pixel bitplane, void *closure);
+
+/* glamor_core.c */
+Bool glamor_prepare_access(DrawablePtr drawable, glamor_access_t access);
+void glamor_finish_access(DrawablePtr drawable);
+Bool glamor_prepare_access_window(WindowPtr window);
+void glamor_finish_access_window(WindowPtr window);
+Bool glamor_prepare_access_gc(GCPtr gc);
+void glamor_finish_access_gc(GCPtr gc);
+void glamor_init_finish_access_shaders(ScreenPtr screen);
+void glamor_fini_finish_access_shaders(ScreenPtr screen);
+const Bool glamor_get_drawable_location(const DrawablePtr drawable);
+void glamor_get_drawable_deltas(DrawablePtr drawable, PixmapPtr pixmap,
+                                int *x, int *y);
+Bool glamor_stipple(PixmapPtr pixmap, PixmapPtr stipple,
+                    int x, int y, int width, int height,
+                    unsigned char alu, unsigned long planemask,
+                    unsigned long fg_pixel, unsigned long bg_pixel,
+                    int stipple_x, int stipple_y);
+GLint glamor_compile_glsl_prog(GLenum type, const char *source);
+void glamor_link_glsl_prog(ScreenPtr screen, GLint prog,
+                           const char *format, ...) _X_ATTRIBUTE_PRINTF(3,4);
+void glamor_get_color_4f_from_pixel(PixmapPtr pixmap,
+                                    unsigned long fg_pixel, GLfloat *color);
+
+int glamor_set_destination_pixmap(PixmapPtr pixmap);
+int glamor_set_destination_pixmap_priv(glamor_pixmap_private *pixmap_priv);
+void glamor_set_destination_pixmap_fbo(glamor_pixmap_fbo *, int, int, int, int);
+
+/* nc means no check. caller must ensure this pixmap has valid fbo.
+ * usually use the GLAMOR_PIXMAP_PRIV_HAS_FBO firstly. 
+ * */
+void glamor_set_destination_pixmap_priv_nc(glamor_pixmap_private *pixmap_priv);
+
+glamor_pixmap_fbo *glamor_es2_pixmap_read_prepare(PixmapPtr source, int x,
+                                                  int y, int w, int h,
+                                                  GLenum format, GLenum type,
+                                                  int no_alpha, int revert,
+                                                  int swap_rb);
+
+Bool glamor_set_alu(ScreenPtr screen, unsigned char alu);
+Bool glamor_set_planemask(PixmapPtr pixmap, unsigned long planemask);
+RegionPtr glamor_bitmap_to_region(PixmapPtr pixmap);
+
+/* glamor_fill.c */
+Bool glamor_fill(DrawablePtr drawable,
+                 GCPtr gc, int x, int y, int width, int height, Bool fallback);
+Bool glamor_solid(PixmapPtr pixmap, int x, int y, int width, int height,
+                  unsigned char alu, unsigned long planemask,
+                  unsigned long fg_pixel);
+Bool glamor_solid_boxes(PixmapPtr pixmap,
+                        BoxPtr box, int nbox, unsigned long fg_pixel);
+
+void glamor_init_solid_shader(ScreenPtr screen);
+void glamor_fini_solid_shader(ScreenPtr screen);
+
+/* glamor_glyphs.c */
+Bool glamor_realize_glyph_caches(ScreenPtr screen);
+void glamor_glyphs_fini(ScreenPtr screen);
+void glamor_glyphs(CARD8 op,
+                   PicturePtr pSrc,
+                   PicturePtr pDst,
+                   PictFormatPtr maskFormat,
+                   INT16 xSrc,
+                   INT16 ySrc, int nlist, GlyphListPtr list, GlyphPtr *glyphs);
+
+/* glamor_polylines.c */
+void glamor_poly_lines(DrawablePtr drawable, GCPtr gc, int mode, int n,
+                       DDXPointPtr points);
+
+/* glamor_render.c */
+Bool glamor_composite_clipped_region(CARD8 op,
+                                     PicturePtr source,
+                                     PicturePtr mask,
+                                     PicturePtr dest,
+                                     glamor_pixmap_private *soruce_pixmap_priv,
+                                     glamor_pixmap_private *mask_pixmap_priv,
+                                     glamor_pixmap_private *dest_pixmap_priv,
+                                     RegionPtr region,
+                                     int x_source,
+                                     int y_source,
+                                     int x_mask, int y_mask,
+                                     int x_dest, int y_dest);
+
+void glamor_composite(CARD8 op,
+                      PicturePtr pSrc,
+                      PicturePtr pMask,
+                      PicturePtr pDst,
+                      INT16 xSrc,
+                      INT16 ySrc,
+                      INT16 xMask,
+                      INT16 yMask,
+                      INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+void glamor_init_composite_shaders(ScreenPtr screen);
+void glamor_fini_composite_shaders(ScreenPtr screen);
+void glamor_composite_glyph_rects(CARD8 op,
+                                  PicturePtr src, PicturePtr mask,
+                                  PicturePtr dst, int nrect,
+                                  glamor_composite_rect_t *rects);
+void glamor_composite_rects(CARD8 op,
+                            PicturePtr pDst,
+                            xRenderColor *color, int nRect, xRectangle *rects);
+void glamor_init_trapezoid_shader(ScreenPtr screen);
+void glamor_fini_trapezoid_shader(ScreenPtr screen);
+PicturePtr glamor_convert_gradient_picture(ScreenPtr screen,
+                                           PicturePtr source,
+                                           int x_source,
+                                           int y_source, int width, int height);
+
+Bool glamor_composite_choose_shader(CARD8 op,
+                                    PicturePtr source,
+                                    PicturePtr mask,
+                                    PicturePtr dest,
+                                    glamor_pixmap_private *source_pixmap_priv,
+                                    glamor_pixmap_private *mask_pixmap_priv,
+                                    glamor_pixmap_private *dest_pixmap_priv,
+                                    struct shader_key *s_key,
+                                    glamor_composite_shader ** shader,
+                                    struct blendinfo *op_info,
+                                    PictFormatShort *psaved_source_format);
+
+void glamor_composite_set_shader_blend(glamor_pixmap_private *dest_priv,
+                                       struct shader_key *key,
+                                       glamor_composite_shader *shader,
+                                       struct blendinfo *op_info);
+
+void *glamor_setup_composite_vbo(ScreenPtr screen, int n_verts);
+
+/* glamor_trapezoid.c */
+void glamor_trapezoids(CARD8 op,
+                       PicturePtr src, PicturePtr dst,
+                       PictFormatPtr mask_format, INT16 x_src, INT16 y_src,
+                       int ntrap, xTrapezoid *traps);
+
+/* glamor_tile.c */
+Bool glamor_tile(PixmapPtr pixmap, PixmapPtr tile,
+                 int x, int y, int width, int height,
+                 unsigned char alu, unsigned long planemask,
+                 int tile_x, int tile_y);
+void glamor_init_tile_shader(ScreenPtr screen);
+void glamor_fini_tile_shader(ScreenPtr screen);
+
+/* glamor_gradient.c */
+void glamor_init_gradient_shader(ScreenPtr screen);
+void glamor_fini_gradient_shader(ScreenPtr screen);
+PicturePtr glamor_generate_linear_gradient_picture(ScreenPtr screen,
+                                                   PicturePtr src_picture,
+                                                   int x_source, int y_source,
+                                                   int width, int height,
+                                                   PictFormatShort format);
+PicturePtr glamor_generate_radial_gradient_picture(ScreenPtr screen,
+                                                   PicturePtr src_picture,
+                                                   int x_source, int y_source,
+                                                   int width, int height,
+                                                   PictFormatShort format);
+
+/* glamor_triangles.c */
+void glamor_triangles(CARD8 op,
+                      PicturePtr pSrc,
+                      PicturePtr pDst,
+                      PictFormatPtr maskFormat,
+                      INT16 xSrc, INT16 ySrc, int ntris, xTriangle * tris);
+
+/* glamor_pixmap.c */
+
+void glamor_pixmap_init(ScreenPtr screen);
+void glamor_pixmap_fini(ScreenPtr screen);
+
+/* glamor_vbo.c */
+
+void glamor_init_vbo(ScreenPtr screen);
+void glamor_fini_vbo(ScreenPtr screen);
+
+void *
+glamor_get_vbo_space(ScreenPtr screen, unsigned size, char **vbo_offset);
+
+void
+glamor_put_vbo_space(ScreenPtr screen);
+
+/** 
+ * Download a pixmap's texture to cpu memory. If success,
+ * One copy of current pixmap's texture will be put into
+ * the pixmap->devPrivate.ptr. Will use pbo to map to 
+ * the pointer if possible.
+ * The pixmap must be a gl texture pixmap. gl_fbo must be GLAMOR_FBO_NORMAL and
+ * gl_tex must be 1. Used by glamor_prepare_access.
+ *
+ */
+Bool glamor_download_pixmap_to_cpu(PixmapPtr pixmap, glamor_access_t access);
+
+void *glamor_download_sub_pixmap_to_cpu(PixmapPtr pixmap, int x, int y, int w,
+                                        int h, int stride, void *bits, int pbo,
+                                        glamor_access_t access);
+
+/**
+ * Restore a pixmap's data which is downloaded by 
+ * glamor_download_pixmap_to_cpu to its original 
+ * gl texture. Used by glamor_finish_access. 
+ *
+ * The pixmap must originally be a texture -- gl_fbo must be
+ * GLAMOR_FBO_NORMAL.
+ **/
+void glamor_restore_pixmap_to_texture(PixmapPtr pixmap);
+
+/**
+ * According to the flag,
+ * if the flag is GLAMOR_CREATE_FBO_NO_FBO then just ensure
+ * the fbo has a valid texture. Otherwise, it will ensure
+ * the fbo has valid texture and attach to a valid fb.
+ * If the fbo already has a valid glfbo then do nothing.
+ */
+Bool glamor_pixmap_ensure_fbo(PixmapPtr pixmap, GLenum format, int flag);
+
+/**
+ * Upload a pixmap to gl texture. Used by dynamic pixmap
+ * uploading feature. The pixmap must be a software pixmap.
+ * This function will change current FBO and current shaders.
+ */
+enum glamor_pixmap_status glamor_upload_pixmap_to_texture(PixmapPtr pixmap);
+
+Bool glamor_upload_sub_pixmap_to_texture(PixmapPtr pixmap, int x, int y, int w,
+                                         int h, int stride, void *bits,
+                                         int pbo);
+
+PixmapPtr glamor_get_sub_pixmap(PixmapPtr pixmap, int x, int y,
+                                int w, int h, glamor_access_t access);
+void glamor_put_sub_pixmap(PixmapPtr sub_pixmap, PixmapPtr pixmap, int x, int y,
+                           int w, int h, glamor_access_t access);
+
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions(glamor_pixmap_private *priv,
+                               RegionPtr region, int *clipped_nbox,
+                               int repeat_type, int reverse,
+                               int upsidedown);
+
+glamor_pixmap_clipped_regions *
+glamor_compute_clipped_regions_ext(glamor_pixmap_private *pixmap_priv,
+                                   RegionPtr region, int *n_region,
+                                   int inner_block_w, int inner_block_h,
+                                   int reverse, int upsidedown);
+
+glamor_pixmap_clipped_regions *
+glamor_compute_transform_clipped_regions(glamor_pixmap_private *priv,
+                                         struct pixman_transform *transform,
+                                         RegionPtr region,
+                                         int *n_region, int dx, int dy,
+                                         int repeat_type, int reverse,
+                                         int upsidedown);
+
+Bool glamor_composite_largepixmap_region(CARD8 op,
+                                         PicturePtr source,
+                                         PicturePtr mask,
+                                         PicturePtr dest,
+                                         glamor_pixmap_private *source_pixmap_priv,
+                                         glamor_pixmap_private *mask_pixmap_priv,
+                                         glamor_pixmap_private *dest_pixmap_priv,
+                                         RegionPtr region, Bool force_clip,
+                                         INT16 x_source,
+                                         INT16 y_source,
+                                         INT16 x_mask,
+                                         INT16 y_mask,
+                                         INT16 x_dest, INT16 y_dest,
+                                         CARD16 width, CARD16 height);
+
+Bool glamor_get_transform_block_size(struct pixman_transform *transform,
+                                     int block_w, int block_h,
+                                     int *transformed_block_w,
+                                     int *transformed_block_h);
+
+void glamor_get_transform_extent_from_box(struct pixman_box32 *temp_box,
+                                          struct pixman_transform *transform);
+
+/**
+ * Upload a picture to gl texture. Similar to the
+ * glamor_upload_pixmap_to_texture. Used in rendering.
+ **/
+enum glamor_pixmap_status glamor_upload_picture_to_texture(PicturePtr picture);
+
+/**
+ * Upload bits to a pixmap's texture. This function will
+ * convert the bits to the specified format/type format
+ * if the conversion is unavoidable.
+ **/
+Bool glamor_upload_bits_to_pixmap_texture(PixmapPtr pixmap, GLenum format,
+                                          GLenum type, int no_alpha, int revert,
+                                          int swap_rb, void *bits);
+
+/**
+ * Destroy all the resources allocated on the uploading
+ * phase, includs the tex and fbo.
+ **/
+void glamor_destroy_upload_pixmap(PixmapPtr pixmap);
+
+int glamor_create_picture(PicturePtr picture);
+
+void glamor_set_window_pixmap(WindowPtr pWindow, PixmapPtr pPixmap);
+
+Bool glamor_prepare_access_picture(PicturePtr picture, glamor_access_t access);
+
+void glamor_finish_access_picture(PicturePtr picture);
+
+void glamor_destroy_picture(PicturePtr picture);
+
+/* fixup a fbo to the exact size as the pixmap. */
+Bool glamor_fixup_pixmap_priv(ScreenPtr screen,
+                              glamor_pixmap_private *pixmap_priv);
+
+void glamor_picture_format_fixup(PicturePtr picture,
+                                 glamor_pixmap_private *pixmap_priv);
+
+void glamor_add_traps(PicturePtr pPicture,
+                      INT16 x_off, INT16 y_off, int ntrap, xTrap *traps);
+
+RegionPtr glamor_copy_plane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+                            int srcx, int srcy, int w, int h,
+                            int dstx, int dsty,
+                            unsigned long bitPlane);
+
+/* glamor_text.c */
+int glamor_poly_text8(DrawablePtr pDrawable, GCPtr pGC,
+                      int x, int y, int count, char *chars);
+
+int glamor_poly_text16(DrawablePtr pDrawable, GCPtr pGC,
+                       int x, int y, int count, unsigned short *chars);
+
+void glamor_image_text8(DrawablePtr pDrawable, GCPtr pGC,
+                        int x, int y, int count, char *chars);
+
+void glamor_image_text16(DrawablePtr pDrawable, GCPtr pGC,
+                         int x, int y, int count, unsigned short *chars);
+
+/* glamor_spans.c */
+void
+glamor_fill_spans(DrawablePtr drawable,
+                  GCPtr gc,
+                  int n, DDXPointPtr points, int *widths, int sorted);
+
+void
+glamor_get_spans(DrawablePtr drawable, int wmax,
+                 DDXPointPtr points, int *widths, int count, char *dst);
+
+void
+glamor_set_spans(DrawablePtr drawable, GCPtr gc, char *src,
+                 DDXPointPtr points, int *widths, int numPoints, int sorted);
+
+/* glamor_rects.c */
+void
+glamor_poly_fill_rect(DrawablePtr drawable,
+                      GCPtr gc, int nrect, xRectangle *prect);
+
+/* glamor_image.c */
+void
+glamor_put_image(DrawablePtr drawable, GCPtr gc, int depth, int x, int y,
+                 int w, int h, int leftPad, int format, char *bits);
+
+void
+glamor_get_image(DrawablePtr pDrawable, int x, int y, int w, int h,
+                 unsigned int format, unsigned long planeMask, char *d);
+
+/* glamor_glyphblt.c */
+void glamor_image_glyph_blt(DrawablePtr pDrawable, GCPtr pGC,
+                            int x, int y, unsigned int nglyph,
+                            CharInfoPtr *ppci, void *pglyphBase);
+
+void glamor_poly_glyph_blt(DrawablePtr pDrawable, GCPtr pGC,
+                           int x, int y, unsigned int nglyph,
+                           CharInfoPtr *ppci, void *pglyphBase);
+
+void glamor_push_pixels(GCPtr pGC, PixmapPtr pBitmap,
+                        DrawablePtr pDrawable, int w, int h, int x, int y);
+
+void glamor_poly_point(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
+                       DDXPointPtr ppt);
+
+void glamor_poly_segment(DrawablePtr pDrawable, GCPtr pGC, int nseg,
+                         xSegment *pSeg);
+
+void glamor_poly_line(DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
+                      DDXPointPtr ppt);
+
+void glamor_composite_rectangles(CARD8 op,
+                                 PicturePtr dst,
+                                 xRenderColor *color,
+                                 int num_rects, xRectangle *rects);
+
+/* glamor_xv */
+typedef struct {
+    uint32_t transform_index;
+    uint32_t gamma;             /* gamma value x 1000 */
+    int brightness;
+    int saturation;
+    int hue;
+    int contrast;
+
+    DrawablePtr pDraw;
+    PixmapPtr pPixmap;
+    uint32_t src_pitch;
+    uint8_t *src_addr;
+    int src_w, src_h, dst_w, dst_h;
+    int src_x, src_y, drw_x, drw_y;
+    int w, h;
+    RegionRec clip;
+    PixmapPtr src_pix[3];       /* y, u, v for planar */
+    int src_pix_w, src_pix_h;
+} glamor_port_private;
+
+void glamor_init_xv_shader(ScreenPtr screen);
+void glamor_fini_xv_shader(ScreenPtr screen);
+
+#include"glamor_utils.h"
+
+/* Dynamic pixmap upload to texture if needed. 
+ * Sometimes, the target is a gl texture pixmap/picture,
+ * but the source or mask is in cpu memory. In that case,
+ * upload the source/mask to gl texture and then avoid 
+ * fallback the whole process to cpu. Most of the time,
+ * this will increase performance obviously. */
+
+#define GLAMOR_PIXMAP_DYNAMIC_UPLOAD
+#define GLAMOR_GRADIENT_SHADER
+#define GLAMOR_TRAPEZOID_SHADER
+#define GLAMOR_TEXTURED_LARGE_PIXMAP 1
+#define WALKAROUND_LARGE_TEXTURE_MAP
+#if 0
+#define MAX_FBO_SIZE 32         /* For test purpose only. */
+#endif
+//#define GLYPHS_NO_EDEGEMAP_OVERLAP_CHECK
+#define GLYPHS_EDEGE_OVERLAP_LOOSE_CHECK
+
+#include "glamor_font.h"
+
+#endif                          /* GLAMOR_PRIV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glamor_priv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86InPriv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86InPriv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86InPriv.h	(Revision 52145)
@@ -0,0 +1,40 @@
+
+/*
+ * Copyright (c) 1999 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86InPriv_h
+#define _xf86InPriv_h
+
+/* xf86Globals.c */
+extern InputDriverPtr *xf86InputDriverList;
+extern int xf86NumInputDrivers;
+
+#endif                          /* _xf86InPriv_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86InPriv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxclient.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxclient.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxclient.h	(Revision 52145)
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 1995  X Consortium
+ * Copyright 2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT, THE X CONSORTIUM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the X Consortium
+ * shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written
+ * authorization from the X Consortium.
+ */
+
+/*
+ * Derived from hw/xnest/Xnest.h by Rickard E. (Rik) Faith <faith@redhat.com>
+ */
+
+/** \file
+ * This file includes all client-side include files with proper wrapping.
+ */
+
+#ifndef _DMXCLIENT_H_
+#define _DMXCLIENT_H_
+
+#define GC XlibGC
+
+#ifdef _XSERVER64
+#define DMX64
+#undef _XSERVER64
+typedef unsigned long XID64;
+typedef unsigned long Mask64;
+typedef unsigned long Atom64;
+typedef unsigned long VisualID64;
+typedef unsigned long Time64;
+
+#define XID           XID64
+#define Mask          Mask64
+#define Atom          Atom64
+#define VisualID      VisualID64
+#define Time          Time64
+typedef XID Window64;
+typedef XID Drawable64;
+typedef XID Font64;
+typedef XID Pixmap64;
+typedef XID Cursor64;
+typedef XID Colormap64;
+typedef XID GContext64;
+typedef XID KeySym64;
+
+#define Window        Window64
+#define Drawable      Drawable64
+#define Font          Font64
+#define Pixmap        Pixmap64
+#define Cursor        Cursor64
+#define Colormap      Colormap64
+#define GContext      GContext64
+#define KeySym        KeySym64
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/Xlibint.h>        /* For _XExtension */
+#include <X11/X.h>              /* from glxserver.h */
+#include <X11/Xmd.h>            /* from glxserver.h */
+#include <X11/Xproto.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include <X11/cursorfont.h>
+
+#include <X11/extensions/shape.h>
+
+#include <X11/extensions/Xrender.h>
+#undef PictFormatType
+
+#include <X11/extensions/XKB.h>
+#include "xkbstr.h"
+
+#include <X11/extensions/XI.h>
+
+/* Always include these, since we query them even if we don't export XINPUT. */
+#include <X11/extensions/XInput.h>      /* For XDevice */
+#include <X11/extensions/Xext.h>
+
+#undef GC
+
+#ifdef DMX64
+#define _XSERVER64
+#undef XID
+#undef Mask
+#undef Atom
+#undef VisualID
+#undef Time
+#undef Window
+#undef Drawable
+#undef Font
+#undef Pixmap
+#undef Cursor
+#undef Colormap
+#undef GContext
+#undef KeySym
+#endif
+
+/* Some protocol gets included last, after undefines. */
+#include <X11/XKBlib.h>
+#include <X11/extensions/XKBproto.h>
+#include "xkbstr.h"
+#undef XPointer
+#include <X11/extensions/XIproto.h>
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxclient.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inputstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inputstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inputstr.h	(Revision 52145)
@@ -0,0 +1,673 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+#ifndef INPUTSTRUCT_H
+#define INPUTSTRUCT_H
+
+#include <X11/extensions/XI2proto.h>
+
+#include <pixman.h>
+#include "input.h"
+#include "window.h"
+#include "dixstruct.h"
+#include "cursorstr.h"
+#include "geext.h"
+#include "privates.h"
+
+#define BitIsOn(ptr, bit) (!!(((const BYTE *) (ptr))[(bit)>>3] & (1 << ((bit) & 7))))
+#define SetBit(ptr, bit)  (((BYTE *) (ptr))[(bit)>>3] |= (1 << ((bit) & 7)))
+#define ClearBit(ptr, bit) (((BYTE *)(ptr))[(bit)>>3] &= ~(1 << ((bit) & 7)))
+extern _X_EXPORT int CountBits(const uint8_t * mask, int len);
+
+#define SameClient(obj,client) \
+	(CLIENT_BITS((obj)->resource) == (client)->clientAsMask)
+
+#define EMASKSIZE	(MAXDEVICES + 2)
+
+/* This is the last XI2 event supported by the server. If you add
+ * events to the protocol, the server will not support these events until
+ * this number here is bumped.
+ */
+#define XI2LASTEVENT    XI_BarrierLeave
+#define XI2MASKSIZE     ((XI2LASTEVENT >> 3) + 1)       /* no of bytes for masks */
+
+/**
+ * Scroll types for ::SetScrollValuator and the scroll type in the
+ * ::ScrollInfoPtr.
+ */
+enum ScrollType {
+    SCROLL_TYPE_NONE = 0,           /**< Not a scrolling valuator */
+    SCROLL_TYPE_VERTICAL = 8,
+    SCROLL_TYPE_HORIZONTAL = 9,
+};
+
+/**
+ * This struct stores the core event mask for each client except the client
+ * that created the window.
+ *
+ * Each window that has events selected from other clients has at least one of
+ * these masks. If multiple clients selected for events on the same window,
+ * these masks are in a linked list.
+ *
+ * The event mask for the client that created the window is stored in
+ * win->eventMask instead.
+ *
+ * The resource id is simply a fake client ID to associate this mask with a
+ * client.
+ *
+ * Kludge: OtherClients and InputClients must be compatible, see code.
+ */
+typedef struct _OtherClients {
+    OtherClientsPtr next;     /**< Pointer to the next mask */
+    XID resource;                 /**< id for putting into resource manager */
+    Mask mask;                /**< Core event mask */
+} OtherClients;
+
+/**
+ * This struct stores the XI event mask for each client.
+ *
+ * Each window that has events selected has at least one of these masks. If
+ * multiple client selected for events on the same window, these masks are in
+ * a linked list.
+ */
+typedef struct _InputClients {
+    InputClientsPtr next;     /**< Pointer to the next mask */
+    XID resource;                 /**< id for putting into resource manager */
+    Mask mask[EMASKSIZE];                /**< Actual XI event mask, deviceid is index */
+    /** XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    struct _XI2Mask *xi2mask;
+} InputClients;
+
+/**
+ * Combined XI event masks from all devices.
+ *
+ * This is the XI equivalent of the deliverableEvents, eventMask and
+ * dontPropagate mask of the WindowRec (or WindowOptRec).
+ *
+ * A window that has an XI client selecting for events has exactly one
+ * OtherInputMasks struct and exactly one InputClients struct hanging off
+ * inputClients. Each further client appends to the inputClients list.
+ * Each Mask field is per-device, with the device id as the index.
+ * Exception: for non-device events (Presence events), the MAXDEVICES
+ * deviceid is used.
+ */
+typedef struct _OtherInputMasks {
+    /**
+     * Bitwise OR of all masks by all clients and the window's parent's masks.
+     */
+    Mask deliverableEvents[EMASKSIZE];
+    /**
+     * Bitwise OR of all masks by all clients on this window.
+     */
+    Mask inputEvents[EMASKSIZE];
+    /** The do-not-propagate masks for each device. */
+    Mask dontPropagateMask[EMASKSIZE];
+    /** The clients that selected for events */
+    InputClientsPtr inputClients;
+    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    struct _XI2Mask *xi2mask;
+} OtherInputMasks;
+
+/*
+ * The following structure gets used for both active and passive grabs. For
+ * active grabs some of the fields (e.g. modifiers) are not used. However,
+ * that is not much waste since there aren't many active grabs (one per
+ * keyboard/pointer device) going at once in the server.
+ */
+
+#define MasksPerDetailMask 8    /* 256 keycodes and 256 possible
+                                   modifier combinations, but only      
+                                   3 buttons. */
+
+typedef struct _DetailRec {     /* Grab details may be bit masks */
+    unsigned int exact;
+    Mask *pMask;
+} DetailRec;
+
+union _GrabMask {
+    Mask core;
+    Mask xi;
+    struct _XI2Mask *xi2mask;
+};
+
+/**
+ * Central struct for device grabs. 
+ * The same struct is used for both core grabs and device grabs, with
+ * different fields being set. 
+ * If the grab is a core grab (GrabPointer/GrabKeyboard), then the eventMask
+ * is a combination of standard event masks (i.e. PointerMotionMask |
+ * ButtonPressMask).
+ * If the grab is a device grab (GrabDevice), then the eventMask is a
+ * combination of event masks for a given XI event type (see SetEventInfo).
+ *
+ * If the grab is a result of a ButtonPress, then eventMask is the core mask
+ * and deviceMask is set to the XI event mask for the grab.
+ */
+typedef struct _GrabRec {
+    GrabPtr next;               /* for chain of passive grabs */
+    XID resource;
+    DeviceIntPtr device;
+    WindowPtr window;
+    unsigned ownerEvents:1;
+    unsigned keyboardMode:1;
+    unsigned pointerMode:1;
+    enum InputLevel grabtype;
+    CARD8 type;                 /* event type for passive grabs, 0 for active grabs */
+    DetailRec modifiersDetail;
+    DeviceIntPtr modifierDevice;
+    DetailRec detail;           /* key or button */
+    WindowPtr confineTo;        /* always NULL for keyboards */
+    CursorPtr cursor;           /* always NULL for keyboards */
+    Mask eventMask;
+    Mask deviceMask;
+    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    struct _XI2Mask *xi2mask;
+} GrabRec;
+
+/**
+ * Sprite information for a device.
+ */
+typedef struct _SpriteRec {
+    CursorPtr current;
+    BoxRec hotLimits;           /* logical constraints of hot spot */
+    Bool confined;              /* confined to screen */
+    RegionPtr hotShape;         /* additional logical shape constraint */
+    BoxRec physLimits;          /* physical constraints of hot spot */
+    WindowPtr win;              /* window of logical position */
+    HotSpot hot;                /* logical pointer position */
+    HotSpot hotPhys;            /* physical pointer position */
+#ifdef PANORAMIX
+    ScreenPtr screen;           /* all others are in Screen 0 coordinates */
+    RegionRec Reg1;             /* Region 1 for confining motion */
+    RegionRec Reg2;             /* Region 2 for confining virtual motion */
+    WindowPtr windows[MAXSCREENS];
+    WindowPtr confineWin;       /* confine window */
+#endif
+    /* The window trace information is used at dix/events.c to avoid having
+     * to compute all the windows between the root and the current pointer
+     * window each time a button or key goes down. The grabs on each of those
+     * windows must be checked.
+     * spriteTraces should only be used at dix/events.c! */
+    WindowPtr *spriteTrace;
+    int spriteTraceSize;
+    int spriteTraceGood;
+
+    /* Due to delays between event generation and event processing, it is
+     * possible that the pointer has crossed screen boundaries between the
+     * time in which it begins generating events and the time when
+     * those events are processed.
+     *
+     * pEnqueueScreen: screen the pointer was on when the event was generated
+     * pDequeueScreen: screen the pointer was on when the event is processed
+     */
+    ScreenPtr pEnqueueScreen;
+    ScreenPtr pDequeueScreen;
+
+} SpriteRec;
+
+typedef struct _KeyClassRec {
+    int sourceid;
+    CARD8 down[DOWN_LENGTH];
+    CARD8 postdown[DOWN_LENGTH];
+    int modifierKeyCount[8];
+    struct _XkbSrvInfo *xkbInfo;
+} KeyClassRec, *KeyClassPtr;
+
+typedef struct _ScrollInfo {
+    enum ScrollType type;
+    double increment;
+    int flags;
+} ScrollInfo, *ScrollInfoPtr;
+
+typedef struct _AxisInfo {
+    int resolution;
+    int min_resolution;
+    int max_resolution;
+    int min_value;
+    int max_value;
+    Atom label;
+    CARD8 mode;
+    ScrollInfo scroll;
+} AxisInfo, *AxisInfoPtr;
+
+typedef struct _ValuatorAccelerationRec {
+    int number;
+    PointerAccelSchemeProc AccelSchemeProc;
+    void *accelData;            /* at disposal of AccelScheme */
+    PointerAccelSchemeInitProc AccelInitProc;
+    DeviceCallbackProc AccelCleanupProc;
+} ValuatorAccelerationRec, *ValuatorAccelerationPtr;
+
+typedef struct _ValuatorClassRec {
+    int sourceid;
+    int numMotionEvents;
+    int first_motion;
+    int last_motion;
+    void *motion;               /* motion history buffer. Different layout
+                                   for MDs and SDs! */
+    WindowPtr motionHintWindow;
+
+    AxisInfoPtr axes;
+    unsigned short numAxes;
+    double *axisVal;            /* always absolute, but device-coord system */
+    ValuatorAccelerationRec accelScheme;
+    int h_scroll_axis;          /* horiz smooth-scrolling axis */
+    int v_scroll_axis;          /* vert smooth-scrolling axis */
+} ValuatorClassRec;
+
+typedef struct _TouchListener {
+    XID listener;           /* grabs/event selection IDs receiving
+                             * events for this touch */
+    int resource_type;      /* listener's resource type */
+    enum TouchListenerType type;
+    enum TouchListenerState state;
+    enum InputLevel level;  /* matters only for emulating touches */
+    WindowPtr window;
+    GrabPtr grab;
+} TouchListener;
+
+typedef struct _TouchPointInfo {
+    uint32_t client_id;         /* touch ID as seen in client events */
+    int sourceid;               /* Source device's ID for this touchpoint */
+    Bool active;                /* whether or not the touch is active */
+    Bool pending_finish;        /* true if the touch is physically inactive
+                                 * but still owned by a grab */
+    SpriteRec sprite;           /* window trace for delivery */
+    ValuatorMask *valuators;    /* last recorded axis values */
+    TouchListener *listeners;   /* set of listeners */
+    int num_listeners;
+    int num_grabs;              /* number of open grabs on this touch
+                                 * which have not accepted or rejected */
+    Bool emulate_pointer;
+    DeviceEvent *history;       /* History of events on this touchpoint */
+    size_t history_elements;    /* Number of current elements in history */
+    size_t history_size;        /* Size of history in elements */
+} TouchPointInfoRec;
+
+typedef struct _DDXTouchPointInfo {
+    uint32_t client_id;         /* touch ID as seen in client events */
+    Bool active;                /* whether or not the touch is active */
+    uint32_t ddx_id;            /* touch ID given by the DDX */
+    Bool emulate_pointer;
+
+    ValuatorMask *valuators;    /* last axis values as posted, pre-transform */
+} DDXTouchPointInfoRec;
+
+typedef struct _TouchClassRec {
+    int sourceid;
+    TouchPointInfoPtr touches;
+    unsigned short num_touches; /* number of allocated touches */
+    unsigned short max_touches; /* maximum number of touches, may be 0 */
+    CARD8 mode;                 /* ::XIDirectTouch, XIDependentTouch */
+    /* for pointer-emulation */
+    CARD8 buttonsDown;          /* number of buttons down */
+    unsigned short state;       /* logical button state */
+    Mask motionMask;
+} TouchClassRec;
+
+typedef struct _ButtonClassRec {
+    int sourceid;
+    CARD8 numButtons;
+    CARD8 buttonsDown;          /* number of buttons currently down
+                                   This counts logical buttons, not
+                                   physical ones, i.e if some buttons
+                                   are mapped to 0, they're not counted
+                                   here */
+    unsigned short state;
+    Mask motionMask;
+    CARD8 down[DOWN_LENGTH];
+    CARD8 postdown[DOWN_LENGTH];
+    CARD8 map[MAP_LENGTH];
+    union _XkbAction *xkb_acts;
+    Atom labels[MAX_BUTTONS];
+} ButtonClassRec, *ButtonClassPtr;
+
+typedef struct _FocusClassRec {
+    int sourceid;
+    WindowPtr win;              /* May be set to a int constant (e.g. PointerRootWin)! */
+    int revert;
+    TimeStamp time;
+    WindowPtr *trace;
+    int traceSize;
+    int traceGood;
+} FocusClassRec, *FocusClassPtr;
+
+typedef struct _ProximityClassRec {
+    int sourceid;
+    char in_proximity;
+} ProximityClassRec, *ProximityClassPtr;
+
+typedef struct _KbdFeedbackClassRec *KbdFeedbackPtr;
+typedef struct _PtrFeedbackClassRec *PtrFeedbackPtr;
+typedef struct _IntegerFeedbackClassRec *IntegerFeedbackPtr;
+typedef struct _StringFeedbackClassRec *StringFeedbackPtr;
+typedef struct _BellFeedbackClassRec *BellFeedbackPtr;
+typedef struct _LedFeedbackClassRec *LedFeedbackPtr;
+
+typedef struct _KbdFeedbackClassRec {
+    BellProcPtr BellProc;
+    KbdCtrlProcPtr CtrlProc;
+    KeybdCtrl ctrl;
+    KbdFeedbackPtr next;
+    struct _XkbSrvLedInfo *xkb_sli;
+} KbdFeedbackClassRec;
+
+typedef struct _PtrFeedbackClassRec {
+    PtrCtrlProcPtr CtrlProc;
+    PtrCtrl ctrl;
+    PtrFeedbackPtr next;
+} PtrFeedbackClassRec;
+
+typedef struct _IntegerFeedbackClassRec {
+    IntegerCtrlProcPtr CtrlProc;
+    IntegerCtrl ctrl;
+    IntegerFeedbackPtr next;
+} IntegerFeedbackClassRec;
+
+typedef struct _StringFeedbackClassRec {
+    StringCtrlProcPtr CtrlProc;
+    StringCtrl ctrl;
+    StringFeedbackPtr next;
+} StringFeedbackClassRec;
+
+typedef struct _BellFeedbackClassRec {
+    BellProcPtr BellProc;
+    BellCtrlProcPtr CtrlProc;
+    BellCtrl ctrl;
+    BellFeedbackPtr next;
+} BellFeedbackClassRec;
+
+typedef struct _LedFeedbackClassRec {
+    LedCtrlProcPtr CtrlProc;
+    LedCtrl ctrl;
+    LedFeedbackPtr next;
+    struct _XkbSrvLedInfo *xkb_sli;
+} LedFeedbackClassRec;
+
+typedef struct _ClassesRec {
+    KeyClassPtr key;
+    ValuatorClassPtr valuator;
+    TouchClassPtr touch;
+    ButtonClassPtr button;
+    FocusClassPtr focus;
+    ProximityClassPtr proximity;
+    KbdFeedbackPtr kbdfeed;
+    PtrFeedbackPtr ptrfeed;
+    IntegerFeedbackPtr intfeed;
+    StringFeedbackPtr stringfeed;
+    BellFeedbackPtr bell;
+    LedFeedbackPtr leds;
+} ClassesRec;
+
+/* Device properties */
+typedef struct _XIPropertyValue {
+    Atom type;                  /* ignored by server */
+    short format;               /* format of data for swapping - 8,16,32 */
+    long size;                  /* size of data in (format/8) bytes */
+    void *data;                 /* private to client */
+} XIPropertyValueRec;
+
+typedef struct _XIProperty {
+    struct _XIProperty *next;
+    Atom propertyName;
+    BOOL deletable;             /* clients can delete this prop? */
+    XIPropertyValueRec value;
+} XIPropertyRec;
+
+typedef XIPropertyRec *XIPropertyPtr;
+typedef XIPropertyValueRec *XIPropertyValuePtr;
+
+typedef struct _XIPropertyHandler {
+    struct _XIPropertyHandler *next;
+    long id;
+    int (*SetProperty) (DeviceIntPtr dev,
+                        Atom property, XIPropertyValuePtr prop, BOOL checkonly);
+    int (*GetProperty) (DeviceIntPtr dev, Atom property);
+    int (*DeleteProperty) (DeviceIntPtr dev, Atom property);
+} XIPropertyHandler, *XIPropertyHandlerPtr;
+
+/* states for devices */
+
+#define NOT_GRABBED		0
+#define THAWED			1
+#define THAWED_BOTH		2       /* not a real state */
+#define FREEZE_NEXT_EVENT	3
+#define FREEZE_BOTH_NEXT_EVENT	4
+#define FROZEN			5       /* any state >= has device frozen */
+#define FROZEN_NO_EVENT		5
+#define FROZEN_WITH_EVENT	6
+#define THAW_OTHERS		7
+
+typedef struct _GrabInfoRec {
+    TimeStamp grabTime;
+    Bool fromPassiveGrab;       /* true if from passive grab */
+    Bool implicitGrab;          /* implicit from ButtonPress */
+    GrabPtr unused;             /* Kept for ABI stability, remove soon */
+    GrabPtr grab;
+    CARD8 activatingKey;
+    void (*ActivateGrab) (DeviceIntPtr /*device */ ,
+                          GrabPtr /*grab */ ,
+                          TimeStamp /*time */ ,
+                          Bool /*autoGrab */ );
+    void (*DeactivateGrab) (DeviceIntPtr /*device */ );
+    struct {
+        Bool frozen;
+        int state;
+        GrabPtr other;          /* if other grab has this frozen */
+        DeviceEvent *event;     /* saved to be replayed */
+    } sync;
+} GrabInfoRec, *GrabInfoPtr;
+
+typedef struct _SpriteInfoRec {
+    /* sprite must always point to a valid sprite. For devices sharing the
+     * sprite, let sprite point to a paired spriteOwner's sprite. */
+    SpritePtr sprite;           /* sprite information */
+    Bool spriteOwner;           /* True if device owns the sprite */
+    DeviceIntPtr paired;        /* The paired device. Keyboard if
+                                   spriteOwner is TRUE, otherwise the
+                                   pointer that owns the sprite. */
+
+    /* keep states for animated cursor */
+    struct {
+        CursorPtr pCursor;
+        ScreenPtr pScreen;
+        int elt;
+        CARD32 time;
+    } anim;
+} SpriteInfoRec, *SpriteInfoPtr;
+
+/* device types */
+#define MASTER_POINTER          1
+#define MASTER_KEYBOARD         2
+#define SLAVE                   3
+/* special types for GetMaster */
+#define MASTER_ATTACHED         4       /* Master for this device */
+#define KEYBOARD_OR_FLOAT       5       /* Keyboard master for this device or this device if floating */
+#define POINTER_OR_FLOAT        6       /* Pointer master for this device or this device if floating */
+
+typedef struct _DeviceIntRec {
+    DeviceRec public;
+    DeviceIntPtr next;
+    Bool startup;               /* true if needs to be turned on at
+                                   server initialization time */
+    DeviceProc deviceProc;      /* proc(DevicePtr, DEVICE_xx). It is
+                                   used to initialize, turn on, or
+                                   turn off the device */
+    Bool inited;                /* TRUE if INIT returns Success */
+    Bool enabled;               /* TRUE if ON returns Success */
+    Bool coreEvents;            /* TRUE if device also sends core */
+    GrabInfoRec deviceGrab;     /* grab on the device */
+    int type;                   /* MASTER_POINTER, MASTER_KEYBOARD, SLAVE */
+    Atom xinput_type;
+    char *name;
+    int id;
+    KeyClassPtr key;
+    ValuatorClassPtr valuator;
+    TouchClassPtr touch;
+    ButtonClassPtr button;
+    FocusClassPtr focus;
+    ProximityClassPtr proximity;
+    KbdFeedbackPtr kbdfeed;
+    PtrFeedbackPtr ptrfeed;
+    IntegerFeedbackPtr intfeed;
+    StringFeedbackPtr stringfeed;
+    BellFeedbackPtr bell;
+    LedFeedbackPtr leds;
+    struct _XkbInterest *xkb_interest;
+    char *config_info;          /* used by the hotplug layer */
+    ClassesPtr unused_classes;  /* for master devices */
+    int saved_master_id;        /* for slaves while grabbed */
+    PrivateRec *devPrivates;
+    DeviceUnwrapProc unwrapProc;
+    SpriteInfoPtr spriteInfo;
+    DeviceIntPtr master;        /* master device */
+    DeviceIntPtr lastSlave;     /* last slave device used */
+
+    /* last valuator values recorded, not posted to client;
+     * for slave devices, valuators is in device coordinates, mapped to the
+     * desktop
+     * for master devices, valuators is in desktop coordinates.
+     * see dix/getevents.c
+     * remainder supports acceleration
+     */
+    struct {
+        double valuators[MAX_VALUATORS];
+        int numValuators;
+        DeviceIntPtr slave;
+        ValuatorMask *scroll;
+        int num_touches;        /* size of the touches array */
+        DDXTouchPointInfoPtr touches;
+    } last;
+
+    /* Input device property handling. */
+    struct {
+        XIPropertyPtr properties;
+        XIPropertyHandlerPtr handlers;  /* NULL-terminated */
+    } properties;
+
+    /* coordinate transformation matrix for relative movement. Matrix with
+     * the translation component dropped */
+    struct pixman_f_transform relative_transform;
+    /* scale matrix for absolute devices, this is the combined matrix of
+       [1/scale] . [transform] . [scale]. See DeviceSetTransform */
+    struct pixman_f_transform scale_and_transform;
+
+    /* XTest related master device id */
+    int xtest_master_id;
+
+    struct _SyncCounter *idle_counter;
+} DeviceIntRec;
+
+typedef struct {
+    int numDevices;             /* total number of devices */
+    DeviceIntPtr devices;       /* all devices turned on */
+    DeviceIntPtr off_devices;   /* all devices turned off */
+    DeviceIntPtr keyboard;      /* the main one for the server */
+    DeviceIntPtr pointer;
+    DeviceIntPtr all_devices;
+    DeviceIntPtr all_master_devices;
+} InputInfo;
+
+extern _X_EXPORT InputInfo inputInfo;
+
+/* for keeping the events for devices grabbed synchronously */
+typedef struct _QdEvent *QdEventPtr;
+typedef struct _QdEvent {
+    struct xorg_list next;
+    DeviceIntPtr device;
+    ScreenPtr pScreen;          /* what screen the pointer was on */
+    unsigned long months;       /* milliseconds is in the event */
+    InternalEvent *event;
+} QdEventRec;
+
+/**
+ * syncEvents is the global structure for queued events.
+ *
+ * Devices can be frozen through GrabModeSync pointer grabs. If this is the
+ * case, events from these devices are added to "pending" instead of being
+ * processed normally. When the device is unfrozen, events in "pending" are
+ * replayed and processed as if they would come from the device directly.
+ */
+typedef struct _EventSyncInfo {
+    struct xorg_list pending;
+
+    /** The device to replay events for. Only set in AllowEvents(), in which
+     * case it is set to the device specified in the request. */
+    DeviceIntPtr replayDev;     /* kludgy rock to put flag for */
+
+    /**
+     * The window the events are supposed to be replayed on.
+     * This window may be set to the grab's window (but only when
+     * Replay{Pointer|Keyboard} is given in the XAllowEvents()
+     * request. */
+    WindowPtr replayWin;        /*   ComputeFreezes            */
+    /**
+     * Flag to indicate whether we're in the process of
+     * replaying events. Only set in ComputeFreezes(). */
+    Bool playingEvents;
+    TimeStamp time;
+} EventSyncInfoRec, *EventSyncInfoPtr;
+
+extern EventSyncInfoRec syncEvents;
+
+/**
+ * Given a sprite, returns the window at the bottom of the trace (i.e. the
+ * furthest window from the root).
+ */
+static inline WindowPtr
+DeepestSpriteWin(SpritePtr sprite)
+{
+    assert(sprite->spriteTraceGood > 0);
+    return sprite->spriteTrace[sprite->spriteTraceGood - 1];
+}
+
+struct _XI2Mask {
+    unsigned char **masks;      /* event mask in masks[deviceid][event type byte] */
+    size_t nmasks;              /* number of masks */
+    size_t mask_size;           /* size of each mask in bytes */
+};
+
+#endif                          /* INPUTSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/inputstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fboverlay.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fboverlay.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fboverlay.h	(Revision 52145)
@@ -0,0 +1,112 @@
+/*
+ *
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _FBOVERLAY_H_
+#define _FBOVERLAY_H_
+
+#include "privates.h"
+
+extern _X_EXPORT DevPrivateKey fbOverlayGetScreenPrivateKey(void);
+
+#ifndef FB_OVERLAY_MAX
+#define FB_OVERLAY_MAX	2
+#endif
+
+typedef void (*fbOverlayPaintKeyProc) (DrawablePtr, RegionPtr, CARD32, int);
+
+typedef struct _fbOverlayLayer {
+    union {
+        struct {
+            void *pbits;
+            int width;
+            int depth;
+        } init;
+        struct {
+            PixmapPtr pixmap;
+            RegionRec region;
+        } run;
+    } u;
+    CARD32 key;                 /* special pixel value */
+} FbOverlayLayer;
+
+typedef struct _fbOverlayScrPriv {
+    int nlayers;
+    fbOverlayPaintKeyProc PaintKey;
+    miCopyProc CopyWindow;
+    FbOverlayLayer layer[FB_OVERLAY_MAX];
+} FbOverlayScrPrivRec, *FbOverlayScrPrivPtr;
+
+#define fbOverlayGetScrPriv(s) \
+    dixLookupPrivate(&(s)->devPrivates, fbOverlayGetScreenPrivateKey())
+extern _X_EXPORT Bool
+ fbOverlayCreateWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+ fbOverlayCloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT int
+ fbOverlayWindowLayer(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+ fbOverlayCreateScreenResources(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+
+fbOverlayPaintKey(DrawablePtr pDrawable,
+                  RegionPtr pRegion, CARD32 pixel, int layer);
+extern _X_EXPORT void
+ fbOverlayUpdateLayerRegion(ScreenPtr pScreen, int layer, RegionPtr prgn);
+
+extern _X_EXPORT void
+ fbOverlayCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+extern _X_EXPORT void
+
+fbOverlayWindowExposures(WindowPtr pWin,
+                         RegionPtr prgn, RegionPtr other_exposed);
+
+extern _X_EXPORT Bool
+
+fbOverlaySetupScreen(ScreenPtr pScreen,
+                     void *pbits1,
+                     void *pbits2,
+                     int xsize,
+                     int ysize,
+                     int dpix,
+                     int dpiy, int width1, int width2, int bpp1, int bpp2);
+
+extern _X_EXPORT Bool
+
+fbOverlayFinishScreenInit(ScreenPtr pScreen,
+                          void *pbits1,
+                          void *pbits2,
+                          int xsize,
+                          int ysize,
+                          int dpix,
+                          int dpiy,
+                          int width1,
+                          int width2,
+                          int bpp1, int bpp2, int depth1, int depth2);
+
+#endif                          /* _FBOVERLAY_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fboverlay.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinuxint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinuxint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinuxint.h	(Revision 52145)
@@ -0,0 +1,564 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XSELINUXINT_H
+#define _XSELINUXINT_H
+
+#include <selinux/selinux.h>
+#include <selinux/avc.h>
+
+#include "globals.h"
+#include "dixaccess.h"
+#include "dixstruct.h"
+#include "privates.h"
+#include "resource.h"
+#include "registry.h"
+#include "inputstr.h"
+#include "xselinux.h"
+
+/*
+ * Types
+ */
+
+#define COMMAND_LEN 64
+
+/* subject state (clients and devices only) */
+typedef struct {
+    security_id_t sid;
+    security_id_t dev_create_sid;
+    security_id_t win_create_sid;
+    security_id_t sel_create_sid;
+    security_id_t prp_create_sid;
+    security_id_t sel_use_sid;
+    security_id_t prp_use_sid;
+    struct avc_entry_ref aeref;
+    char command[COMMAND_LEN];
+    int privileged;
+} SELinuxSubjectRec;
+
+/* object state */
+typedef struct {
+    security_id_t sid;
+    int poly;
+} SELinuxObjectRec;
+
+/*
+ * Globals
+ */
+
+extern DevPrivateKeyRec subjectKeyRec;
+
+#define subjectKey (&subjectKeyRec)
+extern DevPrivateKeyRec objectKeyRec;
+
+#define objectKey (&objectKeyRec)
+extern DevPrivateKeyRec dataKeyRec;
+
+#define dataKey (&dataKeyRec)
+
+/*
+ * Label functions
+ */
+
+int
+ SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec ** obj_rtn);
+
+int
+
+SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec * subj,
+                      security_id_t * sid_rtn, int *poly_rtn);
+
+int
+
+SELinuxPropertyToSID(Atom property, SELinuxSubjectRec * subj,
+                     security_id_t * sid_rtn, int *poly_rtn);
+
+int
+
+SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
+                  SELinuxObjectRec * sid_return);
+
+int
+ SELinuxExtensionToSID(const char *name, security_id_t * sid_rtn);
+
+security_class_t SELinuxTypeToClass(RESTYPE type);
+
+security_context_t SELinuxDefaultClientLabel(void);
+
+void
+ SELinuxLabelInit(void);
+
+void
+ SELinuxLabelReset(void);
+
+/*
+ * Security module functions
+ */
+
+void
+ SELinuxFlaskInit(void);
+
+void
+ SELinuxFlaskReset(void);
+
+/*
+ * Private Flask definitions
+ */
+
+/* Security class constants */
+#define SECCLASS_X_DRAWABLE		1
+#define SECCLASS_X_SCREEN		2
+#define SECCLASS_X_GC			3
+#define SECCLASS_X_FONT			4
+#define SECCLASS_X_COLORMAP		5
+#define SECCLASS_X_PROPERTY		6
+#define SECCLASS_X_SELECTION		7
+#define SECCLASS_X_CURSOR		8
+#define SECCLASS_X_CLIENT		9
+#define SECCLASS_X_POINTER		10
+#define SECCLASS_X_KEYBOARD		11
+#define SECCLASS_X_SERVER		12
+#define SECCLASS_X_EXTENSION		13
+#define SECCLASS_X_EVENT		14
+#define SECCLASS_X_FAKEEVENT		15
+#define SECCLASS_X_RESOURCE		16
+
+#ifdef _XSELINUX_NEED_FLASK_MAP
+/* Mapping from DixAccess bits to Flask permissions */
+static struct security_class_mapping map[] = {
+    {"x_drawable",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "list_property",          /* DixListPropAccess */
+      "get_property",           /* DixGetPropAccess */
+      "set_property",           /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "list_child",             /* DixListAccess */
+      "add_child",              /* DixAddAccess */
+      "remove_child",           /* DixRemoveAccess */
+      "hide",                   /* DixHideAccess */
+      "show",                   /* DixShowAccess */
+      "blend",                  /* DixBlendAccess */
+      "override",               /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "send",                   /* DixSendAccess */
+      "receive",                /* DixReceiveAccess */
+      "",                       /* DixUseAccess */
+      "manage",                 /* DixManageAccess */
+      NULL}},
+    {"x_screen",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "saver_getattr",          /* DixListPropAccess */
+      "saver_setattr",          /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "hide_cursor",            /* DixHideAccess */
+      "show_cursor",            /* DixShowAccess */
+      "saver_hide",             /* DixBlendAccess */
+      "saver_show",             /* DixGrabAccess */
+      NULL}},
+    {"x_gc",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      NULL}},
+    {"x_font",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "",                       /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "add_glyph",              /* DixAddAccess */
+      "remove_glyph",           /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      NULL}},
+    {"x_colormap",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "",                       /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "add_color",              /* DixAddAccess */
+      "remove_color",           /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "install",                /* DixInstallAccess */
+      "uninstall",              /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      NULL}},
+    {"x_property",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "write",                  /* DixBlendAccess */
+      NULL}},
+    {"x_selection",
+     {"read",                   /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "setattr",                /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      NULL}},
+    {"x_cursor",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      NULL}},
+    {"x_client",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "",                       /* DixUseAccess */
+      "manage",                 /* DixManageAccess */
+      NULL}},
+    {"x_pointer",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "list_property",          /* DixListPropAccess */
+      "get_property",           /* DixGetPropAccess */
+      "set_property",           /* DixSetPropAccess */
+      "getfocus",               /* DixGetFocusAccess */
+      "setfocus",               /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "add",                    /* DixAddAccess */
+      "remove",                 /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "grab",                   /* DixGrabAccess */
+      "freeze",                 /* DixFreezeAccess */
+      "force_cursor",           /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      "manage",                 /* DixManageAccess */
+      "",                       /* DixDebugAccess */
+      "bell",                   /* DixBellAccess */
+      NULL}},
+    {"x_keyboard",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "destroy",                /* DixDestroyAccess */
+      "create",                 /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "list_property",          /* DixListPropAccess */
+      "get_property",           /* DixGetPropAccess */
+      "set_property",           /* DixSetPropAccess */
+      "getfocus",               /* DixGetFocusAccess */
+      "setfocus",               /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "add",                    /* DixAddAccess */
+      "remove",                 /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "grab",                   /* DixGrabAccess */
+      "freeze",                 /* DixFreezeAccess */
+      "force_cursor",           /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      "manage",                 /* DixManageAccess */
+      "",                       /* DixDebugAccess */
+      "bell",                   /* DixBellAccess */
+      NULL}},
+    {"x_server",
+     {"record",                 /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "getattr",                /* DixGetAttrAccess */
+      "setattr",                /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "grab",                   /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "",                       /* DixUseAccess */
+      "manage",                 /* DixManageAccess */
+      "debug",                  /* DixDebugAccess */
+      NULL}},
+    {"x_extension",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "query",                  /* DixGetAttrAccess */
+      "",                       /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "",                       /* DixSendAccess */
+      "",                       /* DixReceiveAccess */
+      "use",                    /* DixUseAccess */
+      NULL}},
+    {"x_event",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "",                       /* DixGetAttrAccess */
+      "",                       /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "send",                   /* DixSendAccess */
+      "receive",                /* DixReceiveAccess */
+      NULL}},
+    {"x_synthetic_event",
+     {"",                       /* DixReadAccess */
+      "",                       /* DixWriteAccess */
+      "",                       /* DixDestroyAccess */
+      "",                       /* DixCreateAccess */
+      "",                       /* DixGetAttrAccess */
+      "",                       /* DixSetAttrAccess */
+      "",                       /* DixListPropAccess */
+      "",                       /* DixGetPropAccess */
+      "",                       /* DixSetPropAccess */
+      "",                       /* DixGetFocusAccess */
+      "",                       /* DixSetFocusAccess */
+      "",                       /* DixListAccess */
+      "",                       /* DixAddAccess */
+      "",                       /* DixRemoveAccess */
+      "",                       /* DixHideAccess */
+      "",                       /* DixShowAccess */
+      "",                       /* DixBlendAccess */
+      "",                       /* DixGrabAccess */
+      "",                       /* DixFreezeAccess */
+      "",                       /* DixForceAccess */
+      "",                       /* DixInstallAccess */
+      "",                       /* DixUninstallAccess */
+      "send",                   /* DixSendAccess */
+      "receive",                /* DixReceiveAccess */
+      NULL}},
+    {"x_resource",
+     {"read",                   /* DixReadAccess */
+      "write",                  /* DixWriteAccess */
+      "write",                  /* DixDestroyAccess */
+      "write",                  /* DixCreateAccess */
+      "read",                   /* DixGetAttrAccess */
+      "write",                  /* DixSetAttrAccess */
+      "read",                   /* DixListPropAccess */
+      "read",                   /* DixGetPropAccess */
+      "write",                  /* DixSetPropAccess */
+      "read",                   /* DixGetFocusAccess */
+      "write",                  /* DixSetFocusAccess */
+      "read",                   /* DixListAccess */
+      "write",                  /* DixAddAccess */
+      "write",                  /* DixRemoveAccess */
+      "write",                  /* DixHideAccess */
+      "read",                   /* DixShowAccess */
+      "read",                   /* DixBlendAccess */
+      "write",                  /* DixGrabAccess */
+      "write",                  /* DixFreezeAccess */
+      "write",                  /* DixForceAccess */
+      "write",                  /* DixInstallAccess */
+      "write",                  /* DixUninstallAccess */
+      "write",                  /* DixSendAccess */
+      "read",                   /* DixReceiveAccess */
+      "read",                   /* DixUseAccess */
+      "write",                  /* DixManageAccess */
+      "read",                   /* DixDebugAccess */
+      "write",                  /* DixBellAccess */
+      NULL}},
+    {NULL}
+};
+
+/* x_resource "read" bits from the list above */
+#define SELinuxReadMask (DixReadAccess|DixGetAttrAccess|DixListPropAccess| \
+			 DixGetPropAccess|DixGetFocusAccess|DixListAccess| \
+			 DixShowAccess|DixBlendAccess|DixReceiveAccess| \
+			 DixUseAccess|DixDebugAccess)
+
+#endif                          /* _XSELINUX_NEED_FLASK_MAP */
+#endif                          /* _XSELINUXINT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xselinuxint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setbmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setbmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setbmap.h	(Revision 52145)
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETBMAP_H
+#define SETBMAP_H 1
+
+int SProcXSetDeviceButtonMapping(ClientPtr      /* client */
+    );
+
+int ProcXSetDeviceButtonMapping(ClientPtr       /* client */
+    );
+
+void SRepXSetDeviceButtonMapping(ClientPtr /* client */ ,
+                                 int /* size */ ,
+                                 xSetDeviceButtonMappingReply * /* rep */
+    );
+
+#endif                          /* SETBMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/setbmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxsingle.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxsingle.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxsingle.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef __GLXSINGLE_H
+#define __GLXSINGLE_H
+
+extern int __glXForwardSingleReq(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardPipe0WithReply(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardAllWithReply(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXForwardSingleReqSwap(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXForwardPipe0WithReplySwap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardPipe0WithReplySwapsv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardPipe0WithReplySwapiv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardPipe0WithReplySwapdv(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXForwardAllWithReplySwap(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardAllWithReplySwapsv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardAllWithReplySwapiv(__GLXclientState * cl, GLbyte * pc);
+extern int __glXForwardAllWithReplySwapdv(__GLXclientState * cl, GLbyte * pc);
+
+extern int __glXDisp_ReadPixels(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDispSwap_GetTexImage(__GLXclientState * cl, GLbyte * pc);
+extern int __glXDispSwap_GetColorTable(__GLXclientState * cl, GLbyte * pc);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxsingle.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix-config-apple-verbatim.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix-config-apple-verbatim.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix-config-apple-verbatim.h	(Revision 52145)
@@ -0,0 +1,8 @@
+/* Do not include this file directly.  It is included at the end of <dix-config.h> */
+
+/* Correctly set _XSERVER64 for OSX fat binaries */
+#if defined(__LP64__) && !defined(_XSERVER64)
+#define _XSERVER64 1
+#elif !defined(__LP64__) && defined(_XSERVER64)
+#undef _XSERVER64
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dix-config-apple-verbatim.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86fbman.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86fbman.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86fbman.h	(Revision 52145)
@@ -0,0 +1,171 @@
+
+/*
+ * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86FBMAN_H
+#define _XF86FBMAN_H
+
+#include "scrnintstr.h"
+#include "regionstr.h"
+
+#define FAVOR_AREA_THEN_WIDTH		0
+#define FAVOR_AREA_THEN_HEIGHT		1
+#define FAVOR_WIDTH_THEN_AREA		2
+#define FAVOR_HEIGHT_THEN_AREA		3
+
+#define PRIORITY_LOW			0
+#define PRIORITY_NORMAL			1
+#define PRIORITY_EXTREME		2
+
+typedef struct _FBArea {
+    ScreenPtr pScreen;
+    BoxRec box;
+    int granularity;
+    void (*MoveAreaCallback) (struct _FBArea *, struct _FBArea *);
+    void (*RemoveAreaCallback) (struct _FBArea *);
+    DevUnion devPrivate;
+} FBArea, *FBAreaPtr;
+
+typedef struct _FBLinear {
+    ScreenPtr pScreen;
+    int size;
+    int offset;
+    int granularity;
+    void (*MoveLinearCallback) (struct _FBLinear *, struct _FBLinear *);
+    void (*RemoveLinearCallback) (struct _FBLinear *);
+    DevUnion devPrivate;
+} FBLinear, *FBLinearPtr;
+
+typedef void (*FreeBoxCallbackProcPtr) (ScreenPtr, RegionPtr, void *);
+typedef void (*MoveAreaCallbackProcPtr) (FBAreaPtr, FBAreaPtr);
+typedef void (*RemoveAreaCallbackProcPtr) (FBAreaPtr);
+
+typedef void (*MoveLinearCallbackProcPtr) (FBLinearPtr, FBLinearPtr);
+typedef void (*RemoveLinearCallbackProcPtr) (FBLinearPtr);
+
+typedef struct {
+    FBAreaPtr(*AllocateOffscreenArea) (ScreenPtr pScreen,
+                                       int w, int h,
+                                       int granularity,
+                                       MoveAreaCallbackProcPtr moveCB,
+                                       RemoveAreaCallbackProcPtr removeCB,
+                                       void *privData);
+    void (*FreeOffscreenArea) (FBAreaPtr area);
+    Bool (*ResizeOffscreenArea) (FBAreaPtr area, int w, int h);
+    Bool (*QueryLargestOffscreenArea) (ScreenPtr pScreen,
+                                       int *width, int *height,
+                                       int granularity,
+                                       int preferences, int priority);
+    Bool (*RegisterFreeBoxCallback) (ScreenPtr pScreen,
+                                     FreeBoxCallbackProcPtr FreeBoxCallback,
+                                     void *devPriv);
+/* linear functions */
+     FBLinearPtr(*AllocateOffscreenLinear) (ScreenPtr pScreen,
+                                            int size,
+                                            int granularity,
+                                            MoveLinearCallbackProcPtr moveCB,
+                                            RemoveLinearCallbackProcPtr
+                                            removeCB, void *privData);
+    void (*FreeOffscreenLinear) (FBLinearPtr area);
+    Bool (*ResizeOffscreenLinear) (FBLinearPtr area, int size);
+    Bool (*QueryLargestOffscreenLinear) (ScreenPtr pScreen,
+                                         int *size,
+                                         int granularity, int priority);
+    Bool (*PurgeOffscreenAreas) (ScreenPtr);
+} FBManagerFuncs, *FBManagerFuncsPtr;
+
+extern _X_EXPORT Bool xf86RegisterOffscreenManager(ScreenPtr pScreen,
+                                                   FBManagerFuncsPtr funcs);
+
+extern _X_EXPORT Bool
+ xf86InitFBManagerRegion(ScreenPtr pScreen, RegionPtr ScreenRegion);
+
+extern _X_EXPORT Bool
+ xf86InitFBManagerArea(ScreenPtr pScreen, int PixalArea, int Verbosity);
+
+extern _X_EXPORT Bool
+ xf86InitFBManager(ScreenPtr pScreen, BoxPtr FullBox);
+
+extern _X_EXPORT Bool
+ xf86InitFBManagerLinear(ScreenPtr pScreen, int offset, int size);
+
+extern _X_EXPORT Bool
+ xf86FBManagerRunning(ScreenPtr pScreen);
+
+extern _X_EXPORT FBAreaPtr
+xf86AllocateOffscreenArea(ScreenPtr pScreen,
+                          int w, int h,
+                          int granularity,
+                          MoveAreaCallbackProcPtr moveCB,
+                          RemoveAreaCallbackProcPtr removeCB, void *privData);
+
+extern _X_EXPORT FBAreaPtr
+xf86AllocateLinearOffscreenArea(ScreenPtr pScreen,
+                                int length,
+                                int granularity,
+                                MoveAreaCallbackProcPtr moveCB,
+                                RemoveAreaCallbackProcPtr removeCB,
+                                void *privData);
+
+extern _X_EXPORT FBLinearPtr
+xf86AllocateOffscreenLinear(ScreenPtr pScreen,
+                            int length,
+                            int granularity,
+                            MoveLinearCallbackProcPtr moveCB,
+                            RemoveLinearCallbackProcPtr removeCB,
+                            void *privData);
+
+extern _X_EXPORT void xf86FreeOffscreenArea(FBAreaPtr area);
+extern _X_EXPORT void xf86FreeOffscreenLinear(FBLinearPtr area);
+
+extern _X_EXPORT Bool
+ xf86ResizeOffscreenArea(FBAreaPtr resize, int w, int h);
+
+extern _X_EXPORT Bool
+ xf86ResizeOffscreenLinear(FBLinearPtr resize, int size);
+
+extern _X_EXPORT Bool
+
+xf86RegisterFreeBoxCallback(ScreenPtr pScreen,
+                            FreeBoxCallbackProcPtr FreeBoxCallback,
+                            void *devPriv);
+
+extern _X_EXPORT Bool
+ xf86PurgeUnlockedOffscreenAreas(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+
+xf86QueryLargestOffscreenArea(ScreenPtr pScreen,
+                              int *width, int *height,
+                              int granularity, int preferences, int priority);
+
+extern _X_EXPORT Bool
+
+xf86QueryLargestOffscreenLinear(ScreenPtr pScreen,
+                                int *size, int granularity, int priority);
+
+#endif                          /* _XF86FBMAN_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86fbman.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/windowstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/windowstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/windowstr.h	(Revision 52145)
@@ -0,0 +1,221 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef WINDOWSTRUCT_H
+#define WINDOWSTRUCT_H
+
+#include "window.h"
+#include "pixmapstr.h"
+#include "regionstr.h"
+#include "cursor.h"
+#include "property.h"
+#include "resource.h"           /* for ROOT_WINDOW_ID_BASE */
+#include "dix.h"
+#include "privates.h"
+#include "miscstruct.h"
+#include <X11/Xprotostr.h>
+#include "opaque.h"
+
+#define GuaranteeNothing	0
+#define GuaranteeVisBack	1
+
+#define SameBackground(as, a, bs, b)				\
+    ((as) == (bs) && ((as) == None ||				\
+		      (as) == ParentRelative ||			\
+ 		      SamePixUnion(a,b,as == BackgroundPixel)))
+
+#define SameBorder(as, a, bs, b)				\
+    EqualPixUnion(as, a, bs, b)
+
+/* used as NULL-terminated list */
+typedef struct _DevCursorNode {
+    CursorPtr cursor;
+    DeviceIntPtr dev;
+    struct _DevCursorNode *next;
+} DevCursNodeRec, *DevCursNodePtr, *DevCursorList;
+
+typedef struct _WindowOpt {
+    CursorPtr cursor;           /* default: window.cursorNone */
+    VisualID visual;            /* default: same as parent */
+    Colormap colormap;          /* default: same as parent */
+    Mask dontPropagateMask;     /* default: window.dontPropagate */
+    Mask otherEventMasks;       /* default: 0 */
+    struct _OtherClients *otherClients; /* default: NULL */
+    struct _GrabRec *passiveGrabs;      /* default: NULL */
+    PropertyPtr userProps;      /* default: NULL */
+    CARD32 backingBitPlanes;    /* default: ~0L */
+    CARD32 backingPixel;        /* default: 0 */
+    RegionPtr boundingShape;    /* default: NULL */
+    RegionPtr clipShape;        /* default: NULL */
+    RegionPtr inputShape;       /* default: NULL */
+    struct _OtherInputMasks *inputMasks;        /* default: NULL */
+    DevCursorList deviceCursors;        /* default: NULL */
+} WindowOptRec, *WindowOptPtr;
+
+#define BackgroundPixel	    2L
+#define BackgroundPixmap    3L
+
+/*
+ * The redirectDraw field can have one of three values:
+ *
+ *  RedirectDrawNone
+ *	A normal window; painted into the same pixmap as the parent
+ *	and clipping parent and siblings to its geometry. These
+ *	windows get a clip list equal to the intersection of their
+ *	geometry with the parent geometry, minus the geometry
+ *	of overlapping None and Clipped siblings.
+ *  RedirectDrawAutomatic
+ *	A redirected window which clips parent and sibling drawing.
+ *	Contents for these windows are manage inside the server.
+ *	These windows get an internal clip list equal to their
+ *	geometry.
+ *  RedirectDrawManual
+ *	A redirected window which does not clip parent and sibling
+ *	drawing; the window must be represented within the parent
+ *	geometry by the client performing the redirection management.
+ *	Contents for these windows are managed outside the server.
+ *	These windows get an internal clip list equal to their
+ *	geometry.
+ */
+
+#define RedirectDrawNone	0
+#define RedirectDrawAutomatic	1
+#define RedirectDrawManual	2
+
+typedef struct _Window {
+    DrawableRec drawable;
+    PrivateRec *devPrivates;
+    WindowPtr parent;           /* ancestor chain */
+    WindowPtr nextSib;          /* next lower sibling */
+    WindowPtr prevSib;          /* next higher sibling */
+    WindowPtr firstChild;       /* top-most child */
+    WindowPtr lastChild;        /* bottom-most child */
+    RegionRec clipList;         /* clipping rectangle for output */
+    RegionRec borderClip;       /* NotClippedByChildren + border */
+    union _Validate *valdata;
+    RegionRec winSize;
+    RegionRec borderSize;
+    DDXPointRec origin;         /* position relative to parent */
+    unsigned short borderWidth;
+    unsigned short deliverableEvents;   /* all masks from all clients */
+    Mask eventMask;             /* mask from the creating client */
+    PixUnion background;
+    PixUnion border;
+    void *backStorage;          /* null when BS disabled */
+    WindowOptPtr optional;
+    unsigned backgroundState:2; /* None, Relative, Pixel, Pixmap */
+    unsigned borderIsPixel:1;
+    unsigned cursorIsNone:1;    /* else real cursor (might inherit) */
+    unsigned backingStore:2;
+    unsigned saveUnder:1;
+    unsigned DIXsaveUnder:1;
+    unsigned bitGravity:4;
+    unsigned winGravity:4;
+    unsigned overrideRedirect:1;
+    unsigned visibility:2;
+    unsigned mapped:1;
+    unsigned realized:1;        /* ancestors are all mapped */
+    unsigned viewable:1;        /* realized && InputOutput */
+    unsigned dontPropagate:3;   /* index into DontPropagateMasks */
+    unsigned forcedBS:1;        /* system-supplied backingStore */
+    unsigned redirectDraw:2;    /* COMPOSITE rendering redirect */
+    unsigned forcedBG:1;        /* must have an opaque background */
+#ifdef ROOTLESS
+    unsigned rootlessUnhittable:1;      /* doesn't hit-test */
+#endif
+#ifdef COMPOSITE
+    unsigned damagedDescendants:1;      /* some descendants are damaged */
+    unsigned inhibitBGPaint:1;  /* paint the background? */
+#endif
+} WindowRec;
+
+/*
+ * Ok, a bunch of macros for accessing the optional record
+ * fields (or filling the appropriate default value)
+ */
+
+extern _X_EXPORT Mask DontPropagateMasks[];
+
+#define wTrackParent(w,field)	((w)->optional ? \
+				    (w)->optional->field \
+ 				 : FindWindowWithOptional(w)->optional->field)
+#define wUseDefault(w,field,def)	((w)->optional ? \
+				    (w)->optional->field \
+				 : def)
+
+#define wVisual(w)		wTrackParent(w, visual)
+#define wCursor(w)		((w)->cursorIsNone ? None : wTrackParent(w, cursor))
+#define wColormap(w)		((w)->drawable.class == InputOnly ? None : wTrackParent(w, colormap))
+#define wDontPropagateMask(w)	wUseDefault(w, dontPropagateMask, DontPropagateMasks[(w)->dontPropagate])
+#define wOtherEventMasks(w)	wUseDefault(w, otherEventMasks, 0)
+#define wOtherClients(w)	wUseDefault(w, otherClients, NULL)
+#define wOtherInputMasks(w)	wUseDefault(w, inputMasks, NULL)
+#define wPassiveGrabs(w)	wUseDefault(w, passiveGrabs, NULL)
+#define wUserProps(w)		wUseDefault(w, userProps, NULL)
+#define wBackingBitPlanes(w)	wUseDefault(w, backingBitPlanes, ~0L)
+#define wBackingPixel(w)	wUseDefault(w, backingPixel, 0)
+#define wBoundingShape(w)	wUseDefault(w, boundingShape, NULL)
+#define wClipShape(w)		wUseDefault(w, clipShape, NULL)
+#define wInputShape(w)          wUseDefault(w, inputShape, NULL)
+#define wClient(w)		(clients[CLIENT_ID((w)->drawable.id)])
+#define wBorderWidth(w)		((int) (w)->borderWidth)
+
+/* true when w needs a border drawn. */
+
+#define HasBorder(w)	((w)->borderWidth || wClipShape(w))
+
+typedef struct _ScreenSaverStuff *ScreenSaverStuffPtr;
+
+#define SCREEN_IS_BLANKED   0
+#define SCREEN_ISNT_SAVED   1
+#define SCREEN_IS_TILED     2
+#define SCREEN_IS_BLACK	    3
+
+#define HasSaverWindow(pScreen)   (pScreen->screensaver.pWindow != NullWindow)
+
+extern _X_EXPORT int screenIsSaved;
+
+#endif                          /* WINDOWSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/windowstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/XIstubs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/XIstubs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/XIstubs.h	(Revision 52145)
@@ -0,0 +1,46 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef XI_STUBS_H
+#define XI_STUBS_H 1
+
+extern _X_EXPORT int
+ SetDeviceMode(ClientPtr /* client */ ,
+               DeviceIntPtr /* dev */ ,
+               int /* mode */ );
+
+extern _X_EXPORT int
+ SetDeviceValuators(ClientPtr /* client */ ,
+                    DeviceIntPtr /* dev */ ,
+                    int * /* valuators */ ,
+                    int /* first_valuator */ ,
+                    int /* num_valuators */ );
+
+extern _X_EXPORT int
+ ChangeDeviceControl(ClientPtr /* client */ ,
+                     DeviceIntPtr /* dev */ ,
+                     xDeviceCtl * /* control */ );
+
+#endif                          /* XI_STUBS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/XIstubs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/systemd-logind.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/systemd-logind.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/systemd-logind.h	(Revision 52145)
@@ -0,0 +1,45 @@
+/*
+ * Copyright ¬© 2013 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Hans de Goede <hdegoede@redhat.com>
+ */
+
+#ifndef SYSTEMD_LOGIND_H
+#define SYSTEMD_LOGIND_H
+
+#ifdef SYSTEMD_LOGIND
+int systemd_logind_init(void);
+void systemd_logind_fini(void);
+int systemd_logind_take_fd(int major, int minor, const char *path, Bool *paus);
+void systemd_logind_release_fd(int major, int minor, int fd);
+int systemd_logind_controls_session(void);
+void systemd_logind_vtenter(void);
+#else
+#define systemd_logind_init()
+#define systemd_logind_fini()
+#define systemd_logind_take_fd(major, minor, path, paus) -1
+#define systemd_logind_release_fd(major, minor, fd) close(fd)
+#define systemd_logind_controls_session() 0
+#define systemd_logind_vtenter()
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/systemd-logind.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picturestr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picturestr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picturestr.h	(Revision 52145)
@@ -0,0 +1,614 @@
+/*
+ * Copyright ¬© 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _PICTURESTR_H_
+#define _PICTURESTR_H_
+
+#include "scrnintstr.h"
+#include "glyphstr.h"
+#include "resource.h"
+#include "privates.h"
+
+typedef struct _DirectFormat {
+    CARD16 red, redMask;
+    CARD16 green, greenMask;
+    CARD16 blue, blueMask;
+    CARD16 alpha, alphaMask;
+} DirectFormatRec;
+
+typedef struct _IndexFormat {
+    VisualID vid;
+    ColormapPtr pColormap;
+    int nvalues;
+    xIndexValue *pValues;
+    void *devPrivate;
+} IndexFormatRec;
+
+typedef struct _PictFormat {
+    CARD32 id;
+    CARD32 format;              /* except bpp */
+    unsigned char type;
+    unsigned char depth;
+    DirectFormatRec direct;
+    IndexFormatRec index;
+} PictFormatRec;
+
+typedef struct pixman_vector PictVector, *PictVectorPtr;
+typedef struct pixman_transform PictTransform, *PictTransformPtr;
+
+#define pict_f_vector pixman_f_vector
+#define pict_f_transform pixman_f_transform
+
+#define PICT_GRADIENT_STOPTABLE_SIZE 1024
+#define SourcePictTypeSolidFill 0
+#define SourcePictTypeLinear 1
+#define SourcePictTypeRadial 2
+#define SourcePictTypeConical 3
+
+typedef struct _PictSolidFill {
+    unsigned int type;
+    CARD32 color;
+} PictSolidFill, *PictSolidFillPtr;
+
+typedef struct _PictGradientStop {
+    xFixed x;
+    xRenderColor color;
+} PictGradientStop, *PictGradientStopPtr;
+
+typedef struct _PictGradient {
+    unsigned int type;
+    int nstops;
+    PictGradientStopPtr stops;
+} PictGradient, *PictGradientPtr;
+
+typedef struct _PictLinearGradient {
+    unsigned int type;
+    int nstops;
+    PictGradientStopPtr stops;
+    xPointFixed p1;
+    xPointFixed p2;
+} PictLinearGradient, *PictLinearGradientPtr;
+
+typedef struct _PictCircle {
+    xFixed x;
+    xFixed y;
+    xFixed radius;
+} PictCircle, *PictCirclePtr;
+
+typedef struct _PictRadialGradient {
+    unsigned int type;
+    int nstops;
+    PictGradientStopPtr stops;
+    PictCircle c1;
+    PictCircle c2;
+} PictRadialGradient, *PictRadialGradientPtr;
+
+typedef struct _PictConicalGradient {
+    unsigned int type;
+    int nstops;
+    PictGradientStopPtr stops;
+    xPointFixed center;
+    xFixed angle;
+} PictConicalGradient, *PictConicalGradientPtr;
+
+typedef union _SourcePict {
+    unsigned int type;
+    PictSolidFill solidFill;
+    PictGradient gradient;
+    PictLinearGradient linear;
+    PictRadialGradient radial;
+    PictConicalGradient conical;
+} SourcePict, *SourcePictPtr;
+
+typedef struct _Picture {
+    DrawablePtr pDrawable;
+    PictFormatPtr pFormat;
+    PictFormatShort format;     /* PICT_FORMAT */
+    int refcnt;
+    CARD32 id;
+    unsigned int repeat:1;
+    unsigned int graphicsExposures:1;
+    unsigned int subWindowMode:1;
+    unsigned int polyEdge:1;
+    unsigned int polyMode:1;
+    unsigned int freeCompClip:1;
+    unsigned int clientClipType:2;
+    unsigned int componentAlpha:1;
+    unsigned int repeatType:2;
+    unsigned int filter:3;
+    unsigned int stateChanges:CPLastBit;
+    unsigned int unused:18 - CPLastBit;
+
+    PicturePtr pNext;           /* chain on same drawable */
+
+    PicturePtr alphaMap;
+    DDXPointRec alphaOrigin;
+
+    DDXPointRec clipOrigin;
+    void *clientClip;
+
+    unsigned long serialNumber;
+
+    RegionPtr pCompositeClip;
+
+    PrivateRec *devPrivates;
+
+    PictTransform *transform;
+
+    SourcePictPtr pSourcePict;
+    xFixed *filter_params;
+    int filter_nparams;
+} PictureRec;
+
+typedef Bool (*PictFilterValidateParamsProcPtr) (ScreenPtr pScreen, int id,
+                                                 xFixed * params, int nparams,
+                                                 int *width, int *height);
+typedef struct {
+    char *name;
+    int id;
+    PictFilterValidateParamsProcPtr ValidateParams;
+    int width, height;
+} PictFilterRec, *PictFilterPtr;
+
+#define PictFilterNearest	0
+#define PictFilterBilinear	1
+
+#define PictFilterFast		2
+#define PictFilterGood		3
+#define PictFilterBest		4
+
+#define PictFilterConvolution	5
+/* if you add an 8th filter, expand the filter bitfield above */
+
+typedef struct {
+    char *alias;
+    int alias_id;
+    int filter_id;
+} PictFilterAliasRec, *PictFilterAliasPtr;
+
+typedef int (*CreatePictureProcPtr) (PicturePtr pPicture);
+typedef void (*DestroyPictureProcPtr) (PicturePtr pPicture);
+typedef int (*ChangePictureClipProcPtr) (PicturePtr pPicture,
+                                         int clipType, void *value, int n);
+typedef void (*DestroyPictureClipProcPtr) (PicturePtr pPicture);
+
+typedef int (*ChangePictureTransformProcPtr) (PicturePtr pPicture,
+                                              PictTransform * transform);
+
+typedef int (*ChangePictureFilterProcPtr) (PicturePtr pPicture,
+                                           int filter,
+                                           xFixed * params, int nparams);
+
+typedef void (*DestroyPictureFilterProcPtr) (PicturePtr pPicture);
+
+typedef void (*ChangePictureProcPtr) (PicturePtr pPicture, Mask mask);
+typedef void (*ValidatePictureProcPtr) (PicturePtr pPicture, Mask mask);
+typedef void (*CompositeProcPtr) (CARD8 op,
+                                  PicturePtr pSrc,
+                                  PicturePtr pMask,
+                                  PicturePtr pDst,
+                                  INT16 xSrc,
+                                  INT16 ySrc,
+                                  INT16 xMask,
+                                  INT16 yMask,
+                                  INT16 xDst,
+                                  INT16 yDst, CARD16 width, CARD16 height);
+
+typedef void (*GlyphsProcPtr) (CARD8 op,
+                               PicturePtr pSrc,
+                               PicturePtr pDst,
+                               PictFormatPtr maskFormat,
+                               INT16 xSrc,
+                               INT16 ySrc,
+                               int nlists,
+                               GlyphListPtr lists, GlyphPtr * glyphs);
+
+typedef void (*CompositeRectsProcPtr) (CARD8 op,
+                                       PicturePtr pDst,
+                                       xRenderColor * color,
+                                       int nRect, xRectangle *rects);
+
+typedef void (*RasterizeTrapezoidProcPtr) (PicturePtr pMask,
+                                           xTrapezoid * trap,
+                                           int x_off, int y_off);
+
+typedef void (*TrapezoidsProcPtr) (CARD8 op,
+                                   PicturePtr pSrc,
+                                   PicturePtr pDst,
+                                   PictFormatPtr maskFormat,
+                                   INT16 xSrc,
+                                   INT16 ySrc, int ntrap, xTrapezoid * traps);
+
+typedef void (*TrianglesProcPtr) (CARD8 op,
+                                  PicturePtr pSrc,
+                                  PicturePtr pDst,
+                                  PictFormatPtr maskFormat,
+                                  INT16 xSrc,
+                                  INT16 ySrc, int ntri, xTriangle * tris);
+
+typedef void (*TriStripProcPtr) (CARD8 op,
+                                 PicturePtr pSrc,
+                                 PicturePtr pDst,
+                                 PictFormatPtr maskFormat,
+                                 INT16 xSrc,
+                                 INT16 ySrc, int npoint, xPointFixed * points);
+
+typedef void (*TriFanProcPtr) (CARD8 op,
+                               PicturePtr pSrc,
+                               PicturePtr pDst,
+                               PictFormatPtr maskFormat,
+                               INT16 xSrc,
+                               INT16 ySrc, int npoint, xPointFixed * points);
+
+typedef Bool (*InitIndexedProcPtr) (ScreenPtr pScreen, PictFormatPtr pFormat);
+
+typedef void (*CloseIndexedProcPtr) (ScreenPtr pScreen, PictFormatPtr pFormat);
+
+typedef void (*UpdateIndexedProcPtr) (ScreenPtr pScreen,
+                                      PictFormatPtr pFormat,
+                                      int ndef, xColorItem * pdef);
+
+typedef void (*AddTrapsProcPtr) (PicturePtr pPicture,
+                                 INT16 xOff,
+                                 INT16 yOff, int ntrap, xTrap * traps);
+
+typedef void (*AddTrianglesProcPtr) (PicturePtr pPicture,
+                                     INT16 xOff,
+                                     INT16 yOff, int ntri, xTriangle * tris);
+
+typedef Bool (*RealizeGlyphProcPtr) (ScreenPtr pScreen, GlyphPtr glyph);
+
+typedef void (*UnrealizeGlyphProcPtr) (ScreenPtr pScreen, GlyphPtr glyph);
+
+typedef struct _PictureScreen {
+    PictFormatPtr formats;
+    PictFormatPtr fallback;
+    int nformats;
+
+    CreatePictureProcPtr CreatePicture;
+    DestroyPictureProcPtr DestroyPicture;
+    ChangePictureClipProcPtr ChangePictureClip;
+    DestroyPictureClipProcPtr DestroyPictureClip;
+
+    ChangePictureProcPtr ChangePicture;
+    ValidatePictureProcPtr ValidatePicture;
+
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;       /* unused */
+    CompositeRectsProcPtr CompositeRects;
+
+    DestroyWindowProcPtr DestroyWindow;
+    CloseScreenProcPtr CloseScreen;
+
+    StoreColorsProcPtr StoreColors;
+
+    InitIndexedProcPtr InitIndexed;
+    CloseIndexedProcPtr CloseIndexed;
+    UpdateIndexedProcPtr UpdateIndexed;
+
+    int subpixel;
+
+    PictFilterPtr filters;
+    int nfilters;
+    PictFilterAliasPtr filterAliases;
+    int nfilterAliases;
+
+    /**
+     * Called immediately after a picture's transform is changed through the
+     * SetPictureTransform request.  Not called for source-only pictures.
+     */
+    ChangePictureTransformProcPtr ChangePictureTransform;
+
+    /**
+     * Called immediately after a picture's transform is changed through the
+     * SetPictureFilter request.  Not called for source-only pictures.
+     */
+    ChangePictureFilterProcPtr ChangePictureFilter;
+
+    DestroyPictureFilterProcPtr DestroyPictureFilter;
+
+    TrapezoidsProcPtr Trapezoids;
+    TrianglesProcPtr Triangles;
+
+    RasterizeTrapezoidProcPtr RasterizeTrapezoid;
+
+    AddTrianglesProcPtr AddTriangles;
+
+    AddTrapsProcPtr AddTraps;
+
+    RealizeGlyphProcPtr RealizeGlyph;
+    UnrealizeGlyphProcPtr UnrealizeGlyph;
+
+#define PICTURE_SCREEN_VERSION 2
+    TriStripProcPtr TriStrip;
+    TriFanProcPtr TriFan;
+} PictureScreenRec, *PictureScreenPtr;
+
+extern _X_EXPORT DevPrivateKeyRec PictureScreenPrivateKeyRec;
+
+#define PictureScreenPrivateKey (&PictureScreenPrivateKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec PictureWindowPrivateKeyRec;
+
+#define	PictureWindowPrivateKey (&PictureWindowPrivateKeyRec)
+
+extern _X_EXPORT RESTYPE PictureType;
+extern _X_EXPORT RESTYPE PictFormatType;
+extern _X_EXPORT RESTYPE GlyphSetType;
+
+#define GetPictureScreen(s) ((PictureScreenPtr)dixLookupPrivate(&(s)->devPrivates, PictureScreenPrivateKey))
+#define GetPictureScreenIfSet(s) (dixPrivateKeyRegistered(PictureScreenPrivateKey) ? GetPictureScreen(s) : NULL)
+#define SetPictureScreen(s,p) dixSetPrivate(&(s)->devPrivates, PictureScreenPrivateKey, p)
+#define GetPictureWindow(w) ((PicturePtr)dixLookupPrivate(&(w)->devPrivates, PictureWindowPrivateKey))
+#define SetPictureWindow(w,p) dixSetPrivate(&(w)->devPrivates, PictureWindowPrivateKey, p)
+
+#define VERIFY_PICTURE(pPicture, pid, client, mode) {\
+    int tmprc = dixLookupResourceByType((void *)&(pPicture), pid,\
+	                                PictureType, client, mode);\
+    if (tmprc != Success)\
+	return tmprc;\
+}
+
+#define VERIFY_ALPHA(pPicture, pid, client, mode) {\
+    if (pid == None) \
+	pPicture = 0; \
+    else { \
+	VERIFY_PICTURE(pPicture, pid, client, mode); \
+    } \
+} \
+
+extern _X_EXPORT PictFormatPtr
+ PictureWindowFormat(WindowPtr pWindow);
+
+extern _X_EXPORT Bool
+ PictureDestroyWindow(WindowPtr pWindow);
+
+extern _X_EXPORT Bool
+ PictureCloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ PictureStoreColors(ColormapPtr pColormap, int ndef, xColorItem * pdef);
+
+extern _X_EXPORT Bool
+ PictureInitIndexedFormat(ScreenPtr pScreen, PictFormatPtr format);
+
+extern _X_EXPORT Bool
+ PictureSetSubpixelOrder(ScreenPtr pScreen, int subpixel);
+
+extern _X_EXPORT int
+ PictureGetSubpixelOrder(ScreenPtr pScreen);
+
+extern _X_EXPORT PictFormatPtr
+PictureCreateDefaultFormats(ScreenPtr pScreen, int *nformatp);
+
+extern _X_EXPORT PictFormatPtr
+PictureMatchVisual(ScreenPtr pScreen, int depth, VisualPtr pVisual);
+
+extern _X_EXPORT PictFormatPtr
+PictureMatchFormat(ScreenPtr pScreen, int depth, CARD32 format);
+
+extern _X_EXPORT Bool
+ PictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats);
+
+extern _X_EXPORT int
+ PictureGetFilterId(const char *filter, int len, Bool makeit);
+
+extern _X_EXPORT char *PictureGetFilterName(int id);
+
+extern _X_EXPORT int
+
+PictureAddFilter(ScreenPtr pScreen,
+                 const char *filter,
+                 PictFilterValidateParamsProcPtr ValidateParams,
+                 int width, int height);
+
+extern _X_EXPORT Bool
+
+PictureSetFilterAlias(ScreenPtr pScreen, const char *filter, const char *alias);
+
+extern _X_EXPORT Bool
+ PictureSetDefaultFilters(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ PictureResetFilters(ScreenPtr pScreen);
+
+extern _X_EXPORT PictFilterPtr
+PictureFindFilter(ScreenPtr pScreen, char *name, int len);
+
+extern _X_EXPORT int
+
+SetPicturePictFilter(PicturePtr pPicture, PictFilterPtr pFilter,
+                     xFixed * params, int nparams);
+
+extern _X_EXPORT int
+
+SetPictureFilter(PicturePtr pPicture, char *name, int len,
+                 xFixed * params, int nparams);
+
+extern _X_EXPORT Bool
+ PictureFinishInit(void);
+
+extern _X_EXPORT void
+ SetPictureToDefaults(PicturePtr pPicture);
+
+extern _X_EXPORT PicturePtr
+CreatePicture(Picture pid,
+              DrawablePtr pDrawable,
+              PictFormatPtr pFormat,
+              Mask mask, XID *list, ClientPtr client, int *error);
+
+extern _X_EXPORT int
+
+ChangePicture(PicturePtr pPicture,
+              Mask vmask, XID *vlist, DevUnion *ulist, ClientPtr client);
+
+extern _X_EXPORT int
+
+SetPictureClipRects(PicturePtr pPicture,
+                    int xOrigin, int yOrigin, int nRect, xRectangle *rects);
+
+extern _X_EXPORT int
+
+SetPictureClipRegion(PicturePtr pPicture,
+                     int xOrigin, int yOrigin, RegionPtr pRegion);
+
+extern _X_EXPORT int
+ SetPictureTransform(PicturePtr pPicture, PictTransform * transform);
+
+extern _X_EXPORT void
+ CopyPicture(PicturePtr pSrc, Mask mask, PicturePtr pDst);
+
+extern _X_EXPORT void
+ ValidatePicture(PicturePtr pPicture);
+
+extern _X_EXPORT int
+ FreePicture(void *pPicture, XID pid);
+
+extern _X_EXPORT int
+ FreePictFormat(void *pPictFormat, XID pid);
+
+extern _X_EXPORT void
+
+CompositePicture(CARD8 op,
+                 PicturePtr pSrc,
+                 PicturePtr pMask,
+                 PicturePtr pDst,
+                 INT16 xSrc,
+                 INT16 ySrc,
+                 INT16 xMask,
+                 INT16 yMask,
+                 INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+
+extern _X_EXPORT void
+
+CompositeGlyphs(CARD8 op,
+                PicturePtr pSrc,
+                PicturePtr pDst,
+                PictFormatPtr maskFormat,
+                INT16 xSrc,
+                INT16 ySrc, int nlist, GlyphListPtr lists, GlyphPtr * glyphs);
+
+extern _X_EXPORT void
+
+CompositeRects(CARD8 op,
+               PicturePtr pDst,
+               xRenderColor * color, int nRect, xRectangle *rects);
+
+extern _X_EXPORT void
+
+CompositeTrapezoids(CARD8 op,
+                    PicturePtr pSrc,
+                    PicturePtr pDst,
+                    PictFormatPtr maskFormat,
+                    INT16 xSrc, INT16 ySrc, int ntrap, xTrapezoid * traps);
+
+extern _X_EXPORT void
+
+CompositeTriangles(CARD8 op,
+                   PicturePtr pSrc,
+                   PicturePtr pDst,
+                   PictFormatPtr maskFormat,
+                   INT16 xSrc,
+                   INT16 ySrc, int ntriangles, xTriangle * triangles);
+
+extern _X_EXPORT void
+
+CompositeTriStrip(CARD8 op,
+                  PicturePtr pSrc,
+                  PicturePtr pDst,
+                  PictFormatPtr maskFormat,
+                  INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points);
+
+extern _X_EXPORT void
+
+CompositeTriFan(CARD8 op,
+                PicturePtr pSrc,
+                PicturePtr pDst,
+                PictFormatPtr maskFormat,
+                INT16 xSrc, INT16 ySrc, int npoints, xPointFixed * points);
+
+Bool
+ AnimCurInit(ScreenPtr pScreen);
+
+int
+
+AnimCursorCreate(CursorPtr *cursors, CARD32 *deltas, int ncursor,
+                 CursorPtr *ppCursor, ClientPtr client, XID cid);
+
+extern _X_EXPORT void
+
+AddTraps(PicturePtr pPicture,
+         INT16 xOff, INT16 yOff, int ntraps, xTrap * traps);
+
+extern _X_EXPORT PicturePtr
+CreateSolidPicture(Picture pid, xRenderColor * color, int *error);
+
+extern _X_EXPORT PicturePtr
+CreateLinearGradientPicture(Picture pid,
+                            xPointFixed * p1,
+                            xPointFixed * p2,
+                            int nStops,
+                            xFixed * stops, xRenderColor * colors, int *error);
+
+extern _X_EXPORT PicturePtr
+CreateRadialGradientPicture(Picture pid,
+                            xPointFixed * inner,
+                            xPointFixed * outer,
+                            xFixed innerRadius,
+                            xFixed outerRadius,
+                            int nStops,
+                            xFixed * stops, xRenderColor * colors, int *error);
+
+extern _X_EXPORT PicturePtr
+CreateConicalGradientPicture(Picture pid,
+                             xPointFixed * center,
+                             xFixed angle,
+                             int nStops,
+                             xFixed * stops, xRenderColor * colors, int *error);
+
+#ifdef PANORAMIX
+extern _X_EXPORT void PanoramiXRenderInit(void);
+extern _X_EXPORT void PanoramiXRenderReset(void);
+#endif
+
+/*
+ * matrix.c
+ */
+
+extern _X_EXPORT void
+
+PictTransform_from_xRenderTransform(PictTransformPtr pict,
+                                    xRenderTransform * render);
+
+extern _X_EXPORT void
+
+xRenderTransform_from_PictTransform(xRenderTransform * render,
+                                    PictTransformPtr pict);
+
+extern _X_EXPORT Bool
+ PictureTransformPoint(PictTransformPtr transform, PictVectorPtr vector);
+
+extern _X_EXPORT Bool
+ PictureTransformPoint3d(PictTransformPtr transform, PictVectorPtr vector);
+
+#endif                          /* _PICTURESTR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/picturestr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/types.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/types.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/types.h	(Revision 52145)
@@ -0,0 +1,80 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for x86 emulator type definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_TYPES_H
+#define __X86EMU_TYPES_H
+
+#ifndef NO_SYS_HEADERS
+#include <sys/types.h>
+#endif
+
+/*
+ * The following kludge is an attempt to work around typedef conflicts with
+ * <sys/types.h>.
+ */
+#define u8   x86emuu8
+#define u16  x86emuu16
+#define u32  x86emuu32
+#define u64  x86emuu64
+#define s8   x86emus8
+#define s16  x86emus16
+#define s32  x86emus32
+#define s64  x86emus64
+#define uint x86emuuint
+#define sint x86emusint
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#include <stdint.h>
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
+
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
+
+typedef unsigned int uint;
+typedef int sint;
+
+typedef u16 X86EMU_pioAddr;
+
+#endif                          /* __X86EMU_TYPES_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/types.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86platformBus.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86platformBus.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86platformBus.h	(Revision 52145)
@@ -0,0 +1,82 @@
+/*
+ * Copyright ¬© 2012 Red Hat.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Dave Airlie <airlied@redhat.com>
+ */
+#ifndef XF86_PLATFORM_BUS_H
+#define XF86_PLATFORM_BUS_H
+
+#include "hotplug.h"
+
+struct xf86_platform_device {
+    struct OdevAttributes *attribs;
+    /* for PCI devices */
+    struct pci_device *pdev;
+    int flags;
+};
+
+/* xf86_platform_device flags */
+#define XF86_PDEV_UNOWNED       0x01
+#define XF86_PDEV_SERVER_FD     0x02
+#define XF86_PDEV_PAUSED        0x04
+
+#ifdef XSERVER_PLATFORM_BUS
+int xf86platformProbe(void);
+int xf86platformProbeDev(DriverPtr drvp);
+
+extern int xf86_num_platform_devices;
+extern struct xf86_platform_device *xf86_platform_devices;
+
+extern char *
+xf86_get_platform_attrib(int index, int attrib_id);
+extern int
+xf86_get_platform_int_attrib(int index, int attrib_id, int def);
+extern int
+xf86_add_platform_device(struct OdevAttributes *attribs, Bool unowned);
+extern int
+xf86_remove_platform_device(int dev_index);
+extern Bool
+xf86_get_platform_device_unowned(int index);
+/* Note starting with xserver 1.16 these 2 functions never fail */
+extern Bool
+xf86_add_platform_device_attrib(int index, int attrib_id, char *attrib_str);
+extern Bool
+xf86_add_platform_device_int_attrib(int index, int attrib_id, int attrib_value);
+
+extern int
+xf86platformAddDevice(int index);
+extern void
+xf86platformRemoveDevice(int index);
+
+extern _X_EXPORT char *
+xf86_get_platform_device_attrib(struct xf86_platform_device *device, int attrib_id);
+extern _X_EXPORT int
+xf86_get_platform_device_int_attrib(struct xf86_platform_device *device, int attrib_id, int def);
+extern _X_EXPORT Bool
+xf86PlatformDeviceCheckBusID(struct xf86_platform_device *device, const char *busid);
+
+extern _X_EXPORT int
+xf86PlatformMatchDriver(char *matches[], int nmatches);
+
+extern void xf86platformVTProbe(void);
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86platformBus.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension.h	(Revision 52145)
@@ -0,0 +1,103 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef EXTENSION_H
+#define EXTENSION_H
+
+#include <X11/Xfuncproto.h>
+
+#include "dixstruct.h"
+
+typedef void (*InitExtension) (void);
+
+typedef struct {
+    InitExtension initFunc;
+    const char *name;
+    Bool *disablePtr;
+} ExtensionModule;
+
+extern _X_EXPORT unsigned short StandardMinorOpcode(ClientPtr /*client */ );
+
+extern _X_EXPORT Bool EnableDisableExtension(const char *name, Bool enable);
+
+extern _X_EXPORT void EnableDisableExtensionError(const char *name,
+                                                  Bool enable);
+
+extern _X_EXPORT void InitExtensions(int argc, char **argv);
+
+extern _X_EXPORT void CloseDownExtensions(void);
+
+extern _X_EXPORT void LoadExtensionList(const ExtensionModule ext[],
+                                        int listSize, Bool external);
+
+#endif                          /* EXTENSION_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extension.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-common.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-common.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-common.h	(Revision 52145)
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to common USB support.  \see usb-common.c \see usb-mouse.c
+ * \see usb-keyboard.c \see usb-other.c */
+
+#ifndef _USB_COMMON_H_
+#define _USB_COMMON_H_
+typedef enum {
+    usbMouse,
+    usbKeyboard,
+    usbOther
+} usbType;
+
+extern void *usbCreatePrivate(DeviceIntPtr pDevice);
+extern void usbDestroyPrivate(void *priv);
+extern void usbRead(DevicePtr pDev,
+                    dmxMotionProcPtr motion,
+                    dmxEnqueueProcPtr enqueue,
+                    int minButton, DMXBlockType block);
+extern void usbInit(DevicePtr pDev, usbType type);
+extern void usbOff(DevicePtr pDev);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/usb-common.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86tokens.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86tokens.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86tokens.h	(Revision 52145)
@@ -0,0 +1,292 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86_tokens_h
+#define _xf86_tokens_h
+
+/* Undefine symbols that some OSs might define */
+#undef IOBASE
+
+/* 
+ * Each token should have a unique value regardless of the section
+ * it is used in.
+ */
+
+typedef enum {
+    /* errno-style tokens */
+    OBSOLETE_TOKEN = -5,
+    EOF_TOKEN = -4,
+    LOCK_TOKEN = -3,
+    ERROR_TOKEN = -2,
+
+    /* value type tokens */
+    NUMBER = 1,
+    STRING,
+
+    /* Tokens that can appear in many sections */
+    SECTION,
+    SUBSECTION,
+    ENDSECTION,
+    ENDSUBSECTION,
+    IDENTIFIER,
+    VENDOR,
+    DASH,
+    COMMA,
+    MATCHSEAT,
+    OPTION,
+    COMMENT,
+
+    /* Frequency units */
+    HRZ,
+    KHZ,
+    MHZ,
+
+    /* File tokens */
+    FONTPATH,
+    MODULEPATH,
+    LOGFILEPATH,
+    XKBDIR,
+
+    /* Server Flag tokens.  These are deprecated in favour of generic Options */
+    NOTRAPSIGNALS,
+    DONTZAP,
+    DONTZOOM,
+    DISABLEVIDMODE,
+    ALLOWNONLOCAL,
+    DISABLEMODINDEV,
+    MODINDEVALLOWNONLOCAL,
+    ALLOWMOUSEOPENFAIL,
+    BLANKTIME,
+    STANDBYTIME,
+    SUSPENDTIME,
+    OFFTIME,
+    DEFAULTLAYOUT,
+
+    /* Monitor tokens */
+    MODEL,
+    MODELINE,
+    DISPLAYSIZE,
+    HORIZSYNC,
+    VERTREFRESH,
+    MODE,
+    GAMMA,
+    USEMODES,
+
+    /* Modes tokens */
+    /* no new ones */
+
+    /* Mode tokens */
+    DOTCLOCK,
+    HTIMINGS,
+    VTIMINGS,
+    FLAGS,
+    HSKEW,
+    BCAST,
+    VSCAN,
+    ENDMODE,
+
+    /* Screen tokens */
+    OBSDRIVER,
+    MDEVICE,
+    MONITOR,
+    SCREENNO,
+    DEFAULTDEPTH,
+    DEFAULTBPP,
+    DEFAULTFBBPP,
+
+    /* VideoAdaptor tokens */
+    VIDEOADAPTOR,
+
+    /* Mode timing tokens */
+    TT_INTERLACE,
+    TT_PHSYNC,
+    TT_NHSYNC,
+    TT_PVSYNC,
+    TT_NVSYNC,
+    TT_CSYNC,
+    TT_PCSYNC,
+    TT_NCSYNC,
+    TT_DBLSCAN,
+    TT_HSKEW,
+    TT_BCAST,
+    TT_VSCAN,
+
+    /* Module tokens */
+    LOAD,
+    LOAD_DRIVER,
+    DISABLE,
+
+    /* Device tokens */
+    DRIVER,
+    CHIPSET,
+    CLOCKS,
+    VIDEORAM,
+    BOARD,
+    IOBASE,
+    RAMDAC,
+    DACSPEED,
+    BIOSBASE,
+    MEMBASE,
+    CLOCKCHIP,
+    CHIPID,
+    CHIPREV,
+    CARD,
+    BUSID,
+    TEXTCLOCKFRQ,
+    IRQ,
+
+    /* Keyboard tokens */
+    AUTOREPEAT,
+    XLEDS,
+    KPROTOCOL,
+    XKBKEYMAP,
+    XKBCOMPAT,
+    XKBTYPES,
+    XKBKEYCODES,
+    XKBGEOMETRY,
+    XKBSYMBOLS,
+    XKBDISABLE,
+    PANIX106,
+    XKBRULES,
+    XKBMODEL,
+    XKBLAYOUT,
+    XKBVARIANT,
+    XKBOPTIONS,
+    /* Obsolete keyboard tokens */
+    SERVERNUM,
+    LEFTALT,
+    RIGHTALT,
+    SCROLLLOCK_TOK,
+    RIGHTCTL,
+    /* arguments for the above obsolete tokens */
+    CONF_KM_META,
+    CONF_KM_COMPOSE,
+    CONF_KM_MODESHIFT,
+    CONF_KM_MODELOCK,
+    CONF_KM_SCROLLLOCK,
+    CONF_KM_CONTROL,
+
+    /* Pointer tokens */
+    EMULATE3,
+    BAUDRATE,
+    SAMPLERATE,
+    PRESOLUTION,
+    CLEARDTR,
+    CLEARRTS,
+    CHORDMIDDLE,
+    PROTOCOL,
+    PDEVICE,
+    EM3TIMEOUT,
+    DEVICE_NAME,
+    ALWAYSCORE,
+    PBUTTONS,
+    ZAXISMAPPING,
+
+    /* Pointer Z axis mapping tokens */
+    XAXIS,
+    YAXIS,
+
+    /* Display tokens */
+    MODES,
+    VIEWPORT,
+    VIRTUAL,
+    VISUAL,
+    BLACK_TOK,
+    WHITE_TOK,
+    DEPTH,
+    BPP,
+    WEIGHT,
+
+    /* Layout Tokens */
+    SCREEN,
+    INACTIVE,
+    INPUTDEVICE,
+
+    /* Adjaceny Tokens */
+    RIGHTOF,
+    LEFTOF,
+    ABOVE,
+    BELOW,
+    RELATIVE,
+    ABSOLUTE,
+
+    /* Vendor Tokens */
+    VENDORNAME,
+
+    /* DRI Tokens */
+    GROUP,
+
+    /* InputClass Tokens */
+    MATCH_PRODUCT,
+    MATCH_VENDOR,
+    MATCH_DEVICE_PATH,
+    MATCH_OS,
+    MATCH_PNPID,
+    MATCH_USBID,
+    MATCH_DRIVER,
+    MATCH_TAG,
+    MATCH_LAYOUT,
+    MATCH_IS_KEYBOARD,
+    MATCH_IS_POINTER,
+    MATCH_IS_JOYSTICK,
+    MATCH_IS_TABLET,
+    MATCH_IS_TOUCHPAD,
+    MATCH_IS_TOUCHSCREEN
+} ParserTokens;
+
+#endif                          /* _xf86_tokens_h */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xf86tokens.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xace.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xace.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xace.h	(Revision 52145)
@@ -0,0 +1,128 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XACE_H
+#define _XACE_H
+
+#ifdef XACE
+
+#define XACE_MAJOR_VERSION		2
+#define XACE_MINOR_VERSION		0
+
+#include "pixmap.h"
+#include "region.h"
+#include "window.h"
+#include "property.h"
+#include "selection.h"
+
+/* Default window background */
+#define XaceBackgroundNoneState(w) ((w)->forcedBG ? BackgroundPixel : None)
+
+/* security hooks */
+/* Constants used to identify the available security hooks
+ */
+#define XACE_CORE_DISPATCH		0
+#define XACE_EXT_DISPATCH		1
+#define XACE_RESOURCE_ACCESS		2
+#define XACE_DEVICE_ACCESS		3
+#define XACE_PROPERTY_ACCESS		4
+#define XACE_SEND_ACCESS		5
+#define XACE_RECEIVE_ACCESS		6
+#define XACE_CLIENT_ACCESS		7
+#define XACE_EXT_ACCESS			8
+#define XACE_SERVER_ACCESS		9
+#define XACE_SELECTION_ACCESS		10
+#define XACE_SCREEN_ACCESS		11
+#define XACE_SCREENSAVER_ACCESS		12
+#define XACE_AUTH_AVAIL			13
+#define XACE_KEY_AVAIL			14
+#define XACE_AUDIT_BEGIN		15
+#define XACE_AUDIT_END			16
+#define XACE_NUM_HOOKS			17
+
+extern _X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS];
+
+/* Entry point for hook functions.  Called by Xserver.
+ * Required by libdbe and libextmod
+ */
+extern _X_EXPORT int XaceHook(int /*hook */ ,
+                              ...       /*appropriate args for hook */
+    );
+
+/* Special-cased hook functions
+ */
+extern _X_EXPORT int XaceHookDispatch(ClientPtr ptr, int major);
+extern _X_EXPORT int XaceHookPropertyAccess(ClientPtr ptr, WindowPtr pWin,
+                                            PropertyPtr *ppProp,
+                                            Mask access_mode);
+extern _X_EXPORT int XaceHookSelectionAccess(ClientPtr ptr, Selection ** ppSel,
+                                             Mask access_mode);
+extern _X_EXPORT void XaceHookAuditEnd(ClientPtr ptr, int result);
+
+/* Register a callback for a given hook.
+ */
+#define XaceRegisterCallback(hook,callback,data) \
+    AddCallback(XaceHooks+(hook), callback, data)
+
+/* Unregister an existing callback for a given hook.
+ */
+#define XaceDeleteCallback(hook,callback,data) \
+    DeleteCallback(XaceHooks+(hook), callback, data)
+
+/* XTrans wrappers for use by security modules
+ */
+extern _X_EXPORT int XaceGetConnectionNumber(ClientPtr ptr);
+extern _X_EXPORT int XaceIsLocal(ClientPtr ptr);
+
+/* From the original Security extension...
+ */
+
+extern _X_EXPORT void XaceCensorImage(ClientPtr client,
+                                      RegionPtr pVisibleRegion,
+                                      long widthBytesLine,
+                                      DrawablePtr pDraw,
+                                      int x, int y, int w, int h,
+                                      unsigned int format, char *pBuf);
+
+#else                           /* XACE */
+
+/* Default window background */
+#define XaceBackgroundNoneState(w)		None
+
+/* Define calls away when XACE is not being built. */
+
+#ifdef __GNUC__
+#define XaceHook(args...) Success
+#define XaceHookDispatch(args...) Success
+#define XaceHookPropertyAccess(args...) Success
+#define XaceHookSelectionAccess(args...) Success
+#define XaceHookAuditEnd(args...) { ; }
+#define XaceCensorImage(args...) { ; }
+#else
+#define XaceHook(...) Success
+#define XaceHookDispatch(...) Success
+#define XaceHookPropertyAccess(...) Success
+#define XaceHookSelectionAccess(...) Success
+#define XaceHookAuditEnd(...) { ; }
+#define XaceCensorImage(...) { ; }
+#endif
+
+#endif                          /* XACE */
+
+#endif                          /* _XACE_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xace.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sendexev.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sendexev.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sendexev.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SENDEXEV_H
+#define SENDEXEV_H 1
+
+int SProcXSendExtensionEvent(ClientPtr  /* client */
+    );
+
+int ProcXSendExtensionEvent(ClientPtr   /* client */
+    );
+
+#endif                          /* SENDEXEV_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/sendexev.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbus-core.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbus-core.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbus-core.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/*
+ * Copyright ¬© 2013 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Hans de Goede <hdegoede@redhat.com>
+ */
+
+#ifndef DBUS_CORE_H
+#define DBUS_CORE_H
+
+#ifdef NEED_DBUS
+typedef struct DBusConnection DBusConnection;
+
+typedef void (*dbus_core_connect_hook) (DBusConnection * connection,
+                                               void *data);
+typedef void (*dbus_core_disconnect_hook) (void *data);
+
+struct dbus_core_hook {
+    dbus_core_connect_hook connect;
+    dbus_core_disconnect_hook disconnect;
+    void *data;
+
+    struct dbus_core_hook *next;
+};
+
+int dbus_core_init(void);
+void dbus_core_fini(void);
+int dbus_core_add_hook(struct dbus_core_hook *hook);
+void dbus_core_remove_hook(struct dbus_core_hook *hook);
+
+#else
+
+#define dbus_core_init()
+#define dbus_core_fini()
+
+#endif
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbus-core.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevk.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevk.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevk.h	(Revision 52145)
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEVK_H
+#define GRABDEVK_H 1
+
+int SProcXGrabDeviceKey(ClientPtr       /* client */
+    );
+
+int ProcXGrabDeviceKey(ClientPtr        /* client */
+    );
+
+#endif                          /* GRABDEVK_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/grabdevk.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgptr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgptr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgptr.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGPTR_H
+#define CHGPTR_H 1
+
+int SProcXChangePointerDevice(ClientPtr /* client */
+    );
+
+int ProcXChangePointerDevice(ClientPtr  /* client */
+    );
+
+void DeleteFocusClassDeviceStruct(DeviceIntPtr  /* dev */
+    );
+
+#endif                          /* CHGPTR_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/chgptr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb.h	(Revision 52145)
@@ -0,0 +1,1660 @@
+/*
+ *
+ * Copyright ¬© 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FB_H_
+#define _FB_H_
+
+#include <X11/X.h>
+#include <pixman.h>
+
+#include "scrnintstr.h"
+#include "pixmap.h"
+#include "pixmapstr.h"
+#include "region.h"
+#include "gcstruct.h"
+#include "colormap.h"
+#include "miscstruct.h"
+#include "servermd.h"
+#include "windowstr.h"
+#include "privates.h"
+#include "mi.h"
+#include "migc.h"
+#include "picturestr.h"
+
+#ifdef FB_ACCESS_WRAPPER
+
+#include "wfbrename.h"
+#define FBPREFIX(x) wfb##x
+#define WRITE(ptr, val) ((*wfbWriteMemory)((ptr), (val), sizeof(*(ptr))))
+#define READ(ptr) ((*wfbReadMemory)((ptr), sizeof(*(ptr))))
+
+#define MEMCPY_WRAPPED(dst, src, size) do {                       \
+    size_t _i;                                                    \
+    CARD8 *_dst = (CARD8*)(dst), *_src = (CARD8*)(src);           \
+    for(_i = 0; _i < size; _i++) {                                \
+        WRITE(_dst +_i, READ(_src + _i));                         \
+    }                                                             \
+} while(0)
+
+#define MEMSET_WRAPPED(dst, val, size) do {                       \
+    size_t _i;                                                    \
+    CARD8 *_dst = (CARD8*)(dst);                                  \
+    for(_i = 0; _i < size; _i++) {                                \
+        WRITE(_dst +_i, (val));                                   \
+    }                                                             \
+} while(0)
+
+#else
+
+#define FBPREFIX(x) fb##x
+#define WRITE(ptr, val) (*(ptr) = (val))
+#define READ(ptr) (*(ptr))
+#define MEMCPY_WRAPPED(dst, src, size) memcpy((dst), (src), (size))
+#define MEMSET_WRAPPED(dst, val, size) memset((dst), (val), (size))
+
+#endif
+
+/*
+ * This single define controls the basic size of data manipulated
+ * by this software; it must be log2(sizeof (FbBits) * 8)
+ */
+
+#ifndef FB_SHIFT
+#define FB_SHIFT    LOG2_BITMAP_PAD
+#endif
+
+#if FB_SHIFT < LOG2_BITMAP_PAD
+error FB_SHIFT must be >= LOG2_BITMAP_PAD
+#endif
+#define FB_UNIT	    (1 << FB_SHIFT)
+#define FB_HALFUNIT (1 << (FB_SHIFT-1))
+#define FB_MASK	    (FB_UNIT - 1)
+#define FB_ALLONES  ((FbBits) -1)
+#if GLYPHPADBYTES != 4
+#error "GLYPHPADBYTES must be 4"
+#endif
+/* for driver compat - intel UXA needs the second one at least */
+#define FB_24BIT
+#define FB_24_32BIT
+#define FB_STIP_SHIFT	LOG2_BITMAP_PAD
+#define FB_STIP_UNIT	(1 << FB_STIP_SHIFT)
+#define FB_STIP_MASK	(FB_STIP_UNIT - 1)
+#define FB_STIP_ALLONES	((FbStip) -1)
+#define FB_STIP_ODDSTRIDE(s)	(((s) & (FB_MASK >> FB_STIP_SHIFT)) != 0)
+#define FB_STIP_ODDPTR(p)	((((long) (p)) & (FB_MASK >> 3)) != 0)
+#define FbStipStrideToBitsStride(s) (((s) >> (FB_SHIFT - FB_STIP_SHIFT)))
+#define FbBitsStrideToStipStride(s) (((s) << (FB_SHIFT - FB_STIP_SHIFT)))
+#define FbFullMask(n)   ((n) == FB_UNIT ? FB_ALLONES : ((((FbBits) 1) << n) - 1))
+#if FB_SHIFT == 6
+#ifdef WIN32
+typedef unsigned __int64 FbBits;
+#else
+#if defined(__alpha__) || defined(__alpha) || \
+      defined(ia64) || defined(__ia64__) || \
+      defined(__sparc64__) || defined(_LP64) || \
+      defined(__s390x__) || \
+      defined(amd64) || defined (__amd64__) || \
+      defined (__powerpc64__)
+typedef unsigned long FbBits;
+#else
+typedef unsigned long long FbBits;
+#endif
+#endif
+#endif
+
+#if FB_SHIFT == 5
+typedef CARD32 FbBits;
+#endif
+
+#if FB_SHIFT == 4
+typedef CARD16 FbBits;
+#endif
+
+#if LOG2_BITMAP_PAD == FB_SHIFT
+typedef FbBits FbStip;
+#else
+#if LOG2_BITMAP_PAD == 5
+typedef CARD32 FbStip;
+#endif
+#endif
+
+typedef int FbStride;
+
+#ifdef FB_DEBUG
+extern _X_EXPORT void fbValidateDrawable(DrawablePtr d);
+extern _X_EXPORT void fbInitializeDrawable(DrawablePtr d);
+extern _X_EXPORT void fbSetBits(FbStip * bits, int stride, FbStip data);
+
+#define FB_HEAD_BITS   (FbStip) (0xbaadf00d)
+#define FB_TAIL_BITS   (FbStip) (0xbaddf0ad)
+#else
+#define fbValidateDrawable(d)
+#define fdInitializeDrawable(d)
+#endif
+
+#include "fbrop.h"
+
+#if BITMAP_BIT_ORDER == LSBFirst
+#define FbScrLeft(x,n)	((x) >> (n))
+#define FbScrRight(x,n)	((x) << (n))
+/* #define FbLeftBits(x,n)	((x) & ((((FbBits) 1) << (n)) - 1)) */
+#define FbLeftStipBits(x,n) ((x) & ((((FbStip) 1) << (n)) - 1))
+#define FbStipMoveLsb(x,s,n)	(FbStipRight (x,(s)-(n)))
+#define FbPatternOffsetBits	0
+#else
+#define FbScrLeft(x,n)	((x) << (n))
+#define FbScrRight(x,n)	((x) >> (n))
+/* #define FbLeftBits(x,n)	((x) >> (FB_UNIT - (n))) */
+#define FbLeftStipBits(x,n) ((x) >> (FB_STIP_UNIT - (n)))
+#define FbStipMoveLsb(x,s,n)	(x)
+#define FbPatternOffsetBits	(sizeof (FbBits) - 1)
+#endif
+
+#include "micoord.h"
+
+#define FbStipLeft(x,n)	FbScrLeft(x,n)
+#define FbStipRight(x,n) FbScrRight(x,n)
+
+#define FbRotLeft(x,n)	FbScrLeft(x,n) | (n ? FbScrRight(x,FB_UNIT-n) : 0)
+#define FbRotRight(x,n)	FbScrRight(x,n) | (n ? FbScrLeft(x,FB_UNIT-n) : 0)
+
+#define FbRotStipLeft(x,n)  FbStipLeft(x,n) | (n ? FbStipRight(x,FB_STIP_UNIT-n) : 0)
+#define FbRotStipRight(x,n)  FbStipRight(x,n) | (n ? FbStipLeft(x,FB_STIP_UNIT-n) : 0)
+
+#define FbLeftMask(x)	    ( ((x) & FB_MASK) ? \
+			     FbScrRight(FB_ALLONES,(x) & FB_MASK) : 0)
+#define FbRightMask(x)	    ( ((FB_UNIT - (x)) & FB_MASK) ? \
+			     FbScrLeft(FB_ALLONES,(FB_UNIT - (x)) & FB_MASK) : 0)
+
+#define FbLeftStipMask(x)   ( ((x) & FB_STIP_MASK) ? \
+			     FbStipRight(FB_STIP_ALLONES,(x) & FB_STIP_MASK) : 0)
+#define FbRightStipMask(x)  ( ((FB_STIP_UNIT - (x)) & FB_STIP_MASK) ? \
+			     FbScrLeft(FB_STIP_ALLONES,(FB_STIP_UNIT - (x)) & FB_STIP_MASK) : 0)
+
+#define FbBitsMask(x,w)	(FbScrRight(FB_ALLONES,(x) & FB_MASK) & \
+			 FbScrLeft(FB_ALLONES,(FB_UNIT - ((x) + (w))) & FB_MASK))
+
+#define FbStipMask(x,w)	(FbStipRight(FB_STIP_ALLONES,(x) & FB_STIP_MASK) & \
+			 FbStipLeft(FB_STIP_ALLONES,(FB_STIP_UNIT - ((x)+(w))) & FB_STIP_MASK))
+
+#define FbMaskBits(x,w,l,n,r) { \
+    n = (w); \
+    r = FbRightMask((x)+n); \
+    l = FbLeftMask(x); \
+    if (l) { \
+	n -= FB_UNIT - ((x) & FB_MASK); \
+	if (n < 0) { \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	} \
+    } \
+    n >>= FB_SHIFT; \
+}
+
+#define FbByteMaskInvalid   0x10
+
+#define FbPatternOffset(o,t)  ((o) ^ (FbPatternOffsetBits & ~(sizeof (t) - 1)))
+
+#define FbPtrOffset(p,o,t)		((t *) ((CARD8 *) (p) + (o)))
+#define FbSelectPatternPart(xor,o,t)	((xor) >> (FbPatternOffset (o,t) << 3))
+#define FbStorePart(dst,off,t,xor)	(WRITE(FbPtrOffset(dst,off,t), \
+					 FbSelectPart(xor,off,t)))
+#ifndef FbSelectPart
+#define FbSelectPart(x,o,t) FbSelectPatternPart(x,o,t)
+#endif
+
+#define FbMaskBitsBytes(x,w,copy,l,lb,n,r,rb) { \
+    n = (w); \
+    lb = 0; \
+    rb = 0; \
+    r = FbRightMask((x)+n); \
+    if (r) { \
+	/* compute right byte length */ \
+	if ((copy) && (((x) + n) & 7) == 0) { \
+	    rb = (((x) + n) & FB_MASK) >> 3; \
+	} else { \
+	    rb = FbByteMaskInvalid; \
+	} \
+    } \
+    l = FbLeftMask(x); \
+    if (l) { \
+	/* compute left byte length */ \
+	if ((copy) && ((x) & 7) == 0) { \
+	    lb = ((x) & FB_MASK) >> 3; \
+	} else { \
+	    lb = FbByteMaskInvalid; \
+	} \
+	/* subtract out the portion painted by leftMask */ \
+	n -= FB_UNIT - ((x) & FB_MASK); \
+	if (n < 0) { \
+	    if (lb != FbByteMaskInvalid) { \
+		if (rb == FbByteMaskInvalid) { \
+		    lb = FbByteMaskInvalid; \
+		} else if (rb) { \
+		    lb |= (rb - lb) << (FB_SHIFT - 3); \
+		    rb = 0; \
+		} \
+	    } \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	}\
+    } \
+    n >>= FB_SHIFT; \
+}
+
+#if FB_SHIFT == 6
+#define FbDoLeftMaskByteRRop6Cases(dst,xor) \
+    case (sizeof (FbBits) - 7) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (5 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (6 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (5 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 4): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break;
+
+#define FbDoRightMaskByteRRop6Cases(dst,xor) \
+    case 4: \
+	FbStorePart(dst,0,CARD32,xor); \
+	break; \
+    case 5: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD8,xor); \
+	break; \
+    case 6: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD16,xor); \
+	break; \
+    case 7: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD16,xor); \
+	FbStorePart(dst,6,CARD8,xor); \
+	break;
+#else
+#define FbDoLeftMaskByteRRop6Cases(dst,xor)
+#define FbDoRightMaskByteRRop6Cases(dst,xor)
+#endif
+
+#define FbDoLeftMaskByteRRop(dst,lb,l,and,xor) { \
+    switch (lb) { \
+    FbDoLeftMaskByteRRop6Cases(dst,xor) \
+    case (sizeof (FbBits) - 3) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 3) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 2) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case sizeof (FbBits) - 3: \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+    case sizeof (FbBits) - 2: \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD16,xor); \
+	break; \
+    case sizeof (FbBits) - 1: \
+	FbStorePart(dst,sizeof (FbBits) - 1,CARD8,xor); \
+	break; \
+    default: \
+	WRITE(dst, FbDoMaskRRop(READ(dst), and, xor, l)); \
+	break; \
+    } \
+}
+
+#define FbDoRightMaskByteRRop(dst,rb,r,and,xor) { \
+    switch (rb) { \
+    case 1: \
+	FbStorePart(dst,0,CARD8,xor); \
+	break; \
+    case 2: \
+	FbStorePart(dst,0,CARD16,xor); \
+	break; \
+    case 3: \
+	FbStorePart(dst,0,CARD16,xor); \
+	FbStorePart(dst,2,CARD8,xor); \
+	break; \
+    FbDoRightMaskByteRRop6Cases(dst,xor) \
+    default: \
+	WRITE(dst, FbDoMaskRRop (READ(dst), and, xor, r)); \
+    } \
+}
+
+#define FbMaskStip(x,w,l,n,r) { \
+    n = (w); \
+    r = FbRightStipMask((x)+n); \
+    l = FbLeftStipMask(x); \
+    if (l) { \
+	n -= FB_STIP_UNIT - ((x) & FB_STIP_MASK); \
+	if (n < 0) { \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	} \
+    } \
+    n >>= FB_STIP_SHIFT; \
+}
+
+/*
+ * These macros are used to transparently stipple
+ * in copy mode; the expected usage is with 'n' constant
+ * so all of the conditional parts collapse into a minimal
+ * sequence of partial word writes
+ *
+ * 'n' is the bytemask of which bytes to store, 'a' is the address
+ * of the FbBits base unit, 'o' is the offset within that unit
+ *
+ * The term "lane" comes from the hardware term "byte-lane" which
+ */
+
+#define FbLaneCase1(n,a,o)						\
+    if ((n) == 0x01) {							\
+	WRITE((CARD8 *) ((a)+FbPatternOffset(o,CARD8)), fgxor);		\
+    }
+
+#define FbLaneCase2(n,a,o)						\
+    if ((n) == 0x03) {							\
+	WRITE((CARD16 *) ((a)+FbPatternOffset(o,CARD16)), fgxor);	\
+    } else {								\
+	FbLaneCase1((n)&1,a,o)						\
+	FbLaneCase1((n)>>1,a,(o)+1)					\
+    }
+
+#define FbLaneCase4(n,a,o)						\
+    if ((n) == 0x0f) {							\
+	WRITE((CARD32 *) ((a)+FbPatternOffset(o,CARD32)), fgxor);	\
+    } else {								\
+	FbLaneCase2((n)&3,a,o)						\
+	FbLaneCase2((n)>>2,a,(o)+2)					\
+    }
+
+#define FbLaneCase8(n,a,o)						\
+    if ((n) == 0x0ff) {							\
+	*(FbBits *) ((a)+(o)) = fgxor;					\
+    } else {								\
+	FbLaneCase4((n)&15,a,o)						\
+	FbLaneCase4((n)>>4,a,(o)+4)					\
+    }
+
+#if FB_SHIFT == 6
+#define FbLaneCase(n,a)   FbLaneCase8(n,(CARD8 *) (a),0)
+#endif
+
+#if FB_SHIFT == 5
+#define FbLaneCase(n,a)   FbLaneCase4(n,(CARD8 *) (a),0)
+#endif
+
+/* Rotate a filled pixel value to the specified alignement */
+#define FbRot24(p,b)	    (FbScrRight(p,b) | FbScrLeft(p,24-(b)))
+#define FbRot24Stip(p,b)    (FbStipRight(p,b) | FbStipLeft(p,24-(b)))
+
+/* step a filled pixel value to the next/previous FB_UNIT alignment */
+#define FbNext24Pix(p)	(FbRot24(p,(24-FB_UNIT%24)))
+#define FbPrev24Pix(p)	(FbRot24(p,FB_UNIT%24))
+#define FbNext24Stip(p)	(FbRot24(p,(24-FB_STIP_UNIT%24)))
+#define FbPrev24Stip(p)	(FbRot24(p,FB_STIP_UNIT%24))
+
+/* step a rotation value to the next/previous rotation value */
+#if FB_UNIT == 64
+#define FbNext24Rot(r)        ((r) == 16 ? 0 : (r) + 8)
+#define FbPrev24Rot(r)        ((r) == 0 ? 16 : (r) - 8)
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define FbFirst24Rot(x)		(((x) + 8) % 24)
+#else
+#define FbFirst24Rot(x)		((x) % 24)
+#endif
+
+#endif
+
+#if FB_UNIT == 32
+#define FbNext24Rot(r)        ((r) == 0 ? 16 : (r) - 8)
+#define FbPrev24Rot(r)        ((r) == 16 ? 0 : (r) + 8)
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define FbFirst24Rot(x)		(((x) + 16) % 24)
+#else
+#define FbFirst24Rot(x)		((x) % 24)
+#endif
+#endif
+
+#define FbNext24RotStip(r)        ((r) == 0 ? 16 : (r) - 8)
+#define FbPrev24RotStip(r)        ((r) == 16 ? 0 : (r) + 8)
+
+/* Whether 24-bit specific code is needed for this filled pixel value */
+#define FbCheck24Pix(p)	((p) == FbNext24Pix(p))
+
+/* Macros for dealing with dashing */
+
+#define FbDashDeclare	\
+    unsigned char	*__dash, *__firstDash, *__lastDash
+
+#define FbDashInit(pGC,pPriv,dashOffset,dashlen,even) {	    \
+    (even) = TRUE;					    \
+    __firstDash = (pGC)->dash;				    \
+    __lastDash = __firstDash + (pGC)->numInDashList;	    \
+    (dashOffset) %= (pPriv)->dashLength;		    \
+							    \
+    __dash = __firstDash;				    \
+    while ((dashOffset) >= ((dashlen) = *__dash))	    \
+    {							    \
+	(dashOffset) -= (dashlen);			    \
+	(even) = 1-(even);				    \
+	if (++__dash == __lastDash)			    \
+	    __dash = __firstDash;			    \
+    }							    \
+    (dashlen) -= (dashOffset);				    \
+}
+
+#define FbDashNext(dashlen) {				    \
+    if (++__dash == __lastDash)				    \
+	__dash = __firstDash;				    \
+    (dashlen) = *__dash;				    \
+}
+
+/* as numInDashList is always even, this case can skip a test */
+
+#define FbDashNextEven(dashlen) {			    \
+    (dashlen) = *++__dash;				    \
+}
+
+#define FbDashNextOdd(dashlen)	FbDashNext(dashlen)
+
+#define FbDashStep(dashlen,even) {			    \
+    if (!--(dashlen)) {					    \
+	FbDashNext(dashlen);				    \
+	(even) = 1-(even);				    \
+    }							    \
+}
+
+extern _X_EXPORT const GCOps fbGCOps;
+extern _X_EXPORT const GCFuncs fbGCFuncs;
+
+/* Framebuffer access wrapper */
+typedef FbBits(*ReadMemoryProcPtr) (const void *src, int size);
+typedef void (*WriteMemoryProcPtr) (void *dst, FbBits value, int size);
+typedef void (*SetupWrapProcPtr) (ReadMemoryProcPtr * pRead,
+                                  WriteMemoryProcPtr * pWrite,
+                                  DrawablePtr pDraw);
+typedef void (*FinishWrapProcPtr) (DrawablePtr pDraw);
+
+#ifdef FB_ACCESS_WRAPPER
+
+#define fbPrepareAccess(pDraw) \
+	fbGetScreenPrivate((pDraw)->pScreen)->setupWrap( \
+		&wfbReadMemory, \
+		&wfbWriteMemory, \
+		(pDraw))
+#define fbFinishAccess(pDraw) \
+	fbGetScreenPrivate((pDraw)->pScreen)->finishWrap(pDraw)
+
+#else
+
+#define fbPrepareAccess(pPix)
+#define fbFinishAccess(pDraw)
+
+#endif
+
+extern _X_EXPORT DevPrivateKey
+fbGetScreenPrivateKey(void);
+
+/* private field of a screen */
+typedef struct {
+    unsigned char win32bpp;     /* window bpp for 32-bpp images */
+    unsigned char pix32bpp;     /* pixmap bpp for 32-bpp images */
+#ifdef FB_ACCESS_WRAPPER
+    SetupWrapProcPtr setupWrap; /* driver hook to set pixmap access wrapping */
+    FinishWrapProcPtr finishWrap;       /* driver hook to clean up pixmap access wrapping */
+#endif
+    DevPrivateKeyRec    gcPrivateKeyRec;
+    DevPrivateKeyRec    winPrivateKeyRec;
+} FbScreenPrivRec, *FbScreenPrivPtr;
+
+#define fbGetScreenPrivate(pScreen) ((FbScreenPrivPtr) \
+				     dixLookupPrivate(&(pScreen)->devPrivates, fbGetScreenPrivateKey()))
+
+/* private field of GC */
+typedef struct {
+    FbBits and, xor;            /* reduced rop values */
+    FbBits bgand, bgxor;        /* for stipples */
+    FbBits fg, bg, pm;          /* expanded and filled */
+    unsigned int dashLength;    /* total of all dash elements */
+    unsigned char evenStipple;  /* stipple is even */
+    unsigned char bpp;          /* current drawable bpp */
+} FbGCPrivRec, *FbGCPrivPtr;
+
+#define fbGetGCPrivateKey(pGC)  (&fbGetScreenPrivate((pGC)->pScreen)->gcPrivateKeyRec)
+
+#define fbGetGCPrivate(pGC)	((FbGCPrivPtr)\
+				 dixLookupPrivate(&(pGC)->devPrivates, fbGetGCPrivateKey(pGC)))
+
+#define fbGetCompositeClip(pGC) ((pGC)->pCompositeClip)
+#define fbGetExpose(pGC)	((pGC)->fExpose)
+#define fbGetFreeCompClip(pGC)	((pGC)->freeCompClip)
+#define fbGetRotatedPixmap(pGC)	((pGC)->pRotatedPixmap)
+
+#define fbGetScreenPixmap(s)	((PixmapPtr) (s)->devPrivate)
+
+#define fbGetWinPrivateKey(pWin)        (&fbGetScreenPrivate(((DrawablePtr) (pWin))->pScreen)->winPrivateKeyRec)
+
+#define fbGetWindowPixmap(pWin)	((PixmapPtr)\
+				 dixLookupPrivate(&((WindowPtr)(pWin))->devPrivates, fbGetWinPrivateKey(pWin)))
+
+#ifdef ROOTLESS
+#define __fbPixDrawableX(pPix)	((pPix)->drawable.x)
+#define __fbPixDrawableY(pPix)	((pPix)->drawable.y)
+#else
+#define __fbPixDrawableX(pPix)	0
+#define __fbPixDrawableY(pPix)	0
+#endif
+
+#ifdef COMPOSITE
+#define __fbPixOffXWin(pPix)	(__fbPixDrawableX(pPix) - (pPix)->screen_x)
+#define __fbPixOffYWin(pPix)	(__fbPixDrawableY(pPix) - (pPix)->screen_y)
+#else
+#define __fbPixOffXWin(pPix)	(__fbPixDrawableX(pPix))
+#define __fbPixOffYWin(pPix)	(__fbPixDrawableY(pPix))
+#endif
+#define __fbPixOffXPix(pPix)	(__fbPixDrawableX(pPix))
+#define __fbPixOffYPix(pPix)	(__fbPixDrawableY(pPix))
+
+#define fbGetDrawablePixmap(pDrawable, pixmap, xoff, yoff) {			\
+    if ((pDrawable)->type != DRAWABLE_PIXMAP) { 				\
+	(pixmap) = fbGetWindowPixmap(pDrawable);				\
+	(xoff) = __fbPixOffXWin(pixmap); 					\
+	(yoff) = __fbPixOffYWin(pixmap); 					\
+    } else { 									\
+	(pixmap) = (PixmapPtr) (pDrawable);					\
+	(xoff) = __fbPixOffXPix(pixmap); 					\
+	(yoff) = __fbPixOffYPix(pixmap); 					\
+    } 										\
+    fbPrepareAccess(pDrawable); 						\
+}
+
+#define fbGetPixmapBitsData(pixmap, pointer, stride, bpp) {			\
+    (pointer) = (FbBits *) (pixmap)->devPrivate.ptr; 			       	\
+    (stride) = ((int) (pixmap)->devKind) / sizeof (FbBits); (void)(stride);	\
+    (bpp) = (pixmap)->drawable.bitsPerPixel;  (void)(bpp); 			\
+}
+
+#define fbGetPixmapStipData(pixmap, pointer, stride, bpp) {			\
+    (pointer) = (FbStip *) (pixmap)->devPrivate.ptr; 			       	\
+    (stride) = ((int) (pixmap)->devKind) / sizeof (FbStip); (void)(stride);	\
+    (bpp) = (pixmap)->drawable.bitsPerPixel;  (void)(bpp); 			\
+}
+
+#define fbGetDrawable(pDrawable, pointer, stride, bpp, xoff, yoff) { 		\
+    PixmapPtr   _pPix; 								\
+    fbGetDrawablePixmap(pDrawable, _pPix, xoff, yoff); 				\
+    fbGetPixmapBitsData(_pPix, pointer, stride, bpp);				\
+}
+
+#define fbGetStipDrawable(pDrawable, pointer, stride, bpp, xoff, yoff) { 	\
+    PixmapPtr   _pPix; 								\
+    fbGetDrawablePixmap(pDrawable, _pPix, xoff, yoff);				\
+    fbGetPixmapStipData(_pPix, pointer, stride, bpp);				\
+}
+
+/*
+ * XFree86 empties the root BorderClip when the VT is inactive,
+ * here's a macro which uses that to disable GetImage and GetSpans
+ */
+
+#define fbWindowEnabled(pWin) \
+    RegionNotEmpty(&(pWin)->drawable.pScreen->root->borderClip)
+
+#define fbDrawableEnabled(pDrawable) \
+    ((pDrawable)->type == DRAWABLE_PIXMAP ? \
+     TRUE : fbWindowEnabled((WindowPtr) pDrawable))
+
+#define FbPowerOfTwo(w)	    (((w) & ((w) - 1)) == 0)
+/*
+ * Accelerated tiles are power of 2 width <= FB_UNIT
+ */
+#define FbEvenTile(w)	    ((w) <= FB_UNIT && FbPowerOfTwo(w))
+/*
+ * Accelerated stipples are power of 2 width and <= FB_UNIT/dstBpp
+ * with dstBpp a power of 2 as well
+ */
+#define FbEvenStip(w,bpp)   ((w) * (bpp) <= FB_UNIT && FbPowerOfTwo(w) && FbPowerOfTwo(bpp))
+
+/*
+ * fb24_32.c
+ */
+extern _X_EXPORT void
+
+fb24_32GetSpans(DrawablePtr pDrawable,
+                int wMax,
+                DDXPointPtr ppt, int *pwidth, int nspans, char *pchardstStart);
+
+extern _X_EXPORT void
+
+fb24_32SetSpans(DrawablePtr pDrawable,
+                GCPtr pGC,
+                char *src,
+                DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+
+extern _X_EXPORT void
+
+fb24_32PutZImage(DrawablePtr pDrawable,
+                 RegionPtr pClip,
+                 int alu,
+                 FbBits pm,
+                 int x,
+                 int y, int width, int height, CARD8 *src, FbStride srcStride);
+
+extern _X_EXPORT void
+
+fb24_32GetImage(DrawablePtr pDrawable,
+                int x,
+                int y,
+                int w,
+                int h, unsigned int format, unsigned long planeMask, char *d);
+
+extern _X_EXPORT void
+
+fb24_32CopyMtoN(DrawablePtr pSrcDrawable,
+                DrawablePtr pDstDrawable,
+                GCPtr pGC,
+                BoxPtr pbox,
+                int nbox,
+                int dx,
+                int dy,
+                Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT PixmapPtr
+ fb24_32ReformatTile(PixmapPtr pOldTile, int bitsPerPixel);
+
+extern _X_EXPORT Bool
+ fb24_32CreateScreenResources(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+
+fb24_32ModifyPixmapHeader(PixmapPtr pPixmap,
+                          int width,
+                          int height,
+                          int depth,
+                          int bitsPerPixel, int devKind, void *pPixData);
+
+/*
+ * fballpriv.c
+ */
+extern _X_EXPORT Bool
+fbAllocatePrivates(ScreenPtr pScreen);
+
+/*
+ * fbarc.c
+ */
+
+extern _X_EXPORT void
+fbPolyArc(DrawablePtr pDrawable, GCPtr pGC, int narcs, xArc * parcs);
+
+/*
+ * fbbits.c
+ */
+
+extern _X_EXPORT void
+
+fbBresSolid8(DrawablePtr pDrawable,
+             GCPtr pGC,
+             int dashOffset,
+             int signdx,
+             int signdy,
+             int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbBresDash8(DrawablePtr pDrawable,
+            GCPtr pGC,
+            int dashOffset,
+            int signdx,
+            int signdy, int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbDots8(FbBits * dst,
+        FbStride dstStride,
+        int dstBpp,
+        BoxPtr pBox,
+        xPoint * pts,
+        int npt,
+        int xorg, int yorg, int xoff, int yoff, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbArc8(FbBits * dst,
+       FbStride dstStride,
+       int dstBpp, xArc * arc, int dx, int dy, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbGlyph8(FbBits * dstLine,
+         FbStride dstStride,
+         int dstBpp, FbStip * stipple, FbBits fg, int height, int shift);
+
+extern _X_EXPORT void
+
+fbPolyline8(DrawablePtr pDrawable,
+            GCPtr pGC, int mode, int npt, DDXPointPtr ptsOrig);
+
+extern _X_EXPORT void
+ fbPolySegment8(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);
+
+extern _X_EXPORT void
+
+fbBresSolid16(DrawablePtr pDrawable,
+              GCPtr pGC,
+              int dashOffset,
+              int signdx,
+              int signdy,
+              int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbBresDash16(DrawablePtr pDrawable,
+             GCPtr pGC,
+             int dashOffset,
+             int signdx,
+             int signdy,
+             int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbDots16(FbBits * dst,
+         FbStride dstStride,
+         int dstBpp,
+         BoxPtr pBox,
+         xPoint * pts,
+         int npt,
+         int xorg, int yorg, int xoff, int yoff, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbArc16(FbBits * dst,
+        FbStride dstStride,
+        int dstBpp, xArc * arc, int dx, int dy, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbGlyph16(FbBits * dstLine,
+          FbStride dstStride,
+          int dstBpp, FbStip * stipple, FbBits fg, int height, int shift);
+
+extern _X_EXPORT void
+
+fbPolyline16(DrawablePtr pDrawable,
+             GCPtr pGC, int mode, int npt, DDXPointPtr ptsOrig);
+
+extern _X_EXPORT void
+ fbPolySegment16(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);
+
+extern _X_EXPORT void
+
+fbBresSolid24(DrawablePtr pDrawable,
+              GCPtr pGC,
+              int dashOffset,
+              int signdx,
+              int signdy,
+              int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbBresDash24(DrawablePtr pDrawable,
+             GCPtr pGC,
+             int dashOffset,
+             int signdx,
+             int signdy,
+             int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbDots24(FbBits * dst,
+         FbStride dstStride,
+         int dstBpp,
+         BoxPtr pBox,
+         xPoint * pts,
+         int npt,
+         int xorg, int yorg, int xoff, int yoff, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbArc24(FbBits * dst,
+        FbStride dstStride,
+        int dstBpp, xArc * arc, int dx, int dy, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbGlyph24(FbBits * dstLine,
+          FbStride dstStride,
+          int dstBpp, FbStip * stipple, FbBits fg, int height, int shift);
+
+extern _X_EXPORT void
+
+fbPolyline24(DrawablePtr pDrawable,
+             GCPtr pGC, int mode, int npt, DDXPointPtr ptsOrig);
+
+extern _X_EXPORT void
+ fbPolySegment24(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);
+
+extern _X_EXPORT void
+
+fbBresSolid32(DrawablePtr pDrawable,
+              GCPtr pGC,
+              int dashOffset,
+              int signdx,
+              int signdy,
+              int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbBresDash32(DrawablePtr pDrawable,
+             GCPtr pGC,
+             int dashOffset,
+             int signdx,
+             int signdy,
+             int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbDots32(FbBits * dst,
+         FbStride dstStride,
+         int dstBpp,
+         BoxPtr pBox,
+         xPoint * pts,
+         int npt,
+         int xorg, int yorg, int xoff, int yoff, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbArc32(FbBits * dst,
+        FbStride dstStride,
+        int dstBpp, xArc * arc, int dx, int dy, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbGlyph32(FbBits * dstLine,
+          FbStride dstStride,
+          int dstBpp, FbStip * stipple, FbBits fg, int height, int shift);
+extern _X_EXPORT void
+
+fbPolyline32(DrawablePtr pDrawable,
+             GCPtr pGC, int mode, int npt, DDXPointPtr ptsOrig);
+
+extern _X_EXPORT void
+ fbPolySegment32(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);
+
+/*
+ * fbblt.c
+ */
+extern _X_EXPORT void
+
+fbBlt(FbBits * src,
+      FbStride srcStride,
+      int srcX,
+      FbBits * dst,
+      FbStride dstStride,
+      int dstX,
+      int width,
+      int height, int alu, FbBits pm, int bpp, Bool reverse, Bool upsidedown);
+
+extern _X_EXPORT void
+
+fbBlt24(FbBits * srcLine,
+        FbStride srcStride,
+        int srcX,
+        FbBits * dstLine,
+        FbStride dstStride,
+        int dstX,
+        int width,
+        int height, int alu, FbBits pm, Bool reverse, Bool upsidedown);
+
+extern _X_EXPORT void
+ fbBltStip(FbStip * src, FbStride srcStride,    /* in FbStip units, not FbBits units */
+           int srcX, FbStip * dst, FbStride dstStride,  /* in FbStip units, not FbBits units */
+           int dstX, int width, int height, int alu, FbBits pm, int bpp);
+
+/*
+ * fbbltone.c
+ */
+extern _X_EXPORT void
+
+fbBltOne(FbStip * src,
+         FbStride srcStride,
+         int srcX,
+         FbBits * dst,
+         FbStride dstStride,
+         int dstX,
+         int dstBpp,
+         int width,
+         int height, FbBits fgand, FbBits fbxor, FbBits bgand, FbBits bgxor);
+
+extern _X_EXPORT void
+ fbBltOne24(FbStip * src, FbStride srcStride,   /* FbStip units per scanline */
+            int srcX,           /* bit position of source */
+            FbBits * dst, FbStride dstStride,   /* FbBits units per scanline */
+            int dstX,           /* bit position of dest */
+            int dstBpp,         /* bits per destination unit */
+            int width,          /* width in bits of destination */
+            int height,         /* height in scanlines */
+            FbBits fgand,       /* rrop values */
+            FbBits fgxor, FbBits bgand, FbBits bgxor);
+
+extern _X_EXPORT void
+
+fbBltPlane(FbBits * src,
+           FbStride srcStride,
+           int srcX,
+           int srcBpp,
+           FbStip * dst,
+           FbStride dstStride,
+           int dstX,
+           int width,
+           int height,
+           FbStip fgand,
+           FbStip fgxor, FbStip bgand, FbStip bgxor, Pixel planeMask);
+
+/*
+ * fbcmap_mi.c
+ */
+extern _X_EXPORT int
+ fbListInstalledColormaps(ScreenPtr pScreen, Colormap * pmaps);
+
+extern _X_EXPORT void
+ fbInstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void
+ fbUninstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void
+
+fbResolveColor(unsigned short *pred,
+               unsigned short *pgreen,
+               unsigned short *pblue, VisualPtr pVisual);
+
+extern _X_EXPORT Bool
+ fbInitializeColormap(ColormapPtr pmap);
+
+extern _X_EXPORT int
+
+fbExpandDirectColors(ColormapPtr pmap,
+                     int ndef, xColorItem * indefs, xColorItem * outdefs);
+
+extern _X_EXPORT Bool
+ fbCreateDefColormap(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+ fbClearVisualTypes(void);
+
+extern _X_EXPORT Bool
+ fbHasVisualTypes(int depth);
+
+extern _X_EXPORT Bool
+ fbSetVisualTypes(int depth, int visuals, int bitsPerRGB);
+
+extern _X_EXPORT Bool
+
+fbSetVisualTypesAndMasks(int depth, int visuals, int bitsPerRGB,
+                         Pixel redMask, Pixel greenMask, Pixel blueMask);
+
+extern _X_EXPORT Bool
+
+fbInitVisuals(VisualPtr * visualp,
+              DepthPtr * depthp,
+              int *nvisualp,
+              int *ndepthp,
+              int *rootDepthp,
+              VisualID * defaultVisp, unsigned long sizes, int bitsPerRGB);
+
+/*
+ * fbcopy.c
+ */
+
+extern _X_EXPORT void
+
+fbCopyNtoN(DrawablePtr pSrcDrawable,
+           DrawablePtr pDstDrawable,
+           GCPtr pGC,
+           BoxPtr pbox,
+           int nbox,
+           int dx,
+           int dy,
+           Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT void
+
+fbCopy1toN(DrawablePtr pSrcDrawable,
+           DrawablePtr pDstDrawable,
+           GCPtr pGC,
+           BoxPtr pbox,
+           int nbox,
+           int dx,
+           int dy,
+           Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT void
+
+fbCopyNto1(DrawablePtr pSrcDrawable,
+           DrawablePtr pDstDrawable,
+           GCPtr pGC,
+           BoxPtr pbox,
+           int nbox,
+           int dx,
+           int dy,
+           Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT RegionPtr
+
+fbCopyArea(DrawablePtr pSrcDrawable,
+           DrawablePtr pDstDrawable,
+           GCPtr pGC,
+           int xIn, int yIn, int widthSrc, int heightSrc, int xOut, int yOut);
+
+extern _X_EXPORT RegionPtr
+
+fbCopyPlane(DrawablePtr pSrcDrawable,
+            DrawablePtr pDstDrawable,
+            GCPtr pGC,
+            int xIn,
+            int yIn,
+            int widthSrc,
+            int heightSrc, int xOut, int yOut, unsigned long bitplane);
+
+/*
+ * fbfill.c
+ */
+extern _X_EXPORT void
+ fbFill(DrawablePtr pDrawable, GCPtr pGC, int x, int y, int width, int height);
+
+extern _X_EXPORT void
+
+fbSolidBoxClipped(DrawablePtr pDrawable,
+                  RegionPtr pClip,
+                  int xa, int ya, int xb, int yb, FbBits and, FbBits xor);
+
+/*
+ * fbfillrect.c
+ */
+extern _X_EXPORT void
+
+fbPolyFillRect(DrawablePtr pDrawable,
+               GCPtr pGC, int nrectInit, xRectangle *prectInit);
+
+#define fbPolyFillArc miPolyFillArc
+
+#define fbFillPolygon miFillPolygon
+
+/*
+ * fbfillsp.c
+ */
+extern _X_EXPORT void
+
+fbFillSpans(DrawablePtr pDrawable,
+            GCPtr pGC,
+            int nInit, DDXPointPtr pptInit, int *pwidthInit, int fSorted);
+
+/*
+ * fbgc.c
+ */
+
+extern _X_EXPORT Bool
+ fbCreateGC(GCPtr pGC);
+
+extern _X_EXPORT void
+ fbPadPixmap(PixmapPtr pPixmap);
+
+extern _X_EXPORT void
+ fbValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable);
+
+/*
+ * fbgetsp.c
+ */
+extern _X_EXPORT void
+
+fbGetSpans(DrawablePtr pDrawable,
+           int wMax,
+           DDXPointPtr ppt, int *pwidth, int nspans, char *pchardstStart);
+
+/*
+ * fbglyph.c
+ */
+
+extern _X_EXPORT Bool
+ fbGlyphIn(RegionPtr pRegion, int x, int y, int width, int height);
+
+extern _X_EXPORT void
+
+fbPolyGlyphBlt(DrawablePtr pDrawable,
+               GCPtr pGC,
+               int x,
+               int y,
+               unsigned int nglyph, CharInfoPtr * ppci, void *pglyphBase);
+
+extern _X_EXPORT void
+
+fbImageGlyphBlt(DrawablePtr pDrawable,
+                GCPtr pGC,
+                int x,
+                int y,
+                unsigned int nglyph, CharInfoPtr * ppci, void *pglyphBase);
+
+/*
+ * fbimage.c
+ */
+
+extern _X_EXPORT void
+
+fbPutImage(DrawablePtr pDrawable,
+           GCPtr pGC,
+           int depth,
+           int x, int y, int w, int h, int leftPad, int format, char *pImage);
+
+extern _X_EXPORT void
+
+fbPutZImage(DrawablePtr pDrawable,
+            RegionPtr pClip,
+            int alu,
+            FbBits pm,
+            int x,
+            int y, int width, int height, FbStip * src, FbStride srcStride);
+
+extern _X_EXPORT void
+
+fbPutXYImage(DrawablePtr pDrawable,
+             RegionPtr pClip,
+             FbBits fg,
+             FbBits bg,
+             FbBits pm,
+             int alu,
+             Bool opaque,
+             int x,
+             int y,
+             int width, int height, FbStip * src, FbStride srcStride, int srcX);
+
+extern _X_EXPORT void
+
+fbGetImage(DrawablePtr pDrawable,
+           int x,
+           int y,
+           int w, int h, unsigned int format, unsigned long planeMask, char *d);
+/*
+ * fbline.c
+ */
+
+extern _X_EXPORT void
+
+fbZeroLine(DrawablePtr pDrawable,
+           GCPtr pGC, int mode, int npt, DDXPointPtr ppt);
+
+extern _X_EXPORT void
+ fbZeroSegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pSegs);
+
+extern _X_EXPORT void
+
+fbPolyLine(DrawablePtr pDrawable,
+           GCPtr pGC, int mode, int npt, DDXPointPtr ppt);
+
+extern _X_EXPORT void
+ fbFixCoordModePrevious(int npt, DDXPointPtr ppt);
+
+extern _X_EXPORT void
+ fbPolySegment(DrawablePtr pDrawable, GCPtr pGC, int nseg, xSegment * pseg);
+
+#define fbPolyRectangle	miPolyRectangle
+
+/*
+ * fbpict.c
+ */
+
+extern _X_EXPORT Bool
+ fbPictureInit(ScreenPtr pScreen, PictFormatPtr formats, int nformats);
+
+extern _X_EXPORT void
+fbDestroyGlyphCache(void);
+
+/*
+ * fbpixmap.c
+ */
+
+extern _X_EXPORT PixmapPtr
+
+fbCreatePixmapBpp(ScreenPtr pScreen, int width, int height, int depth, int bpp,
+                  unsigned usage_hint);
+
+extern _X_EXPORT PixmapPtr
+
+fbCreatePixmap(ScreenPtr pScreen, int width, int height, int depth,
+               unsigned usage_hint);
+
+extern _X_EXPORT Bool
+ fbDestroyPixmap(PixmapPtr pPixmap);
+
+extern _X_EXPORT RegionPtr
+ fbPixmapToRegion(PixmapPtr pPix);
+
+/*
+ * fbpoint.c
+ */
+
+extern _X_EXPORT void
+
+fbDots(FbBits * dstOrig,
+       FbStride dstStride,
+       int dstBpp,
+       BoxPtr pBox,
+       xPoint * pts,
+       int npt,
+       int xorg, int yorg, int xoff, int yoff, FbBits andOrig, FbBits xorOrig);
+
+extern _X_EXPORT void
+
+fbPolyPoint(DrawablePtr pDrawable,
+            GCPtr pGC, int mode, int npt, xPoint * pptInit);
+
+/*
+ * fbpush.c
+ */
+extern _X_EXPORT void
+
+fbPushPattern(DrawablePtr pDrawable,
+              GCPtr pGC,
+              FbStip * src,
+              FbStride srcStride,
+              int srcX, int x, int y, int width, int height);
+
+extern _X_EXPORT void
+
+fbPushFill(DrawablePtr pDrawable,
+           GCPtr pGC,
+           FbStip * src,
+           FbStride srcStride, int srcX, int x, int y, int width, int height);
+
+extern _X_EXPORT void
+
+fbPushImage(DrawablePtr pDrawable,
+            GCPtr pGC,
+            FbStip * src,
+            FbStride srcStride, int srcX, int x, int y, int width, int height);
+
+extern _X_EXPORT void
+
+fbPushPixels(GCPtr pGC,
+             PixmapPtr pBitmap,
+             DrawablePtr pDrawable, int dx, int dy, int xOrg, int yOrg);
+
+/*
+ * fbscreen.c
+ */
+
+extern _X_EXPORT Bool
+ fbCloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+ fbRealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern _X_EXPORT Bool
+ fbUnrealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern _X_EXPORT void
+
+fbQueryBestSize(int class,
+                unsigned short *width, unsigned short *height,
+                ScreenPtr pScreen);
+
+extern _X_EXPORT PixmapPtr
+ _fbGetWindowPixmap(WindowPtr pWindow);
+
+extern _X_EXPORT void
+ _fbSetWindowPixmap(WindowPtr pWindow, PixmapPtr pPixmap);
+
+extern _X_EXPORT Bool
+ fbSetupScreen(ScreenPtr pScreen, void *pbits,        /* pointer to screen bitmap */
+               int xsize,       /* in pixels */
+               int ysize, int dpix,     /* dots per inch */
+               int dpiy, int width,     /* pixel width of frame buffer */
+               int bpp);        /* bits per pixel of frame buffer */
+
+extern _X_EXPORT Bool
+
+wfbFinishScreenInit(ScreenPtr pScreen,
+                    void *pbits,
+                    int xsize,
+                    int ysize,
+                    int dpix,
+                    int dpiy,
+                    int width,
+                    int bpp,
+                    SetupWrapProcPtr setupWrap, FinishWrapProcPtr finishWrap);
+
+extern _X_EXPORT Bool
+
+wfbScreenInit(ScreenPtr pScreen,
+              void *pbits,
+              int xsize,
+              int ysize,
+              int dpix,
+              int dpiy,
+              int width,
+              int bpp,
+              SetupWrapProcPtr setupWrap, FinishWrapProcPtr finishWrap);
+
+extern _X_EXPORT Bool
+
+fbFinishScreenInit(ScreenPtr pScreen,
+                   void *pbits,
+                   int xsize,
+                   int ysize, int dpix, int dpiy, int width, int bpp);
+
+extern _X_EXPORT Bool
+
+fbScreenInit(ScreenPtr pScreen,
+             void *pbits,
+             int xsize, int ysize, int dpix, int dpiy, int width, int bpp);
+
+/*
+ * fbseg.c
+ */
+typedef void FbBres(DrawablePtr pDrawable,
+                    GCPtr pGC,
+                    int dashOffset,
+                    int signdx,
+                    int signdy,
+                    int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT FbBres fbBresSolid, fbBresDash, fbBresFill, fbBresFillDash;
+
+/*
+ * fbsetsp.c
+ */
+
+extern _X_EXPORT void
+
+fbSetSpans(DrawablePtr pDrawable,
+           GCPtr pGC,
+           char *src, DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+
+extern _X_EXPORT FbBres *fbSelectBres(DrawablePtr pDrawable, GCPtr pGC);
+
+extern _X_EXPORT void
+
+fbBres(DrawablePtr pDrawable,
+       GCPtr pGC,
+       int dashOffset,
+       int signdx,
+       int signdy, int axis, int x, int y, int e, int e1, int e3, int len);
+
+extern _X_EXPORT void
+
+fbSegment(DrawablePtr pDrawable,
+          GCPtr pGC,
+          int xa, int ya, int xb, int yb, Bool drawLast, int *dashOffset);
+
+/*
+ * fbsolid.c
+ */
+
+extern _X_EXPORT void
+
+fbSolid(FbBits * dst,
+        FbStride dstStride,
+        int dstX, int bpp, int width, int height, FbBits and, FbBits xor);
+
+extern _X_EXPORT void
+
+fbSolid24(FbBits * dst,
+          FbStride dstStride,
+          int dstX, int width, int height, FbBits and, FbBits xor);
+
+/*
+ * fbstipple.c
+ */
+
+extern _X_EXPORT void
+ fbTransparentSpan(FbBits * dst, FbBits stip, FbBits fgxor, int n);
+
+extern _X_EXPORT void
+
+fbEvenStipple(FbBits * dst,
+              FbStride dstStride,
+              int dstX,
+              int dstBpp,
+              int width,
+              int height,
+              FbStip * stip,
+              FbStride stipStride,
+              int stipHeight,
+              FbBits fgand,
+              FbBits fgxor, FbBits bgand, FbBits bgxor, int xRot, int yRot);
+
+extern _X_EXPORT void
+
+fbOddStipple(FbBits * dst,
+             FbStride dstStride,
+             int dstX,
+             int dstBpp,
+             int width,
+             int height,
+             FbStip * stip,
+             FbStride stipStride,
+             int stipWidth,
+             int stipHeight,
+             FbBits fgand,
+             FbBits fgxor, FbBits bgand, FbBits bgxor, int xRot, int yRot);
+
+extern _X_EXPORT void
+
+fbStipple(FbBits * dst,
+          FbStride dstStride,
+          int dstX,
+          int dstBpp,
+          int width,
+          int height,
+          FbStip * stip,
+          FbStride stipStride,
+          int stipWidth,
+          int stipHeight,
+          Bool even,
+          FbBits fgand,
+          FbBits fgxor, FbBits bgand, FbBits bgxor, int xRot, int yRot);
+
+/*
+ * fbtile.c
+ */
+
+extern _X_EXPORT void
+
+fbEvenTile(FbBits * dst,
+           FbStride dstStride,
+           int dstX,
+           int width,
+           int height,
+           FbBits * tile,
+           FbStride tileStride,
+           int tileHeight, int alu, FbBits pm, int xRot, int yRot);
+
+extern _X_EXPORT void
+
+fbOddTile(FbBits * dst,
+          FbStride dstStride,
+          int dstX,
+          int width,
+          int height,
+          FbBits * tile,
+          FbStride tileStride,
+          int tileWidth,
+          int tileHeight, int alu, FbBits pm, int bpp, int xRot, int yRot);
+
+extern _X_EXPORT void
+
+fbTile(FbBits * dst,
+       FbStride dstStride,
+       int dstX,
+       int width,
+       int height,
+       FbBits * tile,
+       FbStride tileStride,
+       int tileWidth,
+       int tileHeight, int alu, FbBits pm, int bpp, int xRot, int yRot);
+
+/*
+ * fbutil.c
+ */
+extern _X_EXPORT FbBits fbReplicatePixel(Pixel p, int bpp);
+
+extern _X_EXPORT void
+ fbReduceRasterOp(int rop, FbBits fg, FbBits pm, FbBits * andp, FbBits * xorp);
+
+#ifdef FB_ACCESS_WRAPPER
+extern _X_EXPORT ReadMemoryProcPtr wfbReadMemory;
+extern _X_EXPORT WriteMemoryProcPtr wfbWriteMemory;
+#endif
+
+/*
+ * fbwindow.c
+ */
+
+extern _X_EXPORT Bool
+ fbCreateWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+ fbDestroyWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+ fbMapWindow(WindowPtr pWindow);
+
+extern _X_EXPORT Bool
+ fbPositionWindow(WindowPtr pWin, int x, int y);
+
+extern _X_EXPORT Bool
+ fbUnmapWindow(WindowPtr pWindow);
+
+extern _X_EXPORT void
+
+fbCopyWindowProc(DrawablePtr pSrcDrawable,
+                 DrawablePtr pDstDrawable,
+                 GCPtr pGC,
+                 BoxPtr pbox,
+                 int nbox,
+                 int dx,
+                 int dy,
+                 Bool reverse, Bool upsidedown, Pixel bitplane, void *closure);
+
+extern _X_EXPORT void
+ fbCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+extern _X_EXPORT Bool
+ fbChangeWindowAttributes(WindowPtr pWin, unsigned long mask);
+
+extern _X_EXPORT void
+
+fbFillRegionSolid(DrawablePtr pDrawable,
+                  RegionPtr pRegion, FbBits and, FbBits xor);
+
+extern _X_EXPORT pixman_image_t *image_from_pict(PicturePtr pict,
+                                                 Bool has_clip,
+                                                 int *xoff, int *yoff);
+
+extern _X_EXPORT void free_pixman_pict(PicturePtr, pixman_image_t *);
+
+#endif                          /* _FB_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fb.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xserver-properties.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xserver-properties.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xserver-properties.h	(Revision 52145)
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software")
+ * to deal in the software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * them Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTIBILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* Properties managed by the server. */
+
+#ifndef _XSERVER_PROPERTIES_H_
+#define _XSERVER_PROPERTIES_H_
+
+/* Type for a 4 byte float. Storage format IEEE 754 in client's default
+ * byte-ordering. */
+#define XATOM_FLOAT "FLOAT"
+
+/* STRING. Seat name of this display */
+#define SEAT_ATOM_NAME "Xorg_Seat"
+
+/* BOOL. 0 - device disabled, 1 - device enabled */
+#define XI_PROP_ENABLED      "Device Enabled"
+/* BOOL. If present, device is a virtual XTEST device */
+#define XI_PROP_XTEST_DEVICE  "XTEST Device"
+
+/* CARD32, 2 values, vendor, product.
+ * This property is set by the driver and may not be available for some
+ * drivers. Read-Only */
+#define XI_PROP_PRODUCT_ID "Device Product ID"
+
+/* Coordinate transformation matrix for absolute input devices
+ * FLOAT, 9 values in row-major order, coordinates in 0..1 range:
+ * [c0 c1 c2]   [x]
+ * [c3 c4 c5] * [y]
+ * [c6 c7 c8]   [1] */
+#define XI_PROP_TRANSFORM "Coordinate Transformation Matrix"
+
+/* STRING. Device node path of device */
+#define XI_PROP_DEVICE_NODE "Device Node"
+
+/* Pointer acceleration properties */
+/* INTEGER of any format */
+#define ACCEL_PROP_PROFILE_NUMBER "Device Accel Profile"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_CONSTANT_DECELERATION "Device Accel Constant Deceleration"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_ADAPTIVE_DECELERATION "Device Accel Adaptive Deceleration"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_VELOCITY_SCALING "Device Accel Velocity Scaling"
+
+/* Axis labels */
+#define AXIS_LABEL_PROP "Axis Labels"
+
+#define AXIS_LABEL_PROP_REL_X           "Rel X"
+#define AXIS_LABEL_PROP_REL_Y           "Rel Y"
+#define AXIS_LABEL_PROP_REL_Z           "Rel Z"
+#define AXIS_LABEL_PROP_REL_RX          "Rel Rotary X"
+#define AXIS_LABEL_PROP_REL_RY          "Rel Rotary Y"
+#define AXIS_LABEL_PROP_REL_RZ          "Rel Rotary Z"
+#define AXIS_LABEL_PROP_REL_HWHEEL      "Rel Horiz Wheel"
+#define AXIS_LABEL_PROP_REL_DIAL        "Rel Dial"
+#define AXIS_LABEL_PROP_REL_WHEEL       "Rel Vert Wheel"
+#define AXIS_LABEL_PROP_REL_MISC        "Rel Misc"
+#define AXIS_LABEL_PROP_REL_VSCROLL     "Rel Vert Scroll"
+#define AXIS_LABEL_PROP_REL_HSCROLL     "Rel Horiz Scroll"
+
+/*
+ * Absolute axes
+ */
+
+#define AXIS_LABEL_PROP_ABS_X           "Abs X"
+#define AXIS_LABEL_PROP_ABS_Y           "Abs Y"
+#define AXIS_LABEL_PROP_ABS_Z           "Abs Z"
+#define AXIS_LABEL_PROP_ABS_RX          "Abs Rotary X"
+#define AXIS_LABEL_PROP_ABS_RY          "Abs Rotary Y"
+#define AXIS_LABEL_PROP_ABS_RZ          "Abs Rotary Z"
+#define AXIS_LABEL_PROP_ABS_THROTTLE    "Abs Throttle"
+#define AXIS_LABEL_PROP_ABS_RUDDER      "Abs Rudder"
+#define AXIS_LABEL_PROP_ABS_WHEEL       "Abs Wheel"
+#define AXIS_LABEL_PROP_ABS_GAS         "Abs Gas"
+#define AXIS_LABEL_PROP_ABS_BRAKE       "Abs Brake"
+#define AXIS_LABEL_PROP_ABS_HAT0X       "Abs Hat 0 X"
+#define AXIS_LABEL_PROP_ABS_HAT0Y       "Abs Hat 0 Y"
+#define AXIS_LABEL_PROP_ABS_HAT1X       "Abs Hat 1 X"
+#define AXIS_LABEL_PROP_ABS_HAT1Y       "Abs Hat 1 Y"
+#define AXIS_LABEL_PROP_ABS_HAT2X       "Abs Hat 2 X"
+#define AXIS_LABEL_PROP_ABS_HAT2Y       "Abs Hat 2 Y"
+#define AXIS_LABEL_PROP_ABS_HAT3X       "Abs Hat 3 X"
+#define AXIS_LABEL_PROP_ABS_HAT3Y       "Abs Hat 3 Y"
+#define AXIS_LABEL_PROP_ABS_PRESSURE    "Abs Pressure"
+#define AXIS_LABEL_PROP_ABS_DISTANCE    "Abs Distance"
+#define AXIS_LABEL_PROP_ABS_TILT_X      "Abs Tilt X"
+#define AXIS_LABEL_PROP_ABS_TILT_Y      "Abs Tilt Y"
+#define AXIS_LABEL_PROP_ABS_TOOL_WIDTH  "Abs Tool Width"
+#define AXIS_LABEL_PROP_ABS_VOLUME      "Abs Volume"
+#define AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR "Abs MT Touch Major"
+#define AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR "Abs MT Touch Minor"
+#define AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR "Abs MT Width Major"
+#define AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR "Abs MT Width Minor"
+#define AXIS_LABEL_PROP_ABS_MT_ORIENTATION "Abs MT Orientation"
+#define AXIS_LABEL_PROP_ABS_MT_POSITION_X  "Abs MT Position X"
+#define AXIS_LABEL_PROP_ABS_MT_POSITION_Y  "Abs MT Position Y"
+#define AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE   "Abs MT Tool Type"
+#define AXIS_LABEL_PROP_ABS_MT_BLOB_ID     "Abs MT Blob ID"
+#define AXIS_LABEL_PROP_ABS_MT_TRACKING_ID "Abs MT Tracking ID"
+#define AXIS_LABEL_PROP_ABS_MT_PRESSURE    "Abs MT Pressure"
+#define AXIS_LABEL_PROP_ABS_MT_DISTANCE    "Abs MT Distance"
+#define AXIS_LABEL_PROP_ABS_MT_TOOL_X      "Abs MT Tool X"
+#define AXIS_LABEL_PROP_ABS_MT_TOOL_Y      "Abs MT Tool Y"
+#define AXIS_LABEL_PROP_ABS_MISC        "Abs Misc"
+
+/* Button names */
+#define BTN_LABEL_PROP "Button Labels"
+
+/* Default label */
+#define BTN_LABEL_PROP_BTN_UNKNOWN      "Button Unknown"
+/* Wheel buttons */
+#define BTN_LABEL_PROP_BTN_WHEEL_UP     "Button Wheel Up"
+#define BTN_LABEL_PROP_BTN_WHEEL_DOWN   "Button Wheel Down"
+#define BTN_LABEL_PROP_BTN_HWHEEL_LEFT  "Button Horiz Wheel Left"
+#define BTN_LABEL_PROP_BTN_HWHEEL_RIGHT "Button Horiz Wheel Right"
+
+/* The following are from linux/input.h */
+#define BTN_LABEL_PROP_BTN_0            "Button 0"
+#define BTN_LABEL_PROP_BTN_1            "Button 1"
+#define BTN_LABEL_PROP_BTN_2            "Button 2"
+#define BTN_LABEL_PROP_BTN_3            "Button 3"
+#define BTN_LABEL_PROP_BTN_4            "Button 4"
+#define BTN_LABEL_PROP_BTN_5            "Button 5"
+#define BTN_LABEL_PROP_BTN_6            "Button 6"
+#define BTN_LABEL_PROP_BTN_7            "Button 7"
+#define BTN_LABEL_PROP_BTN_8            "Button 8"
+#define BTN_LABEL_PROP_BTN_9            "Button 9"
+
+#define BTN_LABEL_PROP_BTN_LEFT         "Button Left"
+#define BTN_LABEL_PROP_BTN_RIGHT        "Button Right"
+#define BTN_LABEL_PROP_BTN_MIDDLE       "Button Middle"
+#define BTN_LABEL_PROP_BTN_SIDE         "Button Side"
+#define BTN_LABEL_PROP_BTN_EXTRA        "Button Extra"
+#define BTN_LABEL_PROP_BTN_FORWARD      "Button Forward"
+#define BTN_LABEL_PROP_BTN_BACK         "Button Back"
+#define BTN_LABEL_PROP_BTN_TASK         "Button Task"
+
+#define BTN_LABEL_PROP_BTN_TRIGGER      "Button Trigger"
+#define BTN_LABEL_PROP_BTN_THUMB        "Button Thumb"
+#define BTN_LABEL_PROP_BTN_THUMB2       "Button Thumb2"
+#define BTN_LABEL_PROP_BTN_TOP          "Button Top"
+#define BTN_LABEL_PROP_BTN_TOP2         "Button Top2"
+#define BTN_LABEL_PROP_BTN_PINKIE       "Button Pinkie"
+#define BTN_LABEL_PROP_BTN_BASE         "Button Base"
+#define BTN_LABEL_PROP_BTN_BASE2        "Button Base2"
+#define BTN_LABEL_PROP_BTN_BASE3        "Button Base3"
+#define BTN_LABEL_PROP_BTN_BASE4        "Button Base4"
+#define BTN_LABEL_PROP_BTN_BASE5        "Button Base5"
+#define BTN_LABEL_PROP_BTN_BASE6        "Button Base6"
+#define BTN_LABEL_PROP_BTN_DEAD         "Button Dead"
+
+#define BTN_LABEL_PROP_BTN_A            "Button A"
+#define BTN_LABEL_PROP_BTN_B            "Button B"
+#define BTN_LABEL_PROP_BTN_C            "Button C"
+#define BTN_LABEL_PROP_BTN_X            "Button X"
+#define BTN_LABEL_PROP_BTN_Y            "Button Y"
+#define BTN_LABEL_PROP_BTN_Z            "Button Z"
+#define BTN_LABEL_PROP_BTN_TL           "Button T Left"
+#define BTN_LABEL_PROP_BTN_TR           "Button T Right"
+#define BTN_LABEL_PROP_BTN_TL2          "Button T Left2"
+#define BTN_LABEL_PROP_BTN_TR2          "Button T Right2"
+#define BTN_LABEL_PROP_BTN_SELECT       "Button Select"
+#define BTN_LABEL_PROP_BTN_START        "Button Start"
+#define BTN_LABEL_PROP_BTN_MODE         "Button Mode"
+#define BTN_LABEL_PROP_BTN_THUMBL       "Button Thumb Left"
+#define BTN_LABEL_PROP_BTN_THUMBR       "Button Thumb Right"
+
+#define BTN_LABEL_PROP_BTN_TOOL_PEN             "Button Tool Pen"
+#define BTN_LABEL_PROP_BTN_TOOL_RUBBER          "Button Tool Rubber"
+#define BTN_LABEL_PROP_BTN_TOOL_BRUSH           "Button Tool Brush"
+#define BTN_LABEL_PROP_BTN_TOOL_PENCIL          "Button Tool Pencil"
+#define BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH        "Button Tool Airbrush"
+#define BTN_LABEL_PROP_BTN_TOOL_FINGER          "Button Tool Finger"
+#define BTN_LABEL_PROP_BTN_TOOL_MOUSE           "Button Tool Mouse"
+#define BTN_LABEL_PROP_BTN_TOOL_LENS            "Button Tool Lens"
+#define BTN_LABEL_PROP_BTN_TOUCH                "Button Touch"
+#define BTN_LABEL_PROP_BTN_STYLUS               "Button Stylus"
+#define BTN_LABEL_PROP_BTN_STYLUS2              "Button Stylus2"
+#define BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP       "Button Tool Doubletap"
+#define BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP       "Button Tool Tripletap"
+
+#define BTN_LABEL_PROP_BTN_GEAR_DOWN            "Button Gear down"
+#define BTN_LABEL_PROP_BTN_GEAR_UP              "Button Gear up"
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xserver-properties.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu.h	(Revision 52145)
@@ -0,0 +1,60 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for FPU instruction decoding.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_FPU_H
+#define __X86EMU_FPU_H
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+/* these have to be defined, whether 8087 support compiled in or not. */
+
+    extern void x86emuOp_esc_coprocess_d8(u8 op1);
+    extern void x86emuOp_esc_coprocess_d9(u8 op1);
+    extern void x86emuOp_esc_coprocess_da(u8 op1);
+    extern void x86emuOp_esc_coprocess_db(u8 op1);
+    extern void x86emuOp_esc_coprocess_dc(u8 op1);
+    extern void x86emuOp_esc_coprocess_dd(u8 op1);
+    extern void x86emuOp_esc_coprocess_de(u8 op1);
+    extern void x86emuOp_esc_coprocess_df(u8 op1);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_FPU_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/fpu.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xaarop.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xaarop.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xaarop.h	(Revision 52145)
@@ -0,0 +1,268 @@
+#ifndef _XAAROP_H
+#define _XAAROP_H
+
+#define ROP_DST		0x00000001
+#define ROP_SRC		0x00000002
+#define ROP_PAT		0x00000004
+
+#define ROP_0		0x00
+#define ROP_DPSoon	0x01
+#define ROP_DPSona	0x02
+#define ROP_PSon	0x03
+#define ROP_SDPona	0x04
+#define ROP_DPon	0x05
+#define ROP_PDSxnon	0x06
+#define ROP_PDSaon	0x07
+#define ROP_SDPnaa	0x08
+#define ROP_PDSxon	0x09
+#define ROP_DPna	0x0A
+#define ROP_PSDnaon	0x0B
+#define ROP_SPna	0x0C
+#define ROP_PDSnaon	0x0D
+#define ROP_PDSonon	0x0E
+#define ROP_Pn		0x0F
+#define ROP_PDSona	0x10
+#define ROP_DSon	0x11
+#define ROP_SDPxnon	0x12
+#define ROP_SDPaon	0x13
+#define ROP_DPSxnon	0x14
+#define ROP_DPSaon	0x15
+#define ROP_PSDPSanaxx	0x16
+#define ROP_SSPxDSxaxn	0x17
+#define ROP_SPxPDxa	0x18
+#define ROP_SDPSanaxn	0x19
+#define ROP_PDSPaox	0x1A
+#define ROP_SDPSxaxn	0x1B
+#define ROP_PSDPaox	0x1C
+#define ROP_DSPDxaxn	0x1D
+#define ROP_PDSox	0x1E
+#define ROP_PDSoan	0x1F
+#define ROP_DPSnaa	0x20
+#define ROP_SDPxon	0x21
+#define ROP_DSna	0x22
+#define ROP_SPDnaon	0x23
+#define ROP_SPxDSxa	0x24
+#define ROP_PDSPanaxn	0x25
+#define ROP_SDPSaox	0x26
+#define ROP_SDPSxnox	0x27
+#define ROP_DPSxa	0x28
+#define ROP_PSDPSaoxxn	0x29
+#define ROP_DPSana	0x2A
+#define ROP_SSPxPDxaxn	0x2B
+#define ROP_SPDSoax	0x2C
+#define ROP_PSDnox	0x2D
+#define ROP_PSDPxox	0x2E
+#define ROP_PSDnoan	0x2F
+#define ROP_PSna	0x30
+#define ROP_SDPnaon	0x31
+#define ROP_SDPSoox	0x32
+#define ROP_Sn		0x33
+#define ROP_SPDSaox	0x34
+#define ROP_SPDSxnox	0x35
+#define ROP_SDPox	0x36
+#define ROP_SDPoan	0x37
+#define ROP_PSDPoax	0x38
+#define ROP_SPDnox	0x39
+#define ROP_SPDSxox	0x3A
+#define ROP_SPDnoan	0x3B
+#define ROP_PSx		0x3C
+#define ROP_SPDSonox	0x3D
+#define ROP_SPDSnaox	0x3E
+#define ROP_PSan	0x3F
+#define ROP_PSDnaa	0x40
+#define ROP_DPSxon	0x41
+#define ROP_SDxPDxa	0x42
+#define ROP_SPDSanaxn	0x43
+#define ROP_SDna	0x44
+#define ROP_DPSnaon	0x45
+#define ROP_DSPDaox	0x46
+#define ROP_PSDPxaxn	0x47
+#define ROP_SDPxa	0x48
+#define ROP_PDSPDaoxxn	0x49
+#define ROP_DPSDoax	0x4A
+#define ROP_PDSnox	0x4B
+#define ROP_SDPana	0x4C
+#define ROP_SSPxDSxoxn	0x4D
+#define ROP_PDSPxox	0x4E
+#define ROP_PDSnoan	0x4F
+#define ROP_PDna	0x50
+#define ROP_DSPnaon	0x51
+#define ROP_DPSDaox	0x52
+#define ROP_SPDSxaxn	0x53
+#define ROP_DPSonon	0x54
+#define ROP_Dn		0x55
+#define ROP_DPSox	0x56
+#define ROP_DPSoan	0x57
+#define ROP_PDSPoax	0x58
+#define ROP_DPSnox	0x59
+#define ROP_DPx		0x5A
+#define ROP_DPSDonox	0x5B
+#define ROP_DPSDxox	0x5C
+#define ROP_DPSnoan	0x5D
+#define ROP_DPSDnaox	0x5E
+#define ROP_DPan	0x5F
+#define ROP_PDSxa	0x60
+#define ROP_DSPDSaoxxn	0x61
+#define ROP_DSPDoax	0x62
+#define ROP_SDPnox	0x63
+#define ROP_SDPSoax	0x64
+#define ROP_DSPnox	0x65
+#define ROP_DSx		0x66
+#define ROP_SDPSonox	0x67
+#define ROP_DSPDSonoxxn	0x68
+#define ROP_PDSxxn	0x69
+#define ROP_DPSax	0x6A
+#define ROP_PSDPSoaxxn	0x6B
+#define ROP_SDPax	0x6C
+#define ROP_PDSPDoaxxn	0x6D
+#define ROP_SDPSnoax	0x6E
+#define ROP_PDSxnan	0x6F
+#define ROP_PDSana	0x70
+#define ROP_SSDxPDxaxn	0x71
+#define ROP_SDPSxox	0x72
+#define ROP_SDPnoan	0x73
+#define ROP_DSPDxox	0x74
+#define ROP_DSPnoan	0x75
+#define ROP_SDPSnaox	0x76
+#define ROP_DSan	0x77
+#define ROP_PDSax	0x78
+#define ROP_DSPDSoaxxn	0x79
+#define ROP_DPSDnoax	0x7A
+#define ROP_SDPxnan	0x7B
+#define ROP_SPDSnoax	0x7C
+#define ROP_DPSxnan	0x7D
+#define ROP_SPxDSxo	0x7E
+#define ROP_DPSaan	0x7F
+#define ROP_DPSaa	0x80
+#define ROP_SPxDSxon	0x81
+#define ROP_DPSxna	0x82
+#define ROP_SPDSnoaxn	0x83
+#define ROP_SDPxna	0x84
+#define ROP_PDSPnoaxn	0x85
+#define ROP_DSPDSoaxx	0x86
+#define ROP_PDSaxn	0x87
+#define ROP_DSa		0x88
+#define ROP_SDPSnaoxn	0x89
+#define ROP_DSPnoa	0x8A
+#define ROP_DSPDxoxn	0x8B
+#define ROP_SDPnoa	0x8C
+#define ROP_SDPSxoxn	0x8D
+#define ROP_SSDxPDxax	0x8E
+#define ROP_PDSanan	0x8F
+#define ROP_PDSxna	0x90
+#define ROP_SDPSnoaxn	0x91
+#define ROP_DPSDPoaxx	0x92
+#define ROP_SPDaxn	0x93
+#define ROP_PSDPSoaxx	0x94
+#define ROP_DPSaxn	0x95
+#define ROP_DPSxx	0x96
+#define ROP_PSDPSonoxx	0x97
+#define ROP_SDPSonoxn	0x98
+#define ROP_DSxn	0x99
+#define ROP_DPSnax	0x9A
+#define ROP_SDPSoaxn	0x9B
+#define ROP_SPDnax	0x9C
+#define ROP_DSPDoaxn	0x9D
+#define ROP_DSPDSaoxx	0x9E
+#define ROP_PDSxan	0x9F
+#define ROP_DPa		0xA0
+#define ROP_PDSPnaoxn	0xA1
+#define ROP_DPSnoa	0xA2
+#define ROP_DPSDxoxn	0xA3
+#define ROP_PDSPonoxn	0xA4
+#define ROP_PDxn	0xA5
+#define ROP_DSPnax	0xA6
+#define ROP_PDSPoaxn	0xA7
+#define ROP_DPSoa	0xA8
+#define ROP_DPSoxn	0xA9
+#define ROP_D		0xAA
+#define ROP_DPSono	0xAB
+#define ROP_SPDSxax	0xAC
+#define ROP_DPSDaoxn	0xAD
+#define ROP_DSPnao	0xAE
+#define ROP_DPno	0xAF
+#define ROP_PDSnoa	0xB0
+#define ROP_PDSPxoxn	0xB1
+#define ROP_SSPxDSxox	0xB2
+#define ROP_SDPanan	0xB3
+#define ROP_PSDnax	0xB4
+#define ROP_DPSDoaxn	0xB5
+#define ROP_DPSDPaoxx	0xB6
+#define ROP_SDPxan	0xB7
+#define ROP_PSDPxax	0xB8
+#define ROP_DSPDaoxn	0xB9
+#define ROP_DPSnao	0xBA
+#define ROP_DSno	0xBB
+#define ROP_SPDSanax	0xBC
+#define ROP_SDxPDxan	0xBD
+#define ROP_DPSxo	0xBE
+#define ROP_DPSano	0xBF
+#define ROP_Psa		0xC0
+#define ROP_SPDSnaoxn	0xC1
+#define ROP_SPDSonoxn	0xC2
+#define ROP_PSxn	0xC3
+#define ROP_SPDnoa	0xC4
+#define ROP_SPDSxoxn	0xC5
+#define ROP_SDPnax	0xC6
+#define ROP_PSDPoaxn	0xC7
+#define ROP_SDPoa	0xC8
+#define ROP_SPDoxn	0xC9
+#define ROP_DPSDxax	0xCA
+#define ROP_SPDSaoxn	0xCB
+#define ROP_S		0xCC
+#define ROP_SDPono	0xCD
+#define ROP_SDPnao	0xCE
+#define ROP_SPno	0xCF
+#define ROP_PSDnoa	0xD0
+#define ROP_PSDPxoxn	0xD1
+#define ROP_PDSnax	0xD2
+#define ROP_SPDSoaxn	0xD3
+#define ROP_SSPxPDxax	0xD4
+#define ROP_DPSanan	0xD5
+#define ROP_PSDPSaoxx	0xD6
+#define ROP_DPSxan	0xD7
+#define ROP_PDSPxax	0xD8
+#define ROP_SDPSaoxn	0xD9
+#define ROP_DPSDanax	0xDA
+#define ROP_SPxDSxan	0xDB
+#define ROP_SPDnao	0xDC
+#define ROP_SDno	0xDD
+#define ROP_SDPxo	0xDE
+#define ROP_SDPano	0xDF
+#define ROP_PDSoa	0xE0
+#define ROP_PDSoxn	0xE1
+#define ROP_DSPDxax	0xE2
+#define ROP_PSDPaoxn	0xE3
+#define ROP_SDPSxax	0xE4
+#define ROP_PDSPaoxn	0xE5
+#define ROP_SDPSanax	0xE6
+#define ROP_SPxPDxan	0xE7
+#define ROP_SSPxDSxax	0xE8
+#define ROP_DSPDSanaxxn	0xE9
+#define ROP_DPSao	0xEA
+#define ROP_DPSxno	0xEB
+#define ROP_SDPao	0xEC
+#define ROP_SDPxno	0xED
+#define ROP_DSo		0xEE
+#define ROP_SDPnoo	0xEF
+#define ROP_P		0xF0
+#define ROP_PDSono	0xF1
+#define ROP_PDSnao	0xF2
+#define ROP_PSno	0xF3
+#define ROP_PSDnao	0xF4
+#define ROP_PDno	0xF5
+#define ROP_PDSxo	0xF6
+#define ROP_PDSano	0xF7
+#define ROP_PDSao	0xF8
+#define ROP_PDSxno	0xF9
+#define ROP_DPo		0xFA
+#define ROP_DPSnoo	0xFB
+#define ROP_PSo		0xFC
+#define ROP_PSDnoo	0xFD
+#define ROP_DPSoo	0xFE
+#define ROP_1		0xFF
+
+#define NO_SRC_ROP(rop) \
+   ((rop == GXnoop) || (rop == GXset) || (rop == GXclear) || (rop == GXinvert))
+
+#endif                          /* _XAAROP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xaarop.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size.h	(Revision 52145)
@@ -0,0 +1,85 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_SIZE_H_ )
+#define _INDIRECT_SIZE_H_
+
+/**
+ * \file
+ * Prototypes for functions used to determine the number of data elements in
+ * various GLX protocol messages.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#include <X11/Xfuncproto.h>
+
+#if defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#define PURE __attribute__((pure))
+#else
+#define PURE
+#endif
+
+#if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#define FASTCALL __attribute__((fastcall))
+#else
+#define FASTCALL
+#endif
+
+extern _X_INTERNAL PURE FASTCALL GLint __glCallLists_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glFogfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glFogiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightModelfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glLightModeliv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMaterialfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMaterialiv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexEnvfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexEnviv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGendv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGenfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glTexGeniv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap1d_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap1f_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap2d_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glMap2f_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glColorTableParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glConvolutionParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint
+__glConvolutionParameteriv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glPointParameterfv_size(GLenum);
+extern _X_INTERNAL PURE FASTCALL GLint __glPointParameteriv_size(GLenum);
+
+#undef PURE
+#undef FASTCALL
+
+#endif /* !defined( _INDIRECT_SIZE_H_ ) */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/indirect_size.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdrawable.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdrawable.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdrawable.h	(Revision 52145)
@@ -0,0 +1,77 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GLX_drawable_h_
+#define _GLX_drawable_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+/* We just need to avoid clashing with DRAWABLE_{WINDOW,PIXMAP} */
+enum {
+    GLX_DRAWABLE_WINDOW,
+    GLX_DRAWABLE_PIXMAP,
+    GLX_DRAWABLE_PBUFFER,
+    GLX_DRAWABLE_ANY
+};
+
+struct __GLXdrawable {
+    void (*destroy) (__GLXdrawable * private);
+     GLboolean(*swapBuffers) (ClientPtr client, __GLXdrawable *);
+    void (*copySubBuffer) (__GLXdrawable * drawable,
+                           int x, int y, int w, int h);
+    void (*waitX) (__GLXdrawable *);
+    void (*waitGL) (__GLXdrawable *);
+
+    DrawablePtr pDraw;
+    XID drawId;
+
+    /*
+     ** Either GLX_DRAWABLE_PIXMAP, GLX_DRAWABLE_WINDOW or
+     ** GLX_DRAWABLE_PBUFFER.
+     */
+    int type;
+
+    /*
+     ** Configuration of the visual to which this drawable was created.
+     */
+    __GLXconfig *config;
+
+    GLenum target;
+    GLenum format;
+
+    /*
+     ** Event mask
+     */
+    unsigned long eventMask;
+};
+
+#endif                          /* !__GLX_drawable_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxdrawable.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinputinit.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinputinit.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinputinit.h	(Revision 52145)
@@ -0,0 +1,284 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for low-level input support.  \see dmxinputinit.c */
+
+#ifndef _DMXINPUTINIT_H_
+#define _DMXINPUTINIT_H_
+
+#include "dmx.h"
+#include "dmxinput.h"
+#include "dmxlog.h"
+
+#define DMX_LOCAL_DEFAULT_KEYBOARD "kbd"
+#define DMX_LOCAL_DEFAULT_POINTER  "ps2"
+#define DMX_MAX_BUTTONS            256
+#define DMX_MOTION_SIZE            256
+#define DMX_MAX_VALUATORS          32
+#define DMX_MAX_AXES               32
+#define DMX_MAX_XINPUT_EVENT_TYPES 100
+#define DMX_MAP_ENTRIES            16   /* Must be a power of 2 */
+#define DMX_MAP_MASK               (DMX_MAP_ENTRIES - 1)
+
+typedef enum {
+    DMX_FUNCTION_GRAB,
+    DMX_FUNCTION_TERMINATE,
+    DMX_FUNCTION_FINE
+} DMXFunctionType;
+
+typedef enum {
+    DMX_LOCAL_HIGHLEVEL,
+    DMX_LOCAL_KEYBOARD,
+    DMX_LOCAL_MOUSE,
+    DMX_LOCAL_OTHER
+} DMXLocalInputType;
+
+typedef enum {
+    DMX_LOCAL_TYPE_LOCAL,
+    DMX_LOCAL_TYPE_CONSOLE,
+    DMX_LOCAL_TYPE_BACKEND,
+    DMX_LOCAL_TYPE_COMMON
+} DMXLocalInputExtType;
+
+typedef enum {
+    DMX_RELATIVE,
+    DMX_ABSOLUTE,
+    DMX_ABSOLUTE_CONFINED
+} DMXMotionType;
+
+/** Stores information from low-level device that is used to initialize
+ * the device at the dix level. */
+typedef struct _DMXLocalInitInfo {
+    int keyboard;                  /**< Non-zero if the device is a keyboard */
+
+    int keyClass;                  /**< Non-zero if keys are present */
+    KeySymsRec keySyms;            /**< Key symbols */
+    int freemap;                   /**< If non-zero, free keySyms.map */
+    CARD8 modMap[MAP_LENGTH];                /**< Modifier map */
+    XkbDescPtr xkb;                 /**< XKB description */
+    XkbComponentNamesRec names;     /**< XKB component names */
+    int freenames;                  /**< Non-zero if names should be free'd */
+    int force;                      /**< Do not allow command line override */
+
+    int buttonClass;                  /**< Non-zero if buttons are present */
+    int numButtons;                   /**< Number of buttons */
+    unsigned char map[DMX_MAX_BUTTONS];        /**< Button map */
+
+    int valuatorClass;                  /**< Non-zero if valuators are
+                                         * present */
+    int numRelAxes;                     /**< Number of relative axes */
+    int numAbsAxes;                     /**< Number of absolute axes */
+    int minval[DMX_MAX_AXES];                  /**< Minimum values */
+    int maxval[DMX_MAX_AXES];                  /**< Maximum values */
+    int res[DMX_MAX_AXES];                     /**< Resolution */
+    int minres[DMX_MAX_AXES];                  /**< Minimum resolutions */
+    int maxres[DMX_MAX_AXES];                  /**< Maximum resolutions */
+
+    int focusClass;                        /**< Non-zero if device can
+                                            * cause focus */
+    int proximityClass;                    /**< Non-zero if device
+                                            * causes proximity events */
+    int kbdFeedbackClass;                  /**< Non-zero if device has
+                                            * keyboard feedback */
+    int ptrFeedbackClass;                  /**< Non-zero if device has
+                                            * pointer feedback */
+    int ledFeedbackClass;                  /**< Non-zero if device has
+                                            * LED indicators */
+    int belFeedbackClass;                  /**< Non-zero if device has a
+                                            * bell */
+    int intFeedbackClass;                  /**< Non-zero if device has
+                                            * integer feedback */
+    int strFeedbackClass;                  /**< Non-zero if device has
+                                            * string feedback */
+
+    int maxSymbols;                           /**< Maximum symbols */
+    int maxSymbolsSupported;                  /**< Maximum symbols supported */
+    KeySym *symbols;                          /**< Key symbols */
+} DMXLocalInitInfo, *DMXLocalInitInfoPtr;
+
+typedef void *(*dmxCreatePrivateProcPtr) (DeviceIntPtr);
+typedef void (*dmxDestroyPrivateProcPtr) (void *);
+
+typedef void (*dmxInitProcPtr) (DevicePtr);
+typedef void (*dmxReInitProcPtr) (DevicePtr);
+typedef void (*dmxLateReInitProcPtr) (DevicePtr);
+typedef void (*dmxGetInfoProcPtr) (DevicePtr, DMXLocalInitInfoPtr);
+typedef int (*dmxOnProcPtr) (DevicePtr);
+typedef void (*dmxOffProcPtr) (DevicePtr);
+typedef void (*dmxUpdatePositionProcPtr) (void *, int x, int y);
+
+typedef void (*dmxVTPreSwitchProcPtr) (void *);        /* Turn I/O Off */
+typedef void (*dmxVTPostSwitchProcPtr) (void *);       /* Turn I/O On */
+typedef void (*dmxVTSwitchReturnProcPtr) (void *);
+typedef int (*dmxVTSwitchProcPtr) (void *, int vt,
+                                   dmxVTSwitchReturnProcPtr, void *);
+
+typedef void (*dmxMotionProcPtr) (DevicePtr,
+                                  int *valuators,
+                                  int firstAxis,
+                                  int axesCount,
+                                  DMXMotionType type, DMXBlockType block);
+typedef void (*dmxEnqueueProcPtr) (DevicePtr, int type, int detail,
+                                   KeySym keySym, XEvent * e,
+                                   DMXBlockType block);
+typedef int (*dmxCheckSpecialProcPtr) (DevicePtr, KeySym keySym);
+typedef void (*dmxCollectEventsProcPtr) (DevicePtr,
+                                         dmxMotionProcPtr,
+                                         dmxEnqueueProcPtr,
+                                         dmxCheckSpecialProcPtr, DMXBlockType);
+typedef void (*dmxProcessInputProcPtr) (void *);
+typedef void (*dmxUpdateInfoProcPtr) (void *, DMXUpdateType, WindowPtr);
+typedef int (*dmxFunctionsProcPtr) (void *, DMXFunctionType);
+
+typedef void (*dmxKBCtrlProcPtr) (DevicePtr, KeybdCtrl * ctrl);
+typedef void (*dmxMCtrlProcPtr) (DevicePtr, PtrCtrl * ctrl);
+typedef void (*dmxKBBellProcPtr) (DevicePtr, int percent,
+                                  int volume, int pitch, int duration);
+
+/** Stores a mapping between the device id on the remote X server and
+ * the id on the DMX server */
+typedef struct _DMXEventMap {
+    int remote;                 /**< Event number on remote X server */
+    int server;                 /**< Event number (unbiased) on DMX server */
+} DMXEventMap;
+
+/** This is the device-independent structure used by the low-level input
+ * routines.  The contents are not exposed to top-level .c files (except
+ * dmxextensions.c).  \see dmxinput.h \see dmxextensions.c */
+typedef struct _DMXLocalInputInfo {
+    const char *name;                 /**< Device name */
+    DMXLocalInputType type;           /**< Device type  */
+    DMXLocalInputExtType extType;     /**< Extended device type */
+    int binding;                      /**< Count of how many consecutive
+                                       * structs are bound to the same
+                                       * device */
+
+    /* Low-level (e.g., keyboard/mouse drivers) */
+
+    dmxCreatePrivateProcPtr create_private;   /**< Create
+                                               * device-dependent
+                                               * private */
+    dmxDestroyPrivateProcPtr destroy_private; /**< Destroy
+                                               * device-dependent
+                                               * private */
+    dmxInitProcPtr init;                      /**< Initialize device  */
+    dmxReInitProcPtr reinit;                  /**< Reinitialize device
+                                               * (during a
+                                               * reconfiguration) */
+    dmxLateReInitProcPtr latereinit;          /**< Reinitialize a device
+                                               * (called very late
+                                               * during a
+                                               * reconfiguration) */
+    dmxGetInfoProcPtr get_info;               /**< Get device information */
+    dmxOnProcPtr on;                          /**< Turn device on */
+    dmxOffProcPtr off;                        /**< Turn device off */
+    dmxUpdatePositionProcPtr update_position; /**< Called when another
+                                               * device updates the
+                                               * cursor position */
+    dmxVTPreSwitchProcPtr vt_pre_switch;      /**< Called before a VT switch */
+    dmxVTPostSwitchProcPtr vt_post_switch;    /**< Called after a VT switch */
+    dmxVTSwitchProcPtr vt_switch;             /**< Causes a VT switch */
+
+    dmxCollectEventsProcPtr collect_events;   /**< Collect and enqueue
+                                               * events from the
+                                               * device*/
+    dmxProcessInputProcPtr process_input;     /**< Process event (from
+                                               * queue)  */
+    dmxFunctionsProcPtr functions;
+    dmxUpdateInfoProcPtr update_info;         /**< Update window layout
+                                               * information */
+
+    dmxMCtrlProcPtr mCtrl;                    /**< Pointer control */
+    dmxKBCtrlProcPtr kCtrl;                   /**< Keyboard control */
+    dmxKBBellProcPtr kBell;                   /**< Bell control */
+
+    void *private;                            /**< Device-dependent private  */
+    int isCore;                               /**< Is a DMX core device  */
+    int sendsCore;                            /**< Sends DMX core events */
+    KeybdCtrl kctrl;                          /**< Keyboard control */
+    PtrCtrl mctrl;                            /**< Pointer control */
+
+    DeviceIntPtr pDevice;                     /**< X-level device  */
+    int inputIdx;                             /**< High-level index */
+    int lastX, lastY;                         /**< Last known position;
+                                               * for XInput in
+                                               * dmxevents.c */
+
+    int head;                                 /**< XInput motion history
+                                               * head */
+    int tail;                                 /**< XInput motion history
+                                               * tail */
+    unsigned long *history;                   /**< XInput motion history */
+    int *valuators;                           /**< Cache of previous values */
+
+    /* for XInput ChangePointerDevice */
+    int (*savedMotionProc) (DeviceIntPtr,
+                            xTimecoord *,
+                            unsigned long, unsigned long, ScreenPtr);
+    int savedMotionEvents;                      /**< Saved motion events */
+    int savedSendsCore;                         /**< Saved sends-core flag */
+
+    DMXEventMap map[DMX_MAP_ENTRIES];              /**< XInput device id map */
+    int mapOptimize;                               /**< XInput device id
+                                                    * map
+                                                    * optimization */
+
+    long deviceId;                        /**< device id on remote side,
+                                           * if any */
+    const char *deviceName;               /**< devive name on remote
+                                           * side, if any */
+} DMXLocalInputInfoRec;
+
+extern DMXLocalInputInfoPtr dmxLocalCorePointer, dmxLocalCoreKeyboard;
+
+extern void dmxLocalInitInput(DMXInputInfo * dmxInput);
+extern DMXLocalInputInfoPtr dmxInputCopyLocal(DMXInputInfo * dmxInput,
+                                              DMXLocalInputInfoPtr s);
+
+extern void dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl * ctrl);
+extern void dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl * ctrl);
+extern void dmxKeyboardBellProc(int percent, DeviceIntPtr pDevice,
+                                void *ctrl, int unknown);
+
+extern int dmxInputExtensionErrorHandler(Display * dsp, _Xconst char *name,
+                                         _Xconst char *reason);
+
+extern int dmxInputDetach(DMXInputInfo * dmxInput);
+extern void dmxInputDetachAll(DMXScreenInfo * dmxScreen);
+extern int dmxInputDetachId(int id);
+extern DMXInputInfo *dmxInputLocateId(int id);
+extern int dmxInputAttachConsole(const char *name, int isCore, int *id);
+extern int dmxInputAttachBackend(int physicalScreen, int isCore, int *id);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxinputinit.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emu.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emu.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emu.h	(Revision 52145)
@@ -0,0 +1,197 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for public specific functions.
+*               Any application linking against us should only
+*               include this header
+*
+****************************************************************************/
+
+#ifndef __X86EMU_X86EMU_H
+#define __X86EMU_X86EMU_H
+
+#ifdef SCITECH
+#include "scitech.h"
+#define	X86API	_ASMAPI
+#define	X86APIP	_ASMAPIP
+typedef int X86EMU_pioAddr;
+#else
+#include "x86emu/types.h"
+#define	X86API
+#define	X86APIP	*
+#endif
+#include "x86emu/regs.h"
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#ifdef PACK
+#pragma	PACK                    /* Don't pack structs with function pointers! */
+#endif
+
+/****************************************************************************
+REMARKS:
+Data structure containing ponters to programmed I/O functions used by the
+emulator. This is used so that the user program can hook all programmed
+I/O for the emulator to handled as necessary by the user program. By
+default the emulator contains simple functions that do not do access the
+hardware in any way. To allow the emualtor access the hardware, you will
+need to override the programmed I/O functions using the X86EMU_setupPioFuncs
+function.
+
+HEADER:
+x86emu.h
+
+MEMBERS:
+inb		- Function to read a byte from an I/O port
+inw		- Function to read a word from an I/O port
+inl     - Function to read a dword from an I/O port
+outb	- Function to write a byte to an I/O port
+outw    - Function to write a word to an I/O port
+outl    - Function to write a dword to an I/O port
+****************************************************************************/
+typedef struct {
+    u8(X86APIP inb) (X86EMU_pioAddr addr);
+    u16(X86APIP inw) (X86EMU_pioAddr addr);
+    u32(X86APIP inl) (X86EMU_pioAddr addr);
+    void (X86APIP outb) (X86EMU_pioAddr addr, u8 val);
+    void (X86APIP outw) (X86EMU_pioAddr addr, u16 val);
+    void (X86APIP outl) (X86EMU_pioAddr addr, u32 val);
+} X86EMU_pioFuncs;
+
+/****************************************************************************
+REMARKS:
+Data structure containing ponters to memory access functions used by the
+emulator. This is used so that the user program can hook all memory
+access functions as necessary for the emulator. By default the emulator
+contains simple functions that only access the internal memory of the
+emulator. If you need specialised functions to handle access to different
+types of memory (ie: hardware framebuffer accesses and BIOS memory access
+etc), you will need to override this using the X86EMU_setupMemFuncs
+function.
+
+HEADER:
+x86emu.h
+
+MEMBERS:
+rdb		- Function to read a byte from an address
+rdw		- Function to read a word from an address
+rdl     - Function to read a dword from an address
+wrb		- Function to write a byte to an address
+wrw    	- Function to write a word to an address
+wrl    	- Function to write a dword to an address
+****************************************************************************/
+typedef struct {
+    u8(X86APIP rdb) (u32 addr);
+    u16(X86APIP rdw) (u32 addr);
+    u32(X86APIP rdl) (u32 addr);
+    void (X86APIP wrb) (u32 addr, u8 val);
+    void (X86APIP wrw) (u32 addr, u16 val);
+    void (X86APIP wrl) (u32 addr, u32 val);
+} X86EMU_memFuncs;
+
+/****************************************************************************
+  Here are the default memory read and write
+  function in case they are needed as fallbacks.
+***************************************************************************/
+extern u8 X86API rdb(u32 addr);
+extern u16 X86API rdw(u32 addr);
+extern u32 X86API rdl(u32 addr);
+extern void X86API wrb(u32 addr, u8 val);
+extern void X86API wrw(u32 addr, u16 val);
+extern void X86API wrl(u32 addr, u32 val);
+
+#ifdef END_PACK
+#pragma	END_PACK
+#endif
+
+/*--------------------- type definitions -----------------------------------*/
+
+typedef void (X86APIP X86EMU_intrFuncs) (int num);
+extern X86EMU_intrFuncs _X86EMU_intrTab[256];
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {                    /* Use "C" linkage when in C++ mode */
+#endif
+
+    void X86EMU_setupMemFuncs(X86EMU_memFuncs * funcs);
+    void X86EMU_setupPioFuncs(X86EMU_pioFuncs * funcs);
+    void X86EMU_setupIntrFuncs(X86EMU_intrFuncs funcs[]);
+    void X86EMU_prepareForInt(int num);
+
+/* decode.c */
+
+    void X86EMU_exec(void);
+    void X86EMU_halt_sys(void);
+
+#ifdef	DEBUG
+#define	HALT_SYS()	\
+	printk("halt_sys: file %s, line %d\n", __FILE__, __LINE__), \
+	X86EMU_halt_sys()
+#else
+#define	HALT_SYS()	X86EMU_halt_sys()
+#endif
+
+/* Debug options */
+
+#define DEBUG_DECODE_F          0x000001        /* print decoded instruction  */
+#define DEBUG_TRACE_F           0x000002        /* dump regs before/after execution */
+#define DEBUG_STEP_F            0x000004
+#define DEBUG_DISASSEMBLE_F     0x000008
+#define DEBUG_BREAK_F           0x000010
+#define DEBUG_SVC_F             0x000020
+#define DEBUG_SAVE_IP_CS_F      0x000040
+#define DEBUG_FS_F              0x000080
+#define DEBUG_PROC_F            0x000100
+#define DEBUG_SYSINT_F          0x000200        /* bios system interrupts. */
+#define DEBUG_TRACECALL_F       0x000400
+#define DEBUG_INSTRUMENT_F      0x000800
+#define DEBUG_MEM_TRACE_F       0x001000
+#define DEBUG_IO_TRACE_F        0x002000
+#define DEBUG_TRACECALL_REGS_F  0x004000
+#define DEBUG_DECODE_NOPRINT_F  0x008000
+#define DEBUG_EXIT              0x010000
+#define DEBUG_SYS_F             (DEBUG_SVC_F|DEBUG_FS_F|DEBUG_PROC_F)
+
+    void X86EMU_trace_regs(void);
+    void X86EMU_trace_xregs(void);
+    void X86EMU_dump_memory(u16 seg, u16 off, u32 amt);
+    int X86EMU_trace_on(void);
+    int X86EMU_trace_off(void);
+
+#ifdef  __cplusplus
+}                               /* End of "C" linkage for C++           */
+#endif
+#endif                          /* __X86EMU_X86EMU_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/x86emu.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcontext.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcontext.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcontext.h	(Revision 52145)
@@ -0,0 +1,141 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GLX_context_h_
+#define _GLX_context_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+typedef struct __GLXtextureFromPixmap __GLXtextureFromPixmap;
+struct __GLXtextureFromPixmap {
+    int (*bindTexImage) (__GLXcontext * baseContext,
+                         int buffer, __GLXdrawable * pixmap);
+    int (*releaseTexImage) (__GLXcontext * baseContext,
+                            int buffer, __GLXdrawable * pixmap);
+};
+
+struct __GLXcontext {
+    void (*destroy) (__GLXcontext * context);
+    int (*makeCurrent) (__GLXcontext * context);
+    int (*loseCurrent) (__GLXcontext * context);
+    int (*copy) (__GLXcontext * dst, __GLXcontext * src, unsigned long mask);
+    Bool (*wait) (__GLXcontext * context, __GLXclientState * cl, int *error);
+
+    __GLXtextureFromPixmap *textureFromPixmap;
+
+    /*
+     ** list of context structs
+     */
+    __GLXcontext *next;
+
+    /*
+     ** config struct for this context
+     */
+    __GLXconfig *config;
+
+    /*
+     ** Pointer to screen info data for this context.  This is set
+     ** when the context is created.
+     */
+    __GLXscreen *pGlxScreen;
+
+    /*
+     ** If this context is current for a client, this will be that client
+     */
+    ClientPtr currentClient;
+
+    /*
+     ** The XID of this context.
+     */
+    XID id;
+
+    /*
+     ** The XID of the shareList context.
+     */
+    XID share_id;
+
+    /*
+     ** Whether this context's ID still exists.
+     */
+    GLboolean idExists;
+
+    /*
+     ** Whether this context is a direct rendering context.
+     */
+    GLboolean isDirect;
+
+    /*
+     ** This flag keeps track of whether there are unflushed GL commands.
+     */
+    GLboolean hasUnflushedCommands;
+
+    /*
+     ** Current rendering mode for this context.
+     */
+    GLenum renderMode;
+
+    /**
+     * Reset notification strategy used when a GPU reset occurs.
+     */
+    GLenum resetNotificationStrategy;
+
+    /*
+     ** Buffers for feedback and selection.
+     */
+    GLfloat *feedbackBuf;
+    GLint feedbackBufSize;      /* number of elements allocated */
+    GLuint *selectBuf;
+    GLint selectBufSize;        /* number of elements allocated */
+
+    /*
+     ** The drawable private this context is bound to
+     */
+    __GLXdrawable *drawPriv;
+    __GLXdrawable *readPriv;
+};
+
+void __glXContextDestroy(__GLXcontext * context);
+
+extern int validGlxScreen(ClientPtr client, int screen,
+                          __GLXscreen ** pGlxScreen, int *err);
+
+extern int validGlxFBConfig(ClientPtr client, __GLXscreen * pGlxScreen,
+                            XID id, __GLXconfig ** config, int *err);
+
+extern int validGlxContext(ClientPtr client, XID id, int access_mode,
+                           __GLXcontext ** context, int *err);
+
+extern __GLXcontext *__glXdirectContextCreate(__GLXscreen * screen,
+                                              __GLXconfig * modes,
+                                              __GLXcontext * shareContext);
+
+#endif                          /* !__GLX_context_h__ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/glxcontext.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbestruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbestruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbestruct.h	(Revision 52145)
@@ -0,0 +1,202 @@
+/******************************************************************************
+ * 
+ * Copyright (c) 1994, 1995  Hewlett-Packard Company
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Hewlett-Packard
+ * Company shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Hewlett-Packard Company.
+ * 
+ *     Header file for DIX-related DBE
+ *
+ *****************************************************************************/
+
+#ifndef DBE_STRUCT_H
+#define DBE_STRUCT_H
+
+/* INCLUDES */
+
+#define NEED_DBE_PROTOCOL
+#include <X11/extensions/dbeproto.h>
+#include "windowstr.h"
+#include "privates.h"
+
+typedef struct {
+    VisualID visual;            /* one visual ID that supports double-buffering */
+    int depth;                  /* depth of visual in bits                      */
+    int perflevel;              /* performance level of visual                  */
+} XdbeVisualInfo;
+
+typedef struct {
+    int count;                  /* number of items in visual_depth   */
+    XdbeVisualInfo *visinfo;    /* list of visuals & depths for scrn */
+} XdbeScreenVisualInfo;
+
+/* DEFINES */
+
+#define DBE_SCREEN_PRIV(pScreen) ((DbeScreenPrivPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, dbeScreenPrivKey))
+
+#define DBE_SCREEN_PRIV_FROM_DRAWABLE(pDrawable) \
+    DBE_SCREEN_PRIV((pDrawable)->pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_WINDOW_PRIV(pDbeWindowPriv) \
+    DBE_SCREEN_PRIV((pDbeWindowPriv)->pWindow->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_WINDOW(pWindow) \
+    DBE_SCREEN_PRIV((pWindow)->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_PIXMAP(pPixmap) \
+    DBE_SCREEN_PRIV((pPixmap)->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_GC(pGC)\
+    DBE_SCREEN_PRIV((pGC)->pScreen)
+
+#define DBE_WINDOW_PRIV(pWin) ((DbeWindowPrivPtr) \
+    dixLookupPrivate(&(pWin)->devPrivates, dbeWindowPrivKey))
+
+/* Initial size of the buffer ID array in the window priv. */
+#define DBE_INIT_MAX_IDS	2
+
+/* Reallocation increment for the buffer ID array. */
+#define DBE_INCR_MAX_IDS	4
+
+/* Marker for free elements in the buffer ID array. */
+#define DBE_FREE_ID_ELEMENT	0
+
+/* TYPEDEFS */
+
+/* Record used to pass swap information between DIX and DDX swapping
+ * procedures.
+ */
+typedef struct _DbeSwapInfoRec {
+    WindowPtr pWindow;
+    unsigned char swapAction;
+
+} DbeSwapInfoRec, *DbeSwapInfoPtr;
+
+/*
+ ******************************************************************************
+ ** Per-window data
+ ******************************************************************************
+ */
+
+typedef struct _DbeWindowPrivRec {
+    /* A pointer to the window with which the DBE window private (buffer) is
+     * associated.
+     */
+    WindowPtr pWindow;
+
+    /* Last known swap action for this buffer.  Legal values for this field
+     * are XdbeUndefined, XdbeBackground, XdbeUntouched, and XdbeCopied.
+     */
+    unsigned char swapAction;
+
+    /* Last known buffer size.
+     */
+    unsigned short width, height;
+
+    /* Coordinates used for static gravity when the window is positioned.
+     */
+    short x, y;
+
+    /* Number of XIDs associated with this buffer.
+     */
+    int nBufferIDs;
+
+    /* Capacity of the current buffer ID array, IDs. */
+    int maxAvailableIDs;
+
+    /* Pointer to the array of buffer IDs.  This initially points to initIDs.
+     * When the static limit of the initIDs array is reached, the array is
+     * reallocated and this pointer is set to the new array instead of initIDs.
+     */
+    XID *IDs;
+
+    /* Initial array of buffer IDs.  We are defining the XID array within the
+     * window priv to optimize for data locality.  In most cases, only one
+     * buffer will be associated with a window.  Having the array declared
+     * here can prevent us from accessing the data in another memory page,
+     * possibly resulting in a page swap and loss of performance.  Initially we
+     * will use this array to store buffer IDs.  For situations where we have
+     * more IDs than can fit in this static array, we will allocate a larger
+     * array to use, possibly suffering a performance loss. 
+     */
+    XID initIDs[DBE_INIT_MAX_IDS];
+
+    /* Pointer to a drawable that contains the contents of the back buffer.
+     */
+    PixmapPtr pBackBuffer;
+
+    /* Pointer to a drawable that contains the contents of the front buffer.
+     * This pointer is only used for the XdbeUntouched swap action.  For that
+     * swap action, we need to copy the front buffer (window) contents into
+     * this drawable, copy the contents of current back buffer drawable (the
+     * back buffer) into the window, swap the front and back drawable pointers,
+     * and then swap the drawable/resource associations in the resource
+     * database.
+     */
+    PixmapPtr pFrontBuffer;
+
+    /* Device-specific private information.
+     */
+    PrivateRec *devPrivates;
+
+} DbeWindowPrivRec, *DbeWindowPrivPtr;
+
+/*
+ ******************************************************************************
+ ** Per-screen data
+ ******************************************************************************
+ */
+
+typedef struct _DbeScreenPrivRec {
+    /* Wrapped functions
+     * It is the responsibilty of the DDX layer to wrap PositionWindow().
+     * DbeExtensionInit wraps DestroyWindow().
+     */
+    PositionWindowProcPtr PositionWindow;
+    DestroyWindowProcPtr DestroyWindow;
+
+    /* Per-screen DIX routines */
+    Bool (*SetupBackgroundPainter) (WindowPtr /*pWin */ ,
+                                    GCPtr       /*pGC */
+        );
+
+    /* Per-screen DDX routines */
+    Bool (*GetVisualInfo) (ScreenPtr /*pScreen */ ,
+                           XdbeScreenVisualInfo *       /*pVisInfo */
+        );
+    int (*AllocBackBufferName) (WindowPtr /*pWin */ ,
+                                XID /*bufId */ ,
+                                int     /*swapAction */
+        );
+    int (*SwapBuffers) (ClientPtr /*client */ ,
+                        int * /*pNumWindows */ ,
+                        DbeSwapInfoPtr  /*swapInfo */
+        );
+    void (*WinPrivDelete) (DbeWindowPrivPtr /*pDbeWindowPriv */ ,
+                           XID  /*bufId */
+        );
+} DbeScreenPrivRec, *DbeScreenPrivPtr;
+
+#endif                          /* DBE_STRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dbestruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxbackend.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxbackend.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxbackend.h	(Revision 52145)
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to backend input device support. \see dmxbackend.c \see
+ * dmxcommon.c */
+
+#ifndef _DMXBACKEND_H_
+#define _DMXBACKEND_H_
+
+extern void *dmxBackendCreatePrivate(DeviceIntPtr pDevice);
+extern void dmxBackendDestroyPrivate(void *private);
+extern void dmxBackendInit(DevicePtr pDev);
+extern void dmxBackendLateReInit(DevicePtr pDev);
+extern void dmxBackendMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxBackendKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxBackendCollectEvents(DevicePtr pDev,
+                                    dmxMotionProcPtr motion,
+                                    dmxEnqueueProcPtr enqueue,
+                                    dmxCheckSpecialProcPtr checkspecial,
+                                    DMXBlockType block);
+extern void dmxBackendProcessInput(void *private);
+extern int dmxBackendFunctions(void *private, DMXFunctionType function);
+extern void dmxBackendUpdatePosition(void *private, int x, int y);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxbackend.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ops.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ops.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ops.h	(Revision 52145)
@@ -0,0 +1,45 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for operand decoding functions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_OPS_H
+#define __X86EMU_OPS_H
+
+extern void (*x86emu_optab[0x100]) (u8 op1);
+extern void (*x86emu_optab2[0x100]) (u8 op2);
+
+#endif                          /* __X86EMU_OPS_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/ops.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3_priv.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3_priv.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3_priv.h	(Revision 52145)
@@ -0,0 +1,80 @@
+/*
+ * Copyright ¬© 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _DRI3PRIV_H_
+#define _DRI3PRIV_H_
+
+#include <X11/X.h>
+#include "scrnintstr.h"
+#include "misc.h"
+#include "list.h"
+#include "windowstr.h"
+#include "dixstruct.h"
+#include <randrstr.h>
+#include "dri3.h"
+
+extern int dri3_request;
+
+extern DevPrivateKeyRec dri3_screen_private_key;
+
+typedef struct dri3_screen_priv {
+    CloseScreenProcPtr          CloseScreen;
+    ConfigNotifyProcPtr         ConfigNotify;
+    DestroyWindowProcPtr        DestroyWindow;
+
+    dri3_screen_info_ptr        info;
+} dri3_screen_priv_rec, *dri3_screen_priv_ptr;
+
+#define wrap(priv,real,mem,func) {\
+    priv->mem = real->mem; \
+    real->mem = func; \
+}
+
+#define unwrap(priv,real,mem) {\
+    real->mem = priv->mem; \
+}
+
+static inline dri3_screen_priv_ptr
+dri3_screen_priv(ScreenPtr screen)
+{
+    return (dri3_screen_priv_ptr)dixLookupPrivate(&(screen)->devPrivates, &dri3_screen_private_key);
+}
+
+int
+proc_dri3_dispatch(ClientPtr client);
+
+int
+sproc_dri3_dispatch(ClientPtr client);
+
+/* DDX interface */
+
+int
+dri3_open(ClientPtr client, ScreenPtr screen, RRProviderPtr provider, int *fd);
+
+int
+dri3_pixmap_from_fd(PixmapPtr *ppixmap, ScreenPtr screen, int fd,
+                    CARD16 width, CARD16 height, CARD16 stride, CARD8 depth, CARD8 bpp);
+
+int
+dri3_fd_from_pixmap(int *pfd, PixmapPtr pixmap, CARD16 *stride, CARD32 *size);
+
+#endif /* _DRI3PRIV_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dri3_priv.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damagestr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damagestr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damagestr.h	(Revision 52145)
@@ -0,0 +1,111 @@
+/*
+ * Copyright ¬© 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGESTR_H_
+#define _DAMAGESTR_H_
+
+#include "damage.h"
+#include "gcstruct.h"
+#include "privates.h"
+#include "picturestr.h"
+
+typedef struct _damage {
+    DamagePtr pNext;
+    DamagePtr pNextWin;
+    RegionRec damage;
+
+    DamageReportLevel damageLevel;
+    Bool isInternal;
+    void *closure;
+    Bool isWindow;
+    DrawablePtr pDrawable;
+
+    DamageReportFunc damageReport;
+    DamageDestroyFunc damageDestroy;
+
+    Bool reportAfter;
+    RegionRec pendingDamage;    /* will be flushed post submission at the latest */
+    ScreenPtr pScreen;
+    PrivateRec *devPrivates;
+} DamageRec;
+
+typedef struct _damageScrPriv {
+    int internalLevel;
+
+    /*
+     * For DDXen which don't provide GetScreenPixmap, this provides
+     * a place to hook damage for windows on the screen
+     */
+    DamagePtr pScreenDamage;
+
+    CopyWindowProcPtr CopyWindow;
+    CloseScreenProcPtr CloseScreen;
+    CreateGCProcPtr CreateGC;
+    DestroyPixmapProcPtr DestroyPixmap;
+    SetWindowPixmapProcPtr SetWindowPixmap;
+    DestroyWindowProcPtr DestroyWindow;
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+    AddTrapsProcPtr AddTraps;
+
+    /* Table of wrappable function pointers */
+    DamageScreenFuncsRec funcs;
+} DamageScrPrivRec, *DamageScrPrivPtr;
+
+typedef struct _damageGCPriv {
+    const GCOps *ops;
+    const GCFuncs *funcs;
+} DamageGCPrivRec, *DamageGCPrivPtr;
+
+/* XXX should move these into damage.c, damageScrPrivateIndex is static */
+#define damageGetScrPriv(pScr) ((DamageScrPrivPtr) \
+    dixLookupPrivate(&(pScr)->devPrivates, damageScrPrivateKey))
+
+#define damageScrPriv(pScr) \
+    DamageScrPrivPtr    pScrPriv = damageGetScrPriv(pScr)
+
+#define damageGetPixPriv(pPix) \
+    dixLookupPrivate(&(pPix)->devPrivates, damagePixPrivateKey)
+
+#define damgeSetPixPriv(pPix,v) \
+    dixSetPrivate(&(pPix)->devPrivates, damagePixPrivateKey, v)
+
+#define damagePixPriv(pPix) \
+    DamagePtr	    pDamage = damageGetPixPriv(pPix)
+
+#define damageGetGCPriv(pGC) \
+    dixLookupPrivate(&(pGC)->devPrivates, damageGCPrivateKey)
+
+#define damageGCPriv(pGC) \
+    DamageGCPrivPtr  pGCPriv = damageGetGCPriv(pGC)
+
+#define damageGetWinPriv(pWin) \
+    ((DamagePtr)dixLookupPrivate(&(pWin)->devPrivates, damageWinPrivateKey))
+
+#define damageSetWinPriv(pWin,d) \
+    dixSetPrivate(&(pWin)->devPrivates, damageWinPrivateKey, d)
+
+#endif                          /* _DAMAGESTR_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/damagestr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/window.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/window.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/window.h	(Revision 52145)
@@ -0,0 +1,228 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef WINDOW_H
+#define WINDOW_H
+
+#include "misc.h"
+#include "region.h"
+#include "screenint.h"
+#include <X11/Xproto.h>
+
+#define TOTALLY_OBSCURED 0
+#define UNOBSCURED 1
+#define OBSCURED 2
+
+#define VisibilityNotViewable	3
+
+/* return values for tree-walking callback procedures */
+#define WT_STOPWALKING		0
+#define WT_WALKCHILDREN		1
+#define WT_DONTWALKCHILDREN	2
+#define WT_NOMATCH 3
+#define NullWindow ((WindowPtr) 0)
+
+/* Forward declaration, we can't include input.h here */
+struct _DeviceIntRec;
+struct _Cursor;
+
+typedef struct _BackingStore *BackingStorePtr;
+typedef struct _Window *WindowPtr;
+
+typedef int (*VisitWindowProcPtr) (WindowPtr /*pWin */ ,
+                                   void */*data */ );
+
+extern _X_EXPORT int TraverseTree(WindowPtr /*pWin */ ,
+                                  VisitWindowProcPtr /*func */ ,
+                                  void */*data */ );
+
+extern _X_EXPORT int WalkTree(ScreenPtr /*pScreen */ ,
+                              VisitWindowProcPtr /*func */ ,
+                              void */*data */ );
+
+extern _X_EXPORT Bool CreateRootWindow(ScreenPtr /*pScreen */ );
+
+extern _X_EXPORT void InitRootWindow(WindowPtr /*pWin */ );
+
+typedef WindowPtr (*RealChildHeadProc) (WindowPtr pWin);
+
+extern _X_EXPORT void RegisterRealChildHeadProc(RealChildHeadProc proc);
+
+extern _X_EXPORT WindowPtr RealChildHead(WindowPtr /*pWin */ );
+
+extern _X_EXPORT WindowPtr CreateWindow(Window /*wid */ ,
+                                        WindowPtr /*pParent */ ,
+                                        int /*x */ ,
+                                        int /*y */ ,
+                                        unsigned int /*w */ ,
+                                        unsigned int /*h */ ,
+                                        unsigned int /*bw */ ,
+                                        unsigned int /*class */ ,
+                                        Mask /*vmask */ ,
+                                        XID * /*vlist */ ,
+                                        int /*depth */ ,
+                                        ClientPtr /*client */ ,
+                                        VisualID /*visual */ ,
+                                        int * /*error */ );
+
+extern _X_EXPORT int DeleteWindow(void */*pWin */ ,
+                                  XID /*wid */ );
+
+extern _X_EXPORT int DestroySubwindows(WindowPtr /*pWin */ ,
+                                       ClientPtr /*client */ );
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose ChangeWindowAttributes function conflicts here. */
+#ifdef __APPLE__
+#define ChangeWindowAttributes Darwin_X_ChangeWindowAttributes
+#endif
+extern _X_EXPORT int ChangeWindowAttributes(WindowPtr /*pWin */ ,
+                                            Mask /*vmask */ ,
+                                            XID * /*vlist */ ,
+                                            ClientPtr /*client */ );
+
+extern _X_EXPORT int ChangeWindowDeviceCursor(WindowPtr /*pWin */ ,
+                                              struct _DeviceIntRec * /*pDev */ ,
+                                              struct _Cursor * /*pCursor */ );
+
+extern _X_EXPORT struct _Cursor *WindowGetDeviceCursor(WindowPtr /*pWin */ ,
+                                                       struct _DeviceIntRec *
+                                                       /*pDev */ );
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose GetWindowAttributes function conflicts here. */
+#ifdef __APPLE__
+#define GetWindowAttributes(w,c,x) Darwin_X_GetWindowAttributes(w,c,x)
+extern void Darwin_X_GetWindowAttributes(
+#else
+extern _X_EXPORT void GetWindowAttributes(
+#endif
+                                             WindowPtr /*pWin */ ,
+                                             ClientPtr /*client */ ,
+                                             xGetWindowAttributesReply *
+                                             /* wa */ );
+
+extern _X_EXPORT void GravityTranslate(int /*x */ ,
+                                       int /*y */ ,
+                                       int /*oldx */ ,
+                                       int /*oldy */ ,
+                                       int /*dw */ ,
+                                       int /*dh */ ,
+                                       unsigned /*gravity */ ,
+                                       int * /*destx */ ,
+                                       int * /*desty */ );
+
+extern _X_EXPORT int ConfigureWindow(WindowPtr /*pWin */ ,
+                                     Mask /*mask */ ,
+                                     XID * /*vlist */ ,
+                                     ClientPtr /*client */ );
+
+extern _X_EXPORT int CirculateWindow(WindowPtr /*pParent */ ,
+                                     int /*direction */ ,
+                                     ClientPtr /*client */ );
+
+extern _X_EXPORT int ReparentWindow(WindowPtr /*pWin */ ,
+                                    WindowPtr /*pParent */ ,
+                                    int /*x */ ,
+                                    int /*y */ ,
+                                    ClientPtr /*client */ );
+
+extern _X_EXPORT int MapWindow(WindowPtr /*pWin */ ,
+                               ClientPtr /*client */ );
+
+extern _X_EXPORT void MapSubwindows(WindowPtr /*pParent */ ,
+                                    ClientPtr /*client */ );
+
+extern _X_EXPORT int UnmapWindow(WindowPtr /*pWin */ ,
+                                 Bool /*fromConfigure */ );
+
+extern _X_EXPORT void UnmapSubwindows(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void HandleSaveSet(ClientPtr /*client */ );
+
+extern _X_EXPORT Bool PointInWindowIsVisible(WindowPtr /*pWin */ ,
+                                             int /*x */ ,
+                                             int /*y */ );
+
+extern _X_EXPORT RegionPtr NotClippedByChildren(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void SendVisibilityNotify(WindowPtr /*pWin */ );
+
+extern _X_EXPORT int dixSaveScreens(ClientPtr client, int on, int mode);
+
+extern _X_EXPORT int SaveScreens(int on, int mode);
+
+extern _X_EXPORT WindowPtr FindWindowWithOptional(WindowPtr /*w */ );
+
+extern _X_EXPORT void CheckWindowOptionalNeed(WindowPtr /*w */ );
+
+extern _X_EXPORT Bool MakeWindowOptional(WindowPtr /*pWin */ );
+
+extern _X_EXPORT WindowPtr MoveWindowInStack(WindowPtr /*pWin */ ,
+                                             WindowPtr /*pNextSib */ );
+
+extern _X_EXPORT void SetWinSize(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void SetBorderSize(WindowPtr /*pWin */ );
+
+extern _X_EXPORT void ResizeChildrenWinSize(WindowPtr /*pWin */ ,
+                                            int /*dx */ ,
+                                            int /*dy */ ,
+                                            int /*dw */ ,
+                                            int /*dh */ );
+
+extern _X_EXPORT void SendShapeNotify(WindowPtr /* pWin */ ,
+                                      int /* which */);
+
+extern _X_EXPORT RegionPtr CreateBoundingShape(WindowPtr /* pWin */ );
+
+extern _X_EXPORT RegionPtr CreateClipShape(WindowPtr /* pWin */ );
+
+extern _X_EXPORT void SetRootClip(ScreenPtr pScreen, Bool enable);
+extern _X_EXPORT void PrintWindowTree(void);
+
+extern _X_EXPORT VisualPtr WindowGetVisual(WindowPtr /*pWin*/);
+#endif                          /* WINDOW_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/window.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compint.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compint.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compint.h	(Revision 52145)
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright ¬© 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _COMPINT_H_
+#define _COMPINT_H_
+
+#include "misc.h"
+#include "scrnintstr.h"
+#include "os.h"
+#include "regionstr.h"
+#include "validate.h"
+#include "windowstr.h"
+#include "input.h"
+#include "resource.h"
+#include "colormapst.h"
+#include "cursorstr.h"
+#include "dixstruct.h"
+#include "gcstruct.h"
+#include "servermd.h"
+#include "dixevents.h"
+#include "globals.h"
+#include "picturestr.h"
+#include "extnsionst.h"
+#include "privates.h"
+#include "mi.h"
+#include "damage.h"
+#include "damageextint.h"
+#include "xfixes.h"
+#include <X11/extensions/compositeproto.h>
+#include "compositeext.h"
+#include <assert.h>
+
+/*
+ *  enable this for debugging
+ 
+    #define COMPOSITE_DEBUG
+ */
+
+typedef struct _CompClientWindow {
+    struct _CompClientWindow *next;
+    XID id;
+    int update;
+} CompClientWindowRec, *CompClientWindowPtr;
+
+typedef struct _CompWindow {
+    RegionRec borderClip;
+    DamagePtr damage;           /* for automatic update mode */
+    Bool damageRegistered;
+    Bool damaged;
+    int update;
+    CompClientWindowPtr clients;
+    int oldx;
+    int oldy;
+    PixmapPtr pOldPixmap;
+    int borderClipX, borderClipY;
+} CompWindowRec, *CompWindowPtr;
+
+#define COMP_ORIGIN_INVALID	    0x80000000
+
+typedef struct _CompSubwindows {
+    int update;
+    CompClientWindowPtr clients;
+} CompSubwindowsRec, *CompSubwindowsPtr;
+
+#ifndef COMP_INCLUDE_RGB24_VISUAL
+#define COMP_INCLUDE_RGB24_VISUAL 0
+#endif
+
+typedef struct _CompOverlayClientRec *CompOverlayClientPtr;
+
+typedef struct _CompOverlayClientRec {
+    CompOverlayClientPtr pNext;
+    ClientPtr pClient;
+    ScreenPtr pScreen;
+    XID resource;
+} CompOverlayClientRec;
+
+typedef struct _CompImplicitRedirectException {
+    XID parentVisual;
+    XID winVisual;
+} CompImplicitRedirectException;
+
+typedef struct _CompScreen {
+    PositionWindowProcPtr PositionWindow;
+    CopyWindowProcPtr CopyWindow;
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    ClipNotifyProcPtr ClipNotify;
+    /*
+     * Called from ConfigureWindow, these
+     * three track changes to the offscreen storage
+     * geometry
+     */
+    ConfigNotifyProcPtr ConfigNotify;
+    MoveWindowProcPtr MoveWindow;
+    ResizeWindowProcPtr ResizeWindow;
+    ChangeBorderWidthProcPtr ChangeBorderWidth;
+    /*
+     * Reparenting has an effect on Subwindows redirect
+     */
+    ReparentWindowProcPtr ReparentWindow;
+
+    /*
+     * Colormaps for new visuals better not get installed
+     */
+    InstallColormapProcPtr InstallColormap;
+
+    /*
+     * Fake backing store via automatic redirection
+     */
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+
+    ScreenBlockHandlerProcPtr BlockHandler;
+    CloseScreenProcPtr CloseScreen;
+    int numAlternateVisuals;
+    VisualID *alternateVisuals;
+    int numImplicitRedirectExceptions;
+    CompImplicitRedirectException *implicitRedirectExceptions;
+
+    WindowPtr pOverlayWin;
+    Window overlayWid;
+    CompOverlayClientPtr pOverlayClients;
+
+    GetImageProcPtr GetImage;
+    SourceValidateProcPtr SourceValidate;
+} CompScreenRec, *CompScreenPtr;
+
+extern DevPrivateKeyRec CompScreenPrivateKeyRec;
+
+#define CompScreenPrivateKey (&CompScreenPrivateKeyRec)
+
+extern DevPrivateKeyRec CompWindowPrivateKeyRec;
+
+#define CompWindowPrivateKey (&CompWindowPrivateKeyRec)
+
+extern DevPrivateKeyRec CompSubwindowsPrivateKeyRec;
+
+#define CompSubwindowsPrivateKey (&CompSubwindowsPrivateKeyRec)
+
+#define GetCompScreen(s) ((CompScreenPtr) \
+    dixLookupPrivate(&(s)->devPrivates, CompScreenPrivateKey))
+#define GetCompWindow(w) ((CompWindowPtr) \
+    dixLookupPrivate(&(w)->devPrivates, CompWindowPrivateKey))
+#define GetCompSubwindows(w) ((CompSubwindowsPtr) \
+    dixLookupPrivate(&(w)->devPrivates, CompSubwindowsPrivateKey))
+
+extern RESTYPE CompositeClientSubwindowsType;
+extern RESTYPE CompositeClientOverlayType;
+
+/*
+ * compalloc.c
+ */
+
+Bool
+ compRedirectWindow(ClientPtr pClient, WindowPtr pWin, int update);
+
+void
+ compFreeClientWindow(WindowPtr pWin, XID id);
+
+int
+ compUnredirectWindow(ClientPtr pClient, WindowPtr pWin, int update);
+
+int
+ compRedirectSubwindows(ClientPtr pClient, WindowPtr pWin, int update);
+
+void
+ compFreeClientSubwindows(WindowPtr pWin, XID id);
+
+int
+ compUnredirectSubwindows(ClientPtr pClient, WindowPtr pWin, int update);
+
+int
+ compRedirectOneSubwindow(WindowPtr pParent, WindowPtr pWin);
+
+int
+ compUnredirectOneSubwindow(WindowPtr pParent, WindowPtr pWin);
+
+Bool
+ compAllocPixmap(WindowPtr pWin);
+
+void
+ compSetParentPixmap(WindowPtr pWin);
+
+void
+ compRestoreWindow(WindowPtr pWin, PixmapPtr pPixmap);
+
+Bool
+
+compReallocPixmap(WindowPtr pWin, int x, int y,
+                  unsigned int w, unsigned int h, int bw);
+
+/*
+ * compinit.c
+ */
+
+Bool
+ compScreenInit(ScreenPtr pScreen);
+
+/*
+ * compoverlay.c
+ */
+
+void
+ compFreeOverlayClient(CompOverlayClientPtr pOcToDel);
+
+CompOverlayClientPtr
+compFindOverlayClient(ScreenPtr pScreen, ClientPtr pClient);
+
+CompOverlayClientPtr
+compCreateOverlayClient(ScreenPtr pScreen, ClientPtr pClient);
+
+Bool
+ compCreateOverlayWindow(ScreenPtr pScreen);
+
+void
+ compDestroyOverlayWindow(ScreenPtr pScreen);
+
+/*
+ * compwindow.c
+ */
+
+#ifdef COMPOSITE_DEBUG
+void
+ compCheckTree(ScreenPtr pScreen);
+#else
+#define compCheckTree(s)
+#endif
+
+void
+ compSetPixmap(WindowPtr pWin, PixmapPtr pPixmap);
+
+Bool
+ compCheckRedirect(WindowPtr pWin);
+
+Bool
+ compPositionWindow(WindowPtr pWin, int x, int y);
+
+Bool
+ compRealizeWindow(WindowPtr pWin);
+
+Bool
+ compUnrealizeWindow(WindowPtr pWin);
+
+void
+ compClipNotify(WindowPtr pWin, int dx, int dy);
+
+void
+ compMoveWindow(WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind);
+
+void
+
+compResizeWindow(WindowPtr pWin, int x, int y,
+                 unsigned int w, unsigned int h, WindowPtr pSib);
+
+void
+ compChangeBorderWidth(WindowPtr pWin, unsigned int border_width);
+
+void
+ compReparentWindow(WindowPtr pWin, WindowPtr pPriorParent);
+
+Bool
+ compCreateWindow(WindowPtr pWin);
+
+Bool
+ compDestroyWindow(WindowPtr pWin);
+
+void
+ compSetRedirectBorderClip(WindowPtr pWin, RegionPtr pRegion);
+
+RegionPtr
+ compGetRedirectBorderClip(WindowPtr pWin);
+
+void
+ compCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+void
+ compPaintChildrenToWindow(WindowPtr pWin);
+
+WindowPtr
+ CompositeRealChildHead(WindowPtr pWin);
+
+int
+ DeleteWindowNoInputDevices(void *value, XID wid);
+
+int
+
+compConfigNotify(WindowPtr pWin, int x, int y, int w, int h,
+                 int bw, WindowPtr pSib);
+
+void PanoramiXCompositeInit(void);
+void PanoramiXCompositeReset(void);
+
+#endif                          /* _COMPINT_H_ */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/compint.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiwarppointer.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiwarppointer.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiwarppointer.h	(Revision 52145)
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef WARPDEVP_H
+#define WARPDEVP_H 1
+
+int SProcXIWarpPointer(ClientPtr /* client */ );
+int ProcXIWarpPointer(ClientPtr /* client */ );
+
+#endif                          /* WARPDEVP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiwarppointer.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/configProcs.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/configProcs.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/configProcs.h	(Revision 52145)
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* Private procs.  Public procs are in xf86Parser.h and xf86Optrec.h */
+
+/* exported functions are/were used by the X Server, and need to be
+ * made public when installing libxf86config */
+
+/* Device.c */
+XF86ConfDevicePtr xf86parseDeviceSection(void);
+void xf86printDeviceSection(FILE * cf, XF86ConfDevicePtr ptr);
+void xf86freeDeviceList(XF86ConfDevicePtr ptr);
+int xf86validateDevice(XF86ConfigPtr p);
+
+/* Files.c */
+XF86ConfFilesPtr xf86parseFilesSection(void);
+void xf86printFileSection(FILE * cf, XF86ConfFilesPtr ptr);
+void xf86freeFiles(XF86ConfFilesPtr p);
+
+/* Flags.c */
+XF86ConfFlagsPtr xf86parseFlagsSection(void);
+void xf86printServerFlagsSection(FILE * f, XF86ConfFlagsPtr flags);
+void xf86freeFlags(XF86ConfFlagsPtr flags);
+
+/* Input.c */
+XF86ConfInputPtr xf86parseInputSection(void);
+void xf86printInputSection(FILE * f, XF86ConfInputPtr ptr);
+void xf86freeInputList(XF86ConfInputPtr ptr);
+int xf86validateInput(XF86ConfigPtr p);
+
+/* InputClass.c */
+XF86ConfInputClassPtr xf86parseInputClassSection(void);
+void xf86printInputClassSection(FILE * f, XF86ConfInputClassPtr ptr);
+void xf86freeInputClassList(XF86ConfInputClassPtr ptr);
+
+/* OutputClass.c */
+XF86ConfOutputClassPtr xf86parseOutputClassSection(void);
+void xf86printOutputClassSection(FILE * f, XF86ConfOutputClassPtr ptr);
+void xf86freeOutputClassList(XF86ConfOutputClassPtr ptr);
+
+/* Layout.c */
+XF86ConfLayoutPtr xf86parseLayoutSection(void);
+void xf86printLayoutSection(FILE * cf, XF86ConfLayoutPtr ptr);
+void xf86freeLayoutList(XF86ConfLayoutPtr ptr);
+int xf86validateLayout(XF86ConfigPtr p);
+
+/* Module.c */
+XF86ConfModulePtr xf86parseModuleSection(void);
+void xf86printModuleSection(FILE * cf, XF86ConfModulePtr ptr);
+extern _X_EXPORT XF86LoadPtr xf86addNewLoadDirective(XF86LoadPtr head,
+                                                     const char *name, int type,
+                                                     XF86OptionPtr opts);
+void xf86freeModules(XF86ConfModulePtr ptr);
+
+/* Monitor.c */
+XF86ConfMonitorPtr xf86parseMonitorSection(void);
+XF86ConfModesPtr xf86parseModesSection(void);
+void xf86printMonitorSection(FILE * cf, XF86ConfMonitorPtr ptr);
+void xf86printModesSection(FILE * cf, XF86ConfModesPtr ptr);
+extern _X_EXPORT void xf86freeMonitorList(XF86ConfMonitorPtr ptr);
+void xf86freeModesList(XF86ConfModesPtr ptr);
+int xf86validateMonitor(XF86ConfigPtr p, XF86ConfScreenPtr screen);
+
+/* Pointer.c */
+XF86ConfInputPtr xf86parsePointerSection(void);
+
+/* Screen.c */
+XF86ConfScreenPtr xf86parseScreenSection(void);
+void xf86printScreenSection(FILE * cf, XF86ConfScreenPtr ptr);
+extern _X_EXPORT void xf86freeScreenList(XF86ConfScreenPtr ptr);
+void xf86freeAdaptorLinkList(XF86ConfAdaptorLinkPtr ptr);
+void xf86freeDisplayList(XF86ConfDisplayPtr ptr);
+void xf86freeModeList(XF86ModePtr ptr);
+int xf86validateScreen(XF86ConfigPtr p);
+
+/* Vendor.c */
+XF86ConfVendorPtr xf86parseVendorSection(void);
+void xf86freeVendorList(XF86ConfVendorPtr p);
+void xf86printVendorSection(FILE * cf, XF86ConfVendorPtr ptr);
+void xf86freeVendorSubList(XF86ConfVendSubPtr ptr);
+
+/* Video.c */
+XF86ConfVideoAdaptorPtr xf86parseVideoAdaptorSection(void);
+void xf86printVideoAdaptorSection(FILE * cf, XF86ConfVideoAdaptorPtr ptr);
+void xf86freeVideoAdaptorList(XF86ConfVideoAdaptorPtr ptr);
+
+/* scan.c */
+int xf86getToken(xf86ConfigSymTabRec * tab);
+int xf86getSubToken(char **comment);
+int xf86getSubTokenWithTab(char **comment, xf86ConfigSymTabRec * tab);
+void xf86unGetToken(int token);
+char *xf86tokenString(void);
+void
+xf86parseError(const char *format, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+void
+xf86validationError(const char *format, ...)
+_X_ATTRIBUTE_PRINTF(1, 2);
+void
+xf86setSection(const char *section);
+int
+xf86getStringToken(xf86ConfigSymTabRec * tab);
+
+/* write.c */
+/* DRI.c */
+XF86ConfDRIPtr
+xf86parseDRISection(void);
+void
+xf86printDRISection(FILE * cf, XF86ConfDRIPtr ptr);
+void
+xf86freeDRI(XF86ConfDRIPtr ptr);
+
+/* Extensions.c */
+XF86ConfExtensionsPtr
+xf86parseExtensionsSection(void);
+void
+xf86printExtensionsSection(FILE * cf, XF86ConfExtensionsPtr ptr);
+void
+xf86freeExtensions(XF86ConfExtensionsPtr ptr);
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef HAVE_XORG_CONFIG_H
+/* Externally provided functions */
+void
+ErrorF(const char *f, ...);
+void
+VErrorF(const char *f, va_list args);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/configProcs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormap.h	(Revision 52145)
@@ -0,0 +1,170 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+*/
+
+#ifndef CMAP_H
+#define CMAP_H 1
+
+#include <X11/Xproto.h>
+#include "screenint.h"
+#include "window.h"
+
+/* these follow X.h's AllocNone and AllocAll */
+#define CM_PSCREEN 2
+#define CM_PWIN	   3
+/* Passed internally in colormap.c */
+#define REDMAP 0
+#define GREENMAP 1
+#define BLUEMAP 2
+#define PSEUDOMAP 3
+#define AllocPrivate (-1)
+#define AllocTemporary (-2)
+#define DynamicClass  1
+
+/* Values for the flags field of a colormap. These should have 1 bit set
+ * and not overlap */
+#define IsDefault 1
+#define AllAllocated 2
+#define BeingCreated 4
+
+typedef CARD32 Pixel;
+typedef struct _CMEntry *EntryPtr;
+
+/* moved to screenint.h: typedef struct _ColormapRec *ColormapPtr */
+typedef struct _colorResource *colorResourcePtr;
+
+extern _X_EXPORT int CreateColormap(Colormap /*mid */ ,
+                                    ScreenPtr /*pScreen */ ,
+                                    VisualPtr /*pVisual */ ,
+                                    ColormapPtr * /*ppcmap */ ,
+                                    int /*alloc */ ,
+                                    int /*client */ );
+
+extern _X_EXPORT int FreeColormap(void */*pmap */ ,
+                                  XID /*mid */ );
+
+extern _X_EXPORT int TellLostMap(WindowPtr /*pwin */ ,
+                                 void */* Colormap *pmid */ );
+
+extern _X_EXPORT int TellGainedMap(WindowPtr /*pwin */ ,
+                                   void */* Colormap *pmid */ );
+
+extern _X_EXPORT int CopyColormapAndFree(Colormap /*mid */ ,
+                                         ColormapPtr /*pSrc */ ,
+                                         int /*client */ );
+
+extern _X_EXPORT int AllocColor(ColormapPtr /*pmap */ ,
+                                unsigned short * /*pred */ ,
+                                unsigned short * /*pgreen */ ,
+                                unsigned short * /*pblue */ ,
+                                Pixel * /*pPix */ ,
+                                int /*client */ );
+
+extern _X_EXPORT void FakeAllocColor(ColormapPtr /*pmap */ ,
+                                     xColorItem * /*item */ );
+
+extern _X_EXPORT void FakeFreeColor(ColormapPtr /*pmap */ ,
+                                    Pixel /*pixel */ );
+
+typedef int (*ColorCompareProcPtr) (EntryPtr /*pent */ ,
+                                    xrgb * /*prgb */ );
+
+extern _X_EXPORT int FindColor(ColormapPtr /*pmap */ ,
+                               EntryPtr /*pentFirst */ ,
+                               int /*size */ ,
+                               xrgb * /*prgb */ ,
+                               Pixel * /*pPixel */ ,
+                               int /*channel */ ,
+                               int /*client */ ,
+                               ColorCompareProcPtr /*comp */ );
+
+extern _X_EXPORT int QueryColors(ColormapPtr /*pmap */ ,
+                                 int /*count */ ,
+                                 Pixel * /*ppixIn */ ,
+                                 xrgb * /*prgbList */ ,
+                                 ClientPtr client);
+
+extern _X_EXPORT int FreeClientPixels(void */*pcr */ ,
+                                      XID /*fakeid */ );
+
+extern _X_EXPORT int AllocColorCells(int /*client */ ,
+                                     ColormapPtr /*pmap */ ,
+                                     int /*colors */ ,
+                                     int /*planes */ ,
+                                     Bool /*contig */ ,
+                                     Pixel * /*ppix */ ,
+                                     Pixel * /*masks */ );
+
+extern _X_EXPORT int AllocColorPlanes(int /*client */ ,
+                                      ColormapPtr /*pmap */ ,
+                                      int /*colors */ ,
+                                      int /*r */ ,
+                                      int /*g */ ,
+                                      int /*b */ ,
+                                      Bool /*contig */ ,
+                                      Pixel * /*pixels */ ,
+                                      Pixel * /*prmask */ ,
+                                      Pixel * /*pgmask */ ,
+                                      Pixel * /*pbmask */ );
+
+extern _X_EXPORT int FreeColors(ColormapPtr /*pmap */ ,
+                                int /*client */ ,
+                                int /*count */ ,
+                                Pixel * /*pixels */ ,
+                                Pixel /*mask */ );
+
+extern _X_EXPORT int StoreColors(ColormapPtr /*pmap */ ,
+                                 int /*count */ ,
+                                 xColorItem * /*defs */ ,
+                                 ClientPtr client);
+
+extern _X_EXPORT int IsMapInstalled(Colormap /*map */ ,
+                                    WindowPtr /*pWin */ );
+
+extern _X_EXPORT Bool ResizeVisualArray(ScreenPtr /* pScreen */ ,
+                                        int /* new_vis_count */ ,
+                                        DepthPtr /* depth */ );
+
+#endif                          /* CMAP_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/colormap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extnsionst.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extnsionst.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extnsionst.h	(Revision 52145)
@@ -0,0 +1,112 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef EXTENSIONSTRUCT_H
+#define EXTENSIONSTRUCT_H
+
+#include "dix.h"
+#include "misc.h"
+#include "screenint.h"
+#include "extension.h"
+#include "gc.h"
+#include "privates.h"
+
+typedef struct _ExtensionEntry {
+    int index;
+    void (*CloseDown) (         /* called at server shutdown */
+                          struct _ExtensionEntry * /* extension */ );
+    const char *name;           /* extension name */
+    int base;                   /* base request number */
+    int eventBase;
+    int eventLast;
+    int errorBase;
+    int errorLast;
+    int num_aliases;
+    const char **aliases;
+    void *extPrivate;
+    unsigned short (*MinorOpcode) (     /* called for errors */
+                                      ClientPtr /* client */ );
+    PrivateRec *devPrivates;
+} ExtensionEntry;
+
+/* 
+ * The arguments may be different for extension event swapping functions.
+ * Deal with this by casting when initializing the event's EventSwapVector[]
+ * entries.
+ */
+typedef void (*EventSwapPtr) (xEvent *, xEvent *);
+
+extern _X_EXPORT EventSwapPtr EventSwapVector[128];
+
+extern _X_EXPORT void
+NotImplemented(                 /* FIXME: this may move to another file... */
+                  xEvent *, xEvent *) _X_NORETURN;
+
+#define    SetGCVector(pGC, VectorElement, NewRoutineAddress, Atom)    \
+    pGC->VectorElement = NewRoutineAddress;
+
+#define    GetGCValue(pGC, GCElement)    (pGC->GCElement)
+
+extern _X_EXPORT ExtensionEntry *
+AddExtension(const char * /*name */ ,
+             int /*NumEvents */ ,
+             int /*NumErrors */ ,
+             int (* /*MainProc */ )(ClientPtr /*client */ ),
+             int (* /*SwappedMainProc */ )(ClientPtr /*client */ ),
+             void (* /*CloseDownProc */ )(ExtensionEntry * /*extension */ ),
+             unsigned short (* /*MinorOpcodeProc */ )(ClientPtr /*client */ )
+    );
+
+extern _X_EXPORT Bool
+AddExtensionAlias(const char * /*alias */ ,
+                  ExtensionEntry * /*extension */ );
+
+extern _X_EXPORT ExtensionEntry *
+CheckExtension(const char *extname);
+extern _X_EXPORT ExtensionEntry *
+GetExtensionEntry(int major);
+
+#endif                          /* EXTENSIONSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/extnsionst.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/migc.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/migc.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/migc.h	(Revision 52145)
@@ -0,0 +1,49 @@
+/*
+
+Copyright 1993, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+extern _X_EXPORT void miChangeGC(GCPtr          pGC,
+                                 unsigned long  mask);
+
+extern _X_EXPORT void miDestroyGC(GCPtr         pGC);
+
+extern _X_EXPORT void miDestroyClip(GCPtr       pGC);
+
+extern _X_EXPORT void miChangeClip(GCPtr        pGC,
+                                   int          type,
+                                   void         *pvalue,
+                                   int          nrects);
+
+extern _X_EXPORT void miCopyClip(GCPtr          pgcDst,
+                                 GCPtr          pgcSrc);
+
+extern _X_EXPORT void miCopyGC(GCPtr            pGCSrc,
+                               unsigned long    changes,
+                               GCPtr            pGCDst);
+
+extern _X_EXPORT void miComputeCompositeClip(GCPtr              pGC,
+                                             DrawablePtr        pDrawable);

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/migc.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dristruct.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dristruct.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dristruct.h	(Revision 52145)
@@ -0,0 +1,124 @@
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Jens Owen <jens@tungstengraphics.com>
+ *
+ */
+
+#ifndef DRI_STRUCT_H
+#define DRI_STRUCT_H
+
+#include "xf86drm.h"
+#include "xf86Crtc.h"
+
+#define DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin) ((DRIDrawablePrivPtr) \
+    dixLookupPrivate(&(pWin)->devPrivates, DRIWindowPrivKey))
+#define DRI_DRAWABLE_PRIV_FROM_PIXMAP(pPix) ((DRIDrawablePrivPtr) \
+    dixLookupPrivate(&(pPix)->devPrivates, DRIWindowPrivKey))
+
+typedef struct _DRIDrawablePrivRec {
+    drm_drawable_t hwDrawable;
+    int drawableIndex;
+    ScreenPtr pScreen;
+    int refCount;
+    int nrects;
+} DRIDrawablePrivRec, *DRIDrawablePrivPtr;
+
+struct _DRIContextPrivRec {
+    drm_context_t hwContext;
+    ScreenPtr pScreen;
+    Bool valid3D;
+    DRIContextFlags flags;
+    void **pContextStore;
+};
+
+#define DRI_SCREEN_PRIV(pScreen) ((DRIScreenPrivPtr) \
+    (dixPrivateKeyRegistered(DRIScreenPrivKey) ?			\
+     dixLookupPrivate(&(pScreen)->devPrivates, DRIScreenPrivKey) : NULL))
+
+#define DRI_SCREEN_PRIV_FROM_INDEX(screenIndex) ((DRIScreenPrivPtr) \
+    dixLookupPrivate(&screenInfo.screens[screenIndex]->devPrivates, \
+		     DRIScreenPrivKey))
+
+#define DRI_ENT_PRIV(pScrn)  \
+    ((DRIEntPrivIndex < 0) ? \
+     NULL:		     \
+     ((DRIEntPrivPtr)(xf86GetEntityPrivate((pScrn)->entityList[0], \
+					   DRIEntPrivIndex)->ptr)))
+
+typedef struct _DRIScreenPrivRec {
+    Bool directRenderingSupport;
+    int drmFD;                  /* File descriptor for /dev/video/?   */
+    drm_handle_t hSAREA;        /* Handle to SAREA, for mapping       */
+    XF86DRISAREAPtr pSAREA;     /* Mapped pointer to SAREA            */
+    drm_context_t myContext;    /* DDX Driver's context               */
+    DRIContextPrivPtr myContextPriv;    /* Pointer to server's private area   */
+    DRIContextPrivPtr lastPartial3DContext;     /* last one partially saved  */
+    void **hiddenContextStore;  /* hidden X context          */
+    void **partial3DContextStore;       /* parital 3D context        */
+    DRIInfoPtr pDriverInfo;
+    int nrWindows;
+    int nrWindowsVisible;
+    int nrWalked;
+    drm_clip_rect_t private_buffer_rect;        /* management of private buffers */
+    DrawablePtr fullscreen;     /* pointer to fullscreen drawable */
+    drm_clip_rect_t fullscreen_rect;    /* fake rect for fullscreen mode */
+    DRIWrappedFuncsRec wrap;
+    DestroyWindowProcPtr DestroyWindow;
+    DrawablePtr DRIDrawables[SAREA_MAX_DRAWABLES];
+    DRIContextPrivPtr dummyCtxPriv;     /* Pointer to dummy context */
+    Bool createDummyCtx;
+    Bool createDummyCtxPriv;
+    Bool grabbedDRILock;
+    Bool drmSIGIOHandlerInstalled;
+    Bool wrapped;
+    Bool windowsTouched;
+    int lockRefCount;
+    drm_handle_t hLSAREA;       /* Handle to SAREA containing lock, for mapping */
+    XF86DRILSAREAPtr pLSAREA;   /* Mapped pointer to SAREA containing lock */
+    int *pLockRefCount;
+    int *pLockingContext;
+    xf86_crtc_notify_proc_ptr xf86_crtc_notify;
+} DRIScreenPrivRec, *DRIScreenPrivPtr;
+
+typedef struct _DRIEntPrivRec {
+    int drmFD;
+    Bool drmOpened;
+    Bool sAreaGrabbed;
+    drm_handle_t hLSAREA;
+    XF86DRILSAREAPtr pLSAREA;
+    unsigned long sAreaSize;
+    int lockRefCount;
+    int lockingContext;
+    ScreenPtr resOwner;
+    Bool keepFDOpen;
+    int refCount;
+} DRIEntPrivRec, *DRIEntPrivPtr;
+
+#endif                          /* DRI_STRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dristruct.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxstat.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxstat.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxstat.h	(Revision 52145)
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for statistic gathering interface. \see dmxstat.c */
+
+#ifndef _DMXSTAT_H_
+#define _DMXSTAT_H_
+
+#define DMX_STAT_LENGTH     10  /**< number of events for moving average */
+#define DMX_STAT_INTERVAL 1000  /**< msec between printouts */
+#define DMX_STAT_BINS        3  /**< number of bins */
+#define DMX_STAT_BIN0    10000  /**< us for bin[0] */
+#define DMX_STAT_BINMULT   100  /**< multiplier for next bin[] */
+
+extern int dmxStatInterval;         /**< Only for dmxstat.c and dmxsync.c */
+extern void dmxStatActivate(const char *interval, const char *displays);
+extern DMXStatInfo *dmxStatAlloc(void);
+extern void dmxStatFree(DMXStatInfo *);
+extern void dmxStatInit(void);
+extern void dmxStatSync(DMXScreenInfo * dmxScreen,
+                        struct timeval *stop, struct timeval *start,
+                        unsigned long pending);
+
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxstat.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiproperty.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiproperty.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiproperty.h	(Revision 52145)
@@ -0,0 +1,67 @@
+/*
+ * Copyright ¬© 2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIPROPERTY_H
+#define XIPROPERTY_H 1
+
+int ProcXListDeviceProperties(ClientPtr client);
+int ProcXChangeDeviceProperty(ClientPtr client);
+int ProcXDeleteDeviceProperty(ClientPtr client);
+int ProcXGetDeviceProperty(ClientPtr client);
+
+/* request swapping */
+int SProcXListDeviceProperties(ClientPtr client);
+int SProcXChangeDeviceProperty(ClientPtr client);
+int SProcXDeleteDeviceProperty(ClientPtr client);
+int SProcXGetDeviceProperty(ClientPtr client);
+
+/* reply swapping */
+void SRepXListDeviceProperties(ClientPtr client, int size,
+                               xListDevicePropertiesReply * rep);
+void SRepXGetDeviceProperty(ClientPtr client, int size,
+                            xGetDevicePropertyReply * rep);
+
+/* XI2 request/reply handling  */
+int ProcXIListProperties(ClientPtr client);
+int ProcXIChangeProperty(ClientPtr client);
+int ProcXIDeleteProperty(ClientPtr client);
+int ProcXIGetProperty(ClientPtr client);
+
+int SProcXIListProperties(ClientPtr client);
+int SProcXIChangeProperty(ClientPtr client);
+int SProcXIDeleteProperty(ClientPtr client);
+int SProcXIGetProperty(ClientPtr client);
+
+void SRepXIListProperties(ClientPtr client, int size,
+                          xXIListPropertiesReply * rep);
+void SRepXIGetProperty(ClientPtr client, int size, xXIGetPropertyReply * rep);
+
+void XIResetProperties(void);
+
+#endif                          /* XIPROPERTY_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/xiproperty.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmap.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmap.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmap.h	(Revision 52145)
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ */
+
+/** \file
+ * Interface to XInput event mapping support.  \see dmxmap.c */
+
+#ifndef _DMXMAP_H_
+#define _DMXMAP_H_
+extern void dmxMapInsert(DMXLocalInputInfoPtr dmxLocal,
+                         int remoteEvent, int serverEvent);
+extern void dmxMapClear(DMXLocalInputInfoPtr dmxLocal);
+extern int dmxMapLookup(DMXLocalInputInfoPtr dmxLocal, int remoteEvent);
+#endif

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/dmxmap.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmapstr.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmapstr.h	(Revision 0)
+++ src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmapstr.h	(Revision 52145)
@@ -0,0 +1,115 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PIXMAPSTRUCT_H
+#define PIXMAPSTRUCT_H
+#include "pixmap.h"
+#include "screenint.h"
+#include "regionstr.h"
+#include "privates.h"
+#include "damage.h"
+
+typedef struct _Drawable {
+    unsigned char type;         /* DRAWABLE_<type> */
+    unsigned char class;        /* specific to type */
+    unsigned char depth;
+    unsigned char bitsPerPixel;
+    XID id;                     /* resource id */
+    short x;                    /* window: screen absolute, pixmap: 0 */
+    short y;                    /* window: screen absolute, pixmap: 0 */
+    unsigned short width;
+    unsigned short height;
+    ScreenPtr pScreen;
+    unsigned long serialNumber;
+} DrawableRec;
+
+/*
+ * PIXMAP -- device dependent 
+ */
+
+typedef struct _Pixmap {
+    DrawableRec drawable;
+    PrivateRec *devPrivates;
+    int refcnt;
+    int devKind;                /* This is the pitch of the pixmap, typically width*bpp/8. */
+    DevUnion devPrivate;        /* When !NULL, devPrivate.ptr points to the raw pixel data. */
+#ifdef COMPOSITE
+    short screen_x;
+    short screen_y;
+#endif
+    unsigned usage_hint;        /* see CREATE_PIXMAP_USAGE_* */
+
+    PixmapPtr master_pixmap;    /* pointer to master copy of pixmap for pixmap sharing */
+} PixmapRec;
+
+typedef struct _PixmapDirtyUpdate {
+    PixmapPtr src, slave_dst;
+    int x, y;
+    DamagePtr damage;
+    struct xorg_list ent;
+} PixmapDirtyUpdateRec;
+
+static inline void
+PixmapBox(BoxPtr box, PixmapPtr pixmap)
+{
+    box->x1 = 0;
+    box->x2 = pixmap->drawable.width;
+
+    box->y1 = 0;
+    box->y2 = pixmap->drawable.height;
+}
+
+
+static inline void
+PixmapRegionInit(RegionPtr region, PixmapPtr pixmap)
+{
+    BoxRec box;
+
+    PixmapBox(&box, pixmap);
+    RegionInit(region, &box, 1);
+}
+
+#endif                          /* PIXMAPSTRUCT_H */

Eigenschafts√§nderungen: src/VBox/Additions/x11/x11include/xorg-server-1.16.0/pixmapstr.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
