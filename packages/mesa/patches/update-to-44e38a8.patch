diff --git a/configure.ac b/configure.ac
index 39d1a87..f85c480 100644
--- a/configure.ac
+++ b/configure.ac
@@ -29,7 +29,7 @@ AC_SUBST([OSMESA_VERSION])
 dnl Versions for external dependencies
 LIBDRM_REQUIRED=2.4.24
 LIBDRM_RADEON_REQUIRED=2.4.46
-LIBDRM_INTEL_REQUIRED=2.4.38
+LIBDRM_INTEL_REQUIRED=2.4.49
 LIBDRM_NVVIEUX_REQUIRED=2.4.33
 LIBDRM_NOUVEAU_REQUIRED="2.4.33 libdrm >= 2.4.41"
 LIBDRM_FREEDRENO_REQUIRED=2.4.39
diff --git a/src/gallium/drivers/radeon/radeon_llvm_util.c b/src/gallium/drivers/radeon/radeon_llvm_util.c
index f2b3e13..3ba0acc 100644
--- a/src/gallium/drivers/radeon/radeon_llvm_util.c
+++ b/src/gallium/drivers/radeon/radeon_llvm_util.c
@@ -30,6 +30,7 @@
 #include <llvm-c/BitReader.h>
 #include <llvm-c/Core.h>
 #include <llvm-c/Target.h>
+#include <llvm-c/Transforms/IPO.h>
 #include <llvm-c/Transforms/PassManagerBuilder.h>
 
 LLVMModuleRef radeon_llvm_parse_bitcode(const unsigned char * bitcode,
@@ -59,9 +60,26 @@ static void radeon_llvm_optimize(LLVMModuleRef mod)
 	LLVMTargetDataRef TD = LLVMCreateTargetData(data_layout);
 	LLVMPassManagerBuilderRef builder = LLVMPassManagerBuilderCreate();
 	LLVMPassManagerRef pass_manager = LLVMCreatePassManager();
-	LLVMAddTargetData(TD, pass_manager);
 
-	LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 1000000000);
+	/* Functions calls are not supported yet, so we need to inline
+	 * everything.  The most efficient way to do this is to add
+	 * the always_inline attribute to all non-kernel functions
+	 * and then run the Always Inline pass.  The Always Inline
+	 * pass will automaically inline functions with this attribute
+	 * and does not perform the expensive cost analysis that the normal
+	 * inliner does.
+	 */
+
+	LLVMValueRef fn;
+	for (fn = LLVMGetFirstFunction(mod); fn; fn = LLVMGetNextFunction(fn)) {
+		/* All the non-kernel functions have internal linkage */
+		if (LLVMGetLinkage(fn) == LLVMInternalLinkage) {
+			LLVMAddFunctionAttr(fn, LLVMAlwaysInlineAttribute);
+		}
+	}
+
+	LLVMAddTargetData(TD, pass_manager);
+	LLVMAddAlwaysInlinerPass(pass_manager);
 	LLVMPassManagerBuilderPopulateModulePassManager(builder, pass_manager);
 
 	LLVMRunPassManager(pass_manager, mod);
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index 6c63c75..b4b97ac 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -131,14 +131,14 @@ static const __DRIimageLookupExtension image_lookup_extension = {
    dri_lookup_egl_image
 };
 
-const __DRIdri2LoaderExtension dri2_loader_extension = {
+static const __DRIdri2LoaderExtension dri2_loader_extension = {
    { __DRI_DRI2_LOADER, 3 },
    dri_get_buffers,
    dri_flush_front_buffer,
    dri_get_buffers_with_format,
 };
 
-const __DRIimageLoaderExtension image_loader_extension = {
+static const __DRIimageLoaderExtension image_loader_extension = {
    { __DRI_IMAGE_LOADER, 1 },
    image_get_buffers,
    dri_flush_front_buffer,
diff --git a/src/glsl/glsl_parser_extras.cpp b/src/glsl/glsl_parser_extras.cpp
index d922db9..b37b9ca 100644
--- a/src/glsl/glsl_parser_extras.cpp
+++ b/src/glsl/glsl_parser_extras.cpp
@@ -191,6 +191,8 @@ _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
    this->gs_input_prim_type = GL_POINTS;
    this->gs_input_size = 0;
    this->out_qualifier = new(this) ast_type_qualifier();
+   memset(this->atomic_counter_offsets, 0,
+          sizeof(this->atomic_counter_offsets));
 }
 
 /**
diff --git a/src/glsl/lower_clip_distance.cpp b/src/glsl/lower_clip_distance.cpp
index 682c8fd..04fa6d4 100644
--- a/src/glsl/lower_clip_distance.cpp
+++ b/src/glsl/lower_clip_distance.cpp
@@ -381,6 +381,11 @@ lower_clip_distance_visitor::fix_lhs(ir_assignment *ir)
 ir_visitor_status
 lower_clip_distance_visitor::visit_leave(ir_assignment *ir)
 {
+   /* First invoke the base class visitor.  This causes handle_rvalue() to be
+    * called on ir->rhs and ir->condition.
+    */
+   ir_rvalue_visitor::visit_leave(ir);
+
    if (this->is_clip_distance_vec8(ir->lhs) ||
        this->is_clip_distance_vec8(ir->rhs)) {
       /* LHS or RHS of the assignment is the entire 1D gl_ClipDistance array
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index 44e47f9..0bce77e 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -407,8 +407,10 @@ driCreateContextAttribs(__DRIscreen *screen, int api,
        mesa_api = API_OPENGL_CORE;
     }
 
-    if ((flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE))
-        != 0) {
+    const uint32_t allowed_flags = (__DRI_CTX_FLAG_DEBUG
+                                    | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
+                                    | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS);
+    if (flags & ~allowed_flags) {
 	*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
 	return NULL;
     }
diff --git a/src/mesa/drivers/dri/i965/brw_binding_tables.c b/src/mesa/drivers/dri/i965/brw_binding_tables.c
index 0a322dc..b39bd10 100644
--- a/src/mesa/drivers/dri/i965/brw_binding_tables.c
+++ b/src/mesa/drivers/dri/i965/brw_binding_tables.c
@@ -128,7 +128,7 @@ static void
 brw_gs_upload_binding_table(struct brw_context *brw)
 {
    /* If there's no GS, skip changing anything. */
-   if (!brw->gs.prog_data)
+   if (brw->geometry_program == NULL)
       return;
 
    brw_upload_binding_table(brw, BRW_NEW_GS_BINDING_TABLE, &brw->gs.base);
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 0b22992..3facf78 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -589,9 +589,16 @@ brwCreateContext(gl_api api,
    struct dd_function_table functions;
    struct gl_config visual;
 
-   if (flags & ~(__DRI_CTX_FLAG_DEBUG
-                 | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
-                 | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)) {
+   /* Only allow the __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS flag if the kernel
+    * provides us with context reset notifications.
+    */
+   uint32_t allowed_flags = __DRI_CTX_FLAG_DEBUG
+      | __DRI_CTX_FLAG_FORWARD_COMPATIBLE;
+
+   if (screen->has_context_reset_notification)
+      allowed_flags |= __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS;
+
+   if (flags & ~allowed_flags) {
       *dri_ctx_error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
       return false;
    }
@@ -713,21 +720,6 @@ brwCreateContext(gl_api api,
       }
    }
 
-   /* Notification of GPU resets requires hardware contexts and a kernel new
-    * enough to support DRM_IOCTL_I915_GET_RESET_STATS.
-    */
-   if (notify_reset &&
-       (brw->hw_ctx == NULL
-        || drm_intel_get_reset_stats(brw->hw_ctx, &brw->reset_count, NULL,
-                                     NULL))) {
-      /* This is the wrong error code, but the correct error code (one that
-       * will cause EGL to generate EGL_BAD_MATCH) doesn't seem to exist.
-       */
-      *dri_ctx_error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
-      intelDestroyContext(driContextPriv);
-      return false;
-   }
-
    brw_init_surface_formats(brw);
 
    if (brw->is_g4x || brw->gen >= 5) {
diff --git a/src/mesa/drivers/dri/i965/brw_fs.cpp b/src/mesa/drivers/dri/i965/brw_fs.cpp
index f89390c..25731fb 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs.cpp
@@ -3192,8 +3192,11 @@ fs_visitor::assign_binding_table_offsets()
 {
    uint32_t next_binding_table_offset = 0;
 
+   /* If there are no color regions, we still perform an FB write to a null
+    * renderbuffer, which we place at surface index 0.
+    */
    c->prog_data.binding_table.render_target_start = next_binding_table_offset;
-   next_binding_table_offset += c->key.nr_color_regions;
+   next_binding_table_offset += MAX2(c->key.nr_color_regions, 1);
 
    assign_common_binding_table_offsets(next_binding_table_offset);
 }
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_gs.c b/src/mesa/drivers/dri/i965/brw_vec4_gs.c
index b52d646..018b0b6 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_gs.c
+++ b/src/mesa/drivers/dri/i965/brw_vec4_gs.c
@@ -259,6 +259,13 @@ brw_upload_gs_prog(struct brw_context *brw)
          brw->vue_map_geom_out = brw->vue_map_vs;
          brw->state.dirty.brw |= BRW_NEW_VUE_MAP_GEOM_OUT;
       }
+
+      /* Other state atoms had better not try to access prog_data, since
+       * there's no GS program.
+       */
+      brw->gs.prog_data = NULL;
+      brw->gs.base.prog_data = NULL;
+
       return;
    }
 
diff --git a/src/mesa/drivers/dri/i965/intel_screen.c b/src/mesa/drivers/dri/i965/intel_screen.c
index e44d0f6..6bbd6dd 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.c
+++ b/src/mesa/drivers/dri/i965/intel_screen.c
@@ -899,6 +899,15 @@ static const __DRIextension *intelScreenExtensions[] = {
     &intelImageExtension.base,
     &intelRendererQueryExtension.base,
     &dri2ConfigQueryExtension.base,
+    NULL
+};
+
+static const __DRIextension *intelRobustScreenExtensions[] = {
+    &intelTexBufferExtension.base,
+    &intelFlushExtension.base,
+    &intelImageExtension.base,
+    &intelRendererQueryExtension.base,
+    &dri2ConfigQueryExtension.base,
     &dri2Robustness.base,
     NULL
 };
@@ -1302,7 +1311,22 @@ __DRIconfig **intelInitScreen2(__DRIscreen *psp)
 
    set_max_gl_versions(intelScreen);
 
-   psp->extensions = intelScreenExtensions;
+   /* Notification of GPU resets requires hardware contexts and a kernel new
+    * enough to support DRM_IOCTL_I915_GET_RESET_STATS.  If the ioctl is
+    * supported, calling it with a context of 0 will either generate EPERM or
+    * no error.  If the ioctl is not supported, it always generate EINVAL.
+    * Use this to determine whether to advertise the __DRI2_ROBUSTNESS
+    * extension to the loader.
+    */
+   struct drm_i915_reset_stats stats;
+   memset(&stats, 0, sizeof(stats));
+
+   const int ret = drmIoctl(psp->fd, DRM_IOCTL_I915_GET_RESET_STATS, &stats);
+
+   intelScreen->has_context_reset_notification = (ret != -1 || errno != EINVAL);
+
+   psp->extensions = !intelScreen->has_context_reset_notification
+      ? intelScreenExtensions : intelRobustScreenExtensions;
 
    return (const __DRIconfig**) intel_screen_make_configs(psp);
 }
diff --git a/src/mesa/drivers/dri/i965/intel_screen.h b/src/mesa/drivers/dri/i965/intel_screen.h
index eb9bfca..abaa05f 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.h
+++ b/src/mesa/drivers/dri/i965/intel_screen.h
@@ -50,6 +50,11 @@ struct intel_screen
 
    bool hw_has_swizzling;
 
+   /**
+    * Does the kernel support context reset notifications?
+    */
+   bool has_context_reset_notification;
+
    dri_bufmgr *bufmgr;
 
    /**
diff --git a/src/mesa/drivers/dri/i965/intel_tex_subimage.c b/src/mesa/drivers/dri/i965/intel_tex_subimage.c
index 0384bcc..75aaea3 100644
--- a/src/mesa/drivers/dri/i965/intel_tex_subimage.c
+++ b/src/mesa/drivers/dri/i965/intel_tex_subimage.c
@@ -331,6 +331,12 @@ ytile_copy(
    }
 }
 
+#ifdef __GNUC__
+#define FLATTEN __attribute__((flatten))
+#else
+#define FLATTEN
+#endif
+
 /**
  * Copy texture data from linear to X tile layout, faster.
  *
@@ -340,7 +346,7 @@ ytile_copy(
  *
  * \copydoc tile_copy_fn
  */
-static void
+static FLATTEN void
 xtile_copy_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                   uint32_t y0, uint32_t y1,
                   char *dst, const char *src,
@@ -376,7 +382,7 @@ xtile_copy_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
  *
  * \copydoc tile_copy_fn
  */
-static void
+static FLATTEN void
 ytile_copy_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
                   uint32_t y0, uint32_t y1,
                   char *dst, const char *src,
