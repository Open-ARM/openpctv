diff --git a/Makefile.am b/Makefile.am
index 343bade..361fb51 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -64,7 +64,7 @@ IGNORE_FILES = \
 
 parsers: configure
 	$(MAKE) -C src/glsl glsl_parser.cpp glsl_parser.h glsl_lexer.cpp glcpp/glcpp-lex.c glcpp/glcpp-parse.c glcpp/glcpp-parse.h
-	$(MAKE) -C src/mesa/program lex.yy.c program_parse.tab.c program_parse.tab.h
+	$(MAKE) -C src/mesa program/lex.yy.c program/program_parse.tab.c program/program_parse.tab.h
 
 # Everything for new a Mesa release:
 ARCHIVES = $(PACKAGE_NAME).tar.gz \
diff --git a/VERSION b/VERSION
index 8e92e83..7432bee 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-10.0.0-devel
+10.1.0-devel
diff --git a/configure.ac b/configure.ac
index f94c9b9..fb16338 100644
--- a/configure.ac
+++ b/configure.ac
@@ -14,10 +14,6 @@ AC_CONFIG_MACRO_DIR([m4])
 AC_CANONICAL_SYSTEM
 AM_INIT_AUTOMAKE([foreign])
 
-dnl http://people.gnome.org/~walters/docs/build-api.txt
-dnl We don't support srcdir != builddir.
-echo \#buildapi-variable-no-builddir >/dev/null
-
 # Support silent build rules, requires at least automake-1.11. Disable
 # by either passing --disable-silent-rules to configure or passing V=1
 # to make
@@ -38,9 +34,10 @@ LIBDRM_NVVIEUX_REQUIRED=2.4.33
 LIBDRM_NOUVEAU_REQUIRED="2.4.33 libdrm >= 2.4.41"
 LIBDRM_FREEDRENO_REQUIRED=2.4.39
 DRI2PROTO_REQUIRED=2.6
+DRI3PROTO_REQUIRED=1.0
+PRESENTPROTO_REQUIRED=1.0
+LIBUDEV_REQUIRED=151
 GLPROTO_REQUIRED=1.4.14
-LIBDRM_XORG_REQUIRED=2.4.24
-LIBKMS_XORG_REQUIRED=1.0.0
 
 dnl Check for progs
 AC_PROG_CPP
@@ -539,6 +536,11 @@ AC_ARG_ENABLE([dri],
         [enable DRI modules @<:@default=enabled@:>@])],
     [enable_dri="$enableval"],
     [enable_dri=yes])
+AC_ARG_ENABLE([dri3],
+    [AS_HELP_STRING([--enable-dri3],
+        [enable DRI3 @<:@default=enabled@:>@])],
+    [enable_dri3="$enableval"],
+    [enable_dri3=yes])
 AC_ARG_ENABLE([glx],
     [AS_HELP_STRING([--enable-glx],
         [enable GLX library @<:@default=enabled@:>@])],
@@ -560,11 +562,6 @@ AC_ARG_ENABLE([egl],
     [enable_egl="$enableval"],
     [enable_egl=yes])
 
-AC_ARG_ENABLE([xorg],
-    [AS_HELP_STRING([--enable-xorg],
-        [enable support for X.Org DDX API @<:@default=no@:>@])],
-    [enable_xorg="$enableval"],
-    [enable_xorg=no])
 AC_ARG_ENABLE([xa],
     [AS_HELP_STRING([--enable-xa],
         [enable build of the XA X Acceleration API @<:@default=no@:>@])],
@@ -655,7 +652,6 @@ if test "x$enable_opengl" = xno -a \
         "x$enable_gles1" = xno -a \
         "x$enable_gles2" = xno -a \
         "x$enable_openvg" = xno -a \
-        "x$enable_xorg" = xno -a \
         "x$enable_xa" = xno -a \
         "x$enable_xvmc" = xno -a \
         "x$enable_vdpau" = xno -a \
@@ -711,6 +707,7 @@ fi
 AM_CONDITIONAL(HAVE_DRI_GLX, test "x$enable_glx" = xyes -a \
                                   "x$enable_dri" = xyes)
 AM_CONDITIONAL(HAVE_DRI, test "x$enable_dri" = xyes)
+AM_CONDITIONAL(HAVE_DRI3, test "x$enable_dri3" = xyes)
 
 AC_ARG_ENABLE([shared-glapi],
     [AS_HELP_STRING([--enable-shared-glapi],
@@ -765,6 +762,9 @@ AC_SUBST([MESA_LLVM])
 PKG_CHECK_MODULES([LIBDRM], [libdrm >= $LIBDRM_REQUIRED],
                   [have_libdrm=yes], [have_libdrm=no])
 
+PKG_CHECK_MODULES([LIBUDEV], [libudev >= $LIBUDEV_REQUIRED],
+                  have_libudev=yes, have_libudev=no)
+
 if test "x$enable_dri" = xyes; then
     # DRI must be shared, I think
     if test "$enable_static" = yes; then
@@ -820,11 +820,22 @@ xyesno)
         fi
         PKG_CHECK_MODULES([DRI2PROTO], [dri2proto >= $DRI2PROTO_REQUIRED])
         GL_PC_REQ_PRIV="$GL_PC_REQ_PRIV libdrm >= $LIBDRM_REQUIRED"
+        if test x"$enable_dri3" = xyes; then
+            if test x"$have_libudev" != xyes; then
+              AC_MSG_ERROR([DRI3 requires libudev >= $LIBUDEV_REQUIRED])
+            fi
+            PKG_CHECK_MODULES([DRI3PROTO], [dri3proto >= $DRI3PROTO_REQUIRED])
+            PKG_CHECK_MODULES([PRESENTPROTO], [presentproto >= $PRESENTPROTO_REQUIRED])
+        fi
     fi
 
     # find the DRI deps for libGL
     dri_modules="x11 xext xdamage xfixes x11-xcb xcb-glx >= 1.8.1 xcb-dri2 >= 1.8"
 
+    if test x"$enable_dri3" = xyes; then
+        dri_modules="$dri_modules xcb-dri3 xcb-present xcb-sync xshmfence"
+    fi
+
     # add xf86vidmode if available
     PKG_CHECK_MODULES([XF86VIDMODE], [xxf86vm], HAVE_XF86VIDMODE=yes, HAVE_XF86VIDMODE=no)
     if test "$HAVE_XF86VIDMODE" = yes ; then
@@ -836,6 +847,11 @@ xyesno)
     X11_INCLUDES="$X11_INCLUDES $DRIGL_CFLAGS"
     GL_LIB_DEPS="$DRIGL_LIBS"
 
+    if test x"$enable_dri3$have_libudev" = xyesyes; then
+        X11_INCLUDES="$X11_INCLUDES $LIBUDEV_CFLAGS"
+        GL_LIB_DEPS="$GL_LIB_DEPS $LIBUDEV_LIBS"
+    fi
+
     # need DRM libs, $PTHREAD_LIBS, etc.
     GL_LIB_DEPS="$GL_LIB_DEPS $LIBDRM_LIBS -lm $PTHREAD_LIBS $DLOPEN_LIBS"
     GL_PC_LIB_PRIV="-lm $PTHREAD_LIBS $DLOPEN_LIBS"
@@ -953,6 +969,9 @@ if test "x$enable_dri" = xyes; then
     linux*)
         DEFINES="$DEFINES -DUSE_EXTERNAL_DXTN_LIB=1"
         DEFINES="$DEFINES -DHAVE_ALIAS"
+        if test "x$enable_dri3" = xyes; then
+            DEFINES="$DEFINES -DHAVE_DRI3"
+        fi
 
         case "$host_cpu" in
         x86_64|amd64)
@@ -974,7 +993,7 @@ if test "x$enable_dri" = xyes; then
             ;;
         esac
         ;;
-    freebsd* | dragonfly* | *netbsd* | openbsd*)
+    *freebsd* | dragonfly* | *netbsd* | openbsd*)
         DEFINES="$DEFINES -DHAVE_PTHREAD -DUSE_EXTERNAL_DXTN_LIB=1"
         DEFINES="$DEFINES -DHAVE_ALIAS"
 
@@ -1031,7 +1050,6 @@ if test "x$enable_dri" = xyes; then
     DRI_LIB_DEPS="$DRI_LIB_DEPS $SELINUX_LIBS $LIBDRM_LIBS $EXPAT_LIBS -lm $PTHREAD_LIBS $DLOPEN_LIBS"
     GALLIUM_DRI_LIB_DEPS="$GALLIUM_DRI_LIB_DEPS $SELINUX_LIBS $LIBDRM_LIBS $EXPAT_LIBS -lm $CLOCK_LIB $PTHREAD_LIBS $DLOPEN_LIBS"
 
-    DRI_DRIVER_LDFLAGS="-module -avoid-version -shared -Wl,-Bsymbolic"
 fi
 
 AM_CONDITIONAL(NEED_MEGADRIVER, test -n "$DRI_DIRS")
@@ -1039,7 +1057,6 @@ AM_CONDITIONAL(NEED_LIBMESA, test "x$enable_xlib_glx" = xyes -o \
                                   "x$enable_osmesa" = xyes -o \
                                   -n "$DRI_DIRS")
 AC_SUBST([DRI_LIB_DEPS])
-AC_SUBST([DRI_DRIVER_LDFLAGS])
 AC_SUBST([GALLIUM_DRI_LIB_DEPS])
 
 case $DRI_DIRS in
@@ -1148,8 +1165,9 @@ if test "x$enable_gbm" = xauto; then
     esac
 fi
 if test "x$enable_gbm" = xyes; then
-    PKG_CHECK_MODULES([LIBUDEV], [libudev], [],
-                      AC_MSG_ERROR([gbm needs udev]))
+    if test x"$have_libudev" != xyes; then
+        AC_MSG_ERROR([gbm needs udev])
+    fi
 
     if test "x$enable_dri" = xyes; then
         GBM_BACKEND_DIRS="$GBM_BACKEND_DIRS dri"
@@ -1176,8 +1194,6 @@ if test "x$enable_egl" = xyes; then
 
     if test "$enable_static" != yes; then
         # build egl_glx when libGL is built
-        PKG_CHECK_MODULES([LIBUDEV], [libudev > 150],
-                          [have_libudev=yes],[have_libudev=no])
         if test "$have_libudev" = yes; then
             DEFINES="$DEFINES -DHAVE_LIBUDEV"
         fi
@@ -1240,20 +1256,6 @@ fi
 AM_CONDITIONAL(HAVE_GALLIUM_GBM, test "x$enable_gallium_gbm" = xyes)
 
 dnl
-dnl X.Org DDX configuration
-dnl
-if test "x$enable_xorg" = xyes; then
-    PKG_CHECK_MODULES([XORG], [xorg-server >= 1.6.0])
-    PKG_CHECK_MODULES([LIBDRM_XORG], [libdrm >= $LIBDRM_XORG_REQUIRED])
-    PKG_CHECK_MODULES([LIBKMS_XORG], [libkms >= $LIBKMS_XORG_REQUIRED])
-    PKG_CHECK_MODULES(XEXT, [xextproto >= 7.0.99.1],
-        HAVE_XEXTPROTO_71="yes"; DEFINES="$DEFINES -DHAVE_XEXTPROTO_71",
-        HAVE_XEXTPROTO_71="no")
-    GALLIUM_STATE_TRACKERS_DIRS="xorg $GALLIUM_STATE_TRACKERS_DIRS"
-fi
-AM_CONDITIONAL(HAVE_ST_XORG, test "x$enable_xorg" = xyes)
-
-dnl
 dnl XA configuration
 dnl
 if test "x$enable_xa" = xyes; then
@@ -1491,13 +1493,6 @@ AC_ARG_WITH([egl-driver-dir],
     [EGL_DRIVER_INSTALL_DIR='${libdir}/egl'])
 AC_SUBST([EGL_DRIVER_INSTALL_DIR])
 
-AC_ARG_WITH([xorg-driver-dir],
-    [AS_HELP_STRING([--with-xorg-driver-dir=DIR],
-                    [Default xorg driver directory[[default=${libdir}/xorg/modules/drivers]]])],
-    [XORG_DRIVER_INSTALL_DIR="$withval"],
-    [XORG_DRIVER_INSTALL_DIR="${libdir}/xorg/modules/drivers"])
-AC_SUBST([XORG_DRIVER_INSTALL_DIR])
-
 AC_ARG_WITH([max-width],
     [AS_HELP_STRING([--with-max-width=N],
                     [Maximum framebuffer width (4096)])],
@@ -1527,12 +1522,6 @@ AC_ARG_WITH([llvm-shared-libs],
         [link with LLVM shared libraries @<:@default=disabled@:>@])],
     [],
     [with_llvm_shared_libs=no])
-AS_IF([test x$enable_opencl = xyes],
-    [
-        if test "x$with_llvm_shared_libs" != xyes; then
-            AC_MSG_ERROR([OpenCL requires LLVM shared libraries])
-        fi
-    ])
 
 AC_ARG_WITH([llvm-prefix],
     [AS_HELP_STRING([--with-llvm-prefix],
@@ -1679,18 +1668,15 @@ gallium_check_st() {
     if test "x$enable_dri" = xyes && test "x$2" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $2"
     fi
-    if test "x$enable_xorg" = xyes && test "x$3" != x; then
+    if test "x$enable_xa" = xyes && test "x$3" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $3"
     fi
-    if test "x$enable_xa" = xyes && test "x$4" != x; then
+    if test "x$enable_xvmc" = xyes && test "x$4" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $4"
     fi
-    if test "x$enable_xvmc" = xyes && test "x$5" != x; then
+    if test "x$enable_vdpau" = xyes && test "x$5" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $5"
     fi
-    if test "x$enable_vdpau" = xyes && test "x$6" != x; then
-         GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $6"
-    fi
 }
 
 gallium_require_llvm() {
@@ -1730,9 +1716,8 @@ radeon_llvm_check() {
 }
 
 dnl Gallium drivers
-if test "x$enable_dri" = xyes -o "x$enable_xorg" = xyes -o \
-        "x$enable_xa" = xyes -o "x$enable_xvmc" = xyes -o \
-        "x$enable_vdpau" = xyes; then
+if test "x$enable_dri" = xyes -o "x$enable_xa" = xyes -o \
+        "x$enable_xvmc" = xyes -o "x$enable_vdpau" = xyes; then
     NEED_NONNULL_WINSYS=yes
 fi
 AM_CONDITIONAL(NEED_NONNULL_WINSYS, test "x$NEED_NONNULL_WINSYS" = xyes)
@@ -1745,7 +1730,7 @@ if test "x$with_gallium_drivers" != x; then
         xsvga)
             HAVE_GALLIUM_SVGA=yes
             GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS svga softpipe"
-            gallium_check_st "svga/drm" "dri-vmwgfx" "" "xa-vmwgfx"
+            gallium_check_st "svga/drm" "dri-vmwgfx" "xa-vmwgfx"
             ;;
         xi915)
             HAVE_GALLIUM_I915=yes
@@ -1755,7 +1740,7 @@ if test "x$with_gallium_drivers" != x; then
                 GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS llvmpipe"
             fi
             GALLIUM_WINSYS_DIRS="$GALLIUM_WINSYS_DIRS i915/sw"
-            gallium_check_st "i915/drm" "dri-i915" "xorg-i915"
+            gallium_check_st "i915/drm" "dri-i915"
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xilo)
@@ -1771,7 +1756,7 @@ if test "x$with_gallium_drivers" != x; then
             PKG_CHECK_MODULES([RADEON], [libdrm_radeon >= $LIBDRM_RADEON_REQUIRED])
             gallium_require_llvm "Gallium R300"
             GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS r300"
-            gallium_check_st "radeon/drm" "r300/dri" "" "" "r300/xvmc" "r300/vdpau"
+            gallium_check_st "radeon/drm" "r300/dri" "" "" ""
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xr600)
@@ -1789,7 +1774,7 @@ if test "x$with_gallium_drivers" != x; then
             if test "x$enable_opencl" = xyes; then
                 LLVM_COMPONENTS="${LLVM_COMPONENTS} bitreader asmparser"
             fi
-            gallium_check_st "radeon/drm" "r600/dri" "r600/xorg" "" "r600/xvmc" "r600/vdpau"
+            gallium_check_st "radeon/drm" "r600/dri" "" "r600/xvmc" "r600/vdpau"
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xradeonsi)
@@ -1798,7 +1783,7 @@ if test "x$with_gallium_drivers" != x; then
             gallium_require_drm_loader
             GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS radeonsi"
             radeon_llvm_check
-            gallium_check_st "radeon/drm" "radeonsi/dri" "radeonsi/xorg" "" "" "radeonsi/vdpau" ""
+            gallium_check_st "radeon/drm" "radeonsi/dri" "" "" "radeonsi/vdpau"
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xnouveau)
@@ -1806,7 +1791,7 @@ if test "x$with_gallium_drivers" != x; then
             PKG_CHECK_MODULES([NOUVEAU], [libdrm_nouveau >= $LIBDRM_NOUVEAU_REQUIRED])
             gallium_require_drm_loader
             GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS nouveau"
-            gallium_check_st "nouveau/drm" "dri-nouveau" "xorg-nouveau" "" "xvmc-nouveau" "vdpau-nouveau"
+            gallium_check_st "nouveau/drm" "dri-nouveau" "" "xvmc-nouveau" "vdpau-nouveau"
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xfreedreno)
@@ -1814,7 +1799,7 @@ if test "x$with_gallium_drivers" != x; then
             PKG_CHECK_MODULES([FREEDRENO], [libdrm_freedreno >= $LIBDRM_FREEDRENO_REQUIRED])
             gallium_require_drm_loader
             GALLIUM_DRIVERS_DIRS="$GALLIUM_DRIVERS_DIRS freedreno"
-            gallium_check_st "freedreno/drm" "dri-freedreno" "" "" "" ""
+            gallium_check_st "freedreno/drm" "dri-freedreno" "" "" ""
             DRICOMMON_NEED_LIBDRM=yes
             ;;
         xswrast)
@@ -1828,16 +1813,6 @@ if test "x$with_gallium_drivers" != x; then
             if test "x$enable_dri" = xyes; then
                 GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS dri-swrast"
             fi
-            if test "x$enable_vdpau" = xyes; then
-                GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS vdpau-softpipe"
-            fi
-            if test "x$enable_xvmc" = xyes; then
-                GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS xvmc-softpipe"
-            fi
-            if test "x$enable_vdpau" = xyes -o "x$enable_xvmc" = xyes; then
-                NEED_WINSYS_XLIB=yes
-                GALLIUM_WINSYS_DIRS="$GALLIUM_WINSYS_DIRS sw/xlib"
-            fi
             ;;
         *)
             AC_MSG_ERROR([Unknown Gallium driver: $driver])
@@ -1952,9 +1927,9 @@ AM_CONDITIONAL(HAVE_X11_DRIVER, test "x$enable_xlib_glx" = xyes)
 AM_CONDITIONAL(HAVE_OSMESA, test "x$enable_osmesa" = xyes)
 AM_CONDITIONAL(HAVE_GALLIUM_OSMESA, test "x$enable_gallium_osmesa" = xyes)
 
-AM_CONDITIONAL(HAVE_X86_ASM, echo "$DEFINES" | grep 'X86_ASM' >/dev/null 2>&1)
-AM_CONDITIONAL(HAVE_X86_64_ASM, echo "$DEFINES" | grep 'X86_64_ASM' >/dev/null 2>&1)
-AM_CONDITIONAL(HAVE_SPARC_ASM, echo "$DEFINES" | grep 'SPARC_ASM' >/dev/null 2>&1)
+AM_CONDITIONAL(HAVE_X86_ASM, test "x$asm_arch" = xx86 -o "x$asm_arch" = xx86_64)
+AM_CONDITIONAL(HAVE_X86_64_ASM, test "x$asm_arch" = xx86_64)
+AM_CONDITIONAL(HAVE_SPARC_ASM, test "x$asm_arch" = xsparc)
 
 AC_SUBST([VDPAU_MAJOR], 1)
 AC_SUBST([VDPAU_MINOR], 0)
@@ -1998,8 +1973,6 @@ AC_CONFIG_FILES([Makefile
 		src/gallium/auxiliary/pipe-loader/Makefile
 		src/gallium/drivers/Makefile
 		src/gallium/drivers/freedreno/Makefile
-		src/gallium/drivers/freedreno/a2xx/Makefile
-		src/gallium/drivers/freedreno/a3xx/Makefile
 		src/gallium/drivers/galahad/Makefile
 		src/gallium/drivers/i915/Makefile
 		src/gallium/drivers/identity/Makefile
@@ -2027,7 +2000,6 @@ AC_CONFIG_FILES([Makefile
 		src/gallium/state_trackers/vdpau/Makefile
 		src/gallium/state_trackers/vega/Makefile
 		src/gallium/state_trackers/xa/Makefile
-		src/gallium/state_trackers/xorg/Makefile
 		src/gallium/state_trackers/xvmc/Makefile
 		src/gallium/targets/Makefile
 		src/gallium/targets/dri-freedreno/Makefile
@@ -2044,23 +2016,15 @@ AC_CONFIG_FILES([Makefile
 		src/gallium/targets/pipe-loader/Makefile
 		src/gallium/targets/radeonsi/dri/Makefile
 		src/gallium/targets/radeonsi/vdpau/Makefile
-		src/gallium/targets/radeonsi/xorg/Makefile
 		src/gallium/targets/r300/dri/Makefile
-		src/gallium/targets/r300/vdpau/Makefile
-		src/gallium/targets/r300/xvmc/Makefile
 		src/gallium/targets/r600/dri/Makefile
 		src/gallium/targets/r600/vdpau/Makefile
-		src/gallium/targets/r600/xorg/Makefile
 		src/gallium/targets/r600/xvmc/Makefile
 		src/gallium/targets/libgl-xlib/Makefile
 		src/gallium/targets/vdpau-nouveau/Makefile
-		src/gallium/targets/vdpau-softpipe/Makefile
 		src/gallium/targets/xa-vmwgfx/Makefile
 		src/gallium/targets/xa-vmwgfx/xatracker.pc
-		src/gallium/targets/xorg-i915/Makefile
-		src/gallium/targets/xorg-nouveau/Makefile
 		src/gallium/targets/xvmc-nouveau/Makefile
-		src/gallium/targets/xvmc-softpipe/Makefile
 		src/gallium/tests/trivial/Makefile
 		src/gallium/tests/unit/Makefile
 		src/gallium/winsys/Makefile
@@ -2111,10 +2075,7 @@ AC_CONFIG_FILES([Makefile
 		src/mesa/drivers/osmesa/osmesa.pc
 		src/mesa/drivers/x11/Makefile
 		src/mesa/main/tests/Makefile
-		src/mesa/main/tests/hash_table/Makefile
-		src/mesa/program/Makefile
-		src/mesa/x86-64/Makefile
-		src/mesa/x86/Makefile])
+		src/mesa/main/tests/hash_table/Makefile])
 
 dnl Sort the dirs alphabetically
 GALLIUM_TARGET_DIRS=`echo $GALLIUM_TARGET_DIRS|tr " " "\n"|sort -u|tr "\n" " "`
diff --git a/docs/GL3.txt b/docs/GL3.txt
index ff28ea6..a8cffab 100644
--- a/docs/GL3.txt
+++ b/docs/GL3.txt
@@ -20,45 +20,45 @@ Feature                                               Status
 
 GL 3.0:
 
-GLSL 1.30                                             DONE
+GLSL 1.30                                             DONE (i965, r600, radeonsi)
 glBindFragDataLocation, glGetFragDataLocation         DONE
-Conditional rendering (GL_NV_conditional_render)      DONE (i965, r300, r600, swrast)
-Map buffer subranges (GL_ARB_map_buffer_range)        DONE (i965, r300, r600, swrast)
-Clamping controls (GL_ARB_color_buffer_float)         DONE (i965, r300, r600)
-Float textures, renderbuffers (GL_ARB_texture_float)  DONE (i965, r300, r600)
-GL_EXT_packed_float                                   DONE (i965, r600)
-GL_EXT_texture_shared_exponent                        DONE (i965, r600, swrast)
-Float depth buffers (GL_ARB_depth_buffer_float)       DONE (i965, r600)
-Framebuffer objects (GL_ARB_framebuffer_object)       DONE (i965, r300, r600, swrast)
-Half-float                                            DONE
-Non-normalized Integer texture/framebuffer formats    DONE (i965, r600)
-1D/2D Texture arrays                                  DONE
-Per-buffer blend and masks (GL_EXT_draw_buffers2)     DONE (i965, r600, swrast)
-GL_EXT_texture_compression_rgtc                       DONE (i965, r300, r600, swrast)
-Red and red/green texture formats                     DONE (i965, swrast, gallium)
-Transform feedback (GL_EXT_transform_feedback)        DONE (i965, r600)
-Vertex array objects (GL_APPLE_vertex_array_object)   DONE (i965, r300, r600, swrast)
-sRGB framebuffer format (GL_EXT_framebuffer_sRGB)     DONE (i965, r600)
+Conditional rendering (GL_NV_conditional_render)      DONE (i965, r300, r600, radeonsi, swrast)
+Map buffer subranges (GL_ARB_map_buffer_range)        DONE (i965, r300, r600, radeonsi, swrast)
+Clamping controls (GL_ARB_color_buffer_float)         DONE (i965, r300, r600, radeonsi)
+Float textures, renderbuffers (GL_ARB_texture_float)  DONE (i965, r300, r600, radeonsi)
+GL_EXT_packed_float                                   DONE (i965, r600, radeonsi)
+GL_EXT_texture_shared_exponent                        DONE (i965, r600, radeonsi, swrast)
+Float depth buffers (GL_ARB_depth_buffer_float)       DONE (i965, r600, radeonsi)
+Framebuffer objects (GL_ARB_framebuffer_object)       DONE (i965, r300, r600, radeonsi, swrast)
+Half-float                                            DONE (i965, r300, r600, radeonsi, swrast)
+Non-normalized Integer texture/framebuffer formats    DONE (i965, r600, radeonsi)
+1D/2D Texture arrays                                  DONE (i965, r600, radeonsi)
+Per-buffer blend and masks (GL_EXT_draw_buffers2)     DONE (i965, r600, radeonsi, swrast)
+GL_EXT_texture_compression_rgtc                       DONE (i965, r300, r600, radeonsi, swrast)
+Red and red/green texture formats                     DONE (i965, r300, r600, radeonsi, swrast)
+Transform feedback (GL_EXT_transform_feedback)        DONE (i965, r600, radeonsi)
+Vertex array objects (GL_APPLE_vertex_array_object)   DONE (all drivers)
+sRGB framebuffer format (GL_EXT_framebuffer_sRGB)     DONE (i965, r600, radeonsi)
 glClearBuffer commands                                DONE
 glGetStringi command                                  DONE
 glTexParameterI, glGetTexParameterI commands          DONE
 glVertexAttribI commands                              DONE
-Depth format cube textures                            DONE
+Depth format cube textures                            DONE (i965, r600, radeonsi)
 GLX_ARB_create_context (GLX 1.4 is required)          DONE
 
 
 GL 3.1:
 
-GLSL 1.40                                             DONE (i965, r600)
-Forward compatibile context support/deprecations      DONE (i965, r600)
-Instanced drawing (GL_ARB_draw_instanced)             DONE (i965, gallium, swrast)
-Buffer copying (GL_ARB_copy_buffer)                   DONE (i965, r300, r600, swrast)
-Primitive restart (GL_NV_primitive_restart)           DONE (i965, r600)
-16 vertex texture image units                         DONE
-Texture buffer objs (GL_ARB_texture_buffer_object)    DONE for OpenGL 3.1 contexts (i965, r600)
-Rectangular textures (GL_ARB_texture_rectangle)       DONE (i965, r300, r600, swrast)
-Uniform buffer objs (GL_ARB_uniform_buffer_object)    DONE (i965, r600, swrast)
-Signed normalized textures (GL_EXT_texture_snorm)     DONE (i965, r300, r600)
+GLSL 1.40                                             DONE (i965, r600, radeonsi)
+Forward compatible context support/deprecations       DONE (i965, r600, radeonsi)
+Instanced drawing (GL_ARB_draw_instanced)             DONE (i965, r600, radeonsi, swrast)
+Buffer copying (GL_ARB_copy_buffer)                   DONE (i965, r300, r600, radeonsi, swrast)
+Primitive restart (GL_NV_primitive_restart)           DONE (i965, r300, r600, radeonsi)
+16 vertex texture image units                         DONE (i965, r600, radeonsi)
+Texture buffer objs (GL_ARB_texture_buffer_object)    DONE for OpenGL 3.1 contexts (i965, r600, radeonsi)
+Rectangular textures (GL_ARB_texture_rectangle)       DONE (i965, r300, r600, radeonsi, swrast)
+Uniform buffer objs (GL_ARB_uniform_buffer_object)    DONE (i965, r600, radeonsi, swrast)
+Signed normalized textures (GL_EXT_texture_snorm)     DONE (i965, r300, r600, radeonsi)
 
 
 GL 3.2:
@@ -66,54 +66,54 @@ GL 3.2:
 Core/compatibility profiles                           DONE
 GLSL 1.50                                             DONE (i965)
 Geometry shaders                                      DONE (i965)
-BGRA vertex order (GL_ARB_vertex_array_bgra)          DONE (i965, r300, r600, swrast)
-Base vertex offset(GL_ARB_draw_elements_base_vertex)  DONE (i965, r300, r600, swrast)
-Frag shader coord (GL_ARB_fragment_coord_conventions) DONE (i965, r300, r600, swrast)
-Provoking vertex (GL_ARB_provoking_vertex)            DONE (i965, r300, r600, swrast)
-Seamless cubemaps (GL_ARB_seamless_cube_map)          DONE (i965, r600)
-Multisample textures (GL_ARB_texture_multisample)     DONE (i965, r600)
-Frag depth clamp (GL_ARB_depth_clamp)                 DONE (i965, r600, swrast)
-Fence objects (GL_ARB_sync)                           DONE (i965, r300, r600, swrast)
+BGRA vertex order (GL_ARB_vertex_array_bgra)          DONE (i965, r300, r600, radeonsi, swrast)
+Base vertex offset(GL_ARB_draw_elements_base_vertex)  DONE (i965, r300, r600, radeonsi, swrast)
+Frag shader coord (GL_ARB_fragment_coord_conventions) DONE (i965, r300, r600, radeonsi, swrast)
+Provoking vertex (GL_ARB_provoking_vertex)            DONE (i965, r300, r600, radeonsi, swrast)
+Seamless cubemaps (GL_ARB_seamless_cube_map)          DONE (i965, r600, radeonsi)
+Multisample textures (GL_ARB_texture_multisample)     DONE (i965, r600, radeonsi)
+Frag depth clamp (GL_ARB_depth_clamp)                 DONE (i965, r600, swrast, radeonsi)
+Fence objects (GL_ARB_sync)                           DONE (i965, r300, r600, radeonsi, swrast)
 GLX_ARB_create_context_profile                        DONE
 
 
 GL 3.3:
 
 GLSL 3.30                                             DONE (i965)
-GL_ARB_blend_func_extended                            DONE (i965, r600, softpipe)
-GL_ARB_explicit_attrib_location                       DONE (i915, i965, r300, r600, swrast)
-GL_ARB_occlusion_query2                               DONE (i965, r300, r600, swrast)
-GL_ARB_sampler_objects                                DONE (i965, r300, r600)
-GL_ARB_shader_bit_encoding                            DONE
-GL_ARB_texture_rgb10_a2ui                             DONE (i965, r600)
-GL_ARB_texture_swizzle                                DONE (same as EXT version) (i965, r300, r600, swrast)
-GL_ARB_timer_query                                    DONE (i965, r600)
-GL_ARB_instanced_arrays                               DONE (i965, r300, r600)
-GL_ARB_vertex_type_2_10_10_10_rev                     DONE (i965, r600)
+GL_ARB_blend_func_extended                            DONE (i965, r600, radeonsi, softpipe)
+GL_ARB_explicit_attrib_location                       DONE (i915, i965, r300, r600, radeonsi, swrast)
+GL_ARB_occlusion_query2                               DONE (i965, r300, r600, radeonsi, swrast)
+GL_ARB_sampler_objects                                DONE (i965, r300, r600, radeonsi)
+GL_ARB_shader_bit_encoding                            DONE (i965, r600, radeonsi)
+GL_ARB_texture_rgb10_a2ui                             DONE (i965, r600, radeonsi)
+GL_ARB_texture_swizzle                                DONE (i965, r300, r600, radeonsi, swrast)
+GL_ARB_timer_query                                    DONE (i965, r600, radeonsi)
+GL_ARB_instanced_arrays                               DONE (i965, r300, r600, radeonsi)
+GL_ARB_vertex_type_2_10_10_10_rev                     DONE (i965, r600, radeonsi)
 
 
 GL 4.0:
 
 GLSL 4.0                                             not started
 GL_ARB_texture_query_lod                             DONE (i965)
-GL_ARB_draw_buffers_blend                            DONE (i965, r600, softpipe)
+GL_ARB_draw_buffers_blend                            DONE (i965, r600, radeonsi, softpipe)
 GL_ARB_draw_indirect                                 started (Christoph)
 GL_ARB_gpu_shader5                                   started
 GL_ARB_gpu_shader_fp64                               not started
-GL_ARB_sample_shading                                started (Anuj)
+GL_ARB_sample_shading                                DONE (i965)
 GL_ARB_shader_subroutine                             not started
 GL_ARB_tessellation_shader                           not started
-GL_ARB_texture_buffer_object_rgb32                   DONE (i965, softpipe)
-GL_ARB_texture_cube_map_array                        DONE (i965, softpipe)
+GL_ARB_texture_buffer_object_rgb32                   DONE (i965, r600, radeonsi, softpipe)
+GL_ARB_texture_cube_map_array                        DONE (i965, r600, softpipe)
 GL_ARB_texture_gather                                DONE (i965)
-GL_ARB_transform_feedback2                           DONE
-GL_ARB_transform_feedback3                           DONE
+GL_ARB_transform_feedback2                           DONE (i965, r600, radeonsi)
+GL_ARB_transform_feedback3                           DONE (i965, r600, radeonsi)
 
 
 GL 4.1:
 
 GLSL 4.1                                             not started
-GL_ARB_ES2_compatibility                             DONE (i965, r300, r600)
+GL_ARB_ES2_compatibility                             DONE (i965, r300, r600, radeonsi)
 GL_ARB_get_program_binary                            DONE (0 binary formats)
 GL_ARB_separate_shader_objects                       some infrastructure done
 GL_ARB_shader_precision                              not started
@@ -126,56 +126,56 @@ GL 4.2:
 GLSL 4.2                                             not started
 GL_ARB_texture_compression_bptc                      not started
 GL_ARB_compressed_texture_pixel_storage              not started
-GL_ARB_shader_atomic_counters                        in progress (Curro)
-GL_ARB_texture_storage                               DONE (i965, r300, r600, swrast, gallium)
-GL_ARB_transform_feedback_instanced                  DONE
+GL_ARB_shader_atomic_counters                        DONE (i965)
+GL_ARB_texture_storage                               DONE (all drivers)
+GL_ARB_transform_feedback_instanced                  DONE (i965, r600, radeonsi)
 GL_ARB_base_instance                                 DONE (i965, nv50, nvc0, r600, radeonsi)
 GL_ARB_shader_image_load_store                       not started
-GL_ARB_conservative_depth                            DONE (i965, softpipe)
-GL_ARB_shading_language_420pack                      DONE (i965, gallium)
-GL_ARB_internalformat_query                          DONE (i965, gallium)
+GL_ARB_conservative_depth                            DONE (all drivers that support GLSL 1.30)
+GL_ARB_shading_language_420pack                      DONE (all drivers that support GLSL 1.30)
+GL_ARB_internalformat_query                          DONE (i965, r300, r600, radeonsi)
 GL_ARB_map_buffer_alignment                          DONE (r300, r600, radeonsi)
 
 
 GL 4.3:
 
 GLSL 4.3                                             not started
-ARB_arrays_of_arrays                                 not started
-ARB_ES3_compatibility                                DONE (i965)
-ARB_clear_buffer_object                              not started
-ARB_compute_shader                                   started (gallium)
-ARB_copy_image                                       not started
-KHR_debug                                            DONE
-ARB_explicit_uniform_location                        not started
-ARB_fragment_layer_viewport                          not started
-ARB_framebuffer_no_attachments                       not started
-ARB_internalformat_query2                            not started
-ARB_invalidate_subdata                               not started
-ARB_multi_draw_indirect                              not started
-ARB_program_interface_query                          not started
-ARB_robust_buffer_access_behavior                    not started
-ARB_shader_image_size                                not started
-ARB_shader_storage_buffer_object                     not started
-ARB_stencil_texturing                                not started
-ARB_texture_buffer_range                             DONE (nv50, nvc0, i965)
-ARB_texture_query_levels                             DONE (i965)
-ARB_texture_storage_multisample                      DONE (i965)
-ARB_texture_view                                     not started
-ARB_vertex_attrib_binding                            started (Fredrik)
+GL_ARB_arrays_of_arrays                              not started
+GL_ARB_ES3_compatibility                             DONE (i965)
+GL_ARB_clear_buffer_object                           not started
+GL_ARB_compute_shader                                not started
+GL_ARB_copy_image                                    not started
+GL_KHR_debug                                         DONE (all drivers)
+GL_ARB_explicit_uniform_location                     not started
+GL_ARB_fragment_layer_viewport                       not started
+GL_ARB_framebuffer_no_attachments                    not started
+GL_ARB_internalformat_query2                         not started
+GL_ARB_invalidate_subdata                            DONE (all drivers)
+GL_ARB_multi_draw_indirect                           not started
+GL_ARB_program_interface_query                       not started
+GL_ARB_robust_buffer_access_behavior                 not started
+GL_ARB_shader_image_size                             not started
+GL_ARB_shader_storage_buffer_object                  not started
+GL_ARB_stencil_texturing                             not started
+GL_ARB_texture_buffer_range                          DONE (nv50, nvc0, i965, r600, radeonsi)
+GL_ARB_texture_query_levels                          DONE (i965)
+GL_ARB_texture_storage_multisample                   DONE (all drivers that support GL_ARB_texture_multisample)
+GL_ARB_texture_view                                  not started
+GL_ARB_vertex_attrib_binding                         DONE (all drivers)
 
 
 GL 4.4:
 
 GLSL 4.4                                             not started
-MAX_VERTEX_ATTRIB_STRIDE                             not started
-ARB_buffer_storage                                   not started
-ARB_clear_texture                                    not started
-ARB_enhanced_layouts                                 not started
-ARB_multi_bind                                       not started
-ARB_query_buffer_object                              not started
-ARB_texture_mirror_clamp_to_edge                     DONE (i965, nv30, nv50, nvc0, r300, r600, radeonsi, swrast)
-ARB_texture_stencil8                                 not started
-ARB_vertex_type_10f_11f_11f_rev                      not started
+GL_MAX_VERTEX_ATTRIB_STRIDE                          not started
+GL_ARB_buffer_storage                                not started
+GL_ARB_clear_texture                                 not started
+GL_ARB_enhanced_layouts                              not started
+GL_ARB_multi_bind                                    not started
+GL_ARB_query_buffer_object                           not started
+GL_ARB_texture_mirror_clamp_to_edge                  DONE (i965, nv30, nv50, nvc0, r300, r600, radeonsi, swrast)
+GL_ARB_texture_stencil8                              not started
+GL_ARB_vertex_type_10f_11f_11f_rev                   DONE (i965, r600)
 
 
 More info about these features and the work involved can be found at
diff --git a/docs/index.html b/docs/index.html
index 9907022..dd407e3 100644
--- a/docs/index.html
+++ b/docs/index.html
@@ -16,6 +16,12 @@
 
 <h1>News</h1>
 
+<h2>November 13, 2013</h2>
+<p>
+<a href="relnotes/9.2.3.html">Mesa 9.2.3</a> is released.
+This is a bug fix release.
+</p>
+
 <h2>October 18, 2013</h2>
 <p>
 <a href="relnotes/9.2.2.html">Mesa 9.2.2</a> is released.
diff --git a/docs/relnotes.html b/docs/relnotes.html
index 35cef80..13de49a 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -21,7 +21,9 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <ul>
+<li><a href="relnotes/10.1.html">10.1 release notes</a>
 <li><a href="relnotes/10.0.html">10.0 release notes</a>
+<li><a href="relnotes/9.2.3.html">9.2.3 release notes</a>
 <li><a href="relnotes/9.2.2.html">9.2.2 release notes</a>
 <li><a href="relnotes/9.2.1.html">9.2.1 release notes</a>
 <li><a href="relnotes/9.2.html">9.2 release notes</a>
diff --git a/docs/relnotes/10.0.html b/docs/relnotes/10.0.html
index 5ff5339..eabe77f 100644
--- a/docs/relnotes/10.0.html
+++ b/docs/relnotes/10.0.html
@@ -50,6 +50,10 @@ Note: some of the new features are only available with certain drivers.
 <li>GL_ARB_texture_query_levels on i965.</li>
 <li>GL_ARB_texture_mirror_clamp_to_edge.</li>
 <li>GL_ARB_transform_feedback2, GL_ARB_transform_feedback3, and GL_ARB_transform_feedback_instanced on i965/Gen7 (with appropriate kernel support).</li>
+<li>GL_ARB_sample_shading on i965.</li>
+<li>GL_ARB_shader_atomic_counters on i965.</li>
+<li>GL_ARB_vertex_attrib_binding</li>
+<li>GL_ARB_vertex_type_10f_11f_11f_rev on i965 and r600g</li>
 <li>GL_KHR_debug</li>
 </ul>
 
diff --git a/docs/relnotes/10.1.html b/docs/relnotes/10.1.html
new file mode 100644
index 0000000..55d810f
--- /dev/null
+++ b/docs/relnotes/10.1.html
@@ -0,0 +1,60 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 10.1 Release Notes / TBD</h1>
+
+<p>
+Mesa 10.1 is a new development release.
+People who are concerned with stability and reliability should stick
+with a previous release or wait for Mesa 10.1.1.
+</p>
+<p>
+Mesa 10.1 implements the OpenGL 3.3 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.3.  OpenGL
+3.3 is <strong>only</strong> available if requested at context creation
+because compatibility contexts are not supported.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+TBD.
+</pre>
+
+
+<h2>New features</h2>
+
+<p>
+Note: some of the new features are only available with certain drivers.
+</p>
+
+<ul>
+</ul>
+
+
+<h2>Bug fixes</h2>
+
+TBD.
+
+<h2>Changes</h2>
+
+TBD.
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/9.2.3.html b/docs/relnotes/9.2.3.html
new file mode 100644
index 0000000..79b8fb2
--- /dev/null
+++ b/docs/relnotes/9.2.3.html
@@ -0,0 +1,115 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 9.2.3 Release Notes / (November 13, 2013)</h1>
+
+<p>
+Mesa 9.2.3 is a bug fix release which fixes bugs found since the 9.2.2 release.
+</p>
+<p>
+Mesa 9.2 implements the OpenGL 3.1 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.1.  OpenGL
+3.1 is <strong>only</strong> available if requested at context creation
+because GL_ARB_compatibility is not supported.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+66e9a33a414f801e1c33398bf627d56b  MesaLib-9.2.3.tar.gz
+f56b6beb556e4b9072814419f7c554e3  MesaLib-9.2.3.tar.bz2
+ed852dab576faac237ac4298bf55d0a1  MesaLib-9.2.3.zip
+</pre>
+
+
+<h2>New features</h2>
+<p>None</p>
+
+<h2>Bug fixes</h2>
+
+<p>This list is likely incomplete.</p>
+
+<ul>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=69437">Bug 69437</a> - Composite Bypass no longer works</li>
+
+</ul>
+
+<h2>Changes</h2>
+
+<p>The full set of changes can be viewed by using the following GIT command:</p>
+
+<pre>
+  git log mesa-9.2.2..mesa-9.2.3
+</pre>
+
+<p>Brian Paul (2):</p>
+<ul>
+  <li>st/mesa: move out of memory check in st_draw_vbo()</li>
+  <li>osmesa: fix broken triangle/line drawing when using float color buffer</li>
+</ul>
+
+<p>Carl Worth (7):</p>
+<ul>
+  <li>Remove error when calling glGenQueries/glDeleteQueries while a query is active</li>
+  <li>Bump version to 9.2.3</li>
+</ul>
+
+<p>Daniel Vetter (1):</p>
+<ul>
+  <li>i965: CS writes/reads should use I915_GEM_INSTRUCTION</li>
+</ul>
+
+<p>Eric Anholt (1):</p>
+<ul>
+  <li>i965: Fix texture buffer rendering after a whole buffer replacement.</li>
+</ul>
+
+<p>Kenneth Graunke (6):</p>
+<ul>
+  <li>i965: Emit post-sync non-zero flush before 3DSTATE_GS_SVB_INDEX.</li>
+  <li>i965: Emit post-sync non-zero flush before 3DSTATE_DRAWING_RECTANGLE.</li>
+  <li>i965: Also guard 3DSTATE_DRAWING_RECTANGLE with a flush in blorp.</li>
+  <li>i965: Move post-sync non-zero flush for 3DSTATE_MULTISAMPLE.</li>
+  <li>i965: Also emit HIER_DEPTH and STENCIL packets when disabling depth.</li>
+  <li>i965: Also emit HiZ and Stencil packets when disabling depth on Gen6.</li>
+</ul>
+
+<p>Kristian Høgsberg (1):</p>
+<ul>
+  <li>wayland: Don't rely on static variable for identifying wl_drm buffers</li>
+</ul>
+
+<p>Marek Olšák (1):</p>
+<ul>
+  <li>radeonsi: fix blitting the last 2 mipmap levels of compressed textures</li>
+</ul>
+
+<p>Petr Sebor (1):</p>
+<ul>
+  <li>meta: enable vertex attributes in the context of the newly created array object</li>
+</ul>
+
+<p>Scott Graham (1):</p>
+<ul>
+  <li>mesa: fixes for MSVC 2013</li>
+</ul>
+
+</div>
+</body>
+</html>
diff --git a/docs/specs/MESA_query_renderer.spec b/docs/specs/MESA_query_renderer.spec
new file mode 100644
index 0000000..bf09756
--- /dev/null
+++ b/docs/specs/MESA_query_renderer.spec
@@ -0,0 +1,405 @@
+Name
+
+    MESA_query_renderer
+
+Name Strings
+
+    GLX_MESA_query_renderer
+
+Contact
+
+    Ian Romanick <ian.d.romanick@intel.com>
+
+IP Status
+
+    No known IP claims.
+
+Status
+
+    Incomplete.  DO NOT SHIP.
+
+Version
+
+    Version 6, 7-November-2013
+
+Number
+
+    TBD.
+
+Dependencies
+
+    GLX 1.4 is required.
+
+    GLX_ARB_create_context and GLX_ARB_create_context_profile are required.
+
+    This extension interacts with GLX_EXT_create_context_es2_profile and
+    GLX_EXT_create_context_es_profile.
+
+Overview
+
+    In many situations, applications want to detect characteristics of a
+    rendering device before creating a context for that device.  Information
+    gathered at this stage may guide choices the application makes about
+    color depth, number of samples per-pixel, texture quality, and so on.
+    In addition, versions of supported APIs and implementation API
+    preference may also guide start-up decisions made by the application.
+    For example, one implementation may prefer vertex data be supplied using
+    methods only available in a compatibility profile, but another
+    implementation may only support the desired version in a core profile.
+
+    There are also cases where more than one renderer may be available per
+    display.  For example, there is typically a hardware implementation and
+    a software based implementation.  There are cases where an application
+    may want to pick one over the other.  One such situation is when the
+    software implementation supports more features than the hardware
+    implementation.  Another situation is when a particular version of the
+    hardware implementation is blacklisted due to known bugs.
+
+    This extension provides a mechanism for the application to query all of
+    the available renderers for a particular display and screen.  In
+    addition, this extension provides a mechanism for applications to create
+    contexts with respect to a specific renderer.
+
+New Procedures and Functions
+
+    Bool glXQueryRendererIntegerMESA(Display *dpy, int screen,
+                                     int renderer, int attribute,
+                                     unsigned int *value);
+    Bool glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *value);
+
+    const char *glXQueryRendererStringMESA(Display *dpy, int screen,
+                                           int renderer, int attribute);
+
+    const char *glXQueryCurrentRendererStringMESA(int attribute);
+
+New Tokens
+
+    Accepted as an <attribute> in glXQueryRendererIntegerMESA and
+    glXQueryCurrentRendererIntegerMESA:
+
+        GLX_RENDERER_VENDOR_ID_MESA                      0x8183
+        GLX_RENDERER_DEVICE_ID_MESA                      0x8184
+        GLX_RENDERER_VERSION_MESA                        0x8185
+        GLX_RENDERER_ACCELERATED_MESA                    0x8186
+        GLX_RENDERER_VIDEO_MEMORY_MESA                   0x8187
+        GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA    0x8188
+        GLX_RENDERER_PREFERRED_PROFILE_MESA              0x8189
+        GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA    0x818A
+        GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA    0x818B
+        GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA      0x818C
+        GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA     0x818D
+
+    Accepted as an <attribute> in glXQueryRendererStringMESA and
+    glXQueryCurrentRendererStringMESA:
+
+        GLX_RENDERER_VENDOR_ID_MESA
+        GLX_RENDERER_DEVICE_ID_MESA
+
+    Accepted as an attribute name in <*attrib_list> in
+    glXCreateContextAttribsARB:
+
+        GLX_RENDERER_ID_MESA                             0x818E
+
+Additions to the OpenGL / WGL Specifications
+
+    None. This specification is written for GLX.
+
+Additions to the GLX 1.4 Specification
+
+    [Add the following to Section X.Y.Z of the GLX Specification]
+
+    To obtain information about the available renderers for a particular
+    display and screen,
+
+        Bool glXQueryRendererIntegerMESA(Display *dpy, int screen, int renderer,
+                                         int attribute, unsigned int *value);
+
+    can be used.  The value for <attribute> will be returned in one or more
+    integers specified by <value>.  The values, data sizes, and descriptions
+    of each renderer attribute are listed in the table below.
+
+    GLX renderer attribute         number     description
+                                  of values
+    ----------------------        ---------   -----------
+    GLX_RENDERER_VENDOR_ID_MESA   1           PCI ID of the device vendor
+    GLX_RENDERER_DEVICE_ID_MESA   1           PCI ID of the device
+    GLX_RENDERER_VERSION_MESA     3           Major, minor, and patch level of
+                                              the renderer implementation
+    GLX_RENDERER_ACCELERATED_MESA 1           Boolean indicating whether or
+                                              not the renderer is hardware
+                                              accelerated
+    GLX_RENDERER_VIDEO_MEMORY_MESA 1          Number of megabytes of video
+                                              memory available to the renderer
+    GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA
+                                  1           Boolean indicating whether or
+                                              not the renderer uses a unified
+                                              memory architecture or has
+                                              separate "on-card" and GART
+                                              memory.
+    GLX_RENDERER_PREFERRED_PROFILE_MESA
+                                  1           Bitmask of the preferred context
+                                              profile for this renderer.  This
+                                              value is suitable to be supplied
+                                              with the
+                                              GLX_CONTEXT_PROFILE_MASK_ARB
+                                              attribute to
+                                              glXCreateContextAttribsARB
+    GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA
+                                  2           Maximum core profile major and
+                                              minor version supported by the
+                                              renderer
+    GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA
+                                  2           Maximum compatibility profile
+                                              major and minor version
+                                              supported by the renderer
+    GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA
+                                  2           Maximum OpenGL ES 1.x
+                                              major and minor version
+                                              supported by the renderer
+    GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA
+                                  2           Maximum OpenGL ES 2.x or 3.x
+                                              major and minor version
+                                              supported by the renderer
+
+    In the table, boolean attributes will have either the value 0 or 1.
+
+    GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA,
+    GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA,
+    GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA, and
+    GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA each return <0, 0> in
+    *value if no version of that profile is supported.
+
+    GLX_RENDERER_VENDOR_ID_MESA and GLX_RENDERER_DEVICE_ID_MESA may return
+    0xFFFFFFFF if the device does not have a PCI ID (because it is not a PCI
+    device) or if the PCI ID is not available.  In this case the application
+    should rely on the string query instead.
+
+    If <attribute> is not a recognized value, False is returned, but no GLX
+    error is generated.  Otherwise, True is returned.
+
+    String versions of some attributes may also be queried using
+
+        const char *glXQueryRendererStringMESA(Display *dpy, int screen,
+                                               int renderer, int attribute);
+
+    The value for <attribute> will be returned in one or more
+    integers specified by <value>.  The values, data sizes, and descriptions
+    of each renderer attribute are listed in the table below.
+
+    GLX renderer attribute        description
+    ----------------------        -----------
+    GLX_RENDERER_VENDOR_ID_MESA   Name of the renderer provider.  This may
+                                  differ from the vendor name of the
+                                  underlying hardware.
+    GLX_RENDERER_DEVICE_ID_MESA   Name of the renderer.  This may differ from
+                                  the name of the underlying hardware (e.g.,
+                                  for a software renderer).
+
+    If <attribute> is not a recognized value, NULL is returned, but no GLX
+    error is generated.
+
+    The string returned for GLX_RENDERER_VENDOR_ID_MESA will have the same
+    format as the string that would be returned by glGetString of GL_VENDOR.
+    It may, however, have a different value.
+
+    The string returned for GLX_RENDERER_DEVICE_ID_MESA will have the same
+    format as the string that would be returned by glGetString of GL_RENDERER.
+    It may, however, have a different value.
+
+
+    [Add to section section 3.3.7 "Rendering Contexts"]
+
+    The attribute name GLX_RENDERER_ID_MESA specified the index of the render
+    against which the context should be created.  The default value of
+    GLX_RENDER_ID_MESA is 0.
+
+
+    [Add to list of errors for glXCreateContextAttribsARB in section section
+    3.3.7 "Rendering Contexts"]
+
+      * If the value of GLX_RENDERER_ID_MESA specifies a non-existent
+        renderer, BadMatch is generated.
+
+Dependencies on GLX_EXT_create_context_es_profile and
+GLX_EXT_create_context_es2_profile
+
+    If neither extension is supported, remove all mention of
+    GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA from the spec.
+
+    If GLX_EXT_create_context_es_profile is not supported, remove all mention of
+    GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA from the spec.
+
+Issues
+
+    1) How should the difference between on-card and GART memory be exposed?
+
+        UNRESOLVED.
+
+    2) How should memory limitations of unified memory architecture (UMA)
+    systems be exposed?
+
+        UNRESOLVED.  Some hardware has different per-process and global
+        limits for memory that can be accessed within a single draw call.
+
+    3) How should the renderer's API preference be advertised?
+
+        UNRESOLVED.  The common case for desktop renderers is to prefer
+        either core or compatibility.  However, some renderers may actually
+        prefer an ES context.  This leaves the application in a tough spot
+        if it can only support core or compatibility and the renderer says it
+        wants ES.
+
+    4) Should OpenGL ES 2.0 and OpenGL ES 3.0 be treated separately?
+
+        RESOLVED.  No.  OpenGL ES 3.0 is backwards compatible with OpenGL ES
+        2.0.  Applications can detect OpenGL ES 3.0 support by querying
+        GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA.
+
+    5) How can applications tell the difference between different hardware
+    renderers for the same device?  For example, whether the renderer is the
+    open-source driver or the closed-source driver.
+
+        RESOLVED.  Assuming this extension is ever implemented outside Mesa,
+        applications can query GLX_RENDERER_VENDOR_ID_MESA from
+        glXQueryRendererStringMESA.  This will almost certainly return
+        different strings for open-source and closed-source drivers.
+
+    6) What is the value of GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA for
+    software renderers?
+
+        UNRESOLVED.  Video (display) memory and texture memory is not unified
+        for software implementations, so it seems reasonable for this to be
+        False.
+
+    7) How does an application determine the number of available renderers?
+
+        UNRESOLVED.
+
+    8) What happens if a fbconfig is used to create context on a renderer
+    that cannot support it?  For example, if a multisampled config is used
+    with a software renderer that does not support multisampling.
+
+        RESOLVED.  The language for glXCreateContextAttribsARB already covers
+        this case.  Context creation will fail, and BadMatch is generated.
+
+    9) In addition to being able to query the supported versions, should
+    applications also be able to query the supported extensions?
+
+        RESOLVED.  No.  Desktop OpenGL core profiles and OpenGL ES 3.0 have
+        moved away from the monolithic string returned by glGetString of
+        GL_EXTENSIONS.  Providing the newer indexed query would require adding
+        a lot of extra infrastructure, and it would probably provide little
+        benefit to applications.
+
+    10) What combination of values for GLX_RENDERER_PREFERRED_PROFILE_MESA,
+    GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA, and
+    GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA should be returned
+    for a renderer that only supports OpenGL 3.1 without the
+    GL_ARB_compatibility extension?
+
+        RESOLVED.  The renderer will return GLX_CONTEXT_CORE_PROFILE_BIT_ARB
+        for GLX_RENDERER_PREFERRED_PROFILE_MESA.
+
+        Further, the renderer will return <3,0> for
+        GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA because OpenGL
+        3.1 without GL_ARB_compatibility is not backwards compatible with
+        previous versions of OpenGL.  The render will return <3,1> for
+        GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA indicating that support
+        for OpenGL 3.1 is available.
+
+        Even though there is no OpenGL 3.1 core profile, the values
+        returned for GLX_RENDERER_PREFERRED_PROFILE_MESA and
+        GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA can be supplied
+        with the GLX_CONTEXT_PROFILE_MASK_ARB and
+        GLX_CONTEXT_{MAJOR,MINOR}_VERSION_ARB attributes of
+        glXCreateContextAttribsARB without error.  If the requested
+        OpenGL version is less than 3.2, the
+        GLX_CONTEXT_PROFILE_MASK_ARB attribute is ignored by
+        glXCreateContextAttribsARB.
+
+    11) How can application learn about multi-GPU (e.g., SLI, CrossFireX,
+    etc.) configurations?
+
+        UNRESOLVED.  Based on ISV feedback, this is important information to
+        provide to the application.  Given the variety of possible hardware
+        configurations (e.g., Hybrid CrossFireX) and different rendering
+        modes (e.g., split-frame rendering vs. alternate-frame rendering),
+        it's not clear how this information can be communicated.
+
+        It is likely that this will be left to a layered extension.
+
+    12) Should capability queries similar to those in
+    GL_ARB_internalformat_query or GL_ARB_internalformat_query2 be added?
+
+        RESOLVED.  No.  With the possible exception of the texture size
+        queries, it seems unlikely that applications would ever use this
+        information before creating a context.
+
+    13) Existing GL extensions (e.g., GL_ATI_meminfo and
+    GL_NVX_gpu_memory_info) allow easy queries after context creation.  With
+    this extension it is a bit of a pain for a portable application to query
+    the information after context creation.
+
+        RESOLVED.  Add versions of the queries that implicitly take the
+        display, screen, and renderer from the currently bound context.
+
+    14) Why not make the queries from issue #13 GL functions (instead of GLX)?
+
+        RESOLVED.  It is fairly compelling for the post-creation queries to
+        just use glGetInteger and glGetString.  However, the GL enums and
+        the GLX enums would have different names and would almost certainly
+        have different values.  It seems like this would cause more problems
+        than it would solve.
+
+    15) Should the string queries be required to return the same values as
+    glGetString(GL_VENDOR) and glGetString(GL_RENDERER)?
+
+        UNRESOLVED.  This may be useful for applications that already do
+        device detection based on these strings.
+
+    16) What type should the value parameter of glXQueryRendererIntegerMESA
+        and glXQueryCurrentRendererIntegerMESA be?
+
+        UNRESOLVED.  Other similar GLX query functions just use int or
+        unsigned int, so that's what this extension uses for now.  However,
+        an expeclitly sized value, such as uint32_t or uint64_t, seems
+        preferable.
+
+    17) What about SoCs and other systems that don't have PCI?
+
+        RESOLVED. The GLX_RENDERER_VENDOR_ID_MESA and
+        GLX_RENDERER_DEVICE_ID_MESA integer queries may return 0xFFFFFFFF if a
+        PCI ID either does not exist or is not available.  Implementations
+        should make every attempt to return as much information as is
+        possible.  For example, if the implementation is running on a non-PCI
+        SoC with a Qualcomm GPU, GLX_RENDERER_VENDOR_ID_MESA should return
+        0x168C, but GLX_RENDERER_DEVICE_ID_MESA will return 0x0000.
+
+Revision History
+
+    Version 1, 2012/08/27 - Initial version
+
+    Version 2, 2012/09/04 - Specify behavior of implementations that
+                            do not support certain profiles.
+                            Change wording of issue #8 to be more
+                            clear.
+                            Make some wording changes to issue #10 to
+                            clarify the resolution a bit.
+
+    Version 3, 2012/09/23 - Add issue #11 regarding multi-GPU systems.
+
+    Version 4, 2013/02/01 - Add issue #12 regarding texture / renderbuffer
+                            format queries.
+
+    Version 5, 2013/02/14 - Add issues #13 and #14 regarding simpler queires
+                            after the context is created and made current.
+                            Add issue #15 regarding the string query.
+                            Add issue #16 regarding the value type returned
+                            by the Integer functions.
+
+    Version 6, 2013/10/25 - Fix a typo.  Update the list of functions to
+                            which the new enums can be passed.  The "Current"
+                            versions were previously missing.
+
+    Version 7, 2013/11/07 - Fix a couple more typos.  Add issue #17 regarding
+                            the PCI queries on systems that don't have PCI.
diff --git a/include/GL/gl.h b/include/GL/gl.h
index 6b94e3f..b484b96 100644
--- a/include/GL/gl.h
+++ b/include/GL/gl.h
@@ -33,25 +33,14 @@
 
 
 /**********************************************************************
- * Begin system-specific stuff. Do not do any of this when building
- * for SciTech SNAP, as this is all done before this header file is
- * included. 
+ * Begin system-specific stuff.
  */
-#if !defined(__SCITECH_SNAP__)
-
-#if defined(__BEOS__)
-#include <stdlib.h>     /* to get some BeOS-isms */
-#endif
-
-#if !defined(OPENSTEP) && (defined(NeXT) || defined(NeXT_PDO))
-#define OPENSTEP
-#endif
 
 #if defined(_WIN32) && !defined(__WIN32__) && !defined(__CYGWIN__)
 #define __WIN32__
 #endif
 
-#if !defined(OPENSTEP) && (defined(__WIN32__) && !defined(__CYGWIN__))
+#if defined(__WIN32__) && !defined(__CYGWIN__)
 #  if (defined(_MSC_VER) || defined(__MINGW32__)) && defined(BUILD_GL32) /* tag specify we're building mesa as a DLL */
 #    define GLAPI __declspec(dllexport)
 #  elif (defined(_MSC_VER) || defined(__MINGW32__)) && defined(_DLL) /* tag specifying we're building for DLL runtime support */
@@ -72,10 +61,6 @@
 #  define GLAPIENTRY
 #endif /* WIN32 && !CYGWIN */
 
-#if (defined(__BEOS__) && defined(__POWERPC__)) || defined(__QUICKDRAW__)
-#  define PRAGMA_EXPORT_SUPPORTED		1
-#endif
-
 /*
  * WINDOWS: Include windows.h here to define APIENTRY.
  * It is also useful when applications include this file by
@@ -91,10 +76,6 @@
 #include <windows.h>
 #endif
 
-#if defined(macintosh) && PRAGMA_IMPORT_SUPPORTED
-#pragma import on
-#endif
-
 #ifndef GLAPI
 #define GLAPI extern
 #endif
@@ -116,15 +97,10 @@
 #define GLAPIENTRYP GLAPIENTRY *
 #endif
 
-#ifdef CENTERLINE_CLPP
-#define signed
-#endif
-
 #if defined(PRAGMA_EXPORT_SUPPORTED)
 #pragma export on
 #endif
 
-#endif /* !__SCITECH_SNAP__ */
 /*
  * End system-specific stuff.
  **********************************************************************/
@@ -2177,9 +2153,6 @@ typedef void (APIENTRYP PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum t
 #pragma export off
 #endif
 
-#if defined(macintosh) && PRAGMA_IMPORT_SUPPORTED
-#pragma import off
-#endif
 /*
  * End system-specific stuff
  **********************************************************************/
diff --git a/include/GL/glx.h b/include/GL/glx.h
index fa5a8ed..62d0ede 100644
--- a/include/GL/glx.h
+++ b/include/GL/glx.h
@@ -467,7 +467,32 @@ extern void glXReleaseTexImageEXT(Display *dpy, GLXDrawable drawable, int buffer
 #endif /* GLX_EXT_texture_from_pixmap */
 
 
-
+#ifndef GLX_MESA_query_renderer
+#define GLX_MESA_query_renderer 1
+
+#define GLX_RENDERER_VENDOR_ID_MESA                      0x8183
+#define GLX_RENDERER_DEVICE_ID_MESA                      0x8184
+#define GLX_RENDERER_VERSION_MESA                        0x8185
+#define GLX_RENDERER_ACCELERATED_MESA                    0x8186
+#define GLX_RENDERER_VIDEO_MEMORY_MESA                   0x8187
+#define GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA    0x8188
+#define GLX_RENDERER_PREFERRED_PROFILE_MESA              0x8189
+#define GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA    0x818A
+#define GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA    0x818B
+#define GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA      0x818C
+#define GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA     0x818D
+#define GLX_RENDERER_ID_MESA                             0x818E
+
+Bool glXQueryRendererIntegerMESA(Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
+Bool glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *value);
+const char *glXQueryRendererStringMESA(Display *dpy, int screen, int renderer, int attribute);
+const char *glXQueryCurrentRendererStringMESA(int attribute);
+
+typedef Bool (*PFNGLXQUERYRENDERERINTEGERMESAPROC) (Display *dpy, int screen, int renderer, int attribute, unsigned int *value);
+typedef Bool (*PFNGLXQUERYCURRENTRENDERERINTEGERMESAPROC) (int attribute, unsigned int *value);
+typedef const char *(*PFNGLXQUERYRENDERERSTRINGMESAPROC) (Display *dpy, int screen, int renderer, int attribute);
+typedef const char *(*PFNGLXQUERYCURRENTRENDERERSTRINGMESAPROC) (int attribute);
+#endif /* GLX_MESA_query_renderer */
 
 /*** Should these go here, or in another header? */
 /*
diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index 48993b9..b012570 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -86,6 +86,10 @@ typedef struct __DRIdri2LoaderExtensionRec	__DRIdri2LoaderExtension;
 typedef struct __DRI2flushExtensionRec	__DRI2flushExtension;
 typedef struct __DRI2throttleExtensionRec	__DRI2throttleExtension;
 
+
+typedef struct __DRIimageLoaderExtensionRec     __DRIimageLoaderExtension;
+typedef struct __DRIimageDriverExtensionRec     __DRIimageDriverExtension;
+
 /*@}*/
 
 
@@ -763,6 +767,34 @@ struct __DRIswrastExtensionRec {
 
 };
 
+/** Common DRI function definitions, shared among DRI2 and Image extensions
+ */
+
+typedef __DRIscreen *
+(*__DRIcreateNewScreen2Func)(int screen, int fd,
+                             const __DRIextension **extensions,
+                             const __DRIextension **driver_extensions,
+                             const __DRIconfig ***driver_configs,
+                             void *loaderPrivate);
+
+typedef __DRIdrawable *
+(*__DRIcreateNewDrawableFunc)(__DRIscreen *screen,
+                              const __DRIconfig *config,
+                              void *loaderPrivate);
+
+typedef __DRIcontext *
+(*__DRIcreateContextAttribsFunc)(__DRIscreen *screen,
+                                 int api,
+                                 const __DRIconfig *config,
+                                 __DRIcontext *shared,
+                                 unsigned num_attribs,
+                                 const uint32_t *attribs,
+                                 unsigned *error,
+                                 void *loaderPrivate);
+
+typedef unsigned int
+(*__DRIgetAPIMaskFunc)(__DRIscreen *screen);
+
 /**
  * DRI2 Loader extension.
  */
@@ -910,17 +942,14 @@ struct __DRIdri2ExtensionRec {
 				    const __DRIconfig ***driver_configs,
 				    void *loaderPrivate);
 
-    __DRIdrawable *(*createNewDrawable)(__DRIscreen *screen,
-					const __DRIconfig *config,
-					void *loaderPrivate);
-
-    __DRIcontext *(*createNewContext)(__DRIscreen *screen,
-				      const __DRIconfig *config,
-				      __DRIcontext *shared,
-				      void *loaderPrivate);
+   __DRIcreateNewDrawableFunc   createNewDrawable;
+   __DRIcontext *(*createNewContext)(__DRIscreen *screen,
+                                     const __DRIconfig *config,
+                                     __DRIcontext *shared,
+                                     void *loaderPrivate);
 
    /* Since version 2 */
-   unsigned int (*getAPIMask)(__DRIscreen *screen);
+   __DRIgetAPIMaskFunc          getAPIMask;
 
    __DRIcontext *(*createNewContextForAPI)(__DRIscreen *screen,
 					   int api,
@@ -943,25 +972,14 @@ struct __DRIdri2ExtensionRec {
     *
     * \sa __DRIswrastExtensionRec::createContextAttribs
     */
-   __DRIcontext *(*createContextAttribs)(__DRIscreen *screen,
-					 int api,
-					 const __DRIconfig *config,
-					 __DRIcontext *shared,
-					 unsigned num_attribs,
-					 const uint32_t *attribs,
-					 unsigned *error,
-					 void *loaderPrivate);
+   __DRIcreateContextAttribsFunc        createContextAttribs;
 
    /**
     * createNewScreen with the driver's extension list passed in.
     *
     * \since version 4
     */
-    __DRIscreen *(*createNewScreen2)(int screen, int fd,
-                                     const __DRIextension **loader_extensions,
-                                     const __DRIextension **driver_extensions,
-                                     const __DRIconfig ***driver_configs,
-                                     void *loaderPrivate);
+   __DRIcreateNewScreen2Func            createNewScreen2;
 };
 
 
@@ -996,6 +1014,7 @@ struct __DRIdri2ExtensionRec {
 #define __DRI_IMAGE_FORMAT_NONE         0x1008
 #define __DRI_IMAGE_FORMAT_XRGB2101010  0x1009
 #define __DRI_IMAGE_FORMAT_ARGB2101010  0x100a
+#define __DRI_IMAGE_FORMAT_SARGB8       0x100b
 
 #define __DRI_IMAGE_USE_SHARE		0x0001
 #define __DRI_IMAGE_USE_SCANOUT		0x0002
@@ -1287,4 +1306,104 @@ typedef struct __DRIDriverVtableExtensionRec {
     const struct __DriverAPIRec *vtable;
 } __DRIDriverVtableExtension;
 
+/**
+ * Query renderer driver extension
+ *
+ * This allows the window system layer (either EGL or GLX) to query aspects of
+ * hardware and driver support without creating a context.
+ */
+#define __DRI2_RENDERER_QUERY "DRI_RENDERER_QUERY"
+#define __DRI2_RENDERER_QUERY_VERSION 1
+
+#define __DRI2_RENDERER_VENDOR_ID                             0x0000
+#define __DRI2_RENDERER_DEVICE_ID                             0x0001
+#define __DRI2_RENDERER_VERSION                               0x0002
+#define __DRI2_RENDERER_ACCELERATED                           0x0003
+#define __DRI2_RENDERER_VIDEO_MEMORY                          0x0004
+#define __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE           0x0005
+#define __DRI2_RENDERER_PREFERRED_PROFILE                     0x0006
+#define __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION           0x0007
+#define __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION  0x0008
+#define __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION             0x0009
+#define __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION            0x000a
+
+typedef struct __DRI2rendererQueryExtensionRec __DRI2rendererQueryExtension;
+struct __DRI2rendererQueryExtensionRec {
+   __DRIextension base;
+
+   int (*queryInteger)(__DRIscreen *screen, int attribute, unsigned int *val);
+   int (*queryString)(__DRIscreen *screen, int attribute, const char **val);
+};
+
+/**
+ * Image Loader extension. Drivers use this to allocate color buffers
+ */
+
+enum __DRIimageBufferMask {
+   __DRI_IMAGE_BUFFER_BACK = (1 << 0),
+   __DRI_IMAGE_BUFFER_FRONT = (1 << 1)
+};
+
+struct __DRIimageList {
+   uint32_t image_mask;
+   __DRIimage *back;
+   __DRIimage *front;
+};
+
+#define __DRI_IMAGE_LOADER "DRI_IMAGE_LOADER"
+#define __DRI_IMAGE_LOADER_VERSION 1
+
+struct __DRIimageLoaderExtensionRec {
+    __DRIextension base;
+
+   /**
+    * Allocate color buffers.
+    *
+    * \param driDrawable
+    * \param width              Width of allocated buffers
+    * \param height             Height of allocated buffers
+    * \param format             one of __DRI_IMAGE_FORMAT_*
+    * \param stamp              Address of variable to be updated when
+    *                           getBuffers must be called again
+    * \param loaderPrivate      The loaderPrivate for driDrawable
+    * \param buffer_mask        Set of buffers to allocate
+    * \param buffers            Returned buffers
+    */
+   int (*getBuffers)(__DRIdrawable *driDrawable,
+                     unsigned int format,
+                     uint32_t *stamp,
+                     void *loaderPrivate,
+                     uint32_t buffer_mask,
+                     struct __DRIimageList *buffers);
+
+    /**
+     * Flush pending front-buffer rendering
+     *
+     * Any rendering that has been performed to the
+     * fake front will be flushed to the front
+     *
+     * \param driDrawable    Drawable whose front-buffer is to be flushed
+     * \param loaderPrivate  Loader's private data that was previously passed
+     *                       into __DRIdri2ExtensionRec::createNewDrawable
+     */
+    void (*flushFrontBuffer)(__DRIdrawable *driDrawable, void *loaderPrivate);
+};
+
+/**
+ * DRI extension.
+ */
+
+#define __DRI_IMAGE_DRIVER           "DRI_IMAGE_DRIVER"
+#define __DRI_IMAGE_DRIVER_VERSION   1
+
+struct __DRIimageDriverExtensionRec {
+   __DRIextension               base;
+
+   /* Common DRI functions, shared with DRI2 */
+   __DRIcreateNewScreen2Func            createNewScreen2;
+   __DRIcreateNewDrawableFunc           createNewDrawable;
+   __DRIcreateContextAttribsFunc        createContextAttribs;
+   __DRIgetAPIMaskFunc                  getAPIMask;
+};
+
 #endif
diff --git a/include/GL/osmesa.h b/include/GL/osmesa.h
index c36f649..10c472d 100644
--- a/include/GL/osmesa.h
+++ b/include/GL/osmesa.h
@@ -101,11 +101,6 @@ extern "C" {
 typedef struct osmesa_context *OSMesaContext;
 
 
-#if defined(__QUICKDRAW__)
-#pragma export on
-#endif
-
-
 /*
  * Create an Off-Screen Mesa rendering context.  The only attribute needed is
  * an RGBA vs Color-Index mode flag.
diff --git a/include/pci_ids/radeonsi_pci_ids.h b/include/pci_ids/radeonsi_pci_ids.h
index 0fdd1ad..7b42d5e 100644
--- a/include/pci_ids/radeonsi_pci_ids.h
+++ b/include/pci_ids/radeonsi_pci_ids.h
@@ -118,3 +118,16 @@ CHIPSET(0x1317, KAVERI_1317, KAVERI)
 CHIPSET(0x131B, KAVERI_131B, KAVERI)
 CHIPSET(0x131C, KAVERI_131C, KAVERI)
 CHIPSET(0x131D, KAVERI_131D, KAVERI)
+
+CHIPSET(0x67A0, HAWAII_67A0, HAWAII)
+CHIPSET(0x67A1, HAWAII_67A1, HAWAII)
+CHIPSET(0x67A2, HAWAII_67A2, HAWAII)
+CHIPSET(0x67A8, HAWAII_67A8, HAWAII)
+CHIPSET(0x67A9, HAWAII_67A9, HAWAII)
+CHIPSET(0x67AA, HAWAII_67AA, HAWAII)
+CHIPSET(0x67B0, HAWAII_67B0, HAWAII)
+CHIPSET(0x67B1, HAWAII_67B1, HAWAII)
+CHIPSET(0x67B8, HAWAII_67B8, HAWAII)
+CHIPSET(0x67B9, HAWAII_67B9, HAWAII)
+CHIPSET(0x67BA, HAWAII_67BA, HAWAII)
+CHIPSET(0x67BE, HAWAII_67BE, HAWAII)
diff --git a/scons/gallium.py b/scons/gallium.py
index be3c3e7..ea8bacd 100755
--- a/scons/gallium.py
+++ b/scons/gallium.py
@@ -295,8 +295,6 @@ def generate(env):
             cppdefines += ['_DEBUG']
     if platform == 'windows':
         cppdefines += ['PIPE_SUBSYSTEM_WINDOWS_USER']
-    if platform == 'haiku':
-        cppdefines += ['BEOS_THREADS']
     if env['embedded']:
         cppdefines += ['PIPE_SUBSYSTEM_EMBEDDED']
     if env['texture_float']:
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index a64f4e8..e703f28 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -33,8 +33,10 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <unistd.h>
+#ifdef HAVE_DRM_PLATFORM
 #include <xf86drm.h>
 #include <drm_fourcc.h>
+#endif
 #include <GL/gl.h>
 #include <GL/internal/dri_interface.h>
 #include <sys/types.h>
@@ -520,10 +522,12 @@ dri2_setup_screen(_EGLDisplay *disp)
          disp->Extensions.KHR_gl_texture_2D_image = EGL_TRUE;
          disp->Extensions.KHR_gl_texture_cubemap_image = EGL_TRUE;
       }
+#ifdef HAVE_DRM_PLATFORM
       if (dri2_dpy->image->base.version >= 8 &&
           dri2_dpy->image->createImageFromDmaBufs) {
          disp->Extensions.EXT_image_dma_buf_import = EGL_TRUE;
       }
+#endif
    }
 }
 
@@ -1158,6 +1162,7 @@ dri2_create_image_khr_renderbuffer(_EGLDisplay *disp, _EGLContext *ctx,
    return dri2_create_image(disp, dri_image);
 }
 
+#ifdef HAVE_DRM_PLATFORM
 static _EGLImage *
 dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
 				  EGLClientBuffer buffer, const EGLint *attr_list)
@@ -1202,6 +1207,7 @@ dri2_create_image_mesa_drm_buffer(_EGLDisplay *disp, _EGLContext *ctx,
 
    return dri2_create_image(disp, dri_image);
 }
+#endif
 
 #ifdef HAVE_WAYLAND_PLATFORM
 
@@ -1375,6 +1381,7 @@ dri2_create_image_khr_texture(_EGLDisplay *disp, _EGLContext *ctx,
    return &dri2_img->base;
 }
 
+#ifdef HAVE_DRM_PLATFORM
 static EGLBoolean
 dri2_check_dma_buf_attribs(const _EGLImageAttribs *attrs)
 {
@@ -1629,6 +1636,7 @@ dri2_create_image_dma_buf(_EGLDisplay *disp, _EGLContext *ctx,
 
    return res;
 }
+#endif
 
 _EGLImage *
 dri2_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
@@ -1648,14 +1656,18 @@ dri2_create_image_khr(_EGLDriver *drv, _EGLDisplay *disp,
       return dri2_create_image_khr_texture(disp, ctx, target, buffer, attr_list);
    case EGL_GL_RENDERBUFFER_KHR:
       return dri2_create_image_khr_renderbuffer(disp, ctx, buffer, attr_list);
+#ifdef HAVE_DRM_PLATFORM
    case EGL_DRM_BUFFER_MESA:
       return dri2_create_image_mesa_drm_buffer(disp, ctx, buffer, attr_list);
+#endif
 #ifdef HAVE_WAYLAND_PLATFORM
    case EGL_WAYLAND_BUFFER_WL:
       return dri2_create_image_wayland_wl_buffer(disp, ctx, buffer, attr_list);
 #endif
+#ifdef HAVE_DRM_PLATFORM
    case EGL_LINUX_DMA_BUF_EXT:
       return dri2_create_image_dma_buf(disp, ctx, buffer, attr_list);
+#endif
    default:
       _eglError(EGL_BAD_PARAMETER, "dri2_create_image_khr");
       return EGL_NO_IMAGE_KHR;
@@ -1676,6 +1688,7 @@ dri2_destroy_image_khr(_EGLDriver *drv, _EGLDisplay *disp, _EGLImage *image)
    return EGL_TRUE;
 }
 
+#ifdef HAVE_DRM_PLATFORM
 static _EGLImage *
 dri2_create_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp,
 			   const EGLint *attr_list)
@@ -1786,6 +1799,7 @@ dri2_export_drm_image_mesa(_EGLDriver *drv, _EGLDisplay *disp, _EGLImage *img,
 
    return EGL_TRUE;
 }
+#endif
 
 #ifdef HAVE_WAYLAND_PLATFORM
 
@@ -2020,8 +2034,10 @@ _eglBuiltInDriverDRI2(const char *args)
    dri2_drv->base.API.ReleaseTexImage = dri2_release_tex_image;
    dri2_drv->base.API.CreateImageKHR = dri2_create_image_khr;
    dri2_drv->base.API.DestroyImageKHR = dri2_destroy_image_khr;
+#ifdef HAVE_DRM_PLATFORM
    dri2_drv->base.API.CreateDRMImageMESA = dri2_create_drm_image_mesa;
    dri2_drv->base.API.ExportDRMImageMESA = dri2_export_drm_image_mesa;
+#endif
 #ifdef HAVE_WAYLAND_PLATFORM
    dri2_drv->base.API.BindWaylandDisplayWL = dri2_bind_wayland_display_wl;
    dri2_drv->base.API.UnbindWaylandDisplayWL = dri2_unbind_wayland_display_wl;
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index c7d6484..bbe5602 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -117,7 +117,7 @@ struct dri2_egl_display
 
    __DRIdri2LoaderExtension    dri2_loader_extension;
    __DRIswrastLoaderExtension  swrast_loader_extension;
-   const __DRIextension     *extensions[4];
+   const __DRIextension     *extensions[5];
    const __DRIextension    **driver_extensions;
 
 #ifdef HAVE_X11_PLATFORM
@@ -189,7 +189,6 @@ struct dri2_egl_surface
 #ifdef HAVE_WAYLAND_PLATFORM
       struct wl_buffer   *wl_buffer;
       __DRIimage         *dri_image;
-      int                 pitch, name;
 #endif
 #ifdef HAVE_DRM_PLATFORM
       struct gbm_bo       *bo;
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index 7b1e3a1..181b29d 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -175,13 +175,12 @@ dri2_destroy_surface(_EGLDriver *drv, _EGLDisplay *disp, _EGLSurface *surf)
 }
 
 static int
-get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
+get_back_bo(struct dri2_egl_surface *dri2_surf)
 {
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
-   struct gbm_dri_bo *bo;
    struct gbm_dri_surface *surf = dri2_surf->gbm_surf;
-   int i, name, pitch;
+   int i;
 
    if (dri2_surf->back == NULL) {
       for (i = 0; i < ARRAY_SIZE(dri2_surf->color_buffers); i++) {
@@ -201,6 +200,17 @@ get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
    if (dri2_surf->back->bo == NULL)
       return -1;
 
+   return 0;
+}
+
+static void
+back_bo_to_dri_buffer(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
+{
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+   struct gbm_dri_bo *bo;
+   int name, pitch;
+
    bo = (struct gbm_dri_bo *) dri2_surf->back->bo;
 
    dri2_dpy->image->queryImage(bo->image, __DRI_IMAGE_ATTRIB_NAME, &name);
@@ -211,8 +221,6 @@ get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
    buffer->pitch = pitch;
    buffer->cpp = 4;
    buffer->flags = 0;
-
-   return 0;
 }
 
 static int
@@ -254,10 +262,11 @@ dri2_get_buffers_with_format(__DRIdrawable *driDrawable,
 
       switch (attachments[i]) {
       case __DRI_BUFFER_BACK_LEFT:
-	 if (get_back_bo(dri2_surf, &dri2_surf->buffers[j]) < 0) {
+	 if (get_back_bo(dri2_surf) < 0) {
 	    _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
 	    return NULL;
 	 }
+         back_bo_to_dri_buffer(dri2_surf, &dri2_surf->buffers[j]);
 	 break;
       default:
 	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
@@ -312,6 +321,27 @@ dri2_get_buffers(__DRIdrawable * driDrawable,
    return buffer;
 }
 
+static int
+dri_image_get_buffers(__DRIdrawable *driDrawable,
+                      unsigned int format,
+                      uint32_t *stamp,
+                      void *loaderPrivate,
+                      uint32_t buffer_mask,
+                      struct __DRIimageList *buffers)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+   struct gbm_dri_bo *bo;
+
+   if (get_back_bo(dri2_surf) < 0)
+      return 0;
+
+   bo = (struct gbm_dri_bo *) dri2_surf->back->bo;
+   buffers->image_mask = __DRI_IMAGE_BUFFER_BACK;
+   buffers->back = bo->image;
+
+   return 1;
+}
+
 static void
 dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
 {
@@ -348,9 +378,8 @@ dri2_query_buffer_age(_EGLDriver *drv,
                       _EGLDisplay *disp, _EGLSurface *surface)
 {
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surface);
-   __DRIbuffer buffer;
 
-   if (get_back_bo(dri2_surf, &buffer) < 0) {
+   if (get_back_bo(dri2_surf) < 0) {
       _eglError(EGL_BAD_ALLOC, "dri2_query_buffer_age");
       return 0;
    }
@@ -469,6 +498,7 @@ dri2_initialize_drm(_EGLDriver *drv, _EGLDisplay *disp)
    dri2_dpy->gbm_dri->get_buffers = dri2_get_buffers;
    dri2_dpy->gbm_dri->flush_front_buffer = dri2_flush_front_buffer;
    dri2_dpy->gbm_dri->get_buffers_with_format = dri2_get_buffers_with_format;
+   dri2_dpy->gbm_dri->image_get_buffers = dri_image_get_buffers;
 
    dri2_dpy->gbm_dri->base.base.surface_lock_front_buffer = lock_front_buffer;
    dri2_dpy->gbm_dri->base.base.surface_release_buffer = release_buffer;
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index c0de16b..f9065bb 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -257,12 +257,11 @@ dri2_release_buffers(struct dri2_egl_surface *dri2_surf)
 }
 
 static int
-get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
+get_back_bo(struct dri2_egl_surface *dri2_surf)
 {
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
-   __DRIimage *image;
-   int i, name, pitch;
+   int i;
 
    /* There might be a buffer release already queued that wasn't processed */
    wl_display_dispatch_queue_pending(dri2_dpy->wl_dpy, dri2_dpy->wl_queue);
@@ -295,23 +294,30 @@ get_back_bo(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
    if (dri2_surf->back->dri_image == NULL)
       return -1;
 
+   dri2_surf->back->locked = 1;
+
+   return 0;
+}
+
+
+static void
+back_bo_to_dri_buffer(struct dri2_egl_surface *dri2_surf, __DRIbuffer *buffer)
+{
+   struct dri2_egl_display *dri2_dpy =
+      dri2_egl_display(dri2_surf->base.Resource.Display);
+   __DRIimage *image;
+   int name, pitch;
+
    image = dri2_surf->back->dri_image;
 
    dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_NAME, &name);
    dri2_dpy->image->queryImage(image, __DRI_IMAGE_ATTRIB_STRIDE, &pitch);
 
-   dri2_surf->back->name = name;
-   dri2_surf->back->pitch = pitch;
-
    buffer->attachment = __DRI_BUFFER_BACK_LEFT;
    buffer->name = name;
    buffer->pitch = pitch;
    buffer->cpp = 4;
    buffer->flags = 0;
-
-   dri2_surf->back->locked = 1;
-
-   return 0;
 }
 
 static int
@@ -337,16 +343,12 @@ get_aux_bo(struct dri2_egl_surface *dri2_surf,
    return 0;
 }
 
-static __DRIbuffer *
-dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
-			     int *width, int *height,
-			     unsigned int *attachments, int count,
-			     int *out_count, void *loaderPrivate)
+static int
+update_buffers(struct dri2_egl_surface *dri2_surf)
 {
-   struct dri2_egl_surface *dri2_surf = loaderPrivate;
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
-   int i, j;
+   int i;
 
    if (dri2_surf->base.Type == EGL_WINDOW_BIT &&
        (dri2_surf->base.Width != dri2_surf->wl_win->width || 
@@ -360,22 +362,9 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
       dri2_surf->dy = dri2_surf->wl_win->dy;
    }
 
-   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
-      switch (attachments[i]) {
-      case __DRI_BUFFER_BACK_LEFT:
-	 if (get_back_bo(dri2_surf, &dri2_surf->buffers[j]) < 0) {
-	    _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
-	    return NULL;
-	 }
-	 break;
-      default:
-	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
-			&dri2_surf->buffers[j]) < 0) {
-	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
-	    return NULL;
-	 }
-	 break;
-      }
+   if (get_back_bo(dri2_surf) < 0) {
+      _eglError(EGL_BAD_ALLOC, "failed to allocate color buffer");
+      return -1;
    }
 
    /* If we have an extra unlocked buffer at this point, we had to do triple
@@ -391,6 +380,36 @@ dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
       }
    }
 
+   return 0;
+}
+
+static __DRIbuffer *
+dri2_get_buffers_with_format(__DRIdrawable * driDrawable,
+			     int *width, int *height,
+			     unsigned int *attachments, int count,
+			     int *out_count, void *loaderPrivate)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+   int i, j;
+
+   if (update_buffers(dri2_surf) < 0)
+      return NULL;
+
+   for (i = 0, j = 0; i < 2 * count; i += 2, j++) {
+      switch (attachments[i]) {
+      case __DRI_BUFFER_BACK_LEFT:
+         back_bo_to_dri_buffer(dri2_surf, &dri2_surf->buffers[j]);
+	 break;
+      default:
+	 if (get_aux_bo(dri2_surf, attachments[i], attachments[i + 1],
+			&dri2_surf->buffers[j]) < 0) {
+	    _eglError(EGL_BAD_ALLOC, "failed to allocate aux buffer");
+	    return NULL;
+	 }
+	 break;
+      }
+   }
+
    *out_count = j;
    if (j == 0)
 	   return NULL;
@@ -434,6 +453,25 @@ dri2_get_buffers(__DRIdrawable * driDrawable,
    return buffer;
 }
 
+static int
+image_get_buffers(__DRIdrawable *driDrawable,
+                  unsigned int format,
+                  uint32_t *stamp,
+                  void *loaderPrivate,
+                  uint32_t buffer_mask,
+                  struct __DRIimageList *buffers)
+{
+   struct dri2_egl_surface *dri2_surf = loaderPrivate;
+
+   if (update_buffers(dri2_surf) < 0)
+      return 0;
+
+   buffers->image_mask = __DRI_IMAGE_BUFFER_BACK;
+   buffers->back = dri2_surf->back->dri_image;
+
+   return 1;
+}
+
 static void
 dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
 {
@@ -441,6 +479,12 @@ dri2_flush_front_buffer(__DRIdrawable * driDrawable, void *loaderPrivate)
    (void) loaderPrivate;
 }
 
+static const __DRIimageLoaderExtension image_loader_extension = {
+   { __DRI_IMAGE_LOADER, 1 },
+   image_get_buffers,
+   dri2_flush_front_buffer
+};
+
 static void
 wayland_frame_callback(void *data, struct wl_callback *callback, uint32_t time)
 {
@@ -459,7 +503,7 @@ create_wl_buffer(struct dri2_egl_surface *dri2_surf)
 {
    struct dri2_egl_display *dri2_dpy =
       dri2_egl_display(dri2_surf->base.Resource.Display);
-   int fd;
+   int fd, stride, name;
 
    if (dri2_surf->current->wl_buffer != NULL)
       return;
@@ -467,6 +511,8 @@ create_wl_buffer(struct dri2_egl_surface *dri2_surf)
    if (dri2_dpy->capabilities & WL_DRM_CAPABILITY_PRIME) {
       dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
                                   __DRI_IMAGE_ATTRIB_FD, &fd);
+      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
+                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);
 
       dri2_surf->current->wl_buffer =
          wl_drm_create_prime_buffer(dri2_dpy->wl_drm,
@@ -474,17 +520,22 @@ create_wl_buffer(struct dri2_egl_surface *dri2_surf)
                                     dri2_surf->base.Width,
                                     dri2_surf->base.Height,
                                     dri2_surf->format,
-                                    0, dri2_surf->current->pitch,
+                                    0, stride,
                                     0, 0,
                                     0, 0);
       close(fd);
    } else {
+      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
+                                  __DRI_IMAGE_ATTRIB_NAME, &name);
+      dri2_dpy->image->queryImage(dri2_surf->current->dri_image,
+                                  __DRI_IMAGE_ATTRIB_STRIDE, &stride);
+
       dri2_surf->current->wl_buffer =
          wl_drm_create_buffer(dri2_dpy->wl_drm,
-                              dri2_surf->current->name,
+                              name,
                               dri2_surf->base.Width,
                               dri2_surf->base.Height,
-                              dri2_surf->current->pitch,
+                              stride,
                               dri2_surf->format);
    }
 
@@ -506,7 +557,6 @@ dri2_swap_buffers_with_damage(_EGLDriver *drv,
 {
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(draw);
-   __DRIbuffer buffer;
    int i, ret = 0;
 
    while (dri2_surf->frame_callback && ret != -1)
@@ -526,7 +576,7 @@ dri2_swap_buffers_with_damage(_EGLDriver *drv,
 
    /* Make sure we have a back buffer in case we're swapping without ever
     * rendering. */
-   if (get_back_bo(dri2_surf, &buffer) < 0) {
+   if (get_back_bo(dri2_surf) < 0) {
       _eglError(EGL_BAD_ALLOC, "dri2_swap_buffers");
       return EGL_FALSE;
    }
@@ -573,9 +623,8 @@ dri2_query_buffer_age(_EGLDriver *drv,
                       _EGLDisplay *disp, _EGLSurface *surface)
 {
    struct dri2_egl_surface *dri2_surf = dri2_egl_surface(surface);
-   __DRIbuffer buffer;
 
-   if (get_back_bo(dri2_surf, &buffer) < 0) {
+   if (get_back_bo(dri2_surf) < 0) {
       _eglError(EGL_BAD_ALLOC, "dri2_query_buffer_age");
       return 0;
    }
@@ -799,11 +848,12 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    dri2_dpy->dri2_loader_extension.flushFrontBuffer = dri2_flush_front_buffer;
    dri2_dpy->dri2_loader_extension.getBuffersWithFormat =
       dri2_get_buffers_with_format;
-      
+
    dri2_dpy->extensions[0] = &dri2_dpy->dri2_loader_extension.base;
-   dri2_dpy->extensions[1] = &image_lookup_extension.base;
-   dri2_dpy->extensions[2] = &use_invalidate.base;
-   dri2_dpy->extensions[3] = NULL;
+   dri2_dpy->extensions[1] = &image_loader_extension.base;
+   dri2_dpy->extensions[2] = &image_lookup_extension.base;
+   dri2_dpy->extensions[3] = &use_invalidate.base;
+   dri2_dpy->extensions[4] = NULL;
 
    if (!dri2_create_screen(disp))
       goto cleanup_driver;
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index a518db1..c56a413 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -33,7 +33,9 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <unistd.h>
+#ifdef HAVE_DRM_PLATFORM
 #include <xf86drm.h>
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
 
@@ -606,6 +608,7 @@ dri2_x11_authenticate(_EGLDisplay *disp, uint32_t id)
 static EGLBoolean
 dri2_authenticate(_EGLDisplay *disp)
 {
+#ifdef HAVE_DRM_PLATFORM
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    drm_magic_t magic;
 
@@ -620,6 +623,9 @@ dri2_authenticate(_EGLDisplay *disp)
    }
 
    return EGL_TRUE;
+#else
+   return EGL_FALSE;
+#endif
 }
 
 static EGLBoolean
diff --git a/src/gallium/Automake.inc b/src/gallium/Automake.inc
index fabc2af..b6b9b36 100644
--- a/src/gallium/Automake.inc
+++ b/src/gallium/Automake.inc
@@ -3,3 +3,90 @@ GALLIUM_CFLAGS = \
 	-I$(top_srcdir)/src/gallium/include \
 	-I$(top_srcdir)/src/gallium/auxiliary \
 	$(DEFINES)
+
+# src/gallium/auxiliary must appear before src/gallium/drivers
+# because there are stupidly two rbug_context.h files in
+# different directories, and which one is included by the
+# preprocessor is determined by the ordering of the -I flags.
+GALLIUM_DRIVER_CFLAGS = \
+	-I$(srcdir)/include \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/gallium/include \
+	-I$(top_srcdir)/src/gallium/auxiliary \
+	-I$(top_srcdir)/src/gallium/drivers \
+	$(DEFINES) \
+	$(VISIBILITY_CFLAGS)
+
+GALLIUM_DRIVER_CXXFLAGS = \
+	-I$(srcdir)/include \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/gallium/include \
+	-I$(top_srcdir)/src/gallium/auxiliary \
+	-I$(top_srcdir)/src/gallium/drivers \
+	$(DEFINES) \
+	$(VISIBILITY_CXXFLAGS)
+
+GALLIUM_DRI_CFLAGS = \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/gallium/include \
+	-I$(top_srcdir)/src/gallium/auxiliary \
+	-I$(top_srcdir)/src/gallium/drivers \
+	-I$(top_srcdir)/src/gallium/winsys \
+	-I$(top_srcdir)/src/mesa \
+	-I$(top_srcdir)/src/mapi \
+	$(DEFINES) \
+	$(PTHREAD_CFLAGS) \
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
+
+GALLIUM_VIDEO_CFLAGS = \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/gallium/include \
+	-I$(top_srcdir)/src/gallium/auxiliary \
+	-I$(top_srcdir)/src/gallium/drivers \
+	-I$(top_srcdir)/src/gallium/winsys \
+	$(DEFINES) \
+	$(PTHREAD_CFLAGS) \
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
+
+
+# TODO: add -export-symbols-regex
+GALLIUM_DRI_LINKER_FLAGS = \
+	-module \
+	-avoid-version \
+	-shared \
+	-Wl,-Bsymbolic
+
+GALLIUM_VDPAU_LINKER_FLAGS = \
+	-module \
+	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
+	-export-symbols-regex $(VDPAU_EXPORTS) \
+	-shared \
+	-no-undefined
+
+# TODO: add -export-symbols-regex
+GALLIUM_XVMC_LINKER_FLAGS = \
+	-module \
+	-version-number $(XVMC_MAJOR):$(XVMC_MINOR) \
+	-shared \
+	-no-undefined
+
+GALLIUM_VDPAU_LIB_DEPS = \
+	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
+	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
+	$(VDPAU_LIBS) \
+	$(LIBDRM_LIBS)
+
+GALLIUM_XVMC_LIB_DEPS = \
+	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
+	$(top_builddir)/src/gallium/state_trackers/xvmc/libxvmctracker.la \
+	$(XVMC_LIBS) \
+	$(LIBDRM_LIBS)
+
+GALLIUM_WINSYS_CFLAGS = \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/gallium/include \
+	-I$(top_srcdir)/src/gallium/auxiliary \
+	$(DEFINES) \
+	$(VISIBILITY_CFLAGS)
diff --git a/src/gallium/SConscript b/src/gallium/SConscript
index 9a25cca..6e27be2 100644
--- a/src/gallium/SConscript
+++ b/src/gallium/SConscript
@@ -45,9 +45,6 @@ if not env['embedded']:
     if env['dri']:
         SConscript('state_trackers/dri/SConscript')
 
-    if env['dri'] and env['xorg']:
-        SConscript('state_trackers/xorg/SConscript')
-
     if env['platform'] == 'windows':
         SConscript('state_trackers/wgl/SConscript')
 
@@ -127,7 +124,6 @@ if not env['embedded']:
 
     if env['dri']:
         SConscript([
-            'targets/SConscript.dri',
             'targets/dri-swrast/SConscript',
             'targets/dri-vmwgfx/SConscript',
         ])
@@ -136,11 +132,6 @@ if not env['embedded']:
                 'targets/dri-i915/SConscript',
             ])
 
-    if env['xorg'] and env['drm']:
-        SConscript([
-            #'targets/xorg-i915/SConscript',
-        ])
-
 
 #
 # Unit tests & tools
diff --git a/src/gallium/auxiliary/draw/draw_context.c b/src/gallium/auxiliary/draw/draw_context.c
index 641dd82..2b3bc0d 100644
--- a/src/gallium/auxiliary/draw/draw_context.c
+++ b/src/gallium/auxiliary/draw/draw_context.c
@@ -38,6 +38,7 @@
 #include "util/u_inlines.h"
 #include "util/u_helpers.h"
 #include "util/u_prim.h"
+#include "util/u_format.h"
 #include "draw_context.h"
 #include "draw_pipe.h"
 #include "draw_prim_assembler.h"
@@ -164,6 +165,8 @@ boolean draw_init(struct draw_context *draw)
    draw->quads_always_flatshade_last = !draw->pipe->screen->get_param(
       draw->pipe->screen, PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION);
 
+   draw->floating_point_depth = false;
+
    return TRUE;
 }
 
@@ -233,15 +236,20 @@ void draw_flush( struct draw_context *draw )
 
 
 /**
- * Specify the Minimum Resolvable Depth factor for polygon offset.
+ * Specify the depth stencil format for the draw pipeline. This function
+ * determines the Minimum Resolvable Depth factor for polygon offset.
  * This factor potentially depends on the number of Z buffer bits,
  * the rasterization algorithm and the arithmetic performed on Z
- * values between vertex shading and rasterization.  It will vary
- * from one driver to another.
+ * values between vertex shading and rasterization.
  */
-void draw_set_mrd(struct draw_context *draw, double mrd)
+void draw_set_zs_format(struct draw_context *draw, enum pipe_format format)
 {
-   draw->mrd = mrd;
+   const struct util_format_description *desc = util_format_description(format);
+
+   draw->floating_point_depth =
+      (util_get_depth_format_type(desc) == UTIL_FORMAT_TYPE_FLOAT);
+
+   draw->mrd = util_get_depth_format_mrd(desc);
 }
 
 
diff --git a/src/gallium/auxiliary/draw/draw_context.h b/src/gallium/auxiliary/draw/draw_context.h
index 46d0de6..e2e0cb4 100644
--- a/src/gallium/auxiliary/draw/draw_context.h
+++ b/src/gallium/auxiliary/draw/draw_context.h
@@ -111,7 +111,7 @@ void draw_enable_line_stipple(struct draw_context *draw, boolean enable);
 
 void draw_enable_point_sprites(struct draw_context *draw, boolean enable);
 
-void draw_set_mrd(struct draw_context *draw, double mrd);
+void draw_set_zs_format(struct draw_context *draw, enum pipe_format format);
 
 boolean
 draw_install_aaline_stage(struct draw_context *draw, struct pipe_context *pipe);
diff --git a/src/gallium/auxiliary/draw/draw_llvm.c b/src/gallium/auxiliary/draw/draw_llvm.c
index 03668d9..fe49b86 100644
--- a/src/gallium/auxiliary/draw/draw_llvm.c
+++ b/src/gallium/auxiliary/draw/draw_llvm.c
@@ -1036,6 +1036,9 @@ store_clip(struct gallivm_state *gallivm,
    LLVMValueRef io_ptrs[LP_MAX_VECTOR_WIDTH / 32];
    LLVMValueRef inds[LP_MAX_VECTOR_WIDTH / 32];
    LLVMValueRef clip_ptrs[LP_MAX_VECTOR_WIDTH / 32];
+   LLVMTypeRef clip_ptr_type =
+      LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context),
+                                     4), 0);
    int i, j;
 
    indices[0] =
@@ -1070,7 +1073,6 @@ store_clip(struct gallivm_state *gallivm,
    }
 
    for (j = 0; j < vs_type.length; j++) {
-      LLVMTypeRef  clip_ptr_type = LLVMPointerType(LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4), 0);
       LLVMValueRef clip_ptr;
 
       clip_ptr = LLVMBuildGEP(builder, clip_ptrs[j], indices, 2, "clipo");
diff --git a/src/gallium/auxiliary/draw/draw_pipe_offset.c b/src/gallium/auxiliary/draw/draw_pipe_offset.c
index 3578525..3411403 100644
--- a/src/gallium/auxiliary/draw/draw_pipe_offset.c
+++ b/src/gallium/auxiliary/draw/draw_pipe_offset.c
@@ -32,6 +32,7 @@
  * \author  Brian Paul
  */
 
+#include "util/u_format.h"
 #include "util/u_math.h"
 #include "util/u_memory.h"
 #include "draw_pipe.h"
@@ -89,7 +90,27 @@ static void do_offset_tri( struct draw_stage *stage,
    float dzdx = fabsf(a * inv_det);
    float dzdy = fabsf(b * inv_det);
 
-   float zoffset = offset->units + MAX2(dzdx, dzdy) * offset->scale;
+   float zoffset, mult;
+
+   mult = MAX2(dzdx, dzdy) * offset->scale;
+
+   if (stage->draw->floating_point_depth) {
+      float bias;
+      union fi maxz;
+      maxz.f = MAX3(v0[2], v1[2], v2[2]);
+      /* just do the math directly on shifted number */
+      maxz.ui &= 0xff << 23;
+      maxz.i -= 23 << 23;
+      /* Clamping to zero means mrd will be zero for very small numbers,
+       * but specs do not indicate this should be prevented by clamping
+       * mrd to smallest normal number instead. */
+      maxz.i = MAX2(maxz.i, 0);
+
+      bias = offset->units * maxz.f;
+      zoffset = bias + mult;
+   } else {
+      zoffset = offset->units + mult;
+   }
 
    if (offset->clamp)
       zoffset = (offset->clamp < 0.0f) ? MAX2(zoffset, offset->clamp) :
@@ -157,7 +178,17 @@ static void offset_first_tri( struct draw_stage *stage,
    if (do_offset) {
       offset->scale = rast->offset_scale;
       offset->clamp = rast->offset_clamp;
-      offset->units = (float) (rast->offset_units * stage->draw->mrd);
+
+      /*
+       * If depth is floating point, depth bias is calculated with respect
+       * to the primitive's maximum Z value. Retain the original depth bias
+       * value until that stage.
+       */
+      if (stage->draw->floating_point_depth) {
+         offset->units = (float) rast->offset_units;
+      } else {
+         offset->units = (float) (rast->offset_units * stage->draw->mrd);
+      }
    }
    else {
       offset->scale = 0.0f;
diff --git a/src/gallium/auxiliary/draw/draw_private.h b/src/gallium/auxiliary/draw/draw_private.h
index ba93b09..fbe25a2 100644
--- a/src/gallium/auxiliary/draw/draw_private.h
+++ b/src/gallium/auxiliary/draw/draw_private.h
@@ -236,6 +236,8 @@ struct draw_context
 
    boolean dump_vs;
 
+   /** Depth format and bias related settings. */
+   boolean floating_point_depth;
    double mrd;  /**< minimum resolvable depth value, for polygon offset */
 
    /** Current rasterizer state given to us by the driver */
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_arit.c b/src/gallium/auxiliary/gallivm/lp_bld_arit.c
index 00052ed..70929e7 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_arit.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_arit.c
@@ -123,8 +123,10 @@ lp_build_min_simple(struct lp_build_context *bld,
       }
    }
    else if (type.floating && util_cpu_caps.has_altivec) {
-      debug_printf("%s: altivec doesn't support nan behavior modes\n",
-                   __FUNCTION__);
+      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
+         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
+                      __FUNCTION__);
+      }
       if (type.width == 32 && type.length == 4) {
          intrinsic = "llvm.ppc.altivec.vminfp";
          intr_size = 128;
@@ -159,8 +161,6 @@ lp_build_min_simple(struct lp_build_context *bld,
       }
    } else if (util_cpu_caps.has_altivec) {
       intr_size = 128;
-      debug_printf("%s: altivec doesn't support nan behavior modes\n",
-                   __FUNCTION__);
       if (type.width == 8) {
          if (!type.sign) {
             intrinsic = "llvm.ppc.altivec.vminub";
@@ -191,7 +191,7 @@ lp_build_min_simple(struct lp_build_context *bld,
        */
       if (util_cpu_caps.has_sse && type.floating &&
           nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
-          nan_behavior != GALLIVM_NAN_RETURN_SECOND) {
+          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
          LLVMValueRef isnan, max;
          max = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
@@ -227,7 +227,7 @@ lp_build_min_simple(struct lp_build_context *bld,
          return lp_build_select(bld, cond, a, b);
       }
          break;
-      case GALLIVM_NAN_RETURN_SECOND:
+      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
          cond = lp_build_cmp_ordered(bld, PIPE_FUNC_LESS, a, b);
          return lp_build_select(bld, cond, a, b);
       case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
@@ -299,8 +299,10 @@ lp_build_max_simple(struct lp_build_context *bld,
       }
    }
    else if (type.floating && util_cpu_caps.has_altivec) {
-      debug_printf("%s: altivec doesn't support nan behavior modes\n",
-                   __FUNCTION__);
+      if (nan_behavior == GALLIVM_NAN_RETURN_NAN) {
+         debug_printf("%s: altivec doesn't support nan return nan behavior\n",
+                      __FUNCTION__);
+      }
       if (type.width == 32 || type.length == 4) {
          intrinsic = "llvm.ppc.altivec.vmaxfp";
          intr_size = 128;
@@ -336,8 +338,6 @@ lp_build_max_simple(struct lp_build_context *bld,
       }
    } else if (util_cpu_caps.has_altivec) {
      intr_size = 128;
-     debug_printf("%s: altivec doesn't support nan behavior modes\n",
-                  __FUNCTION__);
      if (type.width == 8) {
        if (!type.sign) {
          intrinsic = "llvm.ppc.altivec.vmaxub";
@@ -362,7 +362,7 @@ lp_build_max_simple(struct lp_build_context *bld,
    if(intrinsic) {
       if (util_cpu_caps.has_sse && type.floating &&
           nan_behavior != GALLIVM_NAN_BEHAVIOR_UNDEFINED &&
-          nan_behavior != GALLIVM_NAN_RETURN_SECOND) {
+          nan_behavior != GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN) {
          LLVMValueRef isnan, min;
          min = lp_build_intrinsic_binary_anylength(bld->gallivm, intrinsic,
                                                    type,
@@ -398,7 +398,7 @@ lp_build_max_simple(struct lp_build_context *bld,
          return lp_build_select(bld, cond, a, b);
       }
          break;
-      case GALLIVM_NAN_RETURN_SECOND:
+      case GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN:
          cond = lp_build_cmp_ordered(bld, PIPE_FUNC_GREATER, a, b);
          return lp_build_select(bld, cond, a, b);
       case GALLIVM_NAN_BEHAVIOR_UNDEFINED:
@@ -1399,6 +1399,7 @@ lp_build_max_ext(struct lp_build_context *bld,
 
 /**
  * Generate clamp(a, min, max)
+ * NaN behavior (for any of a, min, max) is undefined.
  * Do checks for special cases.
  */
 LLVMValueRef
@@ -1418,6 +1419,20 @@ lp_build_clamp(struct lp_build_context *bld,
 
 
 /**
+ * Generate clamp(a, 0, 1)
+ * A NaN will get converted to zero.
+ */
+LLVMValueRef
+lp_build_clamp_zero_one_nanzero(struct lp_build_context *bld,
+                                LLVMValueRef a)
+{
+   a = lp_build_max_ext(bld, a, bld->zero, GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
+   a = lp_build_min(bld, a, bld->one);
+   return a;
+}
+
+
+/**
  * Generate abs(a)
  */
 LLVMValueRef
@@ -3029,9 +3044,8 @@ lp_build_exp2(struct lp_build_context *bld,
    /* We want to preserve NaN and make sure than for exp2 if x > 128,
     * the result is INF  and if it's smaller than -126.9 the result is 0 */
    x = lp_build_min_ext(bld, lp_build_const_vec(bld->gallivm, type,  128.0), x,
-                        GALLIVM_NAN_RETURN_SECOND);
-   x = lp_build_max_ext(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x,
-                        GALLIVM_NAN_RETURN_SECOND);
+                        GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
+   x = lp_build_max(bld, lp_build_const_vec(bld->gallivm, type, -126.99999), x);
 
    /* ipart = floor(x) */
    /* fpart = x - ipart */
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_arit.h b/src/gallium/auxiliary/gallivm/lp_bld_arit.h
index 49d4e2c..75bf89e 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_arit.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_arit.h
@@ -142,9 +142,11 @@ enum gallivm_nan_behavior {
    GALLIVM_NAN_RETURN_NAN,
    /* If one of the inputs is NaN, the other operand is returned */
    GALLIVM_NAN_RETURN_OTHER,
-   /* If one of the inputs is NaN, the second operand is returned.
-    * In min/max it will be as fast as undefined with sse opcodes */
-   GALLIVM_NAN_RETURN_SECOND
+   /* If one of the inputs is NaN, the other operand is returned,
+    * but we guarantee the second operand is not a NaN.
+    * In min/max it will be as fast as undefined with sse opcodes,
+    * and archs having native return_other can benefit too. */
+   GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN
 };
 
 LLVMValueRef
@@ -176,6 +178,10 @@ lp_build_clamp(struct lp_build_context *bld,
                LLVMValueRef max);
 
 LLVMValueRef
+lp_build_clamp_zero_one_nanzero(struct lp_build_context *bld,
+                                LLVMValueRef a);
+
+LLVMValueRef
 lp_build_abs(struct lp_build_context *bld,
              LLVMValueRef a);
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_format_srgb.c b/src/gallium/auxiliary/gallivm/lp_bld_format_srgb.c
index 2b1fe64..6645151 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_format_srgb.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_format_srgb.c
@@ -326,7 +326,7 @@ lp_build_float_to_srgb_packed(struct gallivm_state *gallivm,
     * can't use lp_build_conv since we want to keep values as 32bit
     * here so we can interleave with rgb to go from SoA->AoS.
     */
-   alpha = lp_build_clamp(&f32_bld, src[3], f32_bld.zero, f32_bld.one);
+   alpha = lp_build_clamp_zero_one_nanzero(&f32_bld, src[3]);
    alpha = lp_build_mul(&f32_bld, alpha,
                         lp_build_const_vec(gallivm, src_type, 255.0f));
    tmpsrgb[3] = lp_build_iround(&f32_bld, alpha);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
index e8d2db2..65c02d8 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
@@ -174,12 +174,14 @@ lp_set_target_options(void)
    }
 #endif
 
+#if HAVE_LLVM < 0x0304
    /*
     * By default LLVM adds a signal handler to output a pretty stack trace.
     * This signal handler is never removed, causing problems when unloading the
     * shared object where the gallium driver resides.
     */
    llvm::DisablePrettyStackTrace = true;
+#endif
 
    // If we have a native target, initialize it to ensure it is linked in and
    // usable by the JIT.
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample.c b/src/gallium/auxiliary/gallivm/lp_bld_sample.c
index a032d9d..e60a035 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample.c
@@ -36,6 +36,7 @@
 #include "pipe/p_state.h"
 #include "util/u_format.h"
 #include "util/u_math.h"
+#include "util/u_cpu_detect.h"
 #include "lp_bld_arit.h"
 #include "lp_bld_const.h"
 #include "lp_bld_debug.h"
@@ -248,7 +249,7 @@ lp_build_rho(struct lp_build_sample_context *bld,
    first_level = bld->dynamic_state->first_level(bld->dynamic_state,
                                                  bld->gallivm, texture_unit);
    first_level_vec = lp_build_broadcast_scalar(int_size_bld, first_level);
-   int_size = lp_build_minify(int_size_bld, bld->int_size, first_level_vec);
+   int_size = lp_build_minify(int_size_bld, bld->int_size, first_level_vec, TRUE);
    float_size = lp_build_int_to_float(float_size_bld, int_size);
 
    if (cube_rho) {
@@ -1089,12 +1090,14 @@ lp_build_get_mip_offsets(struct lp_build_sample_context *bld,
 
 /**
  * Codegen equivalent for u_minify().
+ * @param lod_scalar  if lod is a (broadcasted) scalar
  * Return max(1, base_size >> level);
  */
 LLVMValueRef
 lp_build_minify(struct lp_build_context *bld,
                 LLVMValueRef base_size,
-                LLVMValueRef level)
+                LLVMValueRef level,
+                boolean lod_scalar)
 {
    LLVMBuilderRef builder = bld->gallivm->builder;
    assert(lp_check_value(bld->type, base_size));
@@ -1105,10 +1108,49 @@ lp_build_minify(struct lp_build_context *bld,
       return base_size;
    }
    else {
-      LLVMValueRef size =
-         LLVMBuildLShr(builder, base_size, level, "minify");
+      LLVMValueRef size;
       assert(bld->type.sign);
-      size = lp_build_max(bld, size, bld->one);
+      if (lod_scalar ||
+         (util_cpu_caps.has_avx2 || !util_cpu_caps.has_sse)) {
+         size = LLVMBuildLShr(builder, base_size, level, "minify");
+         size = lp_build_max(bld, size, bld->one);
+      }
+      else {
+         /*
+          * emulate shift with float mul, since intel "forgot" shifts with
+          * per-element shift count until avx2, which results in terrible
+          * scalar extraction (both count and value), scalar shift,
+          * vector reinsertion. Should not be an issue on any non-x86 cpu
+          * with a vector instruction set.
+          * On cpus with AMD's XOP this should also be unnecessary but I'm
+          * not sure if llvm would emit this with current flags.
+          */
+         LLVMValueRef const127, const23, lf;
+         struct lp_type ftype;
+         struct lp_build_context fbld;
+         ftype = lp_type_float_vec(32, bld->type.length * bld->type.width);
+         lp_build_context_init(&fbld, bld->gallivm, ftype);
+         const127 = lp_build_const_int_vec(bld->gallivm, bld->type, 127);
+         const23 = lp_build_const_int_vec(bld->gallivm, bld->type, 23);
+
+         /* calculate 2^(-level) float */
+         lf = lp_build_sub(bld, const127, level);
+         lf = lp_build_shl(bld, lf, const23);
+         lf = LLVMBuildBitCast(builder, lf, fbld.vec_type, "");
+
+         /* finish shift operation by doing float mul */
+         base_size = lp_build_int_to_float(&fbld, base_size);
+         size = lp_build_mul(&fbld, base_size, lf);
+         /*
+          * do the max also with floats because
+          * a) non-emulated int max requires sse41
+          *    (this is actually a lie as we could cast to 16bit values
+          *    as 16bit is sufficient and 16bit int max is sse2)
+          * b) with avx we can do int max 4-wide but float max 8-wide
+          */
+         size = lp_build_max(&fbld, size, fbld.one);
+         size = lp_build_itrunc(&fbld, size);
+      }
       return size;
    }
 }
@@ -1185,7 +1227,7 @@ lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
     */
    if (bld->num_mips == 1) {
       ilevel_vec = lp_build_broadcast_scalar(&bld->int_size_bld, ilevel);
-      *out_size = lp_build_minify(&bld->int_size_bld, bld->int_size, ilevel_vec);
+      *out_size = lp_build_minify(&bld->int_size_bld, bld->int_size, ilevel_vec, TRUE);
    }
    else {
       LLVMValueRef int_size_vec;
@@ -1229,7 +1271,7 @@ lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
                                                  bld4.type,
                                                  ilevel,
                                                  indexi);
-            tmp[i] = lp_build_minify(&bld4, int_size_vec, ileveli);
+            tmp[i] = lp_build_minify(&bld4, int_size_vec, ileveli, TRUE);
          }
          /*
           * out_size is [w0, h0, d0, _, w1, h1, d1, _, ...] vector for dims > 1,
@@ -1248,7 +1290,6 @@ lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
          * with 4-wide vector pack all elements into a 8xi16 vector
          * (on which we can still do useful math) instead of using a 16xi32
          * vector.
-         * FIXME: some callers can't handle this yet.
          * For dims == 1 this will create [w0, w1, w2, w3, ...] vector.
          * For dims > 1 this will create [w0, h0, d0, _, w1, h1, d1, _, ...] vector.
          */
@@ -1257,8 +1298,7 @@ lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
             assert(bld->int_size_in_bld.type.length == 1);
             int_size_vec = lp_build_broadcast_scalar(&bld->int_coord_bld,
                                                      bld->int_size);
-            /* vector shift with variable shift count alert... */
-            *out_size = lp_build_minify(&bld->int_coord_bld, int_size_vec, ilevel);
+            *out_size = lp_build_minify(&bld->int_coord_bld, int_size_vec, ilevel, FALSE);
          }
          else {
             LLVMValueRef ilevel1;
@@ -1267,7 +1307,7 @@ lp_build_mipmap_level_sizes(struct lp_build_sample_context *bld,
                ilevel1 = lp_build_extract_broadcast(bld->gallivm, bld->int_coord_type,
                                                     bld->int_size_in_bld.type, ilevel, indexi);
                tmp[i] = bld->int_size;
-               tmp[i] = lp_build_minify(&bld->int_size_in_bld, tmp[i], ilevel1);
+               tmp[i] = lp_build_minify(&bld->int_size_in_bld, tmp[i], ilevel1, TRUE);
             }
             *out_size = lp_build_concat(bld->gallivm, tmp,
                                         bld->int_size_in_bld.type,
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample.h b/src/gallium/auxiliary/gallivm/lp_bld_sample.h
index 5039128..fd4e053 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample.h
@@ -547,7 +547,8 @@ lp_build_sample_nop(struct gallivm_state *gallivm,
 LLVMValueRef
 lp_build_minify(struct lp_build_context *bld,
                 LLVMValueRef base_size,
-                LLVMValueRef level);
+                LLVMValueRef level,
+                boolean lod_scalar);
 
 
 #endif /* LP_BLD_SAMPLE_H */
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
index 2d83331..e8c04d1 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
@@ -2940,7 +2940,7 @@ lp_build_size_query_soa(struct gallivm_state *gallivm,
                                     lp_build_const_int32(gallivm, 2), "");
    }
 
-   size = lp_build_minify(&bld_int_vec4, size, lod);
+   size = lp_build_minify(&bld_int_vec4, size, lod, TRUE);
 
    if (has_array)
       size = LLVMBuildInsertElement(gallivm->builder, size,
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_tgsi.c b/src/gallium/auxiliary/gallivm/lp_bld_tgsi.c
index 5a9e8d0..7ffeaaf 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_tgsi.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_tgsi.c
@@ -200,6 +200,10 @@ lp_build_tgsi_inst_llvm(
 
    bld_base->pc++;
 
+   if (bld_base->emit_debug) {
+      bld_base->emit_debug(bld_base, inst, info);
+   }
+
    /* Ignore deprecated instructions */
    switch (inst->Instruction.Opcode) {
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_tgsi.h b/src/gallium/auxiliary/gallivm/lp_bld_tgsi.h
index 8bcdbc8..881cd5b 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_tgsi.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_tgsi.h
@@ -352,6 +352,11 @@ struct lp_build_tgsi_context
    LLVMValueRef (*emit_swizzle)(struct lp_build_tgsi_context *,
                          LLVMValueRef, unsigned, unsigned, unsigned, unsigned);
 
+
+   void (*emit_debug)(struct lp_build_tgsi_context *,
+                      const struct tgsi_full_instruction *,
+                      const struct tgsi_opcode_info *);
+
    void (*emit_store)(struct lp_build_tgsi_context *,
                       const struct tgsi_full_instruction *,
                       const struct tgsi_opcode_info *,
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_soa.c
index e50f1d1..3e0fd1c 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_soa.c
@@ -47,6 +47,7 @@
 #include "tgsi/tgsi_parse.h"
 #include "tgsi/tgsi_util.h"
 #include "tgsi/tgsi_scan.h"
+#include "tgsi/tgsi_strings.h"
 #include "lp_bld_tgsi_action.h"
 #include "lp_bld_type.h"
 #include "lp_bld_const.h"
@@ -67,6 +68,37 @@
 
 #define DUMP_GS_EMITS 0
 
+/*
+ * If non-zero, the generated LLVM IR will print intermediate results on every TGSI
+ * instruction.
+ *
+ * TODO:
+ * - take execution masks in consideration
+ * - debug control-flow instructions
+ */
+#define DEBUG_EXECUTION 0
+
+
+/*
+ * Emit code to print a register value.
+ */
+static void
+emit_dump_reg(struct gallivm_state *gallivm,
+              unsigned file,
+              unsigned index,
+              unsigned chan,
+              LLVMValueRef value)
+{
+   char buf[32];
+
+   util_snprintf(buf, sizeof buf, "    %s[%u].%c = ",
+                 tgsi_file_name(file),
+                 index, "xyzw"[chan]);
+
+   lp_build_print_value(gallivm, buf, value);
+}
+
+
 static void lp_exec_mask_init(struct lp_exec_mask *mask, struct lp_build_context *bld)
 {
    LLVMTypeRef int_type = LLVMInt32TypeInContext(bld->gallivm->context);
@@ -664,6 +696,43 @@ static void lp_exec_mask_endsub(struct lp_exec_mask *mask, int *pc)
 }
 
 
+static LLVMValueRef
+get_file_ptr(struct lp_build_tgsi_soa_context *bld,
+             unsigned file,
+             unsigned index,
+             unsigned chan)
+{
+   LLVMBuilderRef builder = bld->bld_base.base.gallivm->builder;
+   LLVMValueRef (*array_of_vars)[TGSI_NUM_CHANNELS];
+   LLVMValueRef var_of_array;
+
+   switch (file) {
+   case TGSI_FILE_TEMPORARY:
+      array_of_vars = bld->temps;
+      var_of_array = bld->temps_array;
+      break;
+   case TGSI_FILE_OUTPUT:
+      array_of_vars = bld->outputs;
+      var_of_array = bld->outputs_array;
+      break;
+   default:
+      assert(0);
+      return NULL;
+   }
+
+   assert(chan < 4);
+
+   if (bld->indirect_files & (1 << file)) {
+      LLVMValueRef lindex = lp_build_const_int32(bld->bld_base.base.gallivm, index * 4 + chan);
+      return LLVMBuildGEP(builder, var_of_array, &lindex, 1, "");
+   }
+   else {
+      assert(index <= bld->bld_base.info->file_max[file]);
+      return array_of_vars[index][chan];
+   }
+}
+
+
 /**
  * Return pointer to a temporary register channel (src or dest).
  * Note that indirect addressing cannot be handled here.
@@ -675,15 +744,7 @@ lp_get_temp_ptr_soa(struct lp_build_tgsi_soa_context *bld,
              unsigned index,
              unsigned chan)
 {
-   LLVMBuilderRef builder = bld->bld_base.base.gallivm->builder;
-   assert(chan < 4);
-   if (bld->indirect_files & (1 << TGSI_FILE_TEMPORARY)) {
-      LLVMValueRef lindex = lp_build_const_int32(bld->bld_base.base.gallivm, index * 4 + chan);
-      return LLVMBuildGEP(builder, bld->temps_array, &lindex, 1, "");
-   }
-   else {
-      return bld->temps[index][chan];
-   }
+   return get_file_ptr(bld, TGSI_FILE_TEMPORARY, index, chan);
 }
 
 /**
@@ -697,16 +758,7 @@ lp_get_output_ptr(struct lp_build_tgsi_soa_context *bld,
                unsigned index,
                unsigned chan)
 {
-   LLVMBuilderRef builder = bld->bld_base.base.gallivm->builder;
-   assert(chan < 4);
-   if (bld->indirect_files & (1 << TGSI_FILE_OUTPUT)) {
-      LLVMValueRef lindex = lp_build_const_int32(bld->bld_base.base.gallivm,
-                                                 index * 4 + chan);
-      return LLVMBuildGEP(builder, bld->outputs_array, &lindex, 1, "");
-   }
-   else {
-      return bld->outputs[index][chan];
-   }
+   return get_file_ptr(bld, TGSI_FILE_OUTPUT, index, chan);
 }
 
 /*
@@ -898,6 +950,39 @@ stype_to_fetch(struct lp_build_tgsi_context * bld_base,
 }
 
 static LLVMValueRef
+get_soa_array_offsets(struct lp_build_context *uint_bld,
+                      LLVMValueRef indirect_index,
+                      unsigned chan_index,
+                      boolean need_perelement_offset)
+{
+   struct gallivm_state *gallivm = uint_bld->gallivm;
+   LLVMValueRef chan_vec =
+      lp_build_const_int_vec(uint_bld->gallivm, uint_bld->type, chan_index);
+   LLVMValueRef length_vec =
+      lp_build_const_int_vec(gallivm, uint_bld->type, uint_bld->type.length);
+   LLVMValueRef index_vec;
+
+   /* index_vec = (indirect_index * 4 + chan_index) * length + offsets */
+   index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
+   index_vec = lp_build_add(uint_bld, index_vec, chan_vec);
+   index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
+
+   if (need_perelement_offset) {
+      LLVMValueRef pixel_offsets;
+      int i;
+     /* build pixel offset vector: {0, 1, 2, 3, ...} */
+      pixel_offsets = uint_bld->undef;
+      for (i = 0; i < uint_bld->type.length; i++) {
+         LLVMValueRef ii = lp_build_const_int32(gallivm, i);
+         pixel_offsets = LLVMBuildInsertElement(gallivm->builder, pixel_offsets,
+                                                ii, ii, "");
+      }
+      index_vec = lp_build_add(uint_bld, index_vec, pixel_offsets);
+   }
+   return index_vec;
+}
+
+static LLVMValueRef
 emit_fetch_constant(
    struct lp_build_tgsi_context * bld_base,
    const struct tgsi_full_src_register * reg,
@@ -908,7 +993,6 @@ emit_fetch_constant(
    struct gallivm_state *gallivm = bld_base->base.gallivm;
    LLVMBuilderRef builder = gallivm->builder;
    struct lp_build_context *uint_bld = &bld_base->uint_bld;
-   LLVMValueRef indirect_index = NULL;
    unsigned dimension = 0;
    LLVMValueRef dimension_index;
    LLVMValueRef consts_ptr;
@@ -927,16 +1011,15 @@ emit_fetch_constant(
    consts_ptr = lp_build_array_get(gallivm, bld->consts_ptr, dimension_index);
 
    if (reg->Register.Indirect) {
+      LLVMValueRef indirect_index;
+      LLVMValueRef swizzle_vec =
+         lp_build_const_int_vec(gallivm, uint_bld->type, swizzle);
+      LLVMValueRef index_vec;  /* index into the const buffer */
+
       indirect_index = get_indirect_index(bld,
                                           reg->Register.File,
                                           reg->Register.Index,
                                           &reg->Indirect);
-   }
-
-   if (reg->Register.Indirect) {
-      LLVMValueRef swizzle_vec =
-         lp_build_const_int_vec(bld->bld_base.base.gallivm, uint_bld->type, swizzle);
-      LLVMValueRef index_vec;  /* index into the const buffer */
 
       /* index_vec = indirect_index * 4 + swizzle */
       index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
@@ -949,7 +1032,7 @@ emit_fetch_constant(
       LLVMValueRef index;  /* index into the const buffer */
       LLVMValueRef scalar, scalar_ptr;
 
-      index = lp_build_const_int32(gallivm, reg->Register.Index*4 + swizzle);
+      index = lp_build_const_int32(gallivm, reg->Register.Index * 4 + swizzle);
 
       scalar_ptr = LLVMBuildGEP(builder, consts_ptr,
                                 &index, 1, "");
@@ -974,51 +1057,34 @@ emit_fetch_immediate(
    struct lp_build_tgsi_soa_context * bld = lp_soa_context(bld_base);
    struct gallivm_state *gallivm = bld->bld_base.base.gallivm;
    LLVMBuilderRef builder = gallivm->builder;
-   struct lp_build_context *uint_bld = &bld_base->uint_bld;
-   struct lp_build_context *float_bld = &bld_base->base;
    LLVMValueRef res = NULL;
-   LLVMValueRef indirect_index = NULL;
 
    if (reg->Register.Indirect) {
+      LLVMValueRef indirect_index;
+      LLVMValueRef index_vec;  /* index into the immediate register array */
+      LLVMValueRef imms_array;
+      LLVMTypeRef fptr_type;
+
       indirect_index = get_indirect_index(bld,
                                           reg->Register.File,
                                           reg->Register.Index,
                                           &reg->Indirect);
-   }
-
-   if (reg->Register.Indirect) {
-      LLVMValueRef swizzle_vec =
-         lp_build_const_int_vec(bld->bld_base.base.gallivm,
-                                uint_bld->type, swizzle);
-      LLVMValueRef length_vec =
-         lp_build_const_int_vec(bld->bld_base.base.gallivm, uint_bld->type,
-                                bld->bld_base.base.type.length);
-      LLVMValueRef index_vec;  /* index into the const buffer */
-      LLVMValueRef imms_array;
-      LLVMValueRef pixel_offsets;
-      LLVMValueRef offsets[LP_MAX_VECTOR_LENGTH];
-      LLVMTypeRef float4_ptr_type;
-      int i;
-
-      /* build pixel offset vector: {0, 1, 2, 3, ...} */
-      for (i = 0; i < float_bld->type.length; i++) {
-         offsets[i] = lp_build_const_int32(gallivm, i);
-      }
-      pixel_offsets = LLVMConstVector(offsets, float_bld->type.length);
-
-      /* index_vec = (indirect_index * 4 + swizzle) * length */
-      index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
-      index_vec = lp_build_add(uint_bld, index_vec, swizzle_vec);
-      index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
-      index_vec = lp_build_add(uint_bld, index_vec, pixel_offsets);
+      /*
+       * Unlike for other reg classes, adding pixel offsets is unnecessary -
+       * immediates are stored as full vectors (FIXME??? - might be better
+       * to store them the same as constants) but all elements are the same
+       * in any case.
+       */
+      index_vec = get_soa_array_offsets(&bld_base->uint_bld,
+                                        indirect_index,
+                                        swizzle,
+                                        FALSE);
 
       /* cast imms_array pointer to float* */
-      float4_ptr_type = LLVMPointerType(
-         LLVMFloatTypeInContext(bld->bld_base.base.gallivm->context), 0);
-      imms_array = LLVMBuildBitCast(builder, bld->imms_array,
-                                    float4_ptr_type, "");
+      fptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
+      imms_array = LLVMBuildBitCast(builder, bld->imms_array, fptr_type, "");
 
-      /* Gather values from the temporary register array */
+      /* Gather values from the immediate register array */
       res = build_gather(&bld_base->base, imms_array, index_vec);
    }
    else {
@@ -1043,37 +1109,29 @@ emit_fetch_input(
    struct lp_build_tgsi_soa_context * bld = lp_soa_context(bld_base);
    struct gallivm_state *gallivm = bld->bld_base.base.gallivm;
    LLVMBuilderRef builder = gallivm->builder;
-   struct lp_build_context *uint_bld = &bld_base->uint_bld;
-   LLVMValueRef indirect_index = NULL;
    LLVMValueRef res;
 
    if (reg->Register.Indirect) {
+      LLVMValueRef indirect_index;
+      LLVMValueRef index_vec;  /* index into the input reg array */
+      LLVMValueRef inputs_array;
+      LLVMTypeRef fptr_type;
+
       indirect_index = get_indirect_index(bld,
                                           reg->Register.File,
                                           reg->Register.Index,
                                           &reg->Indirect);
-   }
 
-   if (reg->Register.Indirect) {
-      LLVMValueRef swizzle_vec =
-         lp_build_const_int_vec(gallivm, uint_bld->type, swizzle);
-      LLVMValueRef length_vec =
-         lp_build_const_int_vec(gallivm, uint_bld->type, bld->bld_base.base.type.length);
-      LLVMValueRef index_vec;  /* index into the const buffer */
-      LLVMValueRef inputs_array;
-      LLVMTypeRef float4_ptr_type;
-
-      /* index_vec = (indirect_index * 4 + swizzle) * length */
-      index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
-      index_vec = lp_build_add(uint_bld, index_vec, swizzle_vec);
-      index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
+      index_vec = get_soa_array_offsets(&bld_base->uint_bld,
+                                        indirect_index,
+                                        swizzle,
+                                        TRUE);
 
       /* cast inputs_array pointer to float* */
-      float4_ptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
-      inputs_array = LLVMBuildBitCast(builder, bld->inputs_array,
-                                         float4_ptr_type, "");
+      fptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
+      inputs_array = LLVMBuildBitCast(builder, bld->inputs_array, fptr_type, "");
 
-      /* Gather values from the temporary register array */
+      /* Gather values from the input register array */
       res = build_gather(&bld_base->base, inputs_array, index_vec);
    } else {
       if (bld->indirect_files & (1 << TGSI_FILE_INPUT)) {
@@ -1117,9 +1175,9 @@ emit_fetch_gs_input(
 
    if (reg->Register.Indirect) {
       attrib_index = get_indirect_index(bld,
-                                          reg->Register.File,
-                                          reg->Register.Index,
-                                          &reg->Indirect);
+                                        reg->Register.File,
+                                        reg->Register.Index,
+                                        &reg->Indirect);
    } else {
       attrib_index = lp_build_const_int32(gallivm, reg->Register.Index);
    }
@@ -1161,47 +1219,27 @@ emit_fetch_temporary(
    struct lp_build_tgsi_soa_context * bld = lp_soa_context(bld_base);
    struct gallivm_state *gallivm = bld->bld_base.base.gallivm;
    LLVMBuilderRef builder = gallivm->builder;
-   struct lp_build_context *uint_bld = &bld_base->uint_bld;
-   struct lp_build_context *float_bld = &bld_base->base;
-   LLVMValueRef indirect_index = NULL;
    LLVMValueRef res;
 
    if (reg->Register.Indirect) {
+      LLVMValueRef indirect_index;
+      LLVMValueRef index_vec;  /* index into the temp reg array */
+      LLVMValueRef temps_array;
+      LLVMTypeRef fptr_type;
+
       indirect_index = get_indirect_index(bld,
                                           reg->Register.File,
                                           reg->Register.Index,
                                           &reg->Indirect);
-   }
 
-   if (reg->Register.Indirect) {
-      LLVMValueRef swizzle_vec =
-         lp_build_const_int_vec(bld->bld_base.base.gallivm, uint_bld->type, swizzle);
-      LLVMValueRef length_vec =
-         lp_build_const_int_vec(bld->bld_base.base.gallivm, uint_bld->type,
-                                bld->bld_base.base.type.length);
-      LLVMValueRef index_vec;  /* index into the const buffer */
-      LLVMValueRef temps_array;
-      LLVMValueRef pixel_offsets;
-      LLVMValueRef offsets[LP_MAX_VECTOR_LENGTH];
-      LLVMTypeRef float4_ptr_type;
-      int i;
-
-      /* build pixel offset vector: {0, 1, 2, 3, ...} */
-      for (i = 0; i < float_bld->type.length; i++) {
-         offsets[i] = lp_build_const_int32(gallivm, i);
-      }
-      pixel_offsets = LLVMConstVector(offsets, float_bld->type.length);
-
-      /* index_vec = (indirect_index * 4 + swizzle) * length */
-      index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
-      index_vec = lp_build_add(uint_bld, index_vec, swizzle_vec);
-      index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
-      index_vec = lp_build_add(uint_bld, index_vec, pixel_offsets);
+      index_vec = get_soa_array_offsets(&bld_base->uint_bld,
+                                        indirect_index,
+                                        swizzle,
+                                        TRUE);
 
       /* cast temps_array pointer to float* */
-      float4_ptr_type = LLVMPointerType(LLVMFloatTypeInContext(bld->bld_base.base.gallivm->context), 0);
-      temps_array = LLVMBuildBitCast(builder, bld->temps_array,
-                                     float4_ptr_type, "");
+      fptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
+      temps_array = LLVMBuildBitCast(builder, bld->temps_array, fptr_type, "");
 
       /* Gather values from the temporary register array */
       res = build_gather(&bld_base->base, temps_array, index_vec);
@@ -1363,6 +1401,7 @@ emit_fetch_predicate(
    }
 }
 
+
 /**
  * Register store.
  */
@@ -1381,7 +1420,6 @@ emit_store_chan(
    const struct tgsi_full_dst_register *reg = &inst->Dst[index];
    struct lp_build_context *float_bld = &bld_base->base;
    struct lp_build_context *int_bld = &bld_base->int_bld;
-   struct lp_build_context *uint_bld = &bld_base->uint_bld;
    LLVMValueRef indirect_index = NULL;
    enum tgsi_opcode_type dtype = tgsi_opcode_infer_dst_type(inst->Instruction.Opcode);
 
@@ -1398,21 +1436,18 @@ emit_store_chan(
       assert(dtype == TGSI_TYPE_FLOAT ||
              dtype == TGSI_TYPE_UNTYPED);
       value = LLVMBuildBitCast(builder, value, float_bld->vec_type, "");
-      value = lp_build_max_ext(float_bld, value, float_bld->zero,
-                               GALLIVM_NAN_RETURN_SECOND);
-      value = lp_build_min_ext(float_bld, value, float_bld->one,
-                               GALLIVM_NAN_BEHAVIOR_UNDEFINED);
+      value = lp_build_clamp_zero_one_nanzero(float_bld, value);
       break;
 
    case TGSI_SAT_MINUS_PLUS_ONE:
       assert(dtype == TGSI_TYPE_FLOAT ||
              dtype == TGSI_TYPE_UNTYPED);
       value = LLVMBuildBitCast(builder, value, float_bld->vec_type, "");
+      /* This will give -1.0 for NaN which is probably not what we want. */
       value = lp_build_max_ext(float_bld, value,
                                lp_build_const_vec(gallivm, float_bld->type, -1.0),
-                               GALLIVM_NAN_RETURN_SECOND);
-      value = lp_build_min_ext(float_bld, value, float_bld->one,
-                               GALLIVM_NAN_BEHAVIOR_UNDEFINED);
+                               GALLIVM_NAN_RETURN_OTHER_SECOND_NONNAN);
+      value = lp_build_min(float_bld, value, float_bld->one);
       break;
 
    default:
@@ -1429,42 +1464,29 @@ emit_store_chan(
                              bld_base->info->file_max[reg->Register.File]);
    }
 
+   if (DEBUG_EXECUTION) {
+      emit_dump_reg(gallivm, reg->Register.File, reg->Register.Index, chan_index, value);
+   }
+
    switch( reg->Register.File ) {
    case TGSI_FILE_OUTPUT:
       /* Outputs are always stored as floats */
       value = LLVMBuildBitCast(builder, value, float_bld->vec_type, "");
 
       if (reg->Register.Indirect) {
-         LLVMValueRef chan_vec =
-            lp_build_const_int_vec(gallivm, uint_bld->type, chan_index);
-         LLVMValueRef length_vec =
-            lp_build_const_int_vec(gallivm, uint_bld->type, float_bld->type.length);
-         LLVMValueRef index_vec;  /* indexes into the temp registers */
+         LLVMValueRef index_vec;  /* indexes into the output registers */
          LLVMValueRef outputs_array;
-         LLVMValueRef pixel_offsets;
-         LLVMTypeRef float_ptr_type;
-         int i;
-
-         /* build pixel offset vector: {0, 1, 2, 3, ...} */
-         pixel_offsets = uint_bld->undef;
-         for (i = 0; i < float_bld->type.length; i++) {
-            LLVMValueRef ii = lp_build_const_int32(gallivm, i);
-            pixel_offsets = LLVMBuildInsertElement(builder, pixel_offsets,
-                                                   ii, ii, "");
-         }
+         LLVMTypeRef fptr_type;
 
-         /* index_vec = (indirect_index * 4 + chan_index) * length + offsets */
-         index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
-         index_vec = lp_build_add(uint_bld, index_vec, chan_vec);
-         index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
-         index_vec = lp_build_add(uint_bld, index_vec, pixel_offsets);
+         index_vec = get_soa_array_offsets(&bld_base->uint_bld,
+                                           indirect_index,
+                                           chan_index,
+                                           TRUE);
 
-         float_ptr_type =
-            LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
-         outputs_array = LLVMBuildBitCast(builder, bld->outputs_array,
-                                          float_ptr_type, "");
+         fptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
+         outputs_array = LLVMBuildBitCast(builder, bld->outputs_array, fptr_type, "");
 
-         /* Scatter store values into temp registers */
+         /* Scatter store values into output registers */
          emit_mask_scatter(bld, outputs_array, index_vec, value,
                            &bld->exec_mask, pred);
       }
@@ -1480,35 +1502,17 @@ emit_store_chan(
       value = LLVMBuildBitCast(builder, value, float_bld->vec_type, "");
 
       if (reg->Register.Indirect) {
-         LLVMValueRef chan_vec =
-            lp_build_const_int_vec(gallivm, uint_bld->type, chan_index);
-         LLVMValueRef length_vec =
-            lp_build_const_int_vec(gallivm, uint_bld->type,
-                                   float_bld->type.length);
          LLVMValueRef index_vec;  /* indexes into the temp registers */
          LLVMValueRef temps_array;
-         LLVMValueRef pixel_offsets;
-         LLVMTypeRef float_ptr_type;
-         int i;
-
-         /* build pixel offset vector: {0, 1, 2, 3, ...} */
-         pixel_offsets = uint_bld->undef; 
-         for (i = 0; i < float_bld->type.length; i++) {
-            LLVMValueRef ii = lp_build_const_int32(gallivm, i);
-            pixel_offsets = LLVMBuildInsertElement(builder, pixel_offsets,
-                                                   ii, ii, "");
-         }
+         LLVMTypeRef fptr_type;
 
-         /* index_vec = (indirect_index * 4 + chan_index) * length + offsets */
-         index_vec = lp_build_shl_imm(uint_bld, indirect_index, 2);
-         index_vec = lp_build_add(uint_bld, index_vec, chan_vec);
-         index_vec = lp_build_mul(uint_bld, index_vec, length_vec);
-         index_vec = lp_build_add(uint_bld, index_vec, pixel_offsets);
+         index_vec = get_soa_array_offsets(&bld_base->uint_bld,
+                                           indirect_index,
+                                           chan_index,
+                                           TRUE);
 
-         float_ptr_type =
-            LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
-         temps_array = LLVMBuildBitCast(builder, bld->temps_array,
-                                        float_ptr_type, "");
+         fptr_type = LLVMPointerType(LLVMFloatTypeInContext(gallivm->context), 0);
+         temps_array = LLVMBuildBitCast(builder, bld->temps_array, fptr_type, "");
 
          /* Scatter store values into temp registers */
          emit_mask_scatter(bld, temps_array, index_vec, value,
@@ -1516,8 +1520,7 @@ emit_store_chan(
       }
       else {
          LLVMValueRef temp_ptr;
-         temp_ptr = lp_get_temp_ptr_soa(bld, reg->Register.Index,
-                                        chan_index);
+         temp_ptr = lp_get_temp_ptr_soa(bld, reg->Register.Index, chan_index);
          lp_exec_mask_store(&bld->exec_mask, float_bld, pred, value, temp_ptr);
       }
       break;
@@ -1544,6 +1547,39 @@ emit_store_chan(
    (void)dtype;
 }
 
+/*
+ * Called at the beginning of the translation of each TGSI instruction, to
+ * emit some debug code.
+ */
+static void
+emit_debug(
+   struct lp_build_tgsi_context * bld_base,
+   const struct tgsi_full_instruction * inst,
+   const struct tgsi_opcode_info * info)
+
+{
+   struct lp_build_tgsi_soa_context * bld = lp_soa_context(bld_base);
+
+   if (DEBUG_EXECUTION) {
+      /*
+       * Dump the TGSI instruction.
+       */
+
+      struct gallivm_state *gallivm = bld_base->base.gallivm;
+      char buf[512];
+      buf[0] = '$';
+      buf[1] = ' ';
+      tgsi_dump_instruction_str(inst, bld_base->pc, &buf[2], sizeof buf - 2);
+      lp_build_printf(gallivm, buf);
+
+      /* Dump the execution mask.
+       */
+      if (bld->exec_mask.has_mask) {
+         lp_build_print_value(gallivm, "    mask = ", bld->exec_mask.exec_mask);
+      }
+   }
+}
+
 static void
 emit_store(
    struct lp_build_tgsi_context * bld_base,
@@ -2303,42 +2339,78 @@ emit_kill(struct lp_build_tgsi_soa_context *bld,
  * to stdout.
  */
 static void
-emit_dump_temps(struct lp_build_tgsi_soa_context *bld)
+emit_dump_file(struct lp_build_tgsi_soa_context *bld,
+               unsigned file)
 {
+   const struct tgsi_shader_info *info = bld->bld_base.info;
    struct gallivm_state *gallivm = bld->bld_base.base.gallivm;
    LLVMBuilderRef builder = gallivm->builder;
-   LLVMValueRef temp_ptr;
-   LLVMValueRef i0 = lp_build_const_int32(gallivm, 0);
-   LLVMValueRef i1 = lp_build_const_int32(gallivm, 1);
-   LLVMValueRef i2 = lp_build_const_int32(gallivm, 2);
-   LLVMValueRef i3 = lp_build_const_int32(gallivm, 3);
+   LLVMValueRef reg_ptr;
    int index;
-   int n = bld->bld_base.info->file_max[TGSI_FILE_TEMPORARY];
+   int max_index = info->file_max[file];
 
-   for (index = 0; index < n; index++) {
-      LLVMValueRef idx = lp_build_const_int32(gallivm, index);
-      LLVMValueRef v[4][4], res;
+   /*
+    * Some register files, particularly constants, can be very large,
+    * and dumping everything could make this unusably slow.
+    */
+   max_index = MIN2(max_index, 32);
+
+   for (index = 0; index <= max_index; index++) {
+      LLVMValueRef res;
+      unsigned mask;
       int chan;
 
-      lp_build_printf(gallivm, "TEMP[%d]:\n", idx);
+      if (index < 8 * sizeof(unsigned) &&
+          (info->file_mask[file] & (1 << index)) == 0)  {
+         /* This was not declared.*/
+         continue;
+      }
 
-      for (chan = 0; chan < 4; chan++) {
-         temp_ptr = lp_get_temp_ptr_soa(bld, index, chan);
-         res = LLVMBuildLoad(builder, temp_ptr, "");
-         v[chan][0] = LLVMBuildExtractElement(builder, res, i0, "");
-         v[chan][1] = LLVMBuildExtractElement(builder, res, i1, "");
-         v[chan][2] = LLVMBuildExtractElement(builder, res, i2, "");
-         v[chan][3] = LLVMBuildExtractElement(builder, res, i3, "");
+      if (file == TGSI_FILE_INPUT) {
+         mask = info->input_usage_mask[index];
+      } else {
+         mask = TGSI_WRITEMASK_XYZW;
       }
 
-      lp_build_printf(gallivm, "  X: %f %f %f %f\n",
-                      v[0][0], v[0][1], v[0][2], v[0][3]);
-      lp_build_printf(gallivm, "  Y: %f %f %f %f\n",
-                      v[1][0], v[1][1], v[1][2], v[1][3]);
-      lp_build_printf(gallivm, "  Z: %f %f %f %f\n",
-                      v[2][0], v[2][1], v[2][2], v[2][3]);
-      lp_build_printf(gallivm, "  W: %f %f %f %f\n",
-                      v[3][0], v[3][1], v[3][2], v[3][3]);
+      for (chan = 0; chan < 4; chan++) {
+         if ((mask & (1 << chan)) == 0) {
+            /* This channel is not used.*/
+            continue;
+         }
+
+         if (file == TGSI_FILE_CONSTANT) {
+            struct tgsi_full_src_register reg;
+            memset(&reg, 0, sizeof reg);
+            reg.Register.File = file;
+            reg.Register.Index = index;
+            reg.Register.SwizzleX = 0;
+            reg.Register.SwizzleY = 1;
+            reg.Register.SwizzleZ = 2;
+            reg.Register.SwizzleW = 3;
+
+            res = bld->bld_base.emit_fetch_funcs[file](&bld->bld_base, &reg, TGSI_TYPE_FLOAT, chan);
+            if (!res) {
+               continue;
+            }
+         } else if (file == TGSI_FILE_INPUT) {
+            res = bld->inputs[index][chan];
+            if (!res) {
+               continue;
+            }
+         } else if (file == TGSI_FILE_TEMPORARY) {
+            reg_ptr = lp_get_temp_ptr_soa(bld, index, chan);
+            assert(reg_ptr);
+            res = LLVMBuildLoad(builder, reg_ptr, "");
+         } else if (file == TGSI_FILE_OUTPUT) {
+            reg_ptr = lp_get_output_ptr(bld, index, chan);
+            assert(reg_ptr);
+            res = LLVMBuildLoad(builder, reg_ptr, "");
+         } else {
+            assert(0);
+         }
+
+         emit_dump_reg(gallivm, file, index, chan, res);
+      }
    }
 }
 
@@ -3224,6 +3296,12 @@ static void emit_prologue(struct lp_build_tgsi_context * bld_base)
       LLVMBuildStore(gallivm->builder, uint_bld->zero,
                      bld->total_emitted_vertices_vec_ptr);
    }
+
+   if (DEBUG_EXECUTION) {
+      lp_build_printf(gallivm, "\n");
+      emit_dump_file(bld, TGSI_FILE_CONSTANT);
+      emit_dump_file(bld, TGSI_FILE_INPUT);
+   }
 }
 
 static void emit_epilogue(struct lp_build_tgsi_context * bld_base)
@@ -3231,9 +3309,13 @@ static void emit_epilogue(struct lp_build_tgsi_context * bld_base)
    struct lp_build_tgsi_soa_context * bld = lp_soa_context(bld_base);
    LLVMBuilderRef builder = bld_base->base.gallivm->builder;
 
-   if (0) {
+   if (DEBUG_EXECUTION) {
       /* for debugging */
-      emit_dump_temps(bld);
+      if (0) {
+         emit_dump_file(bld, TGSI_FILE_TEMPORARY);
+      }
+      emit_dump_file(bld, TGSI_FILE_OUTPUT);
+      lp_build_printf(bld_base->base.gallivm, "\n");
    }
 
    /* If we have indirect addressing in outputs we need to copy our alloca array
@@ -3298,6 +3380,7 @@ lp_build_tgsi_soa(struct gallivm_state *gallivm,
    bld.indirect_files = info->indirect_files;
 
    bld.bld_base.soa = TRUE;
+   bld.bld_base.emit_debug = emit_debug;
    bld.bld_base.emit_fetch_funcs[TGSI_FILE_CONSTANT] = emit_fetch_constant;
    bld.bld_base.emit_fetch_funcs[TGSI_FILE_IMMEDIATE] = emit_fetch_immediate;
    bld.bld_base.emit_fetch_funcs[TGSI_FILE_INPUT] = emit_fetch_input;
diff --git a/src/gallium/auxiliary/indices/u_indices.c b/src/gallium/auxiliary/indices/u_indices.c
index 30b54b9..1b33f41 100644
--- a/src/gallium/auxiliary/indices/u_indices.c
+++ b/src/gallium/auxiliary/indices/u_indices.c
@@ -42,6 +42,27 @@ static void translate_memcpy_uint( const void *in,
 }
                               
 
+/**
+ * Translate indexes when a driver can't support certain types
+ * of drawing.  Example include:
+ * - Translate 1-byte indexes into 2-byte indexes
+ * - Translate PIPE_PRIM_QUADS into PIPE_PRIM_TRIANGLES when the hardware
+ *   doesn't support the former.
+ * - Translate from first provoking vertex to last provoking vertex and
+ *   vice versa.
+ *
+ * \param hw_mask  mask of (1 << PIPE_PRIM_x) flags indicating which types
+ *                 of primitives are supported by the hardware.
+ * \param prim  incoming PIPE_PRIM_x
+ * \param in_index_size  bytes per index value (1, 2 or 4)
+ * \param nr  number of incoming vertices
+ * \param in_pv  incoming provoking vertex convention (PV_FIRST or PV_LAST)
+ * \param out_pv  desired provoking vertex convention (PV_FIRST or PV_LAST)
+ * \param out_prim  returns new PIPE_PRIM_x we'll translate to
+ * \param out_index_size  returns bytes per new index value (2 or 4)
+ * \param out_nr  returns number of new vertices
+ * \param out_translate  returns the translation function to use by the caller
+ */
 int u_index_translator( unsigned hw_mask,
                         unsigned prim,
                         unsigned in_index_size,
@@ -57,6 +78,10 @@ int u_index_translator( unsigned hw_mask,
    unsigned out_idx;
    int ret = U_TRANSLATE_NORMAL;
 
+   assert(in_index_size == 1 ||
+          in_index_size == 2 ||
+          in_index_size == 4);
+
    u_index_init();
 
    in_idx = in_size_idx(in_index_size);
@@ -67,6 +92,7 @@ int u_index_translator( unsigned hw_mask,
        in_index_size == *out_index_size &&
        in_pv == out_pv) 
    {
+      /* Index translation not really needed */
       if (in_index_size == 4)
          *out_translate = translate_memcpy_uint;
       else
diff --git a/src/gallium/auxiliary/os/os_thread.h b/src/gallium/auxiliary/os/os_thread.h
index e153ab4..4528abb 100644
--- a/src/gallium/auxiliary/os/os_thread.h
+++ b/src/gallium/auxiliary/os/os_thread.h
@@ -41,7 +41,7 @@
 #include "util/u_debug.h" /* for assert */
 
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_HURD)
 
 #include <pthread.h> /* POSIX threads headers */
 #include <stdio.h> /* for perror() */
@@ -316,7 +316,7 @@ typedef int64_t pipe_condvar;
  * pipe_barrier
  */
 
-#if (defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)) && !defined(PIPE_OS_ANDROID)
+#if (defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HURD)) && !defined(PIPE_OS_ANDROID)
 
 typedef pthread_barrier_t pipe_barrier;
 
@@ -444,7 +444,7 @@ pipe_semaphore_wait(pipe_semaphore *sema)
  */
 
 typedef struct {
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_HURD)
    pthread_key_t key;
 #elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
    DWORD key;
@@ -459,7 +459,7 @@ typedef struct {
 static INLINE void
 pipe_tsd_init(pipe_tsd *tsd)
 {
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_HURD)
    if (pthread_key_create(&tsd->key, NULL/*free*/) != 0) {
       perror("pthread_key_create(): failed to allocate key for thread specific data");
       exit(-1);
@@ -476,7 +476,7 @@ pipe_tsd_get(pipe_tsd *tsd)
    if (tsd->initMagic != (int) PIPE_TSD_INIT_MAGIC) {
       pipe_tsd_init(tsd);
    }
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_HURD)
    return pthread_getspecific(tsd->key);
 #elif defined(PIPE_SUBSYSTEM_WINDOWS_USER)
    assert(0);
@@ -493,7 +493,7 @@ pipe_tsd_set(pipe_tsd *tsd, void *value)
    if (tsd->initMagic != (int) PIPE_TSD_INIT_MAGIC) {
       pipe_tsd_init(tsd);
    }
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_HURD)
    if (pthread_setspecific(tsd->key, value) != 0) {
       perror("pthread_set_specific() failed");
       exit(-1);
diff --git a/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c b/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
index 339d7bf..927fb24 100644
--- a/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
+++ b/src/gallium/auxiliary/pipe-loader/pipe_loader_drm.c
@@ -88,6 +88,9 @@ find_drm_pci_id(struct pipe_loader_drm_device *ddev)
               &ddev->base.u.pci.chip_id) != 2)
       goto fail;
 
+   udev_device_unref(device);
+   udev_unref(udev);
+
    return TRUE;
 
   fail:
diff --git a/src/gallium/auxiliary/rtasm/rtasm_execmem.c b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
index 3c4b048..edc1b66 100644
--- a/src/gallium/auxiliary/rtasm/rtasm_execmem.c
+++ b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
@@ -38,7 +38,7 @@
 
 #include "rtasm_execmem.h"
 
-#if defined(PIPE_OS_BSD)
+#ifndef MAP_ANONYMOUS
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
diff --git a/src/gallium/auxiliary/tgsi/tgsi_dump.c b/src/gallium/auxiliary/tgsi/tgsi_dump.c
index 7f6a3d8..77bca62 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_dump.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_dump.c
@@ -721,3 +721,26 @@ tgsi_dump_str(
 
    tgsi_iterate_shader( tokens, &ctx.base.iter );
 }
+
+void
+tgsi_dump_instruction_str(
+   const struct tgsi_full_instruction *inst,
+   uint instno,
+   char *str,
+   size_t size)
+{
+   struct str_dump_ctx ctx;
+
+   ctx.base.instno = instno;
+   ctx.base.immno = instno;
+   ctx.base.indent = 0;
+   ctx.base.dump_printf = &str_dump_ctx_printf;
+   ctx.base.indentation = 0;
+
+   ctx.str = str;
+   ctx.str[0] = 0;
+   ctx.ptr = str;
+   ctx.left = (int)size;
+
+   iter_instruction( &ctx.base.iter, (struct tgsi_full_instruction *)inst );
+}
diff --git a/src/gallium/auxiliary/tgsi/tgsi_dump.h b/src/gallium/auxiliary/tgsi/tgsi_dump.h
index adaef9d..9820bb1 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_dump.h
+++ b/src/gallium/auxiliary/tgsi/tgsi_dump.h
@@ -58,6 +58,13 @@ tgsi_dump_immediate(
    const struct tgsi_full_immediate *imm );
 
 void
+tgsi_dump_instruction_str(
+   const struct tgsi_full_instruction *inst,
+   uint instno,
+   char *str,
+   size_t size);
+
+void
 tgsi_dump_instruction(
    const struct tgsi_full_instruction *inst,
    uint instno );
diff --git a/src/gallium/auxiliary/tgsi/tgsi_scan.c b/src/gallium/auxiliary/tgsi/tgsi_scan.c
index 05b7111..0f10556 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_scan.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_scan.c
@@ -60,6 +60,8 @@ tgsi_scan_shader(const struct tgsi_token *tokens,
    memset(info, 0, sizeof(*info));
    for (i = 0; i < TGSI_FILE_COUNT; i++)
       info->file_max[i] = -1;
+   for (i = 0; i < Elements(info->const_file_max); i++)
+      info->const_file_max[i] = -1;
 
    /**
     ** Setup to begin parsing input shader
@@ -172,7 +174,16 @@ tgsi_scan_shader(const struct tgsi_token *tokens,
                info->file_count[file]++;
                info->file_max[file] = MAX2(info->file_max[file], (int)reg);
 
-               if (file == TGSI_FILE_INPUT) {
+               if (file == TGSI_FILE_CONSTANT) {
+                  int buffer = 0;
+
+                  if (fulldecl->Declaration.Dimension)
+                     buffer = fulldecl->Dim.Index2D;
+
+                  info->const_file_max[buffer] =
+                        MAX2(info->const_file_max[buffer], (int)reg);
+               }
+               else if (file == TGSI_FILE_INPUT) {
                   info->input_semantic_name[reg] = (ubyte) semName;
                   info->input_semantic_index[reg] = (ubyte) semIndex;
                   info->input_interpolate[reg] = (ubyte)fulldecl->Interp.Interpolate;
diff --git a/src/gallium/auxiliary/tgsi/tgsi_scan.h b/src/gallium/auxiliary/tgsi/tgsi_scan.h
index d9147bd..9f45c36 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_scan.h
+++ b/src/gallium/auxiliary/tgsi/tgsi_scan.h
@@ -59,6 +59,7 @@ struct tgsi_shader_info
    uint file_mask[TGSI_FILE_COUNT];  /**< bitmask of declared registers */
    uint file_count[TGSI_FILE_COUNT];  /**< number of declared registers */
    int file_max[TGSI_FILE_COUNT];  /**< highest index of declared registers */
+   int const_file_max[PIPE_MAX_CONSTANT_BUFFERS];
 
    uint immediate_count; /**< number of immediates declared */
    uint num_instructions;
diff --git a/src/gallium/auxiliary/util/u_format.c b/src/gallium/auxiliary/util/u_format.c
index 9ef3bb5..6b602bf 100644
--- a/src/gallium/auxiliary/util/u_format.c
+++ b/src/gallium/auxiliary/util/u_format.c
@@ -215,9 +215,8 @@ util_format_is_supported(enum pipe_format format, unsigned bind)
  * default MRD will be 1.0 / ((1 << 24) - 1).
  */
 double
-util_get_depth_format_mrd(enum pipe_format format)
+util_get_depth_format_mrd(const struct util_format_description *desc)
 {
-   struct util_format_description *format_desc;
    /*
     * Depth buffer formats without a depth component OR scenarios
     * without a bound depth buffer default to D24.
@@ -225,23 +224,20 @@ util_get_depth_format_mrd(enum pipe_format format)
    double mrd = 1.0 / ((1 << 24) - 1);
    unsigned depth_channel;
 
-   format_desc = (struct util_format_description *)
-                     util_format_description(format);
-
-   assert(format_desc);
+   assert(desc);
 
    /*
     * Some depth formats do not store the depth component in the first
     * channel, detect the format and adjust the depth channel. Get the
     * swizzled depth component channel.
     */
-   depth_channel = format_desc->swizzle[0];
+   depth_channel = desc->swizzle[0];
 
-   if (format_desc->channel[depth_channel].type == UTIL_FORMAT_TYPE_UNSIGNED &&
-       format_desc->channel[depth_channel].normalized) {
+   if (desc->channel[depth_channel].type == UTIL_FORMAT_TYPE_UNSIGNED &&
+       desc->channel[depth_channel].normalized) {
       int depth_bits;
 
-      depth_bits = format_desc->channel[depth_channel].size;
+      depth_bits = desc->channel[depth_channel].size;
       mrd = 1.0 / ((1ULL << depth_bits) - 1);
    }
 
diff --git a/src/gallium/auxiliary/util/u_format.h b/src/gallium/auxiliary/util/u_format.h
index dc777c3..0fbaf4c 100644
--- a/src/gallium/auxiliary/util/u_format.h
+++ b/src/gallium/auxiliary/util/u_format.h
@@ -546,13 +546,29 @@ util_format_is_depth_and_stencil(enum pipe_format format)
 
 
 /**
+ * Calculates the depth format type based upon the incoming format description.
+ */
+static INLINE unsigned
+util_get_depth_format_type(const struct util_format_description *desc)
+{
+   unsigned depth_channel = desc->swizzle[0];
+   if (desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS &&
+       depth_channel != UTIL_FORMAT_SWIZZLE_NONE) {
+      return desc->channel[depth_channel].type;
+   } else {
+      return UTIL_FORMAT_TYPE_VOID;
+   }
+}
+
+
+/**
  * Calculates the MRD for the depth format. MRD is used in depth bias
  * for UNORM and unbound depth buffers. When the depth buffer is floating
  * point, the depth bias calculation does not use the MRD. However, the
  * default MRD will be 1.0 / ((1 << 24) - 1).
  */
 double
-util_get_depth_format_mrd(enum pipe_format format);
+util_get_depth_format_mrd(const struct util_format_description *desc);
 
 
 /**
@@ -696,6 +712,9 @@ util_format_is_rgba8_variant(const struct util_format_description *desc)
       if(desc->channel[chan].type != UTIL_FORMAT_TYPE_UNSIGNED &&
          desc->channel[chan].type != UTIL_FORMAT_TYPE_VOID)
          return FALSE;
+      if(desc->channel[chan].type == UTIL_FORMAT_TYPE_UNSIGNED &&
+         !desc->channel[chan].normalized)
+         return FALSE;
       if(desc->channel[chan].size != 8)
          return FALSE;
    }
diff --git a/src/gallium/auxiliary/util/u_framebuffer.c b/src/gallium/auxiliary/util/u_framebuffer.c
index 7803ec6..f84485d 100644
--- a/src/gallium/auxiliary/util/u_framebuffer.c
+++ b/src/gallium/auxiliary/util/u_framebuffer.c
@@ -88,7 +88,8 @@ util_copy_framebuffer_state(struct pipe_framebuffer_state *dst,
    for (i = 0; i < src->nr_cbufs; i++)
       pipe_surface_reference(&dst->cbufs[i], src->cbufs[i]);
 
-   for (i = src->nr_cbufs; i < dst->nr_cbufs; i++)
+   /* Set remaining dest cbuf pointers to NULL */
+   for ( ; i < Elements(dst->cbufs); i++)
       pipe_surface_reference(&dst->cbufs[i], NULL);
 
    dst->nr_cbufs = src->nr_cbufs;
diff --git a/src/gallium/auxiliary/util/u_math.h b/src/gallium/auxiliary/util/u_math.h
index f5c14ef..426d5da 100644
--- a/src/gallium/auxiliary/util/u_math.h
+++ b/src/gallium/auxiliary/util/u_math.h
@@ -246,6 +246,19 @@ union di {
 
 
 /**
+ * Extract the IEEE float32 exponent.
+ */
+static INLINE signed
+util_get_float32_exponent(float x) {
+   union fi f;
+
+   f.f = x;
+
+   return ((f.ui >> 23) & 0xff) - 127;
+}
+
+
+/**
  * Fast version of 2^x
  * Identity: exp2(a + b) = exp2(a) * exp2(b)
  * Let ipart = int(x)
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
index ca4eb3e..1e69108 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
@@ -82,6 +82,65 @@ static const unsigned const_empty_block_mask_420[3][2][2] = {
    { { 0x01, 0x01 },  { 0x01, 0x01 } }
 };
 
+struct video_buffer_private
+{
+   struct pipe_sampler_view *sampler_view_planes[VL_NUM_COMPONENTS];
+   struct pipe_surface      *surfaces[VL_MAX_SURFACES];
+
+   struct vl_mpeg12_buffer *buffer;
+};
+
+static void
+vl_mpeg12_destroy_buffer(struct vl_mpeg12_buffer *buf);
+
+static void
+destroy_video_buffer_private(void *private)
+{
+   struct video_buffer_private *priv = private;
+   unsigned i;
+
+   for (i = 0; i < VL_NUM_COMPONENTS; ++i)
+      pipe_sampler_view_reference(&priv->sampler_view_planes[i], NULL);
+
+   for (i = 0; i < VL_MAX_SURFACES; ++i)
+      pipe_surface_reference(&priv->surfaces[i], NULL);
+
+   if (priv->buffer)
+      vl_mpeg12_destroy_buffer(priv->buffer);
+
+   FREE(priv);
+}
+
+static struct video_buffer_private *
+get_video_buffer_private(struct vl_mpeg12_decoder *dec, struct pipe_video_buffer *buf)
+{
+   struct pipe_context *pipe = dec->context;
+   struct video_buffer_private *priv;
+   struct pipe_sampler_view **sv;
+   struct pipe_surface **surf;
+   unsigned i;
+
+   priv = vl_video_buffer_get_associated_data(buf, &dec->base);
+   if (priv)
+      return priv;
+
+   priv = CALLOC_STRUCT(video_buffer_private);
+
+   sv = buf->get_sampler_view_planes(buf);
+   for (i = 0; i < VL_NUM_COMPONENTS; ++i)
+      if (sv[i])
+         priv->sampler_view_planes[i] = pipe->create_sampler_view(pipe, sv[i]->texture, sv[i]);
+
+   surf = buf->get_surfaces(buf);
+   for (i = 0; i < VL_MAX_SURFACES; ++i)
+      if (surf[i])
+         priv->surfaces[i] = pipe->create_surface(pipe, surf[i]->texture, surf[i]);
+
+   vl_video_buffer_set_associated_data(buf, &dec->base, priv, destroy_video_buffer_private);
+
+   return priv;
+}
+
 static bool
 init_zscan_buffer(struct vl_mpeg12_decoder *dec, struct vl_mpeg12_buffer *buffer)
 {
@@ -103,7 +162,7 @@ init_zscan_buffer(struct vl_mpeg12_decoder *dec, struct vl_mpeg12_buffer *buffer
    res_tmpl.usage = PIPE_USAGE_STREAM;
    res_tmpl.bind = PIPE_BIND_SAMPLER_VIEW;
 
-   res = dec->base.context->screen->resource_create(dec->base.context->screen, &res_tmpl);
+   res = dec->context->screen->resource_create(dec->context->screen, &res_tmpl);
    if (!res)
       goto error_source;
 
@@ -111,7 +170,7 @@ init_zscan_buffer(struct vl_mpeg12_decoder *dec, struct vl_mpeg12_buffer *buffer
    memset(&sv_tmpl, 0, sizeof(sv_tmpl));
    u_sampler_view_default_template(&sv_tmpl, res, res->format);
    sv_tmpl.swizzle_r = sv_tmpl.swizzle_g = sv_tmpl.swizzle_b = sv_tmpl.swizzle_a = PIPE_SWIZZLE_RED;
-   buffer->zscan_source = dec->base.context->create_sampler_view(dec->base.context, res, &sv_tmpl);
+   buffer->zscan_source = dec->context->create_sampler_view(dec->context, res, &sv_tmpl);
    pipe_resource_reference(&res, NULL);
    if (!buffer->zscan_source)
       goto error_sampler;
@@ -384,9 +443,8 @@ UploadYcbcrBlocks(struct vl_mpeg12_decoder *dec,
 }
 
 static void
-vl_mpeg12_destroy_buffer(void *buffer)
+vl_mpeg12_destroy_buffer(struct vl_mpeg12_buffer *buf)
 {
-   struct vl_mpeg12_buffer *buf = buffer;
 
    assert(buf);
 
@@ -407,11 +465,11 @@ vl_mpeg12_destroy(struct pipe_video_codec *decoder)
    assert(decoder);
 
    /* Asserted in softpipe_delete_fs_state() for some reason */
-   dec->base.context->bind_vs_state(dec->base.context, NULL);
-   dec->base.context->bind_fs_state(dec->base.context, NULL);
+   dec->context->bind_vs_state(dec->context, NULL);
+   dec->context->bind_fs_state(dec->context, NULL);
 
-   dec->base.context->delete_depth_stencil_alpha_state(dec->base.context, dec->dsa);
-   dec->base.context->delete_sampler_state(dec->base.context, dec->sampler_ycbcr);
+   dec->context->delete_depth_stencil_alpha_state(dec->context, dec->dsa);
+   dec->context->delete_sampler_state(dec->context, dec->sampler_ycbcr);
 
    vl_mc_cleanup(&dec->mc_y);
    vl_mc_cleanup(&dec->mc_c);
@@ -426,8 +484,8 @@ vl_mpeg12_destroy(struct pipe_video_codec *decoder)
    vl_zscan_cleanup(&dec->zscan_y);
    vl_zscan_cleanup(&dec->zscan_c);
 
-   dec->base.context->delete_vertex_elements_state(dec->base.context, dec->ves_ycbcr);
-   dec->base.context->delete_vertex_elements_state(dec->base.context, dec->ves_mv);
+   dec->context->delete_vertex_elements_state(dec->context, dec->ves_ycbcr);
+   dec->context->delete_vertex_elements_state(dec->context, dec->ves_mv);
 
    pipe_resource_reference(&dec->quads.buffer, NULL);
    pipe_resource_reference(&dec->pos.buffer, NULL);
@@ -440,19 +498,22 @@ vl_mpeg12_destroy(struct pipe_video_codec *decoder)
       if (dec->dec_buffers[i])
          vl_mpeg12_destroy_buffer(dec->dec_buffers[i]);
 
+   dec->context->destroy(dec->context);
+
    FREE(dec);
 }
 
 static struct vl_mpeg12_buffer *
 vl_mpeg12_get_decode_buffer(struct vl_mpeg12_decoder *dec, struct pipe_video_buffer *target)
 {
+   struct video_buffer_private *priv;
    struct vl_mpeg12_buffer *buffer;
 
    assert(dec);
 
-   buffer = vl_video_buffer_get_associated_data(target, &dec->base);
-   if (buffer)
-      return buffer;
+   priv = get_video_buffer_private(dec, target);
+   if (priv->buffer)
+      return priv->buffer;
 
    buffer = dec->dec_buffers[dec->current_buffer];
    if (buffer)
@@ -462,7 +523,7 @@ vl_mpeg12_get_decode_buffer(struct vl_mpeg12_decoder *dec, struct pipe_video_buf
    if (buffer == NULL)
       return NULL;
 
-   if (!vl_vb_init(&buffer->vertex_stream, dec->base.context,
+   if (!vl_vb_init(&buffer->vertex_stream, dec->context,
                    dec->base.width / VL_MACROBLOCK_WIDTH,
                    dec->base.height / VL_MACROBLOCK_HEIGHT))
       goto error_vertex_buffer;
@@ -481,8 +542,7 @@ vl_mpeg12_get_decode_buffer(struct vl_mpeg12_decoder *dec, struct pipe_video_buf
       vl_mpg12_bs_init(&buffer->bs, &dec->base);
 
    if (dec->base.expect_chunked_decode)
-      vl_video_buffer_set_associated_data(target, &dec->base,
-                                          buffer, vl_mpeg12_destroy_buffer);
+      priv->buffer = buffer;
    else
       dec->dec_buffers[dec->current_buffer] = buffer;
 
@@ -539,17 +599,17 @@ vl_mpeg12_begin_frame(struct pipe_video_codec *decoder,
       vl_zscan_upload_quant(zscan, &buf->zscan[i], non_intra_matrix, false);
    }
 
-   vl_vb_map(&buf->vertex_stream, dec->base.context);
+   vl_vb_map(&buf->vertex_stream, dec->context);
 
    tex = buf->zscan_source->texture;
    rect.width = tex->width0;
    rect.height = tex->height0;
 
    buf->texels =
-      dec->base.context->transfer_map(dec->base.context, tex, 0,
-                                      PIPE_TRANSFER_WRITE |
-                                      PIPE_TRANSFER_DISCARD_RANGE,
-                                      &rect, &buf->tex_transfer);
+      dec->context->transfer_map(dec->context, tex, 0,
+                                 PIPE_TRANSFER_WRITE |
+                                 PIPE_TRANSFER_DISCARD_RANGE,
+                                 &rect, &buf->tex_transfer);
 
    buf->block_num = 0;
 
@@ -685,23 +745,23 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
 
    buf = vl_mpeg12_get_decode_buffer(dec, target);
 
-   vl_vb_unmap(&buf->vertex_stream, dec->base.context);
+   vl_vb_unmap(&buf->vertex_stream, dec->context);
 
-   dec->base.context->transfer_unmap(dec->base.context, buf->tex_transfer);
+   dec->context->transfer_unmap(dec->context, buf->tex_transfer);
 
    vb[0] = dec->quads;
    vb[1] = dec->pos;
 
-   target_surfaces = target->get_surfaces(target);
+   target_surfaces = get_video_buffer_private(dec, target)->surfaces;
 
    for (i = 0; i < VL_MAX_REF_FRAMES; ++i) {
       if (desc->ref[i])
-         ref_frames[i] = desc->ref[i]->get_sampler_view_planes(desc->ref[i]);
+         ref_frames[i] = get_video_buffer_private(dec, desc->ref[i])->sampler_view_planes;
       else
          ref_frames[i] = NULL;
    }
 
-   dec->base.context->bind_vertex_elements_state(dec->base.context, dec->ves_mv);
+   dec->context->bind_vertex_elements_state(dec->context, dec->ves_mv);
    for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
       if (!target_surfaces[i]) continue;
 
@@ -711,18 +771,18 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
          if (!ref_frames[j] || !ref_frames[j][i]) continue;
 
          vb[2] = vl_vb_get_mv(&buf->vertex_stream, j);;
-         dec->base.context->set_vertex_buffers(dec->base.context, 0, 3, vb);
+         dec->context->set_vertex_buffers(dec->context, 0, 3, vb);
 
          vl_mc_render_ref(i ? &dec->mc_c : &dec->mc_y, &buf->mc[i], ref_frames[j][i]);
       }
    }
 
-   dec->base.context->bind_vertex_elements_state(dec->base.context, dec->ves_ycbcr);
+   dec->context->bind_vertex_elements_state(dec->context, dec->ves_ycbcr);
    for (i = 0; i < VL_NUM_COMPONENTS; ++i) {
       if (!buf->num_ycbcr_blocks[i]) continue;
 
       vb[1] = vl_vb_get_ycbcr(&buf->vertex_stream, i);
-      dec->base.context->set_vertex_buffers(dec->base.context, 0, 2, vb);
+      dec->context->set_vertex_buffers(dec->context, 0, 2, vb);
 
       vl_zscan_render(i ? &dec->zscan_c : & dec->zscan_y, &buf->zscan[i] , buf->num_ycbcr_blocks[i]);
 
@@ -741,21 +801,22 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
          if (!buf->num_ycbcr_blocks[plane]) continue;
 
          vb[1] = vl_vb_get_ycbcr(&buf->vertex_stream, plane);
-         dec->base.context->set_vertex_buffers(dec->base.context, 0, 2, vb);
+         dec->context->set_vertex_buffers(dec->context, 0, 2, vb);
 
          if (dec->base.entrypoint <= PIPE_VIDEO_ENTRYPOINT_IDCT)
             vl_idct_prepare_stage2(i ? &dec->idct_c : &dec->idct_y, &buf->idct[plane]);
          else {
-            dec->base.context->set_sampler_views(dec->base.context,
-                                                 PIPE_SHADER_FRAGMENT, 0, 1,
-                                                 &mc_source_sv[plane]);
-            dec->base.context->bind_sampler_states(dec->base.context,
-                                                   PIPE_SHADER_FRAGMENT,
-                                                   0, 1, &dec->sampler_ycbcr);
+            dec->context->set_sampler_views(dec->context,
+                                            PIPE_SHADER_FRAGMENT, 0, 1,
+                                            &mc_source_sv[plane]);
+            dec->context->bind_sampler_states(dec->context,
+                                              PIPE_SHADER_FRAGMENT,
+                                              0, 1, &dec->sampler_ycbcr);
          }
          vl_mc_render_ycbcr(i ? &dec->mc_c : &dec->mc_y, &buf->mc[i], j, buf->num_ycbcr_blocks[plane]);
       }
    }
+   dec->context->flush(dec->context, NULL, 0);
    ++dec->current_buffer;
    dec->current_buffer %= 4;
 }
@@ -793,8 +854,8 @@ init_pipe_state(struct vl_mpeg12_decoder *dec)
    dsa.alpha.enabled = 0;
    dsa.alpha.func = PIPE_FUNC_ALWAYS;
    dsa.alpha.ref_value = 0;
-   dec->dsa = dec->base.context->create_depth_stencil_alpha_state(dec->base.context, &dsa);
-   dec->base.context->bind_depth_stencil_alpha_state(dec->base.context, dec->dsa);
+   dec->dsa = dec->context->create_depth_stencil_alpha_state(dec->context, &dsa);
+   dec->context->bind_depth_stencil_alpha_state(dec->context, dec->dsa);
 
    memset(&sampler, 0, sizeof(sampler));
    sampler.wrap_s = PIPE_TEX_WRAP_CLAMP_TO_EDGE;
@@ -806,7 +867,7 @@ init_pipe_state(struct vl_mpeg12_decoder *dec)
    sampler.compare_mode = PIPE_TEX_COMPARE_NONE;
    sampler.compare_func = PIPE_FUNC_ALWAYS;
    sampler.normalized_coords = 1;
-   dec->sampler_ycbcr = dec->base.context->create_sampler_state(dec->base.context, &sampler);
+   dec->sampler_ycbcr = dec->context->create_sampler_state(dec->context, &sampler);
    if (!dec->sampler_ycbcr)
       return false;
 
@@ -821,7 +882,7 @@ find_format_config(struct vl_mpeg12_decoder *dec, const struct format_config con
 
    assert(dec);
 
-   screen = dec->base.context->screen;
+   screen = dec->context->screen;
 
    for (i = 0; i < num_configs; ++i) {
       if (!screen->is_format_supported(screen, configs[i].zscan_source_format, PIPE_TEXTURE_2D,
@@ -855,17 +916,17 @@ init_zscan(struct vl_mpeg12_decoder *dec, const struct format_config* format_con
    assert(dec);
 
    dec->zscan_source_format = format_config->zscan_source_format;
-   dec->zscan_linear = vl_zscan_layout(dec->base.context, vl_zscan_linear, dec->blocks_per_line);
-   dec->zscan_normal = vl_zscan_layout(dec->base.context, vl_zscan_normal, dec->blocks_per_line);
-   dec->zscan_alternate = vl_zscan_layout(dec->base.context, vl_zscan_alternate, dec->blocks_per_line);
+   dec->zscan_linear = vl_zscan_layout(dec->context, vl_zscan_linear, dec->blocks_per_line);
+   dec->zscan_normal = vl_zscan_layout(dec->context, vl_zscan_normal, dec->blocks_per_line);
+   dec->zscan_alternate = vl_zscan_layout(dec->context, vl_zscan_alternate, dec->blocks_per_line);
 
    num_channels = dec->base.entrypoint <= PIPE_VIDEO_ENTRYPOINT_IDCT ? 4 : 1;
 
-   if (!vl_zscan_init(&dec->zscan_y, dec->base.context, dec->base.width, dec->base.height,
+   if (!vl_zscan_init(&dec->zscan_y, dec->context, dec->base.width, dec->base.height,
                       dec->blocks_per_line, dec->num_blocks, num_channels))
       return false;
 
-   if (!vl_zscan_init(&dec->zscan_c, dec->base.context, dec->chroma_width, dec->chroma_height,
+   if (!vl_zscan_init(&dec->zscan_c, dec->context, dec->chroma_width, dec->chroma_height,
                       dec->blocks_per_line, dec->num_blocks, num_channels))
       return false;
 
@@ -881,14 +942,14 @@ init_idct(struct vl_mpeg12_decoder *dec, const struct format_config* format_conf
 
    struct pipe_sampler_view *matrix = NULL;
 
-   nr_of_idct_render_targets = dec->base.context->screen->get_param
+   nr_of_idct_render_targets = dec->context->screen->get_param
    (
-      dec->base.context->screen, PIPE_CAP_MAX_RENDER_TARGETS
+      dec->context->screen, PIPE_CAP_MAX_RENDER_TARGETS
    );
    
-   max_inst = dec->base.context->screen->get_shader_param
+   max_inst = dec->context->screen->get_shader_param
    (
-      dec->base.context->screen, PIPE_SHADER_FRAGMENT, PIPE_SHADER_CAP_MAX_INSTRUCTIONS
+      dec->context->screen, PIPE_SHADER_FRAGMENT, PIPE_SHADER_CAP_MAX_INSTRUCTIONS
    );
 
    // Just assume we need 32 inst per render target, not 100% true, but should work in most cases
@@ -905,7 +966,7 @@ init_idct(struct vl_mpeg12_decoder *dec, const struct format_config* format_conf
    templat.chroma_format = dec->base.chroma_format;
    dec->idct_source = vl_video_buffer_create_ex
    (
-      dec->base.context, &templat,
+      dec->context, &templat,
       formats, 1, 1, PIPE_USAGE_STATIC
    );
 
@@ -919,21 +980,21 @@ init_idct(struct vl_mpeg12_decoder *dec, const struct format_config* format_conf
    templat.chroma_format = dec->base.chroma_format;
    dec->mc_source = vl_video_buffer_create_ex
    (
-      dec->base.context, &templat,
+      dec->context, &templat,
       formats, nr_of_idct_render_targets, 1, PIPE_USAGE_STATIC
    );
 
    if (!dec->mc_source)
       goto error_mc_source;
 
-   if (!(matrix = vl_idct_upload_matrix(dec->base.context, format_config->idct_scale)))
+   if (!(matrix = vl_idct_upload_matrix(dec->context, format_config->idct_scale)))
       goto error_matrix;
 
-   if (!vl_idct_init(&dec->idct_y, dec->base.context, dec->base.width, dec->base.height,
+   if (!vl_idct_init(&dec->idct_y, dec->context, dec->base.width, dec->base.height,
                      nr_of_idct_render_targets, matrix, matrix))
       goto error_y;
 
-   if(!vl_idct_init(&dec->idct_c, dec->base.context, dec->chroma_width, dec->chroma_height,
+   if(!vl_idct_init(&dec->idct_c, dec->context, dec->chroma_width, dec->chroma_height,
                     nr_of_idct_render_targets, matrix, matrix))
       goto error_c;
 
@@ -970,7 +1031,7 @@ init_mc_source_widthout_idct(struct vl_mpeg12_decoder *dec, const struct format_
    templat.chroma_format = dec->base.chroma_format;
    dec->mc_source = vl_video_buffer_create_ex
    (
-      dec->base.context, &templat,
+      dec->context, &templat,
       formats, 1, 1, PIPE_USAGE_STATIC
    );
       
@@ -1037,6 +1098,7 @@ vl_create_mpeg12_decoder(struct pipe_context *context,
 
    dec->base = *templat;
    dec->base.context = context;
+   dec->context = context->screen->context_create(context->screen, NULL);
 
    dec->base.destroy = vl_mpeg12_destroy;
    dec->base.begin_frame = vl_mpeg12_begin_frame;
@@ -1066,15 +1128,15 @@ vl_create_mpeg12_decoder(struct pipe_context *context,
       dec->num_blocks = dec->num_blocks * 3;
    }
 
-   dec->quads = vl_vb_upload_quads(dec->base.context);
+   dec->quads = vl_vb_upload_quads(dec->context);
    dec->pos = vl_vb_upload_pos(
-      dec->base.context,
+      dec->context,
       dec->base.width / VL_MACROBLOCK_WIDTH,
       dec->base.height / VL_MACROBLOCK_HEIGHT
    );
 
-   dec->ves_ycbcr = vl_vb_get_ves_ycbcr(dec->base.context);
-   dec->ves_mv = vl_vb_get_ves_mv(dec->base.context);
+   dec->ves_ycbcr = vl_vb_get_ves_ycbcr(dec->context);
+   dec->ves_mv = vl_vb_get_ves_mv(dec->context);
 
    switch (templat->entrypoint) {
    case PIPE_VIDEO_ENTRYPOINT_BITSTREAM:
@@ -1111,13 +1173,13 @@ vl_create_mpeg12_decoder(struct pipe_context *context,
          goto error_sources;
    }
 
-   if (!vl_mc_init(&dec->mc_y, dec->base.context, dec->base.width, dec->base.height,
+   if (!vl_mc_init(&dec->mc_y, dec->context, dec->base.width, dec->base.height,
                    VL_MACROBLOCK_HEIGHT, format_config->mc_scale,
                    mc_vert_shader_callback, mc_frag_shader_callback, dec))
       goto error_mc_y;
 
    // TODO
-   if (!vl_mc_init(&dec->mc_c, dec->base.context, dec->base.width, dec->base.height,
+   if (!vl_mc_init(&dec->mc_c, dec->context, dec->base.width, dec->base.height,
                    VL_BLOCK_HEIGHT, format_config->mc_scale,
                    mc_vert_shader_callback, mc_frag_shader_callback, dec))
       goto error_mc_c;
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.h b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.h
index c7fe5e6..b357d8b 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.h
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.h
@@ -44,6 +44,7 @@ struct pipe_context;
 struct vl_mpeg12_decoder
 {
    struct pipe_video_codec base;
+   struct pipe_context *context;
 
    unsigned chroma_width, chroma_height;
 
diff --git a/src/gallium/drivers/freedreno/Makefile.am b/src/gallium/drivers/freedreno/Makefile.am
index 9f5a80a..7947dd1 100644
--- a/src/gallium/drivers/freedreno/Makefile.am
+++ b/src/gallium/drivers/freedreno/Makefile.am
@@ -1,22 +1,18 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libfreedreno.la
-
 AM_CFLAGS = \
 	-Wno-packed-bitfield-compat \
-	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/drivers/freedreno/a3xx \
 	-I$(top_srcdir)/src/gallium/drivers/freedreno/a2xx \
-	$(GALLIUM_CFLAGS) \
-	$(FREEDRENO_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(FREEDRENO_CFLAGS)
 
-SUBDIRS = a2xx a3xx
-
-libfreedreno_la_SOURCES = $(C_SOURCES)
-
-libfreedreno_la_LIBADD = \
-	a3xx/libfd3xx.la \
-	a2xx/libfd2xx.la
+noinst_LTLIBRARIES = libfreedreno.la
 
+libfreedreno_la_SOURCES = \
+	$(C_SOURCES) \
+	$(a2xx_SOURCES) \
+	$(a3xx_SOURCES)
diff --git a/src/gallium/drivers/freedreno/Makefile.sources b/src/gallium/drivers/freedreno/Makefile.sources
index 02a88b6..e54bff0 100644
--- a/src/gallium/drivers/freedreno/Makefile.sources
+++ b/src/gallium/drivers/freedreno/Makefile.sources
@@ -9,3 +9,35 @@ C_SOURCES := \
 	freedreno_context.c \
 	freedreno_screen.c \
 	freedreno_gmem.c
+
+a2xx_SOURCES := \
+	a2xx/fd2_blend.c \
+	a2xx/fd2_compiler.c \
+	a2xx/fd2_context.c \
+	a2xx/fd2_draw.c \
+	a2xx/fd2_emit.c \
+	a2xx/fd2_gmem.c \
+	a2xx/fd2_program.c \
+	a2xx/fd2_rasterizer.c \
+	a2xx/fd2_screen.c \
+	a2xx/fd2_texture.c \
+	a2xx/fd2_util.c \
+	a2xx/fd2_zsa.c \
+	a2xx/disasm-a2xx.c \
+	a2xx/ir-a2xx.c
+
+a3xx_SOURCES := \
+	a3xx/fd3_blend.c \
+	a3xx/fd3_compiler.c \
+	a3xx/fd3_context.c \
+	a3xx/fd3_draw.c \
+	a3xx/fd3_emit.c \
+	a3xx/fd3_gmem.c \
+	a3xx/fd3_program.c \
+	a3xx/fd3_rasterizer.c \
+	a3xx/fd3_screen.c \
+	a3xx/fd3_texture.c \
+	a3xx/fd3_util.c \
+	a3xx/fd3_zsa.c \
+	a3xx/disasm-a3xx.c \
+	a3xx/ir-a3xx.c
diff --git a/src/gallium/drivers/freedreno/a2xx/Makefile.am b/src/gallium/drivers/freedreno/a2xx/Makefile.am
deleted file mode 100644
index b8a5ac1..0000000
--- a/src/gallium/drivers/freedreno/a2xx/Makefile.am
+++ /dev/null
@@ -1,14 +0,0 @@
-include Makefile.sources
-include $(top_srcdir)/src/gallium/Automake.inc
-
-noinst_LTLIBRARIES = libfd2xx.la
-
-AM_CFLAGS = \
-	-Wno-packed-bitfield-compat \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/drivers/freedreno \
-	$(GALLIUM_CFLAGS) \
-	$(FREEDRENO_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-
-libfd2xx_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/drivers/freedreno/a2xx/Makefile.sources b/src/gallium/drivers/freedreno/a2xx/Makefile.sources
deleted file mode 100644
index 1ef2852..0000000
--- a/src/gallium/drivers/freedreno/a2xx/Makefile.sources
+++ /dev/null
@@ -1,15 +0,0 @@
-C_SOURCES := \
-	fd2_blend.c \
-	fd2_compiler.c \
-	fd2_context.c \
-	fd2_draw.c \
-	fd2_emit.c \
-	fd2_gmem.c \
-	fd2_program.c \
-	fd2_rasterizer.c \
-	fd2_screen.c \
-	fd2_texture.c \
-	fd2_util.c \
-	fd2_zsa.c \
-	disasm-a2xx.c \
-	ir-a2xx.c
diff --git a/src/gallium/drivers/freedreno/a3xx/Makefile.am b/src/gallium/drivers/freedreno/a3xx/Makefile.am
deleted file mode 100644
index 6b8b2e4..0000000
--- a/src/gallium/drivers/freedreno/a3xx/Makefile.am
+++ /dev/null
@@ -1,14 +0,0 @@
-include Makefile.sources
-include $(top_srcdir)/src/gallium/Automake.inc
-
-noinst_LTLIBRARIES = libfd3xx.la
-
-AM_CFLAGS = \
-	-Wno-packed-bitfield-compat \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/drivers/freedreno \
-	$(GALLIUM_CFLAGS) \
-	$(FREEDRENO_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-
-libfd3xx_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/drivers/freedreno/a3xx/Makefile.sources b/src/gallium/drivers/freedreno/a3xx/Makefile.sources
deleted file mode 100644
index 24ee6f0..0000000
--- a/src/gallium/drivers/freedreno/a3xx/Makefile.sources
+++ /dev/null
@@ -1,15 +0,0 @@
-C_SOURCES := \
-	fd3_blend.c \
-	fd3_compiler.c \
-	fd3_context.c \
-	fd3_draw.c \
-	fd3_emit.c \
-	fd3_gmem.c \
-	fd3_program.c \
-	fd3_rasterizer.c \
-	fd3_screen.c \
-	fd3_texture.c \
-	fd3_util.c \
-	fd3_zsa.c \
-	disasm-a3xx.c \
-	ir-a3xx.c
diff --git a/src/gallium/drivers/galahad/Makefile.am b/src/gallium/drivers/galahad/Makefile.am
index 5f64b93..17572c3 100644
--- a/src/gallium/drivers/galahad/Makefile.am
+++ b/src/gallium/drivers/galahad/Makefile.am
@@ -7,9 +7,7 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS)
 
 noinst_LTLIBRARIES = libgalahad.la
 
diff --git a/src/gallium/drivers/i915/Makefile.am b/src/gallium/drivers/i915/Makefile.am
index 4e6f464..a4a3e86 100644
--- a/src/gallium/drivers/i915/Makefile.am
+++ b/src/gallium/drivers/i915/Makefile.am
@@ -23,11 +23,9 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libi915.la
+AM_CFLAGS = \
+	$(GALLIUM_DRIVER_CFLAGS)
 
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS)
+noinst_LTLIBRARIES = libi915.la
 
 libi915_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/drivers/identity/Makefile.am b/src/gallium/drivers/identity/Makefile.am
index 1caf328..7fcbc7c 100644
--- a/src/gallium/drivers/identity/Makefile.am
+++ b/src/gallium/drivers/identity/Makefile.am
@@ -2,9 +2,7 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS)
 
 noinst_LTLIBRARIES = libidentity.la
 
diff --git a/src/gallium/drivers/ilo/Makefile.am b/src/gallium/drivers/ilo/Makefile.am
index 0aa4a33..04d4da8 100644
--- a/src/gallium/drivers/ilo/Makefile.am
+++ b/src/gallium/drivers/ilo/Makefile.am
@@ -21,17 +21,15 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libilo.la
-
 AM_CPPFLAGS = \
-	-I$(srcdir)/include \
 	-I$(top_srcdir)/src/gallium/winsys/intel \
-	$(GALLIUM_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS)
 
-AM_CFLAGS = \
-	$(VISIBILITY_CFLAGS)
+noinst_LTLIBRARIES = libilo.la
 
 libilo_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/drivers/llvmpipe/Makefile.am b/src/gallium/drivers/llvmpipe/Makefile.am
index 1a1a575..4f881bb 100644
--- a/src/gallium/drivers/llvmpipe/Makefile.am
+++ b/src/gallium/drivers/llvmpipe/Makefile.am
@@ -23,13 +23,12 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CFLAGS = $(LLVM_CFLAGS)
-AM_CXXFLAGS= $(LLVM_CXXFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(LLVM_CFLAGS)
+AM_CXXFLAGS= \
+	$(GALLIUM_DRIVER_CXXFLAGS) \
+	$(LLVM_CXXFLAGS)
 
 noinst_LTLIBRARIES = libllvmpipe.la
 
diff --git a/src/gallium/drivers/llvmpipe/lp_context.h b/src/gallium/drivers/llvmpipe/lp_context.h
index 106288a..9ec18e8 100644
--- a/src/gallium/drivers/llvmpipe/lp_context.h
+++ b/src/gallium/drivers/llvmpipe/lp_context.h
@@ -124,9 +124,10 @@ struct llvmpipe_context {
    /** A fake frontface output for unfilled primitives */
    int face_slot;
 
-   /**< minimum resolvable depth value, for polygon offset */   
-   double mrd;
-   
+   /** Depth format and bias settings. */
+   boolean floating_point_depth;
+   double mrd;   /**< minimum resolvable depth value, for polygon offset */
+
    /** The tiling engine */
    struct lp_setup_context *setup;
    struct lp_setup_variant setup_variant;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_derived.c b/src/gallium/drivers/llvmpipe/lp_state_derived.c
index 8aee92b..47e413b 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_derived.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_derived.c
@@ -186,7 +186,8 @@ void llvmpipe_update_derived( struct llvmpipe_context *llvmpipe )
       llvmpipe_update_fs( llvmpipe );
 
    if (llvmpipe->dirty & (LP_NEW_FS |
-			  LP_NEW_RASTERIZER))
+                          LP_NEW_FRAMEBUFFER |
+                          LP_NEW_RASTERIZER))
       llvmpipe_update_setup( llvmpipe );
 
    if (llvmpipe->dirty & LP_NEW_BLEND_COLOR)
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 8223d2a..b5816e0 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -1760,11 +1760,11 @@ generate_unswizzled_blend(struct gallivm_state *gallivm,
       assert(row_type.floating);
       lp_build_context_init(&f32_bld, gallivm, row_type);
       for (i = 0; i < src_count; i++) {
-         src[i] = lp_build_clamp(&f32_bld, src[i], f32_bld.zero, f32_bld.one);
+         src[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src[i]);
       }
       if (dual_source_blend) {
          for (i = 0; i < src_count; i++) {
-            src1[i] = lp_build_clamp(&f32_bld, src1[i], f32_bld.zero, f32_bld.one);
+            src1[i] = lp_build_clamp_zero_one_nanzero(&f32_bld, src1[i]);
          }
       }
       /* probably can't be different than row_type but better safe than sorry... */
diff --git a/src/gallium/drivers/llvmpipe/lp_state_setup.c b/src/gallium/drivers/llvmpipe/lp_state_setup.c
index dab5096..59ab467 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_setup.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_setup.c
@@ -31,6 +31,7 @@
 #include "util/u_simple_list.h"
 #include "os/os_time.h"
 #include "gallivm/lp_bld_arit.h"
+#include "gallivm/lp_bld_bitarit.h"
 #include "gallivm/lp_bld_const.h"
 #include "gallivm/lp_bld_debug.h"
 #include "gallivm/lp_bld_init.h"
@@ -76,59 +77,10 @@ struct lp_setup_args
    LLVMValueRef dy01_ooa;
    LLVMValueRef dx20_ooa;
    LLVMValueRef dx01_ooa;
+   struct lp_build_context bld;
 };
 
 
-
-static LLVMTypeRef
-type4f(struct gallivm_state *gallivm)
-{
-   return LLVMVectorType(LLVMFloatTypeInContext(gallivm->context), 4);
-}
-
-
-/* Equivalent of _mm_setr_ps(a,b,c,d)
- */
-static LLVMValueRef
-vec4f(struct gallivm_state *gallivm,
-      LLVMValueRef a, LLVMValueRef b, LLVMValueRef c, LLVMValueRef d,
-      const char *name)
-{
-   LLVMBuilderRef bld = gallivm->builder;
-   LLVMValueRef i0 = lp_build_const_int32(gallivm, 0);
-   LLVMValueRef i1 = lp_build_const_int32(gallivm, 1);
-   LLVMValueRef i2 = lp_build_const_int32(gallivm, 2);
-   LLVMValueRef i3 = lp_build_const_int32(gallivm, 3);
-
-   LLVMValueRef res = LLVMGetUndef(type4f(gallivm));
-
-   res = LLVMBuildInsertElement(bld, res, a, i0, "");
-   res = LLVMBuildInsertElement(bld, res, b, i1, "");
-   res = LLVMBuildInsertElement(bld, res, c, i2, "");
-   res = LLVMBuildInsertElement(bld, res, d, i3, name);
-
-   return res;
-}
-
-/* Equivalent of _mm_set1_ps(a)
- */
-static LLVMValueRef
-vec4f_from_scalar(struct gallivm_state *gallivm,
-                  LLVMValueRef a,
-                  const char *name)
-{
-   LLVMBuilderRef bld = gallivm->builder;
-   LLVMValueRef res = LLVMGetUndef(type4f(gallivm));
-   int i;
-
-   for(i = 0; i < 4; ++i) {
-      LLVMValueRef index = lp_build_const_int32(gallivm, i);
-      res = LLVMBuildInsertElement(bld, res, a, index, i == 3 ? name : "");
-   }
-
-   return res;
-}
-
 static void
 store_coef(struct gallivm_state *gallivm,
 	   struct lp_setup_args *args,
@@ -157,13 +109,11 @@ store_coef(struct gallivm_state *gallivm,
 
 static void 
 emit_constant_coef4(struct gallivm_state *gallivm,
-		     struct lp_setup_args *args,
-		     unsigned slot,
-		     LLVMValueRef vert)
+                    struct lp_setup_args *args,
+                    unsigned slot,
+                    LLVMValueRef vert)
 {
-   LLVMValueRef zero      = lp_build_const_float(gallivm, 0.0);
-   LLVMValueRef zerovec   = vec4f_from_scalar(gallivm, zero, "zero");
-   store_coef(gallivm, args, slot, vert, zerovec, zerovec);
+   store_coef(gallivm, args, slot, vert, args->bld.zero, args->bld.zero);
 }
 
 
@@ -174,38 +124,40 @@ emit_constant_coef4(struct gallivm_state *gallivm,
  */
 static void 
 emit_facing_coef(struct gallivm_state *gallivm,
-		  struct lp_setup_args *args,
-		  unsigned slot )
+                 struct lp_setup_args *args,
+                 unsigned slot )
 {
    LLVMBuilderRef builder = gallivm->builder;
    LLVMTypeRef float_type = LLVMFloatTypeInContext(gallivm->context);
    LLVMValueRef a0_0 = args->facing;
    LLVMValueRef a0_0f = LLVMBuildSIToFP(builder, a0_0, float_type, "");
-   LLVMValueRef zero = lp_build_const_float(gallivm, 0.0);
+   LLVMValueRef a0, face_val;
+   const unsigned char swizzles[4] = { PIPE_SWIZZLE_RED, PIPE_SWIZZLE_ZERO,
+                                       PIPE_SWIZZLE_ZERO, PIPE_SWIZZLE_ZERO };
    /* Our face val is either 1 or 0 so we do
     * face = (val * 2) - 1
     * to make it 1 or -1
     */
-   LLVMValueRef face_val =
+   face_val =
       LLVMBuildFAdd(builder,
                     LLVMBuildFMul(builder, a0_0f,
                                   lp_build_const_float(gallivm, 2.0),
                                   ""),
                     lp_build_const_float(gallivm, -1.0),
-                    "");
-   LLVMValueRef a0 = vec4f(gallivm, face_val, zero, zero, zero, "facing");
-   LLVMValueRef zerovec = vec4f_from_scalar(gallivm, zero, "zero");
+                    "facing");
+   face_val = lp_build_broadcast_scalar(&args->bld, face_val);
+   a0 = lp_build_swizzle_aos(&args->bld, face_val, swizzles);
 
-   store_coef(gallivm, args, slot, a0, zerovec, zerovec);
+   store_coef(gallivm, args, slot, a0, args->bld.zero, args->bld.zero);
 }
 
 
 static LLVMValueRef
 vert_attrib(struct gallivm_state *gallivm,
-	    LLVMValueRef vert,
-	    int attr,
-	    int elem,
-	    const char *name)
+            LLVMValueRef vert,
+            int attr,
+            int elem,
+            const char *name)
 {
    LLVMBuilderRef b = gallivm->builder;
    LLVMValueRef idx[2];
@@ -227,8 +179,9 @@ lp_twoside(struct gallivm_state *gallivm,
    LLVMValueRef idx2 = lp_build_const_int32(gallivm, bcolor_slot);
 
    LLVMValueRef facing = args->facing;
-   LLVMValueRef front_facing = LLVMBuildICmp(b, LLVMIntEQ, facing, lp_build_const_int32(gallivm, 0), ""); /** need i1 for if condition */
-   
+   LLVMValueRef front_facing = LLVMBuildICmp(b, LLVMIntEQ, facing,
+                                             lp_build_const_int32(gallivm, 0), ""); /** need i1 for if condition */
+
    a0_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v0, &idx2, 1, ""), "v0a_back");
    a1_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v1, &idx2, 1, ""), "v1a_back");
    a2_back = LLVMBuildLoad(b, LLVMBuildGEP(b, args->v2, &idx2, 1, ""), "v2a_back");
@@ -254,8 +207,9 @@ lp_do_offset_tri(struct gallivm_state *gallivm,
                  LLVMValueRef attribv[3])
 {
    LLVMBuilderRef b = gallivm->builder;
-   struct lp_build_context bld;
    struct lp_build_context flt_scalar_bld;
+   struct lp_build_context int_scalar_bld;
+   struct lp_build_context *bld = &args->bld;
    LLVMValueRef zoffset, mult;
    LLVMValueRef z0_new, z1_new, z2_new;
    LLVMValueRef dzdxdzdy, dzdx, dzdy, dzxyz20, dyzzx01, dyzzx01_dzxyz20, dzx01_dyz20;
@@ -293,24 +247,67 @@ lp_do_offset_tri(struct gallivm_state *gallivm,
    res12 = LLVMBuildFSub(b, dyzzx01_dzxyz20, dzx01_dyz20, "res12");
 
    /* dzdx = fabsf(res1 * inv_det), dydx = fabsf(res2 * inv_det)*/
-   lp_build_context_init(&bld, gallivm, lp_type_float_vec(32, 128));
    dzdxdzdy = LLVMBuildFMul(b, res12, inv_det, "dzdxdzdy");
-   dzdxdzdy = lp_build_abs(&bld, dzdxdzdy);
+   dzdxdzdy = lp_build_abs(bld, dzdxdzdy);
 
    dzdx = LLVMBuildExtractElement(b, dzdxdzdy, zeroi, "");
    dzdy = LLVMBuildExtractElement(b, dzdxdzdy, onei, "");
 
-   /* zoffset = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale */
+   /* mult = MAX2(dzdx, dzdy) * pgon_offset_scale */
    max = LLVMBuildFCmp(b, LLVMRealUGT, dzdx, dzdy, "");
    max_value = LLVMBuildSelect(b, max, dzdx, dzdy, "max"); 
 
    mult = LLVMBuildFMul(b, max_value,
                         lp_build_const_float(gallivm, key->pgon_offset_scale), "");
-   zoffset = LLVMBuildFAdd(b,
-                           lp_build_const_float(gallivm, key->pgon_offset_units),
-                           mult, "zoffset");
 
    lp_build_context_init(&flt_scalar_bld, gallivm, lp_type_float_vec(32, 32));
+
+   if (key->floating_point_depth) {
+      /*
+       * bias = pgon_offset_units * 2^(exponent(max(z0, z1, z2)) - mantissa_bits) +
+       *           MAX2(dzdx, dzdy) * pgon_offset_scale
+       *
+       * NOTE: Assumes IEEE float32.
+       */
+      LLVMValueRef c23_shifted, exp_mask, bias, exp;
+      LLVMValueRef maxz_value, maxz0z1_value;
+
+      lp_build_context_init(&int_scalar_bld, gallivm, lp_type_int_vec(32, 32));
+
+      c23_shifted = lp_build_const_int32(gallivm, 23 << 23);
+      exp_mask = lp_build_const_int32(gallivm, 0xff << 23);
+
+      maxz0z1_value = lp_build_max(&flt_scalar_bld,
+                         LLVMBuildExtractElement(b, attribv[0], twoi, ""),
+                         LLVMBuildExtractElement(b, attribv[1], twoi, ""));
+
+      maxz_value = lp_build_max(&flt_scalar_bld,
+                      LLVMBuildExtractElement(b, attribv[2], twoi, ""),
+                      maxz0z1_value);
+
+      exp = LLVMBuildBitCast(b, maxz_value, int_scalar_bld.vec_type, "");
+      exp = lp_build_and(&int_scalar_bld, exp, exp_mask);
+      exp = lp_build_sub(&int_scalar_bld, exp, c23_shifted);
+      /* Clamping to zero means mrd will be zero for very small numbers,
+       * but specs do not indicate this should be prevented by clamping
+       * mrd to smallest normal number instead. */
+      exp = lp_build_max(&int_scalar_bld, exp, int_scalar_bld.zero);
+      exp = LLVMBuildBitCast(b, exp, flt_scalar_bld.vec_type, "");
+
+      bias = LLVMBuildFMul(b, exp,
+                           lp_build_const_float(gallivm, key->pgon_offset_units),
+                           "bias");
+
+      zoffset = LLVMBuildFAdd(b, bias, mult, "zoffset");
+   } else {
+      /*
+       * bias = pgon_offset_units + MAX2(dzdx, dzdy) * pgon_offset_scale
+       */
+      zoffset = LLVMBuildFAdd(b,
+                              lp_build_const_float(gallivm, key->pgon_offset_units),
+                              mult, "zoffset");
+   }
+
    if (key->pgon_offset_clamp > 0) {
       zoffset = lp_build_min(&flt_scalar_bld,
                              lp_build_const_float(gallivm, key->pgon_offset_clamp),
@@ -333,14 +330,14 @@ lp_do_offset_tri(struct gallivm_state *gallivm,
    shuffles[2] = lp_build_const_int32(gallivm, 6);
    shuffles[3] = LLVMGetUndef(shuf_type);
    z0z1z2 = LLVMBuildShuffleVector(b, z0z1, attribv[2], LLVMConstVector(shuffles, 4), "");
-   zoffset = vec4f_from_scalar(gallivm, zoffset, "");
+   zoffset = lp_build_broadcast_scalar(bld, zoffset);
 
    /* clamp and do offset */
    /*
     * FIXME I suspect the clamp (is that even right to always clamp to fixed
     * 0.0/1.0?) should really be per fragment?
     */
-   z0z1z2 = lp_build_clamp(&bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld.zero, bld.one);
+   z0z1z2 = lp_build_clamp(bld, LLVMBuildFAdd(b, z0z1z2, zoffset, ""), bld->zero, bld->one);
 
    /* insert into args->a0.z, a1.z, a2.z:
     */
@@ -381,11 +378,11 @@ load_attribute(struct gallivm_state *gallivm,
 
 static void 
 emit_coef4( struct gallivm_state *gallivm,
-	    struct lp_setup_args *args,
-	    unsigned slot,
-	    LLVMValueRef a0,
-	    LLVMValueRef a1,
-	    LLVMValueRef a2)
+            struct lp_setup_args *args,
+            unsigned slot,
+            LLVMValueRef a0,
+            LLVMValueRef a1,
+            LLVMValueRef a2)
 {
    LLVMBuilderRef b = gallivm->builder;
    LLVMValueRef dy20_ooa = args->dy20_ooa;
@@ -394,7 +391,6 @@ emit_coef4( struct gallivm_state *gallivm,
    LLVMValueRef dx01_ooa = args->dx01_ooa;
    LLVMValueRef x0_center = args->x0_center;
    LLVMValueRef y0_center = args->y0_center;
-
    LLVMValueRef da01 = LLVMBuildFSub(b, a0, a1, "da01");
    LLVMValueRef da20 = LLVMBuildFSub(b, a2, a0, "da20");
 
@@ -412,10 +408,10 @@ emit_coef4( struct gallivm_state *gallivm,
 
    /* Calculate a0 - the attribute value at the origin
     */
-   LLVMValueRef dadx_x0       = LLVMBuildFMul(b, dadx, x0_center, "dadx_x0"); 
+   LLVMValueRef dadx_x0       = LLVMBuildFMul(b, dadx, x0_center, "dadx_x0");
    LLVMValueRef dady_y0       = LLVMBuildFMul(b, dady, y0_center, "dady_y0"); 
-   LLVMValueRef attr_v0       = LLVMBuildFAdd(b, dadx_x0, dady_y0, "attr_v0"); 
-   LLVMValueRef attr_0        = LLVMBuildFSub(b, a0, attr_v0, "attr_0"); 
+   LLVMValueRef attr_v0       = LLVMBuildFAdd(b, dadx_x0, dady_y0, "attr_v0");
+   LLVMValueRef attr_0        = LLVMBuildFSub(b, a0, attr_v0, "attr_0");
 
    store_coef(gallivm, args, slot, attr_0, dadx, dady);
 }
@@ -423,9 +419,9 @@ emit_coef4( struct gallivm_state *gallivm,
 
 static void 
 emit_linear_coef( struct gallivm_state *gallivm,
-		  struct lp_setup_args *args,
-		  unsigned slot,
-		  LLVMValueRef attribv[3])
+                  struct lp_setup_args *args,
+                  unsigned slot,
+                  LLVMValueRef attribv[3])
 {
    /* nothing to do anymore */
    emit_coef4(gallivm,
@@ -454,9 +450,12 @@ apply_perspective_corr( struct gallivm_state *gallivm,
 
    /* premultiply by 1/w  (v[0][3] is always 1/w):
     */
-   LLVMValueRef v0_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v0, 0, 3, ""), "v0_oow");
-   LLVMValueRef v1_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v1, 0, 3, ""), "v1_oow");
-   LLVMValueRef v2_oow = vec4f_from_scalar(gallivm, vert_attrib(gallivm, args->v2, 0, 3, ""), "v2_oow");
+   LLVMValueRef v0_oow = lp_build_broadcast_scalar(&args->bld,
+                            vert_attrib(gallivm, args->v0, 0, 3, "v0_oow"));
+   LLVMValueRef v1_oow = lp_build_broadcast_scalar(&args->bld,
+                            vert_attrib(gallivm, args->v1, 0, 3, "v1_oow"));
+   LLVMValueRef v2_oow = lp_build_broadcast_scalar(&args->bld,
+                            vert_attrib(gallivm, args->v2, 0, 3, "v2_oow"));
 
    attribv[0] = LLVMBuildFMul(b, attribv[0], v0_oow, "v0_oow_v0a");
    attribv[1] = LLVMBuildFMul(b, attribv[1], v1_oow, "v1_oow_v1a");
@@ -464,16 +463,6 @@ apply_perspective_corr( struct gallivm_state *gallivm,
 }
 
 
-static void
-emit_position_coef( struct gallivm_state *gallivm,
-		    struct lp_setup_args *args,
-		    int slot,
-		    LLVMValueRef attribv[3])
-{
-   emit_linear_coef(gallivm, args, slot, attribv);
-}
-
-
 /**
  * Applys cylindrical wrapping to vertex attributes if enabled.
  * Input coordinates must be in [0, 1] range, otherwise results are undefined.
@@ -484,12 +473,12 @@ static void
 emit_apply_cyl_wrap(struct gallivm_state *gallivm,
                     struct lp_setup_args *args,
                     uint cyl_wrap,
-		    LLVMValueRef attribv[3])
+                    LLVMValueRef attribv[3])
 
 {
    LLVMBuilderRef builder = gallivm->builder;
-   struct lp_type type = lp_float32_vec4_type();
-   LLVMTypeRef float_vec_type = lp_build_vec_type(gallivm, type);
+   struct lp_type type = args->bld.type;
+   LLVMTypeRef float_vec_type = args->bld.vec_type;
    LLVMValueRef pos_half;
    LLVMValueRef neg_half;
    LLVMValueRef cyl_mask;
@@ -578,13 +567,13 @@ emit_tri_coef( struct gallivm_state *gallivm,
 
       case LP_INTERP_LINEAR:
          load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
-	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
+         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
          emit_linear_coef(gallivm, args, slot+1, attribs);
          break;
 
       case LP_INTERP_PERSPECTIVE:
          load_attribute(gallivm, args, key, key->inputs[slot].src_index, attribs);
-	 emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
+         emit_apply_cyl_wrap(gallivm, args, key->inputs[slot].cyl_wrap, attribs);
          apply_perspective_corr(gallivm, args, slot+1, attribs);
          emit_linear_coef(gallivm, args, slot+1, attribs);
          break;
@@ -611,21 +600,21 @@ emit_tri_coef( struct gallivm_state *gallivm,
  */
 static void
 set_noalias(LLVMBuilderRef builder,
-	    LLVMValueRef function,
-	    const LLVMTypeRef *arg_types,
-	    int nr_args)
+            LLVMValueRef function,
+            const LLVMTypeRef *arg_types,
+            int nr_args)
 {
    int i;
    for(i = 0; i < nr_args; ++i)
       if(LLVMGetTypeKind(arg_types[i]) == LLVMPointerTypeKind)
          LLVMAddAttribute(LLVMGetParam(function, i),
-			  LLVMNoAliasAttribute);
+            LLVMNoAliasAttribute);
 }
 
 static void
 init_args(struct gallivm_state *gallivm,
           const struct lp_setup_variant_key *key,
-	  struct lp_setup_args *args)
+          struct lp_setup_args *args)
 {
    LLVMBuilderRef b = gallivm->builder;
    LLVMTypeRef shuf_type = LLVMInt32TypeInContext(gallivm->context);
@@ -637,13 +626,17 @@ init_args(struct gallivm_state *gallivm,
    LLVMValueRef shuffles[4];
    LLVMValueRef attr_pos[3];
    struct lp_type typef4 = lp_type_float_vec(32, 128);
+   struct lp_build_context bld;
+
+   lp_build_context_init(&bld, gallivm, typef4);
+   args->bld = bld;
 
    /* The internal position input is in slot zero:
     */
    load_attribute(gallivm, args, key, 0, attr_pos);
 
    pixel_center = lp_build_const_vec(gallivm, typef4,
-                                  key->pixel_center_half ? 0.5 : 0.0);
+                                     key->pixel_center_half ? 0.5 : 0.0);
 
    /*
     * xy are first two elems in v0a/v1a/v2a but just use vec4 arit
@@ -667,7 +660,7 @@ init_args(struct gallivm_state *gallivm,
 
    ooa  = LLVMBuildFDiv(b, onef, LLVMBuildFSub(b, e, f, ""), "ooa");
 
-   ooa = vec4f_from_scalar(gallivm, ooa, "");
+   ooa = lp_build_broadcast_scalar(&bld, ooa);
 
    /* tri offset calc shares a lot of arithmetic, do it here */
    if (key->pgon_offset_scale != 0.0f || key->pgon_offset_units != 0.0f) {
@@ -686,8 +679,7 @@ init_args(struct gallivm_state *gallivm,
    args->x0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, zeroi);
    args->y0_center = lp_build_extract_broadcast(gallivm, typef4, typef4, xy0_center, onei);
 
-   /* might want to merge that with other coef emit in the future */
-   emit_position_coef(gallivm, args, 0, attr_pos);
+   emit_linear_coef(gallivm, args, 0, attr_pos);
 }
 
 /**
@@ -731,8 +723,7 @@ generate_setup_variant(struct lp_setup_variant_key *key,
    variant->list_item_global.base = variant;
 
    util_snprintf(func_name, sizeof(func_name), "fs%u_setup%u",
-		 0,
-		 variant->no);
+                 0, variant->no);
 
    /* Currently always deal with full 4-wide vertex attributes from
     * the vertices.
@@ -849,7 +840,20 @@ lp_make_setup_variant_key(struct llvmpipe_context *lp,
    assert(key->spec_slot   == lp->color_slot [1]);
    assert(key->bspec_slot  == lp->bcolor_slot[1]);
 
-   key->pgon_offset_units = (float) (lp->rasterizer->offset_units * lp->mrd);
+   /*
+    * If depth is floating point, depth bias is calculated with respect
+    * to the primitive's maximum Z value. Retain the original depth bias
+    * value until that stage.
+    */
+   key->floating_point_depth = lp->floating_point_depth;
+
+   if (key->floating_point_depth) {
+      key->pgon_offset_units = (float) lp->rasterizer->offset_units;
+   } else {
+      key->pgon_offset_units =
+         (float) (lp->rasterizer->offset_units * lp->mrd);
+   }
+
    key->pgon_offset_scale = lp->rasterizer->offset_scale;
    key->pgon_offset_clamp = lp->rasterizer->offset_clamp;
    key->pad = 0;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_setup.h b/src/gallium/drivers/llvmpipe/lp_state_setup.h
index f49e575..82af835 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_setup.h
+++ b/src/gallium/drivers/llvmpipe/lp_state_setup.h
@@ -25,7 +25,8 @@ struct lp_setup_variant_key {
    unsigned flatshade_first:1;
    unsigned pixel_center_half:1;
    unsigned twoside:1;
-   unsigned pad:5;
+   unsigned floating_point_depth:1;
+   unsigned pad:4;
 
    /* TODO: get those floats out of the key and use a jit_context for setup */
    float pgon_offset_units;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_surface.c b/src/gallium/drivers/llvmpipe/lp_state_surface.c
index 8909841..c228c63 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_surface.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_surface.c
@@ -57,24 +57,32 @@ llvmpipe_set_framebuffer_state(struct pipe_context *pipe,
    assert(fb->height <= LP_MAX_HEIGHT);
 
    if (changed) {
+      /*
+       * If no depth buffer is bound, send the utility function the default
+       * format for no bound depth (PIPE_FORMAT_NONE).
+       */ 
+      enum pipe_format depth_format = fb->zsbuf ?
+         fb->zsbuf->format : PIPE_FORMAT_NONE;
+      const struct util_format_description *depth_desc =
+         util_format_description(depth_format);
+
       util_copy_framebuffer_state(&lp->framebuffer, fb);
 
       if (LP_PERF & PERF_NO_DEPTH) {
 	 pipe_surface_reference(&lp->framebuffer.zsbuf, NULL);
       }
 
-      /* Tell draw module how deep the Z/depth buffer is.
-       *
-       * If no depth buffer is bound, send the utility function the default
-       * format for no bound depth (PIPE_FORMAT_NONE).
-       *
-       * FIXME: mrd constant isn't right should use a value derived from
-       * current primitive not a constant (for float depth buffers)
+      /*
+       * Calculate the floating point depth sense and Minimum Resolvable Depth
+       * value for the llvmpipe module. This is separate from the draw module.
        */
-      lp->mrd = util_get_depth_format_mrd((lp->framebuffer.zsbuf) ?
-                  lp->framebuffer.zsbuf->format : PIPE_FORMAT_NONE);
+      lp->floating_point_depth =
+         (util_get_depth_format_type(depth_desc) == UTIL_FORMAT_TYPE_FLOAT);
+ 
+      lp->mrd = util_get_depth_format_mrd(depth_desc);
 
-      draw_set_mrd(lp->draw, lp->mrd);
+      /* Tell the draw module how deep the Z/depth buffer is. */
+      draw_set_zs_format(lp->draw, depth_format);
 
       lp_setup_bind_framebuffer( lp->setup, &lp->framebuffer );
 
diff --git a/src/gallium/drivers/noop/Makefile.am b/src/gallium/drivers/noop/Makefile.am
index 1f4ba02..cda614d 100644
--- a/src/gallium/drivers/noop/Makefile.am
+++ b/src/gallium/drivers/noop/Makefile.am
@@ -7,9 +7,7 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS)
 
 noinst_LTLIBRARIES = libnoop.la
 
diff --git a/src/gallium/drivers/nouveau/Makefile.am b/src/gallium/drivers/nouveau/Makefile.am
index c4b51d9..7c05223 100644
--- a/src/gallium/drivers/nouveau/Makefile.am
+++ b/src/gallium/drivers/nouveau/Makefile.am
@@ -20,17 +20,17 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libnouveau.la
-
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers/nouveau/include \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_DRIVER_CFLAGS) \
 	$(LIBDRM_CFLAGS) \
-	$(NOUVEAU_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(NOUVEAU_CFLAGS)
+
+noinst_LTLIBRARIES = libnouveau.la
 
 libnouveau_la_SOURCES = \
 	$(C_SOURCES) \
diff --git a/src/gallium/drivers/nouveau/nouveau_video.c b/src/gallium/drivers/nouveau/nouveau_video.c
index 7deea88..f72a096 100644
--- a/src/gallium/drivers/nouveau/nouveau_video.c
+++ b/src/gallium/drivers/nouveau/nouveau_video.c
@@ -519,7 +519,7 @@ nouveau_create_decoder(struct pipe_context *context,
       goto vl;
    if (screen->device->chipset >= 0x98 && screen->device->chipset != 0xa0)
       goto vl;
-   if (screen->device->chipset < 0x31 || screen->device->chipset == 0x35)
+   if (screen->device->chipset < 0x40)
       goto vl;
 
    dec = CALLOC_STRUCT(nouveau_decoder);
@@ -611,7 +611,6 @@ nouveau_create_decoder(struct pipe_context *context,
    BEGIN_NV04(push, NV31_MPEG(FORMAT), 2);
    PUSH_DATA (push, 0);
    switch (templ->entrypoint) {
-      case PIPE_VIDEO_ENTRYPOINT_BITSTREAM: PUSH_DATA (push, 0x100); break;
       case PIPE_VIDEO_ENTRYPOINT_IDCT: PUSH_DATA (push, 1); break;
       case PIPE_VIDEO_ENTRYPOINT_MC: PUSH_DATA (push, 0); break;
       default: assert(0);
@@ -782,7 +781,7 @@ nouveau_video_buffer_create(struct pipe_context *pipe,
     */
    if (templat->buffer_format != PIPE_FORMAT_NV12 || getenv("XVMC_VL") ||
        (screen->device->chipset >= 0x98 && screen->device->chipset != 0xa0) ||
-       screen->device->chipset < 0x31 || screen->device->chipset == 0x35)
+       screen->device->chipset < 0x40)
       return vl_video_buffer_create(pipe, templat);
 
    assert(templat->chroma_format == PIPE_VIDEO_CHROMA_FORMAT_420);
@@ -839,7 +838,8 @@ nouveau_screen_get_video_param(struct pipe_screen *pscreen,
 {
    switch (param) {
    case PIPE_VIDEO_CAP_SUPPORTED:
-      return vl_profile_supported(pscreen, profile, entrypoint);
+      return entrypoint >= PIPE_VIDEO_ENTRYPOINT_IDCT &&
+         u_reduce_video_profile(profile) == PIPE_VIDEO_FORMAT_MPEG12;
    case PIPE_VIDEO_CAP_NPOT_TEXTURES:
       return 1;
    case PIPE_VIDEO_CAP_MAX_WIDTH:
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
index c4bc7dc..490d16e 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_vbo.c
@@ -832,6 +832,7 @@ nvc0_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info)
    if (nvc0->state.vbo_mode) {
       nvc0_push_vbo(nvc0, info);
       push->kick_notify = nvc0_default_kick_notify;
+      nouveau_pushbuf_bufctx(push, NULL);
       return;
    }
 
@@ -888,4 +889,6 @@ nvc0_draw_vbo(struct pipe_context *pipe, const struct pipe_draw_info *info)
    push->kick_notify = nvc0_default_kick_notify;
 
    nvc0_release_user_vbufs(nvc0);
+
+   nouveau_pushbuf_bufctx(push, NULL);
 }
diff --git a/src/gallium/drivers/r300/Makefile.am b/src/gallium/drivers/r300/Makefile.am
index 14aaf03..8aa6707 100644
--- a/src/gallium/drivers/r300/Makefile.am
+++ b/src/gallium/drivers/r300/Makefile.am
@@ -1,34 +1,27 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libr300.la libr300-helper.la
-check_PROGRAMS = r300_compiler_tests
-testdir = compiler/tests
-TESTS = r300_compiler_tests
-
 AM_CFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/src/mesa/program \
 	-I$(top_srcdir)/src/mesa \
 	-I$(top_srcdir)/src/glsl \
 	-I$(top_srcdir)/src/mapi \
-	$(VISIBILITY_CFLAGS) \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_DRIVER_CFLAGS) \
 	$(LLVM_CFLAGS) \
 	$(RADEON_CFLAGS)
 
+noinst_LTLIBRARIES = libr300.la libr300-helper.la
+check_PROGRAMS = r300_compiler_tests
+TESTS = r300_compiler_tests
+
 r300_compiler_tests_LDADD = libr300.la libr300-helper.la \
 	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
 	$(GALLIUM_DRI_LIB_DEPS)
 r300_compiler_tests_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers/r300/compiler
-r300_compiler_tests_SOURCES = \
-	$(testdir)/r300_compiler_tests.c \
-	$(testdir)/radeon_compiler_optimize_tests.c \
-	$(testdir)/radeon_compiler_regalloc_tests.c \
-	$(testdir)/radeon_compiler_util_tests.c \
-	$(testdir)/rc_test_helpers.c \
-	$(testdir)/unit_test.c
+r300_compiler_tests_SOURCES = $(COMPILER_TESTS_SOURCES)
 
 libr300_la_SOURCES = $(C_SOURCES)
 
@@ -39,6 +32,4 @@ libr300_la_SOURCES = $(C_SOURCES)
 #
 # Solve this by building them into a separate helper library that can be linked
 # in place of libmesagallium.
-libr300_helper_la_SOURCES = \
-	$(top_srcdir)/src/glsl/ralloc.c \
-	$(top_srcdir)/src/mesa/program/register_allocate.c
+libr300_helper_la_SOURCES = $(HELPER_SOURCES)
diff --git a/src/gallium/drivers/r300/Makefile.sources b/src/gallium/drivers/r300/Makefile.sources
index 10ceffb..0e9ab52 100644
--- a/src/gallium/drivers/r300/Makefile.sources
+++ b/src/gallium/drivers/r300/Makefile.sources
@@ -1,4 +1,4 @@
-C_SOURCES = \
+C_SOURCES := \
 	r300_blit.c \
 	r300_chipset.c \
 	r300_context.c \
@@ -57,3 +57,15 @@ C_SOURCES = \
 	compiler/r3xx_vertprog.c \
 	compiler/r3xx_vertprog_dump.c \
 	compiler/memory_pool.c
+
+COMPILER_TESTS_SOURCES := \
+	compiler/tests/r300_compiler_tests.c \
+	compiler/tests/radeon_compiler_optimize_tests.c \
+	compiler/tests/radeon_compiler_regalloc_tests.c \
+	compiler/tests/radeon_compiler_util_tests.c \
+	compiler/tests/rc_test_helpers.c \
+	compiler/tests/unit_test.c
+
+HELPER_SOURCES := \
+	ralloc.c \
+	register_allocate.c
diff --git a/src/gallium/drivers/r300/ralloc.c b/src/gallium/drivers/r300/ralloc.c
new file mode 120000
index 0000000..c5402db
--- /dev/null
+++ b/src/gallium/drivers/r300/ralloc.c
@@ -0,0 +1 @@
+../../../glsl/ralloc.c
\ No newline at end of file
diff --git a/src/gallium/drivers/r300/register_allocate.c b/src/gallium/drivers/r300/register_allocate.c
new file mode 120000
index 0000000..2117950
--- /dev/null
+++ b/src/gallium/drivers/r300/register_allocate.c
@@ -0,0 +1 @@
+../../../mesa/program/register_allocate.c
\ No newline at end of file
diff --git a/src/gallium/drivers/r600/Makefile.am b/src/gallium/drivers/r600/Makefile.am
index 0490ba2..b2e3708 100644
--- a/src/gallium/drivers/r600/Makefile.am
+++ b/src/gallium/drivers/r600/Makefile.am
@@ -1,23 +1,17 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libr600.la
-
 AM_CFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS) \
-	$(RADEON_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(RADEON_CFLAGS)
 
 AM_CXXFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/src/gallium/include \
-	-I$(top_srcdir)/src/gallium/auxiliary \
-	$(RADEON_CFLAGS) \
-	$(DEFINES) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CXXFLAGS) \
+	$(RADEON_CFLAGS)
+
+noinst_LTLIBRARIES = libr600.la
 
 libr600_la_SOURCES = \
 	$(C_SOURCES) \
@@ -27,15 +21,15 @@ libr600_la_LIBADD = ../radeon/libradeon.la
 
 if NEED_RADEON_LLVM
 
+AM_CFLAGS += \
+	$(LLVM_CFLAGS) \
+	-I$(top_srcdir)/src/gallium/drivers/radeon/
+
 libr600_la_SOURCES += \
 	$(LLVM_C_SOURCES)
 
 libr600_la_LIBADD += ../radeon/libllvmradeon.la
 
-AM_CFLAGS += \
-	$(LLVM_CFLAGS) \
-	-I$(top_srcdir)/src/gallium/drivers/radeon/
-
 endif
 
 if USE_R600_LLVM_COMPILER
diff --git a/src/gallium/drivers/r600/evergreen_compute.c b/src/gallium/drivers/r600/evergreen_compute.c
index ea77f5e..ffdc5c3 100644
--- a/src/gallium/drivers/r600/evergreen_compute.c
+++ b/src/gallium/drivers/r600/evergreen_compute.c
@@ -392,7 +392,6 @@ static void compute_emit_cs(struct r600_context *ctx, const uint *block_layout,
 		const uint *grid_layout)
 {
 	struct radeon_winsys_cs *cs = ctx->b.rings.gfx.cs;
-	unsigned flush_flags = 0;
 	int i;
 
 	/* make sure that the gfx ring is only one active */
diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index 4535d21..a4a4e3e 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -711,9 +711,14 @@ boolean evergreen_is_format_supported(struct pipe_screen *screen,
 		}
 	}
 
-	if ((usage & PIPE_BIND_SAMPLER_VIEW) &&
-	    r600_is_sampler_format_supported(screen, format)) {
-		retval |= PIPE_BIND_SAMPLER_VIEW;
+	if (usage & PIPE_BIND_SAMPLER_VIEW) {
+		if (target == PIPE_BUFFER) {
+			if (r600_is_vertex_format_supported(format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		} else {
+			if (r600_is_sampler_format_supported(screen, format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		}
 	}
 
 	if ((usage & (PIPE_BIND_RENDER_TARGET |
diff --git a/src/gallium/drivers/r600/r600_asm.c b/src/gallium/drivers/r600/r600_asm.c
index 3cd14fc..86f79e2 100644
--- a/src/gallium/drivers/r600/r600_asm.c
+++ b/src/gallium/drivers/r600/r600_asm.c
@@ -2134,6 +2134,12 @@ void r600_vertex_data_type(enum pipe_format pformat,
 	*format_comp = 0;
 	*endian = ENDIAN_NONE;
 
+	if (pformat == PIPE_FORMAT_R11G11B10_FLOAT) {
+		*format = FMT_10_11_11_FLOAT;
+		*endian = r600_endian_swap(32);
+		return;
+	}
+
 	desc = util_format_description(pformat);
 	if (desc->layout != UTIL_FORMAT_LAYOUT_PLAIN) {
 		goto out_unknown;
diff --git a/src/gallium/drivers/r600/r600_formats.h b/src/gallium/drivers/r600/r600_formats.h
index 6f57228..453c2b1 100644
--- a/src/gallium/drivers/r600/r600_formats.h
+++ b/src/gallium/drivers/r600/r600_formats.h
@@ -87,6 +87,9 @@ static INLINE bool r600_is_vertex_format_supported(enum pipe_format format)
 	const struct util_format_description *desc = util_format_description(format);
 	unsigned i;
 
+	if (format == PIPE_FORMAT_R11G11B10_FLOAT)
+		return true;
+
 	if (!desc)
 		return false;
 
diff --git a/src/gallium/drivers/r600/r600_llvm.c b/src/gallium/drivers/r600/r600_llvm.c
index 34dd3ad..6860faa 100644
--- a/src/gallium/drivers/r600/r600_llvm.c
+++ b/src/gallium/drivers/r600/r600_llvm.c
@@ -77,6 +77,11 @@ static void llvm_load_system_value(
 	default: assert(!"unknown system value");
 	}
 
+#if HAVE_LLVM >= 0x0304
+	ctx->system_values[index] = LLVMBuildExtractElement(ctx->gallivm.builder,
+		LLVMGetParam(ctx->main_fn, 0), lp_build_const_int32(&(ctx->gallivm), chan),
+		"");
+#else
 	LLVMValueRef reg = lp_build_const_int32(
 			ctx->soa.bld_base.base.gallivm, chan);
 	ctx->system_values[index] = build_intrinsic(
@@ -84,8 +89,49 @@ static void llvm_load_system_value(
 			"llvm.R600.load.input",
 			ctx->soa.bld_base.base.elem_type, &reg, 1,
 			LLVMReadNoneAttribute);
+#endif
 }
 
+#if HAVE_LLVM >= 0x0304
+static LLVMValueRef
+llvm_load_input_vector(
+	struct radeon_llvm_context * ctx, unsigned location, unsigned ijregs,
+	boolean interp)
+{
+		LLVMTypeRef VecType;
+		LLVMValueRef Args[3] = {
+			lp_build_const_int32(&(ctx->gallivm), location)
+		};
+		unsigned ArgCount = 1;
+		if (interp) {
+			VecType = LLVMVectorType(ctx->soa.bld_base.base.elem_type, 2);
+			LLVMValueRef IJIndex = LLVMGetParam(ctx->main_fn, ijregs / 2);
+			Args[ArgCount++] = LLVMBuildExtractElement(ctx->gallivm.builder, IJIndex,
+				lp_build_const_int32(&(ctx->gallivm), 2 * (ijregs % 2)), "");
+			Args[ArgCount++] = LLVMBuildExtractElement(ctx->gallivm.builder, IJIndex,
+				lp_build_const_int32(&(ctx->gallivm), 2 * (ijregs % 2) + 1), "");
+			LLVMValueRef HalfVec[2] = {
+				build_intrinsic(ctx->gallivm.builder, "llvm.R600.interp.xy",
+					VecType, Args, ArgCount, LLVMReadNoneAttribute),
+				build_intrinsic(ctx->gallivm.builder, "llvm.R600.interp.zw",
+					VecType, Args, ArgCount, LLVMReadNoneAttribute)
+			};
+			LLVMValueRef MaskInputs[4] = {
+				lp_build_const_int32(&(ctx->gallivm), 0),
+				lp_build_const_int32(&(ctx->gallivm), 1),
+				lp_build_const_int32(&(ctx->gallivm), 2),
+				lp_build_const_int32(&(ctx->gallivm), 3)
+			};
+			LLVMValueRef Mask = LLVMConstVector(MaskInputs, 4);
+			return LLVMBuildShuffleVector(ctx->gallivm.builder, HalfVec[0], HalfVec[1],
+				Mask, "");
+		} else {
+			VecType = LLVMVectorType(ctx->soa.bld_base.base.elem_type, 4);
+			return build_intrinsic(ctx->gallivm.builder, "llvm.R600.interp.const",
+				VecType, Args, ArgCount, LLVMReadNoneAttribute);
+		}
+}
+#else
 static LLVMValueRef
 llvm_load_input_helper(
 	struct radeon_llvm_context * ctx,
@@ -110,7 +156,22 @@ llvm_load_input_helper(
 	return build_intrinsic(bb->gallivm->builder, intrinsic,
 		bb->elem_type, &arg[0], arg_count, LLVMReadNoneAttribute);
 }
+#endif
 
+#if HAVE_LLVM >= 0x0304
+static LLVMValueRef
+llvm_face_select_helper(
+	struct radeon_llvm_context * ctx,
+	LLVMValueRef face, LLVMValueRef front_color, LLVMValueRef back_color)
+{
+	const struct lp_build_context * bb = &ctx->soa.bld_base.base;
+	LLVMValueRef is_front = LLVMBuildFCmp(
+		bb->gallivm->builder, LLVMRealUGT, face,
+		lp_build_const_float(bb->gallivm, 0.0f),	"");
+	return LLVMBuildSelect(bb->gallivm->builder, is_front,
+		front_color, back_color, "");
+}
+#else
 static LLVMValueRef
 llvm_face_select_helper(
 	struct radeon_llvm_context * ctx,
@@ -124,6 +185,7 @@ llvm_face_select_helper(
 	return LLVMBuildSelect(bb->gallivm->builder, is_front,
 		front_color, back_color, "");
 }
+#endif
 
 static void llvm_load_input(
 	struct radeon_llvm_context * ctx,
@@ -132,11 +194,55 @@ static void llvm_load_input(
 {
 	const struct r600_shader_io * input = &ctx->r600_inputs[input_index];
 	unsigned chan;
+#if HAVE_LLVM < 0x0304
 	unsigned interp = 0;
 	int ij_index;
+#endif
 	int two_side = (ctx->two_side && input->name == TGSI_SEMANTIC_COLOR);
 	LLVMValueRef v;
+#if HAVE_LLVM >= 0x0304
+	boolean require_interp_intrinsic = ctx->chip_class >= EVERGREEN &&
+		ctx->type == TGSI_PROCESSOR_FRAGMENT;
+#endif
+
+#if HAVE_LLVM >= 0x0304
+	if (require_interp_intrinsic && input->spi_sid) {
+		v = llvm_load_input_vector(ctx, input->lds_pos, input->ij_index,
+			(input->interpolate > 0));
+	} else
+		v = LLVMGetParam(ctx->main_fn, input->gpr);
+
+	if (two_side) {
+		struct r600_shader_io * back_input =
+			&ctx->r600_inputs[input->back_color_input];
+		LLVMValueRef v2;
+		LLVMValueRef face = LLVMGetParam(ctx->main_fn, ctx->face_gpr);
+		face = LLVMBuildExtractElement(ctx->gallivm.builder, face,
+			lp_build_const_int32(&(ctx->gallivm), 0), "");
+
+		if (require_interp_intrinsic && back_input->spi_sid)
+			v2 = llvm_load_input_vector(ctx, back_input->lds_pos,
+				back_input->ij_index, (back_input->interpolate > 0));
+		else
+			v2 = LLVMGetParam(ctx->main_fn, back_input->gpr);
+		v = llvm_face_select_helper(ctx, face, v, v2);
+	}
 
+	for (chan = 0; chan < 4; chan++) {
+		unsigned soa_index = radeon_llvm_reg_index_soa(input_index, chan);
+
+		ctx->inputs[soa_index] = LLVMBuildExtractElement(ctx->gallivm.builder, v,
+			lp_build_const_int32(&(ctx->gallivm), chan), "");
+
+		if (input->name == TGSI_SEMANTIC_POSITION &&
+				ctx->type == TGSI_PROCESSOR_FRAGMENT && chan == 3) {
+		/* RCP for fragcoord.w */
+		ctx->inputs[soa_index] = LLVMBuildFDiv(ctx->gallivm.builder,
+				lp_build_const_float(&(ctx->gallivm), 1.0f),
+				ctx->inputs[soa_index], "");
+	}
+}
+#else
 	if (ctx->chip_class >= EVERGREEN && ctx->type == TGSI_PROCESSOR_FRAGMENT &&
 			input->spi_sid) {
 		interp = 1;
@@ -177,6 +283,7 @@ static void llvm_load_input(
 
 		ctx->inputs[soa_index] = v;
 	}
+#endif
 }
 
 static void llvm_emit_prologue(struct lp_build_tgsi_context * bld_base)
@@ -415,9 +522,22 @@ static void llvm_emit_tex(
 		case TGSI_OPCODE_TXQ: {
 			struct radeon_llvm_context * ctx = radeon_llvm_context(bld_base);
 			ctx->uses_tex_buffers = true;
-			LLVMValueRef offset = lp_build_const_int32(bld_base->base.gallivm, 0);
+			bool isEgPlus = (ctx->chip_class >= EVERGREEN);
+			LLVMValueRef offset = lp_build_const_int32(bld_base->base.gallivm,
+				isEgPlus ? 0 : 1);
 			LLVMValueRef cvecval = llvm_load_const_buffer(bld_base, offset,
 				LLVM_R600_BUFFER_INFO_CONST_BUFFER);
+			if (!isEgPlus) {
+				LLVMValueRef maskval[4] = {
+					lp_build_const_int32(gallivm, 1),
+					lp_build_const_int32(gallivm, 2),
+					lp_build_const_int32(gallivm, 3),
+					lp_build_const_int32(gallivm, 0),
+				};
+				LLVMValueRef mask = LLVMConstVector(maskval, 4);
+				cvecval = LLVMBuildShuffleVector(gallivm->builder, cvecval, cvecval,
+					mask, "");
+			}
 			emit_data->output[0] = cvecval;
 			return;
 		}
@@ -427,6 +547,35 @@ static void llvm_emit_tex(
 			emit_data->output[0] = build_intrinsic(gallivm->builder,
 							"llvm.R600.load.texbuf",
 							emit_data->dst_type, args, 2, LLVMReadNoneAttribute);
+			if (ctx->chip_class >= EVERGREEN)
+				return;
+			ctx->uses_tex_buffers = true;
+			LLVMDumpValue(emit_data->output[0]);
+			emit_data->output[0] = LLVMBuildBitCast(gallivm->builder,
+				emit_data->output[0], LLVMVectorType(bld_base->base.int_elem_type, 4),
+				"");
+			LLVMValueRef Mask = llvm_load_const_buffer(bld_base,
+				lp_build_const_int32(gallivm, 0),
+				LLVM_R600_BUFFER_INFO_CONST_BUFFER);
+			Mask = LLVMBuildBitCast(gallivm->builder, Mask,
+				LLVMVectorType(bld_base->base.int_elem_type, 4), "");
+			emit_data->output[0] = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_AND,
+				emit_data->output[0],
+				Mask);
+			LLVMValueRef WComponent = LLVMBuildExtractElement(gallivm->builder,
+				emit_data->output[0], lp_build_const_int32(gallivm, 3), "");
+			Mask = llvm_load_const_buffer(bld_base, lp_build_const_int32(gallivm, 1),
+				LLVM_R600_BUFFER_INFO_CONST_BUFFER);
+			Mask = LLVMBuildExtractElement(gallivm->builder, Mask,
+				lp_build_const_int32(gallivm, 0), "");
+			Mask = LLVMBuildBitCast(gallivm->builder, Mask,
+				bld_base->base.int_elem_type, "");
+			WComponent = lp_build_emit_llvm_binary(bld_base, TGSI_OPCODE_OR,
+				WComponent, Mask);
+			emit_data->output[0] = LLVMBuildInsertElement(gallivm->builder,
+				emit_data->output[0], WComponent, lp_build_const_int32(gallivm, 3), "");
+			emit_data->output[0] = LLVMBuildBitCast(gallivm->builder,
+				emit_data->output[0], LLVMVectorType(bld_base->base.elem_type, 4), "");
 		}
 			return;
 		default:
@@ -615,7 +764,19 @@ LLVMModuleRef r600_tgsi_llvm(
 	struct tgsi_shader_info shader_info;
 	struct lp_build_tgsi_context * bld_base = &ctx->soa.bld_base;
 	radeon_llvm_context_init(ctx);
+#if HAVE_LLVM >= 0x0304
+	LLVMTypeRef Arguments[32];
+	unsigned ArgumentsCount = 0;
+	for (unsigned i = 0; i < ctx->inputs_count; i++)
+		Arguments[ArgumentsCount++] = LLVMVectorType(bld_base->base.elem_type, 4);
+	radeon_llvm_create_func(ctx, Arguments, ArgumentsCount);
+	for (unsigned i = 0; i < ctx->inputs_count; i++) {
+		LLVMValueRef P = LLVMGetParam(ctx->main_fn, i);
+		LLVMAddAttribute(P, LLVMInRegAttribute);
+	}
+#else
 	radeon_llvm_create_func(ctx, NULL, 0);
+#endif
 	tgsi_scan_shader(tokens, &shader_info);
 
 	bld_base->info = &shader_info;
@@ -670,6 +831,7 @@ unsigned r600_llvm_compile(
 	const char * gpu_family = r600_llvm_gpu_string(family);
 	unsigned i;
 
+	memset(&binary, 0, sizeof(struct radeon_llvm_binary));
 	r = radeon_llvm_compile(mod, &binary, gpu_family, dump);
 
 	assert(binary.code_size % 4 == 0);
@@ -702,6 +864,9 @@ unsigned r600_llvm_compile(
 		}
 	}
 
+	FREE(binary.code);
+	FREE(binary.config);
+
 	return r;
 }
 
diff --git a/src/gallium/drivers/r600/r600_pipe.h b/src/gallium/drivers/r600/r600_pipe.h
index 6aa944c..d7af618 100644
--- a/src/gallium/drivers/r600/r600_pipe.h
+++ b/src/gallium/drivers/r600/r600_pipe.h
@@ -538,7 +538,7 @@ static INLINE void r600_set_cso_state_with_cb(struct r600_cso_state *state, void
 					      struct r600_command_buffer *cb)
 {
 	state->cb = cb;
-	state->atom.num_dw = cb->num_dw;
+	state->atom.num_dw = cb ? cb->num_dw : 0;
 	r600_set_cso_state(state, cso);
 }
 
diff --git a/src/gallium/drivers/r600/r600_shader.c b/src/gallium/drivers/r600/r600_shader.c
index aed2100..1ea4ae6 100644
--- a/src/gallium/drivers/r600/r600_shader.c
+++ b/src/gallium/drivers/r600/r600_shader.c
@@ -1102,6 +1102,7 @@ static int r600_shader_from_tgsi(struct r600_screen *rscreen,
 		radeon_llvm_ctx.type = ctx.type;
 		radeon_llvm_ctx.two_side = shader->two_side;
 		radeon_llvm_ctx.face_gpr = ctx.face_gpr;
+		radeon_llvm_ctx.inputs_count = ctx.shader->ninput + 1;
 		radeon_llvm_ctx.r600_inputs = ctx.shader->input;
 		radeon_llvm_ctx.r600_outputs = ctx.shader->output;
 		radeon_llvm_ctx.color_buffer_count = max_color_exports;
diff --git a/src/gallium/drivers/r600/r600_state.c b/src/gallium/drivers/r600/r600_state.c
index f148052..41e9c5d 100644
--- a/src/gallium/drivers/r600/r600_state.c
+++ b/src/gallium/drivers/r600/r600_state.c
@@ -649,9 +649,14 @@ boolean r600_is_format_supported(struct pipe_screen *screen,
 		}
 	}
 
-	if ((usage & PIPE_BIND_SAMPLER_VIEW) &&
-	    r600_is_sampler_format_supported(screen, format)) {
-		retval |= PIPE_BIND_SAMPLER_VIEW;
+	if (usage & PIPE_BIND_SAMPLER_VIEW) {
+		if (target == PIPE_BUFFER) {
+			if (r600_is_vertex_format_supported(format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		} else {
+			if (r600_is_sampler_format_supported(screen, format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		}
 	}
 
 	if ((usage & (PIPE_BIND_RENDER_TARGET |
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index 8f164bf..7d3c5bc 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -269,8 +269,10 @@ static void r600_bind_dsa_state(struct pipe_context *ctx, void *state)
 	struct r600_dsa_state *dsa = state;
 	struct r600_stencil_ref ref;
 
-	if (state == NULL)
+	if (state == NULL) {
+		r600_set_cso_state_with_cb(&rctx->dsa_state, NULL, NULL);
 		return;
+	}
 
 	r600_set_cso_state_with_cb(&rctx->dsa_state, dsa, &dsa->buffer);
 
@@ -458,8 +460,13 @@ static void r600_delete_blend_state(struct pipe_context *ctx, void *state)
 
 static void r600_delete_dsa_state(struct pipe_context *ctx, void *state)
 {
+	struct r600_context *rctx = (struct r600_context *)ctx;
 	struct r600_dsa_state *dsa = (struct r600_dsa_state *)state;
 
+	if (rctx->dsa_state.cso == state) {
+		ctx->bind_depth_stencil_alpha_state(ctx, NULL);
+	}
+
 	r600_release_command_buffer(&dsa->buffer);
 	free(dsa);
 }
diff --git a/src/gallium/drivers/r600/sb/sb_bc.h b/src/gallium/drivers/r600/sb/sb_bc.h
index ad1b862..73b8b08 100644
--- a/src/gallium/drivers/r600/sb/sb_bc.h
+++ b/src/gallium/drivers/r600/sb/sb_bc.h
@@ -614,6 +614,10 @@ public:
 	unsigned num_slots;
 	bool uses_mova_gpr;
 
+	bool stack_workaround_8xx;
+	bool stack_workaround_9xx;
+
+	unsigned wavefront_size;
 	unsigned stack_entry_size;
 
 	static unsigned dump_pass;
@@ -638,6 +642,23 @@ public:
 	bool is_cayman() {return hw_class == HW_CLASS_CAYMAN;}
 	bool is_egcm() {return hw_class >= HW_CLASS_EVERGREEN;}
 
+	bool needs_8xx_stack_workaround() {
+		if (!is_evergreen())
+			return false;
+
+		switch (hw_chip) {
+		case HW_CHIP_CYPRESS:
+		case HW_CHIP_JUNIPER:
+			return false;
+		default:
+			return true;
+		}
+	}
+
+	bool needs_9xx_stack_workaround() {
+		return is_cayman();
+	}
+
 	sb_hw_class_bits hw_class_bit() {
 		switch (hw_class) {
 		case HW_CLASS_R600:return HB_R6;
diff --git a/src/gallium/drivers/r600/sb/sb_bc_finalize.cpp b/src/gallium/drivers/r600/sb/sb_bc_finalize.cpp
index c56c866..bc71cf8 100644
--- a/src/gallium/drivers/r600/sb/sb_bc_finalize.cpp
+++ b/src/gallium/drivers/r600/sb/sb_bc_finalize.cpp
@@ -40,8 +40,9 @@ namespace r600_sb {
 
 int bc_finalizer::run() {
 
-	regions_vec &rv = sh.get_regions();
+	run_on(sh.root);
 
+	regions_vec &rv = sh.get_regions();
 	for (regions_vec::reverse_iterator I = rv.rbegin(), E = rv.rend(); I != E;
 			++I) {
 		region_node *r = *I;
@@ -58,8 +59,6 @@ int bc_finalizer::run() {
 		r->expand();
 	}
 
-	run_on(sh.root);
-
 	cf_peephole();
 
 	// workaround for some problems on r6xx/7xx
@@ -213,18 +212,36 @@ void bc_finalizer::run_on(container_node* c) {
 		if (n->is_alu_group()) {
 			finalize_alu_group(static_cast<alu_group_node*>(n));
 		} else {
-			if (n->is_fetch_inst()) {
+			if (n->is_alu_clause()) {
+				cf_node *c = static_cast<cf_node*>(n);
+
+				if (c->bc.op == CF_OP_ALU_PUSH_BEFORE && ctx.is_egcm()) {
+					if (ctx.stack_workaround_8xx) {
+						region_node *r = c->get_parent_region();
+						if (r) {
+							unsigned ifs, loops;
+							unsigned elems = get_stack_depth(r, loops, ifs);
+							unsigned dmod1 = elems % ctx.stack_entry_size;
+							unsigned dmod2 = (elems + 1) % ctx.stack_entry_size;
+
+							if (elems && (!dmod1 || !dmod2))
+								c->flags |= NF_ALU_STACK_WORKAROUND;
+						}
+					} else if (ctx.stack_workaround_9xx) {
+						region_node *r = c->get_parent_region();
+						if (r) {
+							unsigned ifs, loops;
+							get_stack_depth(r, loops, ifs);
+							if (loops >= 2)
+								c->flags |= NF_ALU_STACK_WORKAROUND;
+						}
+					}
+				}
+			} else if (n->is_fetch_inst()) {
 				finalize_fetch(static_cast<fetch_node*>(n));
 			} else if (n->is_cf_inst()) {
 				finalize_cf(static_cast<cf_node*>(n));
-			} else if (n->is_alu_clause()) {
-
-			} else if (n->is_fetch_clause()) {
-
-			} else {
-				assert(!"unexpected node");
 			}
-
 			if (n->is_container())
 				run_on(static_cast<container_node*>(n));
 		}
@@ -578,10 +595,6 @@ void bc_finalizer::finalize_cf(cf_node* c) {
 
 	unsigned flags = c->bc.op_ptr->flags;
 
-	if (flags & CF_CALL) {
-		update_nstack(c->get_parent_region(), ctx.is_cayman() ? 1 : 2);
-	}
-
 	c->bc.end_of_program = 0;
 	last_cf = c;
 
@@ -715,17 +728,8 @@ void bc_finalizer::finalize_cf(cf_node* c) {
 
 			c->bc.index_gpr = reg >= 0 ? reg : 0;
 		}
-
-
-
-	} else {
-
-#if 0
-		if ((flags & (CF_BRANCH | CF_LOOP)) && !sh.uses_gradients) {
-			c->bc.valid_pixel_mode = 1;
-		}
-#endif
-
+	} else if (flags & CF_CALL) {
+		update_nstack(c->get_parent_region(), ctx.wavefront_size == 16 ? 2 : 1);
 	}
 }
 
@@ -763,37 +767,78 @@ void bc_finalizer::update_ngpr(unsigned gpr) {
 		ngpr = gpr + 1;
 }
 
-void bc_finalizer::update_nstack(region_node* r, unsigned add) {
-	unsigned loops = 0;
-	unsigned ifs = 0;
+unsigned bc_finalizer::get_stack_depth(node *n, unsigned &loops,
+                                           unsigned &ifs, unsigned add) {
+	unsigned stack_elements = add;
+	bool has_non_wqm_push_with_loops_on_stack = false;
+	bool has_non_wqm_push = (add != 0);
+	region_node *r = n->is_region() ?
+			static_cast<region_node*>(n) : n->get_parent_region();
+
+	loops = 0;
+	ifs = 0;
 
 	while (r) {
-		if (r->is_loop())
+		if (r->is_loop()) {
 			++loops;
-		else
+			if (has_non_wqm_push)
+				has_non_wqm_push_with_loops_on_stack = true;
+		} else {
 			++ifs;
-
+			has_non_wqm_push = true;
+		}
 		r = r->get_parent_region();
 	}
-
-	unsigned stack_elements = (loops * ctx.stack_entry_size) + ifs + add;
-
-	// FIXME calculate more precisely
-	if (ctx.is_evergreen()) {
-		++stack_elements;
-	} else {
-		stack_elements += 2;
-		if (ctx.is_cayman())
+	stack_elements += (loops * ctx.stack_entry_size) + ifs;
+
+	// reserve additional elements in some cases
+	switch (ctx.hw_class) {
+	case HW_CLASS_R600:
+	case HW_CLASS_R700:
+		if (has_non_wqm_push)
+			stack_elements += 2;
+		break;
+	case HW_CLASS_CAYMAN:
+		if (stack_elements)
+			stack_elements += 2;
+		break;
+	case HW_CLASS_EVERGREEN:
+		if (has_non_wqm_push_with_loops_on_stack)
 			++stack_elements;
+		break;
 	}
+	return stack_elements;
+}
 
-	unsigned stack_entries = (stack_elements + 3) >> 2;
+void bc_finalizer::update_nstack(region_node* r, unsigned add) {
+	unsigned loops = 0;
+	unsigned ifs = 0;
+	unsigned elems = r ? get_stack_depth(r, loops, ifs, add) : add;
+
+	// XXX all chips expect this value to be computed using 4 as entry size,
+	// not the real entry size
+	unsigned stack_entries = (elems + 3) >> 2;
 
 	if (nstack < stack_entries)
 		nstack = stack_entries;
 }
 
 void bc_finalizer::cf_peephole() {
+	if (ctx.stack_workaround_8xx || ctx.stack_workaround_9xx) {
+		for (node_iterator N, I = sh.root->begin(), E = sh.root->end(); I != E;
+				I = N) {
+			N = I; ++N;
+			cf_node *c = static_cast<cf_node*>(*I);
+
+			if (c->bc.op == CF_OP_ALU_PUSH_BEFORE &&
+					(c->flags & NF_ALU_STACK_WORKAROUND)) {
+				cf_node *push = sh.create_cf(CF_OP_PUSH);
+				c->insert_before(push);
+				push->jump(c);
+				c->bc.set_op(CF_OP_ALU);
+			}
+		}
+	}
 
 	for (node_iterator N, I = sh.root->begin(), E = sh.root->end(); I != E;
 			I = N) {
diff --git a/src/gallium/drivers/r600/sb/sb_context.cpp b/src/gallium/drivers/r600/sb/sb_context.cpp
index 9474f74..8e11428 100644
--- a/src/gallium/drivers/r600/sb/sb_context.cpp
+++ b/src/gallium/drivers/r600/sb/sb_context.cpp
@@ -66,20 +66,27 @@ int sb_context::init(r600_isa *isa, sb_hw_chip chip, sb_hw_class cclass) {
 	case HW_CHIP_RS780:
 	case HW_CHIP_RV620:
 	case HW_CHIP_RS880:
-
+		wavefront_size = 16;
+		stack_entry_size = 8;
+		break;
 	case HW_CHIP_RV630:
 	case HW_CHIP_RV635:
 	case HW_CHIP_RV730:
 	case HW_CHIP_RV710:
 	case HW_CHIP_PALM:
 	case HW_CHIP_CEDAR:
+		wavefront_size = 32;
 		stack_entry_size = 8;
 		break;
 	default:
+		wavefront_size = 64;
 		stack_entry_size = 4;
 		break;
 	}
 
+	stack_workaround_8xx = needs_8xx_stack_workaround();
+	stack_workaround_9xx = needs_9xx_stack_workaround();
+
 	return 0;
 }
 
diff --git a/src/gallium/drivers/r600/sb/sb_ir.h b/src/gallium/drivers/r600/sb/sb_ir.h
index a74d6cb..85c3d06 100644
--- a/src/gallium/drivers/r600/sb/sb_ir.h
+++ b/src/gallium/drivers/r600/sb/sb_ir.h
@@ -700,7 +700,10 @@ enum node_flags {
 	NF_DONT_MOVE = (1 << 8),
 
 	// for KILLxx - we want to schedule them as early as possible
-	NF_SCHEDULE_EARLY = (1 << 9)
+	NF_SCHEDULE_EARLY = (1 << 9),
+
+	// for ALU_PUSH_BEFORE - when set, replace with PUSH + ALU
+	NF_ALU_STACK_WORKAROUND = (1 << 10)
 };
 
 inline node_flags operator |(node_flags l, node_flags r) {
diff --git a/src/gallium/drivers/r600/sb/sb_pass.h b/src/gallium/drivers/r600/sb/sb_pass.h
index a3f8515..c955656 100644
--- a/src/gallium/drivers/r600/sb/sb_pass.h
+++ b/src/gallium/drivers/r600/sb/sb_pass.h
@@ -708,6 +708,9 @@ public:
 	void update_ngpr(unsigned gpr);
 	void update_nstack(region_node *r, unsigned add = 0);
 
+	unsigned get_stack_depth(node *n, unsigned &loops, unsigned &ifs,
+	                         unsigned add = 0);
+
 	void cf_peephole();
 
 };
diff --git a/src/gallium/drivers/r600/sb/sb_sched.cpp b/src/gallium/drivers/r600/sb/sb_sched.cpp
index 2792315..1413916 100644
--- a/src/gallium/drivers/r600/sb/sb_sched.cpp
+++ b/src/gallium/drivers/r600/sb/sb_sched.cpp
@@ -527,7 +527,7 @@ bool alu_group_tracker::try_reserve(alu_node* n) {
 				forced_swz_slots |= (1 << i);
 				a->bc.bank_swizzle = VEC_210;
 				if (!gpr.try_reserve(a))
-					assert("!internal reservation error");
+					assert(!"internal reservation error");
 			} else {
 				if (first_nf == ~0)
 					first_nf = i;
diff --git a/src/gallium/drivers/radeon/Makefile.am b/src/gallium/drivers/radeon/Makefile.am
index a54a3aa..457fee9 100644
--- a/src/gallium/drivers/radeon/Makefile.am
+++ b/src/gallium/drivers/radeon/Makefile.am
@@ -1,29 +1,26 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libradeon.la
 
-AM_CFLAGS = $(GALLIUM_CFLAGS) $(RADEON_CFLAGS) $(VISIBILITY_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(RADEON_CFLAGS)
+
+noinst_LTLIBRARIES = libradeon.la
 
 libradeon_la_SOURCES = \
 	$(C_SOURCES)
 
 if NEED_RADEON_LLVM
 
-libllvmradeon_la_LDFLAGS = \
-	$(LLVM_LDFLAGS)
-
 noinst_LTLIBRARIES += libllvmradeon.la
 
 libllvmradeon_la_CXXFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(DEFINES) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CXXFLAGS)
 
 libllvmradeon_la_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(LLVM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(LLVM_CFLAGS)
 
 libllvmradeon_la_SOURCES = \
 	$(LLVM_CPP_FILES) \
@@ -34,4 +31,7 @@ libllvmradeon_la_LIBADD = \
 	$(LLVM_LIBS) \
 	$(ELF_LIB)
 
+libllvmradeon_la_LDFLAGS = \
+	$(LLVM_LDFLAGS)
+
 endif
diff --git a/src/gallium/drivers/radeon/radeon_llvm.h b/src/gallium/drivers/radeon/radeon_llvm.h
index ef09dc8..2cab6b0 100644
--- a/src/gallium/drivers/radeon/radeon_llvm.h
+++ b/src/gallium/drivers/radeon/radeon_llvm.h
@@ -60,6 +60,7 @@ struct radeon_llvm_context {
 	unsigned face_gpr;
 	unsigned two_side;
 	unsigned clip_vertex;
+	unsigned inputs_count;
 	struct r600_shader_io * r600_inputs;
 	struct r600_shader_io * r600_outputs;
 	struct pipe_stream_output_info *stream_outputs;
diff --git a/src/gallium/drivers/radeon/radeon_llvm_emit.c b/src/gallium/drivers/radeon/radeon_llvm_emit.c
index 8bf278b..92e7dbc 100644
--- a/src/gallium/drivers/radeon/radeon_llvm_emit.c
+++ b/src/gallium/drivers/radeon/radeon_llvm_emit.c
@@ -173,6 +173,10 @@ unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_llvm_binary *binary,
 		}
 	}
 
+	if (elf){
+		elf_end(elf);
+	}
+	FREE(elf_buffer);
 	LLVMDisposeMemoryBuffer(out_buffer);
 	LLVMDisposeTargetMachine(tm);
 	return 0;
diff --git a/src/gallium/drivers/radeon/radeon_llvm_util.c b/src/gallium/drivers/radeon/radeon_llvm_util.c
index 7192dee..f2b3e13 100644
--- a/src/gallium/drivers/radeon/radeon_llvm_util.c
+++ b/src/gallium/drivers/radeon/radeon_llvm_util.c
@@ -42,6 +42,7 @@ LLVMModuleRef radeon_llvm_parse_bitcode(const unsigned char * bitcode,
 	buf = LLVMCreateMemoryBufferWithMemoryRangeCopy((const char*)bitcode,
 							bitcode_len, "radeon");
 	LLVMParseBitcodeInContext(ctx, buf, &module, NULL);
+	LLVMDisposeMemoryBuffer(buf);
 	return module;
 }
 
diff --git a/src/gallium/drivers/radeon/radeon_setup_tgsi_llvm.c b/src/gallium/drivers/radeon/radeon_setup_tgsi_llvm.c
index 286ccdd..57026bf 100644
--- a/src/gallium/drivers/radeon/radeon_setup_tgsi_llvm.c
+++ b/src/gallium/drivers/radeon/radeon_setup_tgsi_llvm.c
@@ -1379,7 +1379,7 @@ void radeon_llvm_finalize_module(struct radeon_llvm_context * ctx)
 	LLVMAddAggressiveDCEPass(gallivm->passmgr);
 	LLVMAddCFGSimplificationPass(gallivm->passmgr);
 
-	/* Run the passs */
+	/* Run the pass */
 	LLVMRunFunctionPassManager(gallivm->passmgr, ctx->main_fn);
 
 	LLVMDisposeBuilder(gallivm->builder);
diff --git a/src/gallium/drivers/radeonsi/Makefile.am b/src/gallium/drivers/radeonsi/Makefile.am
index 9aaab8f..84c99f8 100644
--- a/src/gallium/drivers/radeonsi/Makefile.am
+++ b/src/gallium/drivers/radeonsi/Makefile.am
@@ -23,17 +23,13 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = libradeonsi.la
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers/radeon \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS) \
-	$(RADEON_CFLAGS)
 AM_CFLAGS = \
-	$(LLVM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	-I$(top_srcdir)/src/gallium/drivers/radeon \
+	$(GALLIUM_DRIVER_CFLAGS) \
+	$(RADEON_CFLAGS) \
+	$(LLVM_CFLAGS)
+
+noinst_LTLIBRARIES = libradeonsi.la
 
 libradeonsi_la_SOURCES = $(C_SOURCES)
 libradeonsi_la_LIBADD = \
diff --git a/src/gallium/drivers/radeonsi/radeonsi_compute.c b/src/gallium/drivers/radeonsi/radeonsi_compute.c
index 265dbd7..5df972f 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_compute.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_compute.c
@@ -49,6 +49,7 @@ static void *radeonsi_create_compute_state(
 		LLVMModuleRef mod = radeon_llvm_get_kernel_module(i, code,
 							header->num_bytes);
 		si_compile_llvm(rctx, &program->kernels[i], mod);
+		LLVMDisposeModule(mod);
 	}
 
 	return program;
@@ -161,9 +162,18 @@ static void radeonsi_launch_grid(
 		si_pm4_add_bo(pm4, buffer, RADEON_USAGE_READWRITE);
 	}
 
-	/* XXX: This should be:
-	 * (number of compute units) * 4 * (waves per simd) - 1 */
-	si_pm4_set_reg(pm4, R_00B82C_COMPUTE_MAX_WAVE_ID, 0x190 /* Default value */);
+	/* This register has been moved to R_00CD20_COMPUTE_MAX_WAVE_ID
+	 * and is now per pipe, so it should be handled in the
+	 * kernel if we want to use something other than the default value,
+	 * which is now 0x22f.
+	 */
+	if (rctx->b.chip_class <= SI) {
+		/* XXX: This should be:
+		 * (number of compute units) * 4 * (waves per simd) - 1 */
+
+		si_pm4_set_reg(pm4, R_00B82C_COMPUTE_MAX_WAVE_ID,
+						0x190 /* Default value */);
+	}
 
 	shader_va = r600_resource_va(ctx->screen, (void *)shader->bo);
 	si_pm4_add_bo(pm4, shader->bo, RADEON_USAGE_READ);
@@ -236,7 +246,21 @@ static void radeonsi_launch_grid(
 }
 
 
-static void si_delete_compute_state(struct pipe_context *ctx, void* state){}
+static void si_delete_compute_state(struct pipe_context *ctx, void* state){
+	struct si_pipe_compute *program = (struct si_pipe_compute *)state;
+
+	if (!state) {
+		return;
+	}
+
+	if (program->kernels) {
+		FREE(program->kernels);
+	}
+
+	//And then free the program itself.
+	FREE(program);
+}
+
 static void si_set_compute_resources(struct pipe_context * ctx_,
 		unsigned start, unsigned count,
 		struct pipe_surface ** surfaces) { }
diff --git a/src/gallium/drivers/radeonsi/radeonsi_pipe.c b/src/gallium/drivers/radeonsi/radeonsi_pipe.c
index 6da4c5e..1f92791 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_pipe.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_pipe.c
@@ -101,6 +101,7 @@ static void r600_destroy_context(struct pipe_context *context)
 
 	si_release_all_descriptors(rctx);
 
+	pipe_resource_reference(&rctx->null_const_buf.buffer, NULL);
 	r600_resource_reference(&rctx->border_color_table, NULL);
 
 	if (rctx->dummy_pixel_shader) {
@@ -131,6 +132,7 @@ static struct pipe_context *r600_create_context(struct pipe_screen *screen, void
 {
 	struct r600_context *rctx = CALLOC_STRUCT(r600_context);
 	struct r600_screen* rscreen = (struct r600_screen *)screen;
+	int shader, i;
 
 	if (rctx == NULL)
 		return NULL;
@@ -208,6 +210,26 @@ static struct pipe_context *r600_create_context(struct pipe_screen *screen, void
 	/* these must be last */
 	si_begin_new_cs(rctx);
 	si_get_backend_mask(rctx);
+
+	/* CIK cannot unbind a constant buffer (S_BUFFER_LOAD is buggy
+	 * with a NULL buffer). We need to use a dummy buffer instead. */
+	if (rctx->b.chip_class == CIK) {
+		rctx->null_const_buf.buffer = pipe_buffer_create(screen, PIPE_BIND_CONSTANT_BUFFER,
+								 PIPE_USAGE_STATIC, 16);
+		rctx->null_const_buf.buffer_size = rctx->null_const_buf.buffer->width0;
+
+		for (shader = 0; shader < SI_NUM_SHADERS; shader++) {
+			for (i = 0; i < NUM_CONST_BUFFERS; i++) {
+				rctx->b.b.set_constant_buffer(&rctx->b.b, shader, i,
+							      &rctx->null_const_buf);
+			}
+		}
+
+		/* Clear the NULL constant buffer, because loads should return zeros. */
+		rctx->b.clear_buffer(&rctx->b.b, rctx->null_const_buf.buffer, 0,
+				     rctx->null_const_buf.buffer->width0, 0);
+	}
+
 	return &rctx->b.b;
 fail:
 	r600_destroy_context(&rctx->b.b);
@@ -236,6 +258,7 @@ const char *r600_get_llvm_processor_name(enum radeon_family family)
 		case CHIP_BONAIRE: return "bonaire";
 		case CHIP_KABINI: return "kabini";
 		case CHIP_KAVERI: return "kaveri";
+		case CHIP_HAWAII: return "hawaii";
 		default: return "";
 #endif
 	}
@@ -252,6 +275,7 @@ static const char *r600_get_family_name(enum radeon_family family)
 	case CHIP_BONAIRE: return "AMD BONAIRE";
 	case CHIP_KAVERI: return "AMD KAVERI";
 	case CHIP_KABINI: return "AMD KABINI";
+	case CHIP_HAWAII: return "AMD HAWAII";
 	default: return "AMD unknown";
 	}
 }
@@ -305,6 +329,7 @@ static int r600_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
         case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
 	case PIPE_CAP_TGSI_INSTANCEID:
 	case PIPE_CAP_COMPUTE:
+	case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
 		return 1;
 
 	case PIPE_CAP_TEXTURE_MULTISAMPLE:
@@ -320,7 +345,12 @@ static int r600_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
 		return 256;
 
 	case PIPE_CAP_GLSL_FEATURE_LEVEL:
-		return 130;
+		return 140;
+
+	case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
+		return 1;
+	case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
+		return MIN2(rscreen->b.info.vram_size, 0xFFFFFFFF);
 
 	/* Unsupported features. */
 	case PIPE_CAP_TGSI_FS_COORD_ORIGIN_LOWER_LEFT:
@@ -333,12 +363,11 @@ static int r600_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
 	case PIPE_CAP_USER_VERTEX_BUFFERS:
 	case PIPE_CAP_QUERY_PIPELINE_STATISTICS:
 	case PIPE_CAP_CUBE_MAP_ARRAY:
-	case PIPE_CAP_TEXTURE_BUFFER_OBJECTS:
-	case PIPE_CAP_TEXTURE_BUFFER_OFFSET_ALIGNMENT:
-	case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
-        case PIPE_CAP_MAX_TEXTURE_BUFFER_SIZE:
 		return 0;
 
+	case PIPE_CAP_TEXTURE_BORDER_COLOR_QUIRK:
+		return PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_R600;
+
 	/* Stream output. */
 	case PIPE_CAP_MAX_STREAM_OUTPUT_BUFFERS:
 		return has_streamout ? 4 : 0;
@@ -444,7 +473,7 @@ static int r600_get_shader_param(struct pipe_screen* pscreen, unsigned shader, e
 	case PIPE_SHADER_CAP_MAX_CONSTS:
 		return 4096; /* actually only memory limits this */
 	case PIPE_SHADER_CAP_MAX_CONST_BUFFERS:
-		return 1;
+		return NUM_PIPE_CONST_BUFFERS;
 	case PIPE_SHADER_CAP_MAX_PREDS:
 		return 0; /* FIXME */
 	case PIPE_SHADER_CAP_TGSI_CONT_SUPPORTED:
diff --git a/src/gallium/drivers/radeonsi/radeonsi_pipe.h b/src/gallium/drivers/radeonsi/radeonsi_pipe.h
index 1d4a91b..de613e0 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_pipe.h
+++ b/src/gallium/drivers/radeonsi/radeonsi_pipe.h
@@ -171,6 +171,7 @@ struct r600_context {
 	 * In that case, we bind this one: */
 	struct si_pipe_shader	*dummy_pixel_shader;
 	struct r600_atom	cache_flush;
+	struct pipe_constant_buffer null_const_buf; /* used for set_constant_buffer(NULL) on CIK */
 
 	/* SI state handling */
 	union si_state	queued;
diff --git a/src/gallium/drivers/radeonsi/radeonsi_shader.c b/src/gallium/drivers/radeonsi/radeonsi_shader.c
index dff8be0..61e619a 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_shader.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_shader.c
@@ -66,11 +66,11 @@ struct si_shader_context
 	int param_vertex_id;
 	int param_instance_id;
 	LLVMValueRef const_md;
-	LLVMValueRef const_resource;
+	LLVMValueRef const_resource[NUM_CONST_BUFFERS];
 #if HAVE_LLVM >= 0x0304
 	LLVMValueRef ddxy_lds;
 #endif
-	LLVMValueRef *constants;
+	LLVMValueRef *constants[NUM_CONST_BUFFERS];
 	LLVMValueRef *resources;
 	LLVMValueRef *samplers;
 	LLVMValueRef so_buffers[4];
@@ -444,7 +444,7 @@ static LLVMValueRef fetch_constant(
 	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
 	struct lp_build_context * base = &bld_base->base;
 	const struct tgsi_ind_register *ireg = &reg->Indirect;
-	unsigned idx;
+	unsigned buf, idx;
 
 	LLVMValueRef args[2];
 	LLVMValueRef addr;
@@ -459,11 +459,13 @@ static LLVMValueRef fetch_constant(
 		return lp_build_gather_values(bld_base->base.gallivm, values, 4);
 	}
 
+	buf = reg->Register.Dimension ? reg->Dimension.Index : 0;
 	idx = reg->Register.Index * 4 + swizzle;
+
 	if (!reg->Register.Indirect)
-		return bitcast(bld_base, type, si_shader_ctx->constants[idx]);
+		return bitcast(bld_base, type, si_shader_ctx->constants[buf][idx]);
 
-	args[0] = si_shader_ctx->const_resource;
+	args[0] = si_shader_ctx->const_resource[buf];
 	args[1] = lp_build_const_int32(base->gallivm, idx * 4);
 	addr = si_shader_ctx->radeon_bld.soa.addr[ireg->Index][ireg->Swizzle];
 	addr = LLVMBuildLoad(base->gallivm->builder, addr, "load addr reg");
@@ -624,7 +626,8 @@ static void si_llvm_emit_clipvertex(struct lp_build_tgsi_context * bld_base,
 	LLVMValueRef out_elts[4];
 	LLVMValueRef base_elt;
 	LLVMValueRef ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
-	LLVMValueRef const_resource = build_indexed_load(si_shader_ctx, ptr, uint->one);
+	LLVMValueRef constbuf_index = lp_build_const_int32(base->gallivm, NUM_PIPE_CONST_BUFFERS);
+	LLVMValueRef const_resource = build_indexed_load(si_shader_ctx, ptr, constbuf_index);
 
 	for (chan = 0; chan < TGSI_NUM_CHANNELS; chan++) {
 		LLVMValueRef out_ptr = si_shader_ctx->radeon_bld.soa.outputs[index][chan];
@@ -1186,13 +1189,34 @@ static void tex_fetch_args(
 	const struct tgsi_full_instruction * inst = emit_data->inst;
 	unsigned opcode = inst->Instruction.Opcode;
 	unsigned target = inst->Texture.Texture;
-	unsigned sampler_src, sampler_index;
 	LLVMValueRef coords[4];
 	LLVMValueRef address[16];
 	int ref_pos;
 	unsigned num_coords = tgsi_util_get_texture_coord_dim(target, &ref_pos);
 	unsigned count = 0;
 	unsigned chan;
+	unsigned sampler_src = emit_data->inst->Instruction.NumSrcRegs - 1;
+	unsigned sampler_index = emit_data->inst->Src[sampler_src].Register.Index;
+
+	if (target == TGSI_TEXTURE_BUFFER) {
+		LLVMTypeRef i128 = LLVMIntTypeInContext(gallivm->context, 128);
+		LLVMTypeRef v2i128 = LLVMVectorType(i128, 2);
+		LLVMTypeRef i8 = LLVMInt8TypeInContext(gallivm->context);
+		LLVMTypeRef v16i8 = LLVMVectorType(i8, 16);
+
+		/* Truncate v32i8 to v16i8. */
+		LLVMValueRef res = si_shader_ctx->resources[sampler_index];
+		res = LLVMBuildBitCast(gallivm->builder, res, v2i128, "");
+		res = LLVMBuildExtractElement(gallivm->builder, res, bld_base->uint_bld.zero, "");
+		res = LLVMBuildBitCast(gallivm->builder, res, v16i8, "");
+
+		emit_data->dst_type = LLVMVectorType(bld_base->base.elem_type, 4);
+		emit_data->args[0] = res;
+		emit_data->args[1] = bld_base->uint_bld.zero;
+		emit_data->args[2] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, 0);
+		emit_data->arg_count = 3;
+		return;
+	}
 
 	/* Fetch and project texture coordinates */
 	coords[3] = lp_build_emit_fetch(bld_base, emit_data->inst, 0, TGSI_CHAN_W);
@@ -1264,9 +1288,6 @@ static void tex_fetch_args(
 						 "");
 	}
 
-	sampler_src = emit_data->inst->Instruction.NumSrcRegs - 1;
-	sampler_index = emit_data->inst->Src[sampler_src].Register.Index;
-
 	/* Adjust the sample index according to FMASK.
 	 *
 	 * For uncompressed MSAA surfaces, FMASK should return 0x76543210,
@@ -1427,6 +1448,15 @@ static void build_tex_intrinsic(const struct lp_build_tgsi_action * action,
 	struct lp_build_context * base = &bld_base->base;
 	char intr_name[127];
 
+	if (emit_data->inst->Texture.Texture == TGSI_TEXTURE_BUFFER) {
+		emit_data->output[emit_data->chan] = build_intrinsic(
+			base->gallivm->builder,
+			"llvm.SI.vs.load.input", emit_data->dst_type,
+			emit_data->args, emit_data->arg_count,
+			LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
+		return;
+	}
+
 	sprintf(intr_name, "%sv%ui32", action->intr_name,
 		LLVMGetVectorSize(LLVMTypeOf(emit_data->args[0])));
 
@@ -1442,6 +1472,20 @@ static void txq_fetch_args(
 {
 	struct si_shader_context *si_shader_ctx = si_shader_context(bld_base);
 	const struct tgsi_full_instruction *inst = emit_data->inst;
+	struct gallivm_state *gallivm = bld_base->base.gallivm;
+
+	if (inst->Texture.Texture == TGSI_TEXTURE_BUFFER) {
+		LLVMTypeRef i32 = LLVMInt32TypeInContext(gallivm->context);
+		LLVMTypeRef v8i32 = LLVMVectorType(i32, 8);
+
+		/* Read the size from the buffer descriptor directly. */
+		LLVMValueRef size = si_shader_ctx->resources[inst->Src[1].Register.Index];
+		size = LLVMBuildBitCast(gallivm->builder, size, v8i32, "");
+		size = LLVMBuildExtractElement(gallivm->builder, size,
+					      lp_build_const_int32(gallivm, 2), "");
+		emit_data->args[0] = size;
+		return;
+	}
 
 	/* Mip level */
 	emit_data->args[0] = lp_build_emit_fetch(bld_base, inst, 0, TGSI_CHAN_X);
@@ -1460,6 +1504,19 @@ static void txq_fetch_args(
 		4);
 }
 
+static void build_txq_intrinsic(const struct lp_build_tgsi_action * action,
+				struct lp_build_tgsi_context * bld_base,
+				struct lp_build_emit_data * emit_data)
+{
+	if (emit_data->inst->Texture.Texture == TGSI_TEXTURE_BUFFER) {
+		/* Just return the buffer size. */
+		emit_data->output[emit_data->chan] = emit_data->args[0];
+		return;
+	}
+
+	build_tgsi_intrinsic_nomem(action, bld_base, emit_data);
+}
+
 #if HAVE_LLVM >= 0x0304
 
 static void si_llvm_emit_ddxy(
@@ -1566,7 +1623,7 @@ static const struct lp_build_tgsi_action txl_action = {
 
 static const struct lp_build_tgsi_action txq_action = {
 	.fetch_args = txq_fetch_args,
-	.emit = build_tgsi_intrinsic_nomem,
+	.emit = build_txq_intrinsic,
 	.intr_name = "llvm.SI.resinfo"
 };
 
@@ -1701,29 +1758,33 @@ static void preload_constants(struct si_shader_context *si_shader_ctx)
 	struct lp_build_tgsi_context * bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
 	struct gallivm_state * gallivm = bld_base->base.gallivm;
 	const struct tgsi_shader_info * info = bld_base->info;
+	unsigned buf;
+	LLVMValueRef ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
 
-	unsigned i, num_const = info->file_max[TGSI_FILE_CONSTANT] + 1;
-
-	LLVMValueRef ptr;
+	for (buf = 0; buf < NUM_CONST_BUFFERS; buf++) {
+		unsigned i, num_const = info->const_file_max[buf] + 1;
 
-	if (num_const == 0)
-		return;
+		if (num_const == 0)
+			continue;
 
-	/* Allocate space for the constant values */
-	si_shader_ctx->constants = CALLOC(num_const * 4, sizeof(LLVMValueRef));
-
-	/* Load the resource descriptor */
-	ptr = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, SI_PARAM_CONST);
-	si_shader_ctx->const_resource = build_indexed_load(si_shader_ctx, ptr, bld_base->uint_bld.zero);
-
-	/* Load the constants, we rely on the code sinking to do the rest */
-	for (i = 0; i < num_const * 4; ++i) {
-		LLVMValueRef args[2] = {
-			si_shader_ctx->const_resource,
-			lp_build_const_int32(gallivm, i * 4)
-		};
-		si_shader_ctx->constants[i] = build_intrinsic(gallivm->builder, "llvm.SI.load.const",
-			bld_base->base.elem_type, args, 2, LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
+		/* Allocate space for the constant values */
+		si_shader_ctx->constants[buf] = CALLOC(num_const * 4, sizeof(LLVMValueRef));
+
+		/* Load the resource descriptor */
+		si_shader_ctx->const_resource[buf] =
+			build_indexed_load(si_shader_ctx, ptr, lp_build_const_int32(gallivm, buf));
+
+		/* Load the constants, we rely on the code sinking to do the rest */
+		for (i = 0; i < num_const * 4; ++i) {
+			LLVMValueRef args[2] = {
+				si_shader_ctx->const_resource[buf],
+				lp_build_const_int32(gallivm, i * 4)
+			};
+			si_shader_ctx->constants[buf][i] =
+					build_intrinsic(gallivm->builder, "llvm.SI.load.const",
+							bld_base->base.elem_type, args, 2,
+							LLVMReadNoneAttribute | LLVMNoUnwindAttribute);
+		}
 	}
 }
 
@@ -1931,7 +1992,8 @@ int si_pipe_shader_create(
 
 	if (!lp_build_tgsi_llvm(bld_base, sel->tokens)) {
 		fprintf(stderr, "Failed to translate shader from TGSI to LLVM\n");
-		FREE(si_shader_ctx.constants);
+		for (int i = 0; i < NUM_CONST_BUFFERS; i++)
+			FREE(si_shader_ctx.constants[i]);
 		FREE(si_shader_ctx.resources);
 		FREE(si_shader_ctx.samplers);
 		return -EINVAL;
@@ -1945,7 +2007,8 @@ int si_pipe_shader_create(
 	radeon_llvm_dispose(&si_shader_ctx.radeon_bld);
 	tgsi_parse_free(&si_shader_ctx.parse);
 
-	FREE(si_shader_ctx.constants);
+	for (int i = 0; i < NUM_CONST_BUFFERS; i++)
+		FREE(si_shader_ctx.constants[i]);
 	FREE(si_shader_ctx.resources);
 	FREE(si_shader_ctx.samplers);
 
diff --git a/src/gallium/drivers/radeonsi/si_descriptors.c b/src/gallium/drivers/radeonsi/si_descriptors.c
index 93d3684..c491584 100644
--- a/src/gallium/drivers/radeonsi/si_descriptors.c
+++ b/src/gallium/drivers/radeonsi/si_descriptors.c
@@ -412,6 +412,12 @@ static void si_set_constant_buffer(struct pipe_context *ctx, uint shader, uint s
 	assert(slot < buffers->num_buffers);
 	pipe_resource_reference(&buffers->buffers[slot], NULL);
 
+	/* CIK cannot unbind a constant buffer (S_BUFFER_LOAD is buggy
+	 * with a NULL buffer). We need to use a dummy buffer instead. */
+	if (rctx->b.chip_class == CIK &&
+	    (!input || (!input->buffer && !input->user_buffer)))
+		input = &rctx->null_const_buf;
+
 	if (input && (input->buffer || input->user_buffer)) {
 		struct pipe_resource *buffer = NULL;
 		uint64_t va;
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 97710f0..2742836 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -377,7 +377,7 @@ static void si_set_clip_state(struct pipe_context *ctx,
 	cb.user_buffer = state->ucp;
 	cb.buffer_offset = 0;
 	cb.buffer_size = 4*4*8;
-	ctx->set_constant_buffer(ctx, PIPE_SHADER_VERTEX, 1, &cb);
+	ctx->set_constant_buffer(ctx, PIPE_SHADER_VERTEX, NUM_PIPE_CONST_BUFFERS, &cb);
 	pipe_resource_reference(&cb.buffer, NULL);
 
 	si_pm4_set_state(rctx, clip, pm4);
@@ -525,6 +525,7 @@ static void *si_create_rs_state(struct pipe_context *ctx,
 	rs->two_side = state->light_twoside;
 	rs->multisample_enable = state->multisample;
 	rs->clip_plane_enable = state->clip_plane_enable;
+	rs->line_stipple_enable = state->line_stipple_enable;
 
 	polygon_dual_mode = (state->fill_front != PIPE_POLYGON_MODE_FILL ||
 				state->fill_back != PIPE_POLYGON_MODE_FILL);
@@ -1351,10 +1352,9 @@ static bool si_is_sampler_format_supported(struct pipe_screen *screen, enum pipe
 				      util_format_get_first_non_void_channel(format)) != ~0U;
 }
 
-static uint32_t si_translate_vertexformat(struct pipe_screen *screen,
-					  enum pipe_format format,
-					  const struct util_format_description *desc,
-					  int first_non_void)
+static uint32_t si_translate_buffer_dataformat(struct pipe_screen *screen,
+					       const struct util_format_description *desc,
+					       int first_non_void)
 {
 	unsigned type = desc->channel[first_non_void].type;
 	int i;
@@ -1362,6 +1362,13 @@ static uint32_t si_translate_vertexformat(struct pipe_screen *screen,
 	if (type == UTIL_FORMAT_TYPE_FIXED)
 		return V_008F0C_BUF_DATA_FORMAT_INVALID;
 
+	if (desc->nr_channels == 4 &&
+	    desc->channel[0].size == 10 &&
+	    desc->channel[1].size == 10 &&
+	    desc->channel[2].size == 10 &&
+	    desc->channel[3].size == 2)
+		return V_008F0C_BUF_DATA_FORMAT_2_10_10_10;
+
 	/* See whether the components are of the same size. */
 	for (i = 0; i < desc->nr_channels; i++) {
 		if (desc->channel[first_non_void].size != desc->channel[i].size)
@@ -1416,6 +1423,33 @@ static uint32_t si_translate_vertexformat(struct pipe_screen *screen,
 	return V_008F0C_BUF_DATA_FORMAT_INVALID;
 }
 
+static uint32_t si_translate_buffer_numformat(struct pipe_screen *screen,
+					      const struct util_format_description *desc,
+					      int first_non_void)
+{
+	switch (desc->channel[first_non_void].type) {
+	case UTIL_FORMAT_TYPE_SIGNED:
+		if (desc->channel[first_non_void].normalized)
+			return V_008F0C_BUF_NUM_FORMAT_SNORM;
+		else if (desc->channel[first_non_void].pure_integer)
+			return V_008F0C_BUF_NUM_FORMAT_SINT;
+		else
+			return V_008F0C_BUF_NUM_FORMAT_SSCALED;
+		break;
+	case UTIL_FORMAT_TYPE_UNSIGNED:
+		if (desc->channel[first_non_void].normalized)
+			return V_008F0C_BUF_NUM_FORMAT_UNORM;
+		else if (desc->channel[first_non_void].pure_integer)
+			return V_008F0C_BUF_NUM_FORMAT_UINT;
+		else
+			return V_008F0C_BUF_NUM_FORMAT_USCALED;
+		break;
+	case UTIL_FORMAT_TYPE_FLOAT:
+	default:
+		return V_008F0C_BUF_NUM_FORMAT_FLOAT;
+	}
+}
+
 static bool si_is_vertex_format_supported(struct pipe_screen *screen, enum pipe_format format)
 {
 	const struct util_format_description *desc;
@@ -1424,7 +1458,7 @@ static bool si_is_vertex_format_supported(struct pipe_screen *screen, enum pipe_
 
 	desc = util_format_description(format);
 	first_non_void = util_format_get_first_non_void_channel(format);
-	data_format = si_translate_vertexformat(screen, format, desc, first_non_void);
+	data_format = si_translate_buffer_dataformat(screen, desc, first_non_void);
 	return data_format != V_008F0C_BUF_DATA_FORMAT_INVALID;
 }
 
@@ -1470,9 +1504,14 @@ boolean si_is_format_supported(struct pipe_screen *screen,
 		}
 	}
 
-	if ((usage & PIPE_BIND_SAMPLER_VIEW) &&
-	    si_is_sampler_format_supported(screen, format)) {
-		retval |= PIPE_BIND_SAMPLER_VIEW;
+	if (usage & PIPE_BIND_SAMPLER_VIEW) {
+		if (target == PIPE_BUFFER) {
+			if (si_is_vertex_format_supported(screen, format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		} else {
+			if (si_is_sampler_format_supported(screen, format))
+				retval |= PIPE_BIND_SAMPLER_VIEW;
+		}
 	}
 
 	if ((usage & (PIPE_BIND_RENDER_TARGET |
@@ -2334,10 +2373,34 @@ static struct pipe_sampler_view *si_create_sampler_view(struct pipe_context *ctx
 	/* initialize base object */
 	view->base = *state;
 	view->base.texture = NULL;
-	pipe_reference(NULL, &texture->reference);
-	view->base.texture = texture;
+	pipe_resource_reference(&view->base.texture, texture);
 	view->base.reference.count = 1;
 	view->base.context = ctx;
+	view->resource = &tmp->resource;
+
+	/* Buffer resource. */
+	if (texture->target == PIPE_BUFFER) {
+		unsigned stride;
+
+		desc = util_format_description(state->format);
+		first_non_void = util_format_get_first_non_void_channel(state->format);
+		stride = desc->block.bits / 8;
+		va = r600_resource_va(ctx->screen, texture) + state->u.buf.first_element*stride;
+		format = si_translate_buffer_dataformat(ctx->screen, desc, first_non_void);
+		num_format = si_translate_buffer_numformat(ctx->screen, desc, first_non_void);
+
+		view->state[0] = va;
+		view->state[1] = S_008F04_BASE_ADDRESS_HI(va >> 32) |
+				 S_008F04_STRIDE(stride);
+		view->state[2] = state->u.buf.last_element + 1 - state->u.buf.first_element;
+		view->state[3] = S_008F0C_DST_SEL_X(si_map_swizzle(desc->swizzle[0])) |
+				 S_008F0C_DST_SEL_Y(si_map_swizzle(desc->swizzle[1])) |
+				 S_008F0C_DST_SEL_Z(si_map_swizzle(desc->swizzle[2])) |
+				 S_008F0C_DST_SEL_W(si_map_swizzle(desc->swizzle[3])) |
+				 S_008F0C_NUM_FORMAT(num_format) |
+				 S_008F0C_DATA_FORMAT(format);
+		return &view->base;
+	}
 
 	state_swizzle[0] = state->swizzle_r;
 	state_swizzle[1] = state->swizzle_g;
@@ -2449,8 +2512,6 @@ static struct pipe_sampler_view *si_create_sampler_view(struct pipe_context *ctx
 		format = 0;
 	}
 
-	view->resource = &tmp->resource;
-
 	/* not supported any more */
 	//endian = si_colorformat_endian_swap(format);
 
@@ -2624,7 +2685,18 @@ static void si_set_sampler_views(struct pipe_context *ctx,
 	assert(start == 0);
 
 	for (i = 0; i < count; i++) {
-		if (views[i]) {
+		if (!views[i]) {
+			samplers->depth_texture_mask &= ~(1 << i);
+			samplers->compressed_colortex_mask &= ~(1 << i);
+			si_set_sampler_view(rctx, shader, i, NULL, NULL);
+			si_set_sampler_view(rctx, shader, FMASK_TEX_OFFSET + i,
+					    NULL, NULL);
+			continue;
+		}
+
+		si_set_sampler_view(rctx, shader, i, views[i], rviews[i]->state);
+
+		if (views[i]->texture->target != PIPE_BUFFER) {
 			struct r600_texture *rtex =
 				(struct r600_texture*)views[i]->texture;
 
@@ -2639,8 +2711,6 @@ static void si_set_sampler_views(struct pipe_context *ctx,
 				samplers->compressed_colortex_mask &= ~(1 << i);
 			}
 
-			si_set_sampler_view(rctx, shader, i, views[i], rviews[i]->state);
-
 			if (rtex->fmask.size) {
 				si_set_sampler_view(rctx, shader, FMASK_TEX_OFFSET + i,
 						    views[i], rviews[i]->fmask_state);
@@ -2648,12 +2718,6 @@ static void si_set_sampler_views(struct pipe_context *ctx,
 				si_set_sampler_view(rctx, shader, FMASK_TEX_OFFSET + i,
 						    NULL, NULL);
 			}
-		} else {
-			samplers->depth_texture_mask &= ~(1 << i);
-			samplers->compressed_colortex_mask &= ~(1 << i);
-			si_set_sampler_view(rctx, shader, i, NULL, NULL);
-			si_set_sampler_view(rctx, shader, FMASK_TEX_OFFSET + i,
-					    NULL, NULL);
 		}
 	}
 	for (; i < samplers->n_views; i++) {
@@ -2826,33 +2890,8 @@ static void *si_create_vertex_elements(struct pipe_context *ctx,
 
 		desc = util_format_description(elements[i].src_format);
 		first_non_void = util_format_get_first_non_void_channel(elements[i].src_format);
-		data_format = si_translate_vertexformat(ctx->screen, elements[i].src_format,
-							desc, first_non_void);
-
-		switch (desc->channel[first_non_void].type) {
-		case UTIL_FORMAT_TYPE_FIXED:
-			num_format = V_008F0C_BUF_NUM_FORMAT_USCALED; /* XXX */
-			break;
-		case UTIL_FORMAT_TYPE_SIGNED:
-			if (desc->channel[first_non_void].normalized)
-				num_format = V_008F0C_BUF_NUM_FORMAT_SNORM;
-			else if (desc->channel[first_non_void].pure_integer)
-				num_format = V_008F0C_BUF_NUM_FORMAT_SINT;
-			else
-				num_format = V_008F0C_BUF_NUM_FORMAT_SSCALED;
-			break;
-		case UTIL_FORMAT_TYPE_UNSIGNED:
-			if (desc->channel[first_non_void].normalized)
-				num_format = V_008F0C_BUF_NUM_FORMAT_UNORM;
-			else if (desc->channel[first_non_void].pure_integer)
-				num_format = V_008F0C_BUF_NUM_FORMAT_UINT;
-			else
-				num_format = V_008F0C_BUF_NUM_FORMAT_USCALED;
-			break;
-		case UTIL_FORMAT_TYPE_FLOAT:
-		default:
-			num_format = V_008F14_IMG_NUM_FORMAT_FLOAT;
-		}
+		data_format = si_translate_buffer_dataformat(ctx->screen, desc, first_non_void);
+		num_format = si_translate_buffer_numformat(ctx->screen, desc, first_non_void);
 
 		v->rsrc_word3[i] = S_008F0C_DST_SEL_X(si_map_swizzle(desc->swizzle[0])) |
 				   S_008F0C_DST_SEL_Y(si_map_swizzle(desc->swizzle[1])) |
@@ -3097,6 +3136,10 @@ void si_init_config(struct r600_context *rctx)
 			si_pm4_set_reg(pm4, R_028350_PA_SC_RASTER_CONFIG, 0x16000012);
 			si_pm4_set_reg(pm4, R_028354_PA_SC_RASTER_CONFIG_1, 0x00000000);
 			break;
+		case CHIP_HAWAII:
+			si_pm4_set_reg(pm4, R_028350_PA_SC_RASTER_CONFIG, 0x3a00161a);
+			si_pm4_set_reg(pm4, R_028354_PA_SC_RASTER_CONFIG_1, 0x0000002e);
+			break;
 		case CHIP_KAVERI:
 			/* XXX todo */
 		case CHIP_KABINI:
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index 6dbf880..f3d4023 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -46,6 +46,7 @@ struct si_state_rasterizer {
 	bool			flatshade;
 	bool			two_side;
 	bool			multisample_enable;
+	bool			line_stipple_enable;
 	unsigned		sprite_coord_enable;
 	unsigned		pa_sc_line_stipple;
 	unsigned		pa_su_sc_mode_cntl;
@@ -109,7 +110,8 @@ union si_state {
 #define NUM_SAMPLER_VIEWS	(FMASK_TEX_OFFSET+NUM_TEX_UNITS)
 #define NUM_SAMPLER_STATES	NUM_TEX_UNITS
 
-#define NUM_CONST_BUFFERS 2
+#define NUM_PIPE_CONST_BUFFERS 16
+#define NUM_CONST_BUFFERS 17
 
 /* This represents resource descriptors in memory, such as buffer resources,
  * image resources, and sampler states.
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.c b/src/gallium/drivers/radeonsi/si_state_draw.c
index d20658e..1467bb6 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.c
+++ b/src/gallium/drivers/radeonsi/si_state_draw.c
@@ -320,14 +320,18 @@ static bool si_update_draw_info_state(struct r600_context *rctx,
 	}
 
 	if (rctx->b.chip_class >= CIK) {
+		struct si_state_rasterizer *rs = rctx->queued.named.rasterizer;
 		bool wd_switch_on_eop = prim == V_008958_DI_PT_POLYGON ||
 					prim == V_008958_DI_PT_LINELOOP ||
 					prim == V_008958_DI_PT_TRIFAN ||
 					prim == V_008958_DI_PT_TRISTRIP_ADJ ||
-					info->primitive_restart;
+					info->primitive_restart ||
+					(rs ? rs->line_stipple_enable : false);
+		/* If the WD switch is false, the IA switch must be false too. */
+		bool ia_switch_on_eop = wd_switch_on_eop;
 
 		si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM,
-			       S_028AA8_SWITCH_ON_EOP(1) |
+			       S_028AA8_SWITCH_ON_EOP(ia_switch_on_eop) |
 			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
 			       S_028AA8_PRIMGROUP_SIZE(63) |
 			       S_028AA8_WD_SWITCH_ON_EOP(wd_switch_on_eop));
diff --git a/src/gallium/drivers/radeonsi/sid.h b/src/gallium/drivers/radeonsi/sid.h
index 021f4eb..aab39fc 100644
--- a/src/gallium/drivers/radeonsi/sid.h
+++ b/src/gallium/drivers/radeonsi/sid.h
@@ -5403,6 +5403,8 @@
 #define     V_02803C_X_ADDR_SURF_P8_32X32_16X16                     0x0C
 #define     V_02803C_X_ADDR_SURF_P8_32X32_16X32                     0x0D
 #define     V_02803C_X_ADDR_SURF_P8_32X64_32X32                     0x0E
+#define     V_02803C_X_ADDR_SURF_P16_32X32_8X16                     0x10
+#define     V_02803C_X_ADDR_SURF_P16_32X32_16X16                    0x11
 #define   S_02803C_BANK_WIDTH(x)                                      (((x) & 0x03) << 13)
 #define   G_02803C_BANK_WIDTH(x)                                      (((x) >> 13) & 0x03)
 #define   C_02803C_BANK_WIDTH                                         0xFFFF9FFF
@@ -5731,6 +5733,13 @@
 #define     V_028350_RASTER_CONFIG_PKR_YSEL_1                       0x01
 #define     V_028350_RASTER_CONFIG_PKR_YSEL_2                       0x02
 #define     V_028350_RASTER_CONFIG_PKR_YSEL_3                       0x03
+#define   S_028350_PKR_XSEL2(x)                                       (((x) & 0x03) << 14)
+#define   G_028350_PKR_XSEL2(x)                                       (((x) >> 14) & 0x03)
+#define   C_028350_PKR_XSEL2                                          0xFFFF3FFF
+#define     V_028350_RASTER_CONFIG_PKR_XSEL2_0                      0x00
+#define     V_028350_RASTER_CONFIG_PKR_XSEL2_1                      0x01
+#define     V_028350_RASTER_CONFIG_PKR_XSEL2_2                      0x02
+#define     V_028350_RASTER_CONFIG_PKR_XSEL2_3                      0x03
 #define   S_028350_SC_MAP(x)                                          (((x) & 0x03) << 16)
 #define   G_028350_SC_MAP(x)                                          (((x) >> 16) & 0x03)
 #define   C_028350_SC_MAP                                             0xFFFCFFFF
diff --git a/src/gallium/drivers/rbug/Makefile.am b/src/gallium/drivers/rbug/Makefile.am
index 1aa6521..5de7213 100644
--- a/src/gallium/drivers/rbug/Makefile.am
+++ b/src/gallium/drivers/rbug/Makefile.am
@@ -23,16 +23,9 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-noinst_LTLIBRARIES = librbug.la
-
-# GALLIUM_CFLAGS must appear before src/gallium/drivers
-# because there are stupidly two rbug_context.h files in
-# different directories, and which one is included by the
-# preprocessor is determined by the ordering of the -I flags.
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS) \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include
+	$(GALLIUM_DRIVER_CFLAGS)
+
+noinst_LTLIBRARIES = librbug.la
 
 librbug_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/drivers/softpipe/Makefile.am b/src/gallium/drivers/softpipe/Makefile.am
index 1048d85..f37c4a6 100644
--- a/src/gallium/drivers/softpipe/Makefile.am
+++ b/src/gallium/drivers/softpipe/Makefile.am
@@ -23,11 +23,8 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_DRIVER_CFLAGS)
 
 noinst_LTLIBRARIES = libsoftpipe.la
 
diff --git a/src/gallium/drivers/softpipe/sp_setup.c b/src/gallium/drivers/softpipe/sp_setup.c
index 03a2b46..70a4b5a 100644
--- a/src/gallium/drivers/softpipe/sp_setup.c
+++ b/src/gallium/drivers/softpipe/sp_setup.c
@@ -511,14 +511,6 @@ tri_linear_coeff(struct setup_context *setup,
    coef->a0[i] = (v[0] -
                   (dadx * (setup->vmin[0][0] - setup->pixel_offset) +
                    dady * (setup->vmin[0][1] - setup->pixel_offset)));
-
-   /*
-   debug_printf("attr[%d].%c: %f dx:%f dy:%f\n",
-		slot, "xyzw"[i],
-		setup->coef[slot].a0[i],
-		setup->coef[slot].dadx[i],
-		setup->coef[slot].dady[i]);
-   */
 }
 
 
@@ -549,13 +541,6 @@ tri_persp_coeff(struct setup_context *setup,
    float dadx = a * setup->oneoverarea;
    float dady = b * setup->oneoverarea;
 
-   /*
-   debug_printf("tri persp %d,%d: %f %f %f\n", vertSlot, i,
-          	setup->vmin[vertSlot][i],
-          	setup->vmid[vertSlot][i],
-       		setup->vmax[vertSlot][i]
-          );
-   */
    assert(i <= 3);
 
    coef->dadx[i] = dadx;
@@ -668,6 +653,16 @@ setup_tri_coefficients(struct setup_context *setup)
          setup->coef[fragSlot].dadx[0] = 0.0;
          setup->coef[fragSlot].dady[0] = 0.0;
       }
+
+      if (0) {
+         for (j = 0; j < TGSI_NUM_CHANNELS; j++) {
+            debug_printf("attr[%d].%c: a0:%f dx:%f dy:%f\n",
+                         fragSlot, "xyzw"[j],
+                         setup->coef[fragSlot].a0[j],
+                         setup->coef[fragSlot].dadx[j],
+                         setup->coef[fragSlot].dady[j]);
+         }
+      }
    }
 }
 
diff --git a/src/gallium/drivers/softpipe/sp_state_surface.c b/src/gallium/drivers/softpipe/sp_state_surface.c
index c0bd1f7..922f568 100644
--- a/src/gallium/drivers/softpipe/sp_state_surface.c
+++ b/src/gallium/drivers/softpipe/sp_state_surface.c
@@ -82,21 +82,14 @@ softpipe_set_framebuffer_state(struct pipe_context *pipe,
       /* update cache */
       sp_tile_cache_set_surface(sp->zsbuf_cache, fb->zsbuf);
 
-      /* Tell draw module how deep the Z/depth buffer is */
-      if (sp->framebuffer.zsbuf) {
-         int depth_bits;
-         double mrd;
-         depth_bits = util_format_get_component_bits(sp->framebuffer.zsbuf->format,
-                                                     UTIL_FORMAT_COLORSPACE_ZS,
-                                                     0);
-         if (depth_bits > 16) {
-            mrd = 0.0000001;
-         }
-         else {
-            mrd = 0.00002;
-         }
-         draw_set_mrd(sp->draw, mrd);
-      }
+      /* Tell draw module how deep the Z/depth buffer is
+       *
+       * If no depth buffer is bound, send the utility function the
+       * format for no bound depth (PIPE_FORMAT_NONE).
+       */
+      draw_set_zs_format(sp->draw,
+                         (sp->framebuffer.zsbuf) ?
+                            sp->framebuffer.zsbuf->format : PIPE_FORMAT_NONE);
    }
 
    sp->framebuffer.width = fb->width;
diff --git a/src/gallium/drivers/svga/Makefile.am b/src/gallium/drivers/svga/Makefile.am
index 7eacd90..54ae814 100644
--- a/src/gallium/drivers/svga/Makefile.am
+++ b/src/gallium/drivers/svga/Makefile.am
@@ -20,16 +20,13 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+AUTOMAKE_OPTIONS = subdir-objects
+
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers/svga/include \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS)
-
-AM_CFLAGS = $(VISIBILITY_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_DRIVER_CFLAGS)
 
 #On some systems -std= must be added to CFLAGS to be the last -std=
 CFLAGS += -std=gnu99
diff --git a/src/gallium/drivers/svga/svga_context.c b/src/gallium/drivers/svga/svga_context.c
index 83afe79..21fe73a 100644
--- a/src/gallium/drivers/svga/svga_context.c
+++ b/src/gallium/drivers/svga/svga_context.c
@@ -246,6 +246,7 @@ void svga_hwtnl_flush_buffer( struct svga_context *svga,
  */ 
 void svga_surfaces_flush(struct svga_context *svga)
 {
+   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
    unsigned i;
 
    /* Emit buffered drawing commands.
@@ -254,7 +255,7 @@ void svga_surfaces_flush(struct svga_context *svga)
 
    /* Emit back-copy from render target view to texture.
     */
-   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
+   for (i = 0; i < svgascreen->max_color_buffers; i++) {
       if (svga->curr.framebuffer.cbufs[i])
          svga_propagate_surface(svga, svga->curr.framebuffer.cbufs[i]);
    }
diff --git a/src/gallium/drivers/svga/svga_draw_elements.c b/src/gallium/drivers/svga/svga_draw_elements.c
index fb5f1c9..411b8d9 100644
--- a/src/gallium/drivers/svga/svga_draw_elements.c
+++ b/src/gallium/drivers/svga/svga_draw_elements.c
@@ -24,6 +24,7 @@
  **********************************************************/
 
 #include "util/u_inlines.h"
+#include "util/u_prim.h"
 #include "indices/u_indices.h"
 
 #include "svga_cmd.h"
@@ -37,17 +38,25 @@
 
 static enum pipe_error
 translate_indices(struct svga_hwtnl *hwtnl, struct pipe_resource *src,
-                  unsigned offset, unsigned nr, unsigned index_size,
+                  unsigned offset, unsigned prim, unsigned nr,
+                  unsigned index_size,
                   u_translate_func translate, struct pipe_resource **out_buf)
 {
    struct pipe_context *pipe = &hwtnl->svga->pipe;
    struct pipe_transfer *src_transfer = NULL;
    struct pipe_transfer *dst_transfer = NULL;
-   unsigned size = index_size * nr;
+   unsigned size;
    const void *src_map = NULL;
    struct pipe_resource *dst = NULL;
    void *dst_map = NULL;
 
+   /* Need to trim vertex count to make sure we don't write too much data
+    * to the dst buffer in the translate() call.
+    */
+   u_trim_pipe_prim(prim, &nr);
+
+   size = index_size * nr;
+
    dst = pipe_buffer_create(pipe->screen,
                             PIPE_BIND_INDEX_BUFFER, PIPE_USAGE_STATIC, size);
    if (dst == NULL)
@@ -91,16 +100,14 @@ svga_hwtnl_simple_draw_range_elements(struct svga_hwtnl *hwtnl,
                                       unsigned prim, unsigned start,
                                       unsigned count)
 {
-   struct pipe_resource *upload_buffer = NULL;
    SVGA3dPrimitiveRange range;
    unsigned hw_prim;
    unsigned hw_count;
    unsigned index_offset = start * index_size;
-   enum pipe_error ret = PIPE_OK;
 
    hw_prim = svga_translate_prim(prim, count, &hw_count);
    if (hw_count == 0)
-      goto done;
+      return PIPE_OK; /* nothing to draw */
 
    /* We should never see user-space buffers in the driver.  The vbuf
     * module should have converted them into real buffers.
@@ -115,15 +122,7 @@ svga_hwtnl_simple_draw_range_elements(struct svga_hwtnl *hwtnl,
    range.indexWidth = index_size;
    range.indexBias = index_bias;
 
-   ret = svga_hwtnl_prim(hwtnl, &range, min_index, max_index, index_buffer);
-   if (ret != PIPE_OK)
-      goto done;
-
-done:
-   if (upload_buffer)
-      pipe_resource_reference(&upload_buffer, NULL);
-
-   return ret;
+   return svga_hwtnl_prim(hwtnl, &range, min_index, max_index, index_buffer);
 }
 
 
@@ -180,7 +179,7 @@ svga_hwtnl_draw_range_elements(struct svga_hwtnl *hwtnl,
       ret = translate_indices(hwtnl,
                               index_buffer,
                               start * index_size,
-                              gen_nr, gen_size, gen_func, &gen_buf);
+                              gen_prim, gen_nr, gen_size, gen_func, &gen_buf);
       if (ret != PIPE_OK)
          goto done;
 
diff --git a/src/gallium/drivers/svga/svga_pipe_blit.c b/src/gallium/drivers/svga/svga_pipe_blit.c
index ff1017c..dbb9f4b 100644
--- a/src/gallium/drivers/svga/svga_pipe_blit.c
+++ b/src/gallium/drivers/svga/svga_pipe_blit.c
@@ -148,6 +148,8 @@ static void svga_surface_copy(struct pipe_context *pipe,
 
 #endif
 
+   /* Mark the destination image as being defined */
+   svga_define_texture_level(dtex, dst_face, dst_level);
 }
 
 
diff --git a/src/gallium/drivers/svga/svga_pipe_misc.c b/src/gallium/drivers/svga/svga_pipe_misc.c
index f1c007b..2c88e2a 100644
--- a/src/gallium/drivers/svga/svga_pipe_misc.c
+++ b/src/gallium/drivers/svga/svga_pipe_misc.c
@@ -28,6 +28,7 @@
 #include "util/u_inlines.h"
 
 #include "svga_context.h"
+#include "svga_screen.h"
 #include "svga_surface.h"
 
 
@@ -52,11 +53,12 @@ static void svga_set_polygon_stipple( struct pipe_context *pipe,
 
 void svga_cleanup_framebuffer(struct svga_context *svga)
 {
+   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
    struct pipe_framebuffer_state *curr = &svga->curr.framebuffer;
    struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
-   int i;
+   unsigned i;
 
-   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
+   for (i = 0; i < svgascreen->max_color_buffers; i++) {
       pipe_surface_reference(&curr->cbufs[i], NULL);
       pipe_surface_reference(&hw->cbufs[i], NULL);
    }
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index 49e3b49..3c013ea 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -154,11 +154,7 @@ svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_TGSI_TEXCOORD:
       return 0;
    case PIPE_CAP_MAX_RENDER_TARGETS:
-      if(!sws->get_cap(sws, SVGA3D_DEVCAP_MAX_RENDER_TARGETS, &result))
-         return 1;
-      if(!result.u)
-         return 1;
-      return MIN2(result.u, PIPE_MAX_COLOR_BUFS);
+      return svgascreen->max_color_buffers;
    case PIPE_CAP_OCCLUSION_QUERY:
       return 1;
    case PIPE_CAP_QUERY_TIME_ELAPSED:
@@ -232,10 +228,12 @@ svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
       return 0;
 
+   case PIPE_CAP_SM3:
+      return 1;
+
    /* Unsupported features */
    case PIPE_CAP_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION:
    case PIPE_CAP_TEXTURE_MIRROR_CLAMP:
-   case PIPE_CAP_SM3:
    case PIPE_CAP_SHADER_STENCIL_EXPORT:
    case PIPE_CAP_DEPTH_CLIP_DISABLE:
    case PIPE_CAP_SEAMLESS_CUBE_MAP:
@@ -660,6 +658,11 @@ svga_screen_create(struct svga_winsys_screen *sws)
       svgascreen->maxPointSize = MIN2(result.f, 80.0f);
    }
 
+   /* The SVGA3D device always supports 4 targets at this time, regardless
+    * of what querying SVGA3D_DEVCAP_MAX_RENDER_TARGETS might return.
+    */
+   svgascreen->max_color_buffers = 4;
+
    pipe_mutex_init(svgascreen->tex_mutex);
    pipe_mutex_init(svgascreen->swc_mutex);
 
diff --git a/src/gallium/drivers/svga/svga_screen.h b/src/gallium/drivers/svga/svga_screen.h
index 0606147..517a3fa 100644
--- a/src/gallium/drivers/svga/svga_screen.h
+++ b/src/gallium/drivers/svga/svga_screen.h
@@ -48,6 +48,7 @@ struct svga_screen
    SVGA3dHardwareVersion hw_version;
 
    float maxPointSize;
+   unsigned max_color_buffers;
 
    struct {
       boolean force_level_surface_view;
diff --git a/src/gallium/drivers/svga/svga_state_framebuffer.c b/src/gallium/drivers/svga/svga_state_framebuffer.c
index 8232c32..6976d37 100644
--- a/src/gallium/drivers/svga/svga_state_framebuffer.c
+++ b/src/gallium/drivers/svga/svga_state_framebuffer.c
@@ -31,6 +31,19 @@
 #include "svga_state.h"
 #include "svga_cmd.h"
 #include "svga_debug.h"
+#include "svga_screen.h"
+
+
+/*
+ * flush our command buffer after the 8th distinct render target
+ *
+ * This helps improve the surface cache behaviour in the face of the
+ * large number of single-use render targets generated by EXA and the xorg
+ * state tracker.  Without this we can reference hundreds of individual
+ * render targets from a command buffer, which leaves little scope for
+ * sharing or reuse of those targets.
+ */
+#define MAX_RT_PER_BATCH 8
 
 
 /***********************************************************************
@@ -42,6 +55,7 @@ static enum pipe_error
 emit_framebuffer( struct svga_context *svga,
                   unsigned dirty )
 {
+   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
    const struct pipe_framebuffer_state *curr = &svga->curr.framebuffer;
    struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
    boolean reemit = svga->rebind.rendertargets;
@@ -53,10 +67,10 @@ emit_framebuffer( struct svga_context *svga,
     * dirty, to ensure that the resources are paged in.
     */
    
-   for(i = 0; i < PIPE_MAX_COLOR_BUFS; ++i) {
+   for (i = 0; i < svgascreen->max_color_buffers; i++) {
       if (curr->cbufs[i] != hw->cbufs[i] ||
           (reemit && hw->cbufs[i])) {
-         if (svga->curr.nr_fbs++ > 8)
+         if (svga->curr.nr_fbs++ > MAX_RT_PER_BATCH)
             return PIPE_ERROR_OUT_OF_MEMORY;
 
          ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i, curr->cbufs[i]);
@@ -106,13 +120,14 @@ emit_framebuffer( struct svga_context *svga,
 enum pipe_error
 svga_reemit_framebuffer_bindings(struct svga_context *svga)
 {
+   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
    struct pipe_framebuffer_state *hw = &svga->state.hw_clear.framebuffer;
    unsigned i;
    enum pipe_error ret;
 
    assert(svga->rebind.rendertargets);
 
-   for (i = 0; i < MIN2(PIPE_MAX_COLOR_BUFS, 8); ++i) {
+   for (i = 0; i < svgascreen->max_color_buffers; i++) {
       if (hw->cbufs[i]) {
          ret = SVGA3D_SetRenderTarget(svga->swc, SVGA3D_RT_COLOR0 + i, hw->cbufs[i]);
          if (ret != PIPE_OK) {
diff --git a/src/gallium/drivers/svga/svga_surface.c b/src/gallium/drivers/svga/svga_surface.c
index 3cbe4cb..5fafadf 100644
--- a/src/gallium/drivers/svga/svga_surface.c
+++ b/src/gallium/drivers/svga/svga_surface.c
@@ -323,9 +323,10 @@ svga_mark_surface_dirty(struct pipe_surface *surf)
 void
 svga_mark_surfaces_dirty(struct svga_context *svga)
 {
+   struct svga_screen *svgascreen = svga_screen(svga->pipe.screen);
    unsigned i;
 
-   for (i = 0; i < PIPE_MAX_COLOR_BUFS; i++) {
+   for (i = 0; i < svgascreen->max_color_buffers; i++) {
       if (svga->curr.framebuffer.cbufs[i])
          svga_mark_surface_dirty(svga->curr.framebuffer.cbufs[i]);
    }
diff --git a/src/gallium/drivers/svga/svga_swtnl_state.c b/src/gallium/drivers/svga/svga_swtnl_state.c
index d66f1a1..e62698e 100644
--- a/src/gallium/drivers/svga/svga_swtnl_state.c
+++ b/src/gallium/drivers/svga/svga_swtnl_state.c
@@ -121,9 +121,15 @@ update_swtnl_draw( struct svga_context *svga,
                                 &svga->curr.rast->templ,
                                 (void *) svga->curr.rast);
 
+   /* Tell the draw module how deep the Z/depth buffer is.
+    *
+    * If no depth buffer is bound, send the utility function the
+    * format for no bound depth (PIPE_FORMAT_NONE).
+    */
    if (dirty & SVGA_NEW_FRAME_BUFFER)
-      draw_set_mrd(svga->swtnl.draw, 
-                   svga->curr.depthscale);
+      draw_set_zs_format(svga->swtnl.draw, 
+         (svga->curr.framebuffer.zsbuf) ?
+             svga->curr.framebuffer.zsbuf->format : PIPE_FORMAT_NONE);
 
    return PIPE_OK;
 }
diff --git a/src/gallium/drivers/svga/svga_tgsi_insn.c b/src/gallium/drivers/svga/svga_tgsi_insn.c
index b96efbc..0fc385a 100644
--- a/src/gallium/drivers/svga/svga_tgsi_insn.c
+++ b/src/gallium/drivers/svga/svga_tgsi_insn.c
@@ -107,6 +107,10 @@ translate_dst_register( struct svga_shader_emitter *emit,
       break;
    }
 
+   if (reg->Register.Indirect) {
+      debug_warning("Indirect indexing of dest registers is not supported!\n");
+   }
+
    dest.mask = reg->Register.WriteMask;
    assert(dest.mask);
 
diff --git a/src/gallium/drivers/trace/Makefile.am b/src/gallium/drivers/trace/Makefile.am
index db5904d..e19f5be 100644
--- a/src/gallium/drivers/trace/Makefile.am
+++ b/src/gallium/drivers/trace/Makefile.am
@@ -2,8 +2,7 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRIVER_CFLAGS)
 
 noinst_LTLIBRARIES = libtrace.la
 
diff --git a/src/gallium/drivers/trace/tr_dump_state.c b/src/gallium/drivers/trace/tr_dump_state.c
index 22f1d27..374e32f 100644
--- a/src/gallium/drivers/trace/tr_dump_state.c
+++ b/src/gallium/drivers/trace/tr_dump_state.c
@@ -619,6 +619,7 @@ void trace_dump_vertex_buffer(const struct pipe_vertex_buffer *state)
    trace_dump_member(uint, state, stride);
    trace_dump_member(uint, state, buffer_offset);
    trace_dump_member(resource_ptr, state, buffer);
+   trace_dump_member(ptr, state, user_buffer);
 
    trace_dump_struct_end();
 }
@@ -639,6 +640,7 @@ void trace_dump_index_buffer(const struct pipe_index_buffer *state)
    trace_dump_member(uint, state, index_size);
    trace_dump_member(uint, state, offset);
    trace_dump_member(resource_ptr, state, buffer);
+   trace_dump_member(ptr, state, user_buffer);
 
    trace_dump_struct_end();
 }
diff --git a/src/gallium/include/pipe/p_config.h b/src/gallium/include/pipe/p_config.h
index 9bccf32..64acd02 100644
--- a/src/gallium/include/pipe/p_config.h
+++ b/src/gallium/include/pipe/p_config.h
@@ -190,7 +190,7 @@
 #define PIPE_OS_ANDROID
 #endif
 
-#if defined(__FreeBSD__)
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 #define PIPE_OS_FREEBSD
 #define PIPE_OS_BSD
 #define PIPE_OS_UNIX
diff --git a/src/gallium/state_trackers/Makefile.am b/src/gallium/state_trackers/Makefile.am
index fabe271..03666c4 100644
--- a/src/gallium/state_trackers/Makefile.am
+++ b/src/gallium/state_trackers/Makefile.am
@@ -41,10 +41,6 @@ if HAVE_GALLIUM_GBM
 SUBDIRS += gbm
 endif
 
-if HAVE_ST_XORG
-SUBDIRS += xorg
-endif
-
 if HAVE_ST_XA
 SUBDIRS += xa
 endif
diff --git a/src/gallium/state_trackers/clover/Makefile.sources b/src/gallium/state_trackers/clover/Makefile.sources
index e551677..42b3345 100644
--- a/src/gallium/state_trackers/clover/Makefile.sources
+++ b/src/gallium/state_trackers/clover/Makefile.sources
@@ -4,6 +4,7 @@ CPP_SOURCES := \
 	util/algorithm.hpp \
 	util/compat.cpp \
 	util/compat.hpp \
+	util/factor.hpp \
 	util/functional.hpp \
 	util/lazy.hpp \
 	util/pointer.hpp \
@@ -12,7 +13,6 @@ CPP_SOURCES := \
 	core/object.hpp \
 	core/error.hpp \
 	core/compiler.hpp \
-	core/geometry.hpp \
 	core/device.hpp \
 	core/device.cpp \
 	core/context.hpp \
diff --git a/src/gallium/state_trackers/clover/api/context.cpp b/src/gallium/state_trackers/clover/api/context.cpp
index 7b020a6..a78c00b 100644
--- a/src/gallium/state_trackers/clover/api/context.cpp
+++ b/src/gallium/state_trackers/clover/api/context.cpp
@@ -61,18 +61,24 @@ clCreateContextFromType(const cl_context_properties *d_props,
                         void *user_data, cl_int *r_errcode) try {
    cl_platform_id d_platform;
    cl_uint num_platforms;
-   cl_device_id d_dev;
    cl_int ret;
+   std::vector<cl_device_id> devs;
+   cl_uint num_devices;
 
    ret = clGetPlatformIDs(1, &d_platform, &num_platforms);
    if (ret || !num_platforms)
       throw error(CL_INVALID_PLATFORM);
 
-   ret = clGetDeviceIDs(d_platform, type, 1, &d_dev, 0);
+   ret = clGetDeviceIDs(d_platform, type, 0, NULL, &num_devices);
+   if (ret)
+      throw error(CL_DEVICE_NOT_FOUND);
+   devs.resize(num_devices);
+   ret = clGetDeviceIDs(d_platform, type, num_devices, devs.data(), 0);
    if (ret)
       throw error(CL_DEVICE_NOT_FOUND);
 
-   return clCreateContext(d_props, 1, &d_dev, pfn_notify, user_data, r_errcode);
+   return clCreateContext(d_props, num_devices, devs.data(), pfn_notify,
+                          user_data, r_errcode);
 
 } catch (error &e) {
    ret_error(r_errcode, e);
diff --git a/src/gallium/state_trackers/clover/api/kernel.cpp b/src/gallium/state_trackers/clover/api/kernel.cpp
index 7fd23d2..3367363 100644
--- a/src/gallium/state_trackers/clover/api/kernel.cpp
+++ b/src/gallium/state_trackers/clover/api/kernel.cpp
@@ -159,7 +159,7 @@ clGetKernelWorkGroupInfo(cl_kernel d_kern, cl_device_id d_dev,
       break;
 
    case CL_KERNEL_COMPILE_WORK_GROUP_SIZE:
-      buf.as_vector<size_t>() = kern.block_size();
+      buf.as_vector<size_t>() = kern.required_block_size();
       break;
 
    case CL_KERNEL_LOCAL_MEM_SIZE:
@@ -192,7 +192,7 @@ namespace {
    /// Common argument checking shared by kernel invocation commands.
    ///
    void
-   validate_common(command_queue &q, kernel &kern,
+   validate_common(const command_queue &q, kernel &kern,
                    const ref_vector<event> &deps) {
       if (kern.prog.ctx != q.ctx ||
           any_of([&](const event &ev) {
@@ -209,9 +209,9 @@ namespace {
          throw error(CL_INVALID_PROGRAM_EXECUTABLE);
    }
 
-   void
-   validate_grid(command_queue &q, cl_uint dims,
-                 const size_t *d_grid_size, const size_t *d_block_size) {
+   std::vector<size_t>
+   validate_grid_size(const command_queue &q, cl_uint dims,
+                      const size_t *d_grid_size) {
       auto grid_size = range(d_grid_size, dims);
 
       if (dims < 1 || dims > q.dev.max_block_size().size())
@@ -220,6 +220,24 @@ namespace {
       if (!d_grid_size || any_of(is_zero(), grid_size))
          throw error(CL_INVALID_GLOBAL_WORK_SIZE);
 
+      return grid_size;
+   }
+
+   std::vector<size_t>
+   validate_grid_offset(const command_queue &q, cl_uint dims,
+                        const size_t *d_grid_offset) {
+      if (d_grid_offset)
+         return range(d_grid_offset, dims);
+      else
+         return std::vector<size_t>(dims, 0);
+   }
+
+   std::vector<size_t>
+   validate_block_size(const command_queue &q, const kernel &kern,
+                       cl_uint dims, const size_t *d_grid_size,
+                       const size_t *d_block_size) {
+      auto grid_size = range(d_grid_size, dims);
+
       if (d_block_size) {
          auto block_size = range(d_block_size, dims);
 
@@ -233,15 +251,12 @@ namespace {
          if (fold(multiplies(), 1u, block_size) >
              q.dev.max_threads_per_block())
             throw error(CL_INVALID_WORK_GROUP_SIZE);
-      }
-   }
 
-   std::vector<size_t>
-   pad_vector(const size_t *p, unsigned n, size_t x) {
-      if (p)
-         return { p, p + n };
-      else
-         return { n, x };
+         return block_size;
+
+      } else {
+         return kern.optimal_block_size(q, grid_size);
+      }
    }
 }
 
@@ -254,13 +269,13 @@ clEnqueueNDRangeKernel(cl_command_queue d_q, cl_kernel d_kern,
    auto &q = obj(d_q);
    auto &kern = obj(d_kern);
    auto deps = objs<wait_list_tag>(d_deps, num_deps);
+   auto grid_size = validate_grid_size(q, dims, d_grid_size);
+   auto grid_offset = validate_grid_offset(q, dims, d_grid_offset);
+   auto block_size = validate_block_size(q, kern, dims,
+                                         d_grid_size, d_block_size);
 
    validate_common(q, kern, deps);
-   validate_grid(q, dims, d_grid_size, d_block_size);
 
-   auto grid_offset = pad_vector(d_grid_offset, dims, 0);
-   auto grid_size = pad_vector(d_grid_size, dims, 1);
-   auto block_size = pad_vector(d_block_size, dims, 1);
    hard_event *hev = new hard_event(
       q, CL_COMMAND_NDRANGE_KERNEL, deps,
       [=, &kern, &q](event &) {
diff --git a/src/gallium/state_trackers/clover/core/kernel.cpp b/src/gallium/state_trackers/clover/core/kernel.cpp
index 4670046..58780d6 100644
--- a/src/gallium/state_trackers/clover/core/kernel.cpp
+++ b/src/gallium/state_trackers/clover/core/kernel.cpp
@@ -22,6 +22,7 @@
 
 #include "core/kernel.hpp"
 #include "core/resource.hpp"
+#include "util/factor.hpp"
 #include "util/u_math.h"
 #include "pipe/p_context.h"
 
@@ -126,7 +127,15 @@ kernel::name() const {
 }
 
 std::vector<size_t>
-kernel::block_size() const {
+kernel::optimal_block_size(const command_queue &q,
+                           const std::vector<size_t> &grid_size) const {
+   return factor::find_grid_optimal_factor<size_t>(
+      q.dev.max_threads_per_block(), q.dev.max_block_size(),
+      grid_size);
+}
+
+std::vector<size_t>
+kernel::required_block_size() const {
    return { 0, 0, 0 };
 }
 
diff --git a/src/gallium/state_trackers/clover/core/kernel.hpp b/src/gallium/state_trackers/clover/core/kernel.hpp
index 4bcc3c7..f42e199 100644
--- a/src/gallium/state_trackers/clover/core/kernel.hpp
+++ b/src/gallium/state_trackers/clover/core/kernel.hpp
@@ -121,7 +121,12 @@ namespace clover {
       size_t mem_private() const;
 
       const std::string &name() const;
-      std::vector<size_t> block_size() const;
+
+      std::vector<size_t>
+      optimal_block_size(const command_queue &q,
+                         const std::vector<size_t> &grid_size) const;
+      std::vector<size_t>
+      required_block_size() const;
 
       argument_range args();
       const_argument_range args() const;
diff --git a/src/gallium/state_trackers/clover/llvm/invocation.cpp b/src/gallium/state_trackers/clover/llvm/invocation.cpp
index 4ae496f..3f50317 100644
--- a/src/gallium/state_trackers/clover/llvm/invocation.cpp
+++ b/src/gallium/state_trackers/clover/llvm/invocation.cpp
@@ -267,12 +267,7 @@ namespace {
          llvm::Function *kernel = *I;
          export_list.push_back(kernel->getName().data());
       }
-#if HAVE_LLVM < 0x0304
       PM.add(llvm::createInternalizePass(export_list));
-#else
-      std::vector<const char*> dso_list;
-      PM.add(llvm::createInternalizePass(export_list, dso_list));
-#endif
       PM.run(*mod);
    }
 
diff --git a/src/gallium/state_trackers/clover/util/factor.hpp b/src/gallium/state_trackers/clover/util/factor.hpp
new file mode 100644
index 0000000..76d3bfe
--- /dev/null
+++ b/src/gallium/state_trackers/clover/util/factor.hpp
@@ -0,0 +1,131 @@
+//
+// Copyright 2013 Francisco Jerez
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the "Software"),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+// OTHER DEALINGS IN THE SOFTWARE.
+//
+
+#ifndef CLOVER_UTIL_FACTOR_HPP
+#define CLOVER_UTIL_FACTOR_HPP
+
+#include "util/range.hpp"
+
+namespace clover {
+   namespace factor {
+      ///
+      /// Calculate all prime integer factors of \p x.
+      ///
+      /// If \p limit is non-zero, terminate early as soon as enough
+      /// factors have been collected to reach the product \p limit.
+      ///
+      template<typename T>
+      std::vector<T>
+      find_integer_prime_factors(T x, T limit = 0)
+      {
+         const T max_d = (limit > 0 && limit < x ? limit : x);
+         const T min_x = x / max_d;
+         std::vector<T> factors;
+
+         for (T d = 2; d <= max_d && x > min_x; d++) {
+            if (x % d == 0) {
+               for (; x % d == 0; x /= d);
+               factors.push_back(d);
+            }
+         }
+
+         return factors;
+      }
+
+      namespace detail {
+         ///
+         /// Walk the power set of prime factors of the n-dimensional
+         /// integer array \p grid subject to the constraints given by
+         /// \p limits.
+         ///
+         template<typename T>
+         std::pair<T, std::vector<T>>
+         next_grid_factor(const std::pair<T, std::vector<T>> &limits,
+                          const std::vector<T> &grid,
+                          const std::vector<std::vector<T>> &factors,
+                          std::pair<T, std::vector<T>> block,
+                          unsigned d = 0, unsigned i = 0) {
+            if (d >= factors.size()) {
+               // We're done.
+               return {};
+
+            } else if (i >= factors[d].size()) {
+               // We're done with this grid dimension, try the next.
+               return next_grid_factor(limits, grid, factors,
+                                       std::move(block), d + 1, 0);
+
+            } else {
+               T f = factors[d][i];
+
+               // Try the next power of this factor.
+               block.first *= f;
+               block.second[d] *= f;
+
+               if (block.first <= limits.first &&
+                   block.second[d] <= limits.second[d] &&
+                   grid[d] % block.second[d] == 0) {
+                  // We've found a valid grid divisor.
+                  return block;
+
+               } else {
+                  // Overflow, back off to the zeroth power,
+                  while (block.second[d] % f == 0) {
+                     block.second[d] /= f;
+                     block.first /= f;
+                  }
+
+                  // ...and carry to the next factor.
+                  return next_grid_factor(limits, grid, factors,
+                                          std::move(block), d, i + 1);
+               }
+            }
+         }
+      }
+
+      ///
+      /// Find the divisor of the integer array \p grid that gives the
+      /// highest possible product not greater than \p product_limit
+      /// subject to the constraints given by \p coord_limit.
+      ///
+      template<typename T>
+      std::vector<T>
+      find_grid_optimal_factor(T product_limit,
+                               const std::vector<T> &coord_limit,
+                               const std::vector<T> &grid) {
+         const std::vector<std::vector<T>> factors =
+            map(find_integer_prime_factors<T>, grid, coord_limit);
+         const auto limits = std::make_pair(product_limit, coord_limit);
+         auto best = std::make_pair(T(1), std::vector<T>(grid.size(), T(1)));
+
+         for (auto block = best;
+              block.first != 0 && best.first != product_limit;
+              block = detail::next_grid_factor(limits, grid, factors, block)) {
+            if (block.first > best.first)
+               best = block;
+         }
+
+         return best.second;
+      }
+   }
+}
+
+#endif
diff --git a/src/gallium/state_trackers/clover/util/range.hpp b/src/gallium/state_trackers/clover/util/range.hpp
index 151992e..afa5f77 100644
--- a/src/gallium/state_trackers/clover/util/range.hpp
+++ b/src/gallium/state_trackers/clover/util/range.hpp
@@ -218,14 +218,6 @@ namespace clover {
    namespace detail {
       template<typename T>
       using preferred_iterator_type = decltype(std::declval<T>().begin());
-
-      template<typename F, typename... Os>
-      using adaptor_iterator = detail::iterator_adaptor<
-         F, preferred_iterator_type<Os>...>;
-
-      template<typename F, typename... Os>
-      using adaptor_const_iterator = detail::iterator_adaptor<
-         F, preferred_iterator_type<const Os>...>;
    }
 
    ///
@@ -236,12 +228,17 @@ namespace clover {
    template<typename F, typename... Os>
    class adaptor_range :
       public detail::basic_range<adaptor_range<F, Os...>,
-                                 detail::adaptor_iterator<F, Os...>,
-                                 detail::adaptor_const_iterator<F, Os...>> {
+                                 detail::iterator_adaptor<
+                                    F, detail::preferred_iterator_type<Os>...>,
+                                 detail::iterator_adaptor<
+                                    F, detail::preferred_iterator_type<const Os>...>
+                                 > {
    public:
       typedef detail::basic_range<adaptor_range<F, Os...>,
-                                  detail::adaptor_iterator<F, Os...>,
-                                  detail::adaptor_const_iterator<F, Os...>
+                                  detail::iterator_adaptor<
+                                     F, detail::preferred_iterator_type<Os>...>,
+                                  detail::iterator_adaptor<
+                                     F, detail::preferred_iterator_type<const Os>...>
                                   > super;
 
       template<typename G, typename... Rs>
@@ -254,25 +251,26 @@ namespace clover {
          return f == r.f && os == r.os;
       }
 
-      detail::adaptor_iterator<F, Os...>
+      typename super::iterator
       begin() {
          return { f, tuple::map(begins(), os) };
       }
 
-      detail::adaptor_iterator<F, Os...>
+      typename super::iterator
       end() {
          return { f, tuple::map(advances_by(size()),
                                 tuple::map(begins(), os)) };
       }
 
-      detail::adaptor_const_iterator<F, Os...>
+      typename super::const_iterator
       begin() const {
          return { f, tuple::map(begins(), os) };
       }
 
-      detail::adaptor_const_iterator<F, Os...>
+      typename super::const_iterator
       end() const {
-         return { f, tuple::map(ends(), os) };
+         return { f, tuple::map(advances_by(size()),
+                                tuple::map(begins(), os)) };
       }
 
       typename super::size_type
diff --git a/src/gallium/state_trackers/dri/common/dri_context.c b/src/gallium/state_trackers/dri/common/dri_context.c
index ee3c8be..988e28e 100644
--- a/src/gallium/state_trackers/dri/common/dri_context.c
+++ b/src/gallium/state_trackers/dri/common/dri_context.c
@@ -63,6 +63,7 @@ dri_create_context(gl_api api, const struct gl_config * visual,
 		   unsigned major_version,
 		   unsigned minor_version,
 		   uint32_t flags,
+                   bool notify_reset,
 		   unsigned *error,
 		   void *sharedContextPrivate)
 {
@@ -100,6 +101,16 @@ dri_create_context(gl_api api, const struct gl_config * visual,
       goto fail;
    }
 
+   if (flags & ~(__DRI_CTX_FLAG_DEBUG | __DRI_CTX_FLAG_FORWARD_COMPATIBLE)) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      goto fail;
+   }
+
+   if (notify_reset) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      goto fail;
+   }
+
    if (sharedContextPrivate) {
       st_share = ((struct dri_context *)sharedContextPrivate)->st;
    }
diff --git a/src/gallium/state_trackers/dri/common/dri_context.h b/src/gallium/state_trackers/dri/common/dri_context.h
index b87ce40..56dfa2c 100644
--- a/src/gallium/state_trackers/dri/common/dri_context.h
+++ b/src/gallium/state_trackers/dri/common/dri_context.h
@@ -89,6 +89,7 @@ dri_create_context(gl_api api,
 		   unsigned major_version,
 		   unsigned minor_version,
 		   uint32_t flags,
+		   bool notify_reset,
 		   unsigned *error,
 		   void *sharedContextPrivate);
 
diff --git a/src/gallium/state_trackers/egl/Android.mk b/src/gallium/state_trackers/egl/Android.mk
index 2627608..b27e14b 100644
--- a/src/gallium/state_trackers/egl/Android.mk
+++ b/src/gallium/state_trackers/egl/Android.mk
@@ -23,14 +23,14 @@
 
 LOCAL_PATH := $(call my-dir)
 
-# get common_SOURCES, android_SOURCES
+# get common_FILES, android_FILES
 include $(LOCAL_PATH)/Makefile.sources
 
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := \
-	$(common_SOURCES) \
-	$(android_SOURCES)
+	$(common_FILES) \
+	$(android_FILES)
 
 LOCAL_CFLAGS := -DHAVE_ANDROID_BACKEND
 
diff --git a/src/gallium/state_trackers/egl/Makefile.am b/src/gallium/state_trackers/egl/Makefile.am
index da360bb..c069c29 100644
--- a/src/gallium/state_trackers/egl/Makefile.am
+++ b/src/gallium/state_trackers/egl/Makefile.am
@@ -32,10 +32,10 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/include
 
 noinst_LTLIBRARIES = libegl.la
-libegl_la_SOURCES = $(common_SOURCES)
+libegl_la_SOURCES = $(common_FILES)
 
 if HAVE_EGL_PLATFORM_X11
-libegl_la_SOURCES += $(x11_SOURCES) $(x11_drm_SOURCES)
+libegl_la_SOURCES += $(x11_FILES) $(x11_drm_FILES)
 AM_CFLAGS += \
 	$(X11_INCLUDES) \
 	$(LIBDRM_CFLAGS) \
@@ -49,7 +49,7 @@ AM_CPPFLAGS += \
 endif
 
 if HAVE_EGL_PLATFORM_WAYLAND
-libegl_la_SOURCES += $(wayland_SOURCES)
+libegl_la_SOURCES += $(wayland_FILES)
 AM_CFLAGS += \
 	$(LIBDRM_CFLAGS) \
 	$(WAYLAND_CFLAGS)
@@ -62,7 +62,7 @@ AM_CPPFLAGS += \
 endif
 
 if HAVE_EGL_PLATFORM_DRM
-libegl_la_SOURCES += $(drm_SOURCES)
+libegl_la_SOURCES += $(drm_FILES)
 AM_CFLAGS += \
 	$(LIBDRM_CFLAGS)
 AM_CPPFLAGS += \
@@ -73,14 +73,14 @@ AM_CPPFLAGS += \
 endif
 
 if HAVE_EGL_PLATFORM_FBDEV
-libegl_la_SOURCES += $(fbdev_SOURCES)
+libegl_la_SOURCES += $(fbdev_FILES)
 AM_CPPFLAGS += \
 	-I$(top_srcdir)/src/gallium/winsys/sw \
 	-DHAVE_FBDEV_BACKEND
 endif
 
 if HAVE_EGL_PLATFORM_NULL
-libegl_la_SOURCES += $(null_SOURCES)
+libegl_la_SOURCES += $(null_FILES)
 AM_CPPFLAGS += \
 	-I$(top_srcdir)/src/gallium/winsys/sw \
 	-DHAVE_NULL_BACKEND
diff --git a/src/gallium/state_trackers/egl/Makefile.sources b/src/gallium/state_trackers/egl/Makefile.sources
index aaf6b8b..2f60b3a 100644
--- a/src/gallium/state_trackers/egl/Makefile.sources
+++ b/src/gallium/state_trackers/egl/Makefile.sources
@@ -1,4 +1,4 @@
-common_SOURCES := \
+common_FILES := \
 	common/egl_g3d_api.c \
 	common/egl_g3d.c \
 	common/egl_g3d_image.c \
@@ -7,33 +7,33 @@ common_SOURCES := \
 	common/native_helper.c \
 	common/native_wayland_drm_bufmgr.c
 
-android_SOURCES := \
+android_FILES := \
 	android/native_android.cpp
 
-drm_SOURCES := \
+drm_FILES := \
 	drm/modeset.c \
 	drm/native_drm.c
 
-fbdev_SOURCES := \
+fbdev_FILES := \
 	fbdev/native_fbdev.c
 
-gdi_SOURCES := \
+gdi_FILES := \
 	gdi/native_gdi.c
 
-null_SOURCES := \
+null_FILES := \
 	null/native_null.c
 
-x11_SOURCES := \
+x11_FILES := \
 	x11/glxinit.c \
 	x11/native_dri2.c \
 	x11/native_x11.c \
 	x11/native_ximage.c
 
-x11_drm_SOURCES := \
+x11_drm_FILES := \
 	x11/x11_screen.c \
 	x11/dri2.c
 
-wayland_SOURCES := \
+wayland_FILES := \
 	wayland/native_drm.c \
 	wayland/native_shm.c \
 	wayland/native_wayland.c
diff --git a/src/gallium/state_trackers/egl/SConscript b/src/gallium/state_trackers/egl/SConscript
index b86f8b5..bd0ee02 100644
--- a/src/gallium/state_trackers/egl/SConscript
+++ b/src/gallium/state_trackers/egl/SConscript
@@ -11,11 +11,11 @@ env.Append(CPPPATH = [
     '.',
 ])
 
-sources = env.ParseSourceList('Makefile.sources', 'common_SOURCES')
+sources = env.ParseSourceList('Makefile.sources', 'common_FILES')
 
 if env['platform'] == 'windows':
     env.Append(CPPDEFINES = ['HAVE_GDI_BACKEND'])
-    sources.append(env.ParseSourceList('Makefile.sources', 'gdi_SOURCES'))
+    sources.append(env.ParseSourceList('Makefile.sources', 'gdi_FILES'))
 else:
     if env['drm']:
         env.PkgUseModules('DRM')
@@ -25,10 +25,10 @@ else:
             '#/src/glx',
             '#/src/mapi',
         ])
-        sources.append(env.ParseSourceList('Makefile.sources', 'x11_SOURCES'))
+        sources.append(env.ParseSourceList('Makefile.sources', 'x11_FILES'))
         if env['drm']:
             env.Append(CPPDEFINES = ['GLX_DIRECT_RENDERING'])
-            sources.append(env.ParseSourceList('Makefile.sources', 'x11_drm_SOURCES'))
+            sources.append(env.ParseSourceList('Makefile.sources', 'x11_drm_FILES'))
     if env['drm'] and False:
         # XXX: Disabled as it depends on gbm, which is not yet built with scons
         env.Append(CPPDEFINES = ['HAVE_DRM_BACKEND'])
@@ -36,7 +36,7 @@ else:
             '#/src/gbm/main',
             '#/src/gallium/state_trackers/gbm',
         ])
-        sources.append(env.ParseSourceList('Makefile.sources', 'drm_SOURCES'))
+        sources.append(env.ParseSourceList('Makefile.sources', 'drm_FILES'))
 
 st_egl = env.ConvenienceLibrary(
     target = 'st_egl',
diff --git a/src/gallium/state_trackers/vdpau/output.c b/src/gallium/state_trackers/vdpau/output.c
index def01c8..e4e1433 100644
--- a/src/gallium/state_trackers/vdpau/output.c
+++ b/src/gallium/state_trackers/vdpau/output.c
@@ -734,5 +734,9 @@ struct pipe_resource *vlVdpOutputSurfaceGallium(VdpOutputSurface surface)
    if (!vlsurface || !vlsurface->surface)
       return NULL;
 
+   pipe_mutex_lock(vlsurface->device->mutex);
+   vlVdpResolveDelayedRendering(vlsurface->device, NULL, NULL);
+   pipe_mutex_unlock(vlsurface->device->mutex);
+
    return vlsurface->surface->texture;
 }
diff --git a/src/gallium/state_trackers/vega/paint.c b/src/gallium/state_trackers/vega/paint.c
index 79b7a27..fea9fc1 100644
--- a/src/gallium/state_trackers/vega/paint.c
+++ b/src/gallium/state_trackers/vega/paint.c
@@ -516,7 +516,7 @@ void paint_set_pattern_tiling(struct vg_paint *paint,
       paint->pattern.sampler.wrap_t = PIPE_TEX_WRAP_MIRROR_REPEAT;
       break;
    default:
-      debug_assert("!Unknown tiling mode");
+      debug_assert(!"Unknown tiling mode");
    }
 }
 
diff --git a/src/gallium/state_trackers/xorg/Makefile.am b/src/gallium/state_trackers/xorg/Makefile.am
deleted file mode 100644
index ffc1ad0..0000000
--- a/src/gallium/state_trackers/xorg/Makefile.am
+++ /dev/null
@@ -1,43 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include Makefile.sources
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(XEXT_CFLAGS) \
-	$(LIBKMS_XORG_CFLAGS) \
-	$(LIBDRM_XORG_CFLAGS) \
-	$(shell $(PKG_CONFIG) --cflags-only-I xorg-server)
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mesa/drivers/dri/common \
-	-I$(top_srcdir)/src/mesa/main \
-	-DHAVE_CONFIG_H \
-	-DHAVE_LIBKMS
-
-noinst_LTLIBRARIES = libxorgtracker.la
-
-libxorgtracker_la_SOURCES = $(C_SOURCES)
diff --git a/src/gallium/state_trackers/xorg/Makefile.sources b/src/gallium/state_trackers/xorg/Makefile.sources
deleted file mode 100644
index 7b07356..0000000
--- a/src/gallium/state_trackers/xorg/Makefile.sources
+++ /dev/null
@@ -1,11 +0,0 @@
-C_SOURCES := \
-	xorg_composite.c \
-	xorg_crtc.c \
-	xorg_dri2.c \
-	xorg_driver.c \
-	xorg_exa.c \
-	xorg_exa_tgsi.c \
-	xorg_output.c \
-	xorg_renderer.c \
-	xorg_xv.c \
-	xorg_xvmc.c
diff --git a/src/gallium/state_trackers/xorg/SConscript b/src/gallium/state_trackers/xorg/SConscript
deleted file mode 100644
index 88990d5..0000000
--- a/src/gallium/state_trackers/xorg/SConscript
+++ /dev/null
@@ -1,29 +0,0 @@
-#######################################################################
-# SConscript for xorg state_tracker
-
-Import('*')
-
-env = env.Clone()
-
-env.Append(CPPPATH = [
-    '#/src/mesa',
-])
-
-env.PkgUseModules(['DRM', 'XORG'])
-
-if env['HAVE_KMS']:
-    env.Append(CPPDEFINES = ['HAVE_LIBKMS'])
-    env.PkgUseModules(['KMS'])
-
-conf = env.Configure()
-
-if conf.CheckHeader('X11/extensions/dpmsconst.h'):
-    env.Append(CPPDEFINES = [('HAVE_XEXTPROTO_71', '1')])
-
-conf.Finish()
-
-st_xorg = env.ConvenienceLibrary(
-    target = 'st_xorg',
-    source = env.ParseSourceList('Makefile.sources', 'C_SOURCES')
-)
-Export('st_xorg')
diff --git a/src/gallium/state_trackers/xorg/compat-api.h b/src/gallium/state_trackers/xorg/compat-api.h
deleted file mode 100644
index 6bc946f..0000000
--- a/src/gallium/state_trackers/xorg/compat-api.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright 2012 Red Hat, Inc.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- * Author: Dave Airlie <airlied@redhat.com>
- */
-
-/* this file provides API compat between server post 1.13 and pre it,
-   it should be reused inside as many drivers as possible */
-#ifndef COMPAT_API_H
-#define COMPAT_API_H
-
-#ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
-#define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
-#define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
-#endif
-
-#ifndef XF86_HAS_SCRN_CONV
-#define xf86ScreenToScrn(s) xf86Screens[(s)->myNum]
-#define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
-#endif
-
-#ifndef XF86_SCRN_INTERFACE
-
-#define SCRN_ARG_TYPE int
-#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrn = xf86Screens[(arg1)]
-
-#define SCREEN_ARG_TYPE int
-#define SCREEN_PTR(arg1) ScreenPtr pScreen = screenInfo.screens[(arg1)]
-
-#define SCREEN_INIT_ARGS_DECL int i, ScreenPtr pScreen, int argc, char **argv
-
-#define BLOCKHANDLER_ARGS_DECL int arg, pointer blockData, pointer pTimeout, pointer pReadmask
-#define BLOCKHANDLER_ARGS arg, blockData, pTimeout, pReadmask
-
-#define CLOSE_SCREEN_ARGS_DECL int scrnIndex, ScreenPtr pScreen
-#define CLOSE_SCREEN_ARGS scrnIndex, pScreen
-
-#define ADJUST_FRAME_ARGS_DECL int arg, int x, int y, int flags
-#define ADJUST_FRAME_ARGS(arg, x, y) (arg)->scrnIndex, x, y, 0
-
-#define SWITCH_MODE_ARGS_DECL int arg, DisplayModePtr mode, int flags
-#define SWITCH_MODE_ARGS(arg, m) (arg)->scrnIndex, m, 0
-
-#define FREE_SCREEN_ARGS_DECL int arg, int flags
-
-#define VT_FUNC_ARGS_DECL int arg, int flags
-#define VT_FUNC_ARGS pScrn->scrnIndex, 0
-
-#define XF86_SCRN_ARG(x) ((x)->scrnIndex)
-#else
-#define SCRN_ARG_TYPE ScrnInfoPtr
-#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrn = (arg1)
-
-#define SCREEN_ARG_TYPE ScreenPtr
-#define SCREEN_PTR(arg1) ScreenPtr pScreen = (arg1)
-
-#define SCREEN_INIT_ARGS_DECL ScreenPtr pScreen, int argc, char **argv
-
-#define BLOCKHANDLER_ARGS_DECL ScreenPtr arg, pointer pTimeout, pointer pReadmask
-#define BLOCKHANDLER_ARGS arg, pTimeout, pReadmask
-
-#define CLOSE_SCREEN_ARGS_DECL ScreenPtr pScreen
-#define CLOSE_SCREEN_ARGS pScreen
-
-#define ADJUST_FRAME_ARGS_DECL ScrnInfoPtr arg, int x, int y
-#define ADJUST_FRAME_ARGS(arg, x, y) arg, x, y
-
-#define SWITCH_MODE_ARGS_DECL ScrnInfoPtr arg, DisplayModePtr mode
-#define SWITCH_MODE_ARGS(arg, m) arg, m
-
-#define FREE_SCREEN_ARGS_DECL ScrnInfoPtr arg
-
-#define VT_FUNC_ARGS_DECL ScrnInfoPtr arg
-#define VT_FUNC_ARGS pScrn
-
-#define XF86_SCRN_ARG(x) (x)
-
-#endif
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_composite.c b/src/gallium/state_trackers/xorg/xorg_composite.c
deleted file mode 100644
index 7ccb3fe..0000000
--- a/src/gallium/state_trackers/xorg/xorg_composite.c
+++ /dev/null
@@ -1,585 +0,0 @@
-#include "xorg_composite.h"
-
-#include "xorg_renderer.h"
-#include "xorg_exa_tgsi.h"
-
-#include "cso_cache/cso_context.h"
-#include "util/u_format.h"
-#include "util/u_sampler.h"
-
-
-/*XXX also in Xrender.h but the including it here breaks compilition */
-#define XFixedToDouble(f)    (((double) (f)) / 65536.)
-
-struct xorg_composite_blend {
-   int op : 8;
-
-   unsigned alpha_dst : 4;
-   unsigned alpha_src : 4;
-
-   unsigned rgb_src : 8;    /**< PIPE_BLENDFACTOR_x */
-   unsigned rgb_dst : 8;    /**< PIPE_BLENDFACTOR_x */
-};
-
-#define BLEND_OP_OVER 3
-static const struct xorg_composite_blend xorg_blends[] = {
-   { PictOpClear,
-     0, 0, PIPE_BLENDFACTOR_ZERO, PIPE_BLENDFACTOR_ZERO},
-   { PictOpSrc,
-     0, 0, PIPE_BLENDFACTOR_ONE, PIPE_BLENDFACTOR_ZERO},
-   { PictOpDst,
-     0, 0, PIPE_BLENDFACTOR_ZERO, PIPE_BLENDFACTOR_ONE},
-   { PictOpOver,
-     0, 1, PIPE_BLENDFACTOR_ONE, PIPE_BLENDFACTOR_INV_SRC_ALPHA},
-   { PictOpOverReverse,
-     1, 0, PIPE_BLENDFACTOR_INV_DST_ALPHA, PIPE_BLENDFACTOR_ONE},
-   { PictOpIn,
-     1, 0, PIPE_BLENDFACTOR_DST_ALPHA, PIPE_BLENDFACTOR_ZERO},
-   { PictOpInReverse,
-     0, 1, PIPE_BLENDFACTOR_ZERO, PIPE_BLENDFACTOR_SRC_ALPHA},
-   { PictOpOut,
-     1, 0, PIPE_BLENDFACTOR_INV_DST_ALPHA, PIPE_BLENDFACTOR_ZERO},
-   { PictOpOutReverse,
-     0, 1, PIPE_BLENDFACTOR_ZERO, PIPE_BLENDFACTOR_INV_SRC_ALPHA},
-   { PictOpAtop,
-     1, 1, PIPE_BLENDFACTOR_DST_ALPHA, PIPE_BLENDFACTOR_INV_SRC_ALPHA},
-   { PictOpAtopReverse,
-     1, 1, PIPE_BLENDFACTOR_INV_DST_ALPHA, PIPE_BLENDFACTOR_SRC_ALPHA},
-   { PictOpXor,
-     1, 1, PIPE_BLENDFACTOR_INV_DST_ALPHA, PIPE_BLENDFACTOR_INV_SRC_ALPHA},
-   { PictOpAdd,
-     0, 0, PIPE_BLENDFACTOR_ONE, PIPE_BLENDFACTOR_ONE},
-};
-
-
-static INLINE void
-pixel_to_float4(Pixel pixel, float *color, enum pipe_format format)
-{
-   const struct util_format_description *format_desc;
-   uint8_t packed[4];
-
-   format_desc = util_format_description(format);
-   packed[0] = pixel;
-   packed[1] = pixel >> 8;
-   packed[2] = pixel >> 16;
-   packed[3] = pixel >> 24;
-   format_desc->unpack_rgba_float(color, 0, packed, 0, 1, 1);
-}
-
-static boolean
-blend_for_op(struct xorg_composite_blend *blend,
-             int op, PicturePtr pSrcPicture, PicturePtr pMaskPicture,
-             PicturePtr pDstPicture)
-{
-   const int num_blends =
-      sizeof(xorg_blends)/sizeof(struct xorg_composite_blend);
-   int i;
-   boolean supported = FALSE;
-
-   /* our default in case something goes wrong */
-   *blend = xorg_blends[BLEND_OP_OVER];
-
-   for (i = 0; i < num_blends; ++i) {
-      if (xorg_blends[i].op == op) {
-         *blend = xorg_blends[i];
-         supported = TRUE;
-      }
-   }
-
-   /* If there's no dst alpha channel, adjust the blend op so that we'll treat
-    * it as always 1. */
-   if (pDstPicture &&
-       PICT_FORMAT_A(pDstPicture->format) == 0 && blend->alpha_dst) {
-      if (blend->rgb_src == PIPE_BLENDFACTOR_DST_ALPHA)
-         blend->rgb_src = PIPE_BLENDFACTOR_ONE;
-      else if (blend->rgb_src == PIPE_BLENDFACTOR_INV_DST_ALPHA)
-         blend->rgb_src = PIPE_BLENDFACTOR_ZERO;
-   }
-
-   /* If the source alpha is being used, then we should only be in a case where
-    * the source blend factor is 0, and the source blend value is the mask
-    * channels multiplied by the source picture's alpha. */
-   if (pMaskPicture && pMaskPicture->componentAlpha &&
-       PICT_FORMAT_RGB(pMaskPicture->format) && blend->alpha_src) {
-      if (blend->rgb_dst == PIPE_BLENDFACTOR_SRC_ALPHA) {
-         blend->rgb_dst = PIPE_BLENDFACTOR_SRC_COLOR;
-      } else if (blend->rgb_dst == PIPE_BLENDFACTOR_INV_SRC_ALPHA) {
-         blend->rgb_dst = PIPE_BLENDFACTOR_INV_SRC_COLOR;
-      }
-   }
-
-   return supported;
-}
-
-static INLINE int
-render_repeat_to_gallium(int mode)
-{
-   switch(mode) {
-   case RepeatNone:
-      return PIPE_TEX_WRAP_CLAMP_TO_BORDER;
-   case RepeatNormal:
-      return PIPE_TEX_WRAP_REPEAT;
-   case RepeatReflect:
-      return PIPE_TEX_WRAP_MIRROR_REPEAT;
-   case RepeatPad:
-      return PIPE_TEX_WRAP_CLAMP_TO_EDGE;
-   default:
-      debug_printf("Unsupported repeat mode\n");
-   }
-   return PIPE_TEX_WRAP_REPEAT;
-}
-
-static INLINE boolean
-render_filter_to_gallium(int xrender_filter, int *out_filter)
-{
-
-   switch (xrender_filter) {
-   case PictFilterNearest:
-      *out_filter = PIPE_TEX_FILTER_NEAREST;
-      break;
-   case PictFilterBilinear:
-      *out_filter = PIPE_TEX_FILTER_LINEAR;
-      break;
-   case PictFilterFast:
-      *out_filter = PIPE_TEX_FILTER_NEAREST;
-      break;
-   case PictFilterGood:
-      *out_filter = PIPE_TEX_FILTER_LINEAR;
-      break;
-   case PictFilterBest:
-      *out_filter = PIPE_TEX_FILTER_LINEAR;
-      break;
-   case PictFilterConvolution:
-      *out_filter = PIPE_TEX_FILTER_NEAREST;
-      return FALSE;
-   default:
-      debug_printf("Unknown xrender filter\n");
-      *out_filter = PIPE_TEX_FILTER_NEAREST;
-      return FALSE;
-   }
-
-   return TRUE;
-}
-
-static boolean is_filter_accelerated(PicturePtr pic)
-{
-   int filter;
-   if (pic && !render_filter_to_gallium(pic->filter, &filter))
-       return FALSE;
-   return TRUE;
-}
-
-boolean xorg_composite_accelerated(int op,
-                                   PicturePtr pSrcPicture,
-                                   PicturePtr pMaskPicture,
-                                   PicturePtr pDstPicture)
-{
-   ScreenPtr pScreen = pDstPicture->pDrawable->pScreen;
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct xorg_composite_blend blend;
-
-   if (!is_filter_accelerated(pSrcPicture) ||
-       !is_filter_accelerated(pMaskPicture)) {
-      XORG_FALLBACK("Unsupported Xrender filter");
-   }
-
-   if (pSrcPicture->pSourcePict) {
-      if (pSrcPicture->pSourcePict->type != SourcePictTypeSolidFill)
-         XORG_FALLBACK("Gradients not enabled (haven't been well tested)");
-   }
-
-   if (blend_for_op(&blend, op,
-                    pSrcPicture, pMaskPicture, pDstPicture)) {
-      /* Check for component alpha */
-      if (pMaskPicture && pMaskPicture->componentAlpha &&
-          PICT_FORMAT_RGB(pMaskPicture->format)) {
-         if (blend.alpha_src && blend.rgb_src != PIPE_BLENDFACTOR_ZERO) {
-            XORG_FALLBACK("Component alpha not supported with source "
-                          "alpha and source value blending. (op=%d)",
-                          op);
-         }
-      }
-
-      return TRUE;
-   }
-   XORG_FALLBACK("Unsupported composition operation = %d", op);
-}
-
-static void
-bind_blend_state(struct exa_context *exa, int op,
-                 PicturePtr pSrcPicture,
-                 PicturePtr pMaskPicture,
-                 PicturePtr pDstPicture)
-{
-   struct xorg_composite_blend blend_opt;
-   struct pipe_blend_state blend;
-
-   blend_for_op(&blend_opt, op, pSrcPicture, pMaskPicture, pDstPicture);
-
-   memset(&blend, 0, sizeof(struct pipe_blend_state));
-   blend.rt[0].blend_enable = 1;
-   blend.rt[0].colormask = PIPE_MASK_RGBA;
-
-   blend.rt[0].rgb_src_factor   = blend_opt.rgb_src;
-   blend.rt[0].alpha_src_factor = blend_opt.rgb_src;
-   blend.rt[0].rgb_dst_factor   = blend_opt.rgb_dst;
-   blend.rt[0].alpha_dst_factor = blend_opt.rgb_dst;
-
-   cso_set_blend(exa->renderer->cso, &blend);
-}
-
-static unsigned
-picture_format_fixups(struct exa_pixmap_priv *pSrc, PicturePtr pSrcPicture, boolean mask,
-                      PicturePtr pDstPicture)
-{
-   boolean set_alpha = FALSE;
-   boolean swizzle = FALSE;
-   unsigned ret = 0;
-
-   if (pSrc && pSrc->picture_format == pSrcPicture->format) {
-      if (pSrc->picture_format == PICT_a8) {
-         if (mask)
-            return FS_MASK_LUMINANCE;
-         else if (pDstPicture->format != PICT_a8) {
-            /* if both dst and src are luminance then
-             * we don't want to swizzle the alpha (X) of the
-             * source into W component of the dst because
-             * it will break our destination */
-            return FS_SRC_LUMINANCE;
-         }
-      }
-      return 0;
-   }
-
-   if (pSrc && pSrc->picture_format != PICT_a8r8g8b8) {
-      assert(!"can not handle formats");
-      return 0;
-   }
-
-   /* pSrc->picture_format == PICT_a8r8g8b8 */
-   switch (pSrcPicture->format) {
-   case PICT_x8b8g8r8:
-   case PICT_b8g8r8:
-      set_alpha = TRUE; /* fall trough */
-   case PICT_a8b8g8r8:
-      swizzle = TRUE;
-      break;
-   case PICT_x8r8g8b8:
-   case PICT_r8g8b8:
-      set_alpha = TRUE; /* fall through */
-   case PICT_a8r8g8b8:
-      break;
-#ifdef PICT_TYPE_BGRA
-   case PICT_b8g8r8a8:
-   case PICT_b8g8r8x8:
-   case PICT_a2r10g10b10:
-   case PICT_x2r10g10b10:
-   case PICT_a2b10g10r10:
-   case PICT_x2b10g10r10:
-#endif
-   default:
-      assert(!"can not handle formats");
-      return 0;
-   }
-
-   if (set_alpha)
-      ret |= mask ? FS_MASK_SET_ALPHA : FS_SRC_SET_ALPHA;
-   if (swizzle)
-      ret |= mask ? FS_MASK_SWIZZLE_RGB : FS_SRC_SWIZZLE_RGB;
-
-   return ret;
-}
-
-static void
-bind_shaders(struct exa_context *exa, int op,
-             PicturePtr pSrcPicture, PicturePtr pMaskPicture, PicturePtr pDstPicture,
-             struct exa_pixmap_priv *pSrc, struct exa_pixmap_priv *pMask)
-{
-   unsigned vs_traits = 0, fs_traits = 0;
-   struct xorg_shader shader;
-
-   exa->has_solid_color = FALSE;
-
-   if (pSrcPicture) {
-      if (pSrcPicture->repeatType == RepeatNone && pSrcPicture->transform)
-         fs_traits |= FS_SRC_REPEAT_NONE;
-
-      if (pSrcPicture->pSourcePict) {
-         if (pSrcPicture->pSourcePict->type == SourcePictTypeSolidFill) {
-            fs_traits |= FS_SOLID_FILL;
-            vs_traits |= VS_SOLID_FILL;
-            debug_assert(pSrcPicture->format == PICT_a8r8g8b8);
-            pixel_to_float4(pSrcPicture->pSourcePict->solidFill.color,
-                            exa->solid_color, PIPE_FORMAT_B8G8R8A8_UNORM);
-            exa->has_solid_color = TRUE;
-         } else {
-            debug_assert("!gradients not supported");
-         }
-      } else {
-         fs_traits |= FS_COMPOSITE;
-         vs_traits |= VS_COMPOSITE;
-      }
-
-      fs_traits |= picture_format_fixups(pSrc, pSrcPicture, FALSE, pDstPicture);
-   }
-
-   if (pMaskPicture) {
-      vs_traits |= VS_MASK;
-      fs_traits |= FS_MASK;
-      if (pMaskPicture->repeatType == RepeatNone && pMaskPicture->transform)
-         fs_traits |= FS_MASK_REPEAT_NONE;
-      if (pMaskPicture->componentAlpha) {
-         struct xorg_composite_blend blend;
-         blend_for_op(&blend, op,
-                      pSrcPicture, pMaskPicture, NULL);
-         if (blend.alpha_src) {
-            fs_traits |= FS_CA_SRCALPHA;
-         } else
-            fs_traits |= FS_CA_FULL;
-      }
-
-      fs_traits |= picture_format_fixups(pMask, pMaskPicture, TRUE, pDstPicture);
-   }
-
-   shader = xorg_shaders_get(exa->renderer->shaders, vs_traits, fs_traits);
-   cso_set_vertex_shader_handle(exa->renderer->cso, shader.vs);
-   cso_set_fragment_shader_handle(exa->renderer->cso, shader.fs);
-}
-
-static void
-bind_samplers(struct exa_context *exa, int op,
-              PicturePtr pSrcPicture, PicturePtr pMaskPicture,
-              PicturePtr pDstPicture,
-              struct exa_pixmap_priv *pSrc,
-              struct exa_pixmap_priv *pMask,
-              struct exa_pixmap_priv *pDst)
-{
-   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS] = {0};
-   struct pipe_sampler_state src_sampler, mask_sampler;
-   struct pipe_sampler_view view_templ;
-   struct pipe_sampler_view *src_view;
-   struct pipe_context *pipe = exa->pipe;
-
-   exa->num_bound_samplers = 0;
-
-   memset(&src_sampler, 0, sizeof(struct pipe_sampler_state));
-   memset(&mask_sampler, 0, sizeof(struct pipe_sampler_state));
-
-   if (pSrcPicture && pSrc) {
-      if (exa->has_solid_color) {
-         debug_assert(!"solid color with textures");
-         samplers[0] = NULL;
-         pipe_sampler_view_reference(&exa->bound_sampler_views[0], NULL);
-      } else {
-         unsigned src_wrap = render_repeat_to_gallium(
-            pSrcPicture->repeatType);
-         int filter;
-
-         render_filter_to_gallium(pSrcPicture->filter, &filter);
-
-         src_sampler.wrap_s = src_wrap;
-         src_sampler.wrap_t = src_wrap;
-         src_sampler.min_img_filter = filter;
-         src_sampler.mag_img_filter = filter;
-         src_sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NEAREST;
-         src_sampler.normalized_coords = 1;
-         samplers[0] = &src_sampler;
-         exa->num_bound_samplers = 1;
-         u_sampler_view_default_template(&view_templ,
-                                         pSrc->tex,
-                                         pSrc->tex->format);
-         src_view = pipe->create_sampler_view(pipe, pSrc->tex, &view_templ);
-         pipe_sampler_view_reference(&exa->bound_sampler_views[0], NULL);
-         exa->bound_sampler_views[0] = src_view;
-      }
-   }
-
-   if (pMaskPicture && pMask) {
-      unsigned mask_wrap = render_repeat_to_gallium(
-         pMaskPicture->repeatType);
-      int filter;
-
-      render_filter_to_gallium(pMaskPicture->filter, &filter);
-
-      mask_sampler.wrap_s = mask_wrap;
-      mask_sampler.wrap_t = mask_wrap;
-      mask_sampler.min_img_filter = filter;
-      mask_sampler.mag_img_filter = filter;
-      src_sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NEAREST;
-      mask_sampler.normalized_coords = 1;
-      samplers[1] = &mask_sampler;
-      exa->num_bound_samplers = 2;
-      u_sampler_view_default_template(&view_templ,
-                                      pMask->tex,
-                                      pMask->tex->format);
-      src_view = pipe->create_sampler_view(pipe, pMask->tex, &view_templ);
-      pipe_sampler_view_reference(&exa->bound_sampler_views[1], NULL);
-      exa->bound_sampler_views[1] = src_view;
-   }
-
-   cso_set_samplers(exa->renderer->cso, PIPE_SHADER_FRAGMENT,
-                    exa->num_bound_samplers,
-                    (const struct pipe_sampler_state **)samplers);
-   cso_set_sampler_views(exa->renderer->cso, PIPE_SHADER_FRAGMENT,
-                         exa->num_bound_samplers,
-                         exa->bound_sampler_views);
-}
-
-
-
-static INLINE boolean matrix_from_pict_transform(PictTransform *trans, float *matrix)
-{
-   if (!trans)
-      return FALSE;
-
-   matrix[0] = XFixedToDouble(trans->matrix[0][0]);
-   matrix[3] = XFixedToDouble(trans->matrix[0][1]);
-   matrix[6] = XFixedToDouble(trans->matrix[0][2]);
-
-   matrix[1] = XFixedToDouble(trans->matrix[1][0]);
-   matrix[4] = XFixedToDouble(trans->matrix[1][1]);
-   matrix[7] = XFixedToDouble(trans->matrix[1][2]);
-
-   matrix[2] = XFixedToDouble(trans->matrix[2][0]);
-   matrix[5] = XFixedToDouble(trans->matrix[2][1]);
-   matrix[8] = XFixedToDouble(trans->matrix[2][2]);
-
-   return TRUE;
-}
-
-static void
-setup_transforms(struct  exa_context *exa,
-                 PicturePtr pSrcPicture, PicturePtr pMaskPicture)
-{
-   PictTransform *src_t = NULL;
-   PictTransform *mask_t = NULL;
-
-   if (pSrcPicture)
-      src_t = pSrcPicture->transform;
-   if (pMaskPicture)
-      mask_t = pMaskPicture->transform;
-
-   exa->transform.has_src  =
-      matrix_from_pict_transform(src_t, exa->transform.src);
-   exa->transform.has_mask =
-      matrix_from_pict_transform(mask_t, exa->transform.mask);
-}
-
-boolean xorg_composite_bind_state(struct exa_context *exa,
-                                  int op,
-                                  PicturePtr pSrcPicture,
-                                  PicturePtr pMaskPicture,
-                                  PicturePtr pDstPicture,
-                                  struct exa_pixmap_priv *pSrc,
-                                  struct exa_pixmap_priv *pMask,
-                                  struct exa_pixmap_priv *pDst)
-{
-   struct pipe_surface *dst_surf = xorg_gpu_surface(exa->pipe, pDst);
-
-   renderer_bind_destination(exa->renderer, dst_surf,
-                             pDst->width,
-                             pDst->height);
-
-   bind_blend_state(exa, op, pSrcPicture, pMaskPicture, pDstPicture);
-   bind_shaders(exa, op, pSrcPicture, pMaskPicture, pDstPicture, pSrc, pMask);
-   bind_samplers(exa, op, pSrcPicture, pMaskPicture,
-                 pDstPicture, pSrc, pMask, pDst);
-
-   setup_transforms(exa, pSrcPicture, pMaskPicture);
-
-   if (exa->num_bound_samplers == 0 ) { /* solid fill */
-      renderer_begin_solid(exa->renderer);
-   } else {
-      renderer_begin_textures(exa->renderer,
-                              exa->num_bound_samplers);
-   }
-
-
-   pipe_surface_reference(&dst_surf, NULL);
-   return TRUE;
-}
-
-void xorg_composite(struct exa_context *exa,
-                    struct exa_pixmap_priv *dst,
-                    int srcX, int srcY, int maskX, int maskY,
-                    int dstX, int dstY, int width, int height)
-{
-   if (exa->num_bound_samplers == 0 ) { /* solid fill */
-      renderer_solid(exa->renderer,
-                     dstX, dstY, dstX + width, dstY + height,
-                     exa->solid_color);
-   } else {
-      int pos[6] = {srcX, srcY, maskX, maskY, dstX, dstY};
-      float *src_matrix = NULL;
-      float *mask_matrix = NULL;
-
-      if (exa->transform.has_src)
-         src_matrix = exa->transform.src;
-      if (exa->transform.has_mask)
-         mask_matrix = exa->transform.mask;
-
-      renderer_texture(exa->renderer,
-                       pos, width, height,
-                       exa->bound_sampler_views,
-                       exa->num_bound_samplers,
-                       src_matrix, mask_matrix);
-   }
-}
-
-boolean xorg_solid_bind_state(struct exa_context *exa,
-                              struct exa_pixmap_priv *pixmap,
-                              Pixel fg)
-{
-   struct pipe_surface *dst_surf = xorg_gpu_surface(exa->pipe, pixmap);
-   unsigned vs_traits, fs_traits;
-   struct xorg_shader shader;
-
-   pixel_to_float4(fg, exa->solid_color, pixmap->tex->format);
-   exa->has_solid_color = TRUE;
-
-#if 0
-   debug_printf("Color Pixel=(%d, %d, %d, %d), RGBA=(%f, %f, %f, %f)\n",
-                (fg >> 24) & 0xff, (fg >> 16) & 0xff,
-                (fg >> 8) & 0xff,  (fg >> 0) & 0xff,
-                exa->solid_color[0], exa->solid_color[1],
-                exa->solid_color[2], exa->solid_color[3]);
-#endif
-
-   vs_traits = VS_SOLID_FILL;
-   fs_traits = FS_SOLID_FILL;
-
-   renderer_bind_destination(exa->renderer, dst_surf, 
-                             pixmap->width, pixmap->height);
-   bind_blend_state(exa, PictOpSrc, NULL, NULL, NULL);
-   cso_set_samplers(exa->renderer->cso, PIPE_SHADER_FRAGMENT, 0, NULL);
-   cso_set_sampler_views(exa->renderer->cso, PIPE_SHADER_FRAGMENT, 0, NULL);
-
-   shader = xorg_shaders_get(exa->renderer->shaders, vs_traits, fs_traits);
-   cso_set_vertex_shader_handle(exa->renderer->cso, shader.vs);
-   cso_set_fragment_shader_handle(exa->renderer->cso, shader.fs);
-
-   renderer_begin_solid(exa->renderer);
-
-   pipe_surface_reference(&dst_surf, NULL);
-   return TRUE;
-}
-
-void xorg_solid(struct exa_context *exa,
-                struct exa_pixmap_priv *pixmap,
-                int x0, int y0, int x1, int y1)
-{
-   renderer_solid(exa->renderer,
-                  x0, y0, x1, y1, exa->solid_color);
-}
-
-void
-xorg_composite_done(struct exa_context *exa)
-{
-   renderer_draw_flush(exa->renderer);
-
-   exa->transform.has_src = FALSE;
-   exa->transform.has_mask = FALSE;
-   exa->has_solid_color = FALSE;
-   exa->num_bound_samplers = 0;
-}
diff --git a/src/gallium/state_trackers/xorg/xorg_composite.h b/src/gallium/state_trackers/xorg/xorg_composite.h
deleted file mode 100644
index ec71ebf..0000000
--- a/src/gallium/state_trackers/xorg/xorg_composite.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef XORG_COMPOSITE_H
-#define XORG_COMPOSITE_H
-
-#include "xorg_exa.h"
-
-boolean xorg_composite_accelerated(int op,
-                                   PicturePtr pSrcPicture,
-                                   PicturePtr pMaskPicture,
-                                   PicturePtr pDstPicture);
-
-boolean xorg_composite_bind_state(struct exa_context *exa,
-                                  int op,
-                                  PicturePtr pSrcPicture,
-                                  PicturePtr pMaskPicture,
-                                  PicturePtr pDstPicture,
-                                  struct exa_pixmap_priv *pSrc,
-                                  struct exa_pixmap_priv *pMask,
-                                  struct exa_pixmap_priv *pDst);
-
-void xorg_composite(struct exa_context *exa,
-                    struct exa_pixmap_priv *dst,
-                    int srcX, int srcY, int maskX, int maskY,
-                    int dstX, int dstY, int width, int height);
-
-boolean xorg_solid_bind_state(struct exa_context *exa,
-                              struct exa_pixmap_priv *pixmap,
-                              Pixel fg);
-void xorg_solid(struct exa_context *exa,
-                struct exa_pixmap_priv *pixmap,
-                int x0, int y0, int x1, int y1);
-
-
-void
-xorg_composite_done(struct exa_context *exa);
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_crtc.c b/src/gallium/state_trackers/xorg/xorg_crtc.c
deleted file mode 100644
index 0ab41b4..0000000
--- a/src/gallium/state_trackers/xorg/xorg_crtc.c
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include <unistd.h>
-#include <string.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <math.h>
-#include <stdint.h>
-
-#include "xorg-server.h"
-#include <xf86.h>
-#include <xf86i2c.h>
-#include <xf86Crtc.h>
-#include <cursorstr.h>
-#include "xorg_tracker.h"
-#include "xf86Modes.h"
-
-#ifdef HAVE_XEXTPROTO_71
-#include <X11/extensions/dpmsconst.h>
-#else
-#define DPMS_SERVER
-#include <X11/extensions/dpms.h>
-#endif
-
-#include "state_tracker/drm_driver.h"
-#include "util/u_inlines.h"
-#include "util/u_rect.h"
-#include "util/u_surface.h"
-
-#ifdef HAVE_LIBKMS
-#include "libkms/libkms.h"
-#endif
-
-struct crtc_private
-{
-    drmModeCrtcPtr drm_crtc;
-
-    /* hwcursor */
-    struct pipe_resource *cursor_tex;
-    struct kms_bo *cursor_bo;
-
-    unsigned cursor_handle;
-};
-
-static void
-crtc_dpms(xf86CrtcPtr crtc, int mode)
-{
-    /* ScrnInfoPtr pScrn = crtc->scrn; */
-
-    switch (mode) {
-    case DPMSModeOn:
-    case DPMSModeStandby:
-    case DPMSModeSuspend:
-	break;
-    case DPMSModeOff:
-	break;
-    }
-}
-
-static Bool
-crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
-		    Rotation rotation, int x, int y)
-{
-    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    xf86OutputPtr output = NULL;
-    struct crtc_private *crtcp = crtc->driver_private;
-    drmModeCrtcPtr drm_crtc = crtcp->drm_crtc;
-    drmModeModeInfo drm_mode;
-    int i, ret;
-    unsigned int connector_id;
-
-    for (i = 0; i < config->num_output; output = NULL, i++) {
-	output = config->output[i];
-
-	if (output->crtc == crtc)
-	    break;
-    }
-
-    if (!output)
-	return FALSE;
-
-    connector_id = xorg_output_get_id(output);
-
-    drm_mode.clock = mode->Clock;
-    drm_mode.hdisplay = mode->HDisplay;
-    drm_mode.hsync_start = mode->HSyncStart;
-    drm_mode.hsync_end = mode->HSyncEnd;
-    drm_mode.htotal = mode->HTotal;
-    drm_mode.vdisplay = mode->VDisplay;
-    drm_mode.vsync_start = mode->VSyncStart;
-    drm_mode.vsync_end = mode->VSyncEnd;
-    drm_mode.vtotal = mode->VTotal;
-    drm_mode.flags = mode->Flags;
-    drm_mode.hskew = mode->HSkew;
-    drm_mode.vscan = mode->VScan;
-    drm_mode.vrefresh = mode->VRefresh;
-    drm_mode.type = 0;
-    if (!mode->name)
-	xf86SetModeDefaultName(mode);
-    strncpy(drm_mode.name, mode->name, DRM_DISPLAY_MODE_LEN - 1);
-    drm_mode.name[DRM_DISPLAY_MODE_LEN - 1] = '\0';
-
-    ret = drmModeSetCrtc(ms->fd, drm_crtc->crtc_id, ms->fb_id, x, y,
-			 &connector_id, 1, &drm_mode);
-
-    if (ret)
-	return FALSE;
-
-    /* Only set gamma when needed, to avoid unneeded delays. */
-#if defined(XF86_CRTC_VERSION) && XF86_CRTC_VERSION >= 3
-    if (!crtc->active && crtc->version >= 3)
-	crtc->funcs->gamma_set(crtc, crtc->gamma_red, crtc->gamma_green,
-			       crtc->gamma_blue, crtc->gamma_size);
-    crtc->active = TRUE;
-#endif
-
-    crtc->x = x;
-    crtc->y = y;
-    crtc->mode = *mode;
-    crtc->rotation = rotation;
-
-    return TRUE;
-}
-
-static void
-crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green, CARD16 * blue,
-	       int size)
-{
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    drmModeCrtcSetGamma(ms->fd, crtcp->drm_crtc->crtc_id, size, red, green, blue);
-}
-
-#if 0 /* Implement and enable to enable rotation and reflection. */
-static void *
-crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
-{
-    /* ScrnInfoPtr pScrn = crtc->scrn; */
-
-    return NULL;
-}
-
-static PixmapPtr
-crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
-{
-    /* ScrnInfoPtr pScrn = crtc->scrn; */
-
-    return NULL;
-}
-
-static void
-crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
-{
-    /* ScrnInfoPtr pScrn = crtc->scrn; */
-}
-
-#endif
-
-/*
- * Cursor functions
- */
-
-static void
-crtc_set_cursor_colors(xf86CrtcPtr crtc, int bg, int fg)
-{
-    /* XXX: See if this one is needed, as we only support ARGB cursors */
-}
-
-static void
-crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
-{
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    drmModeMoveCursor(ms->fd, crtcp->drm_crtc->crtc_id, x, y);
-}
-
-static void
-crtc_load_cursor_argb_ga3d(xf86CrtcPtr crtc, CARD32 * image)
-{
-    unsigned char *ptr;
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-    struct pipe_transfer *transfer;
-    struct pipe_fence_handle *fence = NULL;
-    struct pipe_context *ctx = ms->ctx;
-    struct pipe_screen *screen = ms->screen;
-
-    if (!crtcp->cursor_tex) {
-	struct pipe_resource templat;
-	struct winsys_handle whandle;
-
-	memset(&templat, 0, sizeof(templat));
-	templat.bind |= PIPE_BIND_RENDER_TARGET;
-	templat.bind |= PIPE_BIND_SCANOUT;
-	templat.bind |= PIPE_BIND_CURSOR;
-	templat.target = PIPE_TEXTURE_2D;
-	templat.last_level = 0;
-	templat.depth0 = 1;
-	templat.array_size = 1;
-	templat.format = PIPE_FORMAT_B8G8R8A8_UNORM;
-	templat.width0 = 64;
-	templat.height0 = 64;
-
-	memset(&whandle, 0, sizeof(whandle));
-	whandle.type = DRM_API_HANDLE_TYPE_KMS;
-
-	crtcp->cursor_tex = screen->resource_create(screen, &templat);
-	screen->resource_get_handle(screen, crtcp->cursor_tex, &whandle);
-
-	crtcp->cursor_handle = whandle.handle;
-    }
-
-    ptr = pipe_transfer_map(ctx, crtcp->cursor_tex,
-                            0, 0,
-                            PIPE_TRANSFER_WRITE,
-                            0, 0, 64, 64, &transfer);
-    util_copy_rect(ptr, crtcp->cursor_tex->format,
-		   transfer->stride, 0, 0,
-		   64, 64, (void*)image, 64 * 4, 0, 0);
-    ctx->transfer_unmap(ctx, transfer);
-    ctx->flush(ctx, &fence, 0);
-
-    if (fence) {
-	screen->fence_finish(screen, fence, PIPE_TIMEOUT_INFINITE);
-	screen->fence_reference(screen, &fence, NULL);
-    }
-
-    if (crtc->cursor_shown)
-	drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id,
-			 crtcp->cursor_handle, 64, 64);
-}
-
-#if HAVE_LIBKMS
-static void
-crtc_load_cursor_argb_kms(xf86CrtcPtr crtc, CARD32 * image)
-{
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-    unsigned char *ptr;
-
-    if (!crtcp->cursor_bo) {
-	unsigned attr[8];
-
-	attr[0] = KMS_BO_TYPE;
-#ifdef KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8
-	attr[1] = KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8;
-#else
-	attr[1] = KMS_BO_TYPE_CURSOR;
-#endif
-	attr[2] = KMS_WIDTH;
-	attr[3] = 64;
-	attr[4] = KMS_HEIGHT;
-	attr[5] = 64;
-	attr[6] = 0;
-
-        if (kms_bo_create(ms->kms, attr, &crtcp->cursor_bo))
-	   return;
-
-	if (kms_bo_get_prop(crtcp->cursor_bo, KMS_HANDLE,
-			    &crtcp->cursor_handle))
-	    goto err_bo_destroy;
-    }
-
-    kms_bo_map(crtcp->cursor_bo, (void**)&ptr);
-    memcpy(ptr, image, 64*64*4);
-    kms_bo_unmap(crtcp->cursor_bo);
-
-    if (crtc->cursor_shown)
-	drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id,
-			 crtcp->cursor_handle, 64, 64);
-
-    return;
-
-err_bo_destroy:
-    kms_bo_destroy(&crtcp->cursor_bo);
-}
-#endif
-
-static void
-crtc_load_cursor_argb(xf86CrtcPtr crtc, CARD32 * image)
-{
-    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-
-    /* Older X servers have cursor reference counting bugs leading to use of
-     * freed memory and consequently random crashes. Should be fixed as of
-     * xserver 1.8, but this workaround shouldn't hurt anyway.
-     */
-    if (config->cursor)
-       config->cursor->refcnt++;
-
-    if (ms->cursor)
-       FreeCursor(ms->cursor, None);
-
-    ms->cursor = config->cursor;
-
-    if (ms->screen)
-	crtc_load_cursor_argb_ga3d(crtc, image);
-#ifdef HAVE_LIBKMS
-    else if (ms->kms)
-	crtc_load_cursor_argb_kms(crtc, image);
-#endif
-}
-
-static void
-crtc_show_cursor(xf86CrtcPtr crtc)
-{
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    if (crtcp->cursor_tex || crtcp->cursor_bo)
-	drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id,
-			 crtcp->cursor_handle, 64, 64);
-}
-
-static void
-crtc_hide_cursor(xf86CrtcPtr crtc)
-{
-    modesettingPtr ms = modesettingPTR(crtc->scrn);
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    drmModeSetCursor(ms->fd, crtcp->drm_crtc->crtc_id, 0, 0, 0);
-}
-
-/**
- * Called at vt leave
- */
-void
-xorg_crtc_cursor_destroy(xf86CrtcPtr crtc)
-{
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    if (crtcp->cursor_tex)
-	pipe_resource_reference(&crtcp->cursor_tex, NULL);
-#ifdef HAVE_LIBKMS
-    if (crtcp->cursor_bo)
-	kms_bo_destroy(&crtcp->cursor_bo);
-#endif
-}
-
-/*
- * Misc functions
- */
-
-static void
-crtc_destroy(xf86CrtcPtr crtc)
-{
-    struct crtc_private *crtcp = crtc->driver_private;
-
-    xorg_crtc_cursor_destroy(crtc);
-
-    drmModeFreeCrtc(crtcp->drm_crtc);
-
-    free(crtcp);
-    crtc->driver_private = NULL;
-}
-
-static const xf86CrtcFuncsRec crtc_funcs = {
-    .dpms = crtc_dpms,
-    .set_mode_major = crtc_set_mode_major,
-
-    .set_cursor_colors = crtc_set_cursor_colors,
-    .set_cursor_position = crtc_set_cursor_position,
-    .show_cursor = crtc_show_cursor,
-    .hide_cursor = crtc_hide_cursor,
-    .load_cursor_argb = crtc_load_cursor_argb,
-
-    .shadow_create = NULL,
-    .shadow_allocate = NULL,
-    .shadow_destroy = NULL,
-
-    .gamma_set = crtc_gamma_set,
-    .destroy = crtc_destroy,
-};
-
-void
-xorg_crtc_init(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    xf86CrtcPtr crtc;
-    drmModeResPtr res;
-    drmModeCrtcPtr drm_crtc = NULL;
-    struct crtc_private *crtcp;
-    int c;
-
-    res = drmModeGetResources(ms->fd);
-    if (res == 0) {
-	ErrorF("Failed drmModeGetResources %d\n", errno);
-	return;
-    }
-
-    for (c = 0; c < res->count_crtcs; c++) {
-	drm_crtc = drmModeGetCrtc(ms->fd, res->crtcs[c]);
-
-	if (!drm_crtc)
-	    continue;
-
-	crtc = xf86CrtcCreate(pScrn, &crtc_funcs);
-	if (crtc == NULL)
-	    goto out;
-
-	crtcp = calloc(1, sizeof(struct crtc_private));
-	if (!crtcp) {
-	    xf86CrtcDestroy(crtc);
-	    goto out;
-	}
-
-	crtcp->drm_crtc = drm_crtc;
-
-	crtc->driver_private = crtcp;
-    }
-
-  out:
-    drmModeFreeResources(res);
-}
-
-/* vim: set sw=4 ts=8 sts=4: */
diff --git a/src/gallium/state_trackers/xorg/xorg_dri2.c b/src/gallium/state_trackers/xorg/xorg_dri2.c
deleted file mode 100644
index fb50ef8..0000000
--- a/src/gallium/state_trackers/xorg/xorg_dri2.c
+++ /dev/null
@@ -1,473 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include "xorg-server.h"
-#include "xf86.h"
-#include "xf86_OSproc.h"
-
-#include "xorg_tracker.h"
-#include "xorg_exa.h"
-
-#include "dri2.h"
-
-#include "pipe/p_state.h"
-#include "util/u_inlines.h"
-
-#include "util/u_format.h"
-
-#include "state_tracker/drm_driver.h"
-
-/* Make all the #if cases in the code esier to read */
-#ifndef DRI2INFOREC_VERSION
-#define DRI2INFOREC_VERSION 1
-#endif
-
-#if DRI2INFOREC_VERSION == 2
-static Bool set_format_in_do_create_buffer;
-#endif
-
-typedef struct {
-    PixmapPtr pPixmap;
-    struct pipe_resource *tex;
-    struct pipe_fence_handle *fence;
-} *BufferPrivatePtr;
-
-static Bool
-dri2_do_create_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer, unsigned int format)
-{
-    struct pipe_resource *tex = NULL;
-    ScreenPtr pScreen = pDraw->pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_pixmap_priv *exa_priv;
-    BufferPrivatePtr private = buffer->driverPrivate;
-    PixmapPtr pPixmap;
-    struct winsys_handle whandle;
-
-    if (pDraw->type == DRAWABLE_PIXMAP)
-	pPixmap = (PixmapPtr) pDraw;
-    else
-	pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr) pDraw);
-    exa_priv = exaGetPixmapDriverPrivate(pPixmap);
-
-
-    switch (buffer->attachment) {
-    default:
-	if (buffer->attachment != DRI2BufferFakeFrontLeft ||
-	    pDraw->type != DRAWABLE_PIXMAP) {
-	    private->pPixmap = (*pScreen->CreatePixmap)(pScreen, pDraw->width,
-							pDraw->height,
-							pDraw->depth,
-							0);
-	}
-	break;
-    case DRI2BufferFrontLeft:
-	break;
-    case DRI2BufferStencil:
-#if DRI2INFOREC_VERSION >= 3
-    case DRI2BufferDepthStencil:
-#else
-    /* Works on old X servers because sanity checking is for the weak */
-    case 9:
-#endif
-	if (exa_priv->depth_stencil_tex &&
-	    !util_format_is_depth_or_stencil(exa_priv->depth_stencil_tex->format))
-	    exa_priv->depth_stencil_tex = NULL;
-        /* Fall through */
-    case DRI2BufferDepth:
-	if (exa_priv->depth_stencil_tex)
-	    pipe_resource_reference(&tex, exa_priv->depth_stencil_tex);
-        else {
-	    struct pipe_resource template;
-            unsigned depthBits = (format != 0) ? format : pDraw->depth;
-	    memset(&template, 0, sizeof(template));
-	    template.target = PIPE_TEXTURE_2D;
-	    if (buffer->attachment == DRI2BufferDepth) {
-               switch(depthBits) {
-               case 16:
-                  template.format = PIPE_FORMAT_Z16_UNORM;
-                  break;
-               case 32:
-                  template.format = PIPE_FORMAT_Z32_UNORM;
-                  break;
-               default:
-                  template.format = ms->ds_depth_bits_last ?
-                                    PIPE_FORMAT_Z24X8_UNORM : PIPE_FORMAT_X8Z24_UNORM;
-                  break;
-               }
-            } else {
-               template.format = ms->ds_depth_bits_last ?
-                                 PIPE_FORMAT_Z24_UNORM_S8_UINT : PIPE_FORMAT_S8_UINT_Z24_UNORM;
-            }
-	    template.width0 = pDraw->width;
-	    template.height0 = pDraw->height;
-	    template.depth0 = 1;
-	    template.array_size = 1;
-	    template.last_level = 0;
-	    template.bind = PIPE_BIND_DEPTH_STENCIL |
-		PIPE_BIND_SHARED;
-	    tex = ms->screen->resource_create(ms->screen, &template);
-	    pipe_resource_reference(&exa_priv->depth_stencil_tex, tex);
-	}
-	break;
-    }
-
-    if (!private->pPixmap) {
-	private->pPixmap = pPixmap;
-	pPixmap->refcnt++;
-    }
-
-    if (!tex) {
-	/* First call to make sure we have a pixmap private */
-	exaMoveInPixmap(private->pPixmap);
-	xorg_exa_set_shared_usage(private->pPixmap);
-	pScreen->ModifyPixmapHeader(private->pPixmap, 0, 0, 0, 0, 0, NULL);
-	/* Second call to make sure texture has valid contents */
-	exaMoveInPixmap(private->pPixmap);
-	tex = xorg_exa_get_texture(private->pPixmap);
-    }
-
-    if (!tex)
-	FatalError("NO TEXTURE IN DRI2\n");
-
-    memset(&whandle, 0, sizeof(whandle));
-    whandle.type = DRM_API_HANDLE_TYPE_SHARED;
-
-    ms->screen->resource_get_handle(ms->screen, tex, &whandle);
-
-    buffer->name = whandle.handle;
-    buffer->pitch = whandle.stride;
-    buffer->cpp = 4;
-    buffer->driverPrivate = private;
-    buffer->flags = 0; /* not tiled */
-#if DRI2INFOREC_VERSION == 2
-    /* ABI forwards/backwards compatibility */
-    if (set_format_in_do_create_buffer)
-	((DRI2Buffer2Ptr)buffer)->format = 0;
-#elif DRI2INFOREC_VERSION >= 3
-    buffer->format = 0;
-#endif
-    private->tex = tex;
-
-    return TRUE;
-}
-
-static void
-dri2_do_destroy_buffer(DrawablePtr pDraw, DRI2BufferPtr buffer)
-{
-    ScreenPtr pScreen = pDraw->pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    BufferPrivatePtr private = buffer->driverPrivate;
-    struct exa_pixmap_priv *exa_priv = exaGetPixmapDriverPrivate(private->pPixmap);
-
-    pipe_resource_reference(&private->tex, NULL);
-    ms->screen->fence_reference(ms->screen, &private->fence, NULL);
-    pipe_resource_reference(&exa_priv->depth_stencil_tex, NULL);
-    (*pScreen->DestroyPixmap)(private->pPixmap);
-}
-
-#if DRI2INFOREC_VERSION >= 2
-
-static DRI2Buffer2Ptr
-dri2_create_buffer(DrawablePtr pDraw, unsigned int attachment, unsigned int format)
-{
-    DRI2Buffer2Ptr buffer;
-    BufferPrivatePtr private;
-
-    buffer = calloc(1, sizeof *buffer);
-    if (!buffer)
-	return NULL;
-
-    private = calloc(1, sizeof *private);
-    if (!private) {
-	goto fail;
-    }
-
-    buffer->attachment = attachment;
-    buffer->driverPrivate = private;
-
-    /* So far it is safe to downcast a DRI2Buffer2Ptr to DRI2BufferPtr */
-    if (dri2_do_create_buffer(pDraw, (DRI2BufferPtr)buffer, format))
-	return buffer;
-
-    free(private);
-fail:
-    free(buffer);
-    return NULL;
-}
-
-static void
-dri2_destroy_buffer(DrawablePtr pDraw, DRI2Buffer2Ptr buffer)
-{
-    /* So far it is safe to downcast a DRI2Buffer2Ptr to DRI2BufferPtr */
-    dri2_do_destroy_buffer(pDraw, (DRI2BufferPtr)buffer);
-
-    free(buffer->driverPrivate);
-    free(buffer);
-}
-
-#endif /* DRI2INFOREC_VERSION >= 2 */
-
-#if DRI2INFOREC_VERSION <= 2
-
-static DRI2BufferPtr
-dri2_create_buffers(DrawablePtr pDraw, unsigned int *attachments, int count)
-{
-    BufferPrivatePtr privates;
-    DRI2BufferPtr buffers;
-    int i;
-
-    buffers = calloc(count, sizeof *buffers);
-    if (!buffers)
-	goto fail_buffers;
-
-    privates = calloc(count, sizeof *privates);
-    if (!privates)
-	goto fail_privates;
-
-    for (i = 0; i < count; i++) {
-	buffers[i].attachment = attachments[i];
-	buffers[i].driverPrivate = &privates[i];
-
-	if (!dri2_do_create_buffer(pDraw, &buffers[i], 0))
-	    goto fail;
-    }
-
-    return buffers;
-
-fail:
-    free(privates);
-fail_privates:
-    free(buffers);
-fail_buffers:
-    return NULL;
-}
-
-static void
-dri2_destroy_buffers(DrawablePtr pDraw, DRI2BufferPtr buffers, int count)
-{
-    int i;
-
-    for (i = 0; i < count; i++) {
-	dri2_do_destroy_buffer(pDraw, &buffers[i]);
-    }
-
-    if (buffers) {
-	free(buffers[0].driverPrivate);
-	free(buffers);
-    }
-}
-
-#endif /* DRI2INFOREC_VERSION <= 2 */
-
-static void
-dri2_copy_region(DrawablePtr pDraw, RegionPtr pRegion,
-                 DRI2BufferPtr pDestBuffer, DRI2BufferPtr pSrcBuffer)
-{
-    ScreenPtr pScreen = pDraw->pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    BufferPrivatePtr dst_priv = pDestBuffer->driverPrivate;
-    BufferPrivatePtr src_priv = pSrcBuffer->driverPrivate;
-    DrawablePtr src_draw;
-    DrawablePtr dst_draw;
-    GCPtr gc;
-    RegionPtr copy_clip;
-    Bool save_accel;
-    CustomizerPtr cust = ms->cust;
-
-    /*
-     * In driCreateBuffers we dewrap windows into the
-     * backing pixmaps in order to get to the texture.
-     * We need to use the real drawable in CopyArea
-     * so that cliprects and offsets are correct.
-     */
-    src_draw = (pSrcBuffer->attachment == DRI2BufferFrontLeft) ? pDraw :
-       &src_priv->pPixmap->drawable;
-    dst_draw = (pDestBuffer->attachment == DRI2BufferFrontLeft) ? pDraw :
-       &dst_priv->pPixmap->drawable;
-
-    /*
-     * The clients implements glXWaitX with a copy front to fake and then
-     * waiting on the server to signal its completion of it. While
-     * glXWaitGL is a client side flush and a copy from fake to front.
-     * This is how it is done in the DRI2 protocol, how ever depending
-     * which type of drawables the server does things a bit differently
-     * then what the protocol says as the fake and front are the same.
-     *
-     * for pixmaps glXWaitX is a server flush.
-     * for pixmaps glXWaitGL is a client flush.
-     * for windows glXWaitX is a copy from front to fake then a server flush.
-     * for windows glXWaitGL is a client flush then a copy from fake to front.
-     *
-     * XXX in the windows case this code always flushes but that isn't a
-     * must in the glXWaitGL case but we don't know if this is a glXWaitGL
-     * or a glFlush/glFinish call.
-     */
-    if (dst_priv->pPixmap == src_priv->pPixmap) {
-	/* pixmap glXWaitX */
-	if (pSrcBuffer->attachment == DRI2BufferFrontLeft &&
-	    pDestBuffer->attachment == DRI2BufferFakeFrontLeft) {
-	    ms->ctx->flush(ms->ctx, NULL, 0);
-	    return;
-	}
-	/* pixmap glXWaitGL */
-	if (pDestBuffer->attachment == DRI2BufferFrontLeft &&
-	    pSrcBuffer->attachment == DRI2BufferFakeFrontLeft) {
-	    return;
-	} else {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		"copying between the same pixmap\n");
-	}
-    }
-
-    gc = GetScratchGC(pDraw->depth, pScreen);
-    copy_clip = REGION_CREATE(pScreen, NULL, 0);
-    REGION_COPY(pScreen, copy_clip, pRegion);
-    (*gc->funcs->ChangeClip) (gc, CT_REGION, copy_clip, 0);
-    ValidateGC(dst_draw, gc);
-
-    /* If this is a full buffer swap, throttle on the previous one */
-    if (ms->swapThrottling &&
-	dst_priv->fence && REGION_NUM_RECTS(pRegion) == 1) {
-	BoxPtr extents = REGION_EXTENTS(pScreen, pRegion);
-
-	if (extents->x1 == 0 && extents->y1 == 0 &&
-	    extents->x2 == pDraw->width && extents->y2 == pDraw->height) {
-            ms->screen->fence_finish(ms->screen, dst_priv->fence,
-                                     PIPE_TIMEOUT_INFINITE);
-	    ms->screen->fence_reference(ms->screen, &dst_priv->fence, NULL);
-	}
-    }
-
-    /* Try to make sure the blit will be accelerated */
-    save_accel = ms->exa->accel;
-    ms->exa->accel = TRUE;
-
-    if (pSrcBuffer->attachment != DRI2BufferFrontLeft) {
-	/* In case it won't be though, make sure the GPU copy contents of the
-	 * source pixmap will be used for the software fallback - presumably the
-	 * client modified them before calling in here.
-	 */
-	exaMoveInPixmap(src_priv->pPixmap);
-	DamageRegionAppend(src_draw, pRegion);
-	DamageRegionProcessPending(src_draw);
-    }
-
-   if (cust && cust->winsys_context_throttle)
-       cust->winsys_context_throttle(cust, ms->ctx, THROTTLE_SWAP);
-
-    (*gc->ops->CopyArea)(src_draw, dst_draw, gc,
-			 0, 0, pDraw->width, pDraw->height, 0, 0);
-    ms->exa->accel = save_accel;
-
-    FreeScratchGC(gc);
-
-    ms->ctx->flush(ms->ctx,
-		   (pDestBuffer->attachment == DRI2BufferFrontLeft
-		    && ms->swapThrottling) ?
-		   &dst_priv->fence : NULL, 0);
-
-   if (cust && cust->winsys_context_throttle)
-       cust->winsys_context_throttle(cust, ms->ctx, THROTTLE_RENDER);
-
-}
-
-Bool
-xorg_dri2_init(ScreenPtr pScreen)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    DRI2InfoRec dri2info;
-#if DRI2INFOREC_VERSION >= 2
-    int major, minor;
-
-    if (xf86LoaderCheckSymbol("DRI2Version")) {
-	DRI2Version(&major, &minor);
-    } else {
-	/* Assume version 1.0 */
-	major = 1;
-	minor = 0;
-    }
-#endif
-
-    dri2info.version = min(DRI2INFOREC_VERSION, 3);
-    dri2info.fd = ms->fd;
-
-    dri2info.driverName = pScrn->driverName;
-    dri2info.deviceName = "/dev/dri/card0"; /* FIXME */
-
-#if DRI2INFOREC_VERSION >= 2
-    dri2info.CreateBuffer = dri2_create_buffer;
-    dri2info.DestroyBuffer = dri2_destroy_buffer;
-#endif
-
-    /* For X servers in the 1.6.x series there where two DRI2 version.
-     * This allows us to build one binary that works on both servers.
-     */
-#if DRI2INFOREC_VERSION == 2
-    if (minor == 0) {
-	set_format_in_do_create_buffer = FALSE;
-	dri2info.CreateBuffers = dri2_create_buffers;
-	dri2info.DestroyBuffers = dri2_destroy_buffers;
-    } else
-	set_format_in_do_create_buffer = FALSE;
-#endif
-
-    /* For version 1 set these unconditionaly. */
-#if DRI2INFOREC_VERSION == 1
-    dri2info.CreateBuffers = dri2_create_buffers;
-    dri2info.DestroyBuffers = dri2_destroy_buffers;
-#endif
-    dri2info.CopyRegion = dri2_copy_region;
-    dri2info.Wait = NULL;
-
-    ms->d_depth_bits_last =
-	 ms->screen->is_format_supported(ms->screen, PIPE_FORMAT_Z24X8_UNORM,
-					 PIPE_TEXTURE_2D,
-					 0,
-                                         PIPE_BIND_DEPTH_STENCIL);
-    ms->ds_depth_bits_last =
-	 ms->screen->is_format_supported(ms->screen, PIPE_FORMAT_Z24_UNORM_S8_UINT,
-					 PIPE_TEXTURE_2D,
-					 0,
-                                         PIPE_BIND_DEPTH_STENCIL);
-
-    return DRI2ScreenInit(pScreen, &dri2info);
-}
-
-void
-xorg_dri2_close(ScreenPtr pScreen)
-{
-    DRI2CloseScreen(pScreen);
-}
-
-/* vim: set sw=4 ts=8 sts=4: */
diff --git a/src/gallium/state_trackers/xorg/xorg_driver.c b/src/gallium/state_trackers/xorg/xorg_driver.c
deleted file mode 100644
index 097c354..0000000
--- a/src/gallium/state_trackers/xorg/xorg_driver.c
+++ /dev/null
@@ -1,1319 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-
-#include "xorg-server.h"
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#include "compiler.h"
-#include "xf86Pci.h"
-#include "mipointer.h"
-#include "micmap.h"
-#include <X11/extensions/randr.h>
-#include "fb.h"
-#include "edid.h"
-#include "xf86i2c.h"
-#include "xf86Crtc.h"
-#include "miscstruct.h"
-#include "dixstruct.h"
-#include "xf86cmap.h"
-#include "xf86xv.h"
-#include "xorgVersion.h"
-#ifndef XSERVER_LIBPCIACCESS
-#error "libpciaccess needed"
-#endif
-
-#include <pciaccess.h>
-
-#include "state_tracker/drm_driver.h"
-#include "pipe/p_context.h"
-#include "xorg_tracker.h"
-#include "xorg_winsys.h"
-
-#ifdef HAVE_LIBKMS
-#include "libkms/libkms.h"
-#endif
-
-/*
- * Functions and symbols exported to Xorg via pointers.
- */
-
-static Bool drv_pre_init(ScrnInfoPtr pScrn, int flags);
-static Bool drv_screen_init(SCREEN_INIT_ARGS_DECL);
-static Bool drv_switch_mode(SWITCH_MODE_ARGS_DECL);
-static void drv_adjust_frame(ADJUST_FRAME_ARGS_DECL);
-static Bool drv_enter_vt(VT_FUNC_ARGS_DECL);
-static Bool drv_enter_vt_flags(ScrnInfoPtr pScrn, int flags);
-static void drv_leave_vt(VT_FUNC_ARGS_DECL);
-static void drv_free_screen(FREE_SCREEN_ARGS_DECL);
-static ModeStatus drv_valid_mode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose,
-			         int flags);
-
-typedef enum
-{
-    OPTION_SW_CURSOR,
-    OPTION_2D_ACCEL,
-    OPTION_DEBUG_FALLBACK,
-    OPTION_THROTTLE_SWAP,
-    OPTION_THROTTLE_DIRTY,
-    OPTION_3D_ACCEL
-} drv_option_enums;
-
-static const OptionInfoRec drv_options[] = {
-    {OPTION_SW_CURSOR, "SWcursor", OPTV_BOOLEAN, {0}, FALSE},
-    {OPTION_2D_ACCEL, "2DAccel", OPTV_BOOLEAN, {0}, FALSE},
-    {OPTION_DEBUG_FALLBACK, "DebugFallback", OPTV_BOOLEAN, {0}, FALSE},
-    {OPTION_THROTTLE_SWAP, "SwapThrottling", OPTV_BOOLEAN, {0}, FALSE},
-    {OPTION_THROTTLE_DIRTY, "DirtyThrottling", OPTV_BOOLEAN, {0}, FALSE},
-    {OPTION_3D_ACCEL, "3DAccel", OPTV_BOOLEAN, {0}, FALSE},
-    {-1, NULL, OPTV_NONE, {0}, FALSE}
-};
-
-
-/*
- * Exported Xorg driver functions to winsys
- */
-
-const OptionInfoRec *
-xorg_tracker_available_options(int chipid, int busid)
-{
-    return drv_options;
-}
-
-void
-xorg_tracker_set_functions(ScrnInfoPtr scrn)
-{
-    scrn->PreInit = drv_pre_init;
-    scrn->ScreenInit = drv_screen_init;
-    scrn->SwitchMode = drv_switch_mode;
-    scrn->AdjustFrame = drv_adjust_frame;
-    scrn->EnterVT = drv_enter_vt;
-    scrn->LeaveVT = drv_leave_vt;
-    scrn->FreeScreen = drv_free_screen;
-    scrn->ValidMode = drv_valid_mode;
-}
-
-Bool
-xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device)
-{
-    char *BusID = malloc(64);
-
-    if (!BusID)
-	return FALSE;
-    sprintf(BusID, "pci:%04x:%02x:%02x.%d",
-	    device->domain, device->bus,
-	    device->dev, device->func);
-
-    if (drmCheckModesettingSupported(BusID)) {
-	xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
-		       "Drm modesetting not supported %s\n", BusID);
-	free(BusID);
-	return FALSE;
-    }
-
-    xf86DrvMsgVerb(pScrn->scrnIndex, X_INFO, 0,
-		   "Drm modesetting supported on %s\n", BusID);
-
-    free(BusID);
-    return TRUE;
-}
-
-
-/*
- * Internal function definitions
- */
-
-static Bool drv_init_front_buffer_functions(ScrnInfoPtr pScrn);
-static Bool drv_close_screen(CLOSE_SCREEN_ARGS_DECL);
-
-
-/*
- * Internal functions
- */
-
-static Bool
-drv_get_rec(ScrnInfoPtr pScrn)
-{
-    if (pScrn->driverPrivate)
-	return TRUE;
-
-    pScrn->driverPrivate = xnfcalloc(1, sizeof(modesettingRec));
-
-    return TRUE;
-}
-
-static void
-drv_free_rec(ScrnInfoPtr pScrn)
-{
-    if (!pScrn)
-	return;
-
-    if (!pScrn->driverPrivate)
-	return;
-
-    free(pScrn->driverPrivate);
-
-    pScrn->driverPrivate = NULL;
-}
-
-static void
-drv_probe_ddc(ScrnInfoPtr pScrn, int index)
-{
-    ConfiguredMonitor = NULL;
-}
-
-static Bool
-drv_crtc_resize(ScrnInfoPtr pScrn, int width, int height)
-{
-    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    CustomizerPtr cust = ms->cust;
-    ScreenPtr pScreen = pScrn->pScreen;
-    int old_width, old_height;
-    PixmapPtr rootPixmap;
-    int i;
-
-    if (width == pScrn->virtualX && height == pScrn->virtualY)
-	return TRUE;
-
-    if (cust && cust->winsys_check_fb_size &&
-	!cust->winsys_check_fb_size(cust, width*pScrn->bitsPerPixel / 8,
-				    height)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "Requested framebuffer size %dx%dx%d will not fit "
-		   "in display memory.\n",
-		   width, height, pScrn->bitsPerPixel);
-	return FALSE;
-    }
-
-    old_width = pScrn->virtualX;
-    old_height = pScrn->virtualY;
-    pScrn->virtualX = width;
-    pScrn->virtualY = height;
-
-    /* ms->create_front_buffer will remove the old front buffer */
-
-    rootPixmap = pScreen->GetScreenPixmap(pScreen);
-    if (!pScreen->ModifyPixmapHeader(rootPixmap, width, height, -1, -1, -1, NULL))
-	goto error_modify;
-
-    pScrn->displayWidth = rootPixmap->devKind / (rootPixmap->drawable.bitsPerPixel / 8);
-
-    if (!ms->create_front_buffer(pScrn) || !ms->bind_front_buffer(pScrn))
-	goto error_create;
-
-    /*
-     * create && bind will turn off all crtc(s) in the kernel so we need to
-     * re-enable all the crtcs again. For real HW we might want to do this
-     * before destroying the old framebuffer.
-     */
-    for (i = 0; i < xf86_config->num_crtc; i++) {
-	xf86CrtcPtr crtc = xf86_config->crtc[i];
-
-	if (!crtc->enabled)
-	    continue;
-
-	crtc->funcs->set_mode_major(crtc, &crtc->mode, crtc->rotation, crtc->x, crtc->y);
-    }
-
-    return TRUE;
-
-    /*
-     * This is the error recovery path.
-     */
-error_create:
-    if (!pScreen->ModifyPixmapHeader(rootPixmap, old_width, old_height, -1, -1, -1, NULL))
-	FatalError("failed to resize rootPixmap error path\n");
-
-    pScrn->displayWidth = rootPixmap->devKind / (rootPixmap->drawable.bitsPerPixel / 8);
-
-error_modify:
-    pScrn->virtualX = old_width;
-    pScrn->virtualY = old_height;
-
-    if (ms->create_front_buffer(pScrn) && ms->bind_front_buffer(pScrn))
-	return FALSE;
-
-    FatalError("failed to setup old framebuffer\n");
-    return FALSE;
-}
-
-static const xf86CrtcConfigFuncsRec crtc_config_funcs = {
-    .resize = drv_crtc_resize
-};
-
-static Bool
-drv_init_drm(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-
-    /* deal with server regeneration */
-    if (ms->fd < 0) {
-	char *BusID;
-
-	BusID = malloc(64);
-	if (!BusID)
-	    return FALSE;
-
-	sprintf(BusID, "PCI:%d:%d:%d",
-		((ms->PciInfo->domain << 8) | ms->PciInfo->bus),
-		ms->PciInfo->dev, ms->PciInfo->func
-	    );
-
-
-	ms->fd = drmOpen(driver_descriptor.driver_name, BusID);
-	ms->isMaster = TRUE;
-	free(BusID);
-
-	if (ms->fd >= 0)
-	    return TRUE;
-
-	return FALSE;
-    }
-
-    return TRUE;
-}
-
-static Bool
-drv_init_resource_management(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    /*
-    ScreenPtr pScreen = pScrn->pScreen;
-    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
-    Bool fbAccessDisabled;
-    CARD8 *fbstart;
-     */
-
-    if (ms->screen || ms->kms)
-	return TRUE;
-
-    if (!ms->no3D)
-	ms->screen = driver_descriptor.create_screen(ms->fd);
-
-    if (ms->screen)
-	return TRUE;
-
-#ifdef HAVE_LIBKMS
-    if (!kms_create(ms->fd, &ms->kms))
-	return TRUE;
-#endif
-
-    return FALSE;
-}
-
-static void
-drv_cleanup_fences(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    int i;
-
-    assert(ms->screen);
-
-    for (i = 0; i < XORG_NR_FENCES; i++) {
-	if (ms->fence[i]) {
-            ms->screen->fence_finish(ms->screen, ms->fence[i],
-                                     PIPE_TIMEOUT_INFINITE);
-	    ms->screen->fence_reference(ms->screen, &ms->fence[i], NULL);
-	}
-    }
-}
-
-static Bool
-drv_pre_init(ScrnInfoPtr pScrn, int flags)
-{
-    xf86CrtcConfigPtr xf86_config;
-    modesettingPtr ms;
-    rgb defaultWeight = { 0, 0, 0 };
-    EntityInfoPtr pEnt;
-    EntPtr msEnt = NULL;
-    CustomizerPtr cust;
-    Bool use3D;
-
-    if (pScrn->numEntities != 1)
-	return FALSE;
-
-    pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
-
-    if (flags & PROBE_DETECT) {
-	drv_probe_ddc(pScrn, pEnt->index);
-	return TRUE;
-    }
-
-    cust = (CustomizerPtr) pScrn->driverPrivate;
-    pScrn->driverPrivate = NULL;
-
-    /* Allocate driverPrivate */
-    if (!drv_get_rec(pScrn))
-	return FALSE;
-
-    ms = modesettingPTR(pScrn);
-    ms->pEnt = pEnt;
-    ms->cust = cust;
-    ms->fb_id = -1;
-
-    pScrn->displayWidth = 640;	       /* default it */
-
-    if (ms->pEnt->location.type != BUS_PCI)
-	return FALSE;
-
-    ms->PciInfo = xf86GetPciInfoForEntity(ms->pEnt->index);
-
-    /* Allocate an entity private if necessary */
-    if (xf86IsEntityShared(pScrn->entityList[0])) {
-	FatalError("Entity");
-#if 0
-	msEnt = xf86GetEntityPrivate(pScrn->entityList[0],
-				     modesettingEntityIndex)->ptr;
-	ms->entityPrivate = msEnt;
-#else
-	(void)msEnt;
-#endif
-    } else
-	ms->entityPrivate = NULL;
-
-    if (xf86IsEntityShared(pScrn->entityList[0])) {
-	if (xf86IsPrimInitDone(pScrn->entityList[0])) {
-	    /* do something */
-	} else {
-	    xf86SetPrimInitDone(pScrn->entityList[0]);
-	}
-    }
-
-    ms->fd = -1;
-    if (!drv_init_drm(pScrn))
-	return FALSE;
-
-    pScrn->monitor = pScrn->confScreen->monitor;
-    pScrn->progClock = TRUE;
-    pScrn->rgbBits = 8;
-
-    if (!xf86SetDepthBpp
-	(pScrn, 0, 0, 0,
-	 PreferConvert24to32 | SupportConvert24to32 | Support32bppFb))
-	return FALSE;
-
-    switch (pScrn->depth) {
-    case 8:
-    case 15:
-    case 16:
-    case 24:
-	break;
-    default:
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "Given depth (%d) is not supported by the driver\n",
-		   pScrn->depth);
-	return FALSE;
-    }
-    xf86PrintDepthBpp(pScrn);
-
-    if (!xf86SetWeight(pScrn, defaultWeight, defaultWeight))
-	return FALSE;
-    if (!xf86SetDefaultVisual(pScrn, -1))
-	return FALSE;
-
-    /* Process the options */
-    xf86CollectOptions(pScrn, NULL);
-    if (!(ms->Options = malloc(sizeof(drv_options))))
-	return FALSE;
-    memcpy(ms->Options, drv_options, sizeof(drv_options));
-    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, ms->Options);
-
-    use3D = cust ? !cust->no_3d : TRUE;
-    ms->from_3D = xf86GetOptValBool(ms->Options, OPTION_3D_ACCEL,
-				    &use3D) ?
-	X_CONFIG : X_PROBED;
-
-    ms->no3D = !use3D;
-
-    if (!drv_init_resource_management(pScrn)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not init "
-					       "Gallium3D or libKMS.\n");
-	return FALSE;
-    }
-
-    /* Allocate an xf86CrtcConfig */
-    xf86CrtcConfigInit(pScrn, &crtc_config_funcs);
-    xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-
-    /* get max width and height */
-    {
-	drmModeResPtr res;
-	int max_width, max_height;
-
-	res = drmModeGetResources(ms->fd);
-	max_width = res->max_width;
-	max_height = res->max_height;
-
-	if (ms->screen) {
-	    int max;
-
-	    max = ms->screen->get_param(ms->screen,
-					PIPE_CAP_MAX_TEXTURE_2D_LEVELS);
-	    max = 1 << (max - 1);
-	    max_width = max < max_width ? max : max_width;
-	    max_height = max < max_height ? max : max_height;
-	}
-
-	xf86CrtcSetSizeRange(pScrn, res->min_width,
-			     res->min_height, max_width, max_height);
-	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		   "Min width %d, Max Width %d.\n",
-		   res->min_width, max_width);
-	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-		   "Min height %d, Max Height %d.\n",
-		   res->min_height, max_height);
-	drmModeFreeResources(res);
-    }
-
-
-    if (xf86ReturnOptValBool(ms->Options, OPTION_SW_CURSOR, FALSE)) {
-	ms->SWCursor = TRUE;
-    }
-
-    xorg_crtc_init(pScrn);
-    xorg_output_init(pScrn);
-
-    if (cust && cust->winsys_pre_init && !cust->winsys_pre_init(cust, ms->fd))
-	return FALSE;
-
-    if (!xf86InitialConfiguration(pScrn, TRUE)) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No valid modes.\n");
-	return FALSE;
-    }
-
-    /*
-     * If the driver can do gamma correction, it should call xf86SetGamma() here.
-     */
-    {
-	Gamma zeros = { 0.0, 0.0, 0.0 };
-
-	if (!xf86SetGamma(pScrn, zeros)) {
-	    return FALSE;
-	}
-    }
-
-    if (pScrn->modes == NULL) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No modes.\n");
-	return FALSE;
-    }
-
-    pScrn->currentMode = pScrn->modes;
-
-    /* Set display resolution */
-    xf86SetDpi(pScrn, 0, 0);
-
-    /* Load the required sub modules */
-    if (!xf86LoadSubModule(pScrn, "fb"))
-	return FALSE;
-
-    /* XXX: these aren't needed when we are using libkms */
-    if (!xf86LoadSubModule(pScrn, "exa"))
-	return FALSE;
-
-#ifdef DRI2
-    if (!xf86LoadSubModule(pScrn, "dri2"))
-	return FALSE;
-#endif
-
-    return TRUE;
-}
-
-void xorg_flush(ScreenPtr pScreen)
-{
-    modesettingPtr ms = modesettingPTR(xf86ScreenToScrn(pScreen));
-
-    if (ms->ctx) {
-	int j;
-
-	ms->ctx->flush(ms->ctx,
-		       ms->dirtyThrottling ?
-		       &ms->fence[XORG_NR_FENCES-1] :
-		       NULL, 0);
-       
-	if (ms->dirtyThrottling) {
-	    if (ms->fence[0])
-		ms->ctx->screen->fence_finish(ms->ctx->screen,
-                                              ms->fence[0],
-                                              PIPE_TIMEOUT_INFINITE);
-  
-	    /* The amount of rendering generated by a block handler can be
-	     * quite small.  Let us get a fair way ahead of hardware before
-	     * throttling.
-	     */
-	    for (j = 0; j < XORG_NR_FENCES - 1; j++)
-		ms->screen->fence_reference(ms->screen,
-					    &ms->fence[j],
-					    ms->fence[j+1]);
-
-	    ms->screen->fence_reference(ms->screen,
-					&ms->fence[XORG_NR_FENCES-1],
-					NULL);
-	}
-    }
-
-#ifdef DRM_MODE_FEATURE_DIRTYFB
-    {
-	RegionPtr dirty = DamageRegion(ms->damage);
-	unsigned num_cliprects = REGION_NUM_RECTS(dirty);
-
-	if (num_cliprects) {
-	    drmModeClip *clip = alloca(num_cliprects * sizeof(drmModeClip));
-	    BoxPtr rect = REGION_RECTS(dirty);
-	    int i, ret;
-
-	    /* XXX no need for copy? */
-	    for (i = 0; i < num_cliprects; i++, rect++) {
-		clip[i].x1 = rect->x1;
-		clip[i].y1 = rect->y1;
-		clip[i].x2 = rect->x2;
-		clip[i].y2 = rect->y2;
-	    }
-
-	    /* TODO query connector property to see if this is needed */
-	    ret = drmModeDirtyFB(ms->fd, ms->fb_id, clip, num_cliprects);
-	    if (ret) {
-		debug_printf("%s: failed to send dirty (%i, %s)\n",
-			     __func__, ret, strerror(-ret));
-	    }
-
-	    DamageEmpty(ms->damage);
-	}
-    }
-#endif
-}
-
-static void drv_block_handler(BLOCKHANDLER_ARGS_DECL)
-{
-    SCREEN_PTR(arg);
-    modesettingPtr ms = modesettingPTR(xf86ScreenToScrn(pScreen));
-
-    pScreen->BlockHandler = ms->blockHandler;
-    pScreen->BlockHandler(BLOCKHANDLER_ARGS);
-    pScreen->BlockHandler = drv_block_handler;
-
-    xorg_flush(pScreen);
-}
-
-static Bool
-drv_create_screen_resources(ScreenPtr pScreen)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    PixmapPtr rootPixmap;
-    Bool ret;
-
-    ms->noEvict = TRUE;
-
-    pScreen->CreateScreenResources = ms->createScreenResources;
-    ret = pScreen->CreateScreenResources(pScreen);
-    pScreen->CreateScreenResources = drv_create_screen_resources;
-
-    ms->bind_front_buffer(pScrn);
-
-    ms->noEvict = FALSE;
-
-    drv_adjust_frame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
-
-#ifdef DRM_MODE_FEATURE_DIRTYFB
-    rootPixmap = pScreen->GetScreenPixmap(pScreen);
-    ms->damage = DamageCreate(NULL, NULL, DamageReportNone, TRUE,
-                              pScreen, rootPixmap);
-
-    if (ms->damage) {
-       DamageRegister(&rootPixmap->drawable, ms->damage);
-
-       xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Damage tracking initialized\n");
-    } else {
-       xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                  "Failed to create screen damage record\n");
-       return FALSE;
-    }
-#else
-    (void)rootPixmap;
-#endif
-
-    return ret;
-}
-
-static Bool
-drv_set_master(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-
-    if (!ms->isMaster && drmSetMaster(ms->fd) != 0) {
-	if (errno == EINVAL) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		       "drmSetMaster failed: 2.6.29 or newer kernel required for "
-		       "multi-server DRI\n");
-	} else {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		       "drmSetMaster failed: %s\n", strerror(errno));
-	}
-	return FALSE;
-    }
-
-    ms->isMaster = TRUE;
-    return TRUE;
-}
-
-
-static void drv_load_palette(ScrnInfoPtr pScrn, int numColors,
-			     int *indices, LOCO *colors, VisualPtr pVisual)
-{
-    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    int index, j, i;
-    int c;
-
-    switch(pScrn->depth) {
-    case 15:
-	for (i = 0; i < numColors; i++) {
-	    index = indices[i];
-	    for (j = 0; j < 8; j++) {
-		ms->lut_r[index * 8 + j] = colors[index].red << 8;
-		ms->lut_g[index * 8 + j] = colors[index].green << 8;
-		ms->lut_b[index * 8 + j] = colors[index].blue << 8;
-	    }
-	}
-	break;
-    case 16:
-	for (i = 0; i < numColors; i++) {
-	    index = indices[i];
-
-	    if (index < 32) {
-		for (j = 0; j < 8; j++) {
-		    ms->lut_r[index * 8 + j] = colors[index].red << 8;
-		    ms->lut_b[index * 8 + j] = colors[index].blue << 8;
-		}
-	    }
-
-	    for (j = 0; j < 4; j++) {
-		ms->lut_g[index * 4 + j] = colors[index].green << 8;
-	    }
-	}
-	break;
-    default:
-	for (i = 0; i < numColors; i++) {
-	    index = indices[i];
-	    ms->lut_r[index] = colors[index].red << 8;
-	    ms->lut_g[index] = colors[index].green << 8;
-	    ms->lut_b[index] = colors[index].blue << 8;
-	}
-	break;
-    }
-
-    for (c = 0; c < xf86_config->num_crtc; c++) {
-	xf86CrtcPtr crtc = xf86_config->crtc[c];
-
-	/* Make the change through RandR */
-#ifdef RANDR_12_INTERFACE
-	if (crtc->randr_crtc)
-	    RRCrtcGammaSet(crtc->randr_crtc, ms->lut_r, ms->lut_g, ms->lut_b);
-	else
-#endif
-	    crtc->funcs->gamma_set(crtc, ms->lut_r, ms->lut_g, ms->lut_b, 256);
-    }
-}
-
-
-static Bool
-drv_screen_init(SCREEN_INIT_ARGS_DECL)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    VisualPtr visual;
-    CustomizerPtr cust = ms->cust;
-    MessageType from_st;
-    MessageType from_dt;
-
-    if (!drv_set_master(pScrn))
-	return FALSE;
-
-    if (!drv_init_front_buffer_functions(pScrn)) {
-	FatalError("Could not init front buffer manager");
-	return FALSE;
-    }
-
-    pScrn->pScreen = pScreen;
-
-    /* HW dependent - FIXME */
-    pScrn->displayWidth = pScrn->virtualX;
-
-    miClearVisualTypes();
-
-    if (!miSetVisualTypes(pScrn->depth,
-			  miGetDefaultVisualMask(pScrn->depth),
-			  pScrn->rgbBits, pScrn->defaultVisual))
-	return FALSE;
-
-    if (!miSetPixmapDepths())
-	return FALSE;
-
-    pScrn->memPhysBase = 0;
-    pScrn->fbOffset = 0;
-
-    if (!fbScreenInit(pScreen, NULL,
-		      pScrn->virtualX, pScrn->virtualY,
-		      pScrn->xDpi, pScrn->yDpi,
-		      pScrn->displayWidth, pScrn->bitsPerPixel))
-	return FALSE;
-
-    if (pScrn->bitsPerPixel > 8) {
-	/* Fixup RGB ordering */
-	visual = pScreen->visuals + pScreen->numVisuals;
-	while (--visual >= pScreen->visuals) {
-	    if ((visual->class | DynamicClass) == DirectColor) {
-		visual->offsetRed = pScrn->offset.red;
-		visual->offsetGreen = pScrn->offset.green;
-		visual->offsetBlue = pScrn->offset.blue;
-		visual->redMask = pScrn->mask.red;
-		visual->greenMask = pScrn->mask.green;
-		visual->blueMask = pScrn->mask.blue;
-	    }
-	}
-    }
-
-    fbPictureInit(pScreen, NULL, 0);
-
-    ms->blockHandler = pScreen->BlockHandler;
-    pScreen->BlockHandler = drv_block_handler;
-    ms->createScreenResources = pScreen->CreateScreenResources;
-    pScreen->CreateScreenResources = drv_create_screen_resources;
-
-    xf86SetBlackWhitePixels(pScreen);
-
-    ms->accelerate_2d = xf86ReturnOptValBool(ms->Options, OPTION_2D_ACCEL, FALSE);
-    ms->debug_fallback = xf86ReturnOptValBool(ms->Options, OPTION_DEBUG_FALLBACK, ms->accelerate_2d);
-
-    if (cust && cust->winsys_screen_init)
-	cust->winsys_screen_init(cust);
-
-    ms->swapThrottling = cust ?  cust->swap_throttling : TRUE;
-    from_st = xf86GetOptValBool(ms->Options, OPTION_THROTTLE_SWAP,
-				&ms->swapThrottling) ?
-	X_CONFIG : X_DEFAULT;
-
-    ms->dirtyThrottling = cust ?  cust->dirty_throttling : FALSE;
-    from_dt = xf86GetOptValBool(ms->Options, OPTION_THROTTLE_DIRTY,
-				&ms->dirtyThrottling) ?
-	X_CONFIG : X_DEFAULT;
-
-    if (ms->screen) {
-	ms->exa = xorg_exa_init(pScrn, ms->accelerate_2d);
-
-	xorg_xv_init(pScreen);
-#ifdef DRI2
-	xorg_dri2_init(pScreen);
-#endif
-    }
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "#################################\n");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "# Useful debugging info follows #\n");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "#################################\n");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Using %s backend\n",
-	       ms->screen ? "Gallium3D" : "libkms");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "2D Acceleration is %s\n",
-	       ms->screen && ms->accelerate_2d ? "enabled" : "disabled");
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Fallback debugging is %s\n",
-	       ms->debug_fallback ? "enabled" : "disabled");
-#ifdef DRI2
-    xf86DrvMsg(pScrn->scrnIndex, ms->from_3D, "3D Acceleration is %s\n",
-	       ms->screen ? "enabled" : "disabled");
-#else
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "3D Acceleration is disabled\n");
-#endif
-    xf86DrvMsg(pScrn->scrnIndex, from_st, "Swap Throttling is %s.\n",
-	       ms->swapThrottling ? "enabled" : "disabled");
-    xf86DrvMsg(pScrn->scrnIndex, from_dt, "Dirty Throttling is %s.\n",
-	       ms->dirtyThrottling ? "enabled" : "disabled");
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "##################################\n");
-
-    xf86SetBackingStore(pScreen);
-    xf86SetSilkenMouse(pScreen);
-    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
-
-    /* Need to extend HWcursor support to handle mask interleave */
-    if (!ms->SWCursor)
-	xf86_cursors_init(pScreen, 64, 64,
-			  HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64 |
-			  HARDWARE_CURSOR_ARGB |
-			  ((cust && cust->unhidden_hw_cursor_update) ?
-			   HARDWARE_CURSOR_UPDATE_UNHIDDEN : 0));
-
-    /* Must force it before EnterVT, so we are in control of VT and
-     * later memory should be bound when allocating, e.g rotate_mem */
-    pScrn->vtSema = TRUE;
-
-    pScreen->SaveScreen = xf86SaveScreen;
-    ms->CloseScreen = pScreen->CloseScreen;
-    pScreen->CloseScreen = drv_close_screen;
-
-    if (!xf86CrtcScreenInit(pScreen))
-	return FALSE;
-
-    if (!miCreateDefColormap(pScreen))
-	return FALSE;
-    if (!xf86HandleColormaps(pScreen, 256, 8, drv_load_palette, NULL,
-			     CMAP_PALETTED_TRUECOLOR |
-			     CMAP_RELOAD_ON_MODE_SWITCH))
-	return FALSE;
-
-    xf86DPMSInit(pScreen, xf86DPMSSet, 0);
-
-    if (serverGeneration == 1)
-	xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
-
-    return drv_enter_vt_flags(pScrn, 1);
-}
-
-static void
-drv_adjust_frame(ADJUST_FRAME_ARGS_DECL)
-{
-    SCRN_INFO_PTR(arg);
-    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
-    xf86OutputPtr output = config->output[config->compat_output];
-    xf86CrtcPtr crtc = output->crtc;
-
-    if (crtc && crtc->enabled) {
-	crtc->funcs->set_mode_major(crtc, pScrn->currentMode,
-				    RR_Rotate_0, x, y);
-	crtc->x = output->initial_x + x;
-	crtc->y = output->initial_y + y;
-    }
-}
-
-static void
-drv_free_screen(FREE_SCREEN_ARGS_DECL)
-{
-    SCRN_INFO_PTR(arg);
-    drv_free_rec(pScrn);
-}
-
-static void
-drv_leave_vt(VT_FUNC_ARGS_DECL)
-{
-    SCRN_INFO_PTR(arg);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
-    CustomizerPtr cust = ms->cust;
-    int o;
-
-    if (cust && cust->winsys_leave_vt)
-	cust->winsys_leave_vt(cust);
-
-    for (o = 0; o < config->num_crtc; o++) {
-	xf86CrtcPtr crtc = config->crtc[o];
-
-	xorg_crtc_cursor_destroy(crtc);
-
-	if (crtc->rotatedPixmap || crtc->rotatedData) {
-	    crtc->funcs->shadow_destroy(crtc, crtc->rotatedPixmap,
-					crtc->rotatedData);
-	    crtc->rotatedPixmap = NULL;
-	    crtc->rotatedData = NULL;
-	}
-    }
-
-    if (ms->fb_id != -1) {
-	drmModeRmFB(ms->fd, ms->fb_id);
-	ms->fb_id = -1;
-    }
-
-    /* idle hardware */
-    if (!ms->kms)
-	drv_cleanup_fences(pScrn);
-
-    if (drmDropMaster(ms->fd))
-	xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-		   "drmDropMaster failed: %s\n", strerror(errno));
-
-    ms->isMaster = FALSE;
-    pScrn->vtSema = FALSE;
-}
-
-/*
- * This gets called when gaining control of the VT, and from ScreenInit().
- */
-static Bool
-drv_enter_vt_flags(ScrnInfoPtr pScrn, int flags)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    CustomizerPtr cust = ms->cust;
-
-    if (!drv_set_master(pScrn))
-	return FALSE;
-
-    if (!ms->create_front_buffer(pScrn))
-	return FALSE;
-
-    if (!flags && !ms->bind_front_buffer(pScrn))
-	return FALSE;
-
-    if (!xf86SetDesiredModes(pScrn))
-	return FALSE;
-
-    if (cust && cust->winsys_enter_vt)
-	cust->winsys_enter_vt(cust);
-
-    return TRUE;
-}
-
-static Bool
-drv_enter_vt(VT_FUNC_ARGS_DECL)
-{
-    SCRN_INFO_PTR(arg);
-    return drv_enter_vt_flags(pScrn, 0);
-}
-
-static Bool
-drv_switch_mode(SWITCH_MODE_ARGS_DECL)
-{
-    SCRN_INFO_PTR(arg);
-
-    return xf86SetSingleMode(pScrn, mode, RR_Rotate_0);
-}
-
-static Bool
-drv_close_screen(CLOSE_SCREEN_ARGS_DECL)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    CustomizerPtr cust = ms->cust;
-
-    if (ms->cursor) {
-       FreeCursor(ms->cursor, None);
-       ms->cursor = NULL;
-    }
-
-    if (cust && cust->winsys_screen_close)
-	cust->winsys_screen_close(cust);
-
-#ifdef DRI2
-    if (ms->screen)
-	xorg_dri2_close(pScreen);
-#endif
-
-    pScreen->BlockHandler = ms->blockHandler;
-    pScreen->CreateScreenResources = ms->createScreenResources;
-
-#ifdef DRM_MODE_FEATURE_DIRTYFB
-    if (ms->damage) {
-	DamageUnregister(&pScreen->GetScreenPixmap(pScreen)->drawable, ms->damage);
-	DamageDestroy(ms->damage);
-	ms->damage = NULL;
-    }
-#endif
-
-    ms->destroy_front_buffer(pScrn);
-
-    if (ms->exa)
-	xorg_exa_close(pScrn);
-    ms->exa = NULL;
-
-    /* calls drop master make sure we don't talk to 3D HW after that */
-    if (pScrn->vtSema) {
-	drv_leave_vt(VT_FUNC_ARGS);
-    }
-
-    pScrn->vtSema = FALSE;
-    pScreen->CloseScreen = ms->CloseScreen;
-
-    return (*pScreen->CloseScreen) (CLOSE_SCREEN_ARGS);
-}
-
-static ModeStatus
-drv_valid_mode(SCRN_ARG_TYPE arg, DisplayModePtr mode, Bool verbose, int flags)
-{
-    return MODE_OK;
-}
-
-
-/*
- * Front buffer backing store functions.
- */
-
-static Bool
-drv_destroy_front_buffer_ga3d(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-
-    if (!ms->root_texture)
-	return TRUE;
-
-    if (ms->fb_id != -1) {
-	drmModeRmFB(ms->fd, ms->fb_id);
-	ms->fb_id = -1;
-    }
-
-    pipe_resource_reference(&ms->root_texture, NULL);
-    return TRUE;
-}
-
-static Bool
-drv_create_front_buffer_ga3d(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct pipe_resource *tex;
-    struct winsys_handle whandle;
-    unsigned fb_id;
-    int ret;
-
-    ms->noEvict = TRUE;
-
-    tex = xorg_exa_create_root_texture(pScrn, pScrn->virtualX, pScrn->virtualY,
-				       pScrn->depth, pScrn->bitsPerPixel);
-
-    if (!tex)
-	return FALSE;
-
-    memset(&whandle, 0, sizeof(whandle));
-    whandle.type = DRM_API_HANDLE_TYPE_KMS;
-
-    if (!ms->screen->resource_get_handle(ms->screen, tex, &whandle))
-	goto err_destroy;
-
-    ret = drmModeAddFB(ms->fd,
-		       pScrn->virtualX,
-		       pScrn->virtualY,
-		       pScrn->depth,
-		       pScrn->bitsPerPixel,
-		       whandle.stride,
-		       whandle.handle,
-		       &fb_id);
-    if (ret) {
-	debug_printf("%s: failed to create framebuffer (%i, %s)\n",
-		     __func__, ret, strerror(-ret));
-	goto err_destroy;
-    }
-
-    if (!drv_destroy_front_buffer_ga3d(pScrn))
-	FatalError("%s: failed to take down old framebuffer\n", __func__);
-
-    pScrn->frameX0 = 0;
-    pScrn->frameY0 = 0;
-    drv_adjust_frame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
-
-    pipe_resource_reference(&ms->root_texture, tex);
-    pipe_resource_reference(&tex, NULL);
-    ms->fb_id = fb_id;
-
-    return TRUE;
-
-err_destroy:
-    pipe_resource_reference(&tex, NULL);
-    return FALSE;
-}
-
-static Bool
-drv_bind_front_buffer_ga3d(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    ScreenPtr pScreen = pScrn->pScreen;
-    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
-    struct pipe_resource *check;
-
-    xorg_exa_set_displayed_usage(rootPixmap);
-    xorg_exa_set_shared_usage(rootPixmap);
-    xorg_exa_set_texture(rootPixmap, ms->root_texture);
-    if (!pScreen->ModifyPixmapHeader(rootPixmap, -1, -1, -1, -1, -1, NULL))
-	FatalError("Couldn't adjust screen pixmap\n");
-
-    check = xorg_exa_get_texture(rootPixmap);
-    if (ms->root_texture != check)
-	FatalError("Created new root texture\n");
-
-    pipe_resource_reference(&check, NULL);
-    return TRUE;
-}
-
-#ifdef HAVE_LIBKMS
-static Bool
-drv_destroy_front_buffer_kms(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    ScreenPtr pScreen = pScrn->pScreen;
-    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
-
-    /* XXX Do something with the rootPixmap.
-     * This currently works fine but if we are getting crashes in
-     * the fb functions after VT switches maybe look more into it.
-     */
-    (void)rootPixmap;
-
-    if (!ms->root_bo)
-	return TRUE;
-
-    if (ms->fb_id != -1) {
-	drmModeRmFB(ms->fd, ms->fb_id);
-	ms->fb_id = -1;
-    }
-
-    kms_bo_unmap(ms->root_bo);
-    kms_bo_destroy(&ms->root_bo);
-    return TRUE;
-}
-
-static Bool
-drv_create_front_buffer_kms(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    unsigned handle, stride;
-    struct kms_bo *bo;
-    unsigned attr[8];
-    unsigned fb_id;
-    int ret;
-
-    attr[0] = KMS_BO_TYPE;
-#ifdef KMS_BO_TYPE_SCANOUT_X8R8G8B8
-    attr[1] = KMS_BO_TYPE_SCANOUT_X8R8G8B8;
-#else
-    attr[1] = KMS_BO_TYPE_SCANOUT;
-#endif
-    attr[2] = KMS_WIDTH;
-    attr[3] = pScrn->virtualX;
-    attr[4] = KMS_HEIGHT;
-    attr[5] = pScrn->virtualY;
-    attr[6] = 0;
-
-    if (kms_bo_create(ms->kms, attr, &bo))
-	return FALSE;
-
-    if (kms_bo_get_prop(bo, KMS_PITCH, &stride))
-	goto err_destroy;
-
-    if (kms_bo_get_prop(bo, KMS_HANDLE, &handle))
-	goto err_destroy;
-
-    ret = drmModeAddFB(ms->fd,
-		       pScrn->virtualX,
-		       pScrn->virtualY,
-		       pScrn->depth,
-		       pScrn->bitsPerPixel,
-		       stride,
-		       handle,
-		       &fb_id);
-    if (ret) {
-	debug_printf("%s: failed to create framebuffer (%i, %s)",
-		     __func__, ret, strerror(-ret));
-	goto err_destroy;
-    }
-
-    if (!drv_destroy_front_buffer_kms(pScrn))
-	FatalError("%s: could not takedown old bo", __func__);
-
-    pScrn->frameX0 = 0;
-    pScrn->frameY0 = 0;
-    drv_adjust_frame(ADJUST_FRAME_ARGS(pScrn, pScrn->frameX0, pScrn->frameY0));
-    ms->root_bo = bo;
-    ms->fb_id = fb_id;
-
-    return TRUE;
-
-err_destroy:
-    kms_bo_destroy(&bo);
-    return FALSE;
-}
-
-static Bool
-drv_bind_front_buffer_kms(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    ScreenPtr pScreen = pScrn->pScreen;
-    PixmapPtr rootPixmap = pScreen->GetScreenPixmap(pScreen);
-    unsigned stride;
-    void *ptr;
-
-    if (kms_bo_get_prop(ms->root_bo, KMS_PITCH, &stride))
-	return FALSE;
-
-    if (kms_bo_map(ms->root_bo, &ptr))
-	goto err_destroy;
-
-    pScreen->ModifyPixmapHeader(rootPixmap,
-				pScrn->virtualX,
-				pScrn->virtualY,
-				pScreen->rootDepth,
-				pScrn->bitsPerPixel,
-				stride,
-				ptr);
-
-#if (XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1, 9, 99, 1, 0))
-
-    /* This a hack to work around EnableDisableFBAccess setting the pointer
-     * the real fix would be to replace pScrn->EnableDisableFBAccess hook
-     * and set the rootPixmap->devPrivate.ptr to something valid before that.
-     *
-     * But in its infinit visdome something uses either this some times before
-     * that, so our hook doesn't get called before the crash happens.
-     */
-    pScrn->pixmapPrivate.ptr = ptr;
-
-#endif
-
-    return TRUE;
-
-err_destroy:
-    kms_bo_destroy(&ms->root_bo);
-    return FALSE;
-}
-#endif /* HAVE_LIBKMS */
-
-static Bool drv_init_front_buffer_functions(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    if (ms->screen) {
-	ms->destroy_front_buffer = drv_destroy_front_buffer_ga3d;
-	ms->create_front_buffer = drv_create_front_buffer_ga3d;
-	ms->bind_front_buffer = drv_bind_front_buffer_ga3d;
-#ifdef HAVE_LIBKMS
-    } else if (ms->kms) {
-	ms->destroy_front_buffer = drv_destroy_front_buffer_kms;
-	ms->create_front_buffer = drv_create_front_buffer_kms;
-	ms->bind_front_buffer = drv_bind_front_buffer_kms;
-#endif
-    } else
-	return FALSE;
-
-    return TRUE;
-}
-
-CustomizerPtr xorg_customizer(ScrnInfoPtr pScrn)
-{
-    return modesettingPTR(pScrn)->cust;
-}
-
-Bool xorg_has_gallium(ScrnInfoPtr pScrn)
-{
-    return modesettingPTR(pScrn)->screen != NULL;
-}
-
-/* vim: set sw=4 ts=8 sts=4: */
diff --git a/src/gallium/state_trackers/xorg/xorg_exa.c b/src/gallium/state_trackers/xorg/xorg_exa.c
deleted file mode 100644
index 3e764f8..0000000
--- a/src/gallium/state_trackers/xorg/xorg_exa.c
+++ /dev/null
@@ -1,1087 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include "xorg_exa.h"
-#include "xorg_tracker.h"
-#include "xorg_composite.h"
-#include "xorg_exa_tgsi.h"
-
-#include <xorg-server.h>
-#include <xf86.h>
-#include <picturestr.h>
-#include <picture.h>
-
-#include "pipe/p_format.h"
-#include "pipe/p_context.h"
-#include "pipe/p_state.h"
-
-#include "util/u_rect.h"
-#include "util/u_math.h"
-#include "util/u_debug.h"
-#include "util/u_format.h"
-#include "util/u_box.h"
-#include "util/u_surface.h"
-
-#define ROUND_UP_TEXTURES 1
-
-static INLINE void
-exa_debug_printf(const char *format, ...) _util_printf_format(1,2);
-
-static INLINE void
-exa_debug_printf(const char *format, ...)
-{
-#if 0
-   va_list ap;
-   va_start(ap, format);
-   _debug_vprintf(format, ap);
-   va_end(ap);
-#else
-   (void) format; /* silence warning */
-#endif
-}
-
-/*
- * Helper functions
- */
-struct render_format_str {
-   int format;
-   const char *name;
-};
-static const struct render_format_str formats_info[] =
-{
-   {PICT_a8r8g8b8, "PICT_a8r8g8b8"},
-   {PICT_x8r8g8b8, "PICT_x8r8g8b8"},
-   {PICT_a8b8g8r8, "PICT_a8b8g8r8"},
-   {PICT_x8b8g8r8, "PICT_x8b8g8r8"},
-#ifdef PICT_TYPE_BGRA
-   {PICT_b8g8r8a8, "PICT_b8g8r8a8"},
-   {PICT_b8g8r8x8, "PICT_b8g8r8x8"},
-   {PICT_a2r10g10b10, "PICT_a2r10g10b10"},
-   {PICT_x2r10g10b10, "PICT_x2r10g10b10"},
-   {PICT_a2b10g10r10, "PICT_a2b10g10r10"},
-   {PICT_x2b10g10r10, "PICT_x2b10g10r10"},
-#endif
-   {PICT_r8g8b8, "PICT_r8g8b8"},
-   {PICT_b8g8r8, "PICT_b8g8r8"},
-   {PICT_r5g6b5, "PICT_r5g6b5"},
-   {PICT_b5g6r5, "PICT_b5g6r5"},
-   {PICT_a1r5g5b5, "PICT_a1r5g5b5"},
-   {PICT_x1r5g5b5, "PICT_x1r5g5b5"},
-   {PICT_a1b5g5r5, "PICT_a1b5g5r5"},
-   {PICT_x1b5g5r5, "PICT_x1b5g5r5"},
-   {PICT_a4r4g4b4, "PICT_a4r4g4b4"},
-   {PICT_x4r4g4b4, "PICT_x4r4g4b4"},
-   {PICT_a4b4g4r4, "PICT_a4b4g4r4"},
-   {PICT_x4b4g4r4, "PICT_x4b4g4r4"},
-   {PICT_a8, "PICT_a8"},
-   {PICT_r3g3b2, "PICT_r3g3b2"},
-   {PICT_b2g3r3, "PICT_b2g3r3"},
-   {PICT_a2r2g2b2, "PICT_a2r2g2b2"},
-   {PICT_a2b2g2r2, "PICT_a2b2g2r2"},
-   {PICT_c8, "PICT_c8"},
-   {PICT_g8, "PICT_g8"},
-   {PICT_x4a4, "PICT_x4a4"},
-   {PICT_x4c4, "PICT_x4c4"},
-   {PICT_x4g4, "PICT_x4g4"},
-   {PICT_a4, "PICT_a4"},
-   {PICT_r1g2b1, "PICT_r1g2b1"},
-   {PICT_b1g2r1, "PICT_b1g2r1"},
-   {PICT_a1r1g1b1, "PICT_a1r1g1b1"},
-   {PICT_a1b1g1r1, "PICT_a1b1g1r1"},
-   {PICT_c4, "PICT_c4"},
-   {PICT_g4, "PICT_g4"},
-   {PICT_a1, "PICT_a1"},
-   {PICT_g1, "PICT_g1"}
-};
-static const char *render_format_name(int format)
-{
-   int i = 0;
-   for (i = 0; i < sizeof(formats_info)/sizeof(formats_info[0]); ++i) {
-      if (formats_info[i].format == format)
-         return formats_info[i].name;
-   }
-   return NULL;
-}
-
-static void
-exa_get_pipe_format(int depth, enum pipe_format *format, int *bbp, int *picture_format)
-{
-    switch (depth) {
-    case 32:
-	*format = PIPE_FORMAT_B8G8R8A8_UNORM;
-	*picture_format = PICT_a8r8g8b8;
-	assert(*bbp == 32);
-	break;
-    case 24:
-	*format = PIPE_FORMAT_B8G8R8X8_UNORM;
-	*picture_format = PICT_x8r8g8b8;
-	assert(*bbp == 32);
-	break;
-    case 16:
-	*format = PIPE_FORMAT_B5G6R5_UNORM;
-	*picture_format = PICT_r5g6b5;
-	assert(*bbp == 16);
-	break;
-    case 15:
-	*format = PIPE_FORMAT_B5G5R5A1_UNORM;
-	*picture_format = PICT_x1r5g5b5;
-	assert(*bbp == 16);
-	break;
-    case 8:
-	*format = PIPE_FORMAT_L8_UNORM;
-	*picture_format = PICT_a8;
-	assert(*bbp == 8);
-	break;
-    case 4:
-    case 1:
-	*format = PIPE_FORMAT_B8G8R8A8_UNORM; /* bad bad bad */
-	break;
-    default:
-	assert(0);
-	break;
-    }
-}
-
-
-/*
- * Static exported EXA functions
- */
-
-static void
-ExaWaitMarker(ScreenPtr pScreen, int marker)
-{
-   /* Nothing to do, handled in the PrepareAccess hook */
-}
-
-static int
-ExaMarkSync(ScreenPtr pScreen)
-{
-   return 1;
-}
-
-
-/***********************************************************************
- * Screen upload/download
- */
-
-static Bool
-ExaDownloadFromScreen(PixmapPtr pPix, int x,  int y, int w,  int h, char *dst,
-		      int dst_pitch)
-{
-    ScreenPtr pScreen = pPix->drawable.pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPix);
-    struct pipe_transfer *transfer;
-    void *map;
-
-    if (!priv || !priv->tex)
-	return FALSE;
-
-    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
-                            PIPE_TRANSFER_READ, x, y, w, h, &transfer);
-    if (!map)
-	return FALSE;
-
-    exa_debug_printf("------ ExaDownloadFromScreen(%d, %d, %d, %d, %d)\n",
-                 x, y, w, h, dst_pitch);
-
-    util_copy_rect((unsigned char*)dst, priv->tex->format, dst_pitch, 0, 0,
-		   w, h, map, transfer->stride, 0, 0);
-
-    exa->pipe->transfer_unmap(exa->pipe, transfer);
-
-    return TRUE;
-}
-
-static Bool
-ExaUploadToScreen(PixmapPtr pPix, int x, int y, int w, int h, char *src,
-		  int src_pitch)
-{
-    ScreenPtr pScreen = pPix->drawable.pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPix);
-    struct pipe_transfer *transfer;
-    void *map;
-
-    if (!priv || !priv->tex)
-	return FALSE;
-
-    map = pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
-                            PIPE_TRANSFER_WRITE, x, y, w, h, &transfer);
-    if (!map)
-	return FALSE;
-
-    exa_debug_printf("++++++ ExaUploadToScreen(%d, %d, %d, %d, %d)\n",
-                 x, y, w, h, src_pitch);
-
-    util_copy_rect(map,
-		   priv->tex->format, transfer->stride, 0, 0, w, h,
-		   (unsigned char*)src, src_pitch, 0, 0);
-
-    exa->pipe->transfer_unmap(exa->pipe, transfer);
-
-    return TRUE;
-}
-
-static Bool
-ExaPrepareAccess(PixmapPtr pPix, int index)
-{
-    ScreenPtr pScreen = pPix->drawable.pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv;
-
-    priv = exaGetPixmapDriverPrivate(pPix);
-
-    if (!priv)
-	return FALSE;
-
-    if (!priv->tex)
-	return FALSE;
-
-    exa_debug_printf("ExaPrepareAccess %d\n", index);
-
-    if (priv->map_count == 0)
-    {
-        assert(pPix->drawable.width <= priv->tex->width0);
-        assert(pPix->drawable.height <= priv->tex->height0);
-
-	pPix->devPrivate.ptr =
-	   pipe_transfer_map(exa->pipe, priv->tex, 0, 0,
-#ifdef EXA_MIXED_PIXMAPS
-                             PIPE_TRANSFER_MAP_DIRECTLY |
-#endif
-                             PIPE_TRANSFER_READ_WRITE,
-                             0, 0,
-                             pPix->drawable.width,
-                             pPix->drawable.height,
-                             &priv->map_transfer);
-        if (!pPix->devPrivate.ptr)
-#ifdef EXA_MIXED_PIXMAPS
-	    return FALSE;
-#else
-	    FatalError("failed to create transfer\n");
-#endif
-
-	pPix->devKind = priv->map_transfer->stride;
-    }
-
-    priv->map_count++;
-
-    exa_debug_printf("ExaPrepareAccess %d prepared\n", index);
-
-    return TRUE;
-}
-
-static void
-ExaFinishAccess(PixmapPtr pPix, int index)
-{
-    ScreenPtr pScreen = pPix->drawable.pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv;
-    priv = exaGetPixmapDriverPrivate(pPix);
-
-    if (!priv)
-	return;
-
-    if (!priv->map_transfer)
-	return;
-
-    exa_debug_printf("ExaFinishAccess %d\n", index);
-
-    if (--priv->map_count == 0) {
-	assert(priv->map_transfer);
-	exa->pipe->transfer_unmap(exa->pipe, priv->map_transfer);
-	priv->map_transfer = NULL;
-	pPix->devPrivate.ptr = NULL;
-    }
-
-    exa_debug_printf("ExaFinishAccess %d finished\n", index);
-}
-
-/***********************************************************************
- * Solid Fills
- */
-
-static Bool
-ExaPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planeMask, Pixel fg)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-    struct exa_context *exa = ms->exa;
-
-    exa_debug_printf("ExaPrepareSolid(0x%x)\n", fg);
-
-    if (!exa->accel)
-	return FALSE;
-
-    if (!exa->pipe)
-	XORG_FALLBACK("accel not enabled");
-
-    if (!priv || !priv->tex)
-	XORG_FALLBACK("%s", !priv ? "!priv" : "!priv->tex");
-
-    if (!EXA_PM_IS_SOLID(&pPixmap->drawable, planeMask))
-	XORG_FALLBACK("planeMask is not solid");
-
-    if (alu != GXcopy)
-	XORG_FALLBACK("not GXcopy");
-
-    if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
-                                        priv->tex->target, 0,
-                                        PIPE_BIND_RENDER_TARGET)) {
-	XORG_FALLBACK("format %s", util_format_name(priv->tex->format));
-    }
-
-    return xorg_solid_bind_state(exa, priv, fg);
-}
-
-static void
-ExaSolid(PixmapPtr pPixmap, int x0, int y0, int x1, int y1)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-
-    exa_debug_printf("\tExaSolid(%d, %d, %d, %d)\n", x0, y0, x1, y1);
-
-    if (x0 == 0 && y0 == 0 &&
-        x1 == pPixmap->drawable.width && y1 == pPixmap->drawable.height) {
-       union pipe_color_union solid_color;
-       solid_color.f[0] = exa->solid_color[0];
-       solid_color.f[1] = exa->solid_color[1];
-       solid_color.f[2] = exa->solid_color[2];
-       solid_color.f[3] = exa->solid_color[3];
-       exa->pipe->clear(exa->pipe, PIPE_CLEAR_COLOR, &solid_color, 0.0, 0);
-       return;
-    }
-
-    xorg_solid(exa, priv, x0, y0, x1, y1) ;
-}
-
-
-static void
-ExaDoneSolid(PixmapPtr pPixmap)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-    struct exa_context *exa = ms->exa;
-
-    if (!priv)
-	return;
-
-    exa_debug_printf("ExaDoneSolid\n");
-    xorg_composite_done(exa);
-    exa_debug_printf("ExaDoneSolid done\n");
-}
-
-/***********************************************************************
- * Copy Blits
- */
-
-static Bool
-ExaPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int xdir,
-	       int ydir, int alu, Pixel planeMask)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pDstPixmap);
-    struct exa_pixmap_priv *src_priv = exaGetPixmapDriverPrivate(pSrcPixmap);
-
-    exa_debug_printf("ExaPrepareCopy\n");
-
-    if (!exa->accel)
-	return FALSE;
-
-    if (!exa->pipe)
-	XORG_FALLBACK("accel not enabled");
-
-    if (!priv || !priv->tex)
-	XORG_FALLBACK("pDst %s", !priv ? "!priv" : "!priv->tex");
-
-    if (!src_priv || !src_priv->tex)
-	XORG_FALLBACK("pSrc %s", !src_priv ? "!priv" : "!priv->tex");
-
-    if (!EXA_PM_IS_SOLID(&pSrcPixmap->drawable, planeMask))
-	XORG_FALLBACK("planeMask is not solid");
-
-    if (alu != GXcopy)
-	XORG_FALLBACK("alu not GXcopy");
-
-    if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
-                                        priv->tex->target, 0,
-                                        PIPE_BIND_RENDER_TARGET))
-	XORG_FALLBACK("pDst format %s", util_format_name(priv->tex->format));
-
-    if (!exa->scrn->is_format_supported(exa->scrn, src_priv->tex->format,
-                                        src_priv->tex->target, 0,
-                                        PIPE_BIND_SAMPLER_VIEW))
-	XORG_FALLBACK("pSrc format %s", util_format_name(src_priv->tex->format));
-
-    exa->copy.src = src_priv;
-    exa->copy.dst = priv;
-
-    return TRUE;
-}
-
-static void
-ExaCopy(PixmapPtr pDstPixmap, int srcX, int srcY, int dstX, int dstY,
-	int width, int height)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPixmap->drawable.pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-   struct pipe_box src_box;
-
-   exa_debug_printf("\tExaCopy(srcx=%d, srcy=%d, dstX=%d, dstY=%d, w=%d, h=%d)\n",
-                srcX, srcY, dstX, dstY, width, height);
-
-   debug_assert(exaGetPixmapDriverPrivate(pDstPixmap) == exa->copy.dst);
-
-   u_box_2d(srcX, srcY, width, height, &src_box);
-
-   /* If source and destination overlap, we have to copy to/from a scratch
-    * pixmap.
-    */
-   if (exa->copy.dst == exa->copy.src &&
-       !((dstX + width) < srcX || dstX > (srcX + width) ||
-	 (dstY + height) < srcY || dstY > (srcY + height))) {
-      struct exa_pixmap_priv *tmp_priv;
-
-      if (!exa->copy.tmp_pix) {
-         exa->copy.tmp_pix = pScrn->pScreen->CreatePixmap(pScrn->pScreen,
-                                                         pDstPixmap->drawable.width,
-                                                         pDstPixmap->drawable.height,
-                                                         pDstPixmap->drawable.depth,
-                                                         pDstPixmap->drawable.width);
-         exaMoveInPixmap(exa->copy.tmp_pix);
-      }
-
-      tmp_priv = exaGetPixmapDriverPrivate(exa->copy.tmp_pix);
-
-      exa->pipe->resource_copy_region( exa->pipe,
-                                       tmp_priv->tex,
-                                       0,
-                                       srcX, srcY, 0,
-                                       exa->copy.src->tex,
-                                       0, &src_box);
-      exa->pipe->resource_copy_region( exa->pipe,
-                                       exa->copy.dst->tex,
-                                       0,
-                                       dstX, dstY, 0,
-                                       tmp_priv->tex,
-                                       0, &src_box);
-   } else
-      exa->pipe->resource_copy_region( exa->pipe,
-                                       exa->copy.dst->tex,
-                                       0,
-                                       dstX, dstY, 0,
-                                       exa->copy.src->tex,
-                                       0, &src_box);
-}
-
-static void
-ExaDoneCopy(PixmapPtr pPixmap)
-{
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-    struct exa_context *exa = ms->exa;
-
-    if (!priv)
-	return;
-
-   exa_debug_printf("ExaDoneCopy\n");
-
-   if (exa->copy.tmp_pix) {
-      pScrn->pScreen->DestroyPixmap(exa->copy.tmp_pix);
-      exa->copy.tmp_pix = NULL;
-   }
-   exa->copy.src = NULL;
-   exa->copy.dst = NULL;
-
-   exa_debug_printf("ExaDoneCopy done\n");
-}
-
-
-
-static Bool
-picture_check_formats(struct exa_pixmap_priv *pSrc, PicturePtr pSrcPicture)
-{
-   if (pSrc->picture_format == pSrcPicture->format)
-      return TRUE;
-
-   if (pSrc->picture_format != PICT_a8r8g8b8)
-      return FALSE;
-
-   /* pSrc->picture_format == PICT_a8r8g8b8 */
-   switch (pSrcPicture->format) {
-   case PICT_a8r8g8b8:
-   case PICT_x8r8g8b8:
-   case PICT_a8b8g8r8:
-   case PICT_x8b8g8r8:
-   /* just treat these two as x8... */
-   case PICT_r8g8b8:
-   case PICT_b8g8r8:
-      return TRUE;
-#ifdef PICT_TYPE_BGRA
-   case PICT_b8g8r8a8:
-   case PICT_b8g8r8x8:
-      return FALSE; /* does not support swizzleing the alpha channel yet */
-   case PICT_a2r10g10b10:
-   case PICT_x2r10g10b10:
-   case PICT_a2b10g10r10:
-   case PICT_x2b10g10r10:
-      return FALSE;
-#endif
-   default:
-      return FALSE;
-   }
-   return FALSE;
-}
-
-/***********************************************************************
- * Composite entrypoints
- */
-
-static Bool
-ExaCheckComposite(int op,
-		  PicturePtr pSrcPicture, PicturePtr pMaskPicture,
-		  PicturePtr pDstPicture)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDstPicture->pDrawable->pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-   Bool accelerated = exa->accel && xorg_composite_accelerated(op,
-				     pSrcPicture,
-				     pMaskPicture,
-				     pDstPicture);
-
-   exa_debug_printf("ExaCheckComposite(%d, %p, %p, %p) = %d\n",
-                op, pSrcPicture, pMaskPicture, pDstPicture, accelerated);
-
-   return accelerated;
-}
-
-
-static Bool
-ExaPrepareComposite(int op, PicturePtr pSrcPicture,
-		    PicturePtr pMaskPicture, PicturePtr pDstPicture,
-		    PixmapPtr pSrc, PixmapPtr pMask, PixmapPtr pDst)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-   struct exa_pixmap_priv *priv;
-
-   if (!exa->accel)
-       return FALSE;
-
-   exa_debug_printf("ExaPrepareComposite(%d, src=0x%p, mask=0x%p, dst=0x%p)\n",
-                op, pSrcPicture, pMaskPicture, pDstPicture);
-   exa_debug_printf("\tFormats: src(%s), mask(%s), dst(%s)\n",
-                pSrcPicture ? render_format_name(pSrcPicture->format) : "none",
-                pMaskPicture ? render_format_name(pMaskPicture->format) : "none",
-                pDstPicture ? render_format_name(pDstPicture->format) : "none");
-
-   if (!exa->pipe)
-      XORG_FALLBACK("accel not enabled");
-
-   priv = exaGetPixmapDriverPrivate(pDst);
-   if (!priv || !priv->tex)
-      XORG_FALLBACK("pDst %s", !priv ? "!priv" : "!priv->tex");
-
-   if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
-                                       priv->tex->target, 0,
-                                       PIPE_BIND_RENDER_TARGET))
-      XORG_FALLBACK("pDst format: %s", util_format_name(priv->tex->format));
-
-   if (priv->picture_format != pDstPicture->format)
-      XORG_FALLBACK("pDst pic_format: %s != %s",
-                    render_format_name(priv->picture_format),
-                    render_format_name(pDstPicture->format));
-
-   if (pSrc) {
-      priv = exaGetPixmapDriverPrivate(pSrc);
-      if (!priv || !priv->tex)
-         XORG_FALLBACK("pSrc %s", !priv ? "!priv" : "!priv->tex");
-
-      if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
-                                          priv->tex->target, 0,
-                                          PIPE_BIND_SAMPLER_VIEW))
-         XORG_FALLBACK("pSrc format: %s", util_format_name(priv->tex->format));
-
-      if (!picture_check_formats(priv, pSrcPicture))
-         XORG_FALLBACK("pSrc pic_format: %s != %s",
-                       render_format_name(priv->picture_format),
-                       render_format_name(pSrcPicture->format));
-
-   }
-
-   if (pMask) {
-      priv = exaGetPixmapDriverPrivate(pMask);
-      if (!priv || !priv->tex)
-         XORG_FALLBACK("pMask %s", !priv ? "!priv" : "!priv->tex");
-
-      if (!exa->scrn->is_format_supported(exa->scrn, priv->tex->format,
-                                          priv->tex->target, 0,
-                                          PIPE_BIND_SAMPLER_VIEW))
-         XORG_FALLBACK("pMask format: %s", util_format_name(priv->tex->format));
-
-      if (!picture_check_formats(priv, pMaskPicture))
-         XORG_FALLBACK("pMask pic_format: %s != %s",
-                       render_format_name(priv->picture_format),
-                       render_format_name(pMaskPicture->format));
-   }
-
-   return xorg_composite_bind_state(exa, op, pSrcPicture, pMaskPicture,
-                                    pDstPicture,
-                                    pSrc ? exaGetPixmapDriverPrivate(pSrc) : NULL,
-                                    pMask ? exaGetPixmapDriverPrivate(pMask) : NULL,
-                                    exaGetPixmapDriverPrivate(pDst));
-}
-
-static void
-ExaComposite(PixmapPtr pDst, int srcX, int srcY, int maskX, int maskY,
-	     int dstX, int dstY, int width, int height)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pDst->drawable.pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-   struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pDst);
-
-   exa_debug_printf("\tExaComposite(src[%d,%d], mask=[%d, %d], dst=[%d, %d], dim=[%d, %d])\n",
-                srcX, srcY, maskX, maskY, dstX, dstY, width, height);
-   exa_debug_printf("\t   Num bound samplers = %d\n",
-                exa->num_bound_samplers);
-
-   xorg_composite(exa, priv, srcX, srcY, maskX, maskY,
-                  dstX, dstY, width, height);
-}
-
-
-
-static void
-ExaDoneComposite(PixmapPtr pPixmap)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pPixmap->drawable.pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-
-   xorg_composite_done(exa);
-}
-
-
-/***********************************************************************
- * Pixmaps
- */
-
-static void *
-ExaCreatePixmap(ScreenPtr pScreen, int size, int align)
-{
-    struct exa_pixmap_priv *priv;
-
-    priv = calloc(1, sizeof(struct exa_pixmap_priv));
-    if (!priv)
-	return NULL;
-
-    return priv;
-}
-
-static void
-ExaDestroyPixmap(ScreenPtr pScreen, void *dPriv)
-{
-    struct exa_pixmap_priv *priv = (struct exa_pixmap_priv *)dPriv;
-
-    if (!priv)
-	return;
-
-    pipe_resource_reference(&priv->tex, NULL);
-
-    free(priv);
-}
-
-static Bool
-ExaPixmapIsOffscreen(PixmapPtr pPixmap)
-{
-    struct exa_pixmap_priv *priv;
-
-    priv = exaGetPixmapDriverPrivate(pPixmap);
-
-    if (!priv)
-	return FALSE;
-
-    if (priv->tex)
-	return TRUE;
-
-    return FALSE;
-}
-
-int
-xorg_exa_set_displayed_usage(PixmapPtr pPixmap)
-{
-    struct exa_pixmap_priv *priv;
-    priv = exaGetPixmapDriverPrivate(pPixmap);
-
-    if (!priv) {
-	FatalError("NO PIXMAP PRIVATE\n");
-	return 0;
-    }
-
-    priv->flags |= PIPE_BIND_SCANOUT;
-
-    return 0;
-}
-
-int
-xorg_exa_set_shared_usage(PixmapPtr pPixmap)
-{
-    struct exa_pixmap_priv *priv;
-    priv = exaGetPixmapDriverPrivate(pPixmap);
-
-    if (!priv) {
-	FatalError("NO PIXMAP PRIVATE\n");
-	return 0;
-    }
-
-    priv->flags |= PIPE_BIND_SHARED;
-
-    return 0;
-}
-
-
-
-static Bool
-size_match( int width, int tex_width )
-{
-#if ROUND_UP_TEXTURES
-   if (width > tex_width)
-      return FALSE;
-
-   if (width * 2 < tex_width)
-      return FALSE;
-
-   return TRUE;
-#else
-   return width == tex_width;
-#endif
-}
-
-static Bool
-ExaModifyPixmapHeader(PixmapPtr pPixmap, int width, int height,
-		      int depth, int bitsPerPixel, int devKind,
-		      pointer pPixData)
-{
-    ScreenPtr pScreen = pPixmap->drawable.pScreen;
-    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-
-    if (!priv || pPixData)
-	return FALSE;
-
-    if (0) {
-       debug_printf("%s pixmap %p sz %dx%dx%d devKind %d\n",
-                    __FUNCTION__, pPixmap, width, height, bitsPerPixel, devKind);
-       
-       if (priv->tex)
-          debug_printf("  ==> old texture %dx%d\n",
-                       priv->tex->width0, 
-                       priv->tex->height0);
-    }
-
-
-    if (depth <= 0)
-	depth = pPixmap->drawable.depth;
-
-    if (bitsPerPixel <= 0)
-	bitsPerPixel = pPixmap->drawable.bitsPerPixel;
-
-    if (width <= 0)
-	width = pPixmap->drawable.width;
-
-    if (height <= 0)
-	height = pPixmap->drawable.height;
-
-    if (width <= 0 || height <= 0 || depth <= 0)
-	return FALSE;
-
-    miModifyPixmapHeader(pPixmap, width, height, depth,
-			     bitsPerPixel, devKind, NULL);
-
-    priv->width = width;
-    priv->height = height;
-
-    /* Deal with screen resize */
-    if ((exa->accel || priv->flags) &&
-        (!priv->tex ||
-         !size_match(width, priv->tex->width0) ||
-         !size_match(height, priv->tex->height0) ||
-         priv->tex_flags != priv->flags)) {
-	struct pipe_resource *texture = NULL;
-	struct pipe_resource template;
-
-	memset(&template, 0, sizeof(template));
-	template.target = PIPE_TEXTURE_2D;
-	exa_get_pipe_format(depth, &template.format, &bitsPerPixel, &priv->picture_format);
-        if (ROUND_UP_TEXTURES && priv->flags == 0) {
-           template.width0 = util_next_power_of_two(width);
-           template.height0 = util_next_power_of_two(height);
-        }
-        else {
-           template.width0 = width;
-           template.height0 = height;
-        }
-
-	template.depth0 = 1;
-	template.array_size = 1;
-	template.last_level = 0;
-	template.bind = PIPE_BIND_RENDER_TARGET | priv->flags;
-	priv->tex_flags = priv->flags;
-	texture = exa->scrn->resource_create(exa->scrn, &template);
-
-	if (priv->tex) {
-            struct pipe_box src_box;
-            u_box_origin_2d(min(width, texture->width0),
-                            min(height, texture->height0),
-                            &src_box);
-            exa->pipe->resource_copy_region(exa->pipe, texture,
-                                            0, 0, 0, 0,
-                                            priv->tex,
-                                            0, &src_box);
-	}
-
-	pipe_resource_reference(&priv->tex, texture);
-	/* the texture we create has one reference */
-	pipe_resource_reference(&texture, NULL);
-    }
-
-    return TRUE;
-}
-
-struct pipe_resource *
-xorg_exa_get_texture(PixmapPtr pPixmap)
-{
-   struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-   struct pipe_resource *tex = NULL;
-   pipe_resource_reference(&tex, priv->tex);
-   return tex;
-}
-
-Bool
-xorg_exa_set_texture(PixmapPtr pPixmap, struct  pipe_resource *tex)
-{
-    struct exa_pixmap_priv *priv = exaGetPixmapDriverPrivate(pPixmap);
-
-    int mask = PIPE_BIND_SHARED | PIPE_BIND_SCANOUT;
-
-    if (!priv)
-	return FALSE;
-
-    if (pPixmap->drawable.width != tex->width0 ||
-	pPixmap->drawable.height != tex->height0)
-	return FALSE;
-
-    pipe_resource_reference(&priv->tex, tex);
-    priv->tex_flags = tex->bind & mask;
-
-    return TRUE;
-}
-
-struct pipe_resource *
-xorg_exa_create_root_texture(ScrnInfoPtr pScrn,
-			     int width, int height,
-			     int depth, int bitsPerPixel)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    struct exa_context *exa = ms->exa;
-    struct pipe_resource template;
-    int dummy;
-
-    memset(&template, 0, sizeof(template));
-    template.target = PIPE_TEXTURE_2D;
-    exa_get_pipe_format(depth, &template.format, &bitsPerPixel, &dummy);
-    template.width0 = width;
-    template.height0 = height;
-    template.depth0 = 1;
-    template.array_size = 1;
-    template.last_level = 0;
-    template.bind |= PIPE_BIND_RENDER_TARGET;
-    template.bind |= PIPE_BIND_SCANOUT;
-    template.bind |= PIPE_BIND_SHARED;
-
-    return exa->scrn->resource_create(exa->scrn, &template);
-}
-
-void
-xorg_exa_close(ScrnInfoPtr pScrn)
-{
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa = ms->exa;
-
-   pipe_sampler_view_reference(&exa->bound_sampler_views[0], NULL);
-   pipe_sampler_view_reference(&exa->bound_sampler_views[1], NULL);
-
-   renderer_destroy(exa->renderer);
-
-   xorg_exa_finish(exa);
-
-   if (exa->pipe)
-      exa->pipe->destroy(exa->pipe);
-   exa->pipe = NULL;
-   /* Since this was shared be proper with the pointer */
-   ms->ctx = NULL;
-
-   exaDriverFini(pScrn->pScreen);
-   free(exa);
-   ms->exa = NULL;
-}
-
-void *
-xorg_exa_init(ScrnInfoPtr pScrn, Bool accel)
-{
-   modesettingPtr ms = modesettingPTR(pScrn);
-   struct exa_context *exa;
-   ExaDriverPtr pExa;
-   CustomizerPtr cust = ms->cust;
-
-   exa = calloc(1, sizeof(struct exa_context));
-   if (!exa)
-      return NULL;
-
-   exa->scrn = ms->screen;
-   exa->pipe = exa->scrn->context_create(exa->scrn, NULL);
-   if (exa->pipe == NULL)
-      goto out_err;
-
-   pExa = exaDriverAlloc();
-   if (!pExa) {
-      goto out_err;
-   }
-
-   pExa->exa_major         = 2;
-   pExa->exa_minor         = 2;
-   pExa->memoryBase        = 0;
-   pExa->memorySize        = 0;
-   pExa->offScreenBase     = 0;
-   pExa->pixmapOffsetAlign = 0;
-   pExa->pixmapPitchAlign  = 1;
-   pExa->flags             = EXA_OFFSCREEN_PIXMAPS | EXA_HANDLES_PIXMAPS;
-#ifdef EXA_SUPPORTS_PREPARE_AUX
-   pExa->flags            |= EXA_SUPPORTS_PREPARE_AUX;
-#endif
-#ifdef EXA_MIXED_PIXMAPS
-   pExa->flags            |= EXA_MIXED_PIXMAPS;
-#endif
-
-   pExa->maxX = pExa->maxY =
-   1 << (exa->scrn->get_param(exa->scrn, PIPE_CAP_MAX_TEXTURE_2D_LEVELS) - 1);
-
-   pExa->WaitMarker         = ExaWaitMarker;
-   pExa->MarkSync           = ExaMarkSync;
-   pExa->PrepareSolid       = ExaPrepareSolid;
-   pExa->Solid              = ExaSolid;
-   pExa->DoneSolid          = ExaDoneSolid;
-   pExa->PrepareCopy        = ExaPrepareCopy;
-   pExa->Copy               = ExaCopy;
-   pExa->DoneCopy           = ExaDoneCopy;
-   pExa->CheckComposite     = ExaCheckComposite;
-   pExa->PrepareComposite   = ExaPrepareComposite;
-   pExa->Composite          = ExaComposite;
-   pExa->DoneComposite      = ExaDoneComposite;
-   pExa->PixmapIsOffscreen  = ExaPixmapIsOffscreen;
-   pExa->DownloadFromScreen = ExaDownloadFromScreen;
-   pExa->UploadToScreen     = ExaUploadToScreen;
-   pExa->PrepareAccess      = ExaPrepareAccess;
-   pExa->FinishAccess       = ExaFinishAccess;
-   pExa->CreatePixmap       = ExaCreatePixmap;
-   pExa->DestroyPixmap      = ExaDestroyPixmap;
-   pExa->ModifyPixmapHeader = ExaModifyPixmapHeader;
-
-   if (!exaDriverInit(pScrn->pScreen, pExa)) {
-      goto out_err;
-   }
-
-   /* Share context with DRI */
-   ms->ctx = exa->pipe;
-   if (cust && cust->winsys_context_throttle)
-       cust->winsys_context_throttle(cust, ms->ctx, THROTTLE_RENDER);
-
-   exa->renderer = renderer_create(exa->pipe);
-   exa->accel = accel;
-
-   return (void *)exa;
-
-out_err:
-   xorg_exa_close(pScrn);
-   free(exa);
-
-   return NULL;
-}
-
-struct pipe_surface *
-xorg_gpu_surface(struct pipe_context *pipe, struct exa_pixmap_priv *priv)
-{
-   struct pipe_surface surf_tmpl;
-   u_surface_default_template(&surf_tmpl, priv->tex);
-
-   return pipe->create_surface(pipe, priv->tex, &surf_tmpl);
-
-}
-
-void xorg_exa_flush(struct exa_context *exa,
-                    struct pipe_fence_handle **fence)
-{
-   exa->pipe->flush(exa->pipe, fence, 0);
-}
-
-void xorg_exa_finish(struct exa_context *exa)
-{
-   struct pipe_fence_handle *fence = NULL;
-
-   xorg_exa_flush(exa, &fence);
-
-   exa->pipe->screen->fence_finish(exa->pipe->screen, fence,
-                                   PIPE_TIMEOUT_INFINITE);
-   exa->pipe->screen->fence_reference(exa->pipe->screen, &fence, NULL);
-}
-
diff --git a/src/gallium/state_trackers/xorg/xorg_exa.h b/src/gallium/state_trackers/xorg/xorg_exa.h
deleted file mode 100644
index e8f7c9f..0000000
--- a/src/gallium/state_trackers/xorg/xorg_exa.h
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef XORG_EXA_H
-#define XORG_EXA_H
-
-#include "xorg_tracker.h"
-
-#include "pipe/p_state.h"
-
-struct cso_context;
-struct xorg_shaders;
-
-/* src + mask + dst */
-#define MAX_EXA_SAMPLERS 3
-
-struct exa_context
-{
-   ExaDriverPtr pExa;
-   struct pipe_context *pipe;
-   struct pipe_screen *scrn;
-   struct xorg_renderer *renderer;
-
-   struct pipe_sampler_view *bound_sampler_views[MAX_EXA_SAMPLERS];
-   int num_bound_samplers;
-
-   float solid_color[4];
-   boolean has_solid_color;
-
-   boolean accel;
-
-   /* float[9] projective matrix bound to pictures */
-   struct {
-      float    src[9];
-      float   mask[9];
-      boolean has_src;
-      boolean has_mask;
-   } transform;
-
-   struct {
-      struct exa_pixmap_priv *src;
-      struct exa_pixmap_priv *dst;
-      PixmapPtr tmp_pix;
-   } copy;
-};
-
-struct exa_pixmap_priv
-{
-   int width, height;
-
-   int flags;
-   int tex_flags;
-
-   int picture_format;
-
-   struct pipe_resource *tex;
-   struct pipe_resource *depth_stencil_tex;
-
-   struct pipe_transfer *map_transfer;
-   unsigned map_count;
-};
-
-#define XORG_FALLBACK(s, arg...)                              \
-do {                                                          \
-   if (ms->debug_fallback) {                                  \
-      xf86DrvMsg(pScrn->scrnIndex, X_INFO,                    \
-                 "%s fallback " s "\n", __FUNCTION__, ##arg); \
-   }                                                          \
-   return FALSE;                                              \
-} while(0)
-
-struct pipe_surface *
-xorg_gpu_surface(struct pipe_context *pipe, struct exa_pixmap_priv *priv);
-
-void xorg_exa_flush(struct exa_context *exa,
-                    struct pipe_fence_handle **fence);
-void xorg_exa_finish(struct exa_context *exa);
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
deleted file mode 100644
index fe1aab3..0000000
--- a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.c
+++ /dev/null
@@ -1,690 +0,0 @@
-#include "xorg_exa_tgsi.h"
-
-/*### stupidity defined in X11/extensions/XI.h */
-#undef Absolute
-
-#include "pipe/p_format.h"
-#include "pipe/p_context.h"
-#include "pipe/p_state.h"
-#include "pipe/p_shader_tokens.h"
-
-#include "util/u_memory.h"
-
-#include "tgsi/tgsi_ureg.h"
-
-#include "cso_cache/cso_context.h"
-#include "cso_cache/cso_hash.h"
-
-/* Vertex shader:
- * IN[0]    = vertex pos
- * IN[1]    = src tex coord | solid fill color
- * IN[2]    = mask tex coord
- * IN[3]    = dst tex coord
- * CONST[0] = (2/dst_width, 2/dst_height, 1, 1)
- * CONST[1] = (-1, -1, 0, 0)
- *
- * OUT[0]   = vertex pos
- * OUT[1]   = src tex coord | solid fill color
- * OUT[2]   = mask tex coord
- * OUT[3]   = dst tex coord
- */
-
-/* Fragment shader:
- * SAMP[0]  = src
- * SAMP[1]  = mask
- * SAMP[2]  = dst
- * IN[0]    = pos src | solid fill color
- * IN[1]    = pos mask
- * IN[2]    = pos dst
- * CONST[0] = (0, 0, 0, 1)
- *
- * OUT[0] = color
- */
-
-static void
-print_fs_traits(int fs_traits)
-{
-   const char *strings[] = {
-      "FS_COMPOSITE",       /* = 1 << 0, */
-      "FS_MASK",            /* = 1 << 1, */
-      "FS_SOLID_FILL",      /* = 1 << 2, */
-      "FS_LINGRAD_FILL",    /* = 1 << 3, */
-      "FS_RADGRAD_FILL",    /* = 1 << 4, */
-      "FS_CA_FULL",         /* = 1 << 5, */ /* src.rgba * mask.rgba */
-      "FS_CA_SRCALPHA",     /* = 1 << 6, */ /* src.aaaa * mask.rgba */
-      "FS_YUV",             /* = 1 << 7, */
-      "FS_SRC_REPEAT_NONE", /* = 1 << 8, */
-      "FS_MASK_REPEAT_NONE",/* = 1 << 9, */
-      "FS_SRC_SWIZZLE_RGB", /* = 1 << 10, */
-      "FS_MASK_SWIZZLE_RGB",/* = 1 << 11, */
-      "FS_SRC_SET_ALPHA",   /* = 1 << 12, */
-      "FS_MASK_SET_ALPHA",  /* = 1 << 13, */
-      "FS_SRC_LUMINANCE",   /* = 1 << 14, */
-      "FS_MASK_LUMINANCE",  /* = 1 << 15, */
-   };
-   int i, k;
-   debug_printf("%s: ", __func__);
-
-   for (i = 0, k = 1; k < (1 << 16); i++, k <<= 1) {
-      if (fs_traits & k)
-         debug_printf("%s, ", strings[i]);
-   }
-
-   debug_printf("\n");
-}
-
-struct xorg_shaders {
-   struct xorg_renderer *r;
-
-   struct cso_hash *vs_hash;
-   struct cso_hash *fs_hash;
-};
-
-static INLINE void
-src_in_mask(struct ureg_program *ureg,
-            struct ureg_dst dst,
-            struct ureg_src src,
-            struct ureg_src mask,
-            unsigned component_alpha,
-            unsigned mask_luminance)
-{
-   if (component_alpha == FS_CA_FULL) {
-      ureg_MUL(ureg, dst, src, mask);
-   } else if (component_alpha == FS_CA_SRCALPHA) {
-      ureg_MUL(ureg, dst,
-               ureg_scalar(src, TGSI_SWIZZLE_W), mask);
-   }
-   else {
-      if (mask_luminance)
-         ureg_MUL(ureg, dst, src,
-                  ureg_scalar(mask, TGSI_SWIZZLE_X));
-      else
-         ureg_MUL(ureg, dst, src,
-                  ureg_scalar(mask, TGSI_SWIZZLE_W));
-   }
-}
-
-static struct ureg_src
-vs_normalize_coords(struct ureg_program *ureg, struct ureg_src coords,
-                    struct ureg_src const0, struct ureg_src const1)
-{
-   struct ureg_dst tmp = ureg_DECL_temporary(ureg);
-   struct ureg_src ret;
-   ureg_MAD(ureg, tmp, coords, const0, const1);
-   ret = ureg_src(tmp);
-   ureg_release_temporary(ureg, tmp);
-   return ret;
-}
-
-static void
-linear_gradient(struct ureg_program *ureg,
-                struct ureg_dst out,
-                struct ureg_src pos,
-                struct ureg_src sampler,
-                struct ureg_src coords,
-                struct ureg_src const0124,
-                struct ureg_src matrow0,
-                struct ureg_src matrow1,
-                struct ureg_src matrow2)
-{
-   struct ureg_dst temp0 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp1 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp2 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp3 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp4 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp5 = ureg_DECL_temporary(ureg);
-
-   ureg_MOV(ureg,
-            ureg_writemask(temp0, TGSI_WRITEMASK_XY), pos);
-   ureg_MOV(ureg,
-            ureg_writemask(temp0, TGSI_WRITEMASK_Z),
-            ureg_scalar(const0124, TGSI_SWIZZLE_Y));
-
-   ureg_DP3(ureg, temp1, matrow0, ureg_src(temp0));
-   ureg_DP3(ureg, temp2, matrow1, ureg_src(temp0));
-   ureg_DP3(ureg, temp3, matrow2, ureg_src(temp0));
-   ureg_RCP(ureg, temp3, ureg_src(temp3));
-   ureg_MUL(ureg, temp1, ureg_src(temp1), ureg_src(temp3));
-   ureg_MUL(ureg, temp2, ureg_src(temp2), ureg_src(temp3));
-
-   ureg_MOV(ureg, ureg_writemask(temp4, TGSI_WRITEMASK_X),
-            ureg_src(temp1));
-   ureg_MOV(ureg, ureg_writemask(temp4, TGSI_WRITEMASK_Y),
-            ureg_src(temp2));
-
-   ureg_MUL(ureg, temp0,
-            ureg_scalar(coords, TGSI_SWIZZLE_Y),
-            ureg_scalar(ureg_src(temp4), TGSI_SWIZZLE_Y));
-   ureg_MAD(ureg, temp1,
-            ureg_scalar(coords, TGSI_SWIZZLE_X),
-            ureg_scalar(ureg_src(temp4), TGSI_SWIZZLE_X),
-            ureg_src(temp0));
-
-   ureg_MUL(ureg, temp2,
-            ureg_src(temp1),
-            ureg_scalar(coords, TGSI_SWIZZLE_Z));
-
-   ureg_TEX(ureg, out,
-            TGSI_TEXTURE_1D, ureg_src(temp2), sampler);
-
-   ureg_release_temporary(ureg, temp0);
-   ureg_release_temporary(ureg, temp1);
-   ureg_release_temporary(ureg, temp2);
-   ureg_release_temporary(ureg, temp3);
-   ureg_release_temporary(ureg, temp4);
-   ureg_release_temporary(ureg, temp5);
-}
-
-
-static void
-radial_gradient(struct ureg_program *ureg,
-                struct ureg_dst out,
-                struct ureg_src pos,
-                struct ureg_src sampler,
-                struct ureg_src coords,
-                struct ureg_src const0124,
-                struct ureg_src matrow0,
-                struct ureg_src matrow1,
-                struct ureg_src matrow2)
-{
-   struct ureg_dst temp0 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp1 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp2 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp3 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp4 = ureg_DECL_temporary(ureg);
-   struct ureg_dst temp5 = ureg_DECL_temporary(ureg);
-
-   ureg_MOV(ureg,
-            ureg_writemask(temp0, TGSI_WRITEMASK_XY),
-            pos);
-   ureg_MOV(ureg,
-            ureg_writemask(temp0, TGSI_WRITEMASK_Z),
-            ureg_scalar(const0124, TGSI_SWIZZLE_Y));
-
-   ureg_DP3(ureg, temp1, matrow0, ureg_src(temp0));
-   ureg_DP3(ureg, temp2, matrow1, ureg_src(temp0));
-   ureg_DP3(ureg, temp3, matrow2, ureg_src(temp0));
-   ureg_RCP(ureg, temp3, ureg_src(temp3));
-   ureg_MUL(ureg, temp1, ureg_src(temp1), ureg_src(temp3));
-   ureg_MUL(ureg, temp2, ureg_src(temp2), ureg_src(temp3));
-
-   ureg_MOV(ureg, ureg_writemask(temp5, TGSI_WRITEMASK_X),
-            ureg_src(temp1));
-   ureg_MOV(ureg, ureg_writemask(temp5, TGSI_WRITEMASK_Y),
-            ureg_src(temp2));
-
-   ureg_MUL(ureg, temp0, ureg_scalar(coords, TGSI_SWIZZLE_Y),
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_Y));
-   ureg_MAD(ureg, temp1,
-            ureg_scalar(coords, TGSI_SWIZZLE_X),
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_X),
-            ureg_src(temp0));
-   ureg_ADD(ureg, temp1,
-            ureg_src(temp1), ureg_src(temp1));
-   ureg_MUL(ureg, temp3,
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_Y),
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_Y));
-   ureg_MAD(ureg, temp4,
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_X),
-            ureg_scalar(ureg_src(temp5), TGSI_SWIZZLE_X),
-            ureg_src(temp3));
-   ureg_MOV(ureg, temp4, ureg_negate(ureg_src(temp4)));
-   ureg_MUL(ureg, temp2,
-            ureg_scalar(coords, TGSI_SWIZZLE_Z),
-            ureg_src(temp4));
-   ureg_MUL(ureg, temp0,
-            ureg_scalar(const0124, TGSI_SWIZZLE_W),
-            ureg_src(temp2));
-   ureg_MUL(ureg, temp3,
-            ureg_src(temp1), ureg_src(temp1));
-   ureg_SUB(ureg, temp2,
-            ureg_src(temp3), ureg_src(temp0));
-   ureg_RSQ(ureg, temp2, ureg_abs(ureg_src(temp2)));
-   ureg_RCP(ureg, temp2, ureg_src(temp2));
-   ureg_SUB(ureg, temp1,
-            ureg_src(temp2), ureg_src(temp1));
-   ureg_ADD(ureg, temp0,
-            ureg_scalar(coords, TGSI_SWIZZLE_Z),
-            ureg_scalar(coords, TGSI_SWIZZLE_Z));
-   ureg_RCP(ureg, temp0, ureg_src(temp0));
-   ureg_MUL(ureg, temp2,
-            ureg_src(temp1), ureg_src(temp0));
-   ureg_TEX(ureg, out, TGSI_TEXTURE_1D,
-            ureg_src(temp2), sampler);
-
-   ureg_release_temporary(ureg, temp0);
-   ureg_release_temporary(ureg, temp1);
-   ureg_release_temporary(ureg, temp2);
-   ureg_release_temporary(ureg, temp3);
-   ureg_release_temporary(ureg, temp4);
-   ureg_release_temporary(ureg, temp5);
-}
-
-static void *
-create_vs(struct pipe_context *pipe,
-          unsigned vs_traits)
-{
-   struct ureg_program *ureg;
-   struct ureg_src src;
-   struct ureg_dst dst;
-   struct ureg_src const0, const1;
-   boolean is_fill = (vs_traits & VS_FILL) != 0;
-   boolean is_composite = (vs_traits & VS_COMPOSITE) != 0;
-   boolean has_mask = (vs_traits & VS_MASK) != 0;
-   boolean is_yuv = (vs_traits & VS_YUV) != 0;
-   unsigned input_slot = 0;
-
-   ureg = ureg_create(TGSI_PROCESSOR_VERTEX);
-   if (ureg == NULL)
-      return 0;
-
-   const0 = ureg_DECL_constant(ureg, 0);
-   const1 = ureg_DECL_constant(ureg, 1);
-
-   /* it has to be either a fill or a composite op */
-   debug_assert((is_fill ^ is_composite) ^ is_yuv);
-
-   src = ureg_DECL_vs_input(ureg, input_slot++);
-   dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_POSITION, 0);
-   src = vs_normalize_coords(ureg, src,
-                             const0, const1);
-   ureg_MOV(ureg, dst, src);
-
-   if (is_yuv) {
-      src = ureg_DECL_vs_input(ureg, input_slot++);
-      dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_GENERIC, 0);
-      ureg_MOV(ureg, dst, src);
-   }
-
-   if (is_composite) {
-      src = ureg_DECL_vs_input(ureg, input_slot++);
-      dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_GENERIC, 0);
-      ureg_MOV(ureg, dst, src);
-   }
-
-   if (is_fill) {
-      src = ureg_DECL_vs_input(ureg, input_slot++);
-      dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_COLOR, 0);
-      ureg_MOV(ureg, dst, src);
-   }
-
-   if (has_mask) {
-      src = ureg_DECL_vs_input(ureg, input_slot++);
-      dst = ureg_DECL_output(ureg, TGSI_SEMANTIC_GENERIC, 1);
-      ureg_MOV(ureg, dst, src);
-   }
-
-   ureg_END(ureg);
-
-   return ureg_create_shader_and_destroy(ureg, pipe);
-}
-
-static void *
-create_yuv_shader(struct pipe_context *pipe, struct ureg_program *ureg)
-{
-   struct ureg_src y_sampler, u_sampler, v_sampler;
-   struct ureg_src pos;
-   struct ureg_src matrow0, matrow1, matrow2;
-   struct ureg_dst y, u, v, rgb;
-   struct ureg_dst out = ureg_DECL_output(ureg,
-                                          TGSI_SEMANTIC_COLOR,
-                                          0);
-
-   pos = ureg_DECL_fs_input(ureg,
-                            TGSI_SEMANTIC_GENERIC,
-                            0,
-                            TGSI_INTERPOLATE_PERSPECTIVE);
-
-   rgb = ureg_DECL_temporary(ureg);
-   y = ureg_DECL_temporary(ureg);
-   u = ureg_DECL_temporary(ureg);
-   v = ureg_DECL_temporary(ureg);
-
-   y_sampler = ureg_DECL_sampler(ureg, 0);
-   u_sampler = ureg_DECL_sampler(ureg, 1);
-   v_sampler = ureg_DECL_sampler(ureg, 2);
-
-   matrow0 = ureg_DECL_constant(ureg, 0);
-   matrow1 = ureg_DECL_constant(ureg, 1);
-   matrow2 = ureg_DECL_constant(ureg, 2);
-
-   ureg_TEX(ureg, y,
-            TGSI_TEXTURE_2D, pos, y_sampler);
-   ureg_TEX(ureg, u,
-            TGSI_TEXTURE_2D, pos, u_sampler);
-   ureg_TEX(ureg, v,
-            TGSI_TEXTURE_2D, pos, v_sampler);
-
-   ureg_SUB(ureg, u, ureg_src(u),
-            ureg_scalar(matrow0, TGSI_SWIZZLE_W));
-   ureg_SUB(ureg, v, ureg_src(v),
-            ureg_scalar(matrow0, TGSI_SWIZZLE_W));
-
-   ureg_MUL(ureg, rgb,
-            ureg_scalar(ureg_src(y), TGSI_SWIZZLE_X),
-            matrow0);
-   ureg_MAD(ureg, rgb,
-            ureg_scalar(ureg_src(u), TGSI_SWIZZLE_X),
-            matrow1,
-            ureg_src(rgb));
-   ureg_MAD(ureg, rgb,
-            ureg_scalar(ureg_src(v), TGSI_SWIZZLE_X),
-            matrow2,
-            ureg_src(rgb));
-
-   /* rgb.a = 1; */
-   ureg_MOV(ureg, ureg_writemask(rgb, TGSI_WRITEMASK_W),
-            ureg_scalar(matrow0, TGSI_SWIZZLE_X));
-
-   ureg_MOV(ureg, out, ureg_src(rgb));
-
-   ureg_release_temporary(ureg, rgb);
-   ureg_release_temporary(ureg, y);
-   ureg_release_temporary(ureg, u);
-   ureg_release_temporary(ureg, v);
-
-   ureg_END(ureg);
-
-   return ureg_create_shader_and_destroy(ureg, pipe);
-}
-
-
-static INLINE void
-xrender_tex(struct ureg_program *ureg,
-            struct ureg_dst dst,
-            struct ureg_src coords,
-            struct ureg_src sampler,
-            struct ureg_src imm0,
-            boolean repeat_none,
-            boolean swizzle,
-            boolean set_alpha)
-{
-   if (repeat_none) {
-      struct ureg_dst tmp0 = ureg_DECL_temporary(ureg);
-      struct ureg_dst tmp1 = ureg_DECL_temporary(ureg);
-      ureg_SGT(ureg, tmp1, ureg_swizzle(coords,
-                                        TGSI_SWIZZLE_X,
-                                        TGSI_SWIZZLE_Y,
-                                        TGSI_SWIZZLE_X,
-                                        TGSI_SWIZZLE_Y),
-               ureg_scalar(imm0, TGSI_SWIZZLE_X));
-      ureg_SLT(ureg, tmp0, ureg_swizzle(coords,
-                                        TGSI_SWIZZLE_X,
-                                        TGSI_SWIZZLE_Y,
-                                        TGSI_SWIZZLE_X,
-                                        TGSI_SWIZZLE_Y),
-               ureg_scalar(imm0, TGSI_SWIZZLE_W));
-      ureg_MIN(ureg, tmp0, ureg_src(tmp0), ureg_src(tmp1));
-      ureg_MIN(ureg, tmp0, ureg_scalar(ureg_src(tmp0), TGSI_SWIZZLE_X),
-               ureg_scalar(ureg_src(tmp0), TGSI_SWIZZLE_Y));
-      ureg_TEX(ureg, tmp1, TGSI_TEXTURE_2D, coords, sampler);
-      if (swizzle)
-         ureg_MOV(ureg, tmp1, ureg_swizzle(ureg_src(tmp1),
-                                           TGSI_SWIZZLE_Z,
-                                           TGSI_SWIZZLE_Y,
-                                           TGSI_SWIZZLE_X,
-                                           TGSI_SWIZZLE_W));
-      if (set_alpha)
-         ureg_MOV(ureg,
-                  ureg_writemask(tmp1, TGSI_WRITEMASK_W),
-                  ureg_scalar(imm0, TGSI_SWIZZLE_W));
-      ureg_MUL(ureg, dst, ureg_src(tmp1), ureg_src(tmp0));
-      ureg_release_temporary(ureg, tmp0);
-      ureg_release_temporary(ureg, tmp1);
-   } else {
-      if (swizzle) {
-         struct ureg_dst tmp = ureg_DECL_temporary(ureg);
-         ureg_TEX(ureg, tmp, TGSI_TEXTURE_2D, coords, sampler);
-         ureg_MOV(ureg, dst, ureg_swizzle(ureg_src(tmp),
-                                          TGSI_SWIZZLE_Z,
-                                          TGSI_SWIZZLE_Y,
-                                          TGSI_SWIZZLE_X,
-                                          TGSI_SWIZZLE_W));
-         ureg_release_temporary(ureg, tmp);
-      } else {
-         ureg_TEX(ureg, dst, TGSI_TEXTURE_2D, coords, sampler);
-      }
-      if (set_alpha)
-         ureg_MOV(ureg,
-                  ureg_writemask(dst, TGSI_WRITEMASK_W),
-                  ureg_scalar(imm0, TGSI_SWIZZLE_W));
-   }
-}
-
-static void *
-create_fs(struct pipe_context *pipe,
-          unsigned fs_traits)
-{
-   struct ureg_program *ureg;
-   struct ureg_src /*dst_sampler,*/ src_sampler, mask_sampler;
-   struct ureg_src /*dst_pos,*/ src_input, mask_pos;
-   struct ureg_dst src, mask;
-   struct ureg_dst out;
-   struct ureg_src imm0 = { 0 };
-   unsigned has_mask = (fs_traits & FS_MASK) != 0;
-   unsigned is_fill = (fs_traits & FS_FILL) != 0;
-   unsigned is_composite = (fs_traits & FS_COMPOSITE) != 0;
-   unsigned is_solid   = (fs_traits & FS_SOLID_FILL) != 0;
-   unsigned is_lingrad = (fs_traits & FS_LINGRAD_FILL) != 0;
-   unsigned is_radgrad = (fs_traits & FS_RADGRAD_FILL) != 0;
-   unsigned comp_alpha_mask = fs_traits & FS_COMPONENT_ALPHA;
-   unsigned is_yuv = (fs_traits & FS_YUV) != 0;
-   unsigned src_repeat_none = (fs_traits & FS_SRC_REPEAT_NONE) != 0;
-   unsigned mask_repeat_none = (fs_traits & FS_MASK_REPEAT_NONE) != 0;
-   unsigned src_swizzle = (fs_traits & FS_SRC_SWIZZLE_RGB) != 0;
-   unsigned mask_swizzle = (fs_traits & FS_MASK_SWIZZLE_RGB) != 0;
-   unsigned src_set_alpha = (fs_traits & FS_SRC_SET_ALPHA) != 0;
-   unsigned mask_set_alpha = (fs_traits & FS_MASK_SET_ALPHA) != 0;
-   unsigned src_luminance = (fs_traits & FS_SRC_LUMINANCE) != 0;
-   unsigned mask_luminance = (fs_traits & FS_MASK_LUMINANCE) != 0;
-
-#if 0
-   print_fs_traits(fs_traits);
-#else
-   (void)print_fs_traits;
-#endif
-
-   ureg = ureg_create(TGSI_PROCESSOR_FRAGMENT);
-   if (ureg == NULL)
-      return 0;
-
-   /* it has to be either a fill, a composite op or a yuv conversion */
-   debug_assert((is_fill ^ is_composite) ^ is_yuv);
-   (void) is_yuv;
-
-   out = ureg_DECL_output(ureg,
-                          TGSI_SEMANTIC_COLOR,
-                          0);
-
-   if (src_repeat_none || mask_repeat_none ||
-       src_set_alpha || mask_set_alpha ||
-       src_luminance) {
-      imm0 = ureg_imm4f(ureg, 0, 0, 0, 1);
-   }
-   if (is_composite) {
-      src_sampler = ureg_DECL_sampler(ureg, 0);
-      src_input = ureg_DECL_fs_input(ureg,
-                                     TGSI_SEMANTIC_GENERIC,
-                                     0,
-                                     TGSI_INTERPOLATE_PERSPECTIVE);
-   } else if (is_fill) {
-      if (is_solid)
-         src_input = ureg_DECL_fs_input(ureg,
-                                        TGSI_SEMANTIC_COLOR,
-                                        0,
-                                        TGSI_INTERPOLATE_PERSPECTIVE);
-      else
-         src_input = ureg_DECL_fs_input(ureg,
-                                        TGSI_SEMANTIC_POSITION,
-                                        0,
-                                        TGSI_INTERPOLATE_PERSPECTIVE);
-   } else {
-      debug_assert(is_yuv);
-      return create_yuv_shader(pipe, ureg);
-   }
-
-   if (has_mask) {
-      mask_sampler = ureg_DECL_sampler(ureg, 1);
-      mask_pos = ureg_DECL_fs_input(ureg,
-                                    TGSI_SEMANTIC_GENERIC,
-                                    1,
-                                    TGSI_INTERPOLATE_PERSPECTIVE);
-   }
-
-#if 0  /* unused right now */
-   dst_sampler = ureg_DECL_sampler(ureg, 2);
-   dst_pos = ureg_DECL_fs_input(ureg,
-                                TGSI_SEMANTIC_POSITION,
-                                2,
-                                TGSI_INTERPOLATE_PERSPECTIVE);
-#endif
-
-
-   if (is_composite) {
-      if (has_mask || src_luminance)
-         src = ureg_DECL_temporary(ureg);
-      else
-         src = out;
-      xrender_tex(ureg, src, src_input, src_sampler, imm0,
-                  src_repeat_none, src_swizzle, src_set_alpha);
-   } else if (is_fill) {
-      if (is_solid) {
-         if (has_mask || src_luminance)
-            src = ureg_dst(src_input);
-         else
-            ureg_MOV(ureg, out, src_input);
-      } else if (is_lingrad || is_radgrad) {
-         struct ureg_src coords, const0124,
-            matrow0, matrow1, matrow2;
-
-         if (has_mask || src_luminance)
-            src = ureg_DECL_temporary(ureg);
-         else
-            src = out;
-
-         coords = ureg_DECL_constant(ureg, 0);
-         const0124 = ureg_DECL_constant(ureg, 1);
-         matrow0 = ureg_DECL_constant(ureg, 2);
-         matrow1 = ureg_DECL_constant(ureg, 3);
-         matrow2 = ureg_DECL_constant(ureg, 4);
-
-         if (is_lingrad) {
-            linear_gradient(ureg, src,
-                            src_input, src_sampler,
-                            coords, const0124,
-                            matrow0, matrow1, matrow2);
-         } else if (is_radgrad) {
-            radial_gradient(ureg, src,
-                            src_input, src_sampler,
-                            coords, const0124,
-                            matrow0, matrow1, matrow2);
-         }
-      } else
-         debug_assert(!"Unknown fill type!");
-   }
-   if (src_luminance) {
-      ureg_MOV(ureg, src,
-               ureg_scalar(ureg_src(src), TGSI_SWIZZLE_X));
-      ureg_MOV(ureg, ureg_writemask(src, TGSI_WRITEMASK_XYZ),
-               ureg_scalar(imm0, TGSI_SWIZZLE_X));
-      if (!has_mask)
-         ureg_MOV(ureg, out, ureg_src(src));
-   }
-
-   if (has_mask) {
-      mask = ureg_DECL_temporary(ureg);
-      xrender_tex(ureg, mask, mask_pos, mask_sampler, imm0,
-                  mask_repeat_none, mask_swizzle, mask_set_alpha);
-      /* src IN mask */
-      src_in_mask(ureg, out, ureg_src(src), ureg_src(mask),
-                  comp_alpha_mask, mask_luminance);
-      ureg_release_temporary(ureg, mask);
-   }
-
-   ureg_END(ureg);
-
-   return ureg_create_shader_and_destroy(ureg, pipe);
-}
-
-struct xorg_shaders * xorg_shaders_create(struct xorg_renderer *r)
-{
-   struct xorg_shaders *sc = CALLOC_STRUCT(xorg_shaders);
-
-   sc->r = r;
-   sc->vs_hash = cso_hash_create();
-   sc->fs_hash = cso_hash_create();
-
-   return sc;
-}
-
-static void
-cache_destroy(struct cso_context *cso,
-              struct cso_hash *hash,
-              unsigned processor)
-{
-   struct cso_hash_iter iter = cso_hash_first_node(hash);
-   while (!cso_hash_iter_is_null(iter)) {
-      void *shader = (void *)cso_hash_iter_data(iter);
-      if (processor == PIPE_SHADER_FRAGMENT) {
-         cso_delete_fragment_shader(cso, shader);
-      } else if (processor == PIPE_SHADER_VERTEX) {
-         cso_delete_vertex_shader(cso, shader);
-      }
-      iter = cso_hash_erase(hash, iter);
-   }
-   cso_hash_delete(hash);
-}
-
-void xorg_shaders_destroy(struct xorg_shaders *sc)
-{
-   cache_destroy(sc->r->cso, sc->vs_hash,
-                 PIPE_SHADER_VERTEX);
-   cache_destroy(sc->r->cso, sc->fs_hash,
-                 PIPE_SHADER_FRAGMENT);
-
-   FREE(sc);
-}
-
-static INLINE void *
-shader_from_cache(struct pipe_context *pipe,
-                  unsigned type,
-                  struct cso_hash *hash,
-                  unsigned key)
-{
-   void *shader = 0;
-
-   struct cso_hash_iter iter = cso_hash_find(hash, key);
-
-   if (cso_hash_iter_is_null(iter)) {
-      if (type == PIPE_SHADER_VERTEX)
-         shader = create_vs(pipe, key);
-      else
-         shader = create_fs(pipe, key);
-      cso_hash_insert(hash, key, shader);
-   } else
-      shader = (void *)cso_hash_iter_data(iter);
-
-   return shader;
-}
-
-struct xorg_shader xorg_shaders_get(struct xorg_shaders *sc,
-                                    unsigned vs_traits,
-                                    unsigned fs_traits)
-{
-   struct xorg_shader shader = { NULL, NULL };
-   void *vs, *fs;
-
-   vs = shader_from_cache(sc->r->pipe, PIPE_SHADER_VERTEX,
-                          sc->vs_hash, vs_traits);
-   fs = shader_from_cache(sc->r->pipe, PIPE_SHADER_FRAGMENT,
-                          sc->fs_hash, fs_traits);
-
-   debug_assert(vs && fs);
-   if (!vs || !fs)
-      return shader;
-
-   shader.vs = vs;
-   shader.fs = fs;
-
-   return shader;
-}
diff --git a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.h b/src/gallium/state_trackers/xorg/xorg_exa_tgsi.h
deleted file mode 100644
index 6f2a361..0000000
--- a/src/gallium/state_trackers/xorg/xorg_exa_tgsi.h
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifndef XORG_EXA_TGSI_H
-#define XORG_EXA_TGSI_H
-
-#include "xorg_renderer.h"
-
-enum xorg_vs_traits {
-   VS_COMPOSITE        = 1 << 0,
-   VS_MASK             = 1 << 1,
-   VS_SOLID_FILL       = 1 << 2,
-   VS_LINGRAD_FILL     = 1 << 3,
-   VS_RADGRAD_FILL     = 1 << 4,
-   VS_YUV              = 1 << 5,
-
-
-   VS_FILL             = (VS_SOLID_FILL |
-                          VS_LINGRAD_FILL |
-                          VS_RADGRAD_FILL)
-};
-
-enum xorg_fs_traits {
-   FS_COMPOSITE        = 1 << 0,
-   FS_MASK             = 1 << 1,
-   FS_SOLID_FILL       = 1 << 2,
-   FS_LINGRAD_FILL     = 1 << 3,
-   FS_RADGRAD_FILL     = 1 << 4,
-   FS_CA_FULL          = 1 << 5, /* src.rgba * mask.rgba */
-   FS_CA_SRCALPHA      = 1 << 6, /* src.aaaa * mask.rgba */
-   FS_YUV              = 1 << 7,
-   FS_SRC_REPEAT_NONE  = 1 << 8,
-   FS_MASK_REPEAT_NONE = 1 << 9,
-   FS_SRC_SWIZZLE_RGB  = 1 << 10,
-   FS_MASK_SWIZZLE_RGB = 1 << 11,
-   FS_SRC_SET_ALPHA    = 1 << 12,
-   FS_MASK_SET_ALPHA   = 1 << 13,
-   FS_SRC_LUMINANCE    = 1 << 14,
-   FS_MASK_LUMINANCE   = 1 << 15,
-
-   FS_FILL             = (FS_SOLID_FILL |
-                          FS_LINGRAD_FILL |
-                          FS_RADGRAD_FILL),
-   FS_COMPONENT_ALPHA  = (FS_CA_FULL |
-                          FS_CA_SRCALPHA)
-};
-
-struct xorg_shader {
-   void *fs;
-   void *vs;
-};
-
-struct xorg_shaders;
-
-struct xorg_shaders *xorg_shaders_create(struct xorg_renderer *renderer);
-void xorg_shaders_destroy(struct xorg_shaders *shaders);
-
-struct xorg_shader xorg_shaders_get(struct xorg_shaders *shaders,
-                                    unsigned vs_traits,
-                                    unsigned fs_traits);
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_output.c b/src/gallium/state_trackers/xorg/xorg_output.c
deleted file mode 100644
index dffc28e..0000000
--- a/src/gallium/state_trackers/xorg/xorg_output.c
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include "xorg-server.h"
-#include <xf86.h>
-#include <xf86i2c.h>
-#include <xf86Crtc.h>
-#include <xf86DDC.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include "xorg_tracker.h"
-
-struct output_private
-{
-    drmModeConnectorPtr drm_connector;
-    drmModePropertyBlobPtr edid_blob;
-    int fd;
-    int c;
-};
-
-static char *output_enum_list[] = {
-    "Unknown",
-    "VGA",
-    "DVI",
-    "DVI",
-    "DVI",
-    "Composite",
-    "SVIDEO",
-    "LVDS",
-    "CTV",
-    "DIN",
-    "DP",
-    "HDMI",
-    "HDMI",
-};
-
-static void
-output_create_resources(xf86OutputPtr output)
-{
-#ifdef RANDR_12_INTERFACE
-#endif /* RANDR_12_INTERFACE */
-}
-
-static void
-output_dpms(xf86OutputPtr output, int mode)
-{
-}
-
-static xf86OutputStatus
-output_detect(xf86OutputPtr output)
-{
-    modesettingPtr ms = modesettingPTR(output->scrn);
-    struct output_private *priv = output->driver_private;
-    drmModeConnectorPtr drm_connector;
-    xf86OutputStatus status;
-
-    drm_connector = drmModeGetConnector(ms->fd, priv->drm_connector->connector_id);
-    if (drm_connector) {
-	drmModeFreeConnector(priv->drm_connector);
-	priv->drm_connector = drm_connector;
-    } else {
-	drm_connector = priv->drm_connector;
-    }
-
-    switch (drm_connector->connection) {
-    case DRM_MODE_CONNECTED:
-	status = XF86OutputStatusConnected;
-	break;
-    case DRM_MODE_DISCONNECTED:
-	status = XF86OutputStatusDisconnected;
-	break;
-    default:
-	status = XF86OutputStatusUnknown;
-    }
-
-    return status;
-}
-
-static DisplayModePtr
-output_get_modes(xf86OutputPtr output)
-{
-    struct output_private *priv = output->driver_private;
-    drmModeConnectorPtr drm_connector = priv->drm_connector;
-    drmModeModeInfoPtr drm_mode = NULL;
-    drmModePropertyPtr props = NULL;
-    xf86MonPtr ddc_mon = NULL;
-    DisplayModePtr modes = NULL, mode = NULL;
-    int i;
-
-	for (i = 0; i < drm_connector->count_props; i++) {
-		props = drmModeGetProperty(priv->fd, drm_connector->props[i]);
-		if (!props)
-			continue;
-
-		if (!(props->flags & DRM_MODE_PROP_BLOB))
-			goto out_free;
-
-		if (!strcmp(props->name, "EDID")) {
-			if (priv->edid_blob)
-				drmModeFreePropertyBlob(priv->edid_blob);
-			priv->edid_blob = drmModeGetPropertyBlob(priv->fd,
-							  drm_connector->prop_values[i]);
-		}
-
-		out_free:
-		drmModeFreeProperty(props);
-	}
-
-	if (priv->edid_blob) {
-		ddc_mon = xf86InterpretEDID(output->scrn->scrnIndex,
-									priv->edid_blob->data);
-
-		if (ddc_mon && priv->edid_blob->length > 128)
-			ddc_mon->flags |= MONITOR_EDID_COMPLETE_RAWDATA;
-	}
-	xf86OutputSetEDID(output, ddc_mon);
-
-    for (i = 0; i < drm_connector->count_modes; i++) {
-	drm_mode = &drm_connector->modes[i];
-	if (drm_mode) {
-	    mode = calloc(1, sizeof(DisplayModeRec));
-	    if (!mode)
-		continue;
-	    mode->Clock = drm_mode->clock;
-	    mode->HDisplay = drm_mode->hdisplay;
-	    mode->HSyncStart = drm_mode->hsync_start;
-	    mode->HSyncEnd = drm_mode->hsync_end;
-	    mode->HTotal = drm_mode->htotal;
-	    mode->VDisplay = drm_mode->vdisplay;
-	    mode->VSyncStart = drm_mode->vsync_start;
-	    mode->VSyncEnd = drm_mode->vsync_end;
-	    mode->VTotal = drm_mode->vtotal;
-	    mode->Flags = drm_mode->flags;
-	    mode->HSkew = drm_mode->hskew;
-	    mode->VScan = drm_mode->vscan;
-	    mode->VRefresh = xf86ModeVRefresh(mode);
-	    mode->Private = (void *)drm_mode;
-	    mode->type = 0;
-	    if (drm_mode->type & DRM_MODE_TYPE_PREFERRED)
-		mode->type |= M_T_PREFERRED;
-	    if (drm_mode->type & DRM_MODE_TYPE_DRIVER)
-		mode->type |= M_T_DRIVER;
-	    xf86SetModeDefaultName(mode);
-	    modes = xf86ModesAdd(modes, mode);
-	    xf86PrintModeline(0, mode);
-	}
-    }
-
-    return modes;
-}
-
-static int
-output_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
-{
-    modesettingPtr ms = modesettingPTR(output->scrn);
-    CustomizerPtr cust = ms->cust;
-
-    if (cust && cust->winsys_check_fb_size &&
-	!cust->winsys_check_fb_size(cust, pMode->HDisplay *
-				    output->scrn->bitsPerPixel / 8,
-				    pMode->VDisplay))
-	return MODE_BAD;
-
-    return MODE_OK;
-}
-
-#ifdef RANDR_12_INTERFACE
-static Bool
-output_set_property(xf86OutputPtr output, Atom property, RRPropertyValuePtr value)
-{
-    return TRUE;
-}
-#endif /* RANDR_12_INTERFACE */
-
-#ifdef RANDR_13_INTERFACE
-static Bool
-output_get_property(xf86OutputPtr output, Atom property)
-{
-    return TRUE;
-}
-#endif /* RANDR_13_INTERFACE */
-
-static void
-output_destroy(xf86OutputPtr output)
-{
-    struct output_private *priv = output->driver_private;
-    if (priv->edid_blob)
-		drmModeFreePropertyBlob(priv->edid_blob);
-    drmModeFreeConnector(priv->drm_connector);
-    free(priv);
-    output->driver_private = NULL;
-}
-
-static const xf86OutputFuncsRec output_funcs = {
-    .create_resources = output_create_resources,
-#ifdef RANDR_12_INTERFACE
-    .set_property = output_set_property,
-#endif
-#ifdef RANDR_13_INTERFACE
-    .get_property = output_get_property,
-#endif
-    .dpms = output_dpms,
-    .detect = output_detect,
-
-    .get_modes = output_get_modes,
-    .mode_valid = output_mode_valid,
-    .destroy = output_destroy,
-};
-
-void
-xorg_output_init(ScrnInfoPtr pScrn)
-{
-    modesettingPtr ms = modesettingPTR(pScrn);
-    xf86OutputPtr output;
-    drmModeResPtr res;
-    drmModeConnectorPtr drm_connector = NULL;
-    drmModeEncoderPtr drm_encoder = NULL;
-    struct output_private *priv;
-    char name[32];
-    int c, v, p;
-
-    res = drmModeGetResources(ms->fd);
-    if (res == 0) {
-	DRV_ERROR("Failed drmModeGetResources\n");
-	return;
-    }
-
-    for (c = 0; c < res->count_connectors; c++) {
-	drm_connector = drmModeGetConnector(ms->fd, res->connectors[c]);
-	if (!drm_connector)
-	    goto out;
-
-#if 0
-	for (p = 0; p < drm_connector->count_props; p++) {
-	    drmModePropertyPtr prop;
-
-	    prop = drmModeGetProperty(ms->fd, drm_connector->props[p]);
-
-	    name = NULL;
-	    if (prop) {
-		ErrorF("VALUES %d\n", prop->count_values);
-
-		for (v = 0; v < prop->count_values; v++)
-		    ErrorF("%s %lld\n", prop->name, prop->values[v]);
-	    }
-	}
-#else
-	(void)p;
-	(void)v;
-#endif
-
-	snprintf(name, 32, "%s%d",
-		 output_enum_list[drm_connector->connector_type],
-		 drm_connector->connector_type_id);
-
-
-	priv = calloc(sizeof(*priv), 1);
-	if (!priv) {
-	    continue;
-	}
-
-	output = xf86OutputCreate(pScrn, &output_funcs, name);
-	if (!output) {
-	    free(priv);
-	    continue;
-	}
-
-	drm_encoder = drmModeGetEncoder(ms->fd, drm_connector->encoders[0]);
-	if (drm_encoder) {
-	    output->possible_crtcs = drm_encoder->possible_crtcs;
-	    output->possible_clones = drm_encoder->possible_clones;
-	} else {
-	    output->possible_crtcs = 0;
-	    output->possible_clones = 0;
-	}
-	priv->c = c;
-	priv->drm_connector = drm_connector;
-	priv->fd = ms->fd;
-	output->driver_private = priv;
-	output->subpixel_order = SubPixelHorizontalRGB;
-	output->interlaceAllowed = FALSE;
-	output->doubleScanAllowed = FALSE;
-    }
-
-  out:
-    drmModeFreeResources(res);
-}
-
-unsigned
-xorg_output_get_id(xf86OutputPtr output)
-{
-    struct output_private *priv = output->driver_private;
-    return priv->drm_connector->connector_id;
-}
-
-/* vim: set sw=4 ts=8 sts=4: */
diff --git a/src/gallium/state_trackers/xorg/xorg_renderer.c b/src/gallium/state_trackers/xorg/xorg_renderer.c
deleted file mode 100644
index 563e7e7..0000000
--- a/src/gallium/state_trackers/xorg/xorg_renderer.c
+++ /dev/null
@@ -1,547 +0,0 @@
-#include "xorg_exa.h"
-#include "xorg_renderer.h"
-
-#include "xorg_exa_tgsi.h"
-
-#include "cso_cache/cso_context.h"
-#include "util/u_draw_quad.h"
-#include "util/u_math.h"
-#include "util/u_memory.h"
-#include "util/u_sampler.h"
-
-#include "util/u_inlines.h"
-#include "util/u_box.h"
-
-#include <math.h>
-
-#define floatsEqual(x, y) (fabs(x - y) <= 0.00001f * MIN2(fabs(x), fabs(y)))
-#define floatIsZero(x) (floatsEqual((x) + 1, 1))
-
-#define NUM_COMPONENTS 4
-
-static INLINE boolean is_affine(float *matrix)
-{
-   return floatIsZero(matrix[2]) && floatIsZero(matrix[5])
-      && floatsEqual(matrix[8], 1);
-}
-static INLINE void map_point(float *mat, float x, float y,
-                             float *out_x, float *out_y)
-{
-   if (!mat) {
-      *out_x = x;
-      *out_y = y;
-      return;
-   }
-
-   *out_x = mat[0]*x + mat[3]*y + mat[6];
-   *out_y = mat[1]*x + mat[4]*y + mat[7];
-   if (!is_affine(mat)) {
-      float w = 1/(mat[2]*x + mat[5]*y + mat[8]);
-      *out_x *= w;
-      *out_y *= w;
-   }
-}
-
-static INLINE void
-renderer_draw(struct xorg_renderer *r)
-{
-   int num_verts = r->buffer_size/(r->attrs_per_vertex * NUM_COMPONENTS);
-
-   if (!r->buffer_size)
-      return;
-
-   cso_set_vertex_elements(r->cso, r->attrs_per_vertex, r->velems);
-   util_draw_user_vertex_buffer(r->cso, r->buffer, PIPE_PRIM_QUADS,
-                                num_verts, r->attrs_per_vertex);
-
-   r->buffer_size = 0;
-}
-
-static INLINE void
-renderer_draw_conditional(struct xorg_renderer *r,
-                          int next_batch)
-{
-   if (r->buffer_size + next_batch >= BUF_SIZE ||
-       (next_batch == 0 && r->buffer_size)) {
-      renderer_draw(r);
-   }
-}
-
-static void
-renderer_init_state(struct xorg_renderer *r)
-{
-   struct pipe_depth_stencil_alpha_state dsa;
-   struct pipe_rasterizer_state raster;
-   unsigned i;
-
-   /* set common initial clip state */
-   memset(&dsa, 0, sizeof(struct pipe_depth_stencil_alpha_state));
-   cso_set_depth_stencil_alpha(r->cso, &dsa);
-
-
-   /* XXX: move to renderer_init_state? */
-   memset(&raster, 0, sizeof(struct pipe_rasterizer_state));
-   raster.half_pixel_center = 1;
-   raster.bottom_edge_rule = 1;
-   raster.depth_clip = 1;
-   cso_set_rasterizer(r->cso, &raster);
-
-   /* vertex elements state */
-   memset(&r->velems[0], 0, sizeof(r->velems[0]) * 3);
-   for (i = 0; i < 3; i++) {
-      r->velems[i].src_offset = i * 4 * sizeof(float);
-      r->velems[i].instance_divisor = 0;
-      r->velems[i].vertex_buffer_index = 0;
-      r->velems[i].src_format = PIPE_FORMAT_R32G32B32A32_FLOAT;
-   }
-}
-
-
-static INLINE void
-add_vertex_color(struct xorg_renderer *r,
-                 float x, float y,
-                 float color[4])
-{
-   float *vertex = r->buffer + r->buffer_size;
-
-   vertex[0] = x;
-   vertex[1] = y;
-   vertex[2] = 0.f; /*z*/
-   vertex[3] = 1.f; /*w*/
-
-   vertex[4] = color[0]; /*r*/
-   vertex[5] = color[1]; /*g*/
-   vertex[6] = color[2]; /*b*/
-   vertex[7] = color[3]; /*a*/
-
-   r->buffer_size += 8;
-}
-
-static INLINE void
-add_vertex_1tex(struct xorg_renderer *r,
-                float x, float y, float s, float t)
-{
-   float *vertex = r->buffer + r->buffer_size;
-
-   vertex[0] = x;
-   vertex[1] = y;
-   vertex[2] = 0.f; /*z*/
-   vertex[3] = 1.f; /*w*/
-
-   vertex[4] = s;   /*s*/
-   vertex[5] = t;   /*t*/
-   vertex[6] = 0.f; /*r*/
-   vertex[7] = 1.f; /*q*/
-
-   r->buffer_size += 8;
-}
-
-static void
-add_vertex_data1(struct xorg_renderer *r,
-                 float srcX, float srcY,  float dstX, float dstY,
-                 float width, float height,
-                 struct pipe_resource *src, float *src_matrix)
-{
-   float s0, t0, s1, t1, s2, t2, s3, t3;
-   float pt0[2], pt1[2], pt2[2], pt3[2];
-
-   pt0[0] = srcX;
-   pt0[1] = srcY;
-   pt1[0] = (srcX + width);
-   pt1[1] = srcY;
-   pt2[0] = (srcX + width);
-   pt2[1] = (srcY + height);
-   pt3[0] = srcX;
-   pt3[1] = (srcY + height);
-
-   if (src_matrix) {
-      map_point(src_matrix, pt0[0], pt0[1], &pt0[0], &pt0[1]);
-      map_point(src_matrix, pt1[0], pt1[1], &pt1[0], &pt1[1]);
-      map_point(src_matrix, pt2[0], pt2[1], &pt2[0], &pt2[1]);
-      map_point(src_matrix, pt3[0], pt3[1], &pt3[0], &pt3[1]);
-   }
-
-   s0 =  pt0[0] / src->width0;
-   s1 =  pt1[0] / src->width0;
-   s2 =  pt2[0] / src->width0;
-   s3 =  pt3[0] / src->width0;
-   t0 =  pt0[1] / src->height0;
-   t1 =  pt1[1] / src->height0;
-   t2 =  pt2[1] / src->height0;
-   t3 =  pt3[1] / src->height0;
-
-   /* 1st vertex */
-   add_vertex_1tex(r, dstX, dstY, s0, t0);
-   /* 2nd vertex */
-   add_vertex_1tex(r, dstX + width, dstY, s1, t1);
-   /* 3rd vertex */
-   add_vertex_1tex(r, dstX + width, dstY + height, s2, t2);
-   /* 4th vertex */
-   add_vertex_1tex(r, dstX, dstY + height, s3, t3);
-}
-
-
-static INLINE void
-add_vertex_2tex(struct xorg_renderer *r,
-                float x, float y,
-                float s0, float t0, float s1, float t1)
-{
-   float *vertex = r->buffer + r->buffer_size;
-
-   vertex[0] = x;
-   vertex[1] = y;
-   vertex[2] = 0.f; /*z*/
-   vertex[3] = 1.f; /*w*/
-
-   vertex[4] = s0;  /*s*/
-   vertex[5] = t0;  /*t*/
-   vertex[6] = 0.f; /*r*/
-   vertex[7] = 1.f; /*q*/
-
-   vertex[8] = s1;  /*s*/
-   vertex[9] = t1;  /*t*/
-   vertex[10] = 0.f; /*r*/
-   vertex[11] = 1.f; /*q*/
-
-   r->buffer_size += 12;
-}
-
-static void
-add_vertex_data2(struct xorg_renderer *r,
-                 float srcX, float srcY, float maskX, float maskY,
-                 float dstX, float dstY, float width, float height,
-                 struct pipe_resource *src,
-                 struct pipe_resource *mask,
-                 float *src_matrix, float *mask_matrix)
-{
-   float src_s0, src_t0, src_s1, src_t1, src_s2, src_t2, src_s3, src_t3;
-   float mask_s0, mask_t0, mask_s1, mask_t1, mask_s2, mask_t2, mask_s3, mask_t3;
-   float spt0[2], spt1[2], spt2[2], spt3[2];
-   float mpt0[2], mpt1[2], mpt2[2], mpt3[2];
-
-   spt0[0] = srcX;
-   spt0[1] = srcY;
-   spt1[0] = (srcX + width);
-   spt1[1] = srcY;
-   spt2[0] = (srcX + width);
-   spt2[1] = (srcY + height);
-   spt3[0] = srcX;
-   spt3[1] = (srcY + height);
-
-   mpt0[0] = maskX;
-   mpt0[1] = maskY;
-   mpt1[0] = (maskX + width);
-   mpt1[1] = maskY;
-   mpt2[0] = (maskX + width);
-   mpt2[1] = (maskY + height);
-   mpt3[0] = maskX;
-   mpt3[1] = (maskY + height);
-
-   if (src_matrix) {
-      map_point(src_matrix, spt0[0], spt0[1], &spt0[0], &spt0[1]);
-      map_point(src_matrix, spt1[0], spt1[1], &spt1[0], &spt1[1]);
-      map_point(src_matrix, spt2[0], spt2[1], &spt2[0], &spt2[1]);
-      map_point(src_matrix, spt3[0], spt3[1], &spt3[0], &spt3[1]);
-   }
-
-   if (mask_matrix) {
-      map_point(mask_matrix, mpt0[0], mpt0[1], &mpt0[0], &mpt0[1]);
-      map_point(mask_matrix, mpt1[0], mpt1[1], &mpt1[0], &mpt1[1]);
-      map_point(mask_matrix, mpt2[0], mpt2[1], &mpt2[0], &mpt2[1]);
-      map_point(mask_matrix, mpt3[0], mpt3[1], &mpt3[0], &mpt3[1]);
-   }
-
-   src_s0 =  spt0[0] / src->width0;
-   src_s1 =  spt1[0] / src->width0;
-   src_s2 =  spt2[0] / src->width0;
-   src_s3 =  spt3[0] / src->width0;
-   src_t0 =  spt0[1] / src->height0;
-   src_t1 =  spt1[1] / src->height0;
-   src_t2 =  spt2[1] / src->height0;
-   src_t3 =  spt3[1] / src->height0;
-
-   mask_s0 =  mpt0[0] / mask->width0;
-   mask_s1 =  mpt1[0] / mask->width0;
-   mask_s2 =  mpt2[0] / mask->width0;
-   mask_s3 =  mpt3[0] / mask->width0;
-   mask_t0 =  mpt0[1] / mask->height0;
-   mask_t1 =  mpt1[1] / mask->height0;
-   mask_t2 =  mpt2[1] / mask->height0;
-   mask_t3 =  mpt3[1] / mask->height0;
-
-   /* 1st vertex */
-   add_vertex_2tex(r, dstX, dstY,
-                   src_s0, src_t0, mask_s0, mask_t0);
-   /* 2nd vertex */
-   add_vertex_2tex(r, dstX + width, dstY,
-                   src_s1, src_t1, mask_s1, mask_t1);
-   /* 3rd vertex */
-   add_vertex_2tex(r, dstX + width, dstY + height,
-                   src_s2, src_t2, mask_s2, mask_t2);
-   /* 4th vertex */
-   add_vertex_2tex(r, dstX, dstY + height,
-                   src_s3, src_t3, mask_s3, mask_t3);
-}
-
-static void
-setup_vertex_data_yuv(struct xorg_renderer *r,
-                      float srcX, float srcY, float srcW, float srcH,
-                      float dstX, float dstY, float dstW, float dstH,
-                      struct pipe_resource **tex)
-{
-   float s0, t0, s1, t1;
-   float spt0[2], spt1[2];
-
-   spt0[0] = srcX;
-   spt0[1] = srcY;
-   spt1[0] = srcX + srcW;
-   spt1[1] = srcY + srcH;
-
-   s0 = spt0[0] / tex[0]->width0;
-   t0 = spt0[1] / tex[0]->height0;
-   s1 = spt1[0] / tex[0]->width0;
-   t1 = spt1[1] / tex[0]->height0;
-
-   /* 1st vertex */
-   add_vertex_1tex(r, dstX, dstY, s0, t0);
-   /* 2nd vertex */
-   add_vertex_1tex(r, dstX + dstW, dstY,
-                   s1, t0);
-   /* 3rd vertex */
-   add_vertex_1tex(r, dstX + dstW, dstY + dstH,
-                   s1, t1);
-   /* 4th vertex */
-   add_vertex_1tex(r, dstX, dstY + dstH,
-                   s0, t1);
-}
-
-
-
-/* Set up framebuffer, viewport and vertex shader constant buffer
- * state for a particular destinaton surface.  In all our rendering,
- * these concepts are linked.
- */
-void renderer_bind_destination(struct xorg_renderer *r,
-                               struct pipe_surface *surface,
-                               int width,
-                               int height )
-{
-
-   struct pipe_framebuffer_state fb;
-   struct pipe_viewport_state viewport;
-
-   /* Framebuffer uses actual surface width/height
-    */
-   memset(&fb, 0, sizeof fb);
-   fb.width  = surface->width;
-   fb.height = surface->height;
-   fb.nr_cbufs = 1;
-   fb.cbufs[0] = surface;
-   fb.zsbuf = 0;
-
-   /* Viewport just touches the bit we're interested in:
-    */
-   viewport.scale[0] =  width / 2.f;
-   viewport.scale[1] =  height / 2.f;
-   viewport.scale[2] =  1.0;
-   viewport.scale[3] =  1.0;
-   viewport.translate[0] = width / 2.f;
-   viewport.translate[1] = height / 2.f;
-   viewport.translate[2] = 0.0;
-   viewport.translate[3] = 0.0;
-
-   /* Constant buffer set up to match viewport dimensions:
-    */
-   if (r->fb_width != width ||
-       r->fb_height != height) 
-   {
-      float vs_consts[8] = {
-         2.f/width, 2.f/height, 1, 1,
-         -1, -1, 0, 0
-      };
-
-      r->fb_width = width;
-      r->fb_height = height;
-
-      renderer_set_constants(r, PIPE_SHADER_VERTEX,
-                             vs_consts, sizeof vs_consts);
-   }
-
-   cso_set_framebuffer(r->cso, &fb);
-   cso_set_viewport(r->cso, &viewport);
-}
-
-
-struct xorg_renderer * renderer_create(struct pipe_context *pipe)
-{
-   struct xorg_renderer *renderer = CALLOC_STRUCT(xorg_renderer);
-
-   renderer->pipe = pipe;
-   renderer->cso = cso_create_context(pipe);
-   renderer->shaders = xorg_shaders_create(renderer);
-
-   renderer_init_state(renderer);
-
-   return renderer;
-}
-
-void renderer_destroy(struct xorg_renderer *r)
-{
-   struct pipe_resource **vsbuf = &r->vs_const_buffer;
-   struct pipe_resource **fsbuf = &r->fs_const_buffer;
-
-   if (*vsbuf)
-      pipe_resource_reference(vsbuf, NULL);
-
-   if (*fsbuf)
-      pipe_resource_reference(fsbuf, NULL);
-
-   if (r->shaders) {
-      xorg_shaders_destroy(r->shaders);
-      r->shaders = NULL;
-   }
-
-   if (r->cso) {
-      cso_release_all(r->cso);
-      cso_destroy_context(r->cso);
-      r->cso = NULL;
-   }
-}
-
-
-
-
-
-void renderer_set_constants(struct xorg_renderer *r,
-                            int shader_type,
-                            const float *params,
-                            int param_bytes)
-{
-   struct pipe_resource **cbuf =
-      (shader_type == PIPE_SHADER_VERTEX) ? &r->vs_const_buffer :
-      &r->fs_const_buffer;
-
-   pipe_resource_reference(cbuf, NULL);
-   *cbuf = pipe_buffer_create(r->pipe->screen,
-                              PIPE_BIND_CONSTANT_BUFFER,
-                              PIPE_USAGE_STATIC,
-                              param_bytes);
-
-   if (*cbuf) {
-      pipe_buffer_write(r->pipe, *cbuf,
-                        0, param_bytes, params);
-   }
-   pipe_set_constant_buffer(r->pipe, shader_type, 0, *cbuf);
-}
-
-
-
-void renderer_draw_yuv(struct xorg_renderer *r,
-                       float src_x, float src_y, float src_w, float src_h,
-                       int dst_x, int dst_y, int dst_w, int dst_h,
-                       struct pipe_resource **textures)
-{
-   const int num_attribs = 2; /*pos + tex coord*/
-
-   setup_vertex_data_yuv(r,
-                         src_x, src_y, src_w, src_h,
-                         dst_x, dst_y, dst_w, dst_h,
-                         textures);
-
-   cso_set_vertex_elements(r->cso, num_attribs, r->velems);
-
-   util_draw_user_vertex_buffer(r->cso, r->buffer,
-                                PIPE_PRIM_QUADS,
-                                4,  /* verts */
-                                num_attribs); /* attribs/vert */
-
-   r->buffer_size = 0;
-}
-
-void renderer_begin_solid(struct xorg_renderer *r)
-{
-   r->buffer_size = 0;
-   r->attrs_per_vertex = 2;
-}
-
-void renderer_solid(struct xorg_renderer *r,
-                    int x0, int y0,
-                    int x1, int y1,
-                    float *color)
-{
-   /*
-   debug_printf("solid rect[(%d, %d), (%d, %d)], rgba[%f, %f, %f, %f]\n",
-   x0, y0, x1, y1, color[0], color[1], color[2], color[3]);*/
-
-   renderer_draw_conditional(r, 4 * 8);
-
-   /* 1st vertex */
-   add_vertex_color(r, x0, y0, color);
-   /* 2nd vertex */
-   add_vertex_color(r, x1, y0, color);
-   /* 3rd vertex */
-   add_vertex_color(r, x1, y1, color);
-   /* 4th vertex */
-   add_vertex_color(r, x0, y1, color);
-}
-
-void renderer_draw_flush(struct xorg_renderer *r)
-{
-   renderer_draw_conditional(r, 0);
-}
-
-void renderer_begin_textures(struct xorg_renderer *r,
-                             int num_textures)
-{
-   r->attrs_per_vertex = 1 + num_textures;
-   r->buffer_size = 0;
-}
-
-void renderer_texture(struct xorg_renderer *r,
-                      int *pos,
-                      int width, int height,
-                      struct pipe_sampler_view **sampler_view,
-                      int num_textures,
-                      float *src_matrix,
-                      float *mask_matrix)
-{
-
-#if 0
-   if (src_matrix) {
-      debug_printf("src_matrix = \n");
-      debug_printf("%f, %f, %f\n", src_matrix[0], src_matrix[1], src_matrix[2]);
-      debug_printf("%f, %f, %f\n", src_matrix[3], src_matrix[4], src_matrix[5]);
-      debug_printf("%f, %f, %f\n", src_matrix[6], src_matrix[7], src_matrix[8]);
-   }
-   if (mask_matrix) {
-      debug_printf("mask_matrix = \n");
-      debug_printf("%f, %f, %f\n", mask_matrix[0], mask_matrix[1], mask_matrix[2]);
-      debug_printf("%f, %f, %f\n", mask_matrix[3], mask_matrix[4], mask_matrix[5]);
-      debug_printf("%f, %f, %f\n", mask_matrix[6], mask_matrix[7], mask_matrix[8]);
-   }
-#endif
-
-   switch(r->attrs_per_vertex) {
-   case 2:
-      renderer_draw_conditional(r, 4 * 8);
-      add_vertex_data1(r,
-                       pos[0], pos[1], /* src */
-                       pos[4], pos[5], /* dst */
-                       width, height,
-                       sampler_view[0]->texture, src_matrix);
-      break;
-   case 3:
-      renderer_draw_conditional(r, 4 * 12);
-      add_vertex_data2(r,
-                       pos[0], pos[1], /* src */
-                       pos[2], pos[3], /* mask */
-                       pos[4], pos[5], /* dst */
-                       width, height,
-                       sampler_view[0]->texture, sampler_view[1]->texture,
-                       src_matrix, mask_matrix);
-      break;
-   default:
-      debug_assert(!"Unsupported number of textures");
-      break;
-   }
-}
diff --git a/src/gallium/state_trackers/xorg/xorg_renderer.h b/src/gallium/state_trackers/xorg/xorg_renderer.h
deleted file mode 100644
index b652aeb..0000000
--- a/src/gallium/state_trackers/xorg/xorg_renderer.h
+++ /dev/null
@@ -1,81 +0,0 @@
-#ifndef XORG_RENDERER_H
-#define XORG_RENDERER_H
-
-#include "pipe/p_context.h"
-#include "pipe/p_state.h"
-
-struct xorg_shaders;
-struct exa_pixmap_priv;
-
-/* max number of vertices *
- * max number of attributes per vertex *
- * max number of components per attribute
- *
- * currently the max is 100 quads
- */
-#define BUF_SIZE (100 * 4 * 3 * 4)
-
-struct xorg_renderer {
-   struct pipe_context *pipe;
-
-   struct cso_context *cso;
-   struct xorg_shaders *shaders;
-
-   int fb_width;
-   int fb_height;
-   struct pipe_resource *vs_const_buffer;
-   struct pipe_resource *fs_const_buffer;
-
-   float buffer[BUF_SIZE];
-   int buffer_size;
-   struct pipe_vertex_element velems[3];
-
-   /* number of attributes per vertex for the current
-    * draw operation */
-   int attrs_per_vertex;
-};
-
-struct xorg_renderer *renderer_create(struct pipe_context *pipe);
-void renderer_destroy(struct xorg_renderer *renderer);
-
-void renderer_bind_destination(struct xorg_renderer *r,
-                               struct pipe_surface *surface,
-                               int width,
-                               int height );
-
-void renderer_bind_framebuffer(struct xorg_renderer *r,
-                               struct exa_pixmap_priv *priv);
-void renderer_bind_viewport(struct xorg_renderer *r,
-                            struct exa_pixmap_priv *dst);
-void renderer_set_constants(struct xorg_renderer *r,
-                            int shader_type,
-                            const float *buffer,
-                            int size);
-
-
-void renderer_draw_yuv(struct xorg_renderer *r,
-                       float src_x, float src_y, float src_w, float src_h,
-                       int dst_x, int dst_y, int dst_w, int dst_h,
-                       struct pipe_resource **textures);
-
-void renderer_begin_solid(struct xorg_renderer *r);
-void renderer_solid(struct xorg_renderer *r,
-                    int x0, int y0,
-                    int x1, int y1,
-                    float *color);
-
-void renderer_begin_textures(struct xorg_renderer *r,
-                             int num_textures);
-
-void renderer_texture(struct xorg_renderer *r,
-                      int *pos,
-                      int width, int height,
-                      struct pipe_sampler_view **textures,
-                      int num_textures,
-                      float *src_matrix,
-                      float *mask_matrix);
-
-void renderer_draw_flush(struct xorg_renderer *r);
-
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_tracker.h b/src/gallium/state_trackers/xorg/xorg_tracker.h
deleted file mode 100644
index 96f1a77..0000000
--- a/src/gallium/state_trackers/xorg/xorg_tracker.h
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#ifndef _XORG_TRACKER_H_
-#define _XORG_TRACKER_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <errno.h>
-#include <drm.h>
-#include <xf86drm.h>
-#include <xf86drmMode.h>
-#include <xorg-server.h>
-#include <xf86.h>
-#include "xf86Crtc.h"
-#include <exa.h>
-
-#ifdef DRM_MODE_FEATURE_DIRTYFB
-#include <damage.h>
-#endif
-
-/* Prevent symbol clash */
-#undef Absolute
-
-#include "compat-api.h"
-#include "pipe/p_screen.h"
-#include "util/u_inlines.h"
-#include "util/u_debug.h"
-
-#define DRV_ERROR(msg)	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, msg);
-
-struct kms_bo;
-struct kms_driver;
-struct exa_context;
-
-typedef struct
-{
-    int lastInstance;
-    int refCount;
-    ScrnInfoPtr pScrn_1;
-    ScrnInfoPtr pScrn_2;
-} EntRec, *EntPtr;
-
-#define XORG_NR_FENCES 3
-
-enum xorg_throttling_reason {
-    THROTTLE_RENDER,
-    THROTTLE_SWAP
-};
-
-typedef struct _CustomizerRec
-{
-    Bool dirty_throttling;
-    Bool swap_throttling;
-    Bool no_3d;
-    Bool unhidden_hw_cursor_update;
-    Bool (*winsys_pre_init) (struct _CustomizerRec *cust, int fd);
-    Bool (*winsys_screen_init)(struct _CustomizerRec *cust);
-    Bool (*winsys_screen_close)(struct _CustomizerRec *cust);
-    Bool (*winsys_enter_vt)(struct _CustomizerRec *cust);
-    Bool (*winsys_leave_vt)(struct _CustomizerRec *cust);
-    void (*winsys_context_throttle)(struct _CustomizerRec *cust,
-				    struct pipe_context *pipe,
-				    enum xorg_throttling_reason reason);
-    Bool (*winsys_check_fb_size) (struct _CustomizerRec *cust,
-				  unsigned long pitch,
-				  unsigned long height);
-} CustomizerRec, *CustomizerPtr;
-
-typedef struct _modesettingRec
-{
-    /* drm */
-    int fd;
-    unsigned fb_id;
-
-    /* X */
-    EntPtr entityPrivate;
-
-    int Chipset;
-    EntityInfoPtr pEnt;
-    struct pci_device *PciInfo;
-
-    Bool noAccel;
-    Bool SWCursor;
-    CursorPtr cursor;
-    Bool swapThrottling;
-    Bool dirtyThrottling;
-    CloseScreenProcPtr CloseScreen;
-    Bool no3D;
-    Bool from_3D;
-    Bool isMaster;
-
-    /* Broken-out options. */
-    OptionInfoPtr Options;
-
-    void (*blockHandler)(BLOCKHANDLER_ARGS_DECL);
-    struct pipe_fence_handle *fence[XORG_NR_FENCES];
-
-    CreateScreenResourcesProcPtr createScreenResources;
-
-    /* for frontbuffer backing store */
-    Bool (*destroy_front_buffer)(ScrnInfoPtr pScrn);
-    Bool (*create_front_buffer)(ScrnInfoPtr pScrn);
-    Bool (*bind_front_buffer)(ScrnInfoPtr pScrn);
-
-    /* kms */
-    struct kms_driver *kms;
-    struct kms_bo *root_bo;
-    uint16_t lut_r[256], lut_g[256], lut_b[256];
-
-    /* gallium */
-    struct pipe_screen *screen;
-    struct pipe_context *ctx;
-    boolean d_depth_bits_last;
-    boolean ds_depth_bits_last;
-    struct pipe_resource *root_texture;
-
-    /* exa */
-    struct exa_context *exa;
-    Bool noEvict;
-    Bool accelerate_2d;
-    Bool debug_fallback;
-
-    CustomizerPtr cust;
-
-#ifdef DRM_MODE_FEATURE_DIRTYFB
-    DamagePtr damage;
-#endif
-} modesettingRec, *modesettingPtr;
-
-#define modesettingPTR(p) ((modesettingPtr)((p)->driverPrivate))
-
-CustomizerPtr xorg_customizer(ScrnInfoPtr pScrn);
-
-Bool xorg_has_gallium(ScrnInfoPtr pScrn);
-
-void xorg_flush(ScreenPtr pScreen);
-/***********************************************************************
- * xorg_exa.c
- */
-struct pipe_resource *
-xorg_exa_get_texture(PixmapPtr pPixmap);
-
-int
-xorg_exa_set_displayed_usage(PixmapPtr pPixmap);
-
-int
-xorg_exa_set_shared_usage(PixmapPtr pPixmap);
-
-Bool
-xorg_exa_set_texture(PixmapPtr pPixmap, struct  pipe_resource *tex);
-
-struct pipe_resource *
-xorg_exa_create_root_texture(ScrnInfoPtr pScrn,
-			     int width, int height,
-			     int depth, int bpp);
-
-void *
-xorg_exa_init(ScrnInfoPtr pScrn, Bool accel);
-
-void
-xorg_exa_close(ScrnInfoPtr pScrn);
-
-
-/***********************************************************************
- * xorg_dri2.c
- */
-Bool
-xorg_dri2_init(ScreenPtr pScreen);
-
-void
-xorg_dri2_close(ScreenPtr pScreen);
-
-
-/***********************************************************************
- * xorg_crtc.c
- */
-void
-xorg_crtc_init(ScrnInfoPtr pScrn);
-
-void
-xorg_crtc_cursor_destroy(xf86CrtcPtr crtc);
-
-
-/***********************************************************************
- * xorg_output.c
- */
-void
-xorg_output_init(ScrnInfoPtr pScrn);
-
-unsigned
-xorg_output_get_id(xf86OutputPtr output);
-
-
-/***********************************************************************
- * xorg_xv.c
- */
-void
-xorg_xv_init(ScreenPtr pScreen);
-
-
-/***********************************************************************
- * xorg_xvmc.c
- */
-void
-xorg_xvmc_init(ScreenPtr pScreen, char *name);
-
-
-#endif /* _XORG_TRACKER_H_ */
diff --git a/src/gallium/state_trackers/xorg/xorg_winsys.h b/src/gallium/state_trackers/xorg/xorg_winsys.h
deleted file mode 100644
index 865733b..0000000
--- a/src/gallium/state_trackers/xorg/xorg_winsys.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-/*
- * File with all the junk needed to personalize the a xorg driver.
- */
-
-#ifndef _XORG_WINSYS_H_
-#define _XORG_WINSYS_H_
-
-#include "xorg-server.h"
-#include "xf86.h"
-#include "pciaccess.h"
-
-#ifndef XSERVER_LIBPCIACCESS
-#error "libpciaccess needed"
-#endif
-
-void xorg_tracker_set_functions(ScrnInfoPtr scrn);
-const OptionInfoRec * xorg_tracker_available_options(int chipid, int busid);
-Bool xorg_tracker_have_modesetting(ScrnInfoPtr pScrn, struct pci_device *device);
-
-#endif
diff --git a/src/gallium/state_trackers/xorg/xorg_xv.c b/src/gallium/state_trackers/xorg/xorg_xv.c
deleted file mode 100644
index f0de3d2..0000000
--- a/src/gallium/state_trackers/xorg/xorg_xv.c
+++ /dev/null
@@ -1,750 +0,0 @@
-#include "xorg_tracker.h"
-
-#include <xf86xv.h>
-#include <X11/extensions/Xv.h>
-#include <fourcc.h>
-
-#include "xorg_exa.h"
-#include "xorg_renderer.h"
-#include "xorg_exa_tgsi.h"
-
-#include "cso_cache/cso_context.h"
-#include "util/u_sampler.h"
-
-#include "pipe/p_screen.h"
-
-/*XXX get these from pipe's texture limits */
-#define IMAGE_MAX_WIDTH		2048
-#define IMAGE_MAX_HEIGHT	2048
-
-#define RES_720P_X 1280
-#define RES_720P_Y 720
-
-
-/* The ITU-R BT.601 conversion matrix for SDTV. */
-/* original, matrix, but we transpose it to
- * make the shader easier
-static const float bt_601[] = {
-    1.0, 0.0, 1.4075,   ,
-    1.0, -0.3455, -0.7169, 0,
-    1.0, 1.7790, 0., 0,
-};*/
-static const float bt_601[] = {
-    1.0, 1.0, 1.0,        0.5,
-    0.0, -0.3455, 1.7790, 0,
-    1.4075, -0.7169, 0.,  0,
-};
-
-/* The ITU-R BT.709 conversion matrix for HDTV. */
-/* original, but we transpose to make the conversion
- * in the shader easier
-static const float bt_709[] = {
-    1.0, 0.0, 1.581, 0,
-    1.0, -0.1881, -0.47, 0,
-    1.0, 1.8629, 0., 0,
-};*/
-static const float bt_709[] = {
-    1.0,   1.0,     1.0,     0.5,
-    0.0,  -0.1881,  1.8629,  0,
-    1.581,-0.47   , 0.0,     0,
-};
-
-#define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
-
-static Atom xvBrightness, xvContrast;
-
-#define NUM_TEXTURED_ATTRIBUTES 2
-static XF86AttributeRec TexturedAttributes[NUM_TEXTURED_ATTRIBUTES] = {
-   {XvSettable | XvGettable, -128, 127, "XV_BRIGHTNESS"},
-   {XvSettable | XvGettable, 0, 255, "XV_CONTRAST"}
-};
-
-#define NUM_FORMATS 3
-static XF86VideoFormatRec Formats[NUM_FORMATS] = {
-   {15, TrueColor}, {16, TrueColor}, {24, TrueColor}
-};
-
-static XF86VideoEncodingRec DummyEncoding[1] = {
-   {
-      0,
-      "XV_IMAGE",
-      IMAGE_MAX_WIDTH, IMAGE_MAX_HEIGHT,
-      {1, 1}
-   }
-};
-
-#define NUM_IMAGES 3
-static XF86ImageRec Images[NUM_IMAGES] = {
-   XVIMAGE_UYVY,
-   XVIMAGE_YUY2,
-   XVIMAGE_YV12,
-};
-
-struct xorg_xv_port_priv {
-   struct xorg_renderer *r;
-
-   RegionRec clip;
-
-   int brightness;
-   int contrast;
-
-   int current_set;
-   /* juggle two sets of seperate Y, U and V
-    * textures */
-   struct pipe_resource *yuv[2][3];
-   struct pipe_sampler_view *yuv_views[2][3];
-};
-
-
-static void
-stop_video(ScrnInfoPtr pScrn, pointer data, Bool shutdown)
-{
-   struct xorg_xv_port_priv *priv = (struct xorg_xv_port_priv *)data;
-
-   REGION_EMPTY(pScrn->pScreen, &priv->clip);
-}
-
-static int
-set_port_attribute(ScrnInfoPtr pScrn,
-                   Atom attribute, INT32 value, pointer data)
-{
-   struct xorg_xv_port_priv *priv = (struct xorg_xv_port_priv *)data;
-
-   if (attribute == xvBrightness) {
-      if ((value < -128) || (value > 127))
-         return BadValue;
-      priv->brightness = value;
-   } else if (attribute == xvContrast) {
-      if ((value < 0) || (value > 255))
-         return BadValue;
-      priv->contrast = value;
-   } else
-      return BadMatch;
-
-   return Success;
-}
-
-static int
-get_port_attribute(ScrnInfoPtr pScrn,
-                   Atom attribute, INT32 * value, pointer data)
-{
-   struct xorg_xv_port_priv *priv = (struct xorg_xv_port_priv *)data;
-
-   if (attribute == xvBrightness)
-      *value = priv->brightness;
-   else if (attribute == xvContrast)
-      *value = priv->contrast;
-   else
-      return BadMatch;
-
-   return Success;
-}
-
-static void
-query_best_size(ScrnInfoPtr pScrn,
-                Bool motion,
-                short vid_w, short vid_h,
-                short drw_w, short drw_h,
-                unsigned int *p_w, unsigned int *p_h, pointer data)
-{
-   if (vid_w > (drw_w << 1))
-      drw_w = vid_w >> 1;
-   if (vid_h > (drw_h << 1))
-      drw_h = vid_h >> 1;
-
-   *p_w = drw_w;
-   *p_h = drw_h;
-}
-
-static INLINE struct pipe_resource *
-create_component_texture(struct pipe_context *pipe,
-                         int width, int height)
-{
-   struct pipe_screen *screen = pipe->screen;
-   struct pipe_resource *tex = 0;
-   struct pipe_resource templ;
-
-   memset(&templ, 0, sizeof(templ));
-   templ.target = PIPE_TEXTURE_2D;
-   templ.format = PIPE_FORMAT_L8_UNORM;
-   templ.last_level = 0;
-   templ.width0 = width;
-   templ.height0 = height;
-   templ.depth0 = 1;
-   templ.array_size = 1;
-   templ.bind = PIPE_BIND_SAMPLER_VIEW;
-
-   tex = screen->resource_create(screen, &templ);
-
-   return tex;
-}
-
-static int
-check_yuv_textures(struct xorg_xv_port_priv *priv,  int width, int height)
-{
-   struct pipe_resource **dst = priv->yuv[priv->current_set];
-   struct pipe_sampler_view **dst_view = priv->yuv_views[priv->current_set];
-   struct pipe_sampler_view view_templ;
-   struct pipe_context *pipe = priv->r->pipe;
-
-   if (!dst[0] ||
-       dst[0]->width0 != width ||
-       dst[0]->height0 != height) {
-      pipe_resource_reference(&dst[0], NULL);
-      pipe_sampler_view_reference(&dst_view[0], NULL);
-   }
-   if (!dst[1] ||
-       dst[1]->width0 != width ||
-       dst[1]->height0 != height) {
-      pipe_resource_reference(&dst[1], NULL);
-      pipe_sampler_view_reference(&dst_view[1], NULL);
-   }
-   if (!dst[2] ||
-       dst[2]->width0 != width ||
-       dst[2]->height0 != height) {
-      pipe_resource_reference(&dst[2], NULL);
-      pipe_sampler_view_reference(&dst_view[2], NULL);
-   }
-
-   if (!dst[0]) {
-      dst[0] = create_component_texture(priv->r->pipe, width, height);
-      if (dst[0]) {
-         u_sampler_view_default_template(&view_templ,
-                                         dst[0],
-                                         dst[0]->format);
-         dst_view[0] = pipe->create_sampler_view(pipe, dst[0], &view_templ);
-      }
-   }
-
-   if (!dst[1]) {
-      dst[1] = create_component_texture(priv->r->pipe, width, height);
-      if (dst[1]) {
-         u_sampler_view_default_template(&view_templ,
-                                         dst[1],
-                                         dst[1]->format);
-         dst_view[1] = pipe->create_sampler_view(pipe, dst[1], &view_templ);
-      }
-   }
-
-   if (!dst[2]) {
-      dst[2] = create_component_texture(priv->r->pipe, width, height);
-      if (dst[2]) {
-         u_sampler_view_default_template(&view_templ,
-                                      dst[2],
-                                      dst[2]->format);
-         dst_view[2] = pipe->create_sampler_view(pipe, dst[2], &view_templ);
-      }
-   }
-
-   if (!dst[0] || !dst[1] || !dst[2] || !dst_view[0] || !dst_view[1] || !dst_view[2] )
-      return BadAlloc;
-
-   return Success;
-}
-
-static int
-query_image_attributes(ScrnInfoPtr pScrn,
-                       int id,
-                       unsigned short *w, unsigned short *h,
-                       int *pitches, int *offsets)
-{
-   int size, tmp;
-
-   if (*w > IMAGE_MAX_WIDTH)
-      *w = IMAGE_MAX_WIDTH;
-   if (*h > IMAGE_MAX_HEIGHT)
-      *h = IMAGE_MAX_HEIGHT;
-
-   *w = (*w + 1) & ~1;
-   if (offsets)
-      offsets[0] = 0;
-
-   switch (id) {
-   case FOURCC_YV12:
-      *h = (*h + 1) & ~1;
-      size = (*w + 3) & ~3;
-      if (pitches) {
-         pitches[0] = size;
-      }
-      size *= *h;
-      if (offsets) {
-         offsets[1] = size;
-      }
-      tmp = ((*w >> 1) + 3) & ~3;
-      if (pitches) {
-         pitches[1] = pitches[2] = tmp;
-      }
-      tmp *= (*h >> 1);
-      size += tmp;
-      if (offsets) {
-         offsets[2] = size;
-      }
-      size += tmp;
-      break;
-   case FOURCC_UYVY:
-   case FOURCC_YUY2:
-   default:
-      size = *w << 1;
-      if (pitches)
-	 pitches[0] = size;
-      size *= *h;
-      break;
-   }
-
-   return size;
-}
-
-static void
-copy_packed_data(ScrnInfoPtr pScrn,
-                 struct xorg_xv_port_priv *port,
-                 int id,
-                 unsigned char *buf,
-                 int left,
-                 int top,
-                 unsigned short w, unsigned short h)
-{
-   int i, j;
-   struct pipe_resource **dst = port->yuv[port->current_set];
-   struct pipe_transfer *ytrans, *utrans, *vtrans;
-   struct pipe_context *pipe = port->r->pipe;
-   char *ymap, *vmap, *umap;
-   unsigned char y1, y2, u, v;
-   int yidx, uidx, vidx;
-   int y_array_size = w * h;
-
-   ymap = pipe_transfer_map(pipe, dst[0],
-                            0, 0,
-                            PIPE_TRANSFER_WRITE,
-                            left, top, w, h, &ytrans);
-   umap = pipe_transfer_map(pipe, dst[1],
-                            0, 0,
-                            PIPE_TRANSFER_WRITE,
-                            left, top, w, h, &utrans);
-   vmap = pipe_transfer_map(pipe, dst[2],
-                            0, 0,
-                            PIPE_TRANSFER_WRITE,
-                            left, top, w, h, &vtrans);
-
-   yidx = uidx = vidx = 0;
-
-   switch (id) {
-   case FOURCC_YV12: {
-      int pitches[3], offsets[3];
-      unsigned char *y, *u, *v;
-      query_image_attributes(pScrn, FOURCC_YV12,
-                             &w, &h, pitches, offsets);
-
-      y = buf + offsets[0];
-      v = buf + offsets[1];
-      u = buf + offsets[2];
-      for (i = 0; i < h; ++i) {
-         for (j = 0; j < w; ++j) {
-            int yoffset = (w*i+j);
-            int ii = (i|1), jj = (j|1);
-            int vuoffset = (w/2)*(ii/2) + (jj/2);
-            ymap[yidx++] = y[yoffset];
-            umap[uidx++] = u[vuoffset];
-            vmap[vidx++] = v[vuoffset];
-         }
-      }
-   }
-      break;
-   case FOURCC_UYVY:
-      for (i = 0; i < y_array_size; i +=2 ) {
-         /* extracting two pixels */
-         u  = buf[0];
-         y1 = buf[1];
-         v  = buf[2];
-         y2 = buf[3];
-         buf += 4;
-
-         ymap[yidx++] = y1;
-         ymap[yidx++] = y2;
-         umap[uidx++] = u;
-         umap[uidx++] = u;
-         vmap[vidx++] = v;
-         vmap[vidx++] = v;
-      }
-      break;
-   case FOURCC_YUY2:
-      for (i = 0; i < y_array_size; i +=2 ) {
-         /* extracting two pixels */
-         y1 = buf[0];
-         u  = buf[1];
-         y2 = buf[2];
-         v  = buf[3];
-
-         buf += 4;
-
-         ymap[yidx++] = y1;
-         ymap[yidx++] = y2;
-         umap[uidx++] = u;
-         umap[uidx++] = u;
-         vmap[vidx++] = v;
-         vmap[vidx++] = v;
-      }
-      break;
-   default:
-      debug_assert(!"Unsupported yuv format!");
-      break;
-   }
-
-   pipe->transfer_unmap(pipe, ytrans);
-   pipe->transfer_unmap(pipe, utrans);
-   pipe->transfer_unmap(pipe, vtrans);
-}
-
-
-static void
-setup_fs_video_constants(struct xorg_renderer *r, boolean hdtv)
-{
-   const int param_bytes = 12 * sizeof(float);
-   const float *video_constants = (hdtv) ? bt_709 : bt_601;
-
-   renderer_set_constants(r, PIPE_SHADER_FRAGMENT,
-                          video_constants, param_bytes);
-}
-
-static void
-draw_yuv(struct xorg_xv_port_priv *port,
-         float src_x, float src_y, float src_w, float src_h,
-         int dst_x, int dst_y, int dst_w, int dst_h)
-{
-   struct pipe_resource **textures = port->yuv[port->current_set];
-
-   /*debug_printf("  draw_yuv([%d, %d, %d ,%d], [%d, %d, %d, %d])\n",
-                src_x, src_y, src_w, src_h,
-                dst_x, dst_y, dst_w, dst_h);*/
-   renderer_draw_yuv(port->r,
-                     src_x, src_y, src_w, src_h,
-                     dst_x, dst_y, dst_w, dst_h,
-                     textures);
-}
-
-static void
-bind_blend_state(struct xorg_xv_port_priv *port)
-{
-   struct pipe_blend_state blend;
-
-   memset(&blend, 0, sizeof(struct pipe_blend_state));
-   blend.rt[0].blend_enable = 0;
-   blend.rt[0].colormask = PIPE_MASK_RGBA;
-
-   /* porter&duff src */
-   blend.rt[0].rgb_src_factor   = PIPE_BLENDFACTOR_ONE;
-   blend.rt[0].alpha_src_factor = PIPE_BLENDFACTOR_ONE;
-   blend.rt[0].rgb_dst_factor   = PIPE_BLENDFACTOR_ZERO;
-   blend.rt[0].alpha_dst_factor = PIPE_BLENDFACTOR_ZERO;
-
-   cso_set_blend(port->r->cso, &blend);
-}
-
-
-static void
-bind_shaders(struct xorg_xv_port_priv *port)
-{
-   unsigned vs_traits = 0, fs_traits = 0;
-   struct xorg_shader shader;
-
-   vs_traits |= VS_YUV;
-   fs_traits |= FS_YUV;
-
-   shader = xorg_shaders_get(port->r->shaders, vs_traits, fs_traits);
-   cso_set_vertex_shader_handle(port->r->cso, shader.vs);
-   cso_set_fragment_shader_handle(port->r->cso, shader.fs);
-}
-
-static void
-bind_samplers(struct xorg_xv_port_priv *port)
-{
-   struct pipe_sampler_state *samplers[PIPE_MAX_SAMPLERS];
-   struct pipe_sampler_state sampler;
-   struct pipe_sampler_view **dst_views = port->yuv_views[port->current_set];
-
-   memset(&sampler, 0, sizeof(struct pipe_sampler_state));
-
-   sampler.wrap_s = PIPE_TEX_WRAP_CLAMP;
-   sampler.wrap_t = PIPE_TEX_WRAP_CLAMP;
-   sampler.min_img_filter = PIPE_TEX_FILTER_LINEAR;
-   sampler.mag_img_filter = PIPE_TEX_FILTER_LINEAR;
-   sampler.min_mip_filter = PIPE_TEX_MIPFILTER_NEAREST;
-   sampler.normalized_coords = 1;
-
-   samplers[0] = &sampler;
-   samplers[1] = &sampler;
-   samplers[2] = &sampler;
-
-
-   cso_set_samplers(port->r->cso, PIPE_SHADER_FRAGMENT, 3,
-                    (const struct pipe_sampler_state **)samplers);
-   cso_set_sampler_views(port->r->cso, PIPE_SHADER_FRAGMENT, 3, dst_views);
-}
-
-static int
-display_video(ScrnInfoPtr pScrn, struct xorg_xv_port_priv *pPriv, int id,
-              RegionPtr dstRegion,
-              int src_x, int src_y, int src_w, int src_h,
-              int dstX, int dstY, int dst_w, int dst_h,
-              PixmapPtr pPixmap)
-{
-   modesettingPtr ms = modesettingPTR(pScrn);
-   BoxPtr pbox;
-   int nbox;
-   Bool hdtv;
-   int x, y, w, h;
-   struct exa_pixmap_priv *dst;
-   struct pipe_surface *dst_surf = NULL;
-
-   exaMoveInPixmap(pPixmap);
-   dst = exaGetPixmapDriverPrivate(pPixmap);
-
-   /*debug_printf("display_video([%d, %d, %d, %d], [%d, %d, %d, %d])\n",
-     src_x, src_y, src_w, src_h, dstX, dstY, dst_w, dst_h);*/
-
-   if (dst && !dst->tex) {
-	xorg_exa_set_shared_usage(pPixmap);
-	pScrn->pScreen->ModifyPixmapHeader(pPixmap, 0, 0, 0, 0, 0, NULL);
-   }
-
-   if (!dst || !dst->tex)
-      XORG_FALLBACK("Xv destination %s", !dst ? "!dst" : "!dst->tex");
-
-   dst_surf = xorg_gpu_surface(pPriv->r->pipe, dst);
-   hdtv = ((src_w >= RES_720P_X) && (src_h >= RES_720P_Y));
-
-#ifdef COMPOSITE
-   REGION_TRANSLATE(pScrn->pScreen, dstRegion, -pPixmap->screen_x,
-                    -pPixmap->screen_y);
-#endif
-
-   pbox = REGION_RECTS(dstRegion);
-   nbox = REGION_NUM_RECTS(dstRegion);
-
-   renderer_bind_destination(pPriv->r, dst_surf, 
-                             dst_surf->width, dst_surf->height);
-
-   bind_blend_state(pPriv);
-   bind_shaders(pPriv);
-   bind_samplers(pPriv);
-   setup_fs_video_constants(pPriv->r, hdtv);
-
-   DamageDamageRegion(&pPixmap->drawable, dstRegion);
-
-   while (nbox--) {
-      int box_x1 = pbox->x1;
-      int box_y1 = pbox->y1;
-      int box_x2 = pbox->x2;
-      int box_y2 = pbox->y2;
-      float diff_x = (float)src_w / (float)dst_w;
-      float diff_y = (float)src_h / (float)dst_h;
-      float offset_x = box_x1 - dstX;
-      float offset_y = box_y1 - dstY;
-      float offset_w;
-      float offset_h;
-
-#ifdef COMPOSITE
-      offset_x += pPixmap->screen_x;
-      offset_y += pPixmap->screen_y;
-#endif
-
-      x = box_x1;
-      y = box_y1;
-      w = box_x2 - box_x1;
-      h = box_y2 - box_y1;
-
-      offset_w = dst_w - w;
-      offset_h = dst_h - h;
-
-      draw_yuv(pPriv,
-               (float) src_x + offset_x*diff_x, (float) src_y + offset_y*diff_y,
-               (float) src_w - offset_w*diff_x, (float) src_h - offset_h*diff_y,
-               x, y, w, h);
-
-      pbox++;
-   }
-   DamageRegionProcessPending(&pPixmap->drawable);
-
-   pipe_surface_reference(&dst_surf, NULL);
-
-   return TRUE;
-}
-
-static int
-put_image(ScrnInfoPtr pScrn,
-          short src_x, short src_y,
-          short drw_x, short drw_y,
-          short src_w, short src_h,
-          short drw_w, short drw_h,
-          int id, unsigned char *buf,
-          short width, short height,
-          Bool sync, RegionPtr clipBoxes, pointer data,
-          DrawablePtr pDraw)
-{
-   struct xorg_xv_port_priv *pPriv = (struct xorg_xv_port_priv *) data;
-   ScreenPtr pScreen = xf86ScrnToScreen(pScrn);
-   PixmapPtr pPixmap;
-   INT32 x1, x2, y1, y2;
-   BoxRec dstBox;
-   int ret;
-
-   /* Clip */
-   x1 = src_x;
-   x2 = src_x + src_w;
-   y1 = src_y;
-   y2 = src_y + src_h;
-
-   dstBox.x1 = drw_x;
-   dstBox.x2 = drw_x + drw_w;
-   dstBox.y1 = drw_y;
-   dstBox.y2 = drw_y + drw_h;
-
-   if (!xf86XVClipVideoHelper(&dstBox, &x1, &x2, &y1, &y2, clipBoxes,
-			      width, height))
-      return Success;
-
-   ret = check_yuv_textures(pPriv, width, height);
-
-   if (ret)
-      return ret;
-
-   copy_packed_data(pScrn, pPriv, id, buf,
-                    src_x, src_y, width, height);
-
-   if (pDraw->type == DRAWABLE_WINDOW) {
-      pPixmap = (*pScreen->GetWindowPixmap)((WindowPtr)pDraw);
-   } else {
-      pPixmap = (PixmapPtr)pDraw;
-   }
-
-   display_video(pScrn, pPriv, id, clipBoxes,
-                 src_x, src_y, src_w, src_h,
-                 drw_x, drw_y,
-                 drw_w, drw_h, pPixmap);
-
-   pPriv->current_set = (pPriv->current_set + 1) & 1;
-   return Success;
-}
-
-static struct xorg_xv_port_priv *
-port_priv_create(struct xorg_renderer *r)
-{
-   struct xorg_xv_port_priv *priv = NULL;
-
-   priv = calloc(1, sizeof(struct xorg_xv_port_priv));
-
-   if (!priv)
-      return NULL;
-
-   priv->r = r;
-
-   REGION_NULL(pScreen, &priv->clip);
-
-   debug_assert(priv && priv->r);
-
-   return priv;
-}
-
-static XF86VideoAdaptorPtr
-xorg_setup_textured_adapter(ScreenPtr pScreen)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-   modesettingPtr ms = modesettingPTR(pScrn);
-   XF86VideoAdaptorPtr adapt;
-   XF86AttributePtr attrs;
-   DevUnion *dev_unions;
-   int nports = 16, i;
-   int nattributes;
-
-   nattributes = NUM_TEXTURED_ATTRIBUTES;
-
-   debug_assert(ms->exa);
-   debug_assert(ms->exa->renderer);
-
-   adapt = calloc(1, sizeof(XF86VideoAdaptorRec));
-   dev_unions = calloc(nports, sizeof(DevUnion));
-   attrs = calloc(nattributes, sizeof(XF86AttributeRec));
-   if (adapt == NULL || dev_unions == NULL || attrs == NULL) {
-      free(adapt);
-      free(dev_unions);
-      free(attrs);
-      return NULL;
-   }
-
-   adapt->type = XvWindowMask | XvInputMask | XvImageMask;
-   adapt->flags = 0;
-   adapt->name = "Gallium3D Textured Video";
-   adapt->nEncodings = 1;
-   adapt->pEncodings = DummyEncoding;
-   adapt->nFormats = NUM_FORMATS;
-   adapt->pFormats = Formats;
-   adapt->nPorts = 0;
-   adapt->pPortPrivates = dev_unions;
-   adapt->nAttributes = nattributes;
-   adapt->pAttributes = attrs;
-   memcpy(attrs, TexturedAttributes, nattributes * sizeof(XF86AttributeRec));
-   adapt->nImages = NUM_IMAGES;
-   adapt->pImages = Images;
-   adapt->PutVideo = NULL;
-   adapt->PutStill = NULL;
-   adapt->GetVideo = NULL;
-   adapt->GetStill = NULL;
-   adapt->StopVideo = stop_video;
-   adapt->SetPortAttribute = set_port_attribute;
-   adapt->GetPortAttribute = get_port_attribute;
-   adapt->QueryBestSize = query_best_size;
-   adapt->PutImage = put_image;
-   adapt->QueryImageAttributes = query_image_attributes;
-
-   for (i = 0; i < nports; i++) {
-      struct xorg_xv_port_priv *priv =
-         port_priv_create(ms->exa->renderer);
-
-      adapt->pPortPrivates[i].ptr = (pointer) (priv);
-      adapt->nPorts++;
-   }
-
-   return adapt;
-}
-
-void
-xorg_xv_init(ScreenPtr pScreen)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-   /*modesettingPtr ms = modesettingPTR(pScrn);*/
-   XF86VideoAdaptorPtr *adaptors, *new_adaptors = NULL;
-   XF86VideoAdaptorPtr textured_adapter;
-   int num_adaptors;
-
-   num_adaptors = xf86XVListGenericAdaptors(pScrn, &adaptors);
-   new_adaptors = malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
-   if (new_adaptors == NULL)
-      return;
-
-   memcpy(new_adaptors, adaptors, num_adaptors * sizeof(XF86VideoAdaptorPtr));
-   adaptors = new_adaptors;
-
-   /* Add the adaptors supported by our hardware.  First, set up the atoms
-    * that will be used by both output adaptors.
-    */
-   xvBrightness = MAKE_ATOM("XV_BRIGHTNESS");
-   xvContrast = MAKE_ATOM("XV_CONTRAST");
-
-   textured_adapter = xorg_setup_textured_adapter(pScreen);
-
-   debug_assert(textured_adapter);
-
-   if (textured_adapter) {
-      adaptors[num_adaptors++] = textured_adapter;
-   }
-
-   if (num_adaptors) {
-      xf86XVScreenInit(pScreen, adaptors, num_adaptors);
-      if (textured_adapter)
-         xorg_xvmc_init(pScreen, textured_adapter->name);
-   } else {
-      xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                 "Disabling Xv because no adaptors could be initialized.\n");
-   }
-
-   free(adaptors);
-}
diff --git a/src/gallium/state_trackers/xorg/xorg_xvmc.c b/src/gallium/state_trackers/xorg/xorg_xvmc.c
deleted file mode 100644
index ea9a741..0000000
--- a/src/gallium/state_trackers/xorg/xorg_xvmc.c
+++ /dev/null
@@ -1,119 +0,0 @@
-#include "xorg_tracker.h"
-
-#include <xf86.h>
-#include <xf86xv.h>
-#include <xf86xvmc.h>
-#include <X11/extensions/Xv.h>
-#include <X11/extensions/XvMC.h>
-#include <fourcc.h>
-
-#define FOURCC_RGB 0x0000003
-#define XVIMAGE_RGB								\
-{										\
-	FOURCC_RGB,								\
-	XvRGB,									\
-	LSBFirst,								\
-	{									\
-		'R', 'G', 'B', 0x00,						\
-		0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71	\
-	},									\
-	32,									\
-	XvPacked,								\
-	1,									\
-	24, 0x00FF0000, 0x0000FF00, 0x000000FF,					\
-	0, 0, 0,								\
-	0, 0, 0,								\
-	0, 0, 0,								\
-	{									\
-		'B','G','R','X',						\
-		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0		\
-	},									\
-	XvTopToBottom								\
-}
-
-static int subpicture_index_list[] = {
-   FOURCC_RGB,
-   FOURCC_IA44,
-   FOURCC_AI44
-};
-
-static XF86MCImageIDList subpicture_list =
-{
-   sizeof(subpicture_index_list)/sizeof(*subpicture_index_list),
-   subpicture_index_list
-};
-
-static XF86MCSurfaceInfoRec yv12_mpeg2_surface =
-{
-   FOURCC_I420,
-   XVMC_CHROMA_FORMAT_420,
-   0,
-   2048, 2048, 2048, 2048,
-   XVMC_IDCT | XVMC_MPEG_2,
-   XVMC_SUBPICTURE_INDEPENDENT_SCALING | XVMC_BACKEND_SUBPICTURE,
-   &subpicture_list
-};
-
-static const XF86MCSurfaceInfoRec uyvy_mpeg2_surface =
-{
-   FOURCC_UYVY,
-   XVMC_CHROMA_FORMAT_422,
-   0,
-   2048, 2048, 2048, 2048,
-   XVMC_IDCT | XVMC_MPEG_2,
-   XVMC_SUBPICTURE_INDEPENDENT_SCALING | XVMC_BACKEND_SUBPICTURE,
-   &subpicture_list
-};
-
-static XF86MCSurfaceInfoPtr surfaces[] =
-{
-   (XF86MCSurfaceInfoPtr)&yv12_mpeg2_surface,
-   (XF86MCSurfaceInfoPtr)&uyvy_mpeg2_surface
-};
-
-static const XF86ImageRec rgb_subpicture = XVIMAGE_RGB;
-static const XF86ImageRec ia44_subpicture = XVIMAGE_IA44;
-static const XF86ImageRec ai44_subpicture = XVIMAGE_AI44;
-
-static XF86ImagePtr subpictures[] =
-{
-   (XF86ImagePtr)&rgb_subpicture,
-   (XF86ImagePtr)&ia44_subpicture,
-   (XF86ImagePtr)&ai44_subpicture
-};
-
-static const XF86MCAdaptorRec adaptor_template =
-{
-   "",
-   sizeof(surfaces)/sizeof(*surfaces),
-   surfaces,
-   sizeof(subpictures)/sizeof(*subpictures),
-   subpictures,
-   (xf86XvMCCreateContextProcPtr)NULL,
-   (xf86XvMCDestroyContextProcPtr)NULL,
-   (xf86XvMCCreateSurfaceProcPtr)NULL,
-   (xf86XvMCDestroySurfaceProcPtr)NULL,
-   (xf86XvMCCreateSubpictureProcPtr)NULL,
-   (xf86XvMCDestroySubpictureProcPtr)NULL
-};
-
-void
-xorg_xvmc_init(ScreenPtr pScreen, char *name)
-{
-   ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
-   XF86MCAdaptorPtr adaptorXvMC = xf86XvMCCreateAdaptorRec();
-   if (!adaptorXvMC)
-      return;
-
-   *adaptorXvMC = adaptor_template;
-   adaptorXvMC->name = name;
-   xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-              "[XvMC] Associated with %s.\n", name);
-   if (!xf86XvMCScreenInit(pScreen, 1, &adaptorXvMC))
-      xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                 "[XvMC] Failed to initialize extension.\n");
-   else
-      xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                 "[XvMC] Extension initialized.\n");
-   xf86XvMCDestroyAdaptorRec(adaptorXvMC);
-}
diff --git a/src/gallium/state_trackers/xvmc/Makefile.am b/src/gallium/state_trackers/xvmc/Makefile.am
index c110912..3968238 100644
--- a/src/gallium/state_trackers/xvmc/Makefile.am
+++ b/src/gallium/state_trackers/xvmc/Makefile.am
@@ -20,6 +20,7 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+AUTOMAKE_OPTIONS = subdir-objects
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
diff --git a/src/gallium/targets/Makefile.am b/src/gallium/targets/Makefile.am
index 2498ee1..e356020 100644
--- a/src/gallium/targets/Makefile.am
+++ b/src/gallium/targets/Makefile.am
@@ -58,10 +58,6 @@ if HAVE_GALLIUM_I915
 if HAVE_DRI
 SUBDIRS += dri-i915
 endif
-
-if HAVE_ST_XORG
-SUBDIRS += xorg-i915
-endif
 endif
 
 if HAVE_GALLIUM_ILO
@@ -74,14 +70,6 @@ if HAVE_GALLIUM_R300
 if HAVE_DRI
 SUBDIRS += r300/dri
 endif
-
-if HAVE_ST_XVMC
-SUBDIRS += r300/xvmc
-endif
-
-if HAVE_ST_VDPAU
-SUBDIRS += r300/vdpau
-endif
 endif
 
 if HAVE_GALLIUM_R600
@@ -89,10 +77,6 @@ if HAVE_DRI
 SUBDIRS += r600/dri
 endif
 
-if HAVE_ST_XORG
-SUBDIRS += r600/xorg
-endif
-
 if HAVE_ST_XVMC
 SUBDIRS += r600/xvmc
 endif
@@ -107,10 +91,6 @@ if HAVE_DRI
 SUBDIRS += radeonsi/dri
 endif
 
-if HAVE_ST_XORG
-SUBDIRS += radeonsi/xorg
-endif
-
 if HAVE_ST_VDPAU
 SUBDIRS += radeonsi/vdpau
 endif
@@ -121,10 +101,6 @@ if HAVE_DRI
 SUBDIRS += dri-nouveau
 endif
 
-if HAVE_ST_XORG
-SUBDIRS += xorg-nouveau
-endif
-
 if HAVE_ST_XVMC
 SUBDIRS += xvmc-nouveau
 endif
@@ -138,14 +114,6 @@ if HAVE_GALLIUM_SOFTPIPE
 if HAVE_DRI
 SUBDIRS += dri-swrast
 endif
-
-if HAVE_ST_XVMC
-SUBDIRS += xvmc-softpipe
-endif
-
-if HAVE_ST_VDPAU
-SUBDIRS += vdpau-softpipe
-endif
 endif
 
 if NEED_GALLIUM_LOADER
diff --git a/src/gallium/targets/SConscript.dri b/src/gallium/targets/SConscript.dri
deleted file mode 100644
index 8b15532..0000000
--- a/src/gallium/targets/SConscript.dri
+++ /dev/null
@@ -1,83 +0,0 @@
-###################################
-# SConcscript file for dri targets
-
-Import('*')
-
-drienv = env.Clone()
-
-drienv.Replace(CPPPATH = [
-    '#src/mesa/drivers/dri/common',
-    xmlpool_options.dir.dir, # Dir to generated xmlpool/options.h
-    '#include',
-    '#include/GL/internal',
-    '#src/mapi',
-    '#src/gallium/include',
-    '#src/gallium/auxiliary',
-    '#src/gallium/drivers',
-    '#src/gallium/winsys',
-    '#src/mesa',
-    '#src/mesa/main',
-    '#src/mesa/glapi',
-    '#src/mesa/math',
-    '#src/mesa/transform',
-    '#src/mesa/shader',
-    '#src/mesa/swrast',
-    '#src/mesa/swrast_setup',
-    '#src/egl/main',
-    '#src/egl/drivers/dri',
-])
-
-driswenv = drienv.Clone()
-driswenv.Append(CPPDEFINES = [
-    '__NOT_HAVE_DRM_H',
-])
-
-drienv.PkgUseModules('DRM')
-
-dri_common_utils = drienv.SharedObject(
-    target = 'utils.o',
-    source = '#src/mesa/drivers/dri/common/utils.c'
-)
-
-dri_common_xmlconfig = drienv.SharedObject(
-    target = 'xmlconfig.o',
-    source = '#src/mesa/drivers/dri/common/xmlconfig.c'
-)
-
-dri_common_dri_util = drienv.SharedObject(
-    target = 'dri_util.o',
-    source = '#src/mesa/drivers/dri/common/dri_util.c'
-)
-
-dri_common_drisw_util = driswenv.SharedObject(
-    target = 'drisw_util.o',
-    source = '#src/mesa/drivers/dri/common/dri_util.c'
-)
-
-
-COMMON_DRI_SW_OBJECTS = [
-    dri_common_utils,
-    dri_common_xmlconfig,
-    dri_common_drisw_util,
-]
-
-COMMON_DRI_DRM_OBJECTS = [
-    dri_common_utils,
-    dri_common_xmlconfig,
-    dri_common_dri_util,
-]
-
-drienv.AppendUnique(LIBS = [
-    'expat',
-])
-
-driswenv.AppendUnique(LIBS = [
-    'expat',
-])
-
-Export([
-    'drienv',
-    'driswenv',
-    'COMMON_DRI_SW_OBJECTS',
-    'COMMON_DRI_DRM_OBJECTS',
-])
diff --git a/src/gallium/targets/dri-freedreno/Makefile.am b/src/gallium/targets/dri-freedreno/Makefile.am
index 228fafc..94500b0 100644
--- a/src/gallium/targets/dri-freedreno/Makefile.am
+++ b/src/gallium/targets/dri-freedreno/Makefile.am
@@ -23,15 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_NOOP
@@ -39,7 +32,7 @@ AM_CPPFLAGS = \
 dridir = $(DRI_DRIVER_INSTALL_DIR)
 dri_LTLIBRARIES = kgsl_dri.la msm_dri.la
 
-COMMON_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+COMMON_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 COMMON_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-i915/Makefile.am b/src/gallium/targets/dri-i915/Makefile.am
index 851c412..3f8468f 100644
--- a/src/gallium/targets/dri-i915/Makefile.am
+++ b/src/gallium/targets/dri-i915/Makefile.am
@@ -23,15 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_GALAHAD \
@@ -42,7 +35,7 @@ dri_LTLIBRARIES = i915_dri.la
 
 i915_dri_la_SOURCES = target.c
 
-i915_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+i915_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 i915_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-ilo/Makefile.am b/src/gallium/targets/dri-ilo/Makefile.am
index 776c970..418e2ea 100644
--- a/src/gallium/targets/dri-ilo/Makefile.am
+++ b/src/gallium/targets/dri-ilo/Makefile.am
@@ -24,15 +24,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_GALAHAD
@@ -42,7 +35,7 @@ noinst_LTLIBRARIES = ilo_dri.la
 ilo_dri_la_SOURCES = target.c
 
 # need -rpath to create a noinst shared library
-ilo_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS) \
+ilo_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS) \
 		     -rpath $(abs_builddir)
 
 ilo_dri_la_LIBADD = \
diff --git a/src/gallium/targets/dri-nouveau/Makefile.am b/src/gallium/targets/dri-nouveau/Makefile.am
index 17b2c4a..1988067 100644
--- a/src/gallium/targets/dri-nouveau/Makefile.am
+++ b/src/gallium/targets/dri-nouveau/Makefile.am
@@ -23,15 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE
 
@@ -41,7 +34,7 @@ dri_LTLIBRARIES = nouveau_dri.la
 nodist_EXTRA_nouveau_dri_la_SOURCES = dummy.cpp
 nouveau_dri_la_SOURCES = target.c
 
-nouveau_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+nouveau_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 nouveau_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-swrast/Makefile.am b/src/gallium/targets/dri-swrast/Makefile.am
index cddbbe3..ec1576b 100644
--- a/src/gallium/targets/dri-swrast/Makefile.am
+++ b/src/gallium/targets/dri-swrast/Makefile.am
@@ -23,17 +23,10 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
 	$(EXPAT_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/winsys/sw/dri \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
 	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
@@ -49,7 +42,7 @@ swrast_dri_la_SOURCES = \
 	$(top_srcdir)/src/mesa/drivers/dri/common/dri_util.c \
 	$(top_srcdir)/src/mesa/drivers/dri/common/xmlconfig.c
 
-swrast_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+swrast_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 swrast_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/libmesagallium.la \
diff --git a/src/gallium/targets/dri-vmwgfx/Makefile.am b/src/gallium/targets/dri-vmwgfx/Makefile.am
index 5ff521e..712e570 100644
--- a/src/gallium/targets/dri-vmwgfx/Makefile.am
+++ b/src/gallium/targets/dri-vmwgfx/Makefile.am
@@ -23,15 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE
 
@@ -42,7 +35,7 @@ vmwgfx_dri_la_SOURCES = \
 	target.c \
 	vmw_powf.c
 
-vmwgfx_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+vmwgfx_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 vmwgfx_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/egl-static/Makefile.am b/src/gallium/targets/egl-static/Makefile.am
index 0b30aeb..760c477 100644
--- a/src/gallium/targets/egl-static/Makefile.am
+++ b/src/gallium/targets/egl-static/Makefile.am
@@ -30,6 +30,8 @@
 #
 include $(top_srcdir)/src/gallium/Automake.inc
 
+LDFLAGS += -Wl,$(top_srcdir)/src/gallium/targets/egl-static/egl.link
+
 AM_CFLAGS = $(PTHREAD_CFLAGS)
 AM_CPPFLAGS = \
 	$(GALLIUM_CFLAGS) \
diff --git a/src/gallium/targets/egl-static/egl.link b/src/gallium/targets/egl-static/egl.link
new file mode 100644
index 0000000..78d155d
--- /dev/null
+++ b/src/gallium/targets/egl-static/egl.link
@@ -0,0 +1,3 @@
+VERSION {
+{ global: _eglMain; local: *; };
+};
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
index ff420b9..b750f65 100644
--- a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
@@ -18,6 +18,7 @@ extern "C" {
 #include "main/context.h"
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
+#include "main/viewport.h"
 #include "pipe/p_format.h"
 #include "state_tracker/st_cb_fbo.h"
 #include "state_tracker/st_cb_flush.h"
@@ -49,11 +50,11 @@ hgl_viewport(struct gl_context* glContext, GLint x, GLint y,
 	TRACE("%s(glContext: %p, x: %d, y: %d, w: %d, h: %d\n", __func__,
 		glContext, x, y, width, height);
 
+	_mesa_check_init_viewport(glContext, width, height);
+
 	struct gl_framebuffer *draw = glContext->WinSysDrawBuffer;
 	struct gl_framebuffer *read = glContext->WinSysReadBuffer;
 
-	// TODO: SLOW! We need to check for changes in bitmap vs gl_framebuffer
-	// size before doing a _mesa_resize_framebuffer.
 	if (draw)
 		_mesa_resize_framebuffer(glContext, draw, width, height);
 	if (read)
@@ -145,8 +146,8 @@ hook_stm_get_param(struct st_manager *smapi, enum st_manager_param param)
 GalliumContext::GalliumContext(ulong options)
 	:
 	fOptions(options),
-	fCurrentContext(0),
-	fScreen(NULL)
+	fScreen(NULL),
+	fCurrentContext(0)
 {
 	CALLED();
 
@@ -165,10 +166,10 @@ GalliumContext::~GalliumContext()
 	CALLED();
 
 	// Destroy our contexts
-	pipe_mutex_lock(fMutex);
+	Lock();
 	for (context_id i = 0; i < CONTEXT_MAX; i++)
 		DestroyContext(i);
-	pipe_mutex_unlock(fMutex);
+	Unlock();
 
 	pipe_mutex_destroy(fMutex);
 
@@ -337,20 +338,20 @@ GalliumContext::CreateContext(Bitmap *bitmap)
 		return -1;
 	}
 
-	// Init Gallium3D Post Processing
-	//context->postProcess = pp_init(fScreen, context->postProcessEnable);
-
 	assert(!context->st->st_manager_private);
-	context->st->st_manager_private = (void*)this;
+	context->st->st_manager_private = (void*)context;
 
 	struct st_context *stContext = (struct st_context*)context->st;
 	
 	stContext->ctx->Driver.Viewport = hgl_viewport;
 
-	// TODO: Closely review this next context logic...
-	context_id contextNext = -1;
+	// Init Gallium3D Post Processing
+	// TODO: no pp filters are enabled yet through postProcessEnable
+	context->postProcess = pp_init(stContext->pipe, context->postProcessEnable,
+		stContext->cso_context);
 
-	pipe_mutex_lock(fMutex);
+	context_id contextNext = -1;
+	Lock();
 	for (context_id i = 0; i < CONTEXT_MAX; i++) {
 		if (fContext[i] == NULL) {
 			fContext[i] = context;
@@ -358,7 +359,7 @@ GalliumContext::CreateContext(Bitmap *bitmap)
 			break;
 		}
 	}
-	pipe_mutex_unlock(fMutex);
+	Unlock();
 
 	if (contextNext < 0) {
 		ERROR("%s: The next context is invalid... something went wrong!\n",
@@ -419,10 +420,10 @@ GalliumContext::SetCurrentContext(Bitmap *bitmap, context_id contextID)
 		return B_ERROR;
 	}
 
-	pipe_mutex_lock(fMutex);
+	Lock();
 	context_id oldContextID = fCurrentContext;
 	struct hgl_context* context = fContext[contextID];
-	pipe_mutex_unlock(fMutex);
+	Unlock();
 
 	if (!context) {
 		ERROR("%s: Invalid context provided (#%" B_PRIu64 ")!\n",
@@ -453,12 +454,14 @@ GalliumContext::SetCurrentContext(Bitmap *bitmap, context_id contextID)
 	context->draw->Unlock();
 	context->read->Unlock();
 
-	// TODO: Init textures before post-processing them
-	#if 0
-	pp_init_fbos(context->postProcess,
-		context->textures[ST_ATTACHMENT_BACK_LEFT]->width0,
-		context->textures[ST_ATTACHMENT_BACK_LEFT]->height0);
-	#endif
+	if (context->textures[ST_ATTACHMENT_BACK_LEFT]
+		&& context->textures[ST_ATTACHMENT_DEPTH_STENCIL]
+		&& context->postProcess) {
+		TRACE("Postprocessing textures...\n");
+		pp_init_fbos(context->postProcess,
+			context->textures[ST_ATTACHMENT_BACK_LEFT]->width0,
+			context->textures[ST_ATTACHMENT_BACK_LEFT]->height0);
+	}
 
 	context->bitmap = bitmap;
 	//context->st->pipe->priv = context;
@@ -472,9 +475,9 @@ GalliumContext::SwapBuffers(context_id contextID)
 {
 	CALLED();
 
-	pipe_mutex_lock(fMutex);
+	Lock();
 	struct hgl_context *context = fContext[contextID];
-	pipe_mutex_unlock(fMutex);
+	Unlock();
 
 	if (!context) {
 		ERROR("%s: context not found\n", __func__);
@@ -507,10 +510,40 @@ GalliumContext::SwapBuffers(context_id contextID)
 	#if 0
 	// TODO... should we flush the z stencil buffer?
 	pipe_surface* zSurface = stContext->state.framebuffer.zsbuf;
-	fScreen->flush_frontbuffer(fScreen, surface->texture, 0, 0,
+	fScreen->flush_frontbuffer(fScreen, zSurface->texture, 0, 0,
 		context->bitmap);
 	#endif
 
 	return B_OK;
 }
+
+
+void
+GalliumContext::ResizeViewport(int32 width, int32 height)
+{
+	CALLED();
+	for (context_id i = 0; i < CONTEXT_MAX; i++) {
+		if (fContext[i] && fContext[i]->st) {
+			struct st_context *stContext = (struct st_context*)fContext[i]->st;
+			_mesa_set_viewport(stContext->ctx, 0, 0, width, height);
+        		st_manager_validate_framebuffers(stContext);
+		}
+	}
+}
+
+
+void
+GalliumContext::Lock()
+{
+	CALLED();
+	pipe_mutex_lock(fMutex);
+}
+
+
+void
+GalliumContext::Unlock()
+{
+	CALLED();
+	pipe_mutex_unlock(fMutex);
+}
 /* vim: set tabstop=4: */
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.h b/src/gallium/targets/haiku-softpipe/GalliumContext.h
index 88e9f81..e156ef8 100644
--- a/src/gallium/targets/haiku-softpipe/GalliumContext.h
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.h
@@ -58,6 +58,9 @@ public:
 							GalliumContext(ulong options);
 							~GalliumContext();
 
+		void				Lock();
+		void				Unlock();
+
 		context_id			CreateContext(Bitmap* bitmap);
 		void				DestroyContext(context_id contextID);
 		context_id			GetCurrentContext() { return fCurrentContext; };
@@ -65,17 +68,18 @@ public:
 								context_id contextID);
 
 		status_t			SwapBuffers(context_id contextID);
+		void				ResizeViewport(int32 width, int32 height);
 
 private:
 		status_t			CreateScreen();
 		void				Flush();
 
 		ulong				fOptions;
+		struct pipe_screen*	fScreen;
 
+		// Context Management
 		struct hgl_context*	fContext[CONTEXT_MAX];
 		context_id			fCurrentContext;
-		
-		struct pipe_screen*	fScreen;
 		pipe_mutex			fMutex;
 };
 	
diff --git a/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp
index 7a33cc0..dd726ef 100644
--- a/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp
+++ b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp
@@ -15,8 +15,11 @@ extern "C" {
 #include "main/framebuffer.h"
 #include "main/renderbuffer.h"
 #include "pipe/p_format.h"
+#include "state_tracker/st_manager.h"
 }
 
+#include "GalliumContext.h"
+
 
 #ifdef DEBUG
 #   define TRACE(x...) printf("GalliumFramebuffer: " x)
@@ -33,7 +36,13 @@ hgl_framebuffer_flush_front(struct st_context_iface *stctx,
 	struct st_framebuffer_iface* stfb, enum st_attachment_type statt)
 {
 	CALLED();
-	// TODO: I have *NO* idea how we are going to access this data...
+
+	hgl_context* context = (hgl_context*)stfb->st_manager_private;
+
+	if (!context) {
+		ERROR("%s: Couldn't obtain valid hgl_context!\n", __func__);
+		return FALSE;
+	}
 
 	#if 0
 	struct stw_st_framebuffer *stwfb = stw_st_framebuffer(stfb);
@@ -56,6 +65,63 @@ hgl_framebuffer_validate(struct st_context_iface* stctx,
 {
 	CALLED();
 
+	if (!stfb) {
+		ERROR("%s: Invalid st framebuffer interface!\n", __func__);
+		return FALSE;
+	}
+
+	hgl_context* context = (hgl_context*)stfb->st_manager_private;
+
+	if (!context) {
+		ERROR("%s: Couldn't obtain valid hgl_context!\n", __func__);
+		return FALSE;
+	}
+
+	int32 width = 0;
+	int32 height = 0;
+	get_bitmap_size(context->bitmap, &width, &height);
+
+	struct pipe_resource templat;
+	memset(&templat, 0, sizeof(templat));
+	templat.target = PIPE_TEXTURE_RECT;
+	templat.width0 = width;
+	templat.height0 = height;
+	templat.depth0 = 1;
+	templat.array_size = 1;
+	templat.usage = PIPE_USAGE_DEFAULT;
+
+	if (context->stVisual && context->manager && context->manager->screen) {
+		TRACE("%s: Updating resources\n", __func__);
+		int i;
+		for (i = 0; i < count; i++) {
+			enum pipe_format format = PIPE_FORMAT_NONE;
+			unsigned bind = 0;
+	
+			switch(statts[i]) {
+				case ST_ATTACHMENT_FRONT_LEFT:
+					format = context->stVisual->color_format;
+					bind = PIPE_BIND_RENDER_TARGET;
+					break;
+				case ST_ATTACHMENT_DEPTH_STENCIL:
+					format = context->stVisual->depth_stencil_format;
+					bind = PIPE_BIND_DEPTH_STENCIL;
+					break;
+				case ST_ATTACHMENT_ACCUM:
+					format = context->stVisual->accum_format;
+					bind = PIPE_BIND_RENDER_TARGET;
+					break;
+				default:
+					ERROR("%s: Unexpected attachment type!\n", __func__);
+			}
+			templat.format = format;
+			templat.bind = bind;
+
+			struct pipe_screen* screen = context->manager->screen;
+			context->textures[i] = screen->resource_create(screen, &templat);
+			out[i] = context->textures[i];
+		}
+	}
+
 	return TRUE;
 }
 
diff --git a/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp
index fa71dd7..9d85b8d 100644
--- a/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp
+++ b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp
@@ -326,7 +326,8 @@ SoftwareRenderer::DirectConnected(direct_buffer_info *info)
 void
 SoftwareRenderer::FrameResized(float width, float height)
 {
-//	CALLED();
+	TRACE("%s: %f x %f\n", __func__, width, height);
+
 	BAutolock lock(fInfoLocker);
 	fNewWidth = (GLuint)width;
 	fNewHeight = (GLuint)height;
@@ -354,6 +355,11 @@ SoftwareRenderer::_AllocateBitmap()
 		return;
 	}
 
+	TRACE("%s: New bitmap size: %d x %d\n", __func__,
+		fBitmap->Bounds().IntegerWidth(), fBitmap->Bounds().IntegerHeight());
+
+	fContextObj->ResizeViewport(fWidth, fHeight);
+
 #if 0
 	// debug..
 	void *data = fBitmap->Bits();
diff --git a/src/gallium/targets/pipe-loader/Makefile.am b/src/gallium/targets/pipe-loader/Makefile.am
index e6772b8..970ff0e 100644
--- a/src/gallium/targets/pipe-loader/Makefile.am
+++ b/src/gallium/targets/pipe-loader/Makefile.am
@@ -22,6 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
+LDFLAGS += -Wl,$(top_srcdir)/src/gallium/targets/pipe-loader/pipe.link
+
 AM_CPPFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	-I$(top_srcdir)/include \
diff --git a/src/gallium/targets/pipe-loader/pipe.link b/src/gallium/targets/pipe-loader/pipe.link
new file mode 100644
index 0000000..1c98da6
--- /dev/null
+++ b/src/gallium/targets/pipe-loader/pipe.link
@@ -0,0 +1,3 @@
+VERSION {
+	{global: driver_descriptor; local: *;  };
+};
diff --git a/src/gallium/targets/r300/common/drm_target.c b/src/gallium/targets/r300/common/drm_target.c
new file mode 100644
index 0000000..2c10bbd
--- /dev/null
+++ b/src/gallium/targets/r300/common/drm_target.c
@@ -0,0 +1,54 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "target-helpers/inline_debug_helper.h"
+#include "state_tracker/drm_driver.h"
+#include "radeon/drm/radeon_drm_public.h"
+#include "radeon/drm/radeon_winsys.h"
+#include "r300/r300_public.h"
+
+static struct pipe_screen *
+create_screen(int fd)
+{
+   struct radeon_winsys *sws;
+
+   sws = radeon_drm_winsys_create(fd);
+   if (!sws)
+      return NULL;
+
+   if (!sws->screen) {
+      sws->screen = r300_screen_create(sws);
+      if (!sws->screen)
+         return NULL;
+
+      sws->screen = debug_screen_wrap(sws->screen);
+   }
+
+   return sws->screen;
+}
+
+DRM_DRIVER_DESCRIPTOR("r300", "radeon", create_screen, NULL)
diff --git a/src/gallium/targets/r300/dri/Makefile.am b/src/gallium/targets/r300/dri/Makefile.am
index 4b41c30..d6d8f2d 100644
--- a/src/gallium/targets/r300/dri/Makefile.am
+++ b/src/gallium/targets/r300/dri/Makefile.am
@@ -23,16 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_GALAHAD
@@ -42,9 +34,9 @@ dri_LTLIBRARIES = r300_dri.la
 
 nodist_EXTRA_r300_dri_la_SOURCES = dummy.cpp
 r300_dri_la_SOURCES = \
-	../drm_target.c
+	drm_target.c
 
-r300_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+r300_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 r300_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/r300/dri/drm_target.c b/src/gallium/targets/r300/dri/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/r300/dri/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/r300/drm_target.c b/src/gallium/targets/r300/drm_target.c
deleted file mode 100644
index 2c10bbd..0000000
--- a/src/gallium/targets/r300/drm_target.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Advanced Micro Devices, Inc.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- **************************************************************************/
-
-#include "target-helpers/inline_debug_helper.h"
-#include "state_tracker/drm_driver.h"
-#include "radeon/drm/radeon_drm_public.h"
-#include "radeon/drm/radeon_winsys.h"
-#include "r300/r300_public.h"
-
-static struct pipe_screen *
-create_screen(int fd)
-{
-   struct radeon_winsys *sws;
-
-   sws = radeon_drm_winsys_create(fd);
-   if (!sws)
-      return NULL;
-
-   if (!sws->screen) {
-      sws->screen = r300_screen_create(sws);
-      if (!sws->screen)
-         return NULL;
-
-      sws->screen = debug_screen_wrap(sws->screen);
-   }
-
-   return sws->screen;
-}
-
-DRM_DRIVER_DESCRIPTOR("r300", "radeon", create_screen, NULL)
diff --git a/src/gallium/targets/r300/vdpau/Makefile.am b/src/gallium/targets/r300/vdpau/Makefile.am
deleted file mode 100644
index d4855b2..0000000
--- a/src/gallium/targets/r300/vdpau/Makefile.am
+++ /dev/null
@@ -1,74 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
-
-vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
-vdpau_LTLIBRARIES = libvdpau_r300.la
-
-EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
-
-nodist_EXTRA_libvdpau_r300_la_SOURCES = dummy.cpp
-libvdpau_r300_la_SOURCES = \
-	../drm_target.c \
-	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
-
-libvdpau_r300_la_LDFLAGS = \
-	-module \
-	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
-	-export-symbols-regex $(EXPORTS) \
-	-shared \
-	-no-undefined
-
-libvdpau_r300_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/drivers/r300/libr300-helper.la \
-	$(top_builddir)/src/gallium/drivers/r300/libr300.la \
-	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
-	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/galahad/libgalahad.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(VDPAU_LIBS) \
-	$(LIBDRM_LIBS) \
-	$(RADEON_LIBS)
-
-if HAVE_MESA_LLVM
-libvdpau_r300_la_LDFLAGS += $(LLVM_LDFLAGS)
-libvdpau_r300_la_LIBADD += $(LLVM_LIBS)
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: libvdpau_r300.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/libvdpau_r300.so* $(top_builddir)/$(LIB_DIR)/gallium/
diff --git a/src/gallium/targets/r300/xvmc/Makefile.am b/src/gallium/targets/r300/xvmc/Makefile.am
deleted file mode 100644
index 079a0eb..0000000
--- a/src/gallium/targets/r300/xvmc/Makefile.am
+++ /dev/null
@@ -1,69 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
-
-xvmcdir = $(XVMC_LIB_INSTALL_DIR)
-xvmc_LTLIBRARIES = libXvMCr300.la
-
-nodist_EXTRA_libXvMCr300_la_SOURCES = dummy.cpp
-libXvMCr300_la_SOURCES = \
-	../drm_target.c \
-	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
-
-libXvMCr300_la_LDFLAGS = \
-	-module \
-	-version-number $(XVMC_MAJOR):$(XVMC_MINOR) \
-	-shared \
-	-no-undefined
-
-libXvMCr300_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-        $(top_builddir)/src/gallium/drivers/r300/libr300-helper.la \
-        $(top_builddir)/src/gallium/drivers/r300/libr300.la \
-	$(top_builddir)/src/gallium/state_trackers/xvmc/libxvmctracker.la \
-        $(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-        $(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(XVMC_LIBS) \
-	$(LIBDRM_LIBS) \
-	$(RADEON_LIBS)
-
-if HAVE_MESA_LLVM
-libXvMCr300_la_LDFLAGS += $(LLVM_LDFLAGS)
-libXvMCr300_la_LIBADD += $(LLVM_LIBS)
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: libXvMCr300.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/libXvMCr300.so* $(top_builddir)/$(LIB_DIR)/gallium/
diff --git a/src/gallium/targets/r600/common/drm_target.c b/src/gallium/targets/r600/common/drm_target.c
new file mode 100644
index 0000000..28004ac
--- /dev/null
+++ b/src/gallium/targets/r600/common/drm_target.c
@@ -0,0 +1,69 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "state_tracker/drm_driver.h"
+#include "target-helpers/inline_debug_helper.h"
+#include "radeon/drm/radeon_drm_public.h"
+#include "radeon/drm/radeon_winsys.h"
+#include "r600/r600_public.h"
+
+static struct pipe_screen *create_screen(int fd)
+{
+   struct radeon_winsys *radeon;
+
+   radeon = radeon_drm_winsys_create(fd);
+   if (!radeon)
+      return NULL;
+
+   if (!radeon->screen) {
+      radeon->screen = r600_screen_create(radeon);
+      if (!radeon->screen)
+         return NULL;
+
+      radeon->screen = debug_screen_wrap(radeon->screen);
+   }
+
+   return radeon->screen;
+}
+
+static const struct drm_conf_ret throttle_ret = {
+   .type = DRM_CONF_INT,
+   .val.val_int = 2,
+};
+
+static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
+{
+   switch (conf) {
+   case DRM_CONF_THROTTLE:
+      return &throttle_ret;
+   default:
+      break;
+   }
+   return NULL;
+}
+
+DRM_DRIVER_DESCRIPTOR("r600", "radeon", create_screen, drm_configuration)
diff --git a/src/gallium/targets/r600/dri/Makefile.am b/src/gallium/targets/r600/dri/Makefile.am
index c7fca32..42db72f 100644
--- a/src/gallium/targets/r600/dri/Makefile.am
+++ b/src/gallium/targets/r600/dri/Makefile.am
@@ -23,16 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_NOOP
@@ -41,9 +33,9 @@ dridir = $(DRI_DRIVER_INSTALL_DIR)
 dri_LTLIBRARIES = r600_dri.la
 
 r600_dri_la_SOURCES = \
-	../drm_target.c
+	drm_target.c
 
-r600_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+r600_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 r600_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/r600/dri/drm_target.c b/src/gallium/targets/r600/dri/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/r600/dri/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/r600/drm_target.c b/src/gallium/targets/r600/drm_target.c
deleted file mode 100644
index 28004ac..0000000
--- a/src/gallium/targets/r600/drm_target.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Advanced Micro Devices, Inc.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- **************************************************************************/
-
-#include "state_tracker/drm_driver.h"
-#include "target-helpers/inline_debug_helper.h"
-#include "radeon/drm/radeon_drm_public.h"
-#include "radeon/drm/radeon_winsys.h"
-#include "r600/r600_public.h"
-
-static struct pipe_screen *create_screen(int fd)
-{
-   struct radeon_winsys *radeon;
-
-   radeon = radeon_drm_winsys_create(fd);
-   if (!radeon)
-      return NULL;
-
-   if (!radeon->screen) {
-      radeon->screen = r600_screen_create(radeon);
-      if (!radeon->screen)
-         return NULL;
-
-      radeon->screen = debug_screen_wrap(radeon->screen);
-   }
-
-   return radeon->screen;
-}
-
-static const struct drm_conf_ret throttle_ret = {
-   .type = DRM_CONF_INT,
-   .val.val_int = 2,
-};
-
-static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
-{
-   switch (conf) {
-   case DRM_CONF_THROTTLE:
-      return &throttle_ret;
-   default:
-      break;
-   }
-   return NULL;
-}
-
-DRM_DRIVER_DESCRIPTOR("r600", "radeon", create_screen, drm_configuration)
diff --git a/src/gallium/targets/r600/vdpau/Makefile.am b/src/gallium/targets/r600/vdpau/Makefile.am
index 7c97585..7f43fbb 100644
--- a/src/gallium/targets/r600/vdpau/Makefile.am
+++ b/src/gallium/targets/r600/vdpau/Makefile.am
@@ -20,42 +20,28 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+# Note: Make sure VDPAU_EXPORTS is defined before including Automake.inc
+VDPAU_EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
+	$(GALLIUM_VIDEO_CFLAGS)
 
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_r600.la
 
-EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
-
 libvdpau_r600_la_SOURCES = \
-	../drm_target.c \
+	drm_target.c \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
 
 libvdpau_r600_la_LDFLAGS = \
-	-module \
-	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
-	-export-symbols-regex $(EXPORTS) \
-	-shared \
-	-no-undefined
+	$(GALLIUM_VDPAU_LINKER_FLAGS)
 
 libvdpau_r600_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
 	$(top_builddir)/src/gallium/drivers/r600/libr600.la \
-	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
 	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
+	$(GALLIUM_VDPAU_LIB_DEPS) \
 	$(GALLIUM_DRI_LIB_DEPS) \
-	$(VDPAU_LIBS) \
-	$(LIBDRM_LIBS) \
 	$(RADEON_LIBS)
 
 if HAVE_MESA_LLVM
diff --git a/src/gallium/targets/r600/vdpau/drm_target.c b/src/gallium/targets/r600/vdpau/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/r600/vdpau/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/r600/xorg/Makefile.am b/src/gallium/targets/r600/xorg/Makefile.am
deleted file mode 100644
index c3dee5a..0000000
--- a/src/gallium/targets/r600/xorg/Makefile.am
+++ /dev/null
@@ -1,77 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-DHAVE_CONFIG_H \
-	-DGALLIUM_RBUG \
-	-DGALLIUM_TRACE \
-	-DGALLIUM_GALAHAD
-
-xorgdir = $(XORG_DRIVER_INSTALL_DIR)
-xorg_LTLIBRARIES = r600g_drv.la
-
-r600g_drv_la_SOURCES = \
-	../drm_target.c \
-	xorg.c
-
-r600g_drv_la_LDFLAGS = -module -avoid-version -shared -no-undefined
-
-r600g_drv_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xorg/libxorgtracker.la \
-	$(top_builddir)/src/gallium/drivers/r600/libr600.la \
-	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/galahad/libgalahad.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(LIBDRM_XORG_LIBS) \
-	$(LIBKMS_XORG_LIBS) \
-	$(RADEON_LIBS)
-
-if HAVE_MESA_LLVM
-r600g_drv_la_LINK = $(CXXLINK) $(r600g_drv_la_LDFLAGS)
-# Mention a dummy pure C++ file to trigger generation of the $(LINK) variable
-nodist_EXTRA_r600g_drv_la_SOURCES = dummy-cpp.cpp
-
-r600g_drv_la_LDFLAGS += $(LLVM_LDFLAGS)
-r600g_drv_la_LIBADD += $(LLVM_LIBS)
-else
-r600g_drv_la_LINK = $(LINK) $(r600g_drv_la_LDFLAGS)
-# Mention a dummy pure C file to trigger generation of the $(LINK) variable
-nodist_EXTRA_r600g_drv_la_SOURCES = dummy-c.c
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: r600g_drv.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/r600g_drv.so $(top_builddir)/$(LIB_DIR)/gallium/r600g_drv.so
diff --git a/src/gallium/targets/r600/xorg/xorg.c b/src/gallium/targets/r600/xorg/xorg.c
deleted file mode 100644
index b0b0ef0..0000000
--- a/src/gallium/targets/r600/xorg/xorg.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- * Author: Corbin Simpson <MostAwesomedude@gmail.com>
- *
- */
-
-#include "../../../state_trackers/xorg/xorg_winsys.h"
-
-static void r600_xorg_identify(int flags);
-static Bool r600_xorg_pci_probe(DriverPtr driver,
-				 int entity_num,
-				 struct pci_device *device,
-				 intptr_t match_data);
-
-static const struct pci_id_match r600_xorg_device_match[] = {
-    {0x1002, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, 0},
-    {0, 0, 0},
-};
-
-static SymTabRec r600_xorg_chipsets[] = {
-    {PCI_MATCH_ANY, "AMD R6xx Graphics Chipset"},
-    {-1, NULL}
-};
-
-static PciChipsets r600_xorg_pci_devices[] = {
-    {PCI_MATCH_ANY, PCI_MATCH_ANY, NULL},
-    {-1, -1, NULL}
-};
-
-static XF86ModuleVersionInfo r600_xorg_version = {
-    "r600g",
-    MODULEVENDORSTRING,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XORG_VERSION_CURRENT,
-    0, 1, 0, /* major, minor, patch */
-    ABI_CLASS_VIDEODRV,
-    ABI_VIDEODRV_VERSION,
-    MOD_CLASS_VIDEODRV,
-    {0, 0, 0, 0}
-};
-
-/*
- * Xorg driver exported structures
- */
-
-_X_EXPORT DriverRec r600_driver = {
-    1,
-    "r600g",
-    r600_xorg_identify,
-    NULL,
-    xorg_tracker_available_options,
-    NULL,
-    0,
-    NULL,
-    r600_xorg_device_match,
-    r600_xorg_pci_probe
-};
-
-static MODULESETUPPROTO(r600_xorg_setup);
-
-_X_EXPORT XF86ModuleData r600gModuleData = {
-    &r600_xorg_version,
-    r600_xorg_setup,
-    NULL
-};
-
-/*
- * Xorg driver functions
- */
-
-static pointer
-r600_xorg_setup(pointer module, pointer opts, int *errmaj, int *errmin)
-{
-    static Bool setupDone = 0;
-
-    /* This module should be loaded only once, but check to be sure.
-     */
-    if (!setupDone) {
-	setupDone = 1;
-	xf86AddDriver(&r600_driver, module, HaveDriverFuncs);
-
-	/*
-	 * The return value must be non-NULL on success even though there
-	 * is no TearDownProc.
-	 */
-	return (pointer) 1;
-    } else {
-	if (errmaj)
-	    *errmaj = LDR_ONCEONLY;
-	return NULL;
-    }
-}
-
-static void
-r600_xorg_identify(int flags)
-{
-    xf86PrintChipsets("r600", "Driver for R6xx Gallium with KMS",
-		      r600_xorg_chipsets);
-}
-
-static Bool
-r600_xorg_pci_probe(DriverPtr driver,
-	  int entity_num, struct pci_device *device, intptr_t match_data)
-{
-    ScrnInfoPtr scrn = NULL;
-
-    scrn = xf86ConfigPciEntity(scrn, 0, entity_num, r600_xorg_pci_devices,
-			       NULL, NULL, NULL, NULL, NULL);
-    if (scrn != NULL) {
-	scrn->driverVersion = 1;
-	scrn->driverName = "r600";
-	scrn->name = "R600G";
-	scrn->Probe = NULL;
-
-	/* Use all the functions from the xorg tracker */
-	xorg_tracker_set_functions(scrn);
-    }
-    return scrn != NULL;
-}
diff --git a/src/gallium/targets/r600/xvmc/Makefile.am b/src/gallium/targets/r600/xvmc/Makefile.am
index 2083b87..7fe9b1a 100644
--- a/src/gallium/targets/r600/xvmc/Makefile.am
+++ b/src/gallium/targets/r600/xvmc/Makefile.am
@@ -23,36 +23,23 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
+	$(GALLIUM_VIDEO_CFLAGS)
 
 xvmcdir = $(XVMC_LIB_INSTALL_DIR)
 xvmc_LTLIBRARIES = libXvMCr600.la
 
 libXvMCr600_la_SOURCES = \
-	../drm_target.c \
+	drm_target.c \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
 
 libXvMCr600_la_LDFLAGS = \
-	-module \
-	-version-number $(XVMC_MAJOR):$(XVMC_MINOR) \
-	-shared \
-	-no-undefined
+	$(GALLIUM_XVMC_LINKER_FLAGS)
 
 libXvMCr600_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
 	$(top_builddir)/src/gallium/drivers/r600/libr600.la \
-	$(top_builddir)/src/gallium/state_trackers/xvmc/libxvmctracker.la \
 	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
+	$(GALLIUM_XVMC_LIB_DEPS) \
 	$(GALLIUM_DRI_LIB_DEPS) \
-	$(XVMC_LIBS) \
-	$(LIBDRM_LIBS) \
 	$(RADEON_LIBS)
 
 if HAVE_MESA_LLVM
diff --git a/src/gallium/targets/r600/xvmc/drm_target.c b/src/gallium/targets/r600/xvmc/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/r600/xvmc/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/radeonsi/common/drm_target.c b/src/gallium/targets/radeonsi/common/drm_target.c
new file mode 100644
index 0000000..9eef368
--- /dev/null
+++ b/src/gallium/targets/radeonsi/common/drm_target.c
@@ -0,0 +1,69 @@
+/**************************************************************************
+ *
+ * Copyright 2013 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "state_tracker/drm_driver.h"
+#include "target-helpers/inline_debug_helper.h"
+#include "radeon/drm/radeon_drm_public.h"
+#include "radeon/drm/radeon_winsys.h"
+#include "radeonsi/radeonsi_public.h"
+
+static struct pipe_screen *create_screen(int fd)
+{
+   struct radeon_winsys *radeon;
+
+   radeon = radeon_drm_winsys_create(fd);
+   if (!radeon)
+      return NULL;
+
+   if (!radeon->screen) {
+      radeon->screen = radeonsi_screen_create(radeon);
+      if (!radeon->screen)
+         return NULL;
+
+      radeon->screen = debug_screen_wrap(radeon->screen);
+   }
+
+   return radeon->screen;
+}
+
+static const struct drm_conf_ret throttle_ret = {
+   .type = DRM_CONF_INT,
+   .val.val_int = 2,
+};
+
+static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
+{
+   switch (conf) {
+   case DRM_CONF_THROTTLE:
+      return &throttle_ret;
+   default:
+      break;
+   }
+   return NULL;
+}
+
+DRM_DRIVER_DESCRIPTOR("radeonsi", "radeon", create_screen, drm_configuration)
diff --git a/src/gallium/targets/radeonsi/dri/Makefile.am b/src/gallium/targets/radeonsi/dri/Makefile.am
index 8a78f1b..2c1a58d 100644
--- a/src/gallium/targets/radeonsi/dri/Makefile.am
+++ b/src/gallium/targets/radeonsi/dri/Makefile.am
@@ -23,16 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_DRI_CFLAGS)
 AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_NOOP
@@ -42,9 +34,9 @@ dri_LTLIBRARIES = radeonsi_dri.la
 
 nodist_EXTRA_radeonsi_dri_la_SOURCES = dummy.cpp
 radeonsi_dri_la_SOURCES = \
-	../drm_target.c
+	drm_target.c
 
-radeonsi_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
+radeonsi_dri_la_LDFLAGS = $(GALLIUM_DRI_LINKER_FLAGS)
 
 radeonsi_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/radeonsi/dri/drm_target.c b/src/gallium/targets/radeonsi/dri/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/radeonsi/dri/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/radeonsi/drm_target.c b/src/gallium/targets/radeonsi/drm_target.c
deleted file mode 100644
index 9eef368..0000000
--- a/src/gallium/targets/radeonsi/drm_target.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Advanced Micro Devices, Inc.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- **************************************************************************/
-
-#include "state_tracker/drm_driver.h"
-#include "target-helpers/inline_debug_helper.h"
-#include "radeon/drm/radeon_drm_public.h"
-#include "radeon/drm/radeon_winsys.h"
-#include "radeonsi/radeonsi_public.h"
-
-static struct pipe_screen *create_screen(int fd)
-{
-   struct radeon_winsys *radeon;
-
-   radeon = radeon_drm_winsys_create(fd);
-   if (!radeon)
-      return NULL;
-
-   if (!radeon->screen) {
-      radeon->screen = radeonsi_screen_create(radeon);
-      if (!radeon->screen)
-         return NULL;
-
-      radeon->screen = debug_screen_wrap(radeon->screen);
-   }
-
-   return radeon->screen;
-}
-
-static const struct drm_conf_ret throttle_ret = {
-   .type = DRM_CONF_INT,
-   .val.val_int = 2,
-};
-
-static const struct drm_conf_ret *drm_configuration(enum drm_conf conf)
-{
-   switch (conf) {
-   case DRM_CONF_THROTTLE:
-      return &throttle_ret;
-   default:
-      break;
-   }
-   return NULL;
-}
-
-DRM_DRIVER_DESCRIPTOR("radeonsi", "radeon", create_screen, drm_configuration)
diff --git a/src/gallium/targets/radeonsi/vdpau/Makefile.am b/src/gallium/targets/radeonsi/vdpau/Makefile.am
index f21b340..0292b2b 100644
--- a/src/gallium/targets/radeonsi/vdpau/Makefile.am
+++ b/src/gallium/targets/radeonsi/vdpau/Makefile.am
@@ -20,45 +20,29 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+# Note: Make sure VDPAU_EXPORTS is defined before including Automake.inc
+VDPAU_EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
+	$(GALLIUM_VIDEO_CFLAGS)
 
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_radeonsi.la
 
-EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
-
 nodist_EXTRA_libvdpau_radeonsi_la_SOURCES = dummy.cpp
 libvdpau_radeonsi_la_SOURCES = \
-	../drm_target.c \
+	drm_target.c \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
 
 libvdpau_radeonsi_la_LDFLAGS = \
-	-module \
-	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
-	-export-symbols-regex $(EXPORTS) \
-	-shared \
-	-no-undefined
+	$(GALLIUM_VDPAU_LINKER_FLAGS)
 
 libvdpau_radeonsi_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
 	$(top_builddir)/src/gallium/drivers/radeonsi/libradeonsi.la \
-	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
 	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(top_builddir)/src/gallium/drivers/noop/libnoop.la \
+	$(GALLIUM_VDPAU_LIB_DEPS) \
 	$(GALLIUM_DRI_LIB_DEPS) \
-	$(VDPAU_LIBS) \
-	$(LIBDRM_LIBS) \
 	$(RADEON_LIBS)
 
 if HAVE_MESA_LLVM
diff --git a/src/gallium/targets/radeonsi/vdpau/drm_target.c b/src/gallium/targets/radeonsi/vdpau/drm_target.c
new file mode 120000
index 0000000..6955421
--- /dev/null
+++ b/src/gallium/targets/radeonsi/vdpau/drm_target.c
@@ -0,0 +1 @@
+../common/drm_target.c
\ No newline at end of file
diff --git a/src/gallium/targets/radeonsi/xorg/Makefile.am b/src/gallium/targets/radeonsi/xorg/Makefile.am
deleted file mode 100644
index 5f098d5..0000000
--- a/src/gallium/targets/radeonsi/xorg/Makefile.am
+++ /dev/null
@@ -1,71 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-DHAVE_CONFIG_H \
-	-DGALLIUM_RBUG \
-	-DGALLIUM_TRACE \
-	-DGALLIUM_GALAHAD
-
-xorgdir = $(XORG_DRIVER_INSTALL_DIR)
-xorg_LTLIBRARIES = radeonsi_drv.la
-
-nodist_EXTRA_radeonsi_drv_la_SOURCES = dummy.cpp
-radeonsi_drv_la_SOURCES = \
-	../drm_target.c \
-	xorg.c
-
-radeonsi_drv_la_LDFLAGS = -module -avoid-version -shared -no-undefined
-
-radeonsi_drv_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xorg/libxorgtracker.la \
-	$(top_builddir)/src/gallium/drivers/radeonsi/libradeonsi.la \
-	$(top_builddir)/src/gallium/winsys/radeon/drm/libradeonwinsys.la \
-	$(top_builddir)/src/gallium/drivers/galahad/libgalahad.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(LIBDRM_XORG_LIBS) \
-	$(LIBKMS_XORG_LIBS) \
-	$(RADEON_LIBS)
-
-if HAVE_MESA_LLVM
-AM_CFLAGS += $(LLVM_CFLAGS)
-radeonsi_drv_la_LDFLAGS += $(LLVM_LDFLAGS)
-radeonsi_drv_la_LIBADD += $(LLVM_LIBS)
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: radeonsi_drv.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/radeonsi_drv.so $(top_builddir)/$(LIB_DIR)/gallium/radeonsi_drv.so
diff --git a/src/gallium/targets/radeonsi/xorg/xorg.c b/src/gallium/targets/radeonsi/xorg/xorg.c
deleted file mode 100644
index 7858f03..0000000
--- a/src/gallium/targets/radeonsi/xorg/xorg.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- * Author: Corbin Simpson <MostAwesomedude@gmail.com>
- *
- */
-
-#include "../../../state_trackers/xorg/xorg_winsys.h"
-
-static void radeonsi_xorg_identify(int flags);
-static Bool radeonsi_xorg_pci_probe(DriverPtr driver,
-				 int entity_num,
-				 struct pci_device *device,
-				 intptr_t match_data);
-
-static const struct pci_id_match radeonsi_xorg_device_match[] = {
-    {0x1002, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, 0},
-    {0, 0, 0},
-};
-
-static SymTabRec radeonsi_xorg_chipsets[] = {
-    {PCI_MATCH_ANY, "AMD Southern Islands Graphics Chipset"},
-    {-1, NULL}
-};
-
-static PciChipsets radeonsi_xorg_pci_devices[] = {
-    {PCI_MATCH_ANY, PCI_MATCH_ANY, NULL},
-    {-1, -1, NULL}
-};
-
-static XF86ModuleVersionInfo radeonsi_xorg_version = {
-    "radeonsi",
-    MODULEVENDORSTRING,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XORG_VERSION_CURRENT,
-    0, 1, 0, /* major, minor, patch */
-    ABI_CLASS_VIDEODRV,
-    ABI_VIDEODRV_VERSION,
-    MOD_CLASS_VIDEODRV,
-    {0, 0, 0, 0}
-};
-
-/*
- * Xorg driver exported structures
- */
-
-_X_EXPORT DriverRec radeonsi_driver = {
-    1,
-    "radeonsi",
-    radeonsi_xorg_identify,
-    NULL,
-    xorg_tracker_available_options,
-    NULL,
-    0,
-    NULL,
-    radeonsi_xorg_device_match,
-    radeonsi_xorg_pci_probe
-};
-
-static MODULESETUPPROTO(radeonsi_xorg_setup);
-
-_X_EXPORT XF86ModuleData radeonsiModuleData = {
-    &radeonsi_xorg_version,
-    radeonsi_xorg_setup,
-    NULL
-};
-
-/*
- * Xorg driver functions
- */
-
-static pointer
-radeonsi_xorg_setup(pointer module, pointer opts, int *errmaj, int *errmin)
-{
-    static Bool setupDone = 0;
-
-    /* This module should be loaded only once, but check to be sure.
-     */
-    if (!setupDone) {
-	setupDone = 1;
-	xf86AddDriver(&radeonsi_driver, module, HaveDriverFuncs);
-
-	/*
-	 * The return value must be non-NULL on success even though there
-	 * is no TearDownProc.
-	 */
-	return (pointer) 1;
-    } else {
-	if (errmaj)
-	    *errmaj = LDR_ONCEONLY;
-	return NULL;
-    }
-}
-
-static void
-radeonsi_xorg_identify(int flags)
-{
-    xf86PrintChipsets("radeonsi", "Driver for AMD Radeon SI Gallium with KMS",
-		      radeonsi_xorg_chipsets);
-}
-
-static Bool
-radeonsi_xorg_pci_probe(DriverPtr driver,
-	  int entity_num, struct pci_device *device, intptr_t match_data)
-{
-    ScrnInfoPtr scrn = NULL;
-
-    scrn = xf86ConfigPciEntity(scrn, 0, entity_num, radeonsi_xorg_pci_devices,
-			       NULL, NULL, NULL, NULL, NULL);
-    if (scrn != NULL) {
-	scrn->driverVersion = 1;
-	scrn->driverName = "radeonsi";
-	scrn->name = "RADEONSI";
-	scrn->Probe = NULL;
-
-	/* Use all the functions from the xorg tracker */
-	xorg_tracker_set_functions(scrn);
-    }
-    return scrn != NULL;
-}
diff --git a/src/gallium/targets/vdpau-nouveau/Makefile.am b/src/gallium/targets/vdpau-nouveau/Makefile.am
index 213725a..fbaad03 100644
--- a/src/gallium/targets/vdpau-nouveau/Makefile.am
+++ b/src/gallium/targets/vdpau-nouveau/Makefile.am
@@ -20,15 +20,12 @@
 # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
 
+# Note: Make sure VDPAU_EXPORTS is defined before including Automake.inc
+VDPAU_EXPORTS = '^(vdp_imp_device_create_x11|nouveau_drm_screen_create)$$'
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
+	$(GALLIUM_VIDEO_CFLAGS)
 
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_nouveau.la
@@ -39,20 +36,13 @@ libvdpau_nouveau_la_SOURCES = \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
 
 libvdpau_nouveau_la_LDFLAGS = \
-	-module \
-	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
-	-shared \
-	-no-undefined
+	$(GALLIUM_VDPAU_LINKER_FLAGS)
 
 libvdpau_nouveau_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
 	$(top_builddir)/src/gallium/winsys/nouveau/drm/libnouveaudrm.la \
 	$(top_builddir)/src/gallium/drivers/nouveau/libnouveau.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
+	$(GALLIUM_VDPAU_LIB_DEPS) \
 	$(GALLIUM_DRI_LIB_DEPS) \
-	$(VDPAU_LIBS) \
-	$(LIBDRM_LIBS) \
 	$(NOUVEAU_LIBS)
 
 if HAVE_MESA_LLVM
diff --git a/src/gallium/targets/vdpau-softpipe/Makefile.am b/src/gallium/targets/vdpau-softpipe/Makefile.am
deleted file mode 100644
index 7bde2f8..0000000
--- a/src/gallium/targets/vdpau-softpipe/Makefile.am
+++ /dev/null
@@ -1,72 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
-AM_CPPFLAGS = \
-	-DGALLIUM_SOFTPIPE \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
-
-vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
-vdpau_LTLIBRARIES = libvdpau_softpipe.la
-
-libvdpau_softpipe_la_SOURCES = \
-	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_xsp.c
-
-libvdpau_softpipe_la_LDFLAGS = \
-	-module \
-	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
-	-shared \
-	-no-undefined
-
-libvdpau_softpipe_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/vdpau/libvdpautracker.la \
-	$(top_builddir)/src/gallium/winsys/sw/xlib/libws_xlib.la \
-	$(top_builddir)/src/gallium/drivers/softpipe/libsoftpipe.la \
-	$(VDPAU_LIBS) \
-	$(DLOPEN_LIBS) \
-	$(LIBDRM_LIBS)
-
-if HAVE_MESA_LLVM
-libvdpau_softpipe_la_LINK = $(CXXLINK) $(libvdpau_softpipe_la_LDFLAGS)
-# Mention a dummy pure C++ file to trigger generation of the $(LINK) variable
-nodist_EXTRA_libvdpau_softpipe_la_SOURCES = dummy-cpp.cpp
-
-AM_CPPFLAGS += -DGALLIUM_LLVMPIPE
-libvdpau_softpipe_la_LIBADD += $(top_builddir)/src/gallium/drivers/llvmpipe/libllvmpipe.la $(LLVM_LIBS)
-else
-libvdpau_softpipe_la_LINK = $(LINK) $(libvdpau_softpipe_la_LDFLAGS)
-# Mention a dummy pure C file to trigger generation of the $(LINK) variable
-nodist_EXTRA_libvdpau_softpipe_la_SOURCES = dummy-c.c
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: libvdpau_softpipe.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/libvdpau_softpipe.so* $(top_builddir)/$(LIB_DIR)/gallium/
diff --git a/src/gallium/targets/xorg-i915/Makefile.am b/src/gallium/targets/xorg-i915/Makefile.am
deleted file mode 100644
index ed2ab8a..0000000
--- a/src/gallium/targets/xorg-i915/Makefile.am
+++ /dev/null
@@ -1,76 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-DHAVE_CONFIG_H \
-	-DGALLIUM_RBUG \
-	-DGALLIUM_TRACE \
-	-DGALLIUM_GALAHAD
-
-xorgdir = $(XORG_DRIVER_INSTALL_DIR)
-xorg_LTLIBRARIES = i915_drv.la
-
-i915_drv_la_SOURCES = \
-	intel_target.c \
-	intel_xorg.c
-
-i915_drv_la_LDFLAGS = -module -avoid-version -shared -no-undefined
-
-i915_drv_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xorg/libxorgtracker.la \
-	$(top_builddir)/src/gallium/winsys/i915/drm/libi915drm.la \
-	$(top_builddir)/src/gallium/drivers/i915/libi915.la \
-	$(top_builddir)/src/gallium/drivers/galahad/libgalahad.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(LIBDRM_XORG_LIBS) \
-	$(LIBKMS_XORG_LIBS) \
-	$(INTEL_LIBS)
-
-if HAVE_MESA_LLVM
-i915_drv_la_LINK = $(CXXLINK) $(i915_drv_la_LDFLAGS)
-# Mention a dummy pure C++ file to trigger generation of the $(LINK) variable
-nodist_EXTRA_i915_drv_la_SOURCES = dummy-cpp.cpp
-
-AM_CPPFLAGS += -DGALLIUM_LLVMPIPE
-i915_drv_la_LIBADD += $(top_builddir)/src/gallium/drivers/llvmpipe/libllvmpipe.la $(LLVM_LIBS)
-else
-i915_drv_la_LINK = $(LINK) $(i915_drv_la_LDFLAGS)
-# Mention a dummy pure C file to trigger generation of the $(LINK) variable
-nodist_EXTRA_i915_drv_la_SOURCES = dummy-c.c
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: i915_drv.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/i915_drv.so $(top_builddir)/$(LIB_DIR)/gallium/i915_drv.so
diff --git a/src/gallium/targets/xorg-i915/intel_target.c b/src/gallium/targets/xorg-i915/intel_target.c
deleted file mode 100644
index 50efa21..0000000
--- a/src/gallium/targets/xorg-i915/intel_target.c
+++ /dev/null
@@ -1,26 +0,0 @@
-
-#include "state_tracker/drm_driver.h"
-#include "target-helpers/inline_debug_helper.h"
-#include "i915/drm/i915_drm_public.h"
-#include "i915/i915_public.h"
-
-static struct pipe_screen *
-create_screen(int fd)
-{
-   struct i915_winsys *iws;
-   struct pipe_screen *screen;
-
-   iws = i915_drm_winsys_create(fd);
-   if (!iws)
-      return NULL;
-
-   screen = i915_screen_create(iws);
-   if (!screen)
-      return NULL;
-
-   screen = debug_screen_wrap(screen);
-
-   return screen;
-}
-
-DRM_DRIVER_DESCRIPTOR("i915", "i915", create_screen, NULL)
diff --git a/src/gallium/targets/xorg-i915/intel_xorg.c b/src/gallium/targets/xorg-i915/intel_xorg.c
deleted file mode 100644
index d8eb258..0000000
--- a/src/gallium/targets/xorg-i915/intel_xorg.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include "../../state_trackers/xorg/xorg_winsys.h"
-
-static void intel_xorg_identify(int flags);
-static Bool intel_xorg_pci_probe(DriverPtr driver,
-				 int entity_num,
-				 struct pci_device *device,
-				 intptr_t match_data);
-
-static const struct pci_id_match intel_xorg_device_match[] = {
-    {0x8086, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0, 0},
-    {0, 0, 0},
-};
-
-static SymTabRec intel_xorg_chipsets[] = {
-    {PCI_MATCH_ANY, "Intel Graphics Device"},
-    {-1, NULL}
-};
-
-static PciChipsets intel_xorg_pci_devices[] = {
-    {PCI_MATCH_ANY, PCI_MATCH_ANY, NULL},
-    {-1, -1, NULL}
-};
-
-static XF86ModuleVersionInfo intel_xorg_version = {
-    "i915",
-    MODULEVENDORSTRING,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XORG_VERSION_CURRENT,
-    0, 1, 0, /* major, minor, patch */
-    ABI_CLASS_VIDEODRV,
-    ABI_VIDEODRV_VERSION,
-    MOD_CLASS_VIDEODRV,
-    {0, 0, 0, 0}
-};
-
-/*
- * Xorg driver exported structures
- */
-
-_X_EXPORT DriverRec modesetting = {
-    1,
-    "modesetting",
-    intel_xorg_identify,
-    NULL,
-    xorg_tracker_available_options,
-    NULL,
-    0,
-    NULL,
-    intel_xorg_device_match,
-    intel_xorg_pci_probe
-};
-
-static MODULESETUPPROTO(intel_xorg_setup);
-
-_X_EXPORT XF86ModuleData modesettingModuleData = {
-    &intel_xorg_version,
-    intel_xorg_setup,
-    NULL
-};
-
-/*
- * Xorg driver functions
- */
-
-static pointer
-intel_xorg_setup(pointer module, pointer opts, int *errmaj, int *errmin)
-{
-    static Bool setupDone = 0;
-
-    /* This module should be loaded only once, but check to be sure.
-     */
-    if (!setupDone) {
-	setupDone = 1;
-	xf86AddDriver(&modesetting, module, HaveDriverFuncs);
-
-	/*
-	 * The return value must be non-NULL on success even though there
-	 * is no TearDownProc.
-	 */
-	return (pointer) 1;
-    } else {
-	if (errmaj)
-	    *errmaj = LDR_ONCEONLY;
-	return NULL;
-    }
-}
-
-static void
-intel_xorg_identify(int flags)
-{
-    xf86PrintChipsets("modesetting", "Driver for Modesetting Kernel Drivers",
-		      intel_xorg_chipsets);
-}
-
-static Bool
-intel_xorg_pci_probe(DriverPtr driver,
-	  int entity_num, struct pci_device *device, intptr_t match_data)
-{
-    ScrnInfoPtr scrn = NULL;
-
-    scrn = xf86ConfigPciEntity(scrn, 0, entity_num, intel_xorg_pci_devices,
-			       NULL, NULL, NULL, NULL, NULL);
-    if (scrn != NULL) {
-	scrn->driverVersion = 1;
-	scrn->driverName = "i915";
-	scrn->name = "modesetting";
-	scrn->Probe = NULL;
-
-	/* Use all the functions from the xorg tracker */
-	xorg_tracker_set_functions(scrn);
-    }
-    return scrn != NULL;
-}
diff --git a/src/gallium/targets/xorg-nouveau/Makefile.am b/src/gallium/targets/xorg-nouveau/Makefile.am
deleted file mode 100644
index 210d4a2..0000000
--- a/src/gallium/targets/xorg-nouveau/Makefile.am
+++ /dev/null
@@ -1,68 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys \
-	-DHAVE_CONFIG_H \
-	-DGALLIUM_RBUG \
-	-DGALLIUM_TRACE
-
-xorgdir = $(XORG_DRIVER_INSTALL_DIR)
-xorg_LTLIBRARIES = nouveau2_drv.la
-
-nodist_EXTRA_nouveau2_drv_la_SOURCES = dummy.cpp
-nouveau2_drv_la_SOURCES = \
-	nouveau_target.c \
-	nouveau_xorg.c
-
-nouveau2_drv_la_LDFLAGS = -module -avoid-version -shared -no-undefined
-
-nouveau2_drv_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xorg/libxorgtracker.la \
-	$(top_builddir)/src/gallium/winsys/nouveau/drm/libnouveaudrm.la \
-	$(top_builddir)/src/gallium/drivers/nouveau/libnouveau.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
-	$(top_builddir)/src/gallium/drivers/rbug/librbug.la \
-	$(GALLIUM_DRI_LIB_DEPS) \
-	$(LIBDRM_XORG_LIBS) \
-	$(LIBKMS_XORG_LIBS) \
-	$(NOUVEAU_LIBS)
-
-if HAVE_MESA_LLVM
-AM_CFLAGS += $(LLVM_CFLAGS)
-nouveau2_drv_la_LDFLAGS += $(LLVM_LDFLAGS)
-nouveau2_drv_la_LIBADD += $(LLVM_LIBS)
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: nouveau2_drv.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/nouveau2_drv.so $(top_builddir)/$(LIB_DIR)/gallium/nouveau2_drv.so
diff --git a/src/gallium/targets/xorg-nouveau/nouveau_target.c b/src/gallium/targets/xorg-nouveau/nouveau_target.c
deleted file mode 100644
index c0d7f92..0000000
--- a/src/gallium/targets/xorg-nouveau/nouveau_target.c
+++ /dev/null
@@ -1,20 +0,0 @@
-
-#include "target-helpers/inline_debug_helper.h"
-#include "state_tracker/drm_driver.h"
-#include "nouveau/drm/nouveau_drm_public.h"
-
-static struct pipe_screen *
-create_screen(int fd)
-{
-   struct pipe_screen *screen;
-
-   screen = nouveau_drm_screen_create(fd);
-   if (!screen)
-      return NULL;
-
-   screen = debug_screen_wrap(screen);
-
-   return screen;
-}
-
-DRM_DRIVER_DESCRIPTOR("nouveau", "nouveau", create_screen, NULL)
diff --git a/src/gallium/targets/xorg-nouveau/nouveau_xorg.c b/src/gallium/targets/xorg-nouveau/nouveau_xorg.c
deleted file mode 100644
index 2e44ddb..0000000
--- a/src/gallium/targets/xorg-nouveau/nouveau_xorg.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright 2008 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- *
- * Author: Alan Hourihane <alanh@tungstengraphics.com>
- * Author: Jakob Bornecrantz <wallbraker@gmail.com>
- *
- */
-
-#include "../../state_trackers/xorg/xorg_winsys.h"
-#include <nouveau.h>
-#include <xf86drmMode.h>
-
-static void nouveau_xorg_identify(int flags);
-static Bool nouveau_xorg_pci_probe(DriverPtr driver, int entity_num,
-				   struct pci_device *device,
-				   intptr_t match_data);
-
-static const struct pci_id_match nouveau_xorg_device_match[] = {
-    { 0x10de, PCI_MATCH_ANY, PCI_MATCH_ANY, PCI_MATCH_ANY,
-      0x00030000, 0x00ffffff, 0 },
-    {0, 0, 0},
-};
-
-static PciChipsets nouveau_xorg_pci_devices[] = {
-    {PCI_MATCH_ANY, PCI_MATCH_ANY, NULL},
-    {-1, -1, NULL}
-};
-
-static XF86ModuleVersionInfo nouveau_xorg_version = {
-    "nouveau2",
-    MODULEVENDORSTRING,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XORG_VERSION_CURRENT,
-    0, 1, 0, /* major, minor, patch */
-    ABI_CLASS_VIDEODRV,
-    ABI_VIDEODRV_VERSION,
-    MOD_CLASS_VIDEODRV,
-    {0, 0, 0, 0}
-};
-
-/*
- * Xorg driver exported structures
- */
-
-_X_EXPORT DriverRec nouveau2 = {
-    1,
-    "nouveau2",
-    nouveau_xorg_identify,
-    NULL,
-    xorg_tracker_available_options,
-    NULL,
-    0,
-    NULL,
-    nouveau_xorg_device_match,
-    nouveau_xorg_pci_probe
-};
-
-static MODULESETUPPROTO(nouveau_xorg_setup);
-
-_X_EXPORT XF86ModuleData nouveau2ModuleData = {
-    &nouveau_xorg_version,
-    nouveau_xorg_setup,
-    NULL
-};
-
-/*
- * Xorg driver functions
- */
-
-static pointer
-nouveau_xorg_setup(pointer module, pointer opts, int *errmaj, int *errmin)
-{
-    static Bool setupDone = 0;
-
-    /* This module should be loaded only once, but check to be sure.
-     */
-    if (!setupDone) {
-	setupDone = 1;
-	xf86AddDriver(&nouveau2, module, HaveDriverFuncs);
-
-	/*
-	 * The return value must be non-NULL on success even though there
-	 * is no TearDownProc.
-	 */
-	return (pointer) 1;
-    } else {
-	if (errmaj)
-	    *errmaj = LDR_ONCEONLY;
-	return NULL;
-    }
-}
-
-static void
-nouveau_xorg_identify(int flags)
-{
-    xf86DrvMsg(0, X_INFO, "nouveau2: Gallium3D based 2D driver for NV30+ NVIDIA chipsets\n");
-}
-
-static Bool
-nouveau_xorg_pci_probe(DriverPtr driver,
-	  int entity_num, struct pci_device *device, intptr_t match_data)
-{
-    ScrnInfoPtr scrn = NULL;
-    struct nouveau_device *dev = NULL;
-    char *busid;
-    int chipset, ret;
-
-    busid = malloc(64);
-    if (!busid)
-	return FALSE;
-
-    sprintf(busid, "pci:%04x:%02x:%02x.%d",
-	    device->domain, device->bus,
-	    device->dev, device->func);
-
-    ret = drmCheckModesettingSupported(busid);
-    if (ret) {
-	xf86DrvMsg(-1, X_ERROR, "[drm] KMS not enabled\n");
-	free(busid);
-	return FALSE;
-    }
-
-    ret = nouveau_device_open(busid, &dev);
-    free(busid);
-    if (ret) {
-	xf86DrvMsg(-1, X_ERROR, "[drm] failed to open device\n");
-	return FALSE;
-    }
-
-    chipset = dev->chipset;
-    nouveau_device_del(&dev);
-
-    switch (chipset & 0xf0) {
-    case 0x00:
-    case 0x10:
-    case 0x20:
-	xf86DrvMsg(-1, X_NOTICE, "Too old chipset: NV%02x\n", chipset);
-	return FALSE;
-    case 0x30:
-    case 0x40:
-    case 0x60:
-    case 0x50:
-    case 0x80:
-    case 0x90:
-    case 0xa0:
-    case 0xc0:
-    case 0xd0:
-    case 0xe0:
-    case 0xf0:
-	xf86DrvMsg(-1, X_INFO, "Detected chipset: NV%02x\n", chipset);
-	break;
-    default:
-	xf86DrvMsg(-1, X_ERROR, "Unknown chipset: NV%02x\n", chipset);
-	return FALSE;
-    }
-
-    scrn = xf86ConfigPciEntity(scrn, 0, entity_num, nouveau_xorg_pci_devices,
-			       NULL, NULL, NULL, NULL, NULL);
-    if (scrn != NULL) {
-	scrn->driverVersion = 1;
-	scrn->driverName = "nouveau";
-	scrn->name = "nouveau2";
-	scrn->Probe = NULL;
-
-	/* Use all the functions from the xorg tracker */
-	xorg_tracker_set_functions(scrn);
-    }
-    return scrn != NULL;
-}
diff --git a/src/gallium/targets/xvmc-nouveau/Makefile.am b/src/gallium/targets/xvmc-nouveau/Makefile.am
index f3d6b1e..4a45f41 100644
--- a/src/gallium/targets/xvmc-nouveau/Makefile.am
+++ b/src/gallium/targets/xvmc-nouveau/Makefile.am
@@ -23,12 +23,7 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
+	$(GALLIUM_VIDEO_CFLAGS)
 
 xvmcdir = $(XVMC_LIB_INSTALL_DIR)
 xvmc_LTLIBRARIES = libXvMCnouveau.la
@@ -39,20 +34,13 @@ libXvMCnouveau_la_SOURCES = \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
 
 libXvMCnouveau_la_LDFLAGS = \
-	-module \
-	-version-number $(XVMC_MAJOR):$(XVMC_MINOR)
-	-shared \
-	-no-undefined
+	$(GALLIUM_XVMC_LINKER_FLAGS)
 
 libXvMCnouveau_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xvmc/libxvmctracker.la \
 	$(top_builddir)/src/gallium/winsys/nouveau/drm/libnouveaudrm.la \
 	$(top_builddir)/src/gallium/drivers/nouveau/libnouveau.la \
-	$(top_builddir)/src/gallium/drivers/trace/libtrace.la \
+	$(GALLIUM_XVMC_LIB_DEPS) \
 	$(GALLIUM_DRI_LIB_DEPS) \
-	$(XVMC_LIBS) \
-	$(LIBDRM_LIBS) \
 	$(NOUVEAU_LIBS)
 
 if HAVE_MESA_LLVM
diff --git a/src/gallium/targets/xvmc-softpipe/Makefile.am b/src/gallium/targets/xvmc-softpipe/Makefile.am
deleted file mode 100644
index eea6700..0000000
--- a/src/gallium/targets/xvmc-softpipe/Makefile.am
+++ /dev/null
@@ -1,72 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
-# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-include $(top_srcdir)/src/gallium/Automake.inc
-
-AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
-AM_CPPFLAGS = \
-	-DGALLIUM_SOFTPIPE \
-	-I$(top_srcdir)/src/gallium/drivers \
-	-I$(top_srcdir)/src/gallium/winsys
-
-xvmcdir = $(XVMC_LIB_INSTALL_DIR)
-xvmc_LTLIBRARIES = libXvMCsoftpipe.la
-
-libXvMCsoftpipe_la_SOURCES = \
-	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_xsp.c
-
-libXvMCsoftpipe_la_LDFLAGS = \
-	-module \
-	-version-number $(XVMC_MAJOR):$(XVMC_MINOR) \
-	-shared \
-	-no-undefined
-
-libXvMCsoftpipe_la_LIBADD = \
-	$(top_builddir)/src/gallium/auxiliary/libgallium.la \
-	$(top_builddir)/src/gallium/state_trackers/xvmc/libxvmctracker.la \
-	$(top_builddir)/src/gallium/winsys/sw/xlib/libws_xlib.la \
-	$(top_builddir)/src/gallium/drivers/softpipe/libsoftpipe.la \
-	$(XVMC_LIBS) \
-	$(DLOPEN_LIBS) \
-	$(LIBDRM_LIBS)
-
-if HAVE_MESA_LLVM
-libXvMCsoftpipe_la_LINK = $(CXXLINK) $(libXvMCsoftpipe_la_LDFLAGS)
-# Mention a dummy pure C++ file to trigger generation of the $(LINK) variable
-nodist_EXTRA_libXvMCsoftpipe_la_SOURCES = dummy-cpp.cpp
-
-AM_CPPFLAGS += -DGALLIUM_LLVMPIPE
-libXvMCsoftpipe_la_LIBADD += $(top_builddir)/src/gallium/drivers/llvmpipe/libllvmpipe.la $(LLVM_LIBS)
-else
-libXvMCsoftpipe_la_LINK = $(LINK) $(libXvMCsoftpipe_la_LDFLAGS)
-# Mention a dummy pure C file to trigger generation of the $(LINK) variable
-nodist_EXTRA_libXvMCsoftpipe_la_SOURCES = dummy-c.c
-endif
-
-# Provide compatibility with scripts for the old Mesa build system for
-# a while by putting a link to the driver into /lib of the build tree.
-all-local: libXvMCsoftpipe.la
-	$(MKDIR_P) $(top_builddir)/$(LIB_DIR)/gallium
-	ln -f .libs/libXvMCsoftpipe.so* $(top_builddir)/$(LIB_DIR)/gallium/
diff --git a/src/gallium/tools/trace/dump_state.py b/src/gallium/tools/trace/dump_state.py
index 8c3bdab..293d609 100755
--- a/src/gallium/tools/trace/dump_state.py
+++ b/src/gallium/tools/trace/dump_state.py
@@ -104,7 +104,7 @@ class Struct:
         return obj
 
     def __repr__(self):
-        return repr(self.__json__)
+        return repr(self.__json__())
 
 
 class Translator(model.Visitor):
@@ -239,11 +239,12 @@ class Context(Dispatcher):
         self._state.vs.shader = None
         self._state.gs.shader = None
         self._state.fs.shader = None
-        self._state.sampler = {}
         self._state.vs.sampler = []
         self._state.gs.sampler = []
         self._state.fs.sampler = []
-        self._state.sampler_views = {}
+        self._state.vs.sampler_views = []
+        self._state.gs.sampler_views = []
+        self._state.fs.sampler_views = []
         self._state.vs.constant_buffer = []
         self._state.gs.constant_buffer = []
         self._state.fs.constant_buffer = []
@@ -280,7 +281,21 @@ class Context(Dispatcher):
         pass
 
     def bind_sampler_states(self, shader, start, num_states, states):
-        self._state.sampler[shader] = states
+        # FIXME: Handle non-zero start
+        assert start == 0
+        self._get_stage_state(shader).sampler = states
+
+    def bind_vertex_sampler_states(self, num_states, states):
+        # XXX: deprecated method
+        self._state.vs.sampler = states
+
+    def bind_geometry_sampler_states(self, num_states, states):
+        # XXX: deprecated method
+        self._state.gs.sampler = states
+
+    def bind_fragment_sampler_states(self, num_states, states):
+        # XXX: deprecated method
+        self._state.fs.sampler = states
         
     def create_rasterizer_state(self, state):
         return state
@@ -399,7 +414,21 @@ class Context(Dispatcher):
         pass
 
     def set_sampler_views(self, shader, start, num, views):
-        self._state.sampler_views[shader] = views
+        # FIXME: Handle non-zero start
+        assert start == 0
+        self._get_stage_state(shader).sampler_views = views
+
+    def set_fragment_sampler_views(self, num, views):
+        # XXX: deprecated
+        self._state.fs.sampler_views = views
+
+    def set_geometry_sampler_views(self, num, views):
+        # XXX: deprecated
+        self._state.gs.sampler_views = views
+
+    def set_vertex_sampler_views(self, num, views):
+        # XXX: deprecated
+        self._state.vs.sampler_views = views
 
     def set_vertex_buffers(self, start_slot, num_buffers, buffers):
         self._update(self._state.vertex_buffers, start_slot, num_buffers, buffers)
@@ -432,6 +461,10 @@ class Context(Dispatcher):
 
         assert struct.calcsize(format) == index_size
 
+        if self._state.index_buffer.buffer is None:
+            # Could happen with index in user memory
+            return 0, 0
+
         data = self._state.index_buffer.buffer.data
         max_index, min_index = 0, 0xffffffff
 
@@ -535,8 +568,11 @@ class Context(Dispatcher):
                 register = registers.setdefault(file_, set())
                 register.add(int(index))
 
+        if 'SAMP' in registers and 'SVIEW' not in registers:
+            registers['SVIEW'] = registers['SAMP']
+
         mapping = [
-            ("CONST", "constant_buffer"),
+            #("CONST", "constant_buffer"),
             ("SAMP", "sampler"),
             ("SVIEW", "sampler_views"),
         ]
@@ -599,9 +635,9 @@ class Context(Dispatcher):
     def transfer_inline_write(self, resource, level, usage, box, stride, layer_stride, data):
         if resource is not None and resource.target == PIPE_BUFFER:
             data = data.getValue()
-            assert len(data) == box.width
+            assert len(data) >= box.width
             assert box.x + box.width <= len(resource.data)
-            resource.data[box.x : box.x + box.width] = data
+            resource.data[box.x : box.x + box.width] = data[:box.width]
 
     def flush(self, flags):
         # Return a fake fence
@@ -667,7 +703,11 @@ class Interpreter(parser.TraceDumper):
         pass
 
     def lookup_object(self, address):
-        return self.objects[address]
+        try:
+            return self.objects[address]
+        except KeyError:
+            # Could happen, e.g., with user memory pointers
+            return address
     
     def interpret(self, trace):
         for call in trace.calls:
diff --git a/src/gallium/winsys/freedreno/drm/Makefile.am b/src/gallium/winsys/freedreno/drm/Makefile.am
index 8a74dcd..cf4c24c 100644
--- a/src/gallium/winsys/freedreno/drm/Makefile.am
+++ b/src/gallium/winsys/freedreno/drm/Makefile.am
@@ -25,7 +25,7 @@ include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(FREEDRENO_CFLAGS)
 
 noinst_LTLIBRARIES = libfreedrenodrm.la
diff --git a/src/gallium/winsys/i915/drm/Makefile.am b/src/gallium/winsys/i915/drm/Makefile.am
index 7a64925..82c477d 100644
--- a/src/gallium/winsys/i915/drm/Makefile.am
+++ b/src/gallium/winsys/i915/drm/Makefile.am
@@ -24,9 +24,8 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(INTEL_CFLAGS)
 
 noinst_LTLIBRARIES = libi915drm.la
diff --git a/src/gallium/winsys/i915/sw/Makefile.am b/src/gallium/winsys/i915/sw/Makefile.am
index 186fee3..39f6022 100644
--- a/src/gallium/winsys/i915/sw/Makefile.am
+++ b/src/gallium/winsys/i915/sw/Makefile.am
@@ -24,9 +24,8 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(INTEL_CFLAGS)
 
 noinst_LTLIBRARIES = libi915sw.la
diff --git a/src/gallium/winsys/intel/drm/Makefile.am b/src/gallium/winsys/intel/drm/Makefile.am
index 3c4a271..30f4486 100644
--- a/src/gallium/winsys/intel/drm/Makefile.am
+++ b/src/gallium/winsys/intel/drm/Makefile.am
@@ -25,9 +25,8 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(INTEL_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_WINSYS_CFLAGS) \
+	$(INTEL_CFLAGS)
 
 noinst_LTLIBRARIES = libintelwinsys.la
 
diff --git a/src/gallium/winsys/nouveau/drm/Makefile.am b/src/gallium/winsys/nouveau/drm/Makefile.am
index f9645f5..9c94ea4 100644
--- a/src/gallium/winsys/nouveau/drm/Makefile.am
+++ b/src/gallium/winsys/nouveau/drm/Makefile.am
@@ -24,9 +24,8 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(NOUVEAU_CFLAGS)
 
 noinst_LTLIBRARIES = libnouveaudrm.la
diff --git a/src/gallium/winsys/radeon/drm/Makefile.am b/src/gallium/winsys/radeon/drm/Makefile.am
index d5c5474..b413b0b 100644
--- a/src/gallium/winsys/radeon/drm/Makefile.am
+++ b/src/gallium/winsys/radeon/drm/Makefile.am
@@ -2,10 +2,8 @@ include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
-	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS) \
-	$(RADEON_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+	$(GALLIUM_WINSYS_CFLAGS) \
+	$(RADEON_CFLAGS)
 
 noinst_LTLIBRARIES = libradeonwinsys.la
 
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
index e5723a5..acb12b2 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
@@ -491,8 +491,13 @@ static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs, unsigned flags, ui
 				    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
 		    }
 	    } else {
-		    while (rcs->cdw & 7)
-			    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
+		    if (cs->ws->info.chip_class <= SI) {
+			    while (rcs->cdw & 7)
+				    OUT_CS(&cs->base, 0x80000000); /* type2 nop packet */
+		    } else {
+			    while (rcs->cdw & 7)
+				    OUT_CS(&cs->base, 0xffff1000); /* type3 nop packet */
+		    }
 	    }
 	    break;
     case RING_UVD:
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
index 8a8f180..1860810 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_winsys.c
@@ -330,6 +330,7 @@ static boolean do_winsys_init(struct radeon_drm_winsys *ws)
     case CHIP_BONAIRE:
     case CHIP_KAVERI:
     case CHIP_KABINI:
+    case CHIP_HAWAII:
         ws->info.chip_class = CIK;
         break;
     }
diff --git a/src/gallium/winsys/radeon/drm/radeon_winsys.h b/src/gallium/winsys/radeon/drm/radeon_winsys.h
index c000371..d59f48f 100644
--- a/src/gallium/winsys/radeon/drm/radeon_winsys.h
+++ b/src/gallium/winsys/radeon/drm/radeon_winsys.h
@@ -128,6 +128,7 @@ enum radeon_family {
     CHIP_BONAIRE,
     CHIP_KAVERI,
     CHIP_KABINI,
+    CHIP_HAWAII,
     CHIP_LAST,
 };
 
diff --git a/src/gallium/winsys/svga/drm/Makefile.am b/src/gallium/winsys/svga/drm/Makefile.am
index d7ada3c..69398b8 100644
--- a/src/gallium/winsys/svga/drm/Makefile.am
+++ b/src/gallium/winsys/svga/drm/Makefile.am
@@ -23,16 +23,13 @@
 include Makefile.sources
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
+AM_CFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers/svga \
 	-I$(top_srcdir)/src/gallium/drivers/svga/include \
-	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/gallium/drivers \
-	$(GALLIUM_CFLAGS) \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(LIBDRM_CFLAGS)
 
-AM_CFLAGS = $(VISIBILITY_CFLAGS)
-
 #On some systems -std= must be added to CFLAGS to be the last -std=
 CFLAGS += -std=gnu99 -D_FILE_OFFSET_BITS=64
 
diff --git a/src/gallium/winsys/sw/dri/Makefile.am b/src/gallium/winsys/sw/dri/Makefile.am
index d987c15..182825e 100644
--- a/src/gallium/winsys/sw/dri/Makefile.am
+++ b/src/gallium/winsys/sw/dri/Makefile.am
@@ -22,9 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS) \
-	$(VISIBILITY_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS)
 
 noinst_LTLIBRARIES = libswdri.la
 
diff --git a/src/gallium/winsys/sw/fbdev/Makefile.am b/src/gallium/winsys/sw/fbdev/Makefile.am
index 801f689..93abe81 100644
--- a/src/gallium/winsys/sw/fbdev/Makefile.am
+++ b/src/gallium/winsys/sw/fbdev/Makefile.am
@@ -22,8 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS)
 
 noinst_LTLIBRARIES = libfbdev.la
 
diff --git a/src/gallium/winsys/sw/null/Makefile.am b/src/gallium/winsys/sw/null/Makefile.am
index fb450dd..17b52cc 100644
--- a/src/gallium/winsys/sw/null/Makefile.am
+++ b/src/gallium/winsys/sw/null/Makefile.am
@@ -22,8 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS)
 
 noinst_LTLIBRARIES = libws_null.la
 
diff --git a/src/gallium/winsys/sw/wayland/Makefile.am b/src/gallium/winsys/sw/wayland/Makefile.am
index 40ec7d9..0cb47a1 100644
--- a/src/gallium/winsys/sw/wayland/Makefile.am
+++ b/src/gallium/winsys/sw/wayland/Makefile.am
@@ -22,8 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS) \
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(WAYLAND_CFLAGS)
 
 noinst_LTLIBRARIES = libws_wayland.la
diff --git a/src/gallium/winsys/sw/wrapper/Makefile.am b/src/gallium/winsys/sw/wrapper/Makefile.am
index 3dcd6ad..d8bbd9e 100644
--- a/src/gallium/winsys/sw/wrapper/Makefile.am
+++ b/src/gallium/winsys/sw/wrapper/Makefile.am
@@ -22,8 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS)
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS)
 
 noinst_LTLIBRARIES = libwsw.la
 
diff --git a/src/gallium/winsys/sw/xlib/Makefile.am b/src/gallium/winsys/sw/xlib/Makefile.am
index ea6b742..a38189c 100644
--- a/src/gallium/winsys/sw/xlib/Makefile.am
+++ b/src/gallium/winsys/sw/xlib/Makefile.am
@@ -22,8 +22,8 @@
 
 include $(top_srcdir)/src/gallium/Automake.inc
 
-AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS) \
+AM_CFLAGS = \
+	$(GALLIUM_WINSYS_CFLAGS) \
 	$(X11_INCLUDES)
 
 noinst_LTLIBRARIES = libws_xlib.la
diff --git a/src/gbm/Makefile.am b/src/gbm/Makefile.am
index 1282b14..9b3fb0d 100644
--- a/src/gbm/Makefile.am
+++ b/src/gbm/Makefile.am
@@ -1,3 +1,5 @@
+AUTOMAKE_OPTIONS = subdir-objects
+
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = main/gbm.pc
 
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index e95fcc7..6c63c75 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -104,6 +104,24 @@ dri_get_buffers_with_format(__DRIdrawable * driDrawable,
                                    count, out_count, surf->dri_private);
 }
 
+static int
+image_get_buffers(__DRIdrawable *driDrawable,
+                  unsigned int format,
+                  uint32_t *stamp,
+                  void *loaderPrivate,
+                  uint32_t buffer_mask,
+                  struct __DRIimageList *buffers)
+{
+   struct gbm_dri_surface *surf = loaderPrivate;
+   struct gbm_dri_device *dri = gbm_dri_device(surf->base.gbm);
+
+   if (dri->image_get_buffers == NULL)
+      return 0;
+
+   return dri->image_get_buffers(driDrawable, format, stamp,
+                                 surf->dri_private, buffer_mask, buffers);
+}
+
 static const __DRIuseInvalidateExtension use_invalidate = {
    { __DRI_USE_INVALIDATE, 1 }
 };
@@ -120,6 +138,13 @@ const __DRIdri2LoaderExtension dri2_loader_extension = {
    dri_get_buffers_with_format,
 };
 
+const __DRIimageLoaderExtension image_loader_extension = {
+   { __DRI_IMAGE_LOADER, 1 },
+   image_get_buffers,
+   dri_flush_front_buffer,
+};
+
+
 struct dri_extension_match {
    const char *name;
    int version;
@@ -258,7 +283,8 @@ dri_screen_create(struct gbm_dri_device *dri)
    dri->extensions[0] = &image_lookup_extension.base;
    dri->extensions[1] = &use_invalidate.base;
    dri->extensions[2] = &dri2_loader_extension.base;
-   dri->extensions[3] = NULL;
+   dri->extensions[3] = &image_loader_extension.base;
+   dri->extensions[4] = NULL;
 
    if (dri->dri2 == NULL)
       return -1;
diff --git a/src/gbm/backends/dri/gbm_driint.h b/src/gbm/backends/dri/gbm_driint.h
index cb4e477..fb303a3 100644
--- a/src/gbm/backends/dri/gbm_driint.h
+++ b/src/gbm/backends/dri/gbm_driint.h
@@ -52,7 +52,7 @@ struct gbm_dri_device {
    __DRIdri2LoaderExtension *loader;
 
    const __DRIconfig   **driver_configs;
-   const __DRIextension *extensions[4];
+   const __DRIextension *extensions[5];
    const __DRIextension **driver_extensions;
 
    __DRIimage *(*lookup_image)(__DRIscreen *screen, void *image, void *data);
@@ -67,6 +67,12 @@ struct gbm_dri_device {
 			     int *width, int *height,
 			     unsigned int *attachments, int count,
 			     int *out_count, void *data);
+   int (*image_get_buffers)(__DRIdrawable *driDrawable,
+                            unsigned int format,
+                            uint32_t *stamp,
+                            void *loaderPrivate,
+                            uint32_t buffer_mask,
+                            struct __DRIimageList *buffers);
 
    struct wl_drm *wl_drm;
 };
diff --git a/src/glsl/Makefile.sources b/src/glsl/Makefile.sources
index 2aabc05..2e81ded 100644
--- a/src/glsl/Makefile.sources
+++ b/src/glsl/Makefile.sources
@@ -33,6 +33,7 @@ LIBGLSL_FILES = \
 	$(GLSL_SRCDIR)/ir_clone.cpp \
 	$(GLSL_SRCDIR)/ir_constant_expression.cpp \
 	$(GLSL_SRCDIR)/ir.cpp \
+	$(GLSL_SRCDIR)/ir_equals.cpp \
 	$(GLSL_SRCDIR)/ir_expression_flattening.cpp \
 	$(GLSL_SRCDIR)/ir_function_can_inline.cpp \
 	$(GLSL_SRCDIR)/ir_function_detect_recursion.cpp \
@@ -47,6 +48,7 @@ LIBGLSL_FILES = \
 	$(GLSL_SRCDIR)/ir_validate.cpp \
 	$(GLSL_SRCDIR)/ir_variable_refcount.cpp \
 	$(GLSL_SRCDIR)/linker.cpp \
+	$(GLSL_SRCDIR)/link_atomics.cpp \
 	$(GLSL_SRCDIR)/link_functions.cpp \
 	$(GLSL_SRCDIR)/link_interface_blocks.cpp \
 	$(GLSL_SRCDIR)/link_uniforms.cpp \
diff --git a/src/glsl/ast.h b/src/glsl/ast.h
index 97905c6..5c214b6 100644
--- a/src/glsl/ast.h
+++ b/src/glsl/ast.h
@@ -385,6 +385,12 @@ struct ast_type_qualifier {
           */
          unsigned explicit_binding:1;
 
+         /**
+          * Flag set if GL_ARB_shader_atomic counter "offset" layout
+          * qualifier is used.
+          */
+         unsigned explicit_offset:1;
+
          /** \name Layout qualifiers for GL_AMD_conservative_depth */
          /** \{ */
          unsigned depth_any:1;
@@ -448,6 +454,15 @@ struct ast_type_qualifier {
    int binding;
 
    /**
+    * Offset specified via GL_ARB_shader_atomic_counter's "offset"
+    * keyword.
+    *
+    * \note
+    * This field is only valid if \c explicit_offset is set.
+    */
+   int offset;
+
+   /**
     * Return true if and only if an interpolation qualifier is present.
     */
    bool has_interpolation() const;
diff --git a/src/glsl/ast_to_hir.cpp b/src/glsl/ast_to_hir.cpp
index f75e68c..76b256c 100644
--- a/src/glsl/ast_to_hir.cpp
+++ b/src/glsl/ast_to_hir.cpp
@@ -1997,10 +1997,20 @@ validate_binding_qualifier(struct _mesa_glsl_parse_state *state,
 
          return false;
       }
+   } else if (var->type->contains_atomic()) {
+      assert(ctx->Const.MaxAtomicBufferBindings <= MAX_COMBINED_ATOMIC_BUFFERS);
+      if (unsigned(qual->binding) >= ctx->Const.MaxAtomicBufferBindings) {
+         _mesa_glsl_error(loc, state, "layout(binding = %d) exceeds the "
+                          " maximum number of atomic counter buffer bindings"
+                          "(%d)", qual->binding,
+                          ctx->Const.MaxAtomicBufferBindings);
+
+         return false;
+      }
    } else {
       _mesa_glsl_error(loc, state,
                        "the \"binding\" qualifier only applies to uniform "
-                       "blocks, samplers, or arrays of samplers");
+                       "blocks, samplers, atomic counters, or arrays thereof");
       return false;
    }
 
@@ -2300,6 +2310,29 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
       var->binding = qual->binding;
    }
 
+   if (var->type->contains_atomic()) {
+      if (var->mode == ir_var_uniform) {
+         if (var->explicit_binding) {
+            unsigned *offset = &state->atomic_counter_offsets[var->binding];
+
+            if (*offset % ATOMIC_COUNTER_SIZE)
+               _mesa_glsl_error(loc, state,
+                                "misaligned atomic counter offset");
+
+            var->atomic.offset = *offset;
+            *offset += var->type->atomic_size();
+
+         } else {
+            _mesa_glsl_error(loc, state,
+                             "atomic counters require explicit binding point");
+         }
+      } else if (var->mode != ir_var_function_in) {
+         _mesa_glsl_error(loc, state, "atomic counters may only be declared as "
+                          "function parameters or uniform-qualified "
+                          "global variables");
+      }
+   }
+
    /* Does the declaration use the deprecated 'attribute' or 'varying'
     * keywords?
     */
@@ -2835,6 +2868,18 @@ ast_declarator_list::hir(exec_list *instructions,
    (void) this->type->specifier->hir(instructions, state);
 
    decl_type = this->type->glsl_type(& type_name, state);
+
+   /* An offset-qualified atomic counter declaration sets the default
+    * offset for the next declaration within the same atomic counter
+    * buffer.
+    */
+   if (decl_type && decl_type->contains_atomic()) {
+      if (type->qualifier.flags.q.explicit_binding &&
+          type->qualifier.flags.q.explicit_offset)
+         state->atomic_counter_offsets[type->qualifier.binding] =
+            type->qualifier.offset;
+   }
+
    if (this->declarations.is_empty()) {
       /* If there is no structure involved in the program text, there are two
        * possible scenarios:
@@ -2864,6 +2909,11 @@ ast_declarator_list::hir(exec_list *instructions,
          _mesa_glsl_error(&loc, state,
                           "invalid type `%s' in empty declaration",
                           type_name);
+      } else if (decl_type->base_type == GLSL_TYPE_ATOMIC_UINT) {
+         /* Empty atomic counter declarations are allowed and useful
+          * to set the default offset qualifier.
+          */
+         return NULL;
       } else if (this->type->qualifier.precision != ast_precision_none) {
          if (this->type->specifier->structure != NULL) {
             _mesa_glsl_error(&loc, state,
@@ -4565,6 +4615,17 @@ ast_process_structure_or_interface_block(exec_list *instructions,
                              "uniform in non-default uniform block contains sampler");
          }
 
+         if (field_type->contains_atomic()) {
+            /* FINISHME: Add a spec quotation here once updated spec
+             * FINISHME: language is available.  See Khronos bug #10903
+             * FINISHME: on whether atomic counters are allowed in
+             * FINISHME: structures.
+             */
+            YYLTYPE loc = decl_list->get_location();
+            _mesa_glsl_error(&loc, state, "atomic counter in structure or "
+                             "uniform block");
+         }
+
          const struct ast_type_qualifier *const qual =
             & decl_list->type->qualifier;
          if (qual->flags.q.std140 ||
diff --git a/src/glsl/ast_type.cpp b/src/glsl/ast_type.cpp
index 8aabd95..2b088bf 100644
--- a/src/glsl/ast_type.cpp
+++ b/src/glsl/ast_type.cpp
@@ -72,7 +72,8 @@ ast_type_qualifier::has_layout() const
           || this->flags.q.packed
           || this->flags.q.explicit_location
           || this->flags.q.explicit_index
-          || this->flags.q.explicit_binding;
+          || this->flags.q.explicit_binding
+          || this->flags.q.explicit_offset;
 }
 
 bool
@@ -121,13 +122,18 @@ ast_type_qualifier::merge_qualifier(YYLTYPE *loc,
    ubo_layout_mask.flags.q.packed = 1;
    ubo_layout_mask.flags.q.shared = 1;
 
+   ast_type_qualifier ubo_binding_mask;
+   ubo_binding_mask.flags.q.explicit_binding = 1;
+   ubo_binding_mask.flags.q.explicit_offset = 1;
+
    /* Uniform block layout qualifiers get to overwrite each
     * other (rightmost having priority), while all other
     * qualifiers currently don't allow duplicates.
     */
 
    if ((this->flags.i & q.flags.i & ~(ubo_mat_mask.flags.i |
-				      ubo_layout_mask.flags.i)) != 0) {
+				      ubo_layout_mask.flags.i |
+                                      ubo_binding_mask.flags.i)) != 0) {
       _mesa_glsl_error(loc, state,
 		       "duplicate layout qualifiers used");
       return false;
@@ -168,6 +174,9 @@ ast_type_qualifier::merge_qualifier(YYLTYPE *loc,
    if (q.flags.q.explicit_binding)
       this->binding = q.binding;
 
+   if (q.flags.q.explicit_offset)
+      this->offset = q.offset;
+
    if (q.precision != ast_precision_none)
       this->precision = q.precision;
 
diff --git a/src/glsl/builtin_functions.cpp b/src/glsl/builtin_functions.cpp
index 3fa0cb5..8cb75e5 100644
--- a/src/glsl/builtin_functions.cpp
+++ b/src/glsl/builtin_functions.cpp
@@ -293,7 +293,8 @@ static bool
 fs_oes_derivatives(const _mesa_glsl_parse_state *state)
 {
    return state->target == fragment_shader &&
-          (!state->es_shader || state->OES_standard_derivatives_enable);
+          (state->is_version(110, 300) ||
+           state->OES_standard_derivatives_enable);
 }
 
 static bool
diff --git a/src/glsl/glsl_lexer.ll b/src/glsl/glsl_lexer.ll
index e24df80..822d70d 100644
--- a/src/glsl/glsl_lexer.ll
+++ b/src/glsl/glsl_lexer.ll
@@ -337,6 +337,7 @@ samplerExternalOES		{
 			     return IDENTIFIER;
 		}
 
+atomic_uint     KEYWORD_WITH_ALT(420, 300, 420, 0, yyextra->ARB_shader_atomic_counters_enable, ATOMIC_UINT);
 
 struct		return STRUCT;
 void		return VOID_TOK;
@@ -518,7 +519,6 @@ restrict	KEYWORD(0, 300, 0, 0, RESTRICT);
 readonly	KEYWORD(0, 300, 0, 0, READONLY);
 writeonly	KEYWORD(0, 300, 0, 0, WRITEONLY);
 resource	KEYWORD(0, 300, 0, 0, RESOURCE);
-atomic_uint	KEYWORD(0, 300, 0, 0, ATOMIC_UINT);
 patch		KEYWORD(0, 300, 0, 0, PATCH);
 sample		KEYWORD(0, 300, 0, 0, SAMPLE);
 subroutine	KEYWORD(0, 300, 0, 0, SUBROUTINE);
diff --git a/src/glsl/glsl_parser.yy b/src/glsl/glsl_parser.yy
index 14420f8..ada3690 100644
--- a/src/glsl/glsl_parser.yy
+++ b/src/glsl/glsl_parser.yy
@@ -144,6 +144,7 @@ static bool match_layout_qualifier(const char *s1, const char *s2,
 %token SAMPLER2DMS ISAMPLER2DMS USAMPLER2DMS
 %token SAMPLER2DMSARRAY ISAMPLER2DMSARRAY USAMPLER2DMSARRAY
 %token SAMPLEREXTERNALOES
+%token ATOMIC_UINT
 %token STRUCT VOID_TOK WHILE
 %token <identifier> IDENTIFIER TYPE_IDENTIFIER NEW_IDENTIFIER
 %type <identifier> any_identifier
@@ -173,7 +174,7 @@ static bool match_layout_qualifier(const char *s1, const char *s2,
 %token HVEC2 HVEC3 HVEC4 DVEC2 DVEC3 DVEC4 FVEC2 FVEC3 FVEC4
 %token SAMPLER3DRECT
 %token SIZEOF CAST NAMESPACE USING
-%token COHERENT RESTRICT READONLY WRITEONLY RESOURCE ATOMIC_UINT PATCH SAMPLE
+%token COHERENT RESTRICT READONLY WRITEONLY RESOURCE PATCH SAMPLE
 %token SUBROUTINE
 
 %token ERROR_TOK
@@ -1324,12 +1325,19 @@ layout_qualifier_id:
          }
       }
 
-      if (state->ARB_shading_language_420pack_enable &&
+      if ((state->ARB_shading_language_420pack_enable ||
+           state->ARB_shader_atomic_counters_enable) &&
           match_layout_qualifier("binding", $1, state) == 0) {
          $$.flags.q.explicit_binding = 1;
          $$.binding = $3;
       }
 
+      if (state->ARB_shader_atomic_counters_enable &&
+          match_layout_qualifier("offset", $1, state) == 0) {
+         $$.flags.q.explicit_offset = 1;
+         $$.offset = $3;
+      }
+
       if (match_layout_qualifier("max_vertices", $1, state) == 0) {
          $$.flags.q.max_vertices = 1;
 
@@ -1703,6 +1711,7 @@ basic_type_specifier_nonarray:
    | SAMPLER2DMSARRAY       { $$ = "sampler2DMSArray"; }
    | ISAMPLER2DMSARRAY      { $$ = "isampler2DMSArray"; }
    | USAMPLER2DMSARRAY      { $$ = "usampler2DMSArray"; }
+   | ATOMIC_UINT            { $$ = "atomic_uint"; }
    ;
 
 precision_qualifier:
diff --git a/src/glsl/glsl_parser_extras.h b/src/glsl/glsl_parser_extras.h
index 345d7a0..d232bb3 100644
--- a/src/glsl/glsl_parser_extras.h
+++ b/src/glsl/glsl_parser_extras.h
@@ -373,6 +373,9 @@ struct _mesa_glsl_parse_state {
     * Unused for other shader types.
     */
    unsigned gs_input_size;
+
+   /** Atomic counter offsets by binding */
+   unsigned atomic_counter_offsets[MAX_COMBINED_ATOMIC_BUFFERS];
 };
 
 # define YYLLOC_DEFAULT(Current, Rhs, N)			\
diff --git a/src/glsl/ir.h b/src/glsl/ir.h
index 2f06fb9..7859702 100644
--- a/src/glsl/ir.h
+++ b/src/glsl/ir.h
@@ -139,6 +139,16 @@ public:
    virtual class ir_jump *              as_jump()             { return NULL; }
    /*@}*/
 
+   /**
+    * IR equality method: Return true if the referenced instruction would
+    * return the same value as this one.
+    *
+    * This intended to be used for CSE and algebraic optimizations, on rvalues
+    * in particular.  No support for other instruction types (assignments,
+    * jumps, calls, etc.) is planned.
+    */
+   virtual bool equals(ir_instruction *ir);
+
 protected:
    ir_instruction()
    {
@@ -1405,6 +1415,8 @@ public:
       return this;
    }
 
+   virtual bool equals(ir_instruction *ir);
+
    virtual ir_expression *clone(void *mem_ctx, struct hash_table *ht) const;
 
    /**
@@ -1739,6 +1751,8 @@ public:
 
    virtual ir_visitor_status accept(ir_hierarchical_visitor *);
 
+   virtual bool equals(ir_instruction *ir);
+
    /**
     * Return a string representing the ir_texture_opcode.
     */
@@ -1843,6 +1857,8 @@ public:
 
    virtual ir_visitor_status accept(ir_hierarchical_visitor *);
 
+   virtual bool equals(ir_instruction *ir);
+
    bool is_lvalue() const
    {
       return val->is_lvalue() && !mask.has_duplicates;
@@ -1907,6 +1923,8 @@ public:
       return this;
    }
 
+   virtual bool equals(ir_instruction *ir);
+
    /**
     * Get the variable that is ultimately referenced by an r-value
     */
@@ -1965,6 +1983,8 @@ public:
       return this;
    }
 
+   virtual bool equals(ir_instruction *ir);
+
    /**
     * Get the variable that is ultimately referenced by an r-value
     */
@@ -2099,6 +2119,8 @@ public:
 
    virtual ir_visitor_status accept(ir_hierarchical_visitor *);
 
+   virtual bool equals(ir_instruction *ir);
+
    /**
     * Get a particular component of a constant as a specific type
     *
diff --git a/src/glsl/ir_equals.cpp b/src/glsl/ir_equals.cpp
new file mode 100644
index 0000000..7cfe1e6
--- /dev/null
+++ b/src/glsl/ir_equals.cpp
@@ -0,0 +1,198 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "ir.h"
+
+/**
+ * Helper for checking equality when one instruction might be NULL, since you
+ * can't access a's vtable in that case.
+ */
+static bool
+possibly_null_equals(ir_instruction *a, ir_instruction *b)
+{
+   if (!a || !b)
+      return !a && !b;
+
+   return a->equals(b);
+}
+
+/**
+ * The base equality function: Return not equal for anything we don't know
+ * about.
+ */
+bool
+ir_instruction::equals(ir_instruction *ir)
+{
+   return false;
+}
+
+bool
+ir_constant::equals(ir_instruction *ir)
+{
+   const ir_constant *other = ir->as_constant();
+   if (!other)
+      return false;
+
+   if (type != other->type)
+      return false;
+
+   for (unsigned i = 0; i < type->components(); i++) {
+      if (value.u[i] != other->value.u[i])
+         return false;
+   }
+
+   return true;
+}
+
+bool
+ir_dereference_variable::equals(ir_instruction *ir)
+{
+   const ir_dereference_variable *other = ir->as_dereference_variable();
+   if (!other)
+      return false;
+
+   return var == other->var;
+}
+
+bool
+ir_dereference_array::equals(ir_instruction *ir)
+{
+   const ir_dereference_array *other = ir->as_dereference_array();
+   if (!other)
+      return false;
+
+   if (type != other->type)
+      return false;
+
+   if (!array->equals(other->array))
+      return false;
+
+   if (!array_index->equals(other->array_index))
+      return false;
+
+   return true;
+}
+
+bool
+ir_swizzle::equals(ir_instruction *ir)
+{
+   const ir_swizzle *other = ir->as_swizzle();
+   if (!other)
+      return false;
+
+   if (type != other->type)
+      return false;
+
+   if (mask.x != other->mask.x ||
+       mask.y != other->mask.y ||
+       mask.z != other->mask.z ||
+       mask.w != other->mask.w) {
+      return false;
+   }
+
+   return val->equals(other->val);
+}
+
+bool
+ir_texture::equals(ir_instruction *ir)
+{
+   const ir_texture *other = ir->as_texture();
+   if (!other)
+      return false;
+
+   if (type != other->type)
+      return false;
+
+   if (op != other->op)
+      return false;
+
+   if (!possibly_null_equals(coordinate, other->coordinate))
+      return false;
+
+   if (!possibly_null_equals(projector, other->projector))
+      return false;
+
+   if (!possibly_null_equals(shadow_comparitor, other->shadow_comparitor))
+      return false;
+
+   if (!possibly_null_equals(offset, other->offset))
+      return false;
+
+   if (!sampler->equals(other->sampler))
+      return false;
+
+   switch (op) {
+   case ir_tex:
+   case ir_lod:
+   case ir_query_levels:
+      break;
+   case ir_txb:
+      if (!lod_info.bias->equals(other->lod_info.bias))
+         return false;
+      break;
+   case ir_txl:
+   case ir_txf:
+   case ir_txs:
+      if (!lod_info.lod->equals(other->lod_info.lod))
+         return false;
+      break;
+   case ir_txd:
+      if (!lod_info.grad.dPdx->equals(other->lod_info.grad.dPdx) ||
+          !lod_info.grad.dPdy->equals(other->lod_info.grad.dPdy))
+         return false;
+      break;
+   case ir_txf_ms:
+      if (!lod_info.sample_index->equals(other->lod_info.sample_index))
+         return false;
+      break;
+   case ir_tg4:
+      if (!lod_info.component->equals(other->lod_info.component))
+         return false;
+      break;
+   default:
+      assert(!"Unrecognized texture op");
+   }
+
+   return true;
+}
+
+bool
+ir_expression::equals(ir_instruction *ir)
+{
+   const ir_expression *other = ir->as_expression();
+   if (!other)
+      return false;
+
+   if (type != other->type)
+      return false;
+
+   if (operation != other->operation)
+      return false;
+
+   for (unsigned i = 0; i < get_num_operands(); i++) {
+      if (!operands[i]->equals(other->operands[i]))
+         return false;
+   }
+
+   return true;
+}
diff --git a/src/glsl/link_atomics.cpp b/src/glsl/link_atomics.cpp
new file mode 100644
index 0000000..2466bbd
--- /dev/null
+++ b/src/glsl/link_atomics.cpp
@@ -0,0 +1,277 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "ir.h"
+#include "ir_uniform.h"
+#include "linker.h"
+#include "program/hash_table.h"
+#include "main/macros.h"
+
+namespace {
+   /*
+    * Atomic counter as seen by the program.
+    */
+   struct active_atomic_counter {
+      unsigned id;
+      ir_variable *var;
+   };
+
+   /*
+    * Atomic counter buffer referenced by the program.  There is a one
+    * to one correspondence between these and the objects that can be
+    * queried using glGetActiveAtomicCounterBufferiv().
+    */
+   struct active_atomic_buffer {
+      active_atomic_buffer()
+         : counters(0), num_counters(0), stage_references(), size(0)
+      {}
+
+      ~active_atomic_buffer()
+      {
+         free(counters);
+      }
+
+      void push_back(unsigned id, ir_variable *var)
+      {
+         counters = (active_atomic_counter *)
+            realloc(counters, sizeof(active_atomic_counter) * (num_counters + 1));
+
+         counters[num_counters].id = id;
+         counters[num_counters].var = var;
+         num_counters++;
+      }
+
+      active_atomic_counter *counters;
+      unsigned num_counters;
+      unsigned stage_references[MESA_SHADER_TYPES];
+      unsigned size;
+   };
+
+   int
+   cmp_actives(const void *a, const void *b)
+   {
+      const active_atomic_counter *const first = (active_atomic_counter *) a;
+      const active_atomic_counter *const second = (active_atomic_counter *) b;
+
+      return int(first->var->atomic.offset) - int(second->var->atomic.offset);
+   }
+
+   bool
+   check_atomic_counters_overlap(const ir_variable *x, const ir_variable *y)
+   {
+      return ((x->atomic.offset >= y->atomic.offset &&
+               x->atomic.offset < y->atomic.offset + y->type->atomic_size()) ||
+              (y->atomic.offset >= x->atomic.offset &&
+               y->atomic.offset < x->atomic.offset + x->type->atomic_size()));
+   }
+
+   active_atomic_buffer *
+   find_active_atomic_counters(struct gl_context *ctx,
+                               struct gl_shader_program *prog,
+                               unsigned *num_buffers)
+   {
+      active_atomic_buffer *const buffers =
+         new active_atomic_buffer[ctx->Const.MaxAtomicBufferBindings];
+
+      *num_buffers = 0;
+
+      for (unsigned i = 0; i < MESA_SHADER_TYPES; ++i) {
+         struct gl_shader *sh = prog->_LinkedShaders[i];
+         if (sh == NULL)
+            continue;
+
+         foreach_list(node, sh->ir) {
+            ir_variable *var = ((ir_instruction *)node)->as_variable();
+
+            if (var && var->type->contains_atomic()) {
+               unsigned id;
+               bool found = prog->UniformHash->get(id, var->name);
+               assert(found);
+               active_atomic_buffer *buf = &buffers[var->binding];
+
+               /* If this is the first time the buffer is used, increment
+                * the counter of buffers used.
+                */
+               if (buf->size == 0)
+                  (*num_buffers)++;
+
+               buf->push_back(id, var);
+
+               buf->stage_references[i]++;
+               buf->size = MAX2(buf->size, var->atomic.offset +
+                                var->type->atomic_size());
+            }
+         }
+      }
+
+      for (unsigned i = 0; i < ctx->Const.MaxAtomicBufferBindings; i++) {
+         if (buffers[i].size == 0)
+            continue;
+
+         qsort(buffers[i].counters, buffers[i].num_counters,
+               sizeof(active_atomic_counter),
+               cmp_actives);
+
+         for (unsigned j = 1; j < buffers[i].num_counters; j++) {
+            /* If an overlapping counter found, it must be a reference to the
+             * same counter from a different shader stage.
+             */
+            if (check_atomic_counters_overlap(buffers[i].counters[j-1].var,
+                                              buffers[i].counters[j].var)
+                && strcmp(buffers[i].counters[j-1].var->name,
+                          buffers[i].counters[j].var->name) != 0) {
+               linker_error(prog, "Atomic counter %s declared at offset %d "
+                            "which is already in use.",
+                            buffers[i].counters[j].var->name,
+                            buffers[i].counters[j].var->atomic.offset);
+            }
+         }
+      }
+      return buffers;
+   }
+}
+
+void
+link_assign_atomic_counter_resources(struct gl_context *ctx,
+                                     struct gl_shader_program *prog)
+{
+   unsigned num_buffers;
+   active_atomic_buffer *abs =
+      find_active_atomic_counters(ctx, prog, &num_buffers);
+
+   prog->AtomicBuffers = rzalloc_array(prog, gl_active_atomic_buffer,
+                                       num_buffers);
+   prog->NumAtomicBuffers = num_buffers;
+
+   unsigned i = 0;
+   for (unsigned binding = 0;
+        binding < ctx->Const.MaxAtomicBufferBindings;
+        binding++) {
+
+      /* If the binding was not used, skip.
+       */
+      if (abs[binding].size == 0)
+         continue;
+
+      active_atomic_buffer &ab = abs[binding];
+      gl_active_atomic_buffer &mab = prog->AtomicBuffers[i];
+
+      /* Assign buffer-specific fields. */
+      mab.Binding = binding;
+      mab.MinimumSize = ab.size;
+      mab.Uniforms = rzalloc_array(prog->AtomicBuffers, GLuint,
+                                   ab.num_counters);
+      mab.NumUniforms = ab.num_counters;
+
+      /* Assign counter-specific fields. */
+      for (unsigned j = 0; j < ab.num_counters; j++) {
+         ir_variable *const var = ab.counters[j].var;
+         const unsigned id = ab.counters[j].id;
+         gl_uniform_storage *const storage = &prog->UniformStorage[id];
+
+         mab.Uniforms[j] = id;
+         var->atomic.buffer_index = i;
+         storage->atomic_buffer_index = i;
+         storage->offset = var->atomic.offset;
+         storage->array_stride = (var->type->is_array() ?
+                                  var->type->element_type()->atomic_size() : 0);
+      }
+
+      /* Assign stage-specific fields. */
+      for (unsigned j = 0; j < MESA_SHADER_TYPES; ++j)
+         mab.StageReferences[j] =
+            (ab.stage_references[j] ? GL_TRUE : GL_FALSE);
+
+      i++;
+   }
+
+   delete [] abs;
+   assert(i == num_buffers);
+}
+
+void
+link_check_atomic_counter_resources(struct gl_context *ctx,
+                                    struct gl_shader_program *prog)
+{
+   STATIC_ASSERT(MESA_SHADER_TYPES == 3);
+   static const char *shader_names[MESA_SHADER_TYPES] = {
+      "vertex", "geometry", "fragment"
+   };
+   const unsigned max_atomic_counters[MESA_SHADER_TYPES] = {
+      ctx->Const.VertexProgram.MaxAtomicCounters,
+      ctx->Const.GeometryProgram.MaxAtomicCounters,
+      ctx->Const.FragmentProgram.MaxAtomicCounters
+   };
+   const unsigned max_atomic_buffers[MESA_SHADER_TYPES] = {
+      ctx->Const.VertexProgram.MaxAtomicBuffers,
+      ctx->Const.GeometryProgram.MaxAtomicBuffers,
+      ctx->Const.FragmentProgram.MaxAtomicBuffers
+   };
+   unsigned num_buffers;
+   active_atomic_buffer *const abs =
+      find_active_atomic_counters(ctx, prog, &num_buffers);
+   unsigned atomic_counters[MESA_SHADER_TYPES] = {};
+   unsigned atomic_buffers[MESA_SHADER_TYPES] = {};
+   unsigned total_atomic_counters = 0;
+   unsigned total_atomic_buffers = 0;
+
+   /* Sum the required resources.  Note that this counts buffers and
+    * counters referenced by several shader stages multiple times
+    * against the combined limit -- That's the behavior the spec
+    * requires.
+    */
+   for (unsigned i = 0; i < ctx->Const.MaxAtomicBufferBindings; i++) {
+      if (abs[i].size == 0)
+         continue;
+
+      for (unsigned j = 0; j < MESA_SHADER_TYPES; ++j) {
+         const unsigned n = abs[i].stage_references[j];
+
+         if (n) {
+            atomic_counters[j] += n;
+            total_atomic_counters += n;
+            atomic_buffers[j]++;
+            total_atomic_buffers++;
+         }
+      }
+   }
+
+   /* Check that they are within the supported limits. */
+   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++) {
+      if (atomic_counters[i] > max_atomic_counters[i])
+         linker_error(prog, "Too many %s shader atomic counters",
+                      shader_names[i]);
+
+      if (atomic_buffers[i] > max_atomic_buffers[i])
+         linker_error(prog, "Too many %s shader atomic counter buffers",
+                      shader_names[i]);
+   }
+
+   if (total_atomic_counters > ctx->Const.MaxCombinedAtomicCounters)
+      linker_error(prog, "Too many combined atomic counters");
+
+   if (total_atomic_buffers > ctx->Const.MaxCombinedAtomicBuffers)
+      linker_error(prog, "Too many combined atomic buffers");
+
+   delete [] abs;
+}
diff --git a/src/glsl/link_interface_blocks.cpp b/src/glsl/link_interface_blocks.cpp
index 4f1c9d3..a7fceb9 100644
--- a/src/glsl/link_interface_blocks.cpp
+++ b/src/glsl/link_interface_blocks.cpp
@@ -30,13 +30,211 @@
 #include "glsl_symbol_table.h"
 #include "linker.h"
 #include "main/macros.h"
+#include "program/hash_table.h"
+
+
+namespace {
+
+/**
+ * Information about a single interface block definition that we need to keep
+ * track of in order to check linkage rules.
+ *
+ * Note: this class is expected to be short lived, so it doesn't make copies
+ * of the strings it references; it simply borrows the pointers from the
+ * ir_variable class.
+ */
+struct interface_block_definition
+{
+   /**
+    * Extract an interface block definition from an ir_variable that
+    * represents either the interface instance (for named interfaces), or a
+    * member of the interface (for unnamed interfaces).
+    */
+   explicit interface_block_definition(const ir_variable *var)
+      : type(var->get_interface_type()),
+        instance_name(NULL),
+        array_size(-1)
+   {
+      if (var->is_interface_instance()) {
+         instance_name = var->name;
+         if (var->type->is_array())
+            array_size = var->type->length;
+      }
+   }
+
+   /**
+    * Interface block type
+    */
+   const glsl_type *type;
+
+   /**
+    * For a named interface block, the instance name.  Otherwise NULL.
+    */
+   const char *instance_name;
+
+   /**
+    * For an interface block array, the array size (or 0 if unsized).
+    * Otherwise -1.
+    */
+   int array_size;
+};
+
+
+/**
+ * Check if two interfaces match, according to intrastage interface matching
+ * rules.  If they do, and the first interface uses an unsized array, it will
+ * be updated to reflect the array size declared in the second interface.
+ */
+bool
+intrastage_match(interface_block_definition *a,
+                 const interface_block_definition *b,
+                 ir_variable_mode mode)
+{
+   /* Types must match. */
+   if (a->type != b->type)
+      return false;
+
+   /* Presence/absence of interface names must match. */
+   if ((a->instance_name == NULL) != (b->instance_name == NULL))
+      return false;
+
+   /* For uniforms, instance names need not match.  For shader ins/outs,
+    * it's not clear from the spec whether they need to match, but
+    * Mesa's implementation relies on them matching.
+    */
+   if (a->instance_name != NULL && mode != ir_var_uniform &&
+       strcmp(a->instance_name, b->instance_name) != 0) {
+      return false;
+   }
+
+   /* Array vs. nonarray must be consistent, and sizes must be
+    * consistent, with the exception that unsized arrays match sized
+    * arrays.
+    */
+   if ((a->array_size == -1) != (b->array_size == -1))
+      return false;
+   if (b->array_size != 0) {
+      if (a->array_size == 0)
+         a->array_size = b->array_size;
+      else if (a->array_size != b->array_size)
+         return false;
+   }
+
+   return true;
+}
+
+
+/**
+ * Check if two interfaces match, according to interstage (in/out) interface
+ * matching rules.
+ *
+ * If \c extra_array_level is true, then vertex-to-geometry shader matching
+ * rules are enforced (i.e. a successful match requires the consumer interface
+ * to be an array and the producer interface to be a non-array).
+ */
+bool
+interstage_match(const interface_block_definition *producer,
+                 const interface_block_definition *consumer,
+                 bool extra_array_level)
+{
+   /* Unsized arrays should not occur during interstage linking.  They
+    * should have all been assigned a size by link_intrastage_shaders.
+    */
+   assert(consumer->array_size != 0);
+   assert(producer->array_size != 0);
+
+   /* Types must match. */
+   if (consumer->type != producer->type)
+      return false;
+   if (extra_array_level) {
+      /* Consumer must be an array, and producer must not. */
+      if (consumer->array_size == -1)
+         return false;
+      if (producer->array_size != -1)
+         return false;
+   } else {
+      /* Array vs. nonarray must be consistent, and sizes must be consistent.
+       * Since unsized arrays have been ruled out, we can check this by just
+       * making sure the sizes are equal.
+       */
+      if (consumer->array_size != producer->array_size)
+         return false;
+   }
+   return true;
+}
+
+
+/**
+ * This class keeps track of a mapping from an interface block name to the
+ * necessary information about that interface block to determine whether to
+ * generate a link error.
+ *
+ * Note: this class is expected to be short lived, so it doesn't make copies
+ * of the strings it references; it simply borrows the pointers from the
+ * ir_variable class.
+ */
+class interface_block_definitions
+{
+public:
+   interface_block_definitions()
+      : mem_ctx(ralloc_context(NULL)),
+        ht(hash_table_ctor(0, hash_table_string_hash,
+                           hash_table_string_compare))
+   {
+   }
+
+   ~interface_block_definitions()
+   {
+      hash_table_dtor(ht);
+      ralloc_free(mem_ctx);
+   }
+
+   /**
+    * Lookup the interface definition having the given block name.  Return
+    * NULL if none is found.
+    */
+   interface_block_definition *lookup(const char *block_name)
+   {
+      return (interface_block_definition *) hash_table_find(ht, block_name);
+   }
+
+   /**
+    * Add a new interface definition.
+    */
+   void store(const interface_block_definition &def)
+   {
+      interface_block_definition *hash_entry =
+         rzalloc(mem_ctx, interface_block_definition);
+      *hash_entry = def;
+      hash_table_insert(ht, hash_entry, def.type->name);
+   }
+
+private:
+   /**
+    * Ralloc context for data structures allocated by this class.
+    */
+   void *mem_ctx;
+
+   /**
+    * Hash table mapping interface block name to an \c
+    * interface_block_definition struct.  interface_block_definition structs
+    * are allocated using \c mem_ctx.
+    */
+   hash_table *ht;
+};
+
+
+}; /* anonymous namespace */
+
 
 void
 validate_intrastage_interface_blocks(struct gl_shader_program *prog,
                                      const gl_shader **shader_list,
                                      unsigned num_shaders)
 {
-   glsl_symbol_table interfaces;
+   interface_block_definitions in_interfaces;
+   interface_block_definitions out_interfaces;
+   interface_block_definitions uniform_interfaces;
 
    for (unsigned int i = 0; i < num_shaders; i++) {
       if (shader_list[i] == NULL)
@@ -52,17 +250,36 @@ validate_intrastage_interface_blocks(struct gl_shader_program *prog,
          if (iface_type == NULL)
             continue;
 
-         const glsl_type *old_iface_type =
-            interfaces.get_interface(iface_type->name,
-                                     (enum ir_variable_mode) var->mode);
+         interface_block_definitions *definitions;
+         switch (var->mode) {
+         case ir_var_shader_in:
+            definitions = &in_interfaces;
+            break;
+         case ir_var_shader_out:
+            definitions = &out_interfaces;
+            break;
+         case ir_var_uniform:
+            definitions = &uniform_interfaces;
+            break;
+         default:
+            /* Only in, out, and uniform interfaces are legal, so we should
+             * never get here.
+             */
+            assert(!"illegal interface type");
+            continue;
+         }
 
-         if (old_iface_type == NULL) {
+         const interface_block_definition def(var);
+         interface_block_definition *prev_def =
+            definitions->lookup(iface_type->name);
+
+         if (prev_def == NULL) {
             /* This is the first time we've seen the interface, so save
-             * it into our symbol table.
+             * it into the appropriate data structure.
              */
-            interfaces.add_interface(iface_type->name, iface_type,
-                                     (enum ir_variable_mode) var->mode);
-         } else if (old_iface_type != iface_type) {
+            definitions->store(def);
+         } else if (!intrastage_match(prev_def, &def,
+                                      (ir_variable_mode) var->mode)) {
             linker_error(prog, "definitions of interface block `%s' do not"
                          " match\n", iface_type->name);
             return;
@@ -76,7 +293,9 @@ validate_interstage_interface_blocks(struct gl_shader_program *prog,
                                      const gl_shader *producer,
                                      const gl_shader *consumer)
 {
-   glsl_symbol_table interfaces;
+   interface_block_definitions inout_interfaces;
+   interface_block_definitions uniform_interfaces;
+   const bool extra_array_level = consumer->Type == GL_GEOMETRY_SHADER;
 
    /* Add non-output interfaces from the consumer to the symbol table. */
    foreach_list(node, consumer->ir) {
@@ -84,9 +303,9 @@ validate_interstage_interface_blocks(struct gl_shader_program *prog,
       if (!var || !var->get_interface_type() || var->mode == ir_var_shader_out)
          continue;
 
-      interfaces.add_interface(var->get_interface_type()->name,
-                               var->get_interface_type(),
-                               (enum ir_variable_mode) var->mode);
+      interface_block_definitions *definitions = var->mode == ir_var_uniform ?
+         &uniform_interfaces : &inout_interfaces;
+      definitions->store(interface_block_definition(var));
    }
 
    /* Verify that the producer's interfaces match. */
@@ -95,17 +314,29 @@ validate_interstage_interface_blocks(struct gl_shader_program *prog,
       if (!var || !var->get_interface_type() || var->mode == ir_var_shader_in)
          continue;
 
-      enum ir_variable_mode consumer_mode =
-         var->mode == ir_var_uniform ? ir_var_uniform : ir_var_shader_in;
-      const glsl_type *expected_type =
-         interfaces.get_interface(var->get_interface_type()->name,
-                                  consumer_mode);
+      interface_block_definitions *definitions = var->mode == ir_var_uniform ?
+         &uniform_interfaces : &inout_interfaces;
+      interface_block_definition *consumer_def =
+         definitions->lookup(var->get_interface_type()->name);
 
       /* The consumer doesn't use this output block.  Ignore it. */
-      if (expected_type == NULL)
+      if (consumer_def == NULL)
          continue;
 
-      if (var->get_interface_type() != expected_type) {
+      const interface_block_definition producer_def(var);
+      bool match;
+      if (var->mode == ir_var_uniform) {
+         /* Uniform matching rules are the same for interstage and intrastage
+          * linking.
+          */
+         match = intrastage_match(consumer_def, &producer_def,
+                                  (ir_variable_mode) var->mode);
+      } else {
+         match = interstage_match(&producer_def, consumer_def,
+                                  extra_array_level);
+      }
+
+      if (!match) {
          linker_error(prog, "definitions of interface block `%s' do not "
                       "match\n", var->get_interface_type()->name);
          return;
diff --git a/src/glsl/linker.cpp b/src/glsl/linker.cpp
index 49bb142..1d53b65 100644
--- a/src/glsl/linker.cpp
+++ b/src/glsl/linker.cpp
@@ -651,6 +651,14 @@ cross_validate_globals(struct gl_shader_program *prog,
                existing->explicit_binding = true;
             }
 
+            if (var->type->contains_atomic() &&
+                var->atomic.offset != existing->atomic.offset) {
+               linker_error(prog, "offset specifications for %s "
+                            "`%s' have differing values\n",
+                            mode_string(var), var->name);
+               return;
+            }
+
 	    /* Validate layout qualifiers for gl_FragDepth.
 	     *
 	     * From the AMD/ARB_conservative_depth specs:
@@ -1485,8 +1493,12 @@ update_array_sizes(struct gl_shader_program *prog)
 	 /* GL_ARB_uniform_buffer_object says that std140 uniforms
 	  * will not be eliminated.  Since we always do std140, just
 	  * don't resize arrays in UBOs.
+          *
+          * Atomic counters are supposed to get deterministic
+          * locations assigned based on the declaration ordering and
+          * sizes, array compaction would mess that up.
 	  */
-	 if (var->is_in_uniform_block())
+	 if (var->is_in_uniform_block() || var->type->contains_atomic())
 	    continue;
 
 	 unsigned int size = var->max_array_access;
@@ -1991,6 +2003,10 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
       prog->UniformBlockStageIndex[i] = NULL;
    }
 
+   ralloc_free(prog->AtomicBuffers);
+   prog->AtomicBuffers = NULL;
+   prog->NumAtomicBuffers = 0;
+
    /* Separate the shaders into groups based on their type.
     */
    struct gl_shader **vert_shader_list;
@@ -2342,9 +2358,12 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
 
    update_array_sizes(prog);
    link_assign_uniform_locations(prog);
+   link_assign_atomic_counter_resources(ctx, prog);
    store_fragdepth_layout(prog);
 
    check_resources(ctx, prog);
+   link_check_atomic_counter_resources(ctx, prog);
+
    if (!prog->LinkStatus)
       goto done;
 
diff --git a/src/glsl/linker.h b/src/glsl/linker.h
index 887cd33..7b1f6f9 100644
--- a/src/glsl/linker.h
+++ b/src/glsl/linker.h
@@ -69,6 +69,14 @@ validate_interstage_interface_blocks(struct gl_shader_program *prog,
                                      const gl_shader *producer,
                                      const gl_shader *consumer);
 
+extern void
+link_assign_atomic_counter_resources(struct gl_context *ctx,
+                                     struct gl_shader_program *prog);
+
+extern void
+link_check_atomic_counter_resources(struct gl_context *ctx,
+                                    struct gl_shader_program *prog);
+
 /**
  * Class for processing all of the leaf fields of a variable that corresponds
  * to a program resource.
diff --git a/src/glsl/lower_packed_varyings.cpp b/src/glsl/lower_packed_varyings.cpp
index 2bcadfd..61ee692 100644
--- a/src/glsl/lower_packed_varyings.cpp
+++ b/src/glsl/lower_packed_varyings.cpp
@@ -506,17 +506,16 @@ lower_packed_varyings_visitor::lower_arraylike(ir_rvalue *rvalue,
       ir_constant *constant = new(this->mem_ctx) ir_constant(i);
       ir_dereference_array *dereference_array = new(this->mem_ctx)
          ir_dereference_array(rvalue, constant);
-      char *subscripted_name
-         = ralloc_asprintf(this->mem_ctx, "%s[%d]", name, i);
       if (gs_input_toplevel) {
          /* Geometry shader inputs are a special case.  Instead of storing
           * each element of the array at a different location, all elements
           * are at the same location, but with a different vertex index.
           */
          (void) this->lower_rvalue(dereference_array, fine_location,
-                                   unpacked_var, subscripted_name,
-                                   false, i);
+                                   unpacked_var, name, false, i);
       } else {
+         char *subscripted_name
+            = ralloc_asprintf(this->mem_ctx, "%s[%d]", name, i);
          fine_location =
             this->lower_rvalue(dereference_array, fine_location,
                                unpacked_var, subscripted_name,
diff --git a/src/glsl/opt_algebraic.cpp b/src/glsl/opt_algebraic.cpp
index a07e153..05a5899 100644
--- a/src/glsl/opt_algebraic.cpp
+++ b/src/glsl/opt_algebraic.cpp
@@ -357,7 +357,6 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
       break;
 
    case ir_binop_logic_and:
-      /* FINISHME: Also simplify (a && a) to (a). */
       if (is_vec_one(op_const[0])) {
 	 return ir->operands[1];
       } else if (is_vec_one(op_const[1])) {
@@ -371,11 +370,13 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
           */
          return logic_not(logic_or(op_expr[0]->operands[0],
                                    op_expr[1]->operands[0]));
+      } else if (ir->operands[0]->equals(ir->operands[1])) {
+         /* (a && a) == a */
+         return ir->operands[0];
       }
       break;
 
    case ir_binop_logic_xor:
-      /* FINISHME: Also simplify (a ^^ a) to (false). */
       if (is_vec_zero(op_const[0])) {
 	 return ir->operands[1];
       } else if (is_vec_zero(op_const[1])) {
@@ -384,11 +385,13 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
 	 return logic_not(ir->operands[1]);
       } else if (is_vec_one(op_const[1])) {
 	 return logic_not(ir->operands[0]);
+      } else if (ir->operands[0]->equals(ir->operands[1])) {
+         /* (a ^^ a) == false */
+	 return ir_constant::zero(mem_ctx, ir->type);
       }
       break;
 
    case ir_binop_logic_or:
-      /* FINISHME: Also simplify (a || a) to (a). */
       if (is_vec_zero(op_const[0])) {
 	 return ir->operands[1];
       } else if (is_vec_zero(op_const[1])) {
@@ -407,6 +410,9 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
           */
          return logic_not(logic_and(op_expr[0]->operands[0],
                                     op_expr[1]->operands[0]));
+      } else if (ir->operands[0]->equals(ir->operands[1])) {
+         /* (a || a) == a */
+         return ir->operands[0];
       }
       break;
 
@@ -414,10 +420,11 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
       if (op_expr[0] && op_expr[0]->operation == ir_unop_rcp)
 	 return op_expr[0]->operands[0];
 
-      /* FINISHME: We should do rcp(rsq(x)) -> sqrt(x) for some
-       * backends, except that some backends will have done sqrt ->
-       * rcp(rsq(x)) and we don't want to undo it for them.
+      /* While ir_to_mesa.cpp will lower sqrt(x) to rcp(rsq(x)), it does so at
+       * its IR level, so we can always apply this transformation.
        */
+      if (op_expr[0] && op_expr[0]->operation == ir_unop_rsq)
+         return sqrt(op_expr[0]->operands[0]);
 
       /* As far as we know, all backends are OK with rsq. */
       if (op_expr[0] && op_expr[0]->operation == ir_unop_sqrt) {
diff --git a/src/glsl/opt_cse.cpp b/src/glsl/opt_cse.cpp
index c0fdb23..8f73940 100644
--- a/src/glsl/opt_cse.cpp
+++ b/src/glsl/opt_cse.cpp
@@ -243,182 +243,6 @@ is_cse_candidate(ir_rvalue *ir)
    return v.ok;
 }
 
-static bool
-equals(ir_rvalue *a, ir_rvalue *b);
-
-static bool
-equals(ir_constant *a, ir_constant *b)
-{
-   if (!a || !b)
-      return false;
-
-   if (a->type != b->type)
-      return false;
-
-   for (unsigned i = 0; i < a->type->components(); i++) {
-      if (a->value.u[i] != b->value.u[i])
-         return false;
-   }
-
-   return true;
-}
-
-static bool
-equals(ir_dereference_variable *a, ir_dereference_variable *b)
-{
-   if (!a || !b)
-      return false;
-
-   return a->var == b->var;
-}
-
-static bool
-equals(ir_dereference_array *a, ir_dereference_array *b)
-{
-   if (!a || !b)
-      return false;
-
-   if (!equals(a->array, b->array))
-      return false;
-
-   if (!equals(a->array_index, b->array_index))
-      return false;
-
-   return true;
-}
-
-static bool
-equals(ir_swizzle *a, ir_swizzle *b)
-{
-   if (!a || !b)
-      return false;
-
-   if (a->type != b->type)
-      return false;
-
-   if (a->mask.x != b->mask.x ||
-       a->mask.y != b->mask.y ||
-       a->mask.z != b->mask.z ||
-       a->mask.w != b->mask.w) {
-      return false;
-   }
-
-   return equals(a->val, b->val);
-}
-
-static bool
-equals(ir_texture *a, ir_texture *b)
-{
-   if (!a || !b)
-      return false;
-
-   if (a->type != b->type)
-      return false;
-
-   if (a->op != b->op)
-      return false;
-
-   if (!equals(a->coordinate, b->coordinate))
-      return false;
-
-   if (!equals(a->projector, b->projector))
-      return false;
-
-   if (!equals(a->shadow_comparitor, b->shadow_comparitor))
-      return false;
-
-   if (!equals(a->offset, b->offset))
-      return false;
-
-   if (!equals(a->sampler, b->sampler))
-      return false;
-
-   switch (a->op) {
-   case ir_tex:
-   case ir_lod:
-   case ir_query_levels:
-      break;
-   case ir_txb:
-      if (!equals(a->lod_info.bias, b->lod_info.bias))
-         return false;
-      break;
-   case ir_txl:
-   case ir_txf:
-   case ir_txs:
-      if (!equals(a->lod_info.lod, b->lod_info.lod))
-         return false;
-      break;
-   case ir_txd:
-      if (!equals(a->lod_info.grad.dPdx, b->lod_info.grad.dPdx) ||
-          !equals(a->lod_info.grad.dPdy, b->lod_info.grad.dPdy))
-         return false;
-   case ir_txf_ms:
-      if (!equals(a->lod_info.sample_index, b->lod_info.sample_index))
-         return false;
-      break;
-   case ir_tg4:
-      if (!equals(a->lod_info.component, b->lod_info.component))
-         return false;
-   default:
-      assert(!"Unrecognized texture op");
-   }
-
-   return true;
-}
-
-static bool
-equals(ir_expression *a, ir_expression *b)
-{
-   if (!a || !b)
-      return false;
-
-   if (a->type != b->type)
-      return false;
-
-   if (a->operation != b->operation)
-      return false;
-
-   for (unsigned i = 0; i < a->get_num_operands(); i++) {
-      if (!equals(a->operands[i], b->operands[i]))
-         return false;
-   }
-
-   return true;
-}
-
-static bool
-equals(ir_rvalue *a, ir_rvalue *b)
-{
-   if (!a || !b)
-      return !a && !b;
-
-   if (a->type != b->type)
-      return false;
-
-   switch (a->ir_type) {
-   case ir_type_texture:
-      return equals(a->as_texture(), b->as_texture());
-
-   case ir_type_constant:
-      return equals(a->as_constant(), b->as_constant());
-
-   case ir_type_expression:
-      return equals(a->as_expression(), b->as_expression());
-
-   case ir_type_dereference_variable:
-      return equals(a->as_dereference_variable(), b->as_dereference_variable());
-
-   case ir_type_dereference_array:
-      return equals(a->as_dereference_array(), b->as_dereference_array());
-
-   case ir_type_swizzle:
-      return equals(a->as_swizzle(), b->as_swizzle());
-
-   default:
-      return false;
-   }
-}
-
 /**
  * Tries to find and return a reference to a previous computation of a given
  * expression.
@@ -439,7 +263,7 @@ cse_visitor::try_cse(ir_rvalue *rvalue)
          printf("\n");
       }
 
-      if (!equals(rvalue, *entry->val))
+      if (!rvalue->equals(*entry->val))
          continue;
 
       if (debug) {
diff --git a/src/glx/Makefile.am b/src/glx/Makefile.am
index f01709b..0aec2aa 100644
--- a/src/glx/Makefile.am
+++ b/src/glx/Makefile.am
@@ -77,6 +77,7 @@ libglx_la_SOURCES = \
 	  indirect_vertex_program.c \
 	  pixel.c \
 	  pixelstore.c \
+	  query_renderer.c \
 	  render2.c \
 	  renderpix.c \
 	  single2.c \
@@ -92,8 +93,15 @@ libglx_la_SOURCES = \
 	  glxhash.c \
 	  dri2_glx.c \
 	  dri2.c \
+	  dri2_query_renderer.c \
 	  applegl_glx.c
 
+if HAVE_DRI3
+libglx_la_SOURCES += \
+          dri3_glx.c \
+          dri3_common.c
+endif
+
 GL_LIBS = \
 	libglx.la \
 	$(SHARED_GLAPI_LIBS) \
diff --git a/src/glx/SConscript b/src/glx/SConscript
index 887ac61..890f998 100644
--- a/src/glx/SConscript
+++ b/src/glx/SConscript
@@ -63,6 +63,7 @@ sources = [
     'indirect_vertex_program.c',
     'pixel.c',
     'pixelstore.c',
+    'query_renderer.c',
     'render2.c',
     'renderpix.c',
     'single2.c',
@@ -78,6 +79,9 @@ sources = [
     'glxhash.c',
     'dri2_glx.c',
     'dri2.c',
+    'dri2_query_renderer.c',
+    #'dri3_glx.c',
+    #'dri3_common.c',
     'applegl_glx.c',
 ]
 
diff --git a/src/glx/dri2.h b/src/glx/dri2.h
index a6fe66e..90efde8 100644
--- a/src/glx/dri2.h
+++ b/src/glx/dri2.h
@@ -45,6 +45,8 @@ typedef struct
    unsigned int flags;
 } DRI2Buffer;
 
+struct glx_screen;
+
 extern Bool
 DRI2QueryExtension(Display * display, int *eventBase, int *errorBase);
 
@@ -85,4 +87,12 @@ DRI2CopyRegion(Display * dpy, XID drawable,
                XserverRegion region,
                CARD32 dest, CARD32 src);
 
+_X_HIDDEN int
+dri2_query_renderer_integer(struct glx_screen *base, int attribute,
+                            unsigned int *value);
+
+_X_HIDDEN int
+dri2_query_renderer_string(struct glx_screen *base, int attribute,
+                           const char **value);
+
 #endif
diff --git a/src/glx/dri2_glx.c b/src/glx/dri2_glx.c
index cfa5856..3b33312 100644
--- a/src/glx/dri2_glx.c
+++ b/src/glx/dri2_glx.c
@@ -50,6 +50,7 @@
 #include "xf86drm.h"
 #include "dri2.h"
 #include "dri_common.h"
+#include "dri2_priv.h"
 
 /* From xmlpool/options.h, user exposed so should be stable */
 #define DRI_CONF_VBLANK_NEVER 0
@@ -78,26 +79,6 @@ struct dri2_display
    const __DRIextension *loader_extensions[4];
 };
 
-struct dri2_screen {
-   struct glx_screen base;
-
-   __DRIscreen *driScreen;
-   __GLXDRIscreen vtable;
-   const __DRIdri2Extension *dri2;
-   const __DRIcoreExtension *core;
-
-   const __DRI2flushExtension *f;
-   const __DRI2configQueryExtension *config;
-   const __DRItexBufferExtension *texBuffer;
-   const __DRI2throttleExtension *throttle;
-   const __DRIconfig **driver_configs;
-
-   void *driver;
-   int fd;
-
-   int show_fps_interval;
-};
-
 struct dri2_context
 {
    struct glx_context base;
@@ -1136,12 +1117,23 @@ dri2BindExtensions(struct dri2_screen *psc, struct glx_display * priv,
           && strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0)
          __glXEnableDirectExtension(&psc->base,
                                     "GLX_ARB_create_context_robustness");
+
+      /* DRI2 version 3 is also required because GLX_MESA_query_renderer
+       * requires GLX_ARB_create_context_profile.
+       */
+      if (psc->dri2->base.version >= 3
+          && strcmp(extensions[i]->name, __DRI2_RENDERER_QUERY) == 0) {
+         psc->rendererQuery = (__DRI2rendererQueryExtension *) extensions[i];
+         __glXEnableDirectExtension(&psc->base, "GLX_MESA_query_renderer");
+      }
    }
 }
 
 static const struct glx_screen_vtable dri2_screen_vtable = {
    dri2_create_context,
-   dri2_create_context_attribs
+   dri2_create_context_attribs,
+   dri2_query_renderer_integer,
+   dri2_query_renderer_string,
 };
 
 static struct glx_screen *
diff --git a/src/glx/dri2_priv.h b/src/glx/dri2_priv.h
new file mode 100644
index 0000000..c21eee5
--- /dev/null
+++ b/src/glx/dri2_priv.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+struct dri2_screen {
+   struct glx_screen base;
+
+   __DRIscreen *driScreen;
+   __GLXDRIscreen vtable;
+   const __DRIdri2Extension *dri2;
+   const __DRIcoreExtension *core;
+
+   const __DRI2flushExtension *f;
+   const __DRI2configQueryExtension *config;
+   const __DRItexBufferExtension *texBuffer;
+   const __DRI2throttleExtension *throttle;
+   const __DRI2rendererQueryExtension *rendererQuery;
+   const __DRIconfig **driver_configs;
+
+   void *driver;
+   int fd;
+
+   int show_fps_interval;
+};
diff --git a/src/glx/dri2_query_renderer.c b/src/glx/dri2_query_renderer.c
new file mode 100644
index 0000000..b50a202
--- /dev/null
+++ b/src/glx/dri2_query_renderer.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "glxclient.h"
+#include "glx_error.h"
+#include "xf86drm.h"
+#include "dri2.h"
+#include "dri_interface.h"
+#include "dri2_priv.h"
+
+static int
+dri2_convert_glx_query_renderer_attribs(int attribute)
+{
+   switch (attribute) {
+   case GLX_RENDERER_VENDOR_ID_MESA:
+      return __DRI2_RENDERER_VENDOR_ID;
+   case GLX_RENDERER_DEVICE_ID_MESA:
+      return __DRI2_RENDERER_DEVICE_ID;
+   case GLX_RENDERER_VERSION_MESA:
+      return __DRI2_RENDERER_VERSION;
+   case GLX_RENDERER_ACCELERATED_MESA:
+      return __DRI2_RENDERER_ACCELERATED;
+   case GLX_RENDERER_VIDEO_MEMORY_MESA:
+      return __DRI2_RENDERER_VIDEO_MEMORY;
+   case GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA:
+      return __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE;
+   case GLX_RENDERER_PREFERRED_PROFILE_MESA:
+      return __DRI2_RENDERER_PREFERRED_PROFILE;
+   case GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA:
+      return __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION;
+   case GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA:
+      return __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION;
+   case GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA:
+      return __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION;
+   case GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA:
+      return __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION;
+   default:
+      return -1;
+   }
+}
+
+_X_HIDDEN int
+dri2_query_renderer_integer(struct glx_screen *base, int attribute,
+                            unsigned int *value)
+{
+   struct dri2_screen *const psc = (struct dri2_screen *) base;
+
+   /* Even though there are invalid values (and
+    * dri2_convert_glx_query_renderer_attribs may return -1), the higher level
+    * GLX code is required to perform the filtering.  Assume that we got a
+    * good value.
+    */
+   const int dri_attribute = dri2_convert_glx_query_renderer_attribs(attribute);
+
+   if (psc->rendererQuery == NULL)
+      return -1;
+
+   return psc->rendererQuery->queryInteger(psc->driScreen, dri_attribute,
+                                           value);
+}
+
+_X_HIDDEN int
+dri2_query_renderer_string(struct glx_screen *base, int attribute,
+                           const char **value)
+{
+   struct dri2_screen *const psc = (struct dri2_screen *) base;
+
+   /* Even though queryString only accepts a subset of the possible GLX
+    * queries, the higher level GLX code is required to perform the filtering.
+    * Assume that we got a good value.
+    */
+   const int dri_attribute = dri2_convert_glx_query_renderer_attribs(attribute);
+
+   if (psc->rendererQuery == NULL)
+      return -1;
+
+   return psc->rendererQuery->queryString(psc->driScreen, dri_attribute, value);
+}
diff --git a/src/glx/dri3_common.c b/src/glx/dri3_common.c
new file mode 100644
index 0000000..c758f96
--- /dev/null
+++ b/src/glx/dri3_common.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright © 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/*
+ * This code is derived from src/egl/drivers/dri2/common.c which
+ * carries the following copyright:
+ * 
+ * Copyright © 2011 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Kristian Høgsberg <krh@bitplanet.net>
+ *    Benjamin Franzke <benjaminfranzke@googlemail.com>
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <GL/gl.h>
+#include "glapi.h"
+#include "glxclient.h"
+#include "xf86dri.h"
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+#include "xf86drm.h"
+#include "dri_common.h"
+#include "dri3_priv.h"
+
+#define DRIVER_MAP_DRI3_ONLY
+#include "pci_ids/pci_id_driver_map.h"
+
+#include <libudev.h>
+
+static struct udev_device *
+dri3_udev_device_new_from_fd(struct udev *udev, int fd)
+{
+   struct udev_device *device;
+   struct stat buf;
+
+   if (fstat(fd, &buf) < 0) {
+      ErrorMessageF("DRI3: failed to stat fd %d", fd);
+      return NULL;
+   }
+
+   device = udev_device_new_from_devnum(udev, 'c', buf.st_rdev);
+   if (device == NULL) {
+      ErrorMessageF("DRI3: could not create udev device for fd %d", fd);
+      return NULL;
+   }
+
+   return device;
+}
+
+char *
+dri3_get_driver_for_fd(int fd)
+{
+   struct udev *udev;
+   struct udev_device *device, *parent;
+   const char *pci_id;
+   char *driver = NULL;
+   int vendor_id, chip_id, i, j;
+
+   udev = udev_new();
+   device = dri3_udev_device_new_from_fd(udev, fd);
+   if (device == NULL)
+      return NULL;
+
+   parent = udev_device_get_parent(device);
+   if (parent == NULL) {
+      ErrorMessageF("DRI3: could not get parent device");
+      goto out;
+   }
+
+   pci_id = udev_device_get_property_value(parent, "PCI_ID");
+   if (pci_id == NULL ||
+       sscanf(pci_id, "%x:%x", &vendor_id, &chip_id) != 2) {
+      ErrorMessageF("DRI3: malformed or no PCI ID");
+      goto out;
+   }
+
+   for (i = 0; driver_map[i].driver; i++) {
+      if (vendor_id != driver_map[i].vendor_id)
+         continue;
+      if (driver_map[i].num_chips_ids == -1) {
+         driver = strdup(driver_map[i].driver);
+         goto out;
+      }
+
+      for (j = 0; j < driver_map[i].num_chips_ids; j++)
+         if (driver_map[i].chip_ids[j] == chip_id) {
+            driver = strdup(driver_map[i].driver);
+            goto out;
+         }
+   }
+
+out:
+   udev_device_unref(device);
+   udev_unref(udev);
+
+   return driver;
+}
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
new file mode 100644
index 0000000..b047cc8
--- /dev/null
+++ b/src/glx/dri3_glx.c
@@ -0,0 +1,1804 @@
+/*
+ * Copyright © 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/*
+ * Portions of this code were adapted from dri2_glx.c which carries the
+ * following copyright:
+ *
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
+
+#include <X11/Xlib.h>
+#include <X11/extensions/Xfixes.h>
+#include <X11/Xlib-xcb.h>
+#include <X11/xshmfence.h>
+#include <xcb/xcb.h>
+#include <xcb/dri3.h>
+#include <xcb/present.h>
+#include <GL/gl.h>
+#include "glapi.h"
+#include "glxclient.h"
+#include "xf86dri.h"
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+
+#include "xf86drm.h"
+#include "dri_common.h"
+#include "dri3_priv.h"
+
+static const struct glx_context_vtable dri3_context_vtable;
+
+static inline void
+dri3_fence_reset(xcb_connection_t *c, struct dri3_buffer *buffer)
+{
+   xshmfence_reset(buffer->shm_fence);
+}
+
+static inline void
+dri3_fence_set(struct dri3_buffer *buffer)
+{
+   xshmfence_trigger(buffer->shm_fence);
+}
+
+static inline void
+dri3_fence_trigger(xcb_connection_t *c, struct dri3_buffer *buffer)
+{
+   xcb_sync_trigger_fence(c, buffer->sync_fence);
+}
+
+static inline void
+dri3_fence_await(xcb_connection_t *c, struct dri3_buffer *buffer)
+{
+   xcb_flush(c);
+   xshmfence_await(buffer->shm_fence);
+}
+
+static inline Bool
+dri3_fence_triggered(struct dri3_buffer *buffer)
+{
+   return xshmfence_query(buffer->shm_fence);
+}
+
+static void
+dri3_destroy_context(struct glx_context *context)
+{
+   struct dri3_context *pcp = (struct dri3_context *) context;
+   struct dri3_screen *psc = (struct dri3_screen *) context->psc;
+
+   driReleaseDrawables(&pcp->base);
+
+   free((char *) context->extensions);
+
+   (*psc->core->destroyContext) (pcp->driContext);
+
+   free(pcp);
+}
+
+static Bool
+dri3_bind_context(struct glx_context *context, struct glx_context *old,
+                  GLXDrawable draw, GLXDrawable read)
+{
+   struct dri3_context *pcp = (struct dri3_context *) context;
+   struct dri3_screen *psc = (struct dri3_screen *) pcp->base.psc;
+   struct dri3_drawable *pdraw, *pread;
+
+   pdraw = (struct dri3_drawable *) driFetchDrawable(context, draw);
+   pread = (struct dri3_drawable *) driFetchDrawable(context, read);
+
+   driReleaseDrawables(&pcp->base);
+
+   if (pdraw == NULL || pread == NULL)
+      return GLXBadDrawable;
+
+   if (!(*psc->core->bindContext) (pcp->driContext,
+                                   pdraw->driDrawable, pread->driDrawable))
+      return GLXBadContext;
+
+   return Success;
+}
+
+static void
+dri3_unbind_context(struct glx_context *context, struct glx_context *new)
+{
+   struct dri3_context *pcp = (struct dri3_context *) context;
+   struct dri3_screen *psc = (struct dri3_screen *) pcp->base.psc;
+
+   (*psc->core->unbindContext) (pcp->driContext);
+}
+
+static struct glx_context *
+dri3_create_context_attribs(struct glx_screen *base,
+                            struct glx_config *config_base,
+                            struct glx_context *shareList,
+                            unsigned num_attribs,
+                            const uint32_t *attribs,
+                            unsigned *error)
+{
+   struct dri3_context *pcp = NULL;
+   struct dri3_context *pcp_shared = NULL;
+   struct dri3_screen *psc = (struct dri3_screen *) base;
+   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
+   __DRIcontext *shared = NULL;
+
+   uint32_t minor_ver = 1;
+   uint32_t major_ver = 2;
+   uint32_t flags = 0;
+   unsigned api;
+   int reset = __DRI_CTX_RESET_NO_NOTIFICATION;
+   uint32_t ctx_attribs[2 * 5];
+   unsigned num_ctx_attribs = 0;
+   uint32_t render_type;
+
+   /* Remap the GLX tokens to DRI2 tokens.
+    */
+   if (!dri2_convert_glx_attribs(num_attribs, attribs,
+                                 &major_ver, &minor_ver,
+                                 &render_type, &flags, &api,
+                                 &reset, error))
+      goto error_exit;
+
+   /* Check the renderType value */
+   if (!validate_renderType_against_config(config_base, render_type))
+       goto error_exit;
+
+   if (shareList) {
+      pcp_shared = (struct dri3_context *) shareList;
+      shared = pcp_shared->driContext;
+   }
+
+   pcp = calloc(1, sizeof *pcp);
+   if (pcp == NULL) {
+      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      goto error_exit;
+   }
+
+   if (!glx_context_init(&pcp->base, &psc->base, &config->base))
+      goto error_exit;
+
+   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MAJOR_VERSION;
+   ctx_attribs[num_ctx_attribs++] = major_ver;
+   ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_MINOR_VERSION;
+   ctx_attribs[num_ctx_attribs++] = minor_ver;
+
+   /* Only send a value when the non-default value is requested.  By doing
+    * this we don't have to check the driver's DRI3 version before sending the
+    * default value.
+    */
+   if (reset != __DRI_CTX_RESET_NO_NOTIFICATION) {
+      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_RESET_STRATEGY;
+      ctx_attribs[num_ctx_attribs++] = reset;
+   }
+
+   if (flags != 0) {
+      ctx_attribs[num_ctx_attribs++] = __DRI_CTX_ATTRIB_FLAGS;
+
+      /* The current __DRI_CTX_FLAG_* values are identical to the
+       * GLX_CONTEXT_*_BIT values.
+       */
+      ctx_attribs[num_ctx_attribs++] = flags;
+   }
+
+   pcp->driContext =
+      (*psc->image_driver->createContextAttribs) (psc->driScreen,
+                                                  api,
+                                                  config->driConfig,
+                                                  shared,
+                                                  num_ctx_attribs / 2,
+                                                  ctx_attribs,
+                                                  error,
+                                                  pcp);
+
+   if (pcp->driContext == NULL)
+      goto error_exit;
+
+   pcp->base.vtable = &dri3_context_vtable;
+
+   return &pcp->base;
+
+error_exit:
+   free(pcp);
+
+   return NULL;
+}
+
+static struct glx_context *
+dri3_create_context(struct glx_screen *base,
+                    struct glx_config *config_base,
+                    struct glx_context *shareList, int renderType)
+{
+   unsigned int error;
+
+   return dri3_create_context_attribs(base, config_base, shareList,
+                                      0, NULL, &error);
+}
+
+static void
+dri3_destroy_drawable(__GLXDRIdrawable *base)
+{
+   struct dri3_screen *psc = (struct dri3_screen *) base->psc;
+   struct dri3_drawable *pdraw = (struct dri3_drawable *) base;
+
+   (*psc->core->destroyDrawable) (pdraw->driDrawable);
+
+   free(pdraw);
+}
+
+static __GLXDRIdrawable *
+dri3_create_drawable(struct glx_screen *base, XID xDrawable,
+                     GLXDrawable drawable, struct glx_config *config_base)
+{
+   struct dri3_drawable *pdraw;
+   struct dri3_screen *psc = (struct dri3_screen *) base;
+   __GLXDRIconfigPrivate *config = (__GLXDRIconfigPrivate *) config_base;
+   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;
+
+   pdraw = calloc(1, sizeof(*pdraw));
+   if (!pdraw)
+      return NULL;
+
+   pdraw->base.destroyDrawable = dri3_destroy_drawable;
+   pdraw->base.xDrawable = xDrawable;
+   pdraw->base.drawable = drawable;
+   pdraw->base.psc = &psc->base;
+   pdraw->swap_interval = 1; /* default may be overridden below */
+   pdraw->have_back = 0;
+   pdraw->have_fake_front = 0;
+
+   if (psc->config)
+      psc->config->configQueryi(psc->driScreen,
+                                "vblank_mode", &vblank_mode);
+
+   switch (vblank_mode) {
+   case DRI_CONF_VBLANK_NEVER:
+   case DRI_CONF_VBLANK_DEF_INTERVAL_0:
+      pdraw->swap_interval = 0;
+      break;
+   case DRI_CONF_VBLANK_DEF_INTERVAL_1:
+   case DRI_CONF_VBLANK_ALWAYS_SYNC:
+   default:
+      pdraw->swap_interval = 1;
+      break;
+   }
+
+   (void) __glXInitialize(psc->base.dpy);
+
+   /* Create a new drawable */
+   pdraw->driDrawable =
+      (*psc->image_driver->createNewDrawable) (psc->driScreen,
+                                               config->driConfig, pdraw);
+
+   if (!pdraw->driDrawable) {
+      free(pdraw);
+      return NULL;
+   }
+
+   /*
+    * Make sure server has the same swap interval we do for the new
+    * drawable.
+    */
+   if (psc->vtable.setSwapInterval)
+      psc->vtable.setSwapInterval(&pdraw->base, pdraw->swap_interval);
+
+   return &pdraw->base;
+}
+
+/*
+ * Process one Present event
+ */
+static void
+dri3_handle_present_event(struct dri3_drawable *priv, xcb_present_generic_event_t *ge)
+{
+   switch (ge->evtype) {
+   case XCB_PRESENT_CONFIGURE_NOTIFY: {
+      xcb_present_configure_notify_event_t *ce = (void *) ge;
+
+      priv->width = ce->width;
+      priv->height = ce->height;
+      break;
+   }
+   case XCB_PRESENT_COMPLETE_NOTIFY: {
+      xcb_present_complete_notify_event_t *ce = (void *) ge;
+
+      if (ce->kind == XCB_PRESENT_COMPLETE_KIND_PIXMAP)
+         priv->present_event_serial = ce->serial;
+      else
+         priv->present_msc_event_serial = ce->serial;
+      priv->ust = ce->ust;
+      priv->msc = ce->msc;
+      break;
+   }
+   case XCB_PRESENT_EVENT_IDLE_NOTIFY: {
+      xcb_present_idle_notify_event_t *ie = (void *) ge;
+      int b;
+
+      for (b = 0; b < sizeof (priv->buffers) / sizeof (priv->buffers[0]); b++) {
+         struct dri3_buffer        *buf = priv->buffers[b];
+
+         if (buf && buf->pixmap == ie->pixmap) {
+            buf->busy = 0;
+            break;
+         }
+      }
+      break;
+   }
+   }
+   free(ge);
+}
+
+static int
+dri3_wait_for_msc(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
+                  int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
+{
+   xcb_connection_t *c = XGetXCBConnection(pdraw->psc->dpy);
+   struct dri3_drawable *priv = (struct dri3_drawable *) pdraw;
+   xcb_generic_event_t *ev;
+   xcb_present_generic_event_t *ge;
+
+   /* Ask for the an event for the target MSC */
+   ++priv->present_msc_request_serial;
+   xcb_present_notify_msc(c,
+                          priv->base.xDrawable,
+                          priv->present_msc_request_serial,
+                          target_msc,
+                          divisor,
+                          remainder);
+
+   xcb_flush(c);
+
+   /* Wait for the event */
+   if (priv->special_event) {
+      while (priv->present_msc_request_serial != priv->present_msc_event_serial) {
+         ev = xcb_wait_for_special_event(c, priv->special_event);
+         if (!ev)
+            break;
+         ge = (void *) ev;
+         dri3_handle_present_event(priv, ge);
+      }
+   }
+
+   *ust = priv->ust;
+   *msc = priv->msc;
+   *sbc = priv->sbc;
+
+   return 1;
+}
+
+static int
+dri3_drawable_get_msc(struct glx_screen *psc, __GLXDRIdrawable *pdraw,
+                      int64_t *ust, int64_t *msc, int64_t *sbc)
+{
+   return dri3_wait_for_msc(pdraw, 0, 0, 0, ust, msc,sbc);
+}
+
+/** dri3_wait_for_sbc
+ *
+ * Wait for the swap buffer count to increase. The only way this
+ * can happen is if some other thread is doing swap buffers as
+ * we no longer share swap buffer counts with other processes.
+ *
+ * I'm not sure this is actually useful as such, and so this
+ * implementation is a kludge that just polls once a second
+ */
+static int
+dri3_wait_for_sbc(__GLXDRIdrawable *pdraw, int64_t target_sbc, int64_t *ust,
+                  int64_t *msc, int64_t *sbc)
+{
+   struct dri3_drawable *priv = (struct dri3_drawable *) pdraw;
+
+   while (priv->sbc < target_sbc) {
+      sleep(1);
+   }
+   return dri3_wait_for_msc(pdraw, 0, 0, 0, ust, msc, sbc);
+}
+
+/**
+ * Asks the driver to flush any queued work necessary for serializing with the
+ * X command stream, and optionally the slightly more strict requirement of
+ * glFlush() equivalence (which would require flushing even if nothing had
+ * been drawn to a window system framebuffer, for example).
+ */
+static void
+dri3_flush(struct dri3_screen *psc,
+           struct dri3_drawable *draw,
+           unsigned flags,
+           enum __DRI2throttleReason throttle_reason)
+{
+   struct glx_context *gc = __glXGetCurrentContext();
+
+   if (gc) {
+      struct dri3_context *dri3Ctx = (struct dri3_context *)gc;
+
+      (*psc->f->flush_with_flags)(dri3Ctx->driContext, draw->driDrawable, flags, throttle_reason);
+   }
+}
+
+static xcb_gcontext_t
+dri3_drawable_gc(struct dri3_drawable *priv)
+{
+   if (!priv->gc) {
+      uint32_t v;
+      xcb_connection_t *c = XGetXCBConnection(priv->base.psc->dpy);
+
+      v = 0;
+      xcb_create_gc(c,
+                    (priv->gc = xcb_generate_id(c)),
+                    priv->base.xDrawable,
+                    XCB_GC_GRAPHICS_EXPOSURES,
+                    &v);
+   }
+   return priv->gc;
+}
+
+static struct dri3_buffer *
+dri3_back_buffer(struct dri3_drawable *priv)
+{
+   return priv->buffers[DRI3_BACK_ID(priv->cur_back)];
+}
+
+static struct dri3_buffer *
+dri3_fake_front_buffer(struct dri3_drawable *priv)
+{
+   return priv->buffers[DRI3_FRONT_ID];
+}
+
+static void
+dri3_copy_area (xcb_connection_t *c  /**< */,
+                xcb_drawable_t    src_drawable  /**< */,
+                xcb_drawable_t    dst_drawable  /**< */,
+                xcb_gcontext_t    gc  /**< */,
+                int16_t           src_x  /**< */,
+                int16_t           src_y  /**< */,
+                int16_t           dst_x  /**< */,
+                int16_t           dst_y  /**< */,
+                uint16_t          width  /**< */,
+                uint16_t          height  /**< */)
+{
+   xcb_void_cookie_t cookie;
+
+   cookie = xcb_copy_area_checked(c,
+                                  src_drawable,
+                                  dst_drawable,
+                                  gc,
+                                  src_x,
+                                  src_y,
+                                  dst_x,
+                                  dst_y,
+                                  width,
+                                  height);
+   xcb_discard_reply(c, cookie.sequence);
+}
+
+static void
+dri3_copy_sub_buffer(__GLXDRIdrawable *pdraw, int x, int y,
+                     int width, int height,
+                     Bool flush)
+{
+   struct dri3_drawable *priv = (struct dri3_drawable *) pdraw;
+   struct dri3_screen *psc = (struct dri3_screen *) pdraw->psc;
+   xcb_connection_t     *c = XGetXCBConnection(priv->base.psc->dpy);
+   struct dri3_buffer *back = dri3_back_buffer(priv);
+
+   unsigned flags;
+
+   /* Check we have the right attachments */
+   if (!priv->have_back || priv->is_pixmap)
+      return;
+
+   flags = __DRI2_FLUSH_DRAWABLE;
+   if (flush)
+      flags |= __DRI2_FLUSH_CONTEXT;
+   dri3_flush(psc, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);
+
+   y = priv->height - y - height;
+
+   dri3_fence_reset(c, back);
+   dri3_copy_area(c,
+                  dri3_back_buffer(priv)->pixmap,
+                  priv->base.xDrawable,
+                  dri3_drawable_gc(priv),
+                  x, y, x, y, width, height);
+   dri3_fence_trigger(c, back);
+   /* Refresh the fake front (if present) after we just damaged the real
+    * front.
+    */
+   if (priv->have_fake_front) {
+      dri3_fence_reset(c, dri3_fake_front_buffer(priv));
+      dri3_copy_area(c,
+                     dri3_back_buffer(priv)->pixmap,
+                     dri3_fake_front_buffer(priv)->pixmap,
+                     dri3_drawable_gc(priv),
+                     x, y, x, y, width, height);
+      dri3_fence_trigger(c, dri3_fake_front_buffer(priv));
+      dri3_fence_await(c, dri3_fake_front_buffer(priv));
+   }
+   dri3_fence_await(c, back);
+}
+
+static void
+dri3_copy_drawable(struct dri3_drawable *priv, Drawable dest, Drawable src)
+{
+   struct dri3_screen *psc = (struct dri3_screen *) priv->base.psc;
+   xcb_connection_t     *c = XGetXCBConnection(priv->base.psc->dpy);
+
+   dri3_flush(psc, priv, __DRI2_FLUSH_DRAWABLE, 0);
+
+   dri3_fence_reset(c, dri3_fake_front_buffer(priv));
+   dri3_copy_area(c,
+                  src, dest,
+                  dri3_drawable_gc(priv),
+                  0, 0, 0, 0, priv->width, priv->height);
+   dri3_fence_trigger(c, dri3_fake_front_buffer(priv));
+   dri3_fence_await(c, dri3_fake_front_buffer(priv));
+}
+
+static void
+dri3_wait_x(struct glx_context *gc)
+{
+   struct dri3_drawable *priv = (struct dri3_drawable *)
+      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
+
+   if (priv == NULL || !priv->have_fake_front)
+      return;
+
+   dri3_copy_drawable(priv, dri3_fake_front_buffer(priv)->pixmap, priv->base.xDrawable);
+}
+
+static void
+dri3_wait_gl(struct glx_context *gc)
+{
+   struct dri3_drawable *priv = (struct dri3_drawable *)
+      GetGLXDRIDrawable(gc->currentDpy, gc->currentDrawable);
+
+   if (priv == NULL || !priv->have_fake_front)
+      return;
+
+   dri3_copy_drawable(priv, priv->base.xDrawable, dri3_fake_front_buffer(priv)->pixmap);
+}
+
+/**
+ * Called by the driver when it needs to update the real front buffer with the
+ * contents of its fake front buffer.
+ */
+static void
+dri3_flush_front_buffer(__DRIdrawable *driDrawable, void *loaderPrivate)
+{
+   struct glx_context *gc;
+   struct dri3_drawable *pdraw = loaderPrivate;
+   struct dri3_screen *psc;
+
+   if (!pdraw)
+      return;
+
+   if (!pdraw->base.psc)
+      return;
+
+   psc = (struct dri3_screen *) pdraw->base.psc;
+
+   (void) __glXInitialize(psc->base.dpy);
+
+   gc = __glXGetCurrentContext();
+
+   dri3_flush(psc, pdraw, __DRI2_FLUSH_DRAWABLE, __DRI2_THROTTLE_FLUSHFRONT);
+
+   dri3_wait_gl(gc);
+}
+
+static uint32_t
+dri3_cpp_for_format(uint32_t format) {
+   switch (format) {
+   case  __DRI_IMAGE_FORMAT_R8:
+      return 1;
+   case  __DRI_IMAGE_FORMAT_RGB565:
+   case  __DRI_IMAGE_FORMAT_GR88:
+      return 2;
+   case  __DRI_IMAGE_FORMAT_XRGB8888:
+   case  __DRI_IMAGE_FORMAT_ARGB8888:
+   case  __DRI_IMAGE_FORMAT_ABGR8888:
+   case  __DRI_IMAGE_FORMAT_XBGR8888:
+   case  __DRI_IMAGE_FORMAT_XRGB2101010:
+   case  __DRI_IMAGE_FORMAT_ARGB2101010:
+   case  __DRI_IMAGE_FORMAT_SARGB8:
+      return 4;
+   case  __DRI_IMAGE_FORMAT_NONE:
+   default:
+      return 0;
+   }
+}
+
+
+/** dri3_alloc_render_buffer
+ *
+ * Use the driver createImage function to construct a __DRIimage, then
+ * get a file descriptor for that and create an X pixmap from that
+ *
+ * Allocate an xshmfence for synchronization
+ */
+static struct dri3_buffer *
+dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
+                         unsigned int format, int width, int height, int depth)
+{
+   struct dri3_screen *psc = (struct dri3_screen *) glx_screen;
+   Display *dpy = glx_screen->dpy;
+   struct dri3_buffer *buffer;
+   xcb_connection_t *c = XGetXCBConnection(dpy);
+   xcb_pixmap_t pixmap;
+   xcb_sync_fence_t sync_fence;
+   int32_t *shm_fence;
+   int buffer_fd, fence_fd;
+   int stride;
+
+   /* Create an xshmfence object and
+    * prepare to send that to the X server
+    */
+
+   fence_fd = xshmfence_alloc_shm();
+   if (fence_fd < 0)
+      return NULL;
+   shm_fence = xshmfence_map_shm(fence_fd);
+   if (shm_fence == NULL)
+      goto no_shm_fence;
+
+   /* Allocate the image from the driver
+    */
+   buffer = calloc(1, sizeof (struct dri3_buffer));
+   if (!buffer)
+      goto no_buffer;
+
+   buffer->cpp = dri3_cpp_for_format(format);
+   if (!buffer->cpp)
+      goto no_image;
+
+   buffer->image = (*psc->image->createImage) (psc->driScreen,
+                                               width, height,
+                                               format,
+                                               __DRI_IMAGE_USE_SHARE|__DRI_IMAGE_USE_SCANOUT,
+                                               buffer);
+
+
+   if (!buffer->image)
+      goto no_image;
+
+   /* X wants the stride, so ask the image for it
+    */
+   if (!(*psc->image->queryImage)(buffer->image, __DRI_IMAGE_ATTRIB_STRIDE, &stride))
+      goto no_buffer_attrib;
+
+   buffer->pitch = stride;
+
+   if (!(*psc->image->queryImage)(buffer->image, __DRI_IMAGE_ATTRIB_FD, &buffer_fd))
+      goto no_buffer_attrib;
+
+   xcb_dri3_pixmap_from_buffer(c,
+                               (pixmap = xcb_generate_id(c)),
+                               draw,
+                               buffer->size,
+                               width, height, buffer->pitch,
+                               depth, buffer->cpp * 8,
+                               buffer_fd);
+
+   xcb_dri3_fence_from_fd(c,
+                          pixmap,
+                          (sync_fence = xcb_generate_id(c)),
+                          false,
+                          fence_fd);
+
+   buffer->pixmap = pixmap;
+   buffer->sync_fence = sync_fence;
+   buffer->shm_fence = shm_fence;
+   buffer->width = width;
+   buffer->height = height;
+
+   /* Mark the buffer as idle
+    */
+   dri3_fence_set(buffer);
+
+   return buffer;
+
+no_buffer_attrib:
+   (*psc->image->destroyImage)(buffer->image);
+no_image:
+   free(buffer);
+no_buffer:
+   xshmfence_unmap_shm(shm_fence);
+no_shm_fence:
+   close(fence_fd);
+   return NULL;
+}
+
+/** dri3_free_render_buffer
+ *
+ * Free everything associated with one render buffer including pixmap, fence
+ * stuff and the driver image
+ */
+static void
+dri3_free_render_buffer(struct dri3_drawable *pdraw, struct dri3_buffer *buffer)
+{
+   struct dri3_screen   *psc = (struct dri3_screen *) pdraw->base.psc;
+   xcb_connection_t     *c = XGetXCBConnection(pdraw->base.psc->dpy);
+
+   xcb_free_pixmap(c, buffer->pixmap);
+   xcb_sync_destroy_fence(c, buffer->sync_fence);
+   xshmfence_unmap_shm(buffer->shm_fence);
+   (*psc->image->destroyImage)(buffer->image);
+   free(buffer);
+}
+
+
+/** dri3_flush_present_events
+ *
+ * Process any present events that have been received from the X server
+ */
+static void
+dri3_flush_present_events(struct dri3_drawable *priv)
+{
+   xcb_connection_t     *c = XGetXCBConnection(priv->base.psc->dpy);
+
+   /* Check to see if any configuration changes have occurred
+    * since we were last invoked
+    */
+   if (priv->special_event) {
+      xcb_generic_event_t    *ev;
+
+      while ((ev = xcb_poll_for_special_event(c, priv->special_event)) != NULL) {
+         xcb_present_generic_event_t *ge = (void *) ev;
+         dri3_handle_present_event(priv, ge);
+      }
+   }
+}
+
+/** dri3_update_drawable
+ *
+ * Called the first time we use the drawable and then
+ * after we receive present configure notify events to
+ * track the geometry of the drawable
+ */
+static int
+dri3_update_drawable(__DRIdrawable *driDrawable, void *loaderPrivate)
+{
+   struct dri3_drawable *priv = loaderPrivate;
+   xcb_connection_t     *c = XGetXCBConnection(priv->base.psc->dpy);
+
+   /* First time through, go get the current drawable geometry
+    */
+   if (priv->width == 0 || priv->height == 0 || priv->depth == 0) {
+      xcb_get_geometry_cookie_t                 geom_cookie;
+      xcb_get_geometry_reply_t                  *geom_reply;
+      xcb_void_cookie_t                         cookie;
+      xcb_generic_error_t                       *error;
+
+      /* Try to select for input on the window.
+       *
+       * If the drawable is a window, this will get our events
+       * delivered.
+       *
+       * Otherwise, we'll get a BadWindow error back from this request which
+       * will let us know that the drawable is a pixmap instead.
+       */
+
+
+      cookie = xcb_present_select_input_checked(c,
+                                                (priv->eid = xcb_generate_id(c)),
+                                                priv->base.xDrawable,
+                                                XCB_PRESENT_EVENT_MASK_CONFIGURE_NOTIFY|
+                                                XCB_PRESENT_EVENT_MASK_COMPLETE_NOTIFY|
+                                                XCB_PRESENT_EVENT_MASK_IDLE_NOTIFY);
+
+      /* Create an XCB event queue to hold present events outside of the usual
+       * application event queue
+       */
+      priv->special_event = xcb_register_for_special_xge(c,
+                                                         &xcb_present_id,
+                                                         priv->eid,
+                                                         priv->stamp);
+
+      geom_cookie = xcb_get_geometry(c, priv->base.xDrawable);
+
+      geom_reply = xcb_get_geometry_reply(c, geom_cookie, NULL);
+
+      if (!geom_reply)
+         return false;
+
+      priv->width = geom_reply->width;
+      priv->height = geom_reply->height;
+      priv->depth = geom_reply->depth;
+      priv->is_pixmap = false;
+
+      free(geom_reply);
+
+      /* Check to see if our select input call failed. If it failed with a
+       * BadWindow error, then assume the drawable is a pixmap. Destroy the
+       * special event queue created above and mark the drawable as a pixmap
+       */
+
+      error = xcb_request_check(c, cookie);
+
+      if (error) {
+         if (error->error_code != BadWindow) {
+            free(error);
+            return false;
+         }
+         priv->is_pixmap = true;
+         xcb_unregister_for_special_event(c, priv->special_event);
+         priv->special_event = NULL;
+      }
+   }
+   dri3_flush_present_events(priv);
+   return true;
+}
+
+/* the DRIimage createImage function takes __DRI_IMAGE_FORMAT codes, while
+ * the createImageFromFds call takes __DRI_IMAGE_FOURCC codes. To avoid
+ * complete confusion, just deal in __DRI_IMAGE_FORMAT codes for now and
+ * translate to __DRI_IMAGE_FOURCC codes in the call to createImageFromFds
+ */
+static int
+image_format_to_fourcc(int format)
+{
+
+   /* Convert from __DRI_IMAGE_FORMAT to __DRI_IMAGE_FOURCC (sigh) */
+   switch (format) {
+   case __DRI_IMAGE_FORMAT_RGB565: return __DRI_IMAGE_FOURCC_RGB565;
+   case __DRI_IMAGE_FORMAT_XRGB8888: return __DRI_IMAGE_FOURCC_XRGB8888;
+   case __DRI_IMAGE_FORMAT_ARGB8888: return __DRI_IMAGE_FOURCC_ARGB8888;
+   case __DRI_IMAGE_FORMAT_ABGR8888: return __DRI_IMAGE_FOURCC_ABGR8888;
+   case __DRI_IMAGE_FORMAT_XBGR8888: return __DRI_IMAGE_FOURCC_XBGR8888;
+   }
+   return 0;
+}
+
+/** dri3_get_pixmap_buffer
+ *
+ * Get the DRM object for a pixmap from the X server and
+ * wrap that with a __DRIimage structure using createImageFromFds
+ */
+static struct dri3_buffer *
+dri3_get_pixmap_buffer(__DRIdrawable *driDrawable,
+                       unsigned int format,
+                       enum dri3_buffer_type buffer_type,
+                       void *loaderPrivate)
+{
+   struct dri3_drawable                 *pdraw = loaderPrivate;
+   int                                  buf_id = dri3_pixmap_buf_id(buffer_type);
+   struct dri3_buffer                   *buffer = pdraw->buffers[buf_id];
+   Pixmap                               pixmap;
+   xcb_dri3_buffer_from_pixmap_cookie_t bp_cookie;
+   xcb_dri3_buffer_from_pixmap_reply_t  *bp_reply;
+   int                                  *fds;
+   Display                              *dpy;
+   struct dri3_screen                   *psc;
+   xcb_connection_t                     *c;
+   xcb_sync_fence_t                     sync_fence;
+   int32_t                              *shm_fence;
+   int                                  fence_fd;
+   __DRIimage                           *image_planar;
+   int                                  stride, offset;
+
+   if (buffer)
+      return buffer;
+
+   pixmap = pdraw->base.xDrawable;
+   psc = (struct dri3_screen *) pdraw->base.psc;
+   dpy = psc->base.dpy;
+   c = XGetXCBConnection(dpy);
+
+   buffer = calloc(1, sizeof (struct dri3_buffer));
+   if (!buffer)
+      goto no_buffer;
+
+   fence_fd = xshmfence_alloc_shm();
+   if (fence_fd < 0)
+      goto no_fence;
+   shm_fence = xshmfence_map_shm(fence_fd);
+   if (shm_fence == NULL) {
+      close (fence_fd);
+      goto no_fence;
+   }
+
+   xcb_dri3_fence_from_fd(c,
+                          pixmap,
+                          (sync_fence = xcb_generate_id(c)),
+                          false,
+                          fence_fd);
+
+   /* Get an FD for the pixmap object
+    */
+   bp_cookie = xcb_dri3_buffer_from_pixmap(c, pixmap);
+   bp_reply = xcb_dri3_buffer_from_pixmap_reply(c, bp_cookie, NULL);
+   if (!bp_reply)
+      goto no_image;
+   fds = xcb_dri3_buffer_from_pixmap_reply_fds(c, bp_reply);
+
+   stride = bp_reply->stride;
+   offset = 0;
+
+   /* createImageFromFds creates a wrapper __DRIimage structure which
+    * can deal with multiple planes for things like Yuv images. So, once
+    * we've gotten the planar wrapper, pull the single plane out of it and
+    * discard the wrapper.
+    */
+   image_planar = (*psc->image->createImageFromFds) (psc->driScreen,
+                                                     bp_reply->width,
+                                                     bp_reply->height,
+                                                     image_format_to_fourcc(format),
+                                                     fds, 1,
+                                                     &stride, &offset, buffer);
+   close(fds[0]);
+   if (!image_planar)
+      goto no_image;
+
+   buffer->image = (*psc->image->fromPlanar)(image_planar, 0, buffer);
+
+   (*psc->image->destroyImage)(image_planar);
+
+   if (!buffer->image)
+      goto no_image;
+
+   buffer->pixmap = pixmap;
+   buffer->width = bp_reply->width;
+   buffer->height = bp_reply->height;
+   buffer->buffer_type = buffer_type;
+   buffer->shm_fence = shm_fence;
+   buffer->sync_fence = sync_fence;
+
+   pdraw->buffers[buf_id] = buffer;
+   return buffer;
+
+no_image:
+   xcb_sync_destroy_fence(c, sync_fence);
+   xshmfence_unmap_shm(shm_fence);
+no_fence:
+   free(buffer);
+no_buffer:
+   return NULL;
+}
+
+/** dri3_find_back
+ *
+ * Find an idle back buffer. If there isn't one, then
+ * wait for a present idle notify event from the X server
+ */
+static int
+dri3_find_back(xcb_connection_t *c, struct dri3_drawable *priv)
+{
+   int  b;
+   xcb_generic_event_t *ev;
+   xcb_present_generic_event_t *ge;
+
+   for (;;) {
+
+      for (b = 0; b < DRI3_MAX_BACK; b++) {
+         int                    id = DRI3_BACK_ID(b);
+         struct dri3_buffer        *buffer = priv->buffers[id];
+
+         if (!buffer)
+            return b;
+         if (!buffer->busy)
+            return b;
+      }
+      ev = xcb_wait_for_special_event(c, priv->special_event);
+      if (!ev)
+         return -1;
+      ge = (void *) ev;
+      dri3_handle_present_event(priv, ge);
+   }
+}
+
+/** dri3_get_buffer
+ *
+ * Find a front or back buffer, allocating new ones as necessary
+ */
+static struct dri3_buffer *
+dri3_get_buffer(__DRIdrawable *driDrawable,
+                unsigned int format,
+                enum dri3_buffer_type buffer_type,
+                void *loaderPrivate)
+{
+   struct dri3_drawable *priv = loaderPrivate;
+   xcb_connection_t     *c = XGetXCBConnection(priv->base.psc->dpy);
+   struct dri3_buffer      *buffer;
+   int                  buf_id;
+
+   if (buffer_type == dri3_buffer_back) {
+      int back = dri3_find_back(c, priv);
+
+      if (back < 0)
+         return NULL;
+
+      priv->cur_back = back;
+      buf_id = DRI3_BACK_ID(priv->cur_back);
+   } else {
+      buf_id = DRI3_FRONT_ID;
+   }
+
+   buffer = priv->buffers[buf_id];
+
+   /* Allocate a new buffer if there isn't an old one, or if that
+    * old one is the wrong size
+    */
+   if (!buffer || buffer->width != priv->width || buffer->height != priv->height) {
+      struct dri3_buffer   *new_buffer;
+
+      /* Allocate the new buffers
+       */
+      new_buffer = dri3_alloc_render_buffer(priv->base.psc,
+                                            priv->base.xDrawable,
+                                            format, priv->width, priv->height, priv->depth);
+      if (!new_buffer)
+         return NULL;
+
+      /* When resizing, copy the contents of the old buffer, waiting for that
+       * copy to complete using our fences before proceeding
+       */
+      switch (buffer_type) {
+      case dri3_buffer_back:
+         if (buffer) {
+            dri3_fence_reset(c, new_buffer);
+            dri3_fence_await(c, buffer);
+            dri3_copy_area(c,
+                           buffer->pixmap,
+                           new_buffer->pixmap,
+                           dri3_drawable_gc(priv),
+                           0, 0, 0, 0, priv->width, priv->height);
+            dri3_fence_trigger(c, new_buffer);
+            dri3_free_render_buffer(priv, buffer);
+         }
+         break;
+      case dri3_buffer_front:
+         dri3_fence_reset(c, new_buffer);
+         dri3_copy_area(c,
+                        priv->base.xDrawable,
+                        new_buffer->pixmap,
+                        dri3_drawable_gc(priv),
+                        0, 0, 0, 0, priv->width, priv->height);
+         dri3_fence_trigger(c, new_buffer);
+         break;
+      }
+      buffer = new_buffer;
+      buffer->buffer_type = buffer_type;
+      priv->buffers[buf_id] = buffer;
+   }
+   dri3_fence_await(c, buffer);
+
+   /* Return the requested buffer */
+   return buffer;
+}
+
+/** dri3_free_buffers
+ *
+ * Free the front bufffer or all of the back buffers. Used
+ * when the application changes which buffers it needs
+ */
+static void
+dri3_free_buffers(__DRIdrawable *driDrawable,
+                 enum dri3_buffer_type buffer_type,
+                 void *loaderPrivate)
+{
+   struct dri3_drawable *priv = loaderPrivate;
+   struct dri3_buffer      *buffer;
+   int                  first_id;
+   int                  n_id;
+   int                  buf_id;
+
+   switch (buffer_type) {
+   case dri3_buffer_back:
+      first_id = DRI3_BACK_ID(0);
+      n_id = DRI3_MAX_BACK;
+      break;
+   case dri3_buffer_front:
+      first_id = DRI3_FRONT_ID;
+      n_id = 1;
+   }
+
+   for (buf_id = first_id; buf_id < first_id + n_id; buf_id++) {
+      buffer = priv->buffers[buf_id];
+      if (buffer) {
+         dri3_free_render_buffer(priv, buffer);
+         priv->buffers[buf_id] = NULL;
+      }
+   }
+}
+
+/** dri3_get_buffers
+ *
+ * The published buffer allocation API.
+ * Returns all of the necessary buffers, allocating
+ * as needed.
+ */
+static int
+dri3_get_buffers(__DRIdrawable *driDrawable,
+                 unsigned int format,
+                 uint32_t *stamp,
+                 void *loaderPrivate,
+                 uint32_t buffer_mask,
+                 struct __DRIimageList *buffers)
+{
+   struct dri3_drawable *priv = loaderPrivate;
+   struct dri3_buffer   *front, *back;
+
+   buffers->image_mask = 0;
+   buffers->front = NULL;
+   buffers->back = NULL;
+
+   front = NULL;
+   back = NULL;
+
+   if (!dri3_update_drawable(driDrawable, loaderPrivate))
+      return false;
+
+   /* pixmaps always have front buffers */
+   if (priv->is_pixmap)
+      buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;
+
+   if (buffer_mask & __DRI_IMAGE_BUFFER_FRONT) {
+      if (priv->is_pixmap)
+         front = dri3_get_pixmap_buffer(driDrawable,
+                                        format,
+                                        dri3_buffer_front,
+                                        loaderPrivate);
+      else
+         front = dri3_get_buffer(driDrawable,
+                                 format,
+                                 dri3_buffer_front,
+                                 loaderPrivate);
+
+      if (!front)
+         return false;
+   } else {
+      dri3_free_buffers(driDrawable, dri3_buffer_front, loaderPrivate);
+      priv->have_fake_front = 0;
+   }
+
+   if (buffer_mask & __DRI_IMAGE_BUFFER_BACK) {
+      back = dri3_get_buffer(driDrawable,
+                             format,
+                             dri3_buffer_back,
+                             loaderPrivate);
+      if (!back)
+         return false;
+      priv->have_back = 1;
+   } else {
+      dri3_free_buffers(driDrawable, dri3_buffer_back, loaderPrivate);
+      priv->have_back = 0;
+   }
+
+   if (front) {
+      buffers->image_mask |= __DRI_IMAGE_BUFFER_FRONT;
+      buffers->front = front->image;
+      priv->have_fake_front = !priv->is_pixmap;
+   }
+
+   if (back) {
+      buffers->image_mask |= __DRI_IMAGE_BUFFER_BACK;
+      buffers->back = back->image;
+   }
+
+   priv->stamp = stamp;
+
+   return true;
+}
+
+/* The image loader extension record for DRI3
+ */
+static const __DRIimageLoaderExtension imageLoaderExtension = {
+   {__DRI_IMAGE_LOADER, __DRI_IMAGE_LOADER_VERSION},
+   .getBuffers = dri3_get_buffers,
+   .flushFrontBuffer = dri3_flush_front_buffer,
+};
+
+/** dri3_swap_buffers
+ *
+ * Make the current back buffer visible using the present extension
+ */
+static int64_t
+dri3_swap_buffers(__GLXDRIdrawable *pdraw, int64_t target_msc, int64_t divisor,
+                  int64_t remainder, Bool flush)
+{
+   struct dri3_drawable *priv = (struct dri3_drawable *) pdraw;
+   struct dri3_screen *psc = (struct dri3_screen *) priv->base.psc;
+   Display *dpy = priv->base.psc->dpy;
+   xcb_connection_t *c = XGetXCBConnection(dpy);
+   int buf_id = DRI3_BACK_ID(priv->cur_back);
+   int64_t ret = 0;
+
+   unsigned flags = __DRI2_FLUSH_DRAWABLE;
+   if (flush)
+      flags |= __DRI2_FLUSH_CONTEXT;
+   dri3_flush(psc, priv, flags, __DRI2_THROTTLE_SWAPBUFFER);
+
+   dri3_flush_present_events(priv);
+
+   if (priv->buffers[buf_id] && !priv->is_pixmap) {
+      dri3_fence_reset(c, priv->buffers[buf_id]);
+
+      /* Compute when we want the frame shown by taking the last known successful
+       * MSC and adding in a swap interval for each outstanding swap request
+       */
+      ++priv->present_request_serial;
+      if (target_msc == 0)
+         target_msc = priv->msc + priv->swap_interval * (priv->present_request_serial - priv->present_event_serial);
+
+      priv->buffers[buf_id]->busy = 1;
+      xcb_present_pixmap(c,
+                         priv->base.xDrawable,
+                         priv->buffers[buf_id]->pixmap,
+                         priv->present_request_serial,
+                         0,                                    /* valid */
+                         0,                                    /* update */
+                         0,                                    /* x_off */
+                         0,                                    /* y_off */
+                         None,                                 /* target_crtc */
+                         None,
+                         priv->buffers[buf_id]->sync_fence,
+                         XCB_PRESENT_OPTION_NONE,
+                         target_msc,
+                         divisor,
+                         remainder, 0, NULL);
+      ret = ++priv->sbc;
+
+      /* If there's a fake front, then copy the source back buffer
+       * to the fake front to keep it up to date. This needs
+       * to reset the fence and make future users block until
+       * the X server is done copying the bits
+       */
+      if (priv->have_fake_front) {
+         dri3_fence_reset(c, priv->buffers[DRI3_FRONT_ID]);
+         dri3_copy_area(c,
+                        priv->buffers[buf_id]->pixmap,
+                        priv->buffers[DRI3_FRONT_ID]->pixmap,
+                        dri3_drawable_gc(priv),
+                        0, 0, 0, 0, priv->width, priv->height);
+         dri3_fence_trigger(c, priv->buffers[DRI3_FRONT_ID]);
+      }
+      xcb_flush(c);
+      if (priv->stamp)
+         ++(*priv->stamp);
+   }
+
+   return ret;
+}
+
+/** dri3_open
+ *
+ * Wrapper around xcb_dri3_open
+ */
+static int
+dri3_open(Display *dpy,
+          Window root,
+          CARD32 provider)
+{
+   xcb_dri3_open_cookie_t       cookie;
+   xcb_dri3_open_reply_t        *reply;
+   xcb_connection_t             *c = XGetXCBConnection(dpy);
+   xcb_generic_error_t          *error;
+   int                          fd;
+
+   cookie = xcb_dri3_open(c,
+                          root,
+                          provider);
+
+   reply = xcb_dri3_open_reply(c, cookie, &error);
+   if (!reply)
+      return -1;
+
+   if (reply->nfd != 1) {
+      free(reply);
+      return -1;
+   }
+
+   fd = xcb_dri3_open_reply_fds(c, reply)[0];
+   fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+   return fd;
+}
+
+
+/** dri3_destroy_screen
+ */
+static void
+dri3_destroy_screen(struct glx_screen *base)
+{
+   struct dri3_screen *psc = (struct dri3_screen *) base;
+
+   /* Free the direct rendering per screen data */
+   (*psc->core->destroyScreen) (psc->driScreen);
+   driDestroyConfigs(psc->driver_configs);
+   close(psc->fd);
+   free(psc);
+}
+
+/** dri3_set_swap_interval
+ *
+ * Record the application swap interval specification,
+ */
+static int
+dri3_set_swap_interval(__GLXDRIdrawable *pdraw, int interval)
+{
+   struct dri3_drawable *priv =  (struct dri3_drawable *) pdraw;
+   GLint vblank_mode = DRI_CONF_VBLANK_DEF_INTERVAL_1;
+   struct dri3_screen *psc = (struct dri3_screen *) priv->base.psc;
+
+   if (psc->config)
+      psc->config->configQueryi(psc->driScreen,
+                                "vblank_mode", &vblank_mode);
+
+   switch (vblank_mode) {
+   case DRI_CONF_VBLANK_NEVER:
+      if (interval != 0)
+         return GLX_BAD_VALUE;
+      break;
+   case DRI_CONF_VBLANK_ALWAYS_SYNC:
+      if (interval <= 0)
+         return GLX_BAD_VALUE;
+      break;
+   default:
+      break;
+   }
+
+   priv->swap_interval = interval;
+
+   return 0;
+}
+
+/** dri3_get_swap_interval
+ *
+ * Return the stored swap interval
+ */
+static int
+dri3_get_swap_interval(__GLXDRIdrawable *pdraw)
+{
+   struct dri3_drawable *priv =  (struct dri3_drawable *) pdraw;
+
+  return priv->swap_interval;
+}
+
+static void
+dri3_bind_tex_image(Display * dpy,
+                    GLXDrawable drawable,
+                    int buffer, const int *attrib_list)
+{
+   struct glx_context *gc = __glXGetCurrentContext();
+   struct dri3_context *pcp = (struct dri3_context *) gc;
+   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
+   struct dri3_drawable *pdraw = (struct dri3_drawable *) base;
+   struct dri3_screen *psc;
+
+   if (pdraw != NULL) {
+      psc = (struct dri3_screen *) base->psc;
+
+      (*psc->f->invalidate)(pdraw->driDrawable);
+
+      XSync(dpy, false);
+
+      (*psc->texBuffer->setTexBuffer2) (pcp->driContext,
+                                        pdraw->base.textureTarget,
+                                        pdraw->base.textureFormat,
+                                        pdraw->driDrawable);
+   }
+}
+
+static void
+dri3_release_tex_image(Display * dpy, GLXDrawable drawable, int buffer)
+{
+   struct glx_context *gc = __glXGetCurrentContext();
+   struct dri3_context *pcp = (struct dri3_context *) gc;
+   __GLXDRIdrawable *base = GetGLXDRIDrawable(dpy, drawable);
+   struct dri3_drawable *pdraw = (struct dri3_drawable *) base;
+   struct dri3_screen *psc;
+
+   if (pdraw != NULL) {
+      psc = (struct dri3_screen *) base->psc;
+
+      if (psc->texBuffer->releaseTexBuffer)
+         (*psc->texBuffer->releaseTexBuffer) (pcp->driContext,
+                                              pdraw->base.textureTarget,
+                                              pdraw->driDrawable);
+   }
+}
+
+static const struct glx_context_vtable dri3_context_vtable = {
+   dri3_destroy_context,
+   dri3_bind_context,
+   dri3_unbind_context,
+   dri3_wait_gl,
+   dri3_wait_x,
+   DRI_glXUseXFont,
+   dri3_bind_tex_image,
+   dri3_release_tex_image,
+   NULL, /* get_proc_address */
+};
+
+/** dri3_bind_extensions
+ *
+ * Enable all of the extensions supported on DRI3
+ */
+static void
+dri3_bind_extensions(struct dri3_screen *psc, struct glx_display * priv,
+                     const char *driverName)
+{
+   const __DRIextension **extensions;
+   unsigned mask;
+   int i;
+
+   extensions = psc->core->getExtensions(psc->driScreen);
+
+   __glXEnableDirectExtension(&psc->base, "GLX_SGI_video_sync");
+   __glXEnableDirectExtension(&psc->base, "GLX_SGI_swap_control");
+   __glXEnableDirectExtension(&psc->base, "GLX_MESA_swap_control");
+   __glXEnableDirectExtension(&psc->base, "GLX_SGI_make_current_read");
+
+   /*
+    * GLX_INTEL_swap_event is broken on the server side, where it's
+    * currently unconditionally enabled. This completely breaks
+    * systems running on drivers which don't support that extension.
+    * There's no way to test for its presence on this side, so instead
+    * of disabling it unconditionally, just disable it for drivers
+    * which are known to not support it, or for DDX drivers supporting
+    * only an older (pre-ScheduleSwap) version of DRI2.
+    *
+    * This is a hack which is required until:
+    * http://lists.x.org/archives/xorg-devel/2013-February/035449.html
+    * is merged and updated xserver makes it's way into distros:
+    */
+//   if (pdp->swapAvailable && strcmp(driverName, "vmwgfx") != 0) {
+//      __glXEnableDirectExtension(&psc->base, "GLX_INTEL_swap_event");
+//   }
+
+   mask = psc->image_driver->getAPIMask(psc->driScreen);
+
+   __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context");
+   __glXEnableDirectExtension(&psc->base, "GLX_ARB_create_context_profile");
+
+   if ((mask & (1 << __DRI_API_GLES2)) != 0)
+      __glXEnableDirectExtension(&psc->base,
+                                 "GLX_EXT_create_context_es2_profile");
+
+   for (i = 0; extensions[i]; i++) {
+      if ((strcmp(extensions[i]->name, __DRI_TEX_BUFFER) == 0)) {
+         psc->texBuffer = (__DRItexBufferExtension *) extensions[i];
+         __glXEnableDirectExtension(&psc->base, "GLX_EXT_texture_from_pixmap");
+      }
+
+      if ((strcmp(extensions[i]->name, __DRI2_FLUSH) == 0)) {
+         psc->f = (__DRI2flushExtension *) extensions[i];
+         /* internal driver extension, no GL extension exposed */
+      }
+
+      if ((strcmp(extensions[i]->name, __DRI2_CONFIG_QUERY) == 0))
+         psc->config = (__DRI2configQueryExtension *) extensions[i];
+
+      if (strcmp(extensions[i]->name, __DRI2_ROBUSTNESS) == 0)
+         __glXEnableDirectExtension(&psc->base,
+                                    "GLX_ARB_create_context_robustness");
+   }
+}
+
+static const struct glx_screen_vtable dri3_screen_vtable = {
+   dri3_create_context,
+   dri3_create_context_attribs
+};
+
+/** dri3_create_screen
+ *
+ * Initialize DRI3 on the specified screen.
+ *
+ * Opens the DRI device, locates the appropriate DRI driver
+ * and loads that.
+ *
+ * Checks to see if the driver supports the necessary extensions
+ *
+ * Initializes the driver for the screen and sets up our structures
+ */
+
+static struct glx_screen *
+dri3_create_screen(int screen, struct glx_display * priv)
+{
+   xcb_connection_t *c = XGetXCBConnection(priv->dpy);
+   const __DRIconfig **driver_configs;
+   const __DRIextension **extensions;
+   const struct dri3_display *const pdp = (struct dri3_display *)
+      priv->dri3Display;
+   struct dri3_screen *psc;
+   __GLXDRIscreen *psp;
+   struct glx_config *configs = NULL, *visuals = NULL;
+   char *driverName, *deviceName;
+   int i;
+
+   psc = calloc(1, sizeof *psc);
+   if (psc == NULL)
+      return NULL;
+
+   psc->fd = -1;
+
+   if (!glx_screen_init(&psc->base, screen, priv)) {
+      free(psc);
+      return NULL;
+   }
+
+   psc->fd = dri3_open(priv->dpy, RootWindow(priv->dpy, screen), None);
+   if (psc->fd < 0) {
+      int conn_error = xcb_connection_has_error(c);
+
+      glx_screen_cleanup(&psc->base);
+      free(psc);
+      InfoMessageF("screen %d does not appear to be DRI3 capable\n", screen);
+
+      if (conn_error)
+         ErrorMessageF("Connection closed during DRI3 initialization failure");
+
+      return NULL;
+   }
+   deviceName = NULL;
+
+   driverName = dri3_get_driver_for_fd(psc->fd);
+   if (!driverName) {
+      ErrorMessageF("No driver found\n");
+      goto handle_error;
+   }
+
+   psc->driver = driOpenDriver(driverName);
+   if (psc->driver == NULL) {
+      ErrorMessageF("driver pointer missing\n");
+      goto handle_error;
+   }
+
+   extensions = driGetDriverExtensions(psc->driver, driverName);
+   if (extensions == NULL)
+      goto handle_error;
+
+   for (i = 0; extensions[i]; i++) {
+      if (strcmp(extensions[i]->name, __DRI_CORE) == 0)
+         psc->core = (__DRIcoreExtension *) extensions[i];
+      if (strcmp(extensions[i]->name, __DRI_IMAGE_DRIVER) == 0)
+         psc->image_driver = (__DRIimageDriverExtension *) extensions[i];
+   }
+
+
+   if (psc->core == NULL) {
+      ErrorMessageF("core dri driver extension not found\n");
+      goto handle_error;
+   }
+
+   if (psc->image_driver == NULL) {
+      ErrorMessageF("image driver extension not found\n");
+      goto handle_error;
+   }
+
+   psc->driScreen =
+      psc->image_driver->createNewScreen2(screen, psc->fd,
+                                          (const __DRIextension **)
+                                          &pdp->loader_extensions[0],
+                                          extensions,
+                                          &driver_configs, psc);
+
+   if (psc->driScreen == NULL) {
+      ErrorMessageF("failed to create dri screen\n");
+      goto handle_error;
+   }
+
+   extensions = (*psc->core->getExtensions)(psc->driScreen);
+
+   for (i = 0; extensions[i]; i++) {
+      if (strcmp(extensions[i]->name, __DRI_IMAGE) == 0)
+         psc->image = (__DRIimageExtension *) extensions[i];
+   }
+
+   if (psc->image == NULL) {
+      ErrorMessageF("image extension not found\n");
+      goto handle_error;
+   }
+
+   dri3_bind_extensions(psc, priv, driverName);
+
+   if (!psc->f || psc->f->base.version < 4) {
+      ErrorMessageF("Version 4 or later of flush extension not found\n");
+      goto handle_error;
+   }
+
+   if (!psc->texBuffer || psc->texBuffer->base.version < 2 ||
+       !psc->texBuffer->setTexBuffer2)
+   {
+      ErrorMessageF("Version 2 or later of texBuffer extension not found\n");
+      goto handle_error;
+   }
+
+   configs = driConvertConfigs(psc->core, psc->base.configs, driver_configs);
+   visuals = driConvertConfigs(psc->core, psc->base.visuals, driver_configs);
+
+   if (!configs || !visuals)
+       goto handle_error;
+
+   glx_config_destroy_list(psc->base.configs);
+   psc->base.configs = configs;
+   glx_config_destroy_list(psc->base.visuals);
+   psc->base.visuals = visuals;
+
+   psc->driver_configs = driver_configs;
+
+   psc->base.vtable = &dri3_screen_vtable;
+   psp = &psc->vtable;
+   psc->base.driScreen = psp;
+   psp->destroyScreen = dri3_destroy_screen;
+   psp->createDrawable = dri3_create_drawable;
+   psp->swapBuffers = dri3_swap_buffers;
+
+   psp->getDrawableMSC = dri3_drawable_get_msc;
+   psp->waitForMSC = dri3_wait_for_msc;
+   psp->waitForSBC = dri3_wait_for_sbc;
+   psp->setSwapInterval = dri3_set_swap_interval;
+   psp->getSwapInterval = dri3_get_swap_interval;
+   __glXEnableDirectExtension(&psc->base, "GLX_OML_sync_control");
+
+   psp->copySubBuffer = dri3_copy_sub_buffer;
+   __glXEnableDirectExtension(&psc->base, "GLX_MESA_copy_sub_buffer");
+
+   free(driverName);
+   free(deviceName);
+
+   return &psc->base;
+
+handle_error:
+   CriticalErrorMessageF("failed to load driver: %s\n", driverName);
+
+   if (configs)
+       glx_config_destroy_list(configs);
+   if (visuals)
+       glx_config_destroy_list(visuals);
+   if (psc->driScreen)
+       psc->core->destroyScreen(psc->driScreen);
+   psc->driScreen = NULL;
+   if (psc->fd >= 0)
+      close(psc->fd);
+   if (psc->driver)
+      dlclose(psc->driver);
+
+   free(driverName);
+   free(deviceName);
+   glx_screen_cleanup(&psc->base);
+   free(psc);
+
+   return NULL;
+}
+
+/** dri_destroy_display
+ *
+ * Called from __glXFreeDisplayPrivate.
+ */
+static void
+dri3_destroy_display(__GLXDRIdisplay * dpy)
+{
+   free(dpy);
+}
+
+/** dri3_create_display
+ *
+ * Allocate, initialize and return a __DRIdisplayPrivate object.
+ * This is called from __glXInitialize() when we are given a new
+ * display pointer. This is public to that function, but hidden from
+ * outside of libGL.
+ */
+_X_HIDDEN __GLXDRIdisplay *
+dri3_create_display(Display * dpy)
+{
+   struct dri3_display                  *pdp;
+   int                                  i;
+   xcb_connection_t                     *c = XGetXCBConnection(dpy);
+   xcb_dri3_query_version_cookie_t      dri3_cookie;
+   xcb_dri3_query_version_reply_t       *dri3_reply;
+   xcb_present_query_version_cookie_t   present_cookie;
+   xcb_present_query_version_reply_t    *present_reply;
+   xcb_generic_error_t                  *error;
+   const xcb_query_extension_reply_t    *extension;
+
+   xcb_prefetch_extension_data(c, &xcb_dri3_id);
+   xcb_prefetch_extension_data(c, &xcb_present_id);
+
+   extension = xcb_get_extension_data(c, &xcb_dri3_id);
+   if (!(extension && extension->present))
+      return NULL;
+
+   extension = xcb_get_extension_data(c, &xcb_present_id);
+   if (!(extension && extension->present))
+      return NULL;
+
+   dri3_cookie = xcb_dri3_query_version(c,
+                                        XCB_DRI3_MAJOR_VERSION,
+                                        XCB_DRI3_MINOR_VERSION);
+
+
+   present_cookie = xcb_present_query_version(c,
+                                   XCB_PRESENT_MAJOR_VERSION,
+                                   XCB_PRESENT_MINOR_VERSION);
+
+   pdp = malloc(sizeof *pdp);
+   if (pdp == NULL)
+      return NULL;
+
+   dri3_reply = xcb_dri3_query_version_reply(c, dri3_cookie, &error);
+   if (!dri3_reply) {
+      free(error);
+      goto no_extension;
+   }
+
+   pdp->dri3Major = dri3_reply->major_version;
+   pdp->dri3Minor = dri3_reply->minor_version;
+   free(dri3_reply);
+
+   present_reply = xcb_present_query_version_reply(c, present_cookie, &error);
+   if (!present_reply) {
+      free(error);
+      goto no_extension;
+   }
+   pdp->presentMajor = present_reply->major_version;
+   pdp->presentMinor = present_reply->minor_version;
+
+   pdp->base.destroyDisplay = dri3_destroy_display;
+   pdp->base.createScreen = dri3_create_screen;
+
+   i = 0;
+
+   pdp->loader_extensions[i++] = &imageLoaderExtension.base;
+
+   pdp->loader_extensions[i++] = &systemTimeExtension.base;
+
+   pdp->loader_extensions[i++] = NULL;
+
+   return &pdp->base;
+no_extension:
+   free(pdp);
+   return NULL;
+}
+
+#endif /* GLX_DIRECT_RENDERING */
diff --git a/src/glx/dri3_priv.h b/src/glx/dri3_priv.h
new file mode 100644
index 0000000..c892800
--- /dev/null
+++ b/src/glx/dri3_priv.h
@@ -0,0 +1,209 @@
+/*
+ * Copyright © 2013 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+/* This file was derived from dri2_priv.h which carries the following
+ * copyright:
+ *
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#include <xcb/xcb.h>
+#include <xcb/dri3.h>
+#include <xcb/present.h>
+#include <xcb/sync.h>
+
+/* From xmlpool/options.h, user exposed so should be stable */
+#define DRI_CONF_VBLANK_NEVER 0
+#define DRI_CONF_VBLANK_DEF_INTERVAL_0 1
+#define DRI_CONF_VBLANK_DEF_INTERVAL_1 2
+#define DRI_CONF_VBLANK_ALWAYS_SYNC 3
+
+enum dri3_buffer_type {
+   dri3_buffer_back = 0,
+   dri3_buffer_front = 1
+};
+
+struct dri3_buffer {
+   __DRIimage   *image;
+   uint32_t     pixmap;
+
+   /* Synchronization between the client and X server is done using an
+    * xshmfence that is mapped into an X server SyncFence. This lets the
+    * client check whether the X server is done using a buffer with a simple
+    * xshmfence call, rather than going to read X events from the wire.
+    *
+    * However, we can only wait for one xshmfence to be triggered at a time,
+    * so we need to know *which* buffer is going to be idle next. We do that
+    * by waiting for a PresentIdleNotify event. When that event arrives, the
+    * 'busy' flag gets cleared and the client knows that the fence has been
+    * triggered, and that the wait call will not block.
+    */
+
+   uint32_t     sync_fence;     /* XID of X SyncFence object */
+   int32_t      *shm_fence;     /* pointer to xshmfence object */
+   GLboolean    busy;           /* Set on swap, cleared on IdleNotify */
+   void         *driverPrivate;
+
+   uint32_t     size;
+   uint32_t     pitch;
+   uint32_t     cpp;
+   uint32_t     flags;
+   uint32_t     width, height;
+
+   enum dri3_buffer_type        buffer_type;
+};
+
+struct dri3_display
+{
+   __GLXDRIdisplay base;
+
+   const __DRIextension *loader_extensions[8];
+
+   /* DRI3 bits */
+   int dri3Major;
+   int dri3Minor;
+
+   /* Present bits */
+   int hasPresent;
+   int presentMajor;
+   int presentMinor;
+};
+
+struct dri3_screen {
+   struct glx_screen base;
+
+   __DRIscreen *driScreen;
+   __GLXDRIscreen vtable;
+
+   const __DRIimageExtension *image;
+   const __DRIimageDriverExtension *image_driver;
+   const __DRIcoreExtension *core;
+   const __DRI2flushExtension *f;
+   const __DRI2configQueryExtension *config;
+   const __DRItexBufferExtension *texBuffer;
+   const __DRIconfig **driver_configs;
+
+   void *driver;
+   int fd;
+
+   Bool show_fps;
+};
+
+struct dri3_context
+{
+   struct glx_context base;
+   __DRIcontext *driContext;
+};
+
+#define DRI3_MAX_BACK   2
+#define DRI3_BACK_ID(i) (i)
+#define DRI3_FRONT_ID   (DRI3_MAX_BACK)
+
+static inline int
+dri3_buf_id_next(int buf_id)
+{
+   if (buf_id == DRI3_MAX_BACK - 1)
+      return 0;
+   return buf_id + 1;
+}
+
+static inline int
+dri3_buf_id_prev(int buf_id)
+{
+   if (buf_id == 0)
+      return DRI3_MAX_BACK - 1;
+   return buf_id - 1;
+}
+
+static inline int
+dri3_pixmap_buf_id(enum dri3_buffer_type buffer_type)
+{
+   if (buffer_type == dri3_buffer_back)
+      return DRI3_BACK_ID(0);
+   else
+      return DRI3_FRONT_ID;
+}
+
+struct dri3_drawable {
+   __GLXDRIdrawable base;
+   __DRIdrawable *driDrawable;
+   int width, height;
+   int swap_interval;
+   uint8_t have_back;
+   uint8_t have_fake_front;
+   uint8_t is_pixmap;
+
+   uint32_t present_request_serial;
+   uint32_t present_event_serial;
+
+   uint64_t sbc;
+
+   uint64_t ust, msc;
+
+   /* For WaitMSC */
+   uint32_t present_msc_request_serial;
+   uint32_t present_msc_event_serial;
+   
+   uint64_t previous_time;
+   unsigned frames;
+
+   struct dri3_buffer *buffers[1 + DRI3_MAX_BACK];
+   int cur_back;
+   int depth;
+
+   uint32_t *stamp;
+
+   xcb_present_event_t eid;
+   xcb_gcontext_t gc;
+   xcb_special_event_t *special_event;
+};
+
+char *
+dri3_get_driver_for_fd(int fd);
diff --git a/src/glx/glxclient.h b/src/glx/glxclient.h
index 81ae792..e33dba6 100644
--- a/src/glx/glxclient.h
+++ b/src/glx/glxclient.h
@@ -150,6 +150,7 @@ extern __GLXDRIdisplay *dri2CreateDisplay(Display * dpy);
 extern void dri2InvalidateBuffers(Display *dpy, XID drawable);
 extern unsigned dri2GetSwapEventType(Display *dpy, XID drawable);
 
+extern __GLXDRIdisplay *dri3_create_display(Display * dpy);
 
 /*
 ** Functions to obtain driver configuration information from a direct
@@ -474,7 +475,12 @@ struct glx_screen_vtable {
 						 unsigned num_attrib,
 						 const uint32_t *attribs,
 						 unsigned *error);
-
+   int (*query_renderer_integer)(struct glx_screen *psc,
+                                 int attribute,
+                                 unsigned int *value);
+   int (*query_renderer_string)(struct glx_screen *psc,
+                                int attribute,
+                                const char **value);
 };
 
 struct glx_screen
@@ -582,6 +588,7 @@ struct glx_display
    __GLXDRIdisplay *driswDisplay;
    __GLXDRIdisplay *driDisplay;
    __GLXDRIdisplay *dri2Display;
+   __GLXDRIdisplay *dri3Display;
 #endif
 };
 
diff --git a/src/glx/glxcmds.c b/src/glx/glxcmds.c
index 3b250cc..1d8fe83 100644
--- a/src/glx/glxcmds.c
+++ b/src/glx/glxcmds.c
@@ -2603,6 +2603,12 @@ static const struct name_address_pair GLX_functions[] = {
    /*** GLX_ARB_create_context and GLX_ARB_create_context_profile ***/
    GLX_FUNCTION(glXCreateContextAttribsARB),
 
+   /*** GLX_MESA_query_renderer ***/
+   GLX_FUNCTION(glXQueryRendererIntegerMESA),
+   GLX_FUNCTION(glXQueryRendererStringMESA),
+   GLX_FUNCTION(glXQueryCurrentRendererIntegerMESA),
+   GLX_FUNCTION(glXQueryCurrentRendererStringMESA),
+
    {NULL, NULL}                 /* end of list */
 };
 
diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index bea1ccb..2711e57 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -770,7 +770,11 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
    for (i = 0; i < screens; i++, psc++) {
       psc = NULL;
 #if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
-      if (priv->dri2Display)
+#if defined(HAVE_DRI3)
+      if (priv->dri3Display)
+         psc = (*priv->dri3Display->createScreen) (i, priv);
+#endif
+      if (psc == NULL && priv->dri2Display)
 	 psc = (*priv->dri2Display->createScreen) (i, priv);
       if (psc == NULL && priv->driDisplay)
 	 psc = (*priv->driDisplay->createScreen) (i, priv);
@@ -863,6 +867,10 @@ __glXInitialize(Display * dpy)
     ** (e.g., those called in AllocAndFetchScreenConfigs).
     */
    if (glx_direct && glx_accel) {
+#if defined(HAVE_DRI3)
+      if (!getenv("LIBGL_DRI3_DISABLE"))
+         dpyPriv->dri3Display = dri3_create_display(dpy);
+#endif
       dpyPriv->dri2Display = dri2CreateDisplay(dpy);
       dpyPriv->driDisplay = driCreateDisplay(dpy);
    }
diff --git a/src/glx/glxextensions.c b/src/glx/glxextensions.c
index 7b00a9e..f186c13 100644
--- a/src/glx/glxextensions.c
+++ b/src/glx/glxextensions.c
@@ -87,6 +87,7 @@ static const struct extension_info known_glx_extensions[] = {
    { GLX(EXT_create_context_es2_profile), VER(0,0), Y, N, N, Y },
    { GLX(MESA_copy_sub_buffer),        VER(0,0), Y, N, N, N },
    { GLX(MESA_multithread_makecurrent),VER(0,0), Y, N, Y, N },
+   { GLX(MESA_query_renderer),         VER(0,0), Y, N, N, Y },
    { GLX(MESA_swap_control),           VER(0,0), Y, N, N, Y },
    { GLX(NV_float_buffer),             VER(0,0), N, N, N, N },
    { GLX(OML_swap_method),             VER(0,0), Y, Y, N, N },
diff --git a/src/glx/glxextensions.h b/src/glx/glxextensions.h
index 0ca50a6..8436a94 100644
--- a/src/glx/glxextensions.h
+++ b/src/glx/glxextensions.h
@@ -49,6 +49,7 @@ enum
    MESA_copy_sub_buffer_bit,
    MESA_depth_float_bit,
    MESA_multithread_makecurrent_bit,
+   MESA_query_renderer_bit,
    MESA_swap_control_bit,
    MESA_swap_frame_usage_bit,
    NV_float_buffer_bit,
diff --git a/src/glx/query_renderer.c b/src/glx/query_renderer.c
new file mode 100644
index 0000000..9108ec2
--- /dev/null
+++ b/src/glx/query_renderer.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "glxclient.h"
+#include "glx_error.h"
+
+#include <assert.h>
+
+static Bool
+__glXQueryRendererInteger(struct glx_screen *psc, int attribute,
+                          unsigned int *value)
+{
+   unsigned int values_for_query = 0;
+   unsigned int buffer[32];
+   int err;
+
+   /* This probably means the caller is trying to use an extension function
+    * that isn't actually supported.
+    */
+   if (psc->vtable->query_renderer_integer == NULL)
+      return False;
+
+   switch (attribute) {
+   case GLX_RENDERER_VENDOR_ID_MESA:
+   case GLX_RENDERER_DEVICE_ID_MESA:
+      values_for_query = 1;
+      break;
+   case GLX_RENDERER_VERSION_MESA:
+      values_for_query = 3;
+      break;
+   case GLX_RENDERER_ACCELERATED_MESA:
+   case GLX_RENDERER_VIDEO_MEMORY_MESA:
+   case GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA:
+   case GLX_RENDERER_PREFERRED_PROFILE_MESA:
+      values_for_query = 1;
+      break;
+   case GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA:
+   case GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA:
+   case GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA:
+   case GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA:
+      values_for_query = 2;
+      break;
+
+   default:
+      return False;
+   }
+
+   err = psc->vtable->query_renderer_integer(psc, attribute, buffer);
+
+   /* If there was no error, copy the correct number of values from the driver
+    * out to the application.
+    */
+   if (err == 0)
+      memcpy(value, buffer, sizeof(unsigned int) * values_for_query);
+
+   return err == 0;
+}
+
+_X_HIDDEN Bool
+glXQueryRendererIntegerMESA(Display *dpy, int screen,
+                            int renderer, int attribute,
+                            unsigned int *value)
+{
+   struct glx_screen *psc;
+
+   if (dpy == NULL)
+      return False;
+
+   /* This probably means the caller passed the wrong display pointer or
+    * screen number.
+    */
+   psc = GetGLXScreenConfigs(dpy, screen);
+   if (psc == NULL)
+      return False;
+
+   /* Right now only a single renderer per display / screen combination is
+    * supported.
+    */
+   if (renderer != 0)
+      return False;
+
+   return __glXQueryRendererInteger(psc, attribute, value);
+}
+
+_X_HIDDEN Bool
+glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *value)
+{
+   struct glx_context *gc = __glXGetCurrentContext();
+
+   if (gc == NULL)
+      return False;
+
+   return __glXQueryRendererInteger(gc->psc, attribute, value);
+}
+
+static const char *
+__glXQueryRendererString(struct glx_screen *psc, int attribute)
+{
+   const char *value;
+   int err;
+
+   /* This probably means the caller is trying to use an extension function
+    * that isn't actually supported.
+    */
+   if (psc->vtable->query_renderer_integer == NULL)
+      return NULL;
+
+   switch (attribute) {
+   case GLX_RENDERER_VENDOR_ID_MESA:
+   case GLX_RENDERER_DEVICE_ID_MESA:
+      break;
+   default:
+      return NULL;
+   }
+
+   err = psc->vtable->query_renderer_string(psc, attribute, &value);
+   return (err == 0) ? value : NULL;
+}
+
+_X_HIDDEN const char *
+glXQueryRendererStringMESA(Display *dpy, int screen,
+                           int renderer, int attribute)
+{
+   struct glx_screen *psc;
+
+   if (dpy == NULL)
+      return False;
+
+   /* This probably means the caller passed the wrong display pointer or
+    * screen number.
+    */
+   psc = GetGLXScreenConfigs(dpy, screen);
+   if (psc == NULL)
+      return False;
+
+   /* Right now only a single renderer per display / screen combination is
+    * supported.
+    */
+   if (renderer != 0)
+      return False;
+
+   return __glXQueryRendererString(psc, attribute);
+}
+
+_X_HIDDEN const char *
+glXQueryCurrentRendererStringMESA(int attribute)
+{
+   struct glx_context *gc = __glXGetCurrentContext();
+
+   if (gc == NULL)
+      return False;
+
+   return __glXQueryRendererString(gc->psc, attribute);
+}
diff --git a/src/glx/tests/Makefile.am b/src/glx/tests/Makefile.am
index d940712..4dc358c 100644
--- a/src/glx/tests/Makefile.am
+++ b/src/glx/tests/Makefile.am
@@ -6,6 +6,9 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/mesa \
 	-I$(top_srcdir)/src/glx \
 	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/include/GL/internal \
+	$(DEFINES) \
+	$(LIBDRM_CFLAGS) \
 	$(X11_CFLAGS)
 
 TESTS = glx-test
@@ -16,7 +19,9 @@ glx_test_SOURCES =			\
 	create_context_unittest.cpp	\
 	enum_sizes.cpp			\
 	fake_glx_screen.cpp		\
-	indirect_api.cpp
+	indirect_api.cpp		\
+	query_renderer_implementation_unittest.cpp	\
+	query_renderer_unittest.cpp
 
 glx_test_LDADD = \
 	$(top_builddir)/src/glx/libglx.la \
diff --git a/src/glx/tests/create_context_unittest.cpp b/src/glx/tests/create_context_unittest.cpp
index fb3e944..819b0b2 100644
--- a/src/glx/tests/create_context_unittest.cpp
+++ b/src/glx/tests/create_context_unittest.cpp
@@ -54,11 +54,15 @@ glx_context_init(struct glx_context *gc,
    return GL_TRUE;
 }
 
+bool GetGLXScreenConfigs_called = false;
+
 extern "C" struct glx_screen *
 GetGLXScreenConfigs(Display * dpy, int scrn)
 {
    (void) dpy;
    (void) scrn;
+
+   GetGLXScreenConfigs_called = true;
    return psc;
 }
 
diff --git a/src/glx/tests/fake_glx_screen.cpp b/src/glx/tests/fake_glx_screen.cpp
index 845084f..815330a 100644
--- a/src/glx/tests/fake_glx_screen.cpp
+++ b/src/glx/tests/fake_glx_screen.cpp
@@ -24,12 +24,16 @@
 
 struct glx_screen_vtable fake_glx_screen::vt = {
    indirect_create_context,
-   indirect_create_context_attribs
+   indirect_create_context_attribs,
+   NULL,
+   NULL,
 };
 
 struct glx_screen_vtable fake_glx_screen_direct::vt = {
    fake_glx_context_direct::create,
-   fake_glx_context_direct::create_attribs
+   fake_glx_context_direct::create_attribs,
+   NULL,
+   NULL,
 };
 
 const struct glx_context_vtable fake_glx_context::vt = {
@@ -70,3 +74,5 @@ indirect_create_context_attribs(struct glx_screen *base,
 
    return indirect_create_context(base, config_base, shareList, 0);
 }
+
+__thread void *__glX_tls_Context = NULL;
diff --git a/src/glx/tests/query_renderer_implementation_unittest.cpp b/src/glx/tests/query_renderer_implementation_unittest.cpp
new file mode 100644
index 0000000..4749089
--- /dev/null
+++ b/src/glx/tests/query_renderer_implementation_unittest.cpp
@@ -0,0 +1,310 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include <gtest/gtest.h>
+#include <signal.h>
+#include <setjmp.h>
+
+extern "C" {
+#include "glxclient.h"
+#include "glx_error.h"
+#include "xf86drm.h"
+#include "dri2.h"
+#include "dri_interface.h"
+#include "dri2_priv.h"
+}
+
+struct attribute_test_vector {
+   const char *glx_string;
+   const char *dri_string;
+   int glx_attribute;
+   int dri_attribute;
+};
+
+#define E(g, d) { # g, # d, g, d }
+
+static bool got_sigsegv;
+static jmp_buf jmp;
+
+static void
+sigsegv_handler(int sig)
+{
+   (void) sig;
+   got_sigsegv = true;
+   longjmp(jmp, 1);
+}
+
+class dri2_query_renderer_string_test : public ::testing::Test {
+public:
+   virtual void SetUp();
+   virtual void TearDown();
+
+   struct sigaction sa;
+   struct sigaction old_sa;
+};
+
+class dri2_query_renderer_integer_test :
+   public dri2_query_renderer_string_test {
+};
+
+static bool queryString_called = false;
+static int queryString_attribute = -1;
+
+static bool queryInteger_called = false;
+static int queryInteger_attribute = -1;
+
+static int
+fake_queryInteger(__DRIscreen *screen, int attribute, unsigned int *val)
+{
+   (void) screen;
+
+   queryInteger_attribute = attribute;
+   queryInteger_called = true;
+
+   switch (attribute) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      *val = ~__DRI2_RENDERER_VENDOR_ID;
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      *val = ~__DRI2_RENDERER_DEVICE_ID;
+      return 0;
+   case __DRI2_RENDERER_VERSION:
+      *val = ~__DRI2_RENDERER_VERSION;
+      return 0;
+   case __DRI2_RENDERER_ACCELERATED:
+      *val = ~__DRI2_RENDERER_ACCELERATED;
+      return 0;
+   case __DRI2_RENDERER_VIDEO_MEMORY:
+      *val = ~__DRI2_RENDERER_VIDEO_MEMORY;
+      return 0;
+   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
+      *val = ~__DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE;
+      return 0;
+   case __DRI2_RENDERER_PREFERRED_PROFILE:
+      *val = ~__DRI2_RENDERER_PREFERRED_PROFILE;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION:
+      *val = ~__DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION:
+      *val = ~__DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION:
+      *val = ~__DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION:
+      *val = ~__DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION;
+      return 0;
+   }
+
+   return -1;
+}
+
+static int
+fake_queryString(__DRIscreen *screen, int attribute, const char **val)
+{
+   (void) screen;
+
+   queryString_attribute = attribute;
+   queryString_called = true;
+
+   switch (attribute) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      *val = "__DRI2_RENDERER_VENDOR_ID";
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      *val = "__DRI2_RENDERER_DEVICE_ID";
+      return 0;
+   }
+
+   return -1;
+}
+
+struct __DRI2rendererQueryExtensionRec rendererQueryExt = {
+   { __DRI2_RENDERER_QUERY, 1 },
+
+   fake_queryInteger,
+   fake_queryString
+};
+
+void dri2_query_renderer_string_test::SetUp()
+{
+   got_sigsegv = false;
+
+   sa.sa_handler = sigsegv_handler;
+   sigemptyset(&sa.sa_mask);
+   sa.sa_flags = 0;
+   sigaction(SIGSEGV, &sa, &old_sa);
+}
+
+void dri2_query_renderer_string_test::TearDown()
+{
+   sigaction(SIGSEGV, &old_sa, NULL);
+}
+
+/**
+ * dri2_query_renderer_string will return an error if the rendererQuery
+ * extension is not present.  It will also not segfault.
+ */
+TEST_F(dri2_query_renderer_string_test, DRI2_RENDERER_QUERY_not_supported)
+{
+   struct dri2_screen dsc;
+
+   memset(&dsc, 0, sizeof(dsc));
+
+   if (setjmp(jmp) == 0) {
+      static const char original_value[] = "0xDEADBEEF";
+      const char *value = original_value;
+      const int success =
+         dri2_query_renderer_string(&dsc.base,
+                                    GLX_RENDERER_VENDOR_ID_MESA, &value);
+
+      EXPECT_EQ(-1, success);
+      EXPECT_EQ(original_value, value);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * dri2_query_renderer_string will call queryString with the correct DRI2 enum
+ * for each GLX attribute value.
+ *
+ * \note
+ * This test does \b not perform any checking for invalid GLX attribte values.
+ * Other unit tests verify that invalid values are filtered before
+ * dri2_query_renderer_string is called.
+ */
+TEST_F(dri2_query_renderer_string_test, valid_attribute_mapping)
+{
+   struct dri2_screen dsc;
+   struct attribute_test_vector valid_attributes[] = {
+      E(GLX_RENDERER_VENDOR_ID_MESA,
+        __DRI2_RENDERER_VENDOR_ID),
+      E(GLX_RENDERER_DEVICE_ID_MESA,
+        __DRI2_RENDERER_DEVICE_ID),
+   };
+
+   memset(&dsc, 0, sizeof(dsc));
+   dsc.rendererQuery = &rendererQueryExt;
+
+   if (setjmp(jmp) == 0) {
+      for (unsigned i = 0; i < ARRAY_SIZE(valid_attributes); i++) {
+         static const char original_value[] = "original value";
+         const char *value = original_value;
+         const int success =
+            dri2_query_renderer_string(&dsc.base,
+                                       valid_attributes[i].glx_attribute,
+                                       &value);
+
+         EXPECT_EQ(0, success);
+         EXPECT_EQ(valid_attributes[i].dri_attribute, queryString_attribute)
+            << valid_attributes[i].glx_string;
+         EXPECT_STREQ(valid_attributes[i].dri_string, value)
+            << valid_attributes[i].glx_string;
+      }
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * dri2_query_renderer_integer will return an error if the rendererQuery
+ * extension is not present.  It will also not segfault.
+ */
+TEST_F(dri2_query_renderer_integer_test, DRI2_RENDERER_QUERY_not_supported)
+{
+   struct dri2_screen dsc;
+
+   memset(&dsc, 0, sizeof(dsc));
+
+   if (setjmp(jmp) == 0) {
+      unsigned int value = 0xDEADBEEF;
+      const int success =
+         dri2_query_renderer_integer(&dsc.base,
+                                    GLX_RENDERER_VENDOR_ID_MESA, &value);
+
+      EXPECT_EQ(-1, success);
+      EXPECT_EQ(0xDEADBEEF, value);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * dri2_query_renderer_integer will call queryInteger with the correct DRI2 enum
+ * for each GLX attribute value.
+ *
+ * \note
+ * This test does \b not perform any checking for invalid GLX attribte values.
+ * Other unit tests verify that invalid values are filtered before
+ * dri2_query_renderer_integer is called.
+ */
+TEST_F(dri2_query_renderer_integer_test, valid_attribute_mapping)
+{
+   struct dri2_screen dsc;
+   struct attribute_test_vector valid_attributes[] = {
+      E(GLX_RENDERER_VENDOR_ID_MESA,
+        __DRI2_RENDERER_VENDOR_ID),
+      E(GLX_RENDERER_DEVICE_ID_MESA,
+        __DRI2_RENDERER_DEVICE_ID),
+      E(GLX_RENDERER_VERSION_MESA,
+        __DRI2_RENDERER_VERSION),
+      E(GLX_RENDERER_ACCELERATED_MESA,
+        __DRI2_RENDERER_ACCELERATED),
+      E(GLX_RENDERER_VIDEO_MEMORY_MESA,
+        __DRI2_RENDERER_VIDEO_MEMORY),
+      E(GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA,
+        __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE),
+      E(GLX_RENDERER_PREFERRED_PROFILE_MESA,
+        __DRI2_RENDERER_PREFERRED_PROFILE),
+      E(GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA,
+        __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION),
+      E(GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA,
+        __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION),
+      E(GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA,
+        __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION),
+      E(GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA,
+        __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION),
+   };
+
+   memset(&dsc, 0, sizeof(dsc));
+   dsc.rendererQuery = &rendererQueryExt;
+
+   if (setjmp(jmp) == 0) {
+      for (unsigned i = 0; i < ARRAY_SIZE(valid_attributes); i++) {
+         unsigned int value = 0xDEADBEEF;
+         const int success =
+            dri2_query_renderer_integer(&dsc.base,
+                                       valid_attributes[i].glx_attribute,
+                                       &value);
+
+         EXPECT_EQ(0, success);
+         EXPECT_EQ(valid_attributes[i].dri_attribute, queryInteger_attribute)
+            << valid_attributes[i].glx_string;
+         EXPECT_EQ((unsigned int) ~valid_attributes[i].dri_attribute, value)
+            << valid_attributes[i].glx_string;
+      }
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
diff --git a/src/glx/tests/query_renderer_unittest.cpp b/src/glx/tests/query_renderer_unittest.cpp
new file mode 100644
index 0000000..2f3c4ef
--- /dev/null
+++ b/src/glx/tests/query_renderer_unittest.cpp
@@ -0,0 +1,440 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include <gtest/gtest.h>
+#include <signal.h>
+#include <setjmp.h>
+
+extern "C" {
+#include "glxclient.h"
+#include "glx_error.h"
+}
+
+extern bool GetGLXScreenConfigs_called;
+extern struct glx_screen *psc;
+
+struct attribute_test_vector {
+   const char *string;
+   int value;
+};
+
+#define E(x) { # x, x }
+
+
+
+static bool got_sigsegv;
+static jmp_buf jmp;
+
+static void
+sigsegv_handler(int sig)
+{
+   (void) sig;
+   got_sigsegv = true;
+   longjmp(jmp, 1);
+}
+
+static bool query_renderer_string_called = false;
+static bool query_renderer_integer_called = false;
+
+static int
+fake_query_renderer_integer(struct glx_screen *psc, int attribute,
+                            unsigned int *value)
+{
+   (void) psc;
+   (void) attribute;
+   (void) value;
+
+   query_renderer_integer_called = true;
+
+   return -1;
+}
+
+static int
+fake_query_renderer_string(struct glx_screen *psc, int attribute,
+                           const char **value)
+{
+   (void) psc;
+   (void) attribute;
+   (void) value;
+
+   query_renderer_string_called = true;
+
+   return -1;
+}
+
+struct glx_screen_vtable fake_vtable = {
+   NULL,
+   NULL,
+   fake_query_renderer_integer,
+   fake_query_renderer_string
+};
+
+class query_renderer_string_test : public ::testing::Test {
+public:
+   virtual void SetUp();
+   virtual void TearDown();
+
+   struct glx_screen scr;
+   struct sigaction sa;
+   struct sigaction old_sa;
+   Display dpy;
+};
+
+class query_renderer_integer_test : public query_renderer_string_test {
+};
+
+void query_renderer_string_test::SetUp()
+{
+   memset(&scr, 0, sizeof(scr));
+   scr.vtable = &fake_vtable;
+   psc = &scr;
+
+   got_sigsegv = false;
+
+   sa.sa_handler = sigsegv_handler;
+   sigemptyset(&sa.sa_mask);
+   sa.sa_flags = 0;
+   sigaction(SIGSEGV, &sa, &old_sa);
+}
+
+void query_renderer_string_test::TearDown()
+{
+   sigaction(SIGSEGV, &old_sa, NULL);
+}
+
+/**
+ * glXQueryRendererStringMESA will return \c NULL if the query_render_string
+ * vtable entry is \c NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_string_test, null_query_render_string)
+{
+   struct glx_screen_vtable vtable = {
+      NULL,
+      NULL,
+      NULL,
+      NULL
+   };
+
+   scr.vtable = &vtable;
+
+   if (setjmp(jmp) == 0) {
+      const char *str =
+         glXQueryRendererStringMESA(&dpy, 0, 0, GLX_RENDERER_VENDOR_ID_MESA);
+      EXPECT_EQ((char *)0, str);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryRendererStringMESA will not call the screen query_render_string
+ * function with an invalid GLX enum value, and it will return NULL.
+ */
+TEST_F(query_renderer_string_test, invalid_attribute)
+{
+   static const attribute_test_vector invalid_attributes[] = {
+      /* These values are just plain invalid for use with this extension.
+       */
+      E(0),
+      E(GLX_VENDOR),
+      E(GLX_VERSION),
+      E(GLX_EXTENSIONS),
+      E(GLX_RENDERER_VENDOR_ID_MESA + 0x10000),
+      E(GLX_RENDERER_DEVICE_ID_MESA + 0x10000),
+
+      /* These enums are part of the extension, but they are not allowed for
+       * the string query.
+       */
+      E(GLX_RENDERER_VERSION_MESA),
+      E(GLX_RENDERER_ACCELERATED_MESA),
+      E(GLX_RENDERER_VIDEO_MEMORY_MESA),
+      E(GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA),
+      E(GLX_RENDERER_PREFERRED_PROFILE_MESA),
+      E(GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA),
+      E(GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA),
+      E(GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA),
+      E(GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA),
+      E(GLX_RENDERER_ID_MESA),
+   };
+
+   for (unsigned i = 0; i < ARRAY_SIZE(invalid_attributes); i++) {
+      query_renderer_integer_called = false;
+      query_renderer_string_called = false;
+
+      const char *str =
+         glXQueryRendererStringMESA(&dpy, 0, 0, invalid_attributes[i].value);
+      EXPECT_EQ((char *)0, str) << invalid_attributes[i].string;
+      EXPECT_FALSE(query_renderer_integer_called)
+         << invalid_attributes[i].string;
+      EXPECT_FALSE(query_renderer_string_called)
+         << invalid_attributes[i].string;
+   }
+}
+
+/**
+ * glXQueryRendererStringMESA will not call GetGLXScreenConfigs if the display
+ * pointer is \c NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_string_test, null_display_pointer)
+{
+   if (setjmp(jmp) == 0) {
+      GetGLXScreenConfigs_called = false;
+
+      const char *str =
+         glXQueryRendererStringMESA(NULL, 0, 0, GLX_RENDERER_VENDOR_ID_MESA);
+      EXPECT_EQ((char *)0, str);
+      EXPECT_FALSE(GetGLXScreenConfigs_called);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryRendererStringMESA will return error if GetGLXScreenConfigs returns
+ * NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_string_test, null_screen_pointer)
+{
+   psc = NULL;
+
+   if (setjmp(jmp) == 0) {
+      GetGLXScreenConfigs_called = false;
+
+      const char *str =
+         glXQueryRendererStringMESA(&dpy, 0, 0, GLX_RENDERER_VENDOR_ID_MESA);
+      EXPECT_EQ((char *)0, str);
+      EXPECT_TRUE(GetGLXScreenConfigs_called);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryRendererStringMESA will not call the screen query_render_string
+ * function if the renderer is invalid, and it will return NULL.
+ */
+TEST_F(query_renderer_string_test, invalid_renderer_index)
+{
+   static const int invalid_renderer_indices[] = {
+      -1,
+      1,
+      999,
+   };
+
+   if (setjmp(jmp) == 0) {
+      for (unsigned i = 0; i < ARRAY_SIZE(invalid_renderer_indices); i++) {
+         const char *str =
+            glXQueryRendererStringMESA(&dpy, 0,
+                                       invalid_renderer_indices[i],
+                                       GLX_RENDERER_VENDOR_ID_MESA);
+         EXPECT_EQ((char *)0, str) << invalid_renderer_indices[i];
+         EXPECT_FALSE(query_renderer_integer_called)
+            << invalid_renderer_indices[i];
+         EXPECT_FALSE(query_renderer_string_called)
+            << invalid_renderer_indices[i];
+      }
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryCurrentRendererStringMESA will return error if there is no context
+ * current.  It will also not segfault.
+ */
+TEST_F(query_renderer_string_test, no_current_context)
+{
+   if (setjmp(jmp) == 0) {
+      const char *str =
+         glXQueryCurrentRendererStringMESA(GLX_RENDERER_VENDOR_ID_MESA);
+      EXPECT_EQ((char *)0, str);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryCurrentRendererIntegerMESA will return \c NULL if the
+ * query_render_string vtable entry is \c NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_integer_test, null_query_render_string)
+{
+   struct glx_screen_vtable vtable = {
+      NULL,
+      NULL,
+      NULL,
+      NULL
+   };
+
+   scr.vtable = &vtable;
+
+   if (setjmp(jmp) == 0) {
+      unsigned value = 0xDEADBEEF;
+      Bool success = glXQueryRendererIntegerMESA(&dpy, 0, 0,
+                                                 GLX_RENDERER_VENDOR_ID_MESA,
+                                                 &value);
+      EXPECT_FALSE(success);
+      EXPECT_EQ(0xDEADBEEF, value);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryCurrentRendererIntegerMESA will not call the screen
+ * query_render_string function with an invalid GLX enum value, and it will
+ * return NULL.
+ */
+TEST_F(query_renderer_integer_test, invalid_attribute)
+{
+   static const attribute_test_vector invalid_attributes[] = {
+      /* These values are just plain invalid for use with this extension.
+       */
+      E(0),
+      E(GLX_VENDOR),
+      E(GLX_VERSION),
+      E(GLX_EXTENSIONS),
+      E(GLX_RENDERER_VENDOR_ID_MESA + 0x10000),
+      E(GLX_RENDERER_DEVICE_ID_MESA + 0x10000),
+      E(GLX_RENDERER_VERSION_MESA + 0x10000),
+      E(GLX_RENDERER_ACCELERATED_MESA + 0x10000),
+      E(GLX_RENDERER_VIDEO_MEMORY_MESA + 0x10000),
+      E(GLX_RENDERER_UNIFIED_MEMORY_ARCHITECTURE_MESA + 0x10000),
+      E(GLX_RENDERER_PREFERRED_PROFILE_MESA + 0x10000),
+      E(GLX_RENDERER_OPENGL_CORE_PROFILE_VERSION_MESA + 0x10000),
+      E(GLX_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION_MESA + 0x10000),
+      E(GLX_RENDERER_OPENGL_ES_PROFILE_VERSION_MESA + 0x10000),
+      E(GLX_RENDERER_OPENGL_ES2_PROFILE_VERSION_MESA + 0x10000),
+      E(GLX_RENDERER_ID_MESA + 0x10000),
+   };
+
+   for (unsigned i = 0; i < ARRAY_SIZE(invalid_attributes); i++) {
+      query_renderer_integer_called = false;
+      query_renderer_string_called = false;
+
+      unsigned value = 0xDEADBEEF;
+      Bool success =
+         glXQueryRendererIntegerMESA(&dpy, 0, 0,
+                                     invalid_attributes[i].value,
+                                     &value);
+      EXPECT_FALSE(success) << invalid_attributes[i].string;
+      EXPECT_EQ(0xDEADBEEF, value) << invalid_attributes[i].string;
+      EXPECT_FALSE(query_renderer_integer_called)
+         << invalid_attributes[i].string;
+      EXPECT_FALSE(query_renderer_string_called)
+         << invalid_attributes[i].string;
+   }
+}
+
+/**
+ * glXQueryCurrentRendererIntegerMESA will not call GetGLXScreenConfigs if the
+ * display pointer is \c NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_integer_test, null_display_pointer)
+{
+   if (setjmp(jmp) == 0) {
+      GetGLXScreenConfigs_called = false;
+
+      unsigned value = 0xDEADBEEF;
+      Bool success =
+         glXQueryRendererIntegerMESA(NULL, 0, 0, GLX_RENDERER_VENDOR_ID_MESA,
+                                     &value);
+      EXPECT_FALSE(success);
+      EXPECT_EQ(0xDEADBEEF, value);
+      EXPECT_FALSE(GetGLXScreenConfigs_called);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryCurrentRendererIntegerMESA will return error if GetGLXScreenConfigs
+ * returns NULL.  It will also not segfault.
+ */
+TEST_F(query_renderer_integer_test, null_screen_pointer)
+{
+   psc = NULL;
+
+   if (setjmp(jmp) == 0) {
+      GetGLXScreenConfigs_called = false;
+
+      unsigned value = 0xDEADBEEF;
+      Bool success =
+         glXQueryRendererIntegerMESA(&dpy, 0, 0, GLX_RENDERER_VENDOR_ID_MESA,
+            &value);
+      EXPECT_FALSE(success);
+      EXPECT_EQ(0xDEADBEEF, value);
+      EXPECT_TRUE(GetGLXScreenConfigs_called);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryRendererIntegerMESA will not call the screen query_render_integer
+ * function if the renderer is invalid, and it will return NULL.
+ */
+TEST_F(query_renderer_integer_test, invalid_renderer_index)
+{
+   static const int invalid_renderer_indices[] = {
+      -1,
+      1,
+      999,
+   };
+
+   if (setjmp(jmp) == 0) {
+      for (unsigned i = 0; i < ARRAY_SIZE(invalid_renderer_indices); i++) {
+         unsigned value = 0xDEADBEEF;
+         Bool success =
+            glXQueryRendererIntegerMESA(&dpy, 0,
+                                        invalid_renderer_indices[i],
+                                        GLX_RENDERER_VENDOR_ID_MESA,
+                                        &value);
+         EXPECT_FALSE(success) << invalid_renderer_indices[i];
+         EXPECT_EQ(0xDEADBEEF, value) << invalid_renderer_indices[i];
+         EXPECT_FALSE(query_renderer_integer_called)
+            << invalid_renderer_indices[i];
+         EXPECT_FALSE(query_renderer_string_called)
+            << invalid_renderer_indices[i];
+      }
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
+
+/**
+ * glXQueryCurrentRendererIntegerMESA will return error if there is no context
+ * current.  It will also not segfault.
+ */
+TEST_F(query_renderer_integer_test, no_current_context)
+{
+   if (setjmp(jmp) == 0) {
+      unsigned value = 0xDEADBEEF;
+      Bool success =
+         glXQueryCurrentRendererIntegerMESA(GLX_RENDERER_VENDOR_ID_MESA,
+                                            &value);
+      EXPECT_FALSE(success);
+      EXPECT_EQ(0xDEADBEEF, value);
+   } else {
+      EXPECT_FALSE(got_sigsegv);
+   }
+}
diff --git a/src/gtest/Makefile.am b/src/gtest/Makefile.am
index 4188c6b..c338977 100644
--- a/src/gtest/Makefile.am
+++ b/src/gtest/Makefile.am
@@ -19,6 +19,8 @@
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 
+AUTOMAKE_OPTIONS = subdir-objects
+
 AM_CFLAGS = $(DEFINES) -I$(top_srcdir)/src/gtest/include
 AM_CXXFLAGS = $(DEFINES) -I$(top_srcdir)/src/gtest/include
 
diff --git a/src/mapi/glapi/Makefile.am b/src/mapi/glapi/Makefile.am
index 05c67a6..bf653a3 100644
--- a/src/mapi/glapi/Makefile.am
+++ b/src/mapi/glapi/Makefile.am
@@ -33,10 +33,11 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/mesa
 
 if HAVE_X86_ASM
-GLAPI_ASM_SOURCES = $(X86_API)
-endif
 if HAVE_X86_64_ASM
 GLAPI_ASM_SOURCES = $(X86_64_API)
+else
+GLAPI_ASM_SOURCES = $(X86_API)
+endif
 endif
 if HAVE_SPARC_ASM
 GLAPI_ASM_SOURCES = $(SPARC_API)
diff --git a/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml b/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml
new file mode 100644
index 0000000..0ee6a3c
--- /dev/null
+++ b/src/mapi/glapi/gen/ARB_vertex_attrib_binding.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0"?>
+<!DOCTYPE OpenGLAPI SYSTEM "gl_API.dtd">
+
+<!-- Note: no GLX protocol info yet. -->
+
+<OpenGLAPI>
+
+<category name="GL_ARB_vertex_attrib_binding" number="125">
+
+    <function name="BindVertexBuffer" offset="assign">
+        <param name="bindingindex" type="GLuint"/>
+        <param name="buffer" type="GLuint"/>
+        <param name="offset" type="GLintptr"/>
+        <param name="stride" type="GLsizei"/>
+    </function>
+
+    <function name="VertexAttribFormat" offset="assign">
+        <param name="attribindex" type="GLuint"/>
+        <param name="size" type="GLint"/>
+        <param name="type" type="GLenum"/>
+        <param name="normalized" type="GLboolean"/>
+        <param name="relativeoffset" type="GLuint"/>
+    </function>
+
+    <function name="VertexAttribIFormat" offset="assign">
+        <param name="attribindex" type="GLuint"/>
+        <param name="size" type="GLint"/>
+        <param name="type" type="GLenum"/>
+        <param name="relativeoffset" type="GLuint"/>
+    </function>
+
+    <function name="VertexAttribLFormat" offset="assign">
+        <param name="attribindex" type="GLuint"/>
+        <param name="size" type="GLint"/>
+        <param name="type" type="GLenum"/>
+        <param name="relativeoffset" type="GLuint"/>
+    </function>
+
+    <function name="VertexAttribBinding" offset="assign">
+        <param name="attribindex" type="GLuint"/>
+        <param name="bindingindex" type="GLuint"/>
+    </function>
+
+    <function name="VertexBindingDivisor" offset="assign">
+        <param name="attribindex" type="GLuint"/>
+        <param name="divisor" type="GLuint"/>
+    </function>
+
+    <enum name="VERTEX_ATTRIB_BINDING" value="0x82D4"/>
+    <enum name="VERTEX_ATTRIB_RELATIVE_OFFSET" value="0x82D5"/>
+    <enum name="VERTEX_BINDING_DIVISOR" value="0x82D6"/>
+    <enum name="VERTEX_BINDING_OFFSET" value="0x82D7"/>
+    <enum name="VERTEX_BINDING_STRIDE" value="0x82D8"/>
+    <enum name="MAX_VERTEX_ATTRIB_RELATIVE_OFFSET" value="0x82D9"/>
+    <enum name="MAX_VERTEX_ATTRIB_BINDINGS" value="0x82DA"/>
+
+</category>
+</OpenGLAPI>
diff --git a/src/mapi/glapi/gen/Makefile.am b/src/mapi/glapi/gen/Makefile.am
index cbbf659..476d943 100644
--- a/src/mapi/glapi/gen/Makefile.am
+++ b/src/mapi/glapi/gen/Makefile.am
@@ -32,11 +32,11 @@ MESA_GLAPI_OUTPUTS = \
 
 MESA_GLAPI_ASM_OUTPUTS =
 if HAVE_X86_ASM
-MESA_GLAPI_ASM_OUTPUTS += $(MESA_GLAPI_DIR)/glapi_x86.S
-endif
-
 if HAVE_X86_64_ASM
 MESA_GLAPI_ASM_OUTPUTS += $(MESA_GLAPI_DIR)/glapi_x86-64.S
+else
+MESA_GLAPI_ASM_OUTPUTS += $(MESA_GLAPI_DIR)/glapi_x86.S
+endif
 endif
 
 if HAVE_SPARC_ASM
@@ -125,6 +125,7 @@ API_XML = \
 	ARB_texture_storage_multisample.xml \
 	ARB_texture_storage.xml \
 	ARB_vertex_array_object.xml \
+	ARB_vertex_attrib_binding.xml \
 	AMD_draw_buffers_blend.xml \
 	AMD_performance_monitor.xml \
 	ARB_vertex_type_2_10_10_10_rev.xml \
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 69014c5..a2d914a 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -8458,7 +8458,11 @@
 
 </category>
 
-<!-- ARB extensions #120...#126 -->
+<!-- ARB extensions #120...#124 -->
+
+<xi:include href="ARB_vertex_attrib_binding.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
+
+<!-- ARB extension #126 -->
 
 <xi:include href="ARB_ES3_compatibility.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
 
diff --git a/src/mapi/shared-glapi/tests/Makefile.am b/src/mapi/shared-glapi/tests/Makefile.am
index 98065fc..7e71b4f 100644
--- a/src/mapi/shared-glapi/tests/Makefile.am
+++ b/src/mapi/shared-glapi/tests/Makefile.am
@@ -3,6 +3,7 @@ AM_CFLAGS = $(PTHREAD_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gtest/include \
 	-I$(top_srcdir)/src/mapi \
+	-I$(top_builddir)/src/mapi \
 	-I$(top_srcdir)/include
 
 TESTS = shared-glapi-test
diff --git a/src/mesa/.gitignore b/src/mesa/.gitignore
new file mode 100644
index 0000000..ca3130d
--- /dev/null
+++ b/src/mesa/.gitignore
@@ -0,0 +1,2 @@
+gen_matypes
+matypes.h
diff --git a/src/mesa/Android.libmesa_dricore.mk b/src/mesa/Android.libmesa_dricore.mk
index 3679b50..0db5825 100644
--- a/src/mesa/Android.libmesa_dricore.mk
+++ b/src/mesa/Android.libmesa_dricore.mk
@@ -38,8 +38,6 @@ include $(CLEAR_VARS)
 LOCAL_MODULE := libmesa_dricore
 LOCAL_MODULE_CLASS := STATIC_LIBRARIES
 
-MESA_ENABLED_APIS := ES1 ES2 GL
-
 LOCAL_SRC_FILES := \
 	$(MESA_FILES)
 
diff --git a/src/mesa/Android.libmesa_st_mesa.mk b/src/mesa/Android.libmesa_st_mesa.mk
index e7203c4..e6374a6 100644
--- a/src/mesa/Android.libmesa_st_mesa.mk
+++ b/src/mesa/Android.libmesa_st_mesa.mk
@@ -37,8 +37,6 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE := libmesa_st_mesa
 
-MESA_ENABLED_APIS := ES1 ES2
-
 LOCAL_SRC_FILES := \
 	$(MESA_GALLIUM_FILES)
 
diff --git a/src/mesa/Makefile.am b/src/mesa/Makefile.am
index f86caee..a60600e 100644
--- a/src/mesa/Makefile.am
+++ b/src/mesa/Makefile.am
@@ -19,7 +19,7 @@
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 # IN THE SOFTWARE.
 
-SUBDIRS = program x86 x86-64 . main/tests
+SUBDIRS = . main/tests
 
 if HAVE_X11_DRIVER
 SUBDIRS += drivers/x11
@@ -59,11 +59,17 @@ main/git_sha1.h: main/git_sha1.h.tmp
 GLAPI = $(top_srcdir)/src/mapi/glapi/gen
 include $(GLAPI)/glapi_gen.mk
 
+BUILDDIR = $(builddir)/
+include Makefile.sources
+
 BUILT_SOURCES = \
 	main/git_sha1.h \
-	main/get_hash.h
+	main/get_hash.h \
+	$(BUILDDIR)program/program_parse.tab.c \
+	$(BUILDDIR)program/lex.yy.c
 CLEANFILES = \
 	$(BUILT_SOURCES) \
+	$(BUILDDIR)program/program_parse.tab.h \
 	git_sha1.h.tmp
 
 GET_HASH_GEN = main/get_hash_generator.py
@@ -75,7 +81,7 @@ main/get_hash.h: $(GLAPI)/gl_and_es_API.xml main/get_hash_params.py 	\
 		-f $< > $@.tmp;						\
 	mv $@.tmp $@;
 
-noinst_LTLIBRARIES =
+noinst_LTLIBRARIES = $(ARCH_LIBS)
 if NEED_LIBMESA
 noinst_LTLIBRARIES += libmesa.la
 else
@@ -85,10 +91,6 @@ if HAVE_GALLIUM
 noinst_LTLIBRARIES += libmesagallium.la
 endif
 
-SRCDIR = $(top_srcdir)/src/mesa/
-BUILDDIR = $(top_builddir)/src/mesa/
-include Makefile.sources
-
 AM_CPPFLAGS = $(DEFINES) $(INCLUDE_DIRS)
 AM_CFLAGS = $(LLVM_CFLAGS) $(VISIBILITY_CFLAGS)
 AM_CXXFLAGS = $(LLVM_CFLAGS) $(VISIBILITY_CXXFLAGS)
@@ -96,46 +98,70 @@ AM_CXXFLAGS = $(LLVM_CFLAGS) $(VISIBILITY_CXXFLAGS)
 MESA_ASM_FILES_FOR_ARCH =
 
 if HAVE_X86_ASM
-MESA_ASM_FILES_FOR_ARCH += $(X86_FILES)
-AM_CPPFLAGS += \
-        -I$(top_builddir)/src/mesa/x86 \
-        -I$(top_srcdir)/src/mesa/x86
-endif
+noinst_PROGRAMS = gen_matypes
+
+gen_matypes_SOURCES = x86/gen_matypes.c
+BUILT_SOURCES += matypes.h
+
+ARCH_LIBS = libmesa_sse41.la
+
 if HAVE_X86_64_ASM
 MESA_ASM_FILES_FOR_ARCH += $(X86_64_FILES)
-AM_CPPFLAGS += \
-        -I$(top_builddir)/src/mesa/x86-64 \
-        -I$(top_srcdir)/src/mesa/x86-64
+AM_CPPFLAGS += -I$(builddir)/x86-64 -I$(srcdir)/x86-64
+else
+MESA_ASM_FILES_FOR_ARCH += $(X86_FILES)
+AM_CPPFLAGS += -I$(builddir)/x86 -I$(srcdir)/x86
+endif
 endif
 if HAVE_SPARC_ASM
 MESA_ASM_FILES_FOR_ARCH += $(SPARC_FILES)
-AM_CPPFLAGS += \
-        -I$(top_builddir)/src/mesa/sparc \
-        -I$(top_srcdir)/src/mesa/sparc
+AM_CPPFLAGS += -I$(builddir)/sparc -I$(srcdir)/sparc
 endif
 
 libmesa_la_SOURCES = \
 	$(MESA_FILES) \
+	$(PROGRAM_FILES) \
         $(MESA_ASM_FILES_FOR_ARCH)
 
 libmesa_la_LIBADD = \
         $(top_builddir)/src/glsl/libglsl.la \
-        $(top_builddir)/src/mesa/program/libprogram.la \
+	$(ARCH_LIBS) \
         $()
-libmesa_la_LDFLAGS =
 
 libmesagallium_la_SOURCES = \
 	$(MESA_GALLIUM_FILES) \
+	$(PROGRAM_FILES) \
         $(MESA_ASM_FILES_FOR_ARCH)
 
 libmesagallium_la_LIBADD = \
         $(top_builddir)/src/glsl/libglsl.la \
-        $(top_builddir)/src/mesa/program/libprogram.la \
+	$(ARCH_LIBS) \
         $()
 
+libmesa_sse41_la_SOURCES = \
+	main/streaming-load-memcpy.c
+libmesa_sse41_la_CFLAGS = $(AM_CFLAGS) -msse4.1
+
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = gl.pc
 
+$(BUILDDIR)program/lex.yy.c: program/program_lexer.l
+	$(MKDIR_P) $(builddir)/program
+	$(AM_V_GEN) $(LEX) --never-interactive --outfile=$@ $<
+
+$(BUILDDIR)program/program_parse.tab.c $(BUILDDIR)program/program_parse.tab.h: program/program_parse.y
+	$(MKDIR_P) $(builddir)/program
+	$(AM_V_GEN) $(YACC) -p "_mesa_program_" -v -d --output=$(BUILDDIR)program/program_parse.tab.c $<
+
+if GEN_ASM_OFFSETS
+matypes.h: $(gen_matypes_SOURCES)
+	$(AM_V_GEN)$(COMPILE) $< -DASM_OFFSETS -S -o - | \
+		sed -n '/^->/{s:^->::;/[$$]/{s:^:#define :;s:[$$]::};p}' > $@
+else
+matypes.h: gen_matypes
+	$(AM_V_GEN)./gen_matypes > $@
+endif
+
 # Emacs tags
 tags:
 	etags `find . -name \*.[ch]` $(top_srcdir)/include/GL/*.h
diff --git a/src/mesa/SConscript b/src/mesa/SConscript
index 4213498..a2bb9f1 100644
--- a/src/mesa/SConscript
+++ b/src/mesa/SConscript
@@ -18,9 +18,6 @@ env.Append(CPPPATH = [
     Dir('.'), # src/mesa build path
 ])
 
-enabled_apis = []
-enabled_apis += ['GL']
-
 if env['platform'] == 'windows':
     env.Append(CPPDEFINES = [
         '_GDI32_', # prevent gl* being declared __declspec(dllimport) in MS headers
@@ -340,10 +337,6 @@ mesa_sources = (
 
 GLAPI = '#src/mapi/glapi/'
 
-if env['gles']:
-
-    enabled_apis += ['ES1', 'ES2']
-
 get_hash_header = env.CodeGenerate(
       target = 'main/get_hash.h',
       script = 'main/get_hash_generator.py',
diff --git a/src/mesa/drivers/SConscript b/src/mesa/drivers/SConscript
index 355e680..9888e33 100644
--- a/src/mesa/drivers/SConscript
+++ b/src/mesa/drivers/SConscript
@@ -6,7 +6,13 @@ if env['x11']:
     SConscript('x11/SConscript')
 
 if env['dri']:
-    SConscript('dri/common/xmlpool/SConscript')
+    SConscript([
+        'dri/common/xmlpool/SConscript',
+        'dri/common/SConscript',
+    ])
 
 if env['platform'] == 'windows':
     SConscript('windows/gdi/SConscript')
+
+if env['platform'] == 'haiku':
+    SConscript('haiku/swrast/SConscript')
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index aa50dde..99b02ba 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -1515,6 +1515,9 @@ setup_glsl_blit_framebuffer(struct gl_context *ctx,
                                    sizeof(struct vertex), OFFSET(x));
       _mesa_VertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE,
                                    sizeof(struct vertex), OFFSET(s));
+
+      _mesa_EnableVertexAttribArray(0);
+      _mesa_EnableVertexAttribArray(1);
    }
 
    /* Generate a relevant fragment shader program for the texture target */
@@ -1591,8 +1594,6 @@ setup_glsl_blit_framebuffer(struct gl_context *ctx,
    _mesa_DeleteObjectARB(vs);
    _mesa_BindAttribLocation(ShaderProg, 0, "position");
    _mesa_BindAttribLocation(ShaderProg, 1, "texcoords");
-   _mesa_EnableVertexAttribArray(0);
-   _mesa_EnableVertexAttribArray(1);
    link_program_with_debug(ctx, ShaderProg);
    ralloc_free(mem_ctx);
    if (texture_2d)
diff --git a/src/mesa/drivers/dri/common/Android.mk b/src/mesa/drivers/dri/common/Android.mk
index b3dac29..0489a32 100644
--- a/src/mesa/drivers/dri/common/Android.mk
+++ b/src/mesa/drivers/dri/common/Android.mk
@@ -40,7 +40,7 @@ LOCAL_C_INCLUDES := \
     $(intermediates) \
     $(MESA_DRI_C_INCLUDES)
 
-LOCAL_SRC_FILES := $(mesa_dri_common_SOURCES)
+LOCAL_SRC_FILES := $(DRI_COMMON_FILES)
 
 LOCAL_GENERATED_SOURCES := \
     $(intermediates)/xmlpool/options.h
diff --git a/src/mesa/drivers/dri/common/Makefile.am b/src/mesa/drivers/dri/common/Makefile.am
index 7f87ed6..e500bdb 100644
--- a/src/mesa/drivers/dri/common/Makefile.am
+++ b/src/mesa/drivers/dri/common/Makefile.am
@@ -21,6 +21,8 @@
 
 SUBDIRS = xmlpool
 
+include Makefile.sources
+
 AM_CFLAGS = \
 	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/ \
@@ -35,13 +37,9 @@ noinst_LTLIBRARIES = \
 	libmegadriver_stub.la \
 	libdri_test_stubs.la
 
-libdricommon_la_SOURCES = \
-	utils.c \
-	dri_util.c \
-	xmlconfig.c
+libdricommon_la_SOURCES = $(DRI_COMMON_FILES)
 
-libdri_test_stubs_la_SOURCES = \
-	dri_test.c
+libdri_test_stubs_la_SOURCES = $(test_stubs_FILES)
 libdri_test_stubs_la_CFLAGS = $(AM_CFLAGS) -DNO_MAIN
 
 libmegadriver_stub_la_SOURCES = megadriver_stub.c
diff --git a/src/mesa/drivers/dri/common/Makefile.sources b/src/mesa/drivers/dri/common/Makefile.sources
index 040b717..8469b49 100644
--- a/src/mesa/drivers/dri/common/Makefile.sources
+++ b/src/mesa/drivers/dri/common/Makefile.sources
@@ -1,11 +1,8 @@
-mesa_dri_common_gallium_SOURCES := \
+DRI_COMMON_FILES := \
 	utils.c \
 	dri_util.c \
 	xmlconfig.c
 
-mesa_dri_common_SOURCES := \
-	$(mesa_dri_common_gallium_SOURCES)
-
 # Paths are relative to MESA_TOP.
 mesa_dri_common_INCLUDES := \
 	include \
@@ -14,3 +11,6 @@ mesa_dri_common_INCLUDES := \
 	src/mapi \
 	src/mesa \
 	src/mesa/drivers/dri/common
+
+test_stubs_FILES := \
+	dri_test.c
diff --git a/src/mesa/drivers/dri/common/SConscript b/src/mesa/drivers/dri/common/SConscript
new file mode 100644
index 0000000..8b15532
--- /dev/null
+++ b/src/mesa/drivers/dri/common/SConscript
@@ -0,0 +1,83 @@
+###################################
+# SConcscript file for dri targets
+
+Import('*')
+
+drienv = env.Clone()
+
+drienv.Replace(CPPPATH = [
+    '#src/mesa/drivers/dri/common',
+    xmlpool_options.dir.dir, # Dir to generated xmlpool/options.h
+    '#include',
+    '#include/GL/internal',
+    '#src/mapi',
+    '#src/gallium/include',
+    '#src/gallium/auxiliary',
+    '#src/gallium/drivers',
+    '#src/gallium/winsys',
+    '#src/mesa',
+    '#src/mesa/main',
+    '#src/mesa/glapi',
+    '#src/mesa/math',
+    '#src/mesa/transform',
+    '#src/mesa/shader',
+    '#src/mesa/swrast',
+    '#src/mesa/swrast_setup',
+    '#src/egl/main',
+    '#src/egl/drivers/dri',
+])
+
+driswenv = drienv.Clone()
+driswenv.Append(CPPDEFINES = [
+    '__NOT_HAVE_DRM_H',
+])
+
+drienv.PkgUseModules('DRM')
+
+dri_common_utils = drienv.SharedObject(
+    target = 'utils.o',
+    source = '#src/mesa/drivers/dri/common/utils.c'
+)
+
+dri_common_xmlconfig = drienv.SharedObject(
+    target = 'xmlconfig.o',
+    source = '#src/mesa/drivers/dri/common/xmlconfig.c'
+)
+
+dri_common_dri_util = drienv.SharedObject(
+    target = 'dri_util.o',
+    source = '#src/mesa/drivers/dri/common/dri_util.c'
+)
+
+dri_common_drisw_util = driswenv.SharedObject(
+    target = 'drisw_util.o',
+    source = '#src/mesa/drivers/dri/common/dri_util.c'
+)
+
+
+COMMON_DRI_SW_OBJECTS = [
+    dri_common_utils,
+    dri_common_xmlconfig,
+    dri_common_drisw_util,
+]
+
+COMMON_DRI_DRM_OBJECTS = [
+    dri_common_utils,
+    dri_common_xmlconfig,
+    dri_common_dri_util,
+]
+
+drienv.AppendUnique(LIBS = [
+    'expat',
+])
+
+driswenv.AppendUnique(LIBS = [
+    'expat',
+])
+
+Export([
+    'drienv',
+    'driswenv',
+    'COMMON_DRI_SW_OBJECTS',
+    'COMMON_DRI_DRM_OBJECTS',
+])
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index c28b0fc..44e47f9 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -78,6 +78,8 @@ setupLoaderExtensions(__DRIscreen *psp,
 	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
 	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
 	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
+        if (strcmp(extensions[i]->name, __DRI_IMAGE_LOADER) == 0)
+           psp->image.loader = (__DRIimageLoaderExtension *) extensions[i];
     }
 }
 
@@ -106,10 +108,10 @@ const struct __DriverAPIRec *globalDriverAPI = &driDriverAPI;
  * Display.
  */
 static __DRIscreen *
-dri2CreateNewScreen2(int scrn, int fd,
-                     const __DRIextension **extensions,
-                     const __DRIextension **driver_extensions,
-                     const __DRIconfig ***driver_configs, void *data)
+driCreateNewScreen2(int scrn, int fd,
+                    const __DRIextension **extensions,
+                    const __DRIextension **driver_extensions,
+                    const __DRIconfig ***driver_configs, void *data)
 {
     static const __DRIextension *emptyExtensionList[] = { NULL };
     __DRIscreen *psp;
@@ -190,7 +192,7 @@ dri2CreateNewScreen(int scrn, int fd,
 		    const __DRIextension **extensions,
 		    const __DRIconfig ***driver_configs, void *data)
 {
-   return dri2CreateNewScreen2(scrn, fd, extensions, NULL,
+   return driCreateNewScreen2(scrn, fd, extensions, NULL,
                                driver_configs, data);
 }
 
@@ -199,7 +201,7 @@ static __DRIscreen *
 driSWRastCreateNewScreen(int scrn, const __DRIextension **extensions,
                          const __DRIconfig ***driver_configs, void *data)
 {
-   return dri2CreateNewScreen2(scrn, -1, extensions, NULL,
+   return driCreateNewScreen2(scrn, -1, extensions, NULL,
                                driver_configs, data);
 }
 
@@ -208,7 +210,7 @@ driSWRastCreateNewScreen2(int scrn, const __DRIextension **extensions,
                           const __DRIextension **driver_extensions,
                           const __DRIconfig ***driver_configs, void *data)
 {
-   return dri2CreateNewScreen2(scrn, -1, extensions, driver_extensions,
+   return driCreateNewScreen2(scrn, -1, extensions, driver_extensions,
                                driver_configs, data);
 }
 
@@ -291,13 +293,13 @@ validate_context_version(__DRIscreen *screen,
 /*@{*/
 
 static __DRIcontext *
-dri2CreateContextAttribs(__DRIscreen *screen, int api,
-			 const __DRIconfig *config,
-			 __DRIcontext *shared,
-			 unsigned num_attribs,
-			 const uint32_t *attribs,
-			 unsigned *error,
-			 void *data)
+driCreateContextAttribs(__DRIscreen *screen, int api,
+                        const __DRIconfig *config,
+                        __DRIcontext *shared,
+                        unsigned num_attribs,
+                        const uint32_t *attribs,
+                        unsigned *error,
+                        void *data)
 {
     __DRIcontext *context;
     const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
@@ -306,6 +308,7 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
     unsigned major_version = 1;
     unsigned minor_version = 0;
     uint32_t flags = 0;
+    bool notify_reset = false;
 
     assert((num_attribs == 0) || (attribs != NULL));
 
@@ -344,6 +347,10 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
 	case __DRI_CTX_ATTRIB_FLAGS:
 	    flags = attribs[i * 2 + 1];
 	    break;
+        case __DRI_CTX_ATTRIB_RESET_STRATEGY:
+            notify_reset = (attribs[i * 2 + 1]
+                            != __DRI_CTX_RESET_NO_NOTIFICATION);
+            break;
 	default:
 	    /* We can't create a context that satisfies the requirements of an
 	     * attribute that we don't understand.  Return failure.
@@ -424,7 +431,7 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
 
     if (!screen->driver->CreateContext(mesa_api, modes, context,
                                        major_version, minor_version,
-                                       flags, error, shareCtx) ) {
+                                       flags, notify_reset, error, shareCtx)) {
         free(context);
         return NULL;
     }
@@ -442,22 +449,22 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
 }
 
 static __DRIcontext *
-dri2CreateNewContextForAPI(__DRIscreen *screen, int api,
-			   const __DRIconfig *config,
-			   __DRIcontext *shared, void *data)
+driCreateNewContextForAPI(__DRIscreen *screen, int api,
+                          const __DRIconfig *config,
+                          __DRIcontext *shared, void *data)
 {
     unsigned error;
 
-    return dri2CreateContextAttribs(screen, api, config, shared, 0, NULL,
-				    &error, data);
+    return driCreateContextAttribs(screen, api, config, shared, 0, NULL,
+                                   &error, data);
 }
 
 static __DRIcontext *
-dri2CreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
-		      __DRIcontext *shared, void *data)
+driCreateNewContext(__DRIscreen *screen, const __DRIconfig *config,
+                    __DRIcontext *shared, void *data)
 {
-    return dri2CreateNewContextForAPI(screen, __DRI_API_OPENGL,
-				      config, shared, data);
+    return driCreateNewContextForAPI(screen, __DRI_API_OPENGL,
+                                     config, shared, data);
 }
 
 /**
@@ -609,9 +616,9 @@ static void dri_put_drawable(__DRIdrawable *pdp)
 }
 
 static __DRIdrawable *
-dri2CreateNewDrawable(__DRIscreen *screen,
-		      const __DRIconfig *config,
-		      void *data)
+driCreateNewDrawable(__DRIscreen *screen,
+                     const __DRIconfig *config,
+                     void *data)
 {
     __DRIdrawable *pdraw;
 
@@ -698,7 +705,7 @@ dri2ConfigQueryf(__DRIscreen *screen, const char *var, GLfloat *val)
 }
 
 static unsigned int
-dri2GetAPIMask(__DRIscreen *screen)
+driGetAPIMask(__DRIscreen *screen)
 {
     return screen->api_mask;
 }
@@ -729,7 +736,7 @@ const __DRIcoreExtension driCoreExtension = {
     .createNewDrawable          = NULL,
     .destroyDrawable            = driDestroyDrawable,
     .swapBuffers                = driSwapBuffers, /* swrast */
-    .createNewContext           = dri2CreateNewContext, /* swrast */
+    .createNewContext           = driCreateNewContext, /* swrast */
     .copyContext                = driCopyContext,
     .destroyContext             = driDestroyContext,
     .bindContext                = driBindContext,
@@ -741,22 +748,22 @@ const __DRIdri2Extension driDRI2Extension = {
     .base = { __DRI_DRI2, 4 },
 
     .createNewScreen            = dri2CreateNewScreen,
-    .createNewDrawable          = dri2CreateNewDrawable,
-    .createNewContext           = dri2CreateNewContext,
-    .getAPIMask                 = dri2GetAPIMask,
-    .createNewContextForAPI     = dri2CreateNewContextForAPI,
+    .createNewDrawable          = driCreateNewDrawable,
+    .createNewContext           = driCreateNewContext,
+    .getAPIMask                 = driGetAPIMask,
+    .createNewContextForAPI     = driCreateNewContextForAPI,
     .allocateBuffer             = dri2AllocateBuffer,
     .releaseBuffer              = dri2ReleaseBuffer,
-    .createContextAttribs       = dri2CreateContextAttribs,
-    .createNewScreen2           = dri2CreateNewScreen2,
+    .createContextAttribs       = driCreateContextAttribs,
+    .createNewScreen2           = driCreateNewScreen2,
 };
 
 const __DRIswrastExtension driSWRastExtension = {
     { __DRI_SWRAST, 4 },
     driSWRastCreateNewScreen,
-    dri2CreateNewDrawable,
-    dri2CreateNewContextForAPI,
-    dri2CreateContextAttribs,
+    driCreateNewDrawable,
+    driCreateNewContextForAPI,
+    driCreateContextAttribs,
     driSWRastCreateNewScreen2,
 };
 
@@ -792,3 +799,75 @@ driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv)
       assert(fb->Height == dPriv->h);
    }
 }
+
+uint32_t
+driGLFormatToImageFormat(gl_format format)
+{
+   switch (format) {
+   case MESA_FORMAT_RGB565:
+      return __DRI_IMAGE_FORMAT_RGB565;
+   case MESA_FORMAT_XRGB8888:
+      return __DRI_IMAGE_FORMAT_XRGB8888;
+   case MESA_FORMAT_ARGB2101010:
+      return __DRI_IMAGE_FORMAT_ARGB2101010;
+   case MESA_FORMAT_XRGB2101010_UNORM:
+      return __DRI_IMAGE_FORMAT_XRGB2101010;
+   case MESA_FORMAT_ARGB8888:
+      return __DRI_IMAGE_FORMAT_ARGB8888;
+   case MESA_FORMAT_RGBA8888_REV:
+      return __DRI_IMAGE_FORMAT_ABGR8888;
+   case MESA_FORMAT_RGBX8888_REV:
+      return __DRI_IMAGE_FORMAT_XBGR8888;
+   case MESA_FORMAT_R8:
+      return __DRI_IMAGE_FORMAT_R8;
+   case MESA_FORMAT_GR88:
+      return __DRI_IMAGE_FORMAT_GR88;
+   case MESA_FORMAT_NONE:
+      return __DRI_IMAGE_FORMAT_NONE;
+   case MESA_FORMAT_SARGB8:
+      return __DRI_IMAGE_FORMAT_SARGB8;
+   default:
+      return 0;
+   }
+}
+
+gl_format
+driImageFormatToGLFormat(uint32_t image_format)
+{
+   switch (image_format) {
+   case __DRI_IMAGE_FORMAT_RGB565:
+      return MESA_FORMAT_RGB565;
+   case __DRI_IMAGE_FORMAT_XRGB8888:
+      return MESA_FORMAT_XRGB8888;
+   case __DRI_IMAGE_FORMAT_ARGB2101010:
+      return MESA_FORMAT_ARGB2101010;
+   case __DRI_IMAGE_FORMAT_XRGB2101010:
+      return MESA_FORMAT_XRGB2101010_UNORM;
+   case __DRI_IMAGE_FORMAT_ARGB8888:
+      return MESA_FORMAT_ARGB8888;
+   case __DRI_IMAGE_FORMAT_ABGR8888:
+      return MESA_FORMAT_RGBA8888_REV;
+   case __DRI_IMAGE_FORMAT_XBGR8888:
+      return MESA_FORMAT_RGBX8888_REV;
+   case __DRI_IMAGE_FORMAT_R8:
+      return MESA_FORMAT_R8;
+   case __DRI_IMAGE_FORMAT_GR88:
+      return MESA_FORMAT_GR88;
+   case __DRI_IMAGE_FORMAT_SARGB8:
+      return MESA_FORMAT_SARGB8;
+   case __DRI_IMAGE_FORMAT_NONE:
+      return MESA_FORMAT_NONE;
+   default:
+      return MESA_FORMAT_NONE;
+   }
+}
+
+/** Image driver interface */
+const __DRIimageDriverExtension driImageDriverExtension = {
+    .base = { __DRI_IMAGE_DRIVER, __DRI_IMAGE_DRIVER_VERSION },
+
+    .createNewScreen2           = driCreateNewScreen2,
+    .createNewDrawable          = driCreateNewDrawable,
+    .getAPIMask                 = driGetAPIMask,
+    .createContextAttribs       = driCreateContextAttribs,
+};
diff --git a/src/mesa/drivers/dri/common/dri_util.h b/src/mesa/drivers/dri/common/dri_util.h
index 5b56061..79a8564 100644
--- a/src/mesa/drivers/dri/common/dri_util.h
+++ b/src/mesa/drivers/dri/common/dri_util.h
@@ -57,6 +57,7 @@
 #include <GL/internal/dri_interface.h>
 #include "main/mtypes.h"
 #include "xmlconfig.h"
+#include <stdbool.h>
 
 /**
  * Extensions.
@@ -87,6 +88,7 @@ struct __DriverAPIRec {
 			       unsigned major_version,
 			       unsigned minor_version,
 			       uint32_t flags,
+                               bool notify_reset,
 			       unsigned *error,
                                void *sharedContextPrivate);
 
@@ -174,6 +176,10 @@ struct __DRIscreenRec {
 	__DRIuseInvalidateExtension *useInvalidate;
     } dri2;
 
+    struct {
+        __DRIimageLoaderExtension *loader;
+    } image;
+
     driOptionCache optionInfo;
     driOptionCache optionCache;
 
@@ -271,10 +277,18 @@ struct __DRIdrawableRec {
     } dri2;
 };
 
+extern uint32_t
+driGLFormatToImageFormat(gl_format format);
+
+extern gl_format
+driImageFormatToGLFormat(uint32_t image_format);
+
 extern void
 dri2InvalidateDrawable(__DRIdrawable *drawable);
 
 extern void
 driUpdateFramebufferSize(struct gl_context *ctx, const __DRIdrawable *dPriv);
 
+extern const __DRIimageDriverExtension driImageDriverExtension;
+
 #endif /* _DRI_UTIL_H_ */
diff --git a/src/mesa/drivers/dri/common/utils.c b/src/mesa/drivers/dri/common/utils.c
index f3780d9..9c94832 100644
--- a/src/mesa/drivers/dri/common/utils.c
+++ b/src/mesa/drivers/dri/common/utils.c
@@ -37,6 +37,7 @@
 #include "main/cpuinfo.h"
 #include "main/extensions.h"
 #include "utils.h"
+#include "dri_util.h"
 
 
 unsigned
@@ -477,3 +478,66 @@ driIndexConfigAttrib(const __DRIconfig *config, int index,
 
     return GL_FALSE;
 }
+
+/**
+ * Implement queries for values that are common across all Mesa drivers
+ *
+ * Currently only the following queries are supported by this function:
+ *
+ *     - \c __DRI2_RENDERER_VERSION
+ *     - \c __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION
+ *     - \c __DRI2_RENDERER_OPENGL_COMPATIBLITY_PROFILE_VERSION
+ *     - \c __DRI2_RENDERER_ES_PROFILE_VERSION
+ *     - \c __DRI2_RENDERER_ES2_PROFILE_VERSION
+ *
+ * \returns
+ * Zero if a recognized value of \c param is supplied, -1 otherwise.
+ */
+int
+driQueryRendererIntegerCommon(__DRIscreen *psp, int param, unsigned int *value)
+{
+   switch (param) {
+   case __DRI2_RENDERER_VERSION: {
+      static const char *const ver = PACKAGE_VERSION;
+      char *endptr;
+      int v[3];
+
+      v[0] = strtol(ver, &endptr, 10);
+      assert(endptr[0] == '.');
+      if (endptr[0] != '.')
+         return -1;
+
+      v[1] = strtol(endptr + 1, &endptr, 10);
+      assert(endptr[0] == '.');
+      if (endptr[0] != '.')
+         return -1;
+
+      v[2] = strtol(endptr + 1, &endptr, 10);
+
+      value[0] = v[0];
+      value[1] = v[1];
+      value[2] = v[2];
+      return 0;
+   }
+   case __DRI2_RENDERER_OPENGL_CORE_PROFILE_VERSION:
+      value[0] = psp->max_gl_core_version / 10;
+      value[1] = psp->max_gl_core_version % 10;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_COMPATIBILITY_PROFILE_VERSION:
+      value[0] = psp->max_gl_compat_version / 10;
+      value[1] = psp->max_gl_compat_version % 10;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_ES_PROFILE_VERSION:
+      value[0] = psp->max_gl_es1_version / 10;
+      value[1] = psp->max_gl_es1_version % 10;
+      return 0;
+   case __DRI2_RENDERER_OPENGL_ES2_PROFILE_VERSION:
+      value[0] = psp->max_gl_es2_version / 10;
+      value[1] = psp->max_gl_es2_version % 10;
+      return 0;
+   default:
+      break;
+   }
+
+   return -1;
+}
diff --git a/src/mesa/drivers/dri/common/utils.h b/src/mesa/drivers/dri/common/utils.h
index e3b3940..22af123 100644
--- a/src/mesa/drivers/dri/common/utils.h
+++ b/src/mesa/drivers/dri/common/utils.h
@@ -65,4 +65,7 @@ int
 driIndexConfigAttrib(const __DRIconfig *config, int index,
 		     unsigned int *attrib, unsigned int *value);
 
+int
+driQueryRendererIntegerCommon(__DRIscreen *psp, int param, unsigned int *value);
+
 #endif /* DRI_DEBUG_H */
diff --git a/src/mesa/drivers/dri/i915/i830_state.c b/src/mesa/drivers/dri/i915/i830_state.c
index cedc58a..bbf0cef 100644
--- a/src/mesa/drivers/dri/i915/i830_state.c
+++ b/src/mesa/drivers/dri/i915/i830_state.c
@@ -451,15 +451,6 @@ i830DepthMask(struct gl_context * ctx, GLboolean flag)
       i830->state.Ctx[I830_CTXREG_ENABLES_2] |= DISABLE_DEPTH_WRITE;
 }
 
-/** Called from ctx->Driver.Viewport() */
-static void
-i830Viewport(struct gl_context * ctx,
-              GLint x, GLint y, GLsizei width, GLsizei height)
-{
-   intelCalcViewport(ctx);
-}
-
-
 /** Called from ctx->Driver.DepthRange() */
 static void
 i830DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
@@ -1136,7 +1127,6 @@ i830InitStateFuncs(struct dd_function_table *functions)
    functions->StencilMaskSeparate = i830StencilMaskSeparate;
    functions->StencilOpSeparate = i830StencilOpSeparate;
    functions->DepthRange = i830DepthRange;
-   functions->Viewport = i830Viewport;
 }
 
 void
diff --git a/src/mesa/drivers/dri/i915/i915_fragprog.c b/src/mesa/drivers/dri/i915/i915_fragprog.c
index 67eff76..dff4b9f 100644
--- a/src/mesa/drivers/dri/i915/i915_fragprog.c
+++ b/src/mesa/drivers/dri/i915/i915_fragprog.c
@@ -160,17 +160,6 @@ src_vector(struct i915_fragment_program *p,
       /* Various paramters and env values.  All emitted to
        * hardware as program constants.
        */
-   case PROGRAM_LOCAL_PARAM:
-      src = i915_emit_param4fv(p, program->Base.LocalParams[source->Index]);
-      break;
-
-   case PROGRAM_ENV_PARAM:
-      src =
-         i915_emit_param4fv(p,
-                            p->ctx->FragmentProgram.Parameters[source->
-                                                               Index]);
-      break;
-
    case PROGRAM_CONSTANT:
    case PROGRAM_STATE_VAR:
    case PROGRAM_UNIFORM:
diff --git a/src/mesa/drivers/dri/i915/i915_state.c b/src/mesa/drivers/dri/i915/i915_state.c
index 2fd0bf1..fedafec 100644
--- a/src/mesa/drivers/dri/i915/i915_state.c
+++ b/src/mesa/drivers/dri/i915/i915_state.c
@@ -424,15 +424,6 @@ intelCalcViewport(struct gl_context * ctx)
 }
 
 
-/** Called from ctx->Driver.Viewport() */
-static void
-i915Viewport(struct gl_context * ctx,
-              GLint x, GLint y, GLsizei width, GLsizei height)
-{
-   intelCalcViewport(ctx);
-}
-
-
 /** Called from ctx->Driver.DepthRange() */
 static void
 i915DepthRange(struct gl_context * ctx, GLclampd nearval, GLclampd farval)
@@ -1091,7 +1082,6 @@ i915InitStateFunctions(struct dd_function_table *functions)
    functions->StencilMaskSeparate = i915StencilMaskSeparate;
    functions->StencilOpSeparate = i915StencilOpSeparate;
    functions->DepthRange = i915DepthRange;
-   functions->Viewport = i915Viewport;
 }
 
 
diff --git a/src/mesa/drivers/dri/i915/intel_blit.c b/src/mesa/drivers/dri/i915/intel_blit.c
index 7b59708..5147d8e 100644
--- a/src/mesa/drivers/dri/i915/intel_blit.c
+++ b/src/mesa/drivers/dri/i915/intel_blit.c
@@ -534,8 +534,7 @@ intelEmitImmediateColorExpandBlit(struct intel_context *intel,
 	 return false;
    }
 
-   assert( logic_op - GL_CLEAR >= 0 );
-   assert( logic_op - GL_CLEAR < 0x10 );
+   assert((logic_op >= GL_CLEAR) && (logic_op <= (GL_CLEAR + 0x0f)));
    assert(dst_pitch > 0);
 
    if (w < 0 || h < 0)
diff --git a/src/mesa/drivers/dri/i915/intel_context.c b/src/mesa/drivers/dri/i915/intel_context.c
index 2748514..3618893 100644
--- a/src/mesa/drivers/dri/i915/intel_context.c
+++ b/src/mesa/drivers/dri/i915/intel_context.c
@@ -60,37 +60,47 @@
 
 int INTEL_DEBUG = (0);
 
+const char *const i915_vendor_string = "Intel Open Source Technology Center";
+
+const char *
+i915_get_renderer_string(unsigned deviceID)
+{
+   const char *chipset;
+   static char buffer[128];
+
+   switch (deviceID) {
+#undef CHIPSET
+#define CHIPSET(id, symbol, str) case id: chipset = str; break;
+#include "pci_ids/i915_pci_ids.h"
+   default:
+      chipset = "Unknown Intel Chipset";
+      break;
+   }
+
+   (void) driGetRendererString(buffer, chipset, 0);
+   return buffer;
+}
 
 static const GLubyte *
 intelGetString(struct gl_context * ctx, GLenum name)
 {
    const struct intel_context *const intel = intel_context(ctx);
-   const char *chipset;
-   static char buffer[128];
 
    switch (name) {
    case GL_VENDOR:
-      return (GLubyte *) "Intel Open Source Technology Center";
-      break;
+      return (GLubyte *) i915_vendor_string;
 
    case GL_RENDERER:
-      switch (intel->intelScreen->deviceID) {
-#undef CHIPSET
-#define CHIPSET(id, symbol, str) case id: chipset = str; break;
-#include "pci_ids/i915_pci_ids.h"
-      default:
-         chipset = "Unknown Intel Chipset";
-         break;
-      }
-
-      (void) driGetRendererString(buffer, chipset, 0);
-      return (GLubyte *) buffer;
+      return
+         (GLubyte *) i915_get_renderer_string(intel->intelScreen->deviceID);
 
    default:
       return NULL;
    }
 }
 
+#define flushFront(screen)      ((screen)->image.loader ? (screen)->image.loader->flushFrontBuffer : (screen)->dri2.loader->flushFrontBuffer)
+
 static void
 intel_flush_front(struct gl_context *ctx)
 {
@@ -100,11 +110,10 @@ intel_flush_front(struct gl_context *ctx)
     __DRIscreen *const screen = intel->intelScreen->driScrnPriv;
 
     if (intel->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
-      if (screen->dri2.loader->flushFrontBuffer != NULL &&
+      if (flushFront(screen) && 
           driDrawable &&
           driDrawable->loaderPrivate) {
-         screen->dri2.loader->flushFrontBuffer(driDrawable,
-                                               driDrawable->loaderPrivate);
+         flushFront(screen)(driDrawable, driDrawable->loaderPrivate);
 
 	 /* We set the dirty bit in intel_prepare_render() if we're
 	  * front buffer rendering once we get there.
@@ -114,6 +123,9 @@ intel_flush_front(struct gl_context *ctx)
    }
 }
 
+static void
+intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable);
+
 static unsigned
 intel_bits_per_pixel(const struct intel_renderbuffer *rb)
 {
@@ -133,15 +145,58 @@ intel_process_dri2_buffer(struct intel_context *intel,
 			  struct intel_renderbuffer *rb,
 			  const char *buffer_name);
 
-void
-intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
+static void
+intel_update_dri2_buffers(struct intel_context *intel, __DRIdrawable *drawable)
 {
-   struct gl_framebuffer *fb = drawable->driverPrivate;
-   struct intel_renderbuffer *rb;
-   struct intel_context *intel = context->driverPrivate;
    __DRIbuffer *buffers = NULL;
    int i, count;
    const char *region_name;
+   struct intel_renderbuffer *rb;
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+
+   intel_query_dri2_buffers(intel, drawable, &buffers, &count);
+
+   if (buffers == NULL)
+      return;
+
+   for (i = 0; i < count; i++) {
+      switch (buffers[i].attachment) {
+      case __DRI_BUFFER_FRONT_LEFT:
+         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+         region_name = "dri2 front buffer";
+         break;
+
+      case __DRI_BUFFER_FAKE_FRONT_LEFT:
+         rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+         region_name = "dri2 fake front buffer";
+         break;
+
+      case __DRI_BUFFER_BACK_LEFT:
+         rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
+         region_name = "dri2 back buffer";
+         break;
+
+      case __DRI_BUFFER_DEPTH:
+      case __DRI_BUFFER_HIZ:
+      case __DRI_BUFFER_DEPTH_STENCIL:
+      case __DRI_BUFFER_STENCIL:
+      case __DRI_BUFFER_ACCUM:
+      default:
+         fprintf(stderr,
+                 "unhandled buffer attach event, attachment type %d\n",
+                 buffers[i].attachment);
+         return;
+      }
+
+      intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
+   }
+}
+
+void
+intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
+{
+   struct intel_context *intel = context->driverPrivate;
+   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
 
    /* Set this up front, so that in case our buffers get invalidated
     * while we're getting new buffers, we don't clobber the stamp and
@@ -151,42 +206,10 @@ intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
    if (unlikely(INTEL_DEBUG & DEBUG_DRI))
       fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);
 
-   intel_query_dri2_buffers(intel, drawable, &buffers, &count);
-
-   if (buffers == NULL)
-      return;
-
-   for (i = 0; i < count; i++) {
-       switch (buffers[i].attachment) {
-       case __DRI_BUFFER_FRONT_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
-	   region_name = "dri2 front buffer";
-	   break;
-
-       case __DRI_BUFFER_FAKE_FRONT_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
-	   region_name = "dri2 fake front buffer";
-	   break;
-
-       case __DRI_BUFFER_BACK_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
-	   region_name = "dri2 back buffer";
-	   break;
-
-       case __DRI_BUFFER_DEPTH:
-       case __DRI_BUFFER_HIZ:
-       case __DRI_BUFFER_DEPTH_STENCIL:
-       case __DRI_BUFFER_STENCIL:
-       case __DRI_BUFFER_ACCUM:
-       default:
-	   fprintf(stderr,
-		   "unhandled buffer attach event, attachment type %d\n",
-		   buffers[i].attachment);
-	   return;
-       }
-
-       intel_process_dri2_buffer(intel, drawable, &buffers[i], rb, region_name);
-   }
+   if (screen->image.loader)
+      intel_update_image_buffers(intel, drawable);
+   else
+      intel_update_dri2_buffers(intel, drawable);
 
    driUpdateFramebufferSize(&intel->ctx, drawable);
 }
@@ -248,13 +271,18 @@ intel_prepare_render(struct intel_context *intel)
 }
 
 static void
-intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
+intel_noninvalidate_viewport(struct gl_context *ctx, GLint x, GLint y,
+                             GLsizei w, GLsizei h)
 {
     struct intel_context *intel = intel_context(ctx);
     __DRIcontext *driContext = intel->driContext;
 
-    if (intel->saved_viewport)
-	intel->saved_viewport(ctx, x, y, w, h);
+    (void) x;
+    (void) y;
+    (void) w;
+    (void) h;
+
+    intelCalcViewport(ctx);
 
     if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
        dri2InvalidateDrawable(driContext->driDrawablePriv);
@@ -262,6 +290,17 @@ intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
     }
 }
 
+static void
+intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
+{
+    (void) x;
+    (void) y;
+    (void) w;
+    (void) h;
+
+    intelCalcViewport(ctx);
+}
+
 static const struct dri_debug_control debug_control[] = {
    { "tex",   DEBUG_TEXTURE},
    { "state", DEBUG_STATE},
@@ -384,10 +423,10 @@ intelInitContext(struct intel_context *intel,
    struct gl_config visual;
 
    /* Can't rely on invalidate events, fall back to glViewport hack */
-   if (!driContextPriv->driScreenPriv->dri2.useInvalidate) {
-      intel->saved_viewport = functions->Viewport;
+   if (!driContextPriv->driScreenPriv->dri2.useInvalidate)
+      functions->Viewport = intel_noninvalidate_viewport;
+   else
       functions->Viewport = intel_viewport;
-   }
 
    if (mesaVis == NULL) {
       memset(&visual, 0, sizeof visual);
@@ -779,3 +818,101 @@ intel_process_dri2_buffer(struct intel_context *intel,
                                                  region);
    intel_region_release(&region);
 }
+
+/**
+ * \brief Query DRI Image loader to obtain a DRIdrawable's buffers.
+ *
+ * To determine which DRI buffers to request, examine the renderbuffers
+ * attached to the drawable's framebuffer. Then request the buffers with
+ * dri3
+ *
+ * This is called from intel_update_renderbuffers().
+ *
+ * \param drawable      Drawable whose buffers are queried.
+ * \param buffers       [out] List of buffers returned by DRI2 query.
+ * \param buffer_count  [out] Number of buffers returned.
+ *
+ * \see intel_update_renderbuffers()
+ */
+
+static void
+intel_update_image_buffer(struct intel_context *intel,
+                          __DRIdrawable *drawable,
+                          struct intel_renderbuffer *rb,
+                          __DRIimage *buffer,
+                          enum __DRIimageBufferMask buffer_type)
+{
+   struct intel_region *region = buffer->region;
+
+   if (!rb || !region)
+      return;
+
+   unsigned num_samples = rb->Base.Base.NumSamples;
+
+   if (rb->mt &&
+       rb->mt->region &&
+       rb->mt->region == region)
+      return;
+
+   intel_miptree_release(&rb->mt);
+   rb->mt = intel_miptree_create_for_image_buffer(intel,
+                                                  buffer_type,
+                                                  intel_rb_format(rb),
+                                                  num_samples,
+                                                  region);
+}
+
+
+static void
+intel_update_image_buffers(struct intel_context *intel, __DRIdrawable *drawable)
+{
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+   __DRIscreen *screen = intel->intelScreen->driScrnPriv;
+   struct intel_renderbuffer *front_rb;
+   struct intel_renderbuffer *back_rb;
+   struct __DRIimageList images;
+   unsigned int format;
+   uint32_t buffer_mask = 0;
+
+   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
+
+   if (back_rb)
+      format = intel_rb_format(back_rb);
+   else if (front_rb)
+      format = intel_rb_format(front_rb);
+   else
+      return;
+
+   if ((intel->is_front_buffer_rendering || intel->is_front_buffer_reading || !back_rb) && front_rb)
+      buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;
+
+   if (back_rb)
+      buffer_mask |= __DRI_IMAGE_BUFFER_BACK;
+
+   (*screen->image.loader->getBuffers) (drawable,
+                                        driGLFormatToImageFormat(format),
+                                        &drawable->dri2.stamp,
+                                        drawable->loaderPrivate,
+                                        buffer_mask,
+                                        &images);
+
+   if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {
+      drawable->w = images.front->width;
+      drawable->h = images.front->height;
+      intel_update_image_buffer(intel,
+                                drawable,
+                                front_rb,
+                                images.front,
+                                __DRI_IMAGE_BUFFER_FRONT);
+   }
+   if (images.image_mask & __DRI_IMAGE_BUFFER_BACK) {
+      drawable->w = images.back->width;
+      drawable->h = images.back->height;
+      intel_update_image_buffer(intel,
+                                drawable,
+                                back_rb,
+                                images.back,
+                                __DRI_IMAGE_BUFFER_BACK);
+   }
+}
diff --git a/src/mesa/drivers/dri/i915/intel_context.h b/src/mesa/drivers/dri/i915/intel_context.h
index 6fb73fc..e488ed1 100644
--- a/src/mesa/drivers/dri/i915/intel_context.h
+++ b/src/mesa/drivers/dri/i915/intel_context.h
@@ -278,8 +278,6 @@ struct intel_context
 
    __DRIcontext *driContext;
    struct intel_screen *intelScreen;
-   void (*saved_viewport)(struct gl_context * ctx,
-			  GLint x, GLint y, GLsizei width, GLsizei height);
 
    /**
     * Configuration cache
@@ -395,6 +393,10 @@ extern int INTEL_DEBUG;
  * intel_context.c:
  */
 
+extern const char *const i915_vendor_string;
+
+extern const char *i915_get_renderer_string(unsigned deviceID);
+
 extern bool intelInitContext(struct intel_context *intel,
                              int api,
                              unsigned major_version,
diff --git a/src/mesa/drivers/dri/i915/intel_mipmap_tree.c b/src/mesa/drivers/dri/i915/intel_mipmap_tree.c
index 8432b6d..f0ad30c 100644
--- a/src/mesa/drivers/dri/i915/intel_mipmap_tree.c
+++ b/src/mesa/drivers/dri/i915/intel_mipmap_tree.c
@@ -264,8 +264,10 @@ intel_miptree_create_for_bo(struct intel_context *intel,
                                     0, 0,
                                     width, height, 1,
                                     true);
-   if (!mt)
+   if (!mt) {
+      free(region);
       return mt;
+   }
 
    region->cpp = mt->cpp;
    region->width = width;
@@ -322,6 +324,39 @@ intel_miptree_create_for_dri2_buffer(struct intel_context *intel,
    return mt;
 }
 
+/**
+ * For a singlesample image buffer, this simply wraps the given region with a miptree.
+ *
+ * For a multisample image buffer, this wraps the given region with
+ * a singlesample miptree, then creates a multisample miptree into which the
+ * singlesample miptree is embedded as a child.
+ */
+struct intel_mipmap_tree*
+intel_miptree_create_for_image_buffer(struct intel_context *intel,
+                                      enum __DRIimageBufferMask buffer_type,
+                                      gl_format format,
+                                      uint32_t num_samples,
+                                      struct intel_region *region)
+{
+   struct intel_mipmap_tree *mt = NULL;
+
+   /* Only the front and back buffers, which are color buffers, are allocated
+    * through the image loader.
+    */
+   assert(_mesa_get_format_base_format(format) == GL_RGB ||
+          _mesa_get_format_base_format(format) == GL_RGBA);
+
+   mt = intel_miptree_create_for_bo(intel,
+                                    region->bo,
+                                    format,
+                                    0,
+                                    region->width,
+                                    region->height,
+                                    region->pitch,
+                                    region->tiling);
+   return mt;
+}
+
 struct intel_mipmap_tree*
 intel_miptree_create_for_renderbuffer(struct intel_context *intel,
                                       gl_format format,
diff --git a/src/mesa/drivers/dri/i915/intel_mipmap_tree.h b/src/mesa/drivers/dri/i915/intel_mipmap_tree.h
index 1142af6..35cad6d 100644
--- a/src/mesa/drivers/dri/i915/intel_mipmap_tree.h
+++ b/src/mesa/drivers/dri/i915/intel_mipmap_tree.h
@@ -32,6 +32,7 @@
 
 #include "intel_screen.h"
 #include "intel_regions.h"
+#include "GL/internal/dri_interface.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -258,6 +259,13 @@ intel_miptree_create_for_dri2_buffer(struct intel_context *intel,
                                      gl_format format,
                                      struct intel_region *region);
 
+struct intel_mipmap_tree*
+intel_miptree_create_for_image_buffer(struct intel_context *intel,
+                                      enum __DRIimageBufferMask buffer_type,
+                                      gl_format format,
+                                      uint32_t num_samples,
+                                      struct intel_region *region);
+
 /**
  * Create a miptree appropriate as the storage for a non-texture renderbuffer.
  * The miptree has the following properties:
diff --git a/src/mesa/drivers/dri/i915/intel_regions.c b/src/mesa/drivers/dri/i915/intel_regions.c
index 44f7030..9f5b89e 100644
--- a/src/mesa/drivers/dri/i915/intel_regions.c
+++ b/src/mesa/drivers/dri/i915/intel_regions.c
@@ -209,6 +209,7 @@ struct intel_region *
 intel_region_alloc_for_fd(struct intel_screen *screen,
                           GLuint cpp,
                           GLuint width, GLuint height, GLuint pitch,
+                          GLuint size,
                           int fd, const char *name)
 {
    struct intel_region *region;
@@ -216,8 +217,7 @@ intel_region_alloc_for_fd(struct intel_screen *screen,
    int ret;
    uint32_t bit_6_swizzle, tiling;
 
-   buffer = drm_intel_bo_gem_create_from_prime(screen->bufmgr,
-                                               fd, height * pitch);
+   buffer = drm_intel_bo_gem_create_from_prime(screen->bufmgr, fd, size);
    if (buffer == NULL)
       return NULL;
    ret = drm_intel_bo_get_tiling(buffer, &tiling, &bit_6_swizzle);
diff --git a/src/mesa/drivers/dri/i915/intel_regions.h b/src/mesa/drivers/dri/i915/intel_regions.h
index 5c612a9..6bc4a42 100644
--- a/src/mesa/drivers/dri/i915/intel_regions.h
+++ b/src/mesa/drivers/dri/i915/intel_regions.h
@@ -91,7 +91,7 @@ struct intel_region *
 intel_region_alloc_for_fd(struct intel_screen *screen,
                           GLuint cpp,
                           GLuint width, GLuint height, GLuint pitch,
-                          int fd, const char *name);
+                          GLuint size, int fd, const char *name);
 
 bool
 intel_region_flink(struct intel_region *region, uint32_t *name);
diff --git a/src/mesa/drivers/dri/i915/intel_screen.c b/src/mesa/drivers/dri/i915/intel_screen.c
index 3f54752..7f1fc6b 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.c
+++ b/src/mesa/drivers/dri/i915/intel_screen.c
@@ -27,6 +27,7 @@
 
 #include <errno.h>
 #include <time.h>
+#include <unistd.h>
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
@@ -244,32 +245,9 @@ intel_allocate_image(int dri_format, void *loaderPrivate)
     image->dri_format = dri_format;
     image->offset = 0;
 
-    switch (dri_format) {
-    case __DRI_IMAGE_FORMAT_RGB565:
-       image->format = MESA_FORMAT_RGB565;
-       break;
-    case __DRI_IMAGE_FORMAT_XRGB8888:
-       image->format = MESA_FORMAT_XRGB8888;
-       break;
-    case __DRI_IMAGE_FORMAT_ARGB8888:
-       image->format = MESA_FORMAT_ARGB8888;
-       break;
-    case __DRI_IMAGE_FORMAT_ABGR8888:
-       image->format = MESA_FORMAT_RGBA8888_REV;
-       break;
-    case __DRI_IMAGE_FORMAT_XBGR8888:
-       image->format = MESA_FORMAT_RGBX8888_REV;
-       break;
-    case __DRI_IMAGE_FORMAT_R8:
-       image->format = MESA_FORMAT_R8;
-       break;
-    case __DRI_IMAGE_FORMAT_GR88:
-       image->format = MESA_FORMAT_GR88;
-       break;
-    case __DRI_IMAGE_FORMAT_NONE:
-       image->format = MESA_FORMAT_NONE;
-       break;
-    default:
+    image->format = driImageFormatToGLFormat(dri_format);
+    if (dri_format != __DRI_IMAGE_FORMAT_NONE &&
+        image->format == MESA_FORMAT_NONE) {
        free(image);
        return NULL;
     }
@@ -318,27 +296,6 @@ intel_setup_image_from_dimensions(__DRIimage *image)
    image->tile_y = 0;
 }
 
-static inline uint32_t
-intel_dri_format(GLuint format)
-{
-   switch (format) {
-   case MESA_FORMAT_RGB565:
-      return __DRI_IMAGE_FORMAT_RGB565;
-   case MESA_FORMAT_XRGB8888:
-      return __DRI_IMAGE_FORMAT_XRGB8888;
-   case MESA_FORMAT_ARGB8888:
-      return __DRI_IMAGE_FORMAT_ARGB8888;
-   case MESA_FORMAT_RGBA8888_REV:
-      return __DRI_IMAGE_FORMAT_ABGR8888;
-   case MESA_FORMAT_R8:
-      return __DRI_IMAGE_FORMAT_R8;
-   case MESA_FORMAT_RG88:
-      return __DRI_IMAGE_FORMAT_GR88;
-   }
-
-   return MESA_FORMAT_NONE;
-}
-
 static __DRIimage *
 intel_create_image_from_name(__DRIscreen *screen,
 			     int width, int height, int format,
@@ -396,7 +353,7 @@ intel_create_image_from_renderbuffer(__DRIcontext *context,
    image->data = loaderPrivate;
    intel_region_reference(&image->region, irb->mt->region);
    intel_setup_image_from_dimensions(image);
-   image->dri_format = intel_dri_format(image->format);
+   image->dri_format = driGLFormatToImageFormat(image->format);
 
    rb->NeedsFinishRenderTexture = true;
    return image;
@@ -450,7 +407,7 @@ intel_create_image_from_texture(__DRIcontext *context, int target,
    image->format = obj->Image[face][level]->TexFormat;
    image->data = loaderPrivate;
    intel_setup_image_from_mipmap_tree(intel, image, iobj->mt, level, zoffset);
-   image->dri_format = intel_dri_format(image->format);
+   image->dri_format = driGLFormatToImageFormat(image->format);
    if (image->dri_format == MESA_FORMAT_NONE) {
       *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
       free(image);
@@ -653,8 +610,8 @@ intel_create_image_from_fds(__DRIscreen *screen,
       return NULL;
 
    image->region = intel_region_alloc_for_fd(intelScreen,
-                                             1, width, height,
-                                             strides[0], fds[0], "image");
+                                             f->planes[0].cpp, width, height, strides[0],
+                                             height * strides[0], fds[0], "image");
    if (image->region == NULL) {
       free(image);
       return NULL;
@@ -745,10 +702,95 @@ static struct __DRIimageExtensionRec intelImageExtension = {
     .createImageFromFds                 = intel_create_image_from_fds
 };
 
+static int
+i915_query_renderer_integer(__DRIscreen *psp, int param, unsigned int *value)
+{
+   const struct intel_screen *const intelScreen =
+      (struct intel_screen *) psp->driverPrivate;
+
+   switch (param) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      value[0] = 0x8086;
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      value[0] = intelScreen->deviceID;
+      return 0;
+   case __DRI2_RENDERER_ACCELERATED:
+      value[0] = 1;
+      return 0;
+   case __DRI2_RENDERER_VIDEO_MEMORY: {
+      /* Once a batch uses more than 75% of the maximum mappable size, we
+       * assume that there's some fragmentation, and we start doing extra
+       * flushing, etc.  That's the big cliff apps will care about.
+       */
+      size_t aper_size;
+      size_t mappable_size;
+
+      drm_intel_get_aperture_sizes(psp->fd, &mappable_size, &aper_size);
+
+      const unsigned gpu_mappable_megabytes =
+         (aper_size / (1024 * 1024)) * 3 / 4;
+
+      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);
+      const long system_page_size = sysconf(_SC_PAGE_SIZE);
+
+      if (system_memory_pages <= 0 || system_page_size <= 0)
+         return -1;
+
+      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages
+         * (uint64_t) system_page_size;
+
+      const unsigned system_memory_megabytes =
+         (unsigned) (system_memory_bytes / 1024);
+
+      value[0] = MIN2(system_memory_megabytes, gpu_mappable_megabytes);
+      return 0;
+   }
+   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
+      value[0] = 1;
+      return 0;
+   case __DRI2_RENDERER_PREFERRED_PROFILE:
+      value[0] = (1U << __DRI_API_OPENGL);
+      return 0;
+   default:
+      return driQueryRendererIntegerCommon(psp, param, value);
+   }
+
+   return -1;
+}
+
+static int
+i915_query_renderer_string(__DRIscreen *psp, int param, const char **value)
+{
+   const struct intel_screen *intelScreen =
+      (struct intel_screen *) psp->driverPrivate;
+
+   switch (param) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      value[0] = i915_vendor_string;
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      value[0] = i915_get_renderer_string(intelScreen->deviceID);
+      return 0;
+   default:
+      break;
+   }
+
+   return -1;
+}
+
+static struct __DRI2rendererQueryExtensionRec intelRendererQueryExtension = {
+   .base = { __DRI2_RENDERER_QUERY, 1 },
+
+   .queryInteger = i915_query_renderer_integer,
+   .queryString = i915_query_renderer_string
+};
+
 static const __DRIextension *intelScreenExtensions[] = {
     &intelTexBufferExtension.base,
     &intelFlushExtension.base,
     &intelImageExtension.base,
+    &intelRendererQueryExtension.base,
     &dri2ConfigQueryExtension.base,
     NULL
 };
@@ -908,6 +950,7 @@ intelCreateContext(gl_api api,
 		   unsigned major_version,
 		   unsigned minor_version,
 		   uint32_t flags,
+                   bool notify_reset,
 		   unsigned *error,
                    void *sharedContextPrivate)
 {
@@ -916,6 +959,16 @@ intelCreateContext(gl_api api,
    __DRIscreen *sPriv = driContextPriv->driScreenPriv;
    struct intel_screen *intelScreen = sPriv->driverPrivate;
 
+   if (flags & ~__DRI_CTX_FLAG_DEBUG) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return false;
+   }
+
+   if (notify_reset) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      return false;
+   }
+
    if (IS_9XX(intelScreen->deviceID)) {
       success = i915CreateContext(api, mesaVis, driContextPriv,
                                   major_version, minor_version, error,
@@ -1211,6 +1264,7 @@ static const struct __DRIDriverVtableExtensionRec i915_vtable = {
 /* This is the table of extensions that the loader will dlsym() for. */
 static const __DRIextension *i915_driver_extensions[] = {
     &driCoreExtension.base,
+    &driImageDriverExtension.base,
     &driDRI2Extension.base,
     &i915_vtable.base,
     &i915_config_options.base,
diff --git a/src/mesa/drivers/dri/i915/intel_screen.h b/src/mesa/drivers/dri/i915/intel_screen.h
index 4ae259c..faa4c20 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.h
+++ b/src/mesa/drivers/dri/i915/intel_screen.h
@@ -155,6 +155,7 @@ struct intel_screen
 #define intel_fbo_init                      old_intel_fbo_init
 #define intel_get_rb_region                 old_intel_get_rb_region
 #define intel_renderbuffer_set_draw_offset  old_intel_renderbuffer_set_draw_offset
+#define intel_miptree_create_for_image_buffer old_intel_miptree_create_for_image_buffer
 
 extern void intelDestroyContext(__DRIcontext * driContextPriv);
 
diff --git a/src/mesa/drivers/dri/i965/Makefile.sources b/src/mesa/drivers/dri/i965/Makefile.sources
index 14b2f61..5724458 100644
--- a/src/mesa/drivers/dri/i965/Makefile.sources
+++ b/src/mesa/drivers/dri/i965/Makefile.sources
@@ -72,10 +72,10 @@ i965_FILES = \
 	brw_lower_unnormalized_offset.cpp \
 	brw_misc_state.c \
 	brw_object_purgeable.c \
-	brw_performance_monitor.c \
 	brw_program.c \
 	brw_primitive_restart.c \
 	brw_queryobj.c \
+	brw_reset.c \
 	brw_schedule_instructions.cpp \
 	brw_sf.c \
 	brw_sf_emit.c \
@@ -124,7 +124,6 @@ i965_FILES = \
 	gen6_vs_state.c \
 	gen6_wm_state.c \
 	gen7_blorp.cpp \
-	gen7_clip_state.c \
 	gen7_disable.c \
         gen7_gs_state.c \
 	gen7_misc_state.c \
diff --git a/src/mesa/drivers/dri/i965/brw_blorp.cpp b/src/mesa/drivers/dri/i965/brw_blorp.cpp
index 91df346..4cbcebe 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp.cpp
@@ -21,6 +21,7 @@
  * IN THE SOFTWARE.
  */
 
+#include <errno.h>
 #include "intel_batchbuffer.h"
 #include "intel_fbo.h"
 
@@ -195,6 +196,26 @@ intel_hiz_exec(struct brw_context *brw, struct intel_mipmap_tree *mt,
 void
 brw_blorp_exec(struct brw_context *brw, const brw_blorp_params *params)
 {
+   struct gl_context *ctx = &brw->ctx;
+   uint32_t estimated_max_batch_usage = 1500;
+   bool check_aperture_failed_once = false;
+
+   /* Flush the sampler and render caches.  We definitely need to flush the
+    * sampler cache so that we get updated contents from the render cache for
+    * the glBlitFramebuffer() source.  Also, we are sometimes warned in the
+    * docs to flush the cache between reinterpretations of the same surface
+    * data with different formats, which blorp does for stencil and depth
+    * data.
+    */
+   intel_batchbuffer_emit_mi_flush(brw);
+
+retry:
+   intel_batchbuffer_require_space(brw, estimated_max_batch_usage, false);
+   intel_batchbuffer_save_state(brw);
+   drm_intel_bo *saved_bo = brw->batch.bo;
+   uint32_t saved_used = brw->batch.used;
+   uint32_t saved_state_batch_offset = brw->batch.state_batch_offset;
+
    switch (brw->gen) {
    case 6:
       gen6_blorp_exec(brw, params);
@@ -208,6 +229,35 @@ brw_blorp_exec(struct brw_context *brw, const brw_blorp_params *params)
       break;
    }
 
+   /* Make sure we didn't wrap the batch unintentionally, and make sure we
+    * reserved enough space that a wrap will never happen.
+    */
+   assert(brw->batch.bo == saved_bo);
+   assert((brw->batch.used - saved_used) * 4 +
+          (saved_state_batch_offset - brw->batch.state_batch_offset) <
+          estimated_max_batch_usage);
+   /* Shut up compiler warnings on release build */
+   (void)saved_bo;
+   (void)saved_used;
+   (void)saved_state_batch_offset;
+
+   /* Check if the blorp op we just did would make our batch likely to fail to
+    * map all the BOs into the GPU at batch exec time later.  If so, flush the
+    * batch and try again with nothing else in the batch.
+    */
+   if (dri_bufmgr_check_aperture_space(&brw->batch.bo, 1)) {
+      if (!check_aperture_failed_once) {
+         check_aperture_failed_once = true;
+         intel_batchbuffer_reset_to_saved(brw);
+         intel_batchbuffer_flush(brw);
+         goto retry;
+      } else {
+         int ret = intel_batchbuffer_flush(brw);
+         WARN_ONCE(ret == -ENOSPC,
+                   "i965: blorp emit exceeded available aperture space\n");
+      }
+   }
+
    if (unlikely(brw->always_flush_batch))
       intel_batchbuffer_flush(brw);
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp.h b/src/mesa/drivers/dri/i965/brw_blorp.h
index 07ab805..85bf099 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp.h
+++ b/src/mesa/drivers/dri/i965/brw_blorp.h
@@ -371,10 +371,6 @@ void
 gen6_blorp_init(struct brw_context *brw);
 
 void
-gen6_blorp_emit_batch_head(struct brw_context *brw,
-                           const brw_blorp_params *params);
-
-void
 gen6_blorp_emit_state_base_address(struct brw_context *brw,
                                    const brw_blorp_params *params);
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
index 7e436f7..d54b926 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
@@ -1403,10 +1403,6 @@ brw_blorp_blit_program::kill_if_outside_dst_rect()
    brw_pop_insn_state(&func);
 }
 
-#define X_f retype(X, BRW_REGISTER_TYPE_F)
-#define Y_f retype(Y, BRW_REGISTER_TYPE_F)
-#define Xp_f retype(Xp, BRW_REGISTER_TYPE_F)
-#define Yp_f retype(Yp, BRW_REGISTER_TYPE_F)
 /**
  * Emit code to translate from destination (X, Y) coordinates to source (X, Y)
  * coordinates.
@@ -1414,6 +1410,11 @@ brw_blorp_blit_program::kill_if_outside_dst_rect()
 void
 brw_blorp_blit_program::translate_dst_to_src()
 {
+   struct brw_reg X_f = retype(X, BRW_REGISTER_TYPE_F);
+   struct brw_reg Y_f = retype(Y, BRW_REGISTER_TYPE_F);
+   struct brw_reg Xp_f = retype(Xp, BRW_REGISTER_TYPE_F);
+   struct brw_reg Yp_f = retype(Yp, BRW_REGISTER_TYPE_F);
+
    brw_set_compression_control(&func, BRW_COMPRESSION_COMPRESSED);
    /* Move the UD coordinates to float registers. */
    brw_MOV(&func, Xp_f, X);
@@ -1489,10 +1490,6 @@ brw_blorp_blit_program::clamp_tex_coords(struct brw_reg regX,
    brw_MOV(&func, regY, clampY1);
    brw_set_predicate_control(&func, BRW_PREDICATE_NONE);
 }
-#undef X_f
-#undef Y_f
-#undef Xp_f
-#undef Yp_f
 
 /**
  * Emit code to transform the X and Y coordinates as needed for blending
diff --git a/src/mesa/drivers/dri/i965/brw_cc.c b/src/mesa/drivers/dri/i965/brw_cc.c
index 6f85f63..53466e7 100644
--- a/src/mesa/drivers/dri/i965/brw_cc.c
+++ b/src/mesa/drivers/dri/i965/brw_cc.c
@@ -187,7 +187,8 @@ static void upload_cc_unit(struct brw_context *brw)
 				eqA != eqRGB);
    }
 
-   if (ctx->Color.AlphaEnabled) {
+   /* _NEW_BUFFERS */
+   if (ctx->Color.AlphaEnabled && ctx->DrawBuffer->_NumColorDrawBuffers <= 1) {
       cc->cc3.alpha_test = 1;
       cc->cc3.alpha_test_func =
 	 intel_translate_compare_func(ctx->Color.AlphaFunc);
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 38147e9..bee98e3 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -94,30 +94,39 @@ brw_query_samples_for_format(struct gl_context *ctx, GLenum target,
    }
 }
 
+const char *const brw_vendor_string = "Intel Open Source Technology Center";
+
+const char *
+brw_get_renderer_string(unsigned deviceID)
+{
+   const char *chipset;
+   static char buffer[128];
+
+   switch (deviceID) {
+#undef CHIPSET
+#define CHIPSET(id, symbol, str) case id: chipset = str; break;
+#include "pci_ids/i965_pci_ids.h"
+   default:
+      chipset = "Unknown Intel Chipset";
+      break;
+   }
+
+   (void) driGetRendererString(buffer, chipset, 0);
+   return buffer;
+}
+
 static const GLubyte *
 intelGetString(struct gl_context * ctx, GLenum name)
 {
    const struct brw_context *const brw = brw_context(ctx);
-   const char *chipset;
-   static char buffer[128];
 
    switch (name) {
    case GL_VENDOR:
-      return (GLubyte *) "Intel Open Source Technology Center";
-      break;
+      return (GLubyte *) brw_vendor_string;
 
    case GL_RENDERER:
-      switch (brw->intelScreen->deviceID) {
-#undef CHIPSET
-#define CHIPSET(id, family, str) case id: chipset = str; break;
-#include "pci_ids/i965_pci_ids.h"
-      default:
-         chipset = "Unknown Intel Chipset";
-         break;
-      }
-
-      (void) driGetRendererString(buffer, chipset, 0);
-      return (GLubyte *) buffer;
+      return
+         (GLubyte *) brw_get_renderer_string(brw->intelScreen->deviceID);
 
    default:
       return NULL;
@@ -130,8 +139,10 @@ intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
    struct brw_context *brw = brw_context(ctx);
    __DRIcontext *driContext = brw->driContext;
 
-   if (brw->saved_viewport)
-      brw->saved_viewport(ctx, x, y, w, h);
+   (void) x;
+   (void) y;
+   (void) w;
+   (void) h;
 
    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
       dri2InvalidateDrawable(driContext->driDrawablePriv);
@@ -151,6 +162,8 @@ intelInvalidateState(struct gl_context * ctx, GLuint new_state)
    brw->NewGLState |= new_state;
 }
 
+#define flushFront(screen)      ((screen)->image.loader ? (screen)->image.loader->flushFrontBuffer : (screen)->dri2.loader->flushFrontBuffer)
+
 static void
 intel_flush_front(struct gl_context *ctx)
 {
@@ -160,8 +173,7 @@ intel_flush_front(struct gl_context *ctx)
    __DRIscreen *const screen = brw->intelScreen->driScrnPriv;
 
    if (brw->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
-      if (screen->dri2.loader->flushFrontBuffer != NULL &&
-          driDrawable &&
+      if (flushFront(screen) && driDrawable &&
           driDrawable->loaderPrivate) {
 
          /* Resolve before flushing FAKE_FRONT_LEFT to FRONT_LEFT.
@@ -174,8 +186,7 @@ intel_flush_front(struct gl_context *ctx)
          intel_resolve_for_dri2_flush(brw, driDrawable);
          intel_batchbuffer_flush(brw);
 
-         screen->dri2.loader->flushFrontBuffer(driDrawable,
-                                               driDrawable->loaderPrivate);
+         flushFront(screen)(driDrawable, driDrawable->loaderPrivate);
 
          /* We set the dirty bit in intel_prepare_render() if we're
           * front buffer rendering once we get there.
@@ -220,10 +231,8 @@ brw_init_driver_functions(struct brw_context *brw,
     * So EGL still relies on viewport hacks to handle window resizing.
     * This should go away with DRI3000.
     */
-   if (!brw->driContext->driScreenPriv->dri2.useInvalidate) {
-      brw->saved_viewport = functions->Viewport;
+   if (!brw->driContext->driScreenPriv->dri2.useInvalidate)
       functions->Viewport = intel_viewport;
-   }
 
    functions->Flush = intel_glFlush;
    functions->Finish = intelFinish;
@@ -268,6 +277,56 @@ brw_init_driver_functions(struct brw_context *brw,
       functions->GetSamplePosition = gen6_get_sample_position;
 }
 
+/**
+ * Return array of MSAA modes supported by the hardware. The array is
+ * zero-terminated and sorted in decreasing order.
+ */
+static const int*
+brw_supported_msaa_modes(const struct brw_context *brw)
+{
+   static const int gen7_samples[] = {8, 4, 0};
+   static const int gen6_samples[] = {4, 0};
+   static const int gen4_samples[] = {0};
+   if (brw->gen >= 7) {
+      return gen7_samples;
+   } else if (brw->gen == 6) {
+      return gen6_samples;
+   } else {
+      return gen4_samples;
+   }
+}
+
+/**
+ * Override GL_MAX_SAMPLES and related constants according to value of driconf
+ * option 'clamp_max_samples'.
+ */
+static void
+brw_override_max_samples(struct brw_context *brw)
+{
+   const int clamp_max_samples = driQueryOptioni(&brw->optionCache,
+                                                 "clamp_max_samples");
+   if (clamp_max_samples < 0)
+      return;
+
+   const int *supported_msaa_modes = brw_supported_msaa_modes(brw);
+   int max_samples = 0;
+
+   /* Select the largest supported MSAA mode that does not exceed
+    * clamp_max_samples.
+    */
+   for (int i = 0; supported_msaa_modes[i] != 0; ++i) {
+      if (supported_msaa_modes[i] <= clamp_max_samples) {
+         max_samples = supported_msaa_modes[i];
+         break;
+      }
+   }
+
+   brw->ctx.Const.MaxSamples = max_samples;
+   brw->ctx.Const.MaxColorTextureSamples = max_samples;
+   brw->ctx.Const.MaxDepthTextureSamples = max_samples;
+   brw->ctx.Const.MaxIntegerSamples = max_samples;
+}
+
 static void
 brw_initialize_context_constants(struct brw_context *brw)
 {
@@ -333,18 +392,14 @@ brw_initialize_context_constants(struct brw_context *brw)
 
    ctx->Const.AlwaysUseGetTransformFeedbackVertexCount = true;
 
-   if (brw->gen == 6) {
-      ctx->Const.MaxSamples = 4;
-      ctx->Const.MaxColorTextureSamples = 4;
-      ctx->Const.MaxDepthTextureSamples = 4;
-      ctx->Const.MaxIntegerSamples = 4;
-   } else if (brw->gen >= 7) {
-      ctx->Const.MaxSamples = 8;
-      ctx->Const.MaxColorTextureSamples = 8;
-      ctx->Const.MaxDepthTextureSamples = 8;
-      ctx->Const.MaxIntegerSamples = 8;
+   const int max_samples = brw_supported_msaa_modes(brw)[0];
+   ctx->Const.MaxSamples = max_samples;
+   ctx->Const.MaxColorTextureSamples = max_samples;
+   ctx->Const.MaxDepthTextureSamples = max_samples;
+   ctx->Const.MaxIntegerSamples = max_samples;
+
+   if (brw->gen >= 7)
       ctx->Const.MaxProgramTextureGatherComponents = 4;
-   }
 
    ctx->Const.MinLineWidth = 1.0;
    ctx->Const.MinLineWidthAA = 1.0;
@@ -397,6 +452,16 @@ brw_initialize_context_constants(struct brw_context *brw)
    ctx->Const.FragmentProgram.HighInt = ctx->Const.FragmentProgram.LowInt;
    ctx->Const.FragmentProgram.MediumInt = ctx->Const.FragmentProgram.LowInt;
 
+   if (brw->gen >= 7) {
+      ctx->Const.FragmentProgram.MaxAtomicCounters = MAX_ATOMIC_COUNTERS;
+      ctx->Const.VertexProgram.MaxAtomicCounters = MAX_ATOMIC_COUNTERS;
+      ctx->Const.GeometryProgram.MaxAtomicCounters = MAX_ATOMIC_COUNTERS;
+      ctx->Const.FragmentProgram.MaxAtomicBuffers = BRW_MAX_ABO;
+      ctx->Const.VertexProgram.MaxAtomicBuffers = BRW_MAX_ABO;
+      ctx->Const.GeometryProgram.MaxAtomicBuffers = BRW_MAX_ABO;
+      ctx->Const.MaxCombinedAtomicBuffers = 3 * BRW_MAX_ABO;
+   }
+
    /* Gen6 converts quads to polygon in beginning of 3D pipeline,
     * but we're not sure how it's actually done for vertex order,
     * that affect provoking vertex decision. Always use last vertex
@@ -506,13 +571,14 @@ brw_process_driconf_options(struct brw_context *brw)
       driQueryOptionb(options, "disable_glsl_line_continuations");
 }
 
-bool
+GLboolean
 brwCreateContext(gl_api api,
 	         const struct gl_config *mesaVis,
 		 __DRIcontext *driContextPriv,
                  unsigned major_version,
                  unsigned minor_version,
                  uint32_t flags,
+                 bool notify_reset,
                  unsigned *dri_ctx_error,
 	         void *sharedContextPrivate)
 {
@@ -523,6 +589,13 @@ brwCreateContext(gl_api api,
    struct dd_function_table functions;
    struct gl_config visual;
 
+   if (flags & ~(__DRI_CTX_FLAG_DEBUG
+                 | __DRI_CTX_FLAG_FORWARD_COMPATIBLE
+                 | __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS)) {
+      *dri_ctx_error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return false;
+   }
+
    struct brw_context *brw = rzalloc(NULL, struct brw_context);
    if (!brw) {
       printf("%s: failed to alloc context\n", __FUNCTION__);
@@ -565,6 +638,9 @@ brwCreateContext(gl_api api,
 
    brw_init_driver_functions(brw, &functions);
 
+   if (notify_reset)
+      functions.GetGraphicsResetStatus = brw_get_graphics_reset_status;
+
    struct gl_context *ctx = &brw->ctx;
 
    if (mesaVis == NULL) {
@@ -606,6 +682,9 @@ brwCreateContext(gl_api api,
    brw_process_intel_debug_variable(brw);
    brw_initialize_context_constants(brw);
 
+   ctx->Const.ResetStrategy = notify_reset
+      ? GL_LOSE_CONTEXT_ON_RESET_ARB : GL_NO_RESET_NOTIFICATION_ARB;
+
    /* Reinitialize the context point state.  It depends on ctx->Const values. */
    _mesa_init_point(ctx);
 
@@ -634,6 +713,19 @@ brwCreateContext(gl_api api,
       }
    }
 
+   /* Notification of GPU resets requires hardware contexts and a kernel new
+    * enough to support DRM_IOCTL_I915_GET_RESET_STATS, which isn't upstream
+    * yet.
+    */
+   if (notify_reset) {
+      /* This is the wrong error code, but the correct error code (one that
+       * will cause EGL to generate EGL_BAD_MATCH) doesn't seem to exist.
+       */
+      *dri_ctx_error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      intelDestroyContext(driContextPriv);
+      return false;
+   }
+
    brw_init_surface_formats(brw);
 
    if (brw->is_g4x || brw->gen >= 5) {
@@ -688,6 +780,9 @@ brwCreateContext(gl_api api,
       brw->perf_debug = true;
    }
 
+   if ((flags & __DRI_CTX_FLAG_ROBUST_BUFFER_ACCESS) != 0)
+      ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB;
+
    brw_fs_alloc_reg_sets(brw);
    brw_vec4_alloc_reg_set(brw);
 
@@ -696,13 +791,15 @@ brwCreateContext(gl_api api,
 
    _mesa_compute_version(ctx);
 
+   /* Here we override context constants. We apply the overrides after
+    * calculation of the context version because we do not want the overridden
+    * constants to change the version.
+    */
+   brw_override_max_samples(brw);
+
    _mesa_initialize_dispatch_tables(ctx);
    _mesa_initialize_vbo_vtxfmt(ctx);
 
-   if (ctx->Extensions.AMD_performance_monitor) {
-      brw_init_performance_monitors(brw);
-   }
-
    return true;
 }
 
@@ -929,12 +1026,14 @@ intel_process_dri2_buffer(struct brw_context *brw,
                           struct intel_renderbuffer *rb,
                           const char *buffer_name);
 
-void
-intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
+static void
+intel_update_image_buffers(struct brw_context *brw, __DRIdrawable *drawable);
+
+static void
+intel_update_dri2_buffers(struct brw_context *brw, __DRIdrawable *drawable)
 {
    struct gl_framebuffer *fb = drawable->driverPrivate;
    struct intel_renderbuffer *rb;
-   struct brw_context *brw = context->driverPrivate;
    __DRIbuffer *buffers = NULL;
    int i, count;
    const char *region_name;
@@ -984,6 +1083,27 @@ intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
        intel_process_dri2_buffer(brw, drawable, &buffers[i], rb, region_name);
    }
 
+}
+
+void
+intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
+{
+   struct brw_context *brw = context->driverPrivate;
+   __DRIscreen *screen = brw->intelScreen->driScrnPriv;
+
+   /* Set this up front, so that in case our buffers get invalidated
+    * while we're getting new buffers, we don't clobber the stamp and
+    * thus ignore the invalidate. */
+   drawable->lastStamp = drawable->dri2.stamp;
+
+   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
+      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);
+
+   if (screen->image.loader)
+      intel_update_image_buffers(brw, drawable);
+   else
+      intel_update_dri2_buffers(brw, drawable);
+
    driUpdateFramebufferSize(&brw->ctx, drawable);
 }
 
@@ -1188,3 +1308,100 @@ intel_process_dri2_buffer(struct brw_context *brw,
                                                  region);
    intel_region_release(&region);
 }
+
+/**
+ * \brief Query DRI image loader to obtain a DRIdrawable's buffers.
+ *
+ * To determine which DRI buffers to request, examine the renderbuffers
+ * attached to the drawable's framebuffer. Then request the buffers from
+ * the image loader
+ *
+ * This is called from intel_update_renderbuffers().
+ *
+ * \param drawable      Drawable whose buffers are queried.
+ * \param buffers       [out] List of buffers returned by DRI2 query.
+ * \param buffer_count  [out] Number of buffers returned.
+ *
+ * \see intel_update_renderbuffers()
+ */
+
+static void
+intel_update_image_buffer(struct brw_context *intel,
+                          __DRIdrawable *drawable,
+                          struct intel_renderbuffer *rb,
+                          __DRIimage *buffer,
+                          enum __DRIimageBufferMask buffer_type)
+{
+   struct intel_region *region = buffer->region;
+
+   if (!rb || !region)
+      return;
+
+   unsigned num_samples = rb->Base.Base.NumSamples;
+
+   if (rb->mt &&
+       rb->mt->region &&
+       rb->mt->region == region)
+      return;
+
+   intel_miptree_release(&rb->mt);
+   rb->mt = intel_miptree_create_for_image_buffer(intel,
+                                                  buffer_type,
+                                                  intel_rb_format(rb),
+                                                  num_samples,
+                                                  region);
+}
+
+static void
+intel_update_image_buffers(struct brw_context *brw, __DRIdrawable *drawable)
+{
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+   __DRIscreen *screen = brw->intelScreen->driScrnPriv;
+   struct intel_renderbuffer *front_rb;
+   struct intel_renderbuffer *back_rb;
+   struct __DRIimageList images;
+   unsigned int format;
+   uint32_t buffer_mask = 0;
+
+   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
+
+   if (back_rb)
+      format = intel_rb_format(back_rb);
+   else if (front_rb)
+      format = intel_rb_format(front_rb);
+   else
+      return;
+
+   if ((brw->is_front_buffer_rendering || brw->is_front_buffer_reading || !back_rb) && front_rb)
+      buffer_mask |= __DRI_IMAGE_BUFFER_FRONT;
+
+   if (back_rb)
+      buffer_mask |= __DRI_IMAGE_BUFFER_BACK;
+
+   (*screen->image.loader->getBuffers) (drawable,
+                                        driGLFormatToImageFormat(format),
+                                        &drawable->dri2.stamp,
+                                        drawable->loaderPrivate,
+                                        buffer_mask,
+                                        &images);
+
+   if (images.image_mask & __DRI_IMAGE_BUFFER_FRONT) {
+      drawable->w = images.front->width;
+      drawable->h = images.front->height;
+      intel_update_image_buffer(brw,
+                                drawable,
+                                front_rb,
+                                images.front,
+                                __DRI_IMAGE_BUFFER_FRONT);
+   }
+   if (images.image_mask & __DRI_IMAGE_BUFFER_BACK) {
+      drawable->w = images.back->width;
+      drawable->h = images.back->height;
+      intel_update_image_buffer(brw,
+                                drawable,
+                                back_rb,
+                                images.back,
+                                __DRI_IMAGE_BUFFER_BACK);
+   }
+}
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index bec4d6b..8b1cbb3 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -151,7 +151,6 @@ struct brw_vs_prog_key;
 struct brw_vec4_prog_key;
 struct brw_wm_prog_key;
 struct brw_wm_prog_data;
-struct brw_perf_bo_layout;
 
 enum brw_state_id {
    BRW_STATE_URB_FENCE,
@@ -976,12 +975,6 @@ struct brw_context
 					  unsigned unit);
       void (*update_null_renderbuffer_surface)(struct brw_context *brw,
 					       unsigned unit);
-      void (*create_constant_surface)(struct brw_context *brw,
-				      drm_intel_bo *bo,
-				      uint32_t offset,
-				      uint32_t size,
-				      uint32_t *out_offset,
-                                      bool dword_pitch);
 
       void (*create_raw_surface)(struct brw_context *brw,
                                  drm_intel_bo *bo,
@@ -989,6 +982,15 @@ struct brw_context
                                  uint32_t size,
                                  uint32_t *out_offset,
                                  bool rw);
+      void (*emit_buffer_surface_state)(struct brw_context *brw,
+                                        uint32_t *out_offset,
+                                        drm_intel_bo *bo,
+                                        unsigned buffer_offset,
+                                        unsigned surface_format,
+                                        unsigned buffer_size,
+                                        unsigned pitch,
+                                        unsigned mocs,
+                                        bool rw);
 
       /** Upload a SAMPLER_STATE table. */
       void (*upload_sampler_state_table)(struct brw_context *brw,
@@ -1017,6 +1019,14 @@ struct brw_context
 
    drm_intel_context *hw_ctx;
 
+   /**
+    * Number of resets observed in the system at context creation.
+    *
+    * This is tracked in the context so that we can determine that another
+    * reset has occured.
+    */
+   uint32_t reset_count;
+
    struct intel_batchbuffer batch;
    bool no_batch_wrap;
 
@@ -1377,16 +1387,6 @@ struct brw_context
       bool begin_emitted;
    } query;
 
-   struct {
-      /* A map describing which counters are stored at a particular 32-bit
-       * offset in the buffer object.
-       */
-      const struct brw_perf_bo_layout *bo_layout;
-
-      /* Number of 32-bit entries in the buffer object. */
-      int entries_in_bo;
-   } perfmon;
-
    int num_atoms;
    const struct brw_tracked_state **atoms;
 
@@ -1442,8 +1442,6 @@ struct brw_context
 
    __DRIcontext *driContext;
    struct intel_screen *intelScreen;
-   void (*saved_viewport)(struct gl_context *ctx,
-                          GLint x, GLint y, GLsizei width, GLsizei height);
 };
 
 static INLINE bool
@@ -1463,6 +1461,10 @@ extern void intelInitClearFuncs(struct dd_function_table *functions);
 /*======================================================================
  * brw_context.c
  */
+extern const char *const brw_vendor_string;
+
+extern const char *brw_get_renderer_string(unsigned deviceID);
+
 extern void intelFinish(struct gl_context * ctx);
 
 enum {
@@ -1477,12 +1479,13 @@ void intel_prepare_render(struct brw_context *brw);
 void intel_resolve_for_dri2_flush(struct brw_context *brw,
                                   __DRIdrawable *drawable);
 
-bool brwCreateContext(gl_api api,
+GLboolean brwCreateContext(gl_api api,
 		      const struct gl_config *mesaVis,
 		      __DRIcontext *driContextPriv,
                       unsigned major_version,
                       unsigned minor_version,
                       uint32_t flags,
+                      bool notify_reset,
                       unsigned *error,
 		      void *sharedContextPrivate);
 
@@ -1570,6 +1573,15 @@ unsigned brw_get_index_type(GLenum type);
 
 /* brw_wm_surface_state.c */
 void brw_init_surface_formats(struct brw_context *brw);
+void brw_create_constant_surface(struct brw_context *brw,
+                                 drm_intel_bo *bo,
+                                 uint32_t offset,
+                                 uint32_t size,
+                                 uint32_t *out_offset,
+                                 bool dword_pitch);
+void brw_update_buffer_texture_surface(struct gl_context *ctx,
+                                       unsigned unit,
+                                       uint32_t *surf_offset);
 void
 brw_update_sol_surface(struct brw_context *brw,
                        struct gl_buffer_object *buffer_obj,
@@ -1589,9 +1601,6 @@ bool brw_is_hiz_depth_format(struct brw_context *ctx, gl_format format);
 bool brw_render_target_supported(struct brw_context *brw,
                                  struct gl_renderbuffer *rb);
 
-/* brw_performance_monitor.c */
-void brw_init_performance_monitors(struct brw_context *brw);
-
 /* intel_extensions.c */
 extern void intelInitExtensions(struct gl_context *ctx);
 
@@ -1677,6 +1686,9 @@ gen7_emit_urb_state(struct brw_context *brw,
                     unsigned gs_size, unsigned gs_start);
 
 
+/* brw_reset.c */
+extern GLenum
+brw_get_graphics_reset_status(struct gl_context *ctx);
 
 /*======================================================================
  * Inline conversion functions.  These are better-typed than the
diff --git a/src/mesa/drivers/dri/i965/brw_defines.h b/src/mesa/drivers/dri/i965/brw_defines.h
index bfea88a..e64d638 100644
--- a/src/mesa/drivers/dri/i965/brw_defines.h
+++ b/src/mesa/drivers/dri/i965/brw_defines.h
@@ -885,6 +885,77 @@ enum opcode {
    GS_OPCODE_SET_CHANNEL_MASKS,
 };
 
+enum brw_urb_write_flags {
+   BRW_URB_WRITE_NO_FLAGS = 0,
+
+   /**
+    * Causes a new URB entry to be allocated, and its address stored in the
+    * destination register (gen < 7).
+    */
+   BRW_URB_WRITE_ALLOCATE = 0x1,
+
+   /**
+    * Causes the current URB entry to be deallocated (gen < 7).
+    */
+   BRW_URB_WRITE_UNUSED = 0x2,
+
+   /**
+    * Causes the thread to terminate.
+    */
+   BRW_URB_WRITE_EOT = 0x4,
+
+   /**
+    * Indicates that the given URB entry is complete, and may be sent further
+    * down the 3D pipeline (gen < 7).
+    */
+   BRW_URB_WRITE_COMPLETE = 0x8,
+
+   /**
+    * Indicates that an additional offset (which may be different for the two
+    * vec4 slots) is stored in the message header (gen == 7).
+    */
+   BRW_URB_WRITE_PER_SLOT_OFFSET = 0x10,
+
+   /**
+    * Indicates that the channel masks in the URB_WRITE message header should
+    * not be overridden to 0xff (gen == 7).
+    */
+   BRW_URB_WRITE_USE_CHANNEL_MASKS = 0x20,
+
+   /**
+    * Indicates that the data should be sent to the URB using the
+    * URB_WRITE_OWORD message rather than URB_WRITE_HWORD (gen == 7).  This
+    * causes offsets to be interpreted as multiples of an OWORD instead of an
+    * HWORD, and only allows one OWORD to be written.
+    */
+   BRW_URB_WRITE_OWORD = 0x40,
+
+   /**
+    * Convenient combination of flags: end the thread while simultaneously
+    * marking the given URB entry as complete.
+    */
+   BRW_URB_WRITE_EOT_COMPLETE = BRW_URB_WRITE_EOT | BRW_URB_WRITE_COMPLETE,
+
+   /**
+    * Convenient combination of flags: mark the given URB entry as complete
+    * and simultaneously allocate a new one.
+    */
+   BRW_URB_WRITE_ALLOCATE_COMPLETE =
+      BRW_URB_WRITE_ALLOCATE | BRW_URB_WRITE_COMPLETE,
+};
+
+#ifdef __cplusplus
+/**
+ * Allow brw_urb_write_flags enums to be ORed together.
+ */
+inline brw_urb_write_flags
+operator|(brw_urb_write_flags x, brw_urb_write_flags y)
+{
+   return static_cast<brw_urb_write_flags>(static_cast<int>(x) |
+                                           static_cast<int>(y));
+}
+#endif
+
 #define BRW_PREDICATE_NONE             0
 #define BRW_PREDICATE_NORMAL           1
 #define BRW_PREDICATE_ALIGN1_ANYV             2
diff --git a/src/mesa/drivers/dri/i965/brw_draw_upload.c b/src/mesa/drivers/dri/i965/brw_draw_upload.c
index 4da1b7e..57b81df 100644
--- a/src/mesa/drivers/dri/i965/brw_draw_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_draw_upload.c
@@ -244,6 +244,8 @@ brw_get_vertex_surface_type(struct brw_context *brw,
       case GL_UNSIGNED_BYTE: return ubyte_types_direct[size];
       default: assert(0); return 0;
       }
+   } else if (glarray->Type == GL_UNSIGNED_INT_10F_11F_11F_REV) {
+      return BRW_SURFACEFORMAT_R11G11B10_FLOAT;
    } else if (glarray->Normalized) {
       switch (glarray->Type) {
       case GL_DOUBLE: return double_types[size];
@@ -607,6 +609,7 @@ static void brw_prepare_vertices(struct brw_context *brw)
 
 static void brw_emit_vertices(struct brw_context *brw)
 {
+   struct gl_context *ctx = &brw->ctx;
    GLuint i, nr_elements;
 
    brw_prepare_vertices(brw);
@@ -678,6 +681,9 @@ static void brw_emit_vertices(struct brw_context *brw)
          if (brw->gen == 7)
 	    dw0 |= GEN7_MOCS_L3 << 16;
 
+         WARN_ONCE(buffer->stride >= (brw->gen >= 5 ? 2048 : 2047),
+                   "VBO stride %d too large, bad rendering may occur\n",
+                   buffer->stride);
 	 OUT_BATCH(dw0 | (buffer->stride << BRW_VB0_PITCH_SHIFT));
 	 OUT_RELOC(buffer->bo, I915_GEM_DOMAIN_VERTEX, 0, buffer->offset);
 	 if (brw->gen >= 5) {
diff --git a/src/mesa/drivers/dri/i965/brw_eu.h b/src/mesa/drivers/dri/i965/brw_eu.h
index 01f8bcc..a6a65ca 100644
--- a/src/mesa/drivers/dri/i965/brw_eu.h
+++ b/src/mesa/drivers/dri/i965/brw_eu.h
@@ -228,77 +228,6 @@ void brw_set_dp_write_message(struct brw_compile *p,
 			      GLuint end_of_thread,
 			      GLuint send_commit_msg);
 
-enum brw_urb_write_flags {
-   BRW_URB_WRITE_NO_FLAGS = 0,
-
-   /**
-    * Causes a new URB entry to be allocated, and its address stored in the
-    * destination register (gen < 7).
-    */
-   BRW_URB_WRITE_ALLOCATE = 0x1,
-
-   /**
-    * Causes the current URB entry to be deallocated (gen < 7).
-    */
-   BRW_URB_WRITE_UNUSED = 0x2,
-
-   /**
-    * Causes the thread to terminate.
-    */
-   BRW_URB_WRITE_EOT = 0x4,
-
-   /**
-    * Indicates that the given URB entry is complete, and may be sent further
-    * down the 3D pipeline (gen < 7).
-    */
-   BRW_URB_WRITE_COMPLETE = 0x8,
-
-   /**
-    * Indicates that an additional offset (which may be different for the two
-    * vec4 slots) is stored in the message header (gen == 7).
-    */
-   BRW_URB_WRITE_PER_SLOT_OFFSET = 0x10,
-
-   /**
-    * Indicates that the channel masks in the URB_WRITE message header should
-    * not be overridden to 0xff (gen == 7).
-    */
-   BRW_URB_WRITE_USE_CHANNEL_MASKS = 0x20,
-
-   /**
-    * Indicates that the data should be sent to the URB using the
-    * URB_WRITE_OWORD message rather than URB_WRITE_HWORD (gen == 7).  This
-    * causes offsets to be interpreted as multiples of an OWORD instead of an
-    * HWORD, and only allows one OWORD to be written.
-    */
-   BRW_URB_WRITE_OWORD = 0x40,
-
-   /**
-    * Convenient combination of flags: end the thread while simultaneously
-    * marking the given URB entry as complete.
-    */
-   BRW_URB_WRITE_EOT_COMPLETE = BRW_URB_WRITE_EOT | BRW_URB_WRITE_COMPLETE,
-
-   /**
-    * Convenient combination of flags: mark the given URB entry as complete
-    * and simultaneously allocate a new one.
-    */
-   BRW_URB_WRITE_ALLOCATE_COMPLETE =
-      BRW_URB_WRITE_ALLOCATE | BRW_URB_WRITE_COMPLETE,
-};
-
-#ifdef __cplusplus
-/**
- * Allow brw_urb_write_flags enums to be ORed together.
- */
-inline brw_urb_write_flags
-operator|(brw_urb_write_flags x, brw_urb_write_flags y)
-{
-   return static_cast<brw_urb_write_flags>(static_cast<int>(x) |
-                                           static_cast<int>(y));
-}
-#endif
-
 void brw_urb_WRITE(struct brw_compile *p,
 		   struct brw_reg dest,
 		   GLuint msg_reg_nr,
diff --git a/src/mesa/drivers/dri/i965/brw_fs.cpp b/src/mesa/drivers/dri/i965/brw_fs.cpp
index 7caa52d..8b3f8df 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs.cpp
@@ -193,11 +193,11 @@ fs_visitor::IF(uint32_t predicate)
    return inst;
 }
 
-/** Gen6+ IF with embedded comparison. */
+/** Gen6 IF with embedded comparison. */
 fs_inst *
 fs_visitor::IF(fs_reg src0, fs_reg src1, uint32_t condition)
 {
-   assert(brw->gen >= 6);
+   assert(brw->gen == 6);
    fs_inst *inst = new(mem_ctx) fs_inst(BRW_OPCODE_IF,
                                         reg_null_d, src0, src1);
    inst->conditional_mod = condition;
@@ -691,19 +691,6 @@ fs_visitor::pop_force_uncompressed()
    assert(force_uncompressed_stack >= 0);
 }
 
-void
-fs_visitor::push_force_sechalf()
-{
-   force_sechalf_stack++;
-}
-
-void
-fs_visitor::pop_force_sechalf()
-{
-   force_sechalf_stack--;
-   assert(force_sechalf_stack >= 0);
-}
-
 /**
  * Returns true if the instruction has a flag that means it won't
  * update an entire destination register.
@@ -2059,7 +2046,7 @@ fs_visitor::dead_code_eliminate()
    foreach_list_safe(node, &this->instructions) {
       fs_inst *inst = (fs_inst *)node;
 
-      if (inst->dst.file == GRF) {
+      if (inst->dst.file == GRF && !inst->has_side_effects()) {
          bool dead = true;
 
          for (int i = 0; i < inst->regs_written; i++) {
@@ -2220,31 +2207,26 @@ fs_visitor::dead_code_eliminate_local()
                get_dead_code_hash_entry(ht, inst->dst.reg,
                                         inst->dst.reg_offset);
 
-            if (inst->is_partial_write()) {
-               /* For a partial write, we can't remove any previous dead code
-                * candidate, since we're just modifying their result, but we can
-                * be dead code eliminiated ourselves.
-                */
-               if (entry) {
-                  entry->data = inst;
+            if (entry) {
+               if (inst->is_partial_write()) {
+                  /* For a partial write, we can't remove any previous dead code
+                   * candidate, since we're just modifying their result.
+                   */
                } else {
-                  insert_dead_code_hash(ht, inst->dst.reg, inst->dst.reg_offset,
-                                        inst);
-               }
-            } else {
-               if (entry) {
                   /* We're completely updating a channel, and there was a
                    * previous write to the channel that wasn't read.  Kill it!
                    */
                   fs_inst *inst = (fs_inst *)entry->data;
                   inst->remove();
                   progress = true;
-                  _mesa_hash_table_remove(ht, entry);
                }
 
+               _mesa_hash_table_remove(ht, entry);
+            }
+
+            if (!inst->has_side_effects())
                insert_dead_code_hash(ht, inst->dst.reg, inst->dst.reg_offset,
                                      inst);
-            }
          }
       }
    }
@@ -3233,7 +3215,7 @@ fs_visitor::run()
       /* We handle discards by keeping track of the still-live pixels in f0.1.
        * Initialize it with the dispatched pixels.
        */
-      if (fp->UsesKill) {
+      if (fp->UsesKill || c->key.alpha_test_func) {
          fs_inst *discard_init = emit(FS_OPCODE_MOV_DISPATCH_TO_FLAGS);
          discard_init->flag_subreg = 1;
       }
@@ -3257,6 +3239,9 @@ fs_visitor::run()
 
       emit(FS_OPCODE_PLACEHOLDER_HALT);
 
+      if (c->key.alpha_test_func)
+         emit_alpha_test();
+
       emit_fb_writes();
 
       split_virtual_grfs();
@@ -3283,24 +3268,36 @@ fs_visitor::run()
 	 progress = compute_to_mrf() || progress;
       } while (progress);
 
-      schedule_instructions(false);
-
       lower_uniform_pull_constant_loads();
 
       assign_curb_setup();
       assign_urb_setup();
 
+      schedule_instructions(SCHEDULE_PRE_NON_LIFO);
+
       if (0)
 	 assign_regs_trivial();
       else {
-	 while (!assign_regs()) {
-	    if (failed)
-	       break;
-	 }
+         if (!assign_regs(false)) {
+            /* Try a non-spilling register allocation again with a different
+             * scheduling heuristic.
+             */
+            schedule_instructions(SCHEDULE_PRE_LIFO);
+            if (!assign_regs(false)) {
+               if (dispatch_width == 16) {
+                  fail("Failure to register allocate.  Reduce number of "
+                       "live scalar values to avoid this.");
+               } else {
+                  while (!assign_regs(true)) {
+                     if (failed)
+                        break;
+                  }
+               }
+            }
+         }
       }
    }
    assert(force_uncompressed_stack == 0);
-   assert(force_sechalf_stack == 0);
 
    /* This must come after all optimization and register allocation, since
     * it inserts dead code that happens to have side effects, and it does
@@ -3311,7 +3308,7 @@ fs_visitor::run()
    if (failed)
       return false;
 
-   schedule_instructions(true);
+   schedule_instructions(SCHEDULE_POST);
 
    if (dispatch_width == 8) {
       c->prog_data.reg_blocks = brw_register_blocks(grf_used);
diff --git a/src/mesa/drivers/dri/i965/brw_fs.h b/src/mesa/drivers/dri/i965/brw_fs.h
index e9bf52f..7991b87 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.h
+++ b/src/mesa/drivers/dri/i965/brw_fs.h
@@ -291,7 +291,7 @@ public:
    void assign_curb_setup();
    void calculate_urb_setup();
    void assign_urb_setup();
-   bool assign_regs();
+   bool assign_regs(bool allow_spilling);
    void assign_regs_trivial();
    void get_used_mrfs(bool *mrf_used);
    void setup_payload_interference(struct ra_graph *g, int payload_reg_count,
@@ -322,7 +322,7 @@ public:
    bool remove_dead_constants();
    bool remove_duplicate_mrf_writes();
    bool virtual_grf_interferes(int a, int b);
-   void schedule_instructions(bool post_reg_alloc);
+   void schedule_instructions(instruction_scheduler_mode mode);
    void insert_gen4_send_dependency_workarounds();
    void insert_gen4_pre_send_dependency_workarounds(fs_inst *inst);
    void insert_gen4_post_send_dependency_workarounds(fs_inst *inst);
@@ -331,8 +331,6 @@ public:
 
    void push_force_uncompressed();
    void pop_force_uncompressed();
-   void push_force_sechalf();
-   void pop_force_sechalf();
 
    void emit_dummy_fs();
    fs_reg *emit_fragcoord_interpolation(ir_variable *ir);
@@ -394,6 +392,7 @@ public:
                     fs_reg dst, fs_reg src0, fs_reg src1, fs_reg one);
 
    void emit_color_write(int target, int index, int first_color_mrf);
+   void emit_alpha_test();
    void emit_fb_writes();
 
    void emit_shader_time_begin();
@@ -401,6 +400,13 @@ public:
    void emit_shader_time_write(enum shader_time_shader_type type,
                                fs_reg value);
 
+   void emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
+                            fs_reg dst, fs_reg offset, fs_reg src0,
+                            fs_reg src1);
+
+   void emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
+                                  fs_reg offset);
+
    bool try_rewrite_rhs_to_dst(ir_assignment *ir,
 			       fs_reg dst,
 			       fs_reg src,
@@ -420,6 +426,8 @@ public:
 
    void dump_instruction(backend_instruction *inst);
 
+   void visit_atomic_counter_intrinsic(ir_call *ir);
+
    struct gl_fragment_program *fp;
    struct brw_wm_compile *c;
    unsigned int sanity_param_count;
@@ -479,7 +487,6 @@ public:
    const unsigned dispatch_width; /**< 8 or 16 */
 
    int force_uncompressed_stack;
-   int force_sechalf_stack;
 };
 
 /**
@@ -610,3 +617,5 @@ private:
 bool brw_do_channel_expressions(struct exec_list *instructions);
 bool brw_do_vector_splitting(struct exec_list *instructions);
 bool brw_fs_precompile(struct gl_context *ctx, struct gl_shader_program *prog);
+
+struct brw_reg brw_reg_from_fs_reg(fs_reg *reg);
diff --git a/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp b/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
index 5024bed..e154441 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
@@ -418,7 +418,7 @@ ir_channel_expressions_visitor::visit_leave(ir_assignment *ir)
    case ir_unop_unpack_half_2x16_split_x:
    case ir_unop_unpack_half_2x16_split_y:
    case ir_binop_pack_half_2x16_split:
-      assert("!not reached: expression operates on scalars only");
+      assert(!"not reached: expression operates on scalars only");
       break;
    }
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs_cse.cpp b/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
index 4793874..27541db 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
@@ -129,7 +129,8 @@ fs_visitor::opt_cse_local(bblock_t *block, exec_list *aeb)
 	inst = (fs_inst *) inst->next) {
 
       /* Skip some cases. */
-      if (is_expression(inst) && !inst->is_partial_write())
+      if (is_expression(inst) && !inst->is_partial_write() &&
+          (inst->dst.file != HW_REG || inst->dst.is_null()))
       {
 	 bool found = false;
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs_generator.cpp b/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
index d67c4e4..cc58ff2 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
@@ -116,7 +116,7 @@ fs_generator::generate_fb_write(fs_inst *inst)
    brw_set_mask_control(p, BRW_MASK_DISABLE);
    brw_set_compression_control(p, BRW_COMPRESSION_NONE);
 
-   if (fp->UsesKill) {
+   if (fp->UsesKill || c->key.alpha_test_func) {
       struct brw_reg pixel_mask;
 
       if (brw->gen >= 6)
@@ -757,7 +757,7 @@ fs_generator::generate_scratch_write(fs_inst *inst, struct brw_reg src)
 	   retype(brw_message_reg(inst->base_mrf + 1), BRW_REGISTER_TYPE_UD),
 	   retype(src, BRW_REGISTER_TYPE_UD));
    brw_oword_block_write_scratch(p, brw_message_reg(inst->base_mrf),
-                                 inst->mlen, inst->offset);
+                                 dispatch_width / 8, inst->offset);
 }
 
 void
@@ -989,7 +989,7 @@ static uint32_t brw_file_from_reg(fs_reg *reg)
    }
 }
 
-static struct brw_reg
+struct brw_reg
 brw_reg_from_fs_reg(fs_reg *reg)
 {
    struct brw_reg brw_reg;
diff --git a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
index d9e80d0..8567afd 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
@@ -417,7 +417,7 @@ fs_visitor::setup_mrf_hack_interference(struct ra_graph *g, int first_mrf_node)
 }
 
 bool
-fs_visitor::assign_regs()
+fs_visitor::assign_regs(bool allow_spilling)
 {
    /* Most of this allocation was written for a reg_width of 1
     * (dispatch_width == 8).  In extending to 16-wide, the code was
@@ -496,14 +496,10 @@ fs_visitor::assign_regs()
       if (reg == -1) {
          fail("no register to spill:\n");
          dump_instructions();
-      } else if (dispatch_width == 16) {
-	 fail("Failure to register allocate.  Reduce number of live scalar "
-              "values to avoid this.");
-      } else {
-	 spill_reg(reg);
+      } else if (allow_spilling) {
+         spill_reg(reg);
       }
 
-
       ralloc_free(g);
 
       return false;
diff --git a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
index dd60671..9eb9a9d 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
@@ -107,8 +107,11 @@ fs_visitor::visit(ir_variable *ir)
       /* Thanks to the lower_ubo_reference pass, we will see only
        * ir_binop_ubo_load expressions and not ir_dereference_variable for UBO
        * variables, so no need for them to be in variable_ht.
+       *
+       * Atomic counters take no uniform storage, no need to do
+       * anything here.
        */
-      if (ir->is_in_uniform_block())
+      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
          return;
 
       if (dispatch_width == 16) {
@@ -2196,9 +2199,58 @@ fs_visitor::visit(ir_loop_jump *ir)
 }
 
 void
+fs_visitor::visit_atomic_counter_intrinsic(ir_call *ir)
+{
+   ir_dereference *deref = static_cast<ir_dereference *>(
+      ir->actual_parameters.get_head());
+   ir_variable *location = deref->variable_referenced();
+   unsigned surf_index = (c->prog_data.base.binding_table.abo_start +
+                          location->atomic.buffer_index);
+
+   /* Calculate the surface offset */
+   fs_reg offset(this, glsl_type::uint_type);
+   ir_dereference_array *deref_array = deref->as_dereference_array();
+
+   if (deref_array) {
+      deref_array->array_index->accept(this);
+
+      fs_reg tmp(this, glsl_type::uint_type);
+      emit(MUL(tmp, this->result, ATOMIC_COUNTER_SIZE));
+      emit(ADD(offset, tmp, location->atomic.offset));
+   } else {
+      offset = location->atomic.offset;
+   }
+
+   /* Emit the appropriate machine instruction */
+   const char *callee = ir->callee->function_name();
+   ir->return_deref->accept(this);
+   fs_reg dst = this->result;
+
+   if (!strcmp("__intrinsic_atomic_read", callee)) {
+      emit_untyped_surface_read(surf_index, dst, offset);
+
+   } else if (!strcmp("__intrinsic_atomic_increment", callee)) {
+      emit_untyped_atomic(BRW_AOP_INC, surf_index, dst, offset,
+                          fs_reg(), fs_reg());
+
+   } else if (!strcmp("__intrinsic_atomic_predecrement", callee)) {
+      emit_untyped_atomic(BRW_AOP_PREDEC, surf_index, dst, offset,
+                          fs_reg(), fs_reg());
+   }
+}
+
+void
 fs_visitor::visit(ir_call *ir)
 {
-   assert(!"FINISHME");
+   const char *callee = ir->callee->function_name();
+
+   if (!strcmp("__intrinsic_atomic_read", callee) ||
+       !strcmp("__intrinsic_atomic_increment", callee) ||
+       !strcmp("__intrinsic_atomic_predecrement", callee)) {
+      visit_atomic_counter_intrinsic(ir);
+   } else {
+      assert(!"Unsupported intrinsic.");
+   }
 }
 
 void
@@ -2249,6 +2301,84 @@ fs_visitor::visit(ir_end_primitive *)
    assert(!"not reached");
 }
 
+void
+fs_visitor::emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
+                                fs_reg dst, fs_reg offset, fs_reg src0,
+                                fs_reg src1)
+{
+   const unsigned operand_len = dispatch_width / 8;
+   unsigned mlen = 0;
+
+   /* Initialize the sample mask in the message header. */
+   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
+      ->force_writemask_all = true;
+
+   if (fp->UsesKill) {
+      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
+         ->force_writemask_all = true;
+   } else {
+      emit(MOV(brw_uvec_mrf(1, mlen, 7),
+               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
+         ->force_writemask_all = true;
+   }
+
+   mlen++;
+
+   /* Set the atomic operation offset. */
+   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
+   mlen += operand_len;
+
+   /* Set the atomic operation arguments. */
+   if (src0.file != BAD_FILE) {
+      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src0));
+      mlen += operand_len;
+   }
+
+   if (src1.file != BAD_FILE) {
+      emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), src1));
+      mlen += operand_len;
+   }
+
+   /* Emit the instruction. */
+   fs_inst inst(SHADER_OPCODE_UNTYPED_ATOMIC, dst, atomic_op, surf_index);
+   inst.base_mrf = 0;
+   inst.mlen = mlen;
+   emit(inst);
+}
+
+void
+fs_visitor::emit_untyped_surface_read(unsigned surf_index, fs_reg dst,
+                                      fs_reg offset)
+{
+   const unsigned operand_len = dispatch_width / 8;
+   unsigned mlen = 0;
+
+   /* Initialize the sample mask in the message header. */
+   emit(MOV(brw_uvec_mrf(8, mlen, 0), brw_imm_ud(0)))
+      ->force_writemask_all = true;
+
+   if (fp->UsesKill) {
+      emit(MOV(brw_uvec_mrf(1, mlen, 7), brw_flag_reg(0, 1)))
+         ->force_writemask_all = true;
+   } else {
+      emit(MOV(brw_uvec_mrf(1, mlen, 7),
+               retype(brw_vec1_grf(1, 7), BRW_REGISTER_TYPE_UD)))
+         ->force_writemask_all = true;
+   }
+
+   mlen++;
+
+   /* Set the surface read offset. */
+   emit(MOV(brw_uvec_mrf(dispatch_width, mlen, 0), offset));
+   mlen += operand_len;
+
+   /* Emit the instruction. */
+   fs_inst inst(SHADER_OPCODE_UNTYPED_SURFACE_READ, dst, surf_index);
+   inst.base_mrf = 0;
+   inst.mlen = mlen;
+   emit(inst);
+}
+
 fs_inst *
 fs_visitor::emit(fs_inst inst)
 {
@@ -2263,8 +2393,6 @@ fs_visitor::emit(fs_inst *inst)
 {
    if (force_uncompressed_stack > 0)
       inst->force_uncompressed = true;
-   else if (force_sechalf_stack > 0)
-      inst->force_sechalf = true;
 
    inst->annotation = this->current_annotation;
    inst->ir = this->base_ir;
@@ -2469,17 +2597,70 @@ fs_visitor::emit_color_write(int target, int index, int first_color_mrf)
 	 inst->saturate = c->key.clamp_fragment_color;
 	 pop_force_uncompressed();
 
-	 push_force_sechalf();
 	 color.sechalf = true;
 	 inst = emit(MOV(fs_reg(MRF, first_color_mrf + index + 4, color.type),
                          color));
+	 inst->force_sechalf = true;
 	 inst->saturate = c->key.clamp_fragment_color;
-	 pop_force_sechalf();
 	 color.sechalf = false;
       }
    }
 }
 
+static int
+cond_for_alpha_func(GLenum func)
+{
+   switch(func) {
+      case GL_GREATER:
+         return BRW_CONDITIONAL_G;
+      case GL_GEQUAL:
+         return BRW_CONDITIONAL_GE;
+      case GL_LESS:
+         return BRW_CONDITIONAL_L;
+      case GL_LEQUAL:
+         return BRW_CONDITIONAL_LE;
+      case GL_EQUAL:
+         return BRW_CONDITIONAL_EQ;
+      case GL_NOTEQUAL:
+         return BRW_CONDITIONAL_NEQ;
+      default:
+         assert(!"Not reached");
+         return 0;
+   }
+}
+
+/**
+ * Alpha test support for when we compile it into the shader instead
+ * of using the normal fixed-function alpha test.
+ */
+void
+fs_visitor::emit_alpha_test()
+{
+   this->current_annotation = "Alpha test";
+
+   fs_inst *cmp;
+   if (c->key.alpha_test_func == GL_ALWAYS)
+      return;
+
+   if (c->key.alpha_test_func == GL_NEVER) {
+      /* f0.1 = 0 */
+      fs_reg some_reg = fs_reg(retype(brw_vec8_grf(0, 0),
+                                      BRW_REGISTER_TYPE_UW));
+      cmp = emit(CMP(reg_null_f, some_reg, some_reg,
+                     BRW_CONDITIONAL_NEQ));
+   } else {
+      /* RT0 alpha */
+      fs_reg color = outputs[0];
+      color.reg_offset += 3;
+
+      /* f0.1 &= func(color, ref) */
+      cmp = emit(CMP(reg_null_f, color, fs_reg(c->key.alpha_test_ref),
+                     cond_for_alpha_func(c->key.alpha_test_func)));
+   }
+   cmp->predicate = BRW_PREDICATE_NORMAL;
+   cmp->flag_subreg = 1;
+}
+
 void
 fs_visitor::emit_fb_writes()
 {
@@ -2739,7 +2920,6 @@ fs_visitor::fs_visitor(struct brw_context *brw,
    this->nr_params_remap = 0;
 
    this->force_uncompressed_stack = 0;
-   this->force_sechalf_stack = 0;
 
    this->spilled_any_registers = false;
 
diff --git a/src/mesa/drivers/dri/i965/brw_lower_offset_array.cpp b/src/mesa/drivers/dri/i965/brw_lower_offset_array.cpp
index 19e1efe..91c002e 100644
--- a/src/mesa/drivers/dri/i965/brw_lower_offset_array.cpp
+++ b/src/mesa/drivers/dri/i965/brw_lower_offset_array.cpp
@@ -34,26 +34,31 @@
 #include "glsl/glsl_types.h"
 #include "glsl/ir.h"
 #include "glsl/ir_builder.h"
+#include "glsl/ir_rvalue_visitor.h"
 
 using namespace ir_builder;
 
-class brw_lower_offset_array_visitor : public ir_hierarchical_visitor {
+class brw_lower_offset_array_visitor : public ir_rvalue_visitor {
 public:
    brw_lower_offset_array_visitor()
    {
       progress = false;
    }
 
-   ir_visitor_status visit_leave(ir_texture *ir);
+   void handle_rvalue(ir_rvalue **rv);
 
    bool progress;
 };
 
-ir_visitor_status
-brw_lower_offset_array_visitor::visit_leave(ir_texture *ir)
+void
+brw_lower_offset_array_visitor::handle_rvalue(ir_rvalue **rv)
 {
+   if (*rv == NULL || (*rv)->ir_type != ir_type_texture)
+      return;
+
+   ir_texture *ir = (ir_texture *) *rv;
    if (ir->op != ir_tg4 || !ir->offset || !ir->offset->type->is_array())
-      return visit_continue;
+      return;
 
    void *mem_ctx = ralloc_parent(ir);
 
@@ -68,10 +73,9 @@ brw_lower_offset_array_visitor::visit_leave(ir_texture *ir)
       base_ir->insert_before(assign(var, swizzle_w(tex), 1 << i));
    }
 
-   base_ir->replace_with(new (mem_ctx) ir_dereference_variable(var));
+   *rv = new (mem_ctx) ir_dereference_variable(var);
 
    progress = true;
-   return visit_continue;
 }
 
 extern "C" {
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 70b0dbd..454017e 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -338,7 +338,7 @@ brw_workaround_depthstencil_alignment(struct brw_context *brw,
          rebase_depth = true;
 
       /* We didn't even have intra-tile offsets before g45. */
-      if (brw->gen == 4 && !brw->is_g4x) {
+      if (!brw->has_surface_tile_offset) {
          if (tile_x || tile_y)
             rebase_depth = true;
       }
@@ -397,7 +397,7 @@ brw_workaround_depthstencil_alignment(struct brw_context *brw,
       if (stencil_tile_x & 7 || stencil_tile_y & 7)
          rebase_stencil = true;
 
-      if (brw->gen == 4 && !brw->is_g4x) {
+      if (!brw->has_surface_tile_offset) {
          if (stencil_tile_x || stencil_tile_y)
             rebase_stencil = true;
       }
diff --git a/src/mesa/drivers/dri/i965/brw_performance_monitor.c b/src/mesa/drivers/dri/i965/brw_performance_monitor.c
deleted file mode 100644
index 87c4a63..0000000
--- a/src/mesa/drivers/dri/i965/brw_performance_monitor.c
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright © 2012 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file brw_performance_monitor.c
- *
- * Implementation of the GL_AMD_performance_monitor extension.
- *
- * Currently only for Ironlake.
- */
-
-#include <limits.h>
-
-#include "main/bitset.h"
-#include "main/macros.h"
-#include "main/mtypes.h"
-#include "main/performance_monitor.h"
-
-#include "brw_context.h"
-#include "brw_defines.h"
-#include "intel_batchbuffer.h"
-
-/**
- * i965 representation of a performance monitor object.
- */
-struct brw_perf_monitor_object
-{
-   /** The base class. */
-   struct gl_perf_monitor_object base;
-
-   /**
-    * BO containing raw counter data in a hardware specific form.
-    */
-   drm_intel_bo *bo;
-};
-
-/** Downcasting convenience macro. */
-static inline struct brw_perf_monitor_object *
-brw_perf_monitor(struct gl_perf_monitor_object *m)
-{
-   return (struct brw_perf_monitor_object *) m;
-}
-
-#define SECOND_SNAPSHOT_OFFSET_IN_BYTES 2048
-
-/* Two random values used to ensure we're getting valid snapshots. */
-#define FIRST_SNAPSHOT_REPORT_ID  0xd2e9c607
-#define SECOND_SNAPSHOT_REPORT_ID 0xad584b1d
-
-/******************************************************************************/
-
-#define COUNTER(name)           \
-   {                            \
-      .Name = name,             \
-      .Type = GL_UNSIGNED_INT,  \
-      .Minimum = { .u32 =  0 }, \
-      .Maximum = { .u32 = ~0 }, \
-   }
-
-#define GROUP(name, max_active, counter_list)  \
-   {                                           \
-      .Name = name,                            \
-      .MaxActiveCounters = max_active,         \
-      .Counters = counter_list,                \
-      .NumCounters = ARRAY_SIZE(counter_list), \
-   }
-
-struct brw_perf_bo_layout {
-   int group;
-   int counter;
-};
-
-/**
- * Ironlake:
- *  @{
- */
-const static struct gl_perf_monitor_counter gen5_raw_aggregating_counters[] = {
-   COUNTER("cycles the CS unit is starved"),
-   COUNTER("cycles the CS unit is stalled"),
-   COUNTER("cycles the VF unit is starved"),
-   COUNTER("cycles the VF unit is stalled"),
-   COUNTER("cycles the VS unit is starved"),
-   COUNTER("cycles the VS unit is stalled"),
-   COUNTER("cycles the GS unit is starved"),
-   COUNTER("cycles the GS unit is stalled"),
-   COUNTER("cycles the CL unit is starved"),
-   COUNTER("cycles the CL unit is stalled"),
-   COUNTER("cycles the SF unit is starved"),
-   COUNTER("cycles the SF unit is stalled"),
-   COUNTER("cycles the WZ unit is starved"),
-   COUNTER("cycles the WZ unit is stalled"),
-   COUNTER("Z buffer read/write"),
-   COUNTER("cycles each EU was active"),
-   COUNTER("cycles each EU was suspended"),
-   COUNTER("cycles threads loaded all EUs"),
-   COUNTER("cycles filtering active"),
-   COUNTER("cycles PS threads executed"),
-   COUNTER("subspans written to RC"),
-   COUNTER("bytes read for texture reads"),
-   COUNTER("texels returned from sampler"),
-   COUNTER("polygons not culled"),
-   COUNTER("clocks MASF has valid message"),
-   COUNTER("64b writes/reads from RC"),
-   COUNTER("reads on dataport"),
-   COUNTER("clocks MASF has valid msg not consumed by sampler"),
-   COUNTER("cycles any EU is stalled for math"),
-};
-
-const static struct gl_perf_monitor_group gen5_groups[] = {
-   GROUP("Aggregating Counters", INT_MAX, gen5_raw_aggregating_counters),
-};
-
-const static struct brw_perf_bo_layout gen5_perf_bo_layout[] =
-{
-   { -1, -1, }, /* Report ID */
-   { -1, -1, }, /* TIMESTAMP (64-bit) */
-   { -1, -1, }, /* ...second half... */
-   {  0,  0, }, /* cycles the CS unit is starved */
-   {  0,  1, }, /* cycles the CS unit is stalled */
-   {  0,  2, }, /* cycles the VF unit is starved */
-   {  0,  3, }, /* cycles the VF unit is stalled */
-   {  0,  4, }, /* cycles the VS unit is starved */
-   {  0,  5, }, /* cycles the VS unit is stalled */
-   {  0,  6, }, /* cycles the GS unit is starved */
-   {  0,  7, }, /* cycles the GS unit is stalled */
-   {  0,  8, }, /* cycles the CL unit is starved */
-   {  0,  9, }, /* cycles the CL unit is stalled */
-   {  0, 10, }, /* cycles the SF unit is starved */
-   {  0, 11, }, /* cycles the SF unit is stalled */
-   {  0, 12, }, /* cycles the WZ unit is starved */
-   {  0, 13, }, /* cycles the WZ unit is stalled */
-   {  0, 14, }, /* Z buffer read/write */
-   {  0, 15, }, /* cycles each EU was active */
-   {  0, 16, }, /* cycles each EU was suspended */
-   {  0, 17, }, /* cycles threads loaded all EUs */
-   {  0, 18, }, /* cycles filtering active */
-   {  0, 19, }, /* cycles PS threads executed */
-   {  0, 20, }, /* subspans written to RC */
-   {  0, 21, }, /* bytes read for texture reads */
-   {  0, 22, }, /* texels returned from sampler */
-   {  0, 23, }, /* polygons not culled */
-   {  0, 24, }, /* clocks MASF has valid message */
-   {  0, 25, }, /* 64b writes/reads from RC */
-   {  0, 26, }, /* reads on dataport */
-   {  0, 27, }, /* clocks MASF has valid msg not consumed by sampler */
-   {  0, 28, }, /* cycles any EU is stalled for math */
-};
-
-/** @} */
-
-/******************************************************************************/
-
-static void
-snapshot_aggregating_counters(struct brw_context *brw,
-                              drm_intel_bo *bo, uint32_t offset_in_bytes)
-{
-   uint32_t report_id = offset_in_bytes == 0 ? FIRST_SNAPSHOT_REPORT_ID
-                                             : SECOND_SNAPSHOT_REPORT_ID;
-
-   if (brw->gen == 5) {
-      /* Ironlake requires two MI_REPORT_PERF_COUNT commands to write all
-       * the counters.  The report ID is ignored in the second set.
-       */
-      BEGIN_BATCH(6);
-      OUT_BATCH(GEN5_MI_REPORT_PERF_COUNT | GEN5_MI_COUNTER_SET_0);
-      OUT_RELOC(bo,
-                I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
-                offset_in_bytes);
-      OUT_BATCH(report_id);
-
-      OUT_BATCH(GEN5_MI_REPORT_PERF_COUNT | GEN5_MI_COUNTER_SET_1);
-      OUT_RELOC(bo,
-                I915_GEM_DOMAIN_INSTRUCTION, I915_GEM_DOMAIN_INSTRUCTION,
-                offset_in_bytes + 64);
-      OUT_BATCH(report_id);
-      ADVANCE_BATCH();
-   } else {
-      assert(!"Unsupported generation for performance counters.");
-   }
-}
-
-static bool
-aggregating_counters_needed(struct brw_context *brw,
-                            struct gl_perf_monitor_object *m)
-{
-   return m->ActiveGroups[0];
-}
-
-/******************************************************************************/
-
-/**
- * Create a new performance monitor object.
- */
-static struct gl_perf_monitor_object *
-brw_new_perf_monitor(struct gl_context *ctx)
-{
-   return calloc(1, sizeof(struct brw_perf_monitor_object));
-}
-
-/**
- * Delete a performance monitor object.
- */
-static void
-brw_delete_perf_monitor(struct gl_context *ctx, struct gl_perf_monitor_object *m)
-{
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-
-   if (monitor->bo)
-      drm_intel_bo_unreference(monitor->bo);
-
-   free(monitor);
-}
-
-/**
- * Driver hook for glBeginPerformanceMonitorAMD().
- */
-static GLboolean
-brw_begin_perf_monitor(struct gl_context *ctx,
-                       struct gl_perf_monitor_object *m)
-{
-   struct brw_context *brw = brw_context(ctx);
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-
-   /* If the BO already exists, throw it away.  It contains old results
-    * that we're not interested in any more.
-    */
-   if (monitor->bo)
-      drm_intel_bo_unreference(monitor->bo);
-
-   /* Create a new BO. */
-   monitor->bo =
-      drm_intel_bo_alloc(brw->bufmgr, "performance monitor", 4096, 64);
-   drm_intel_bo_map(monitor->bo, true);
-   memset((char *) monitor->bo->virtual, 0xff, 4096);
-   drm_intel_bo_unmap(monitor->bo);
-
-   /* Take a shapshot of all active counters */
-   if (aggregating_counters_needed(brw, m)) {
-      snapshot_aggregating_counters(brw, monitor->bo, 0);
-   }
-
-   return true;
-}
-
-/**
- * Driver hook for glEndPerformanceMonitorAMD().
- */
-static void
-brw_end_perf_monitor(struct gl_context *ctx,
-                     struct gl_perf_monitor_object *m)
-{
-   struct brw_context *brw = brw_context(ctx);
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-   if (aggregating_counters_needed(brw, m)) {
-      snapshot_aggregating_counters(brw, monitor->bo,
-                                    SECOND_SNAPSHOT_OFFSET_IN_BYTES);
-   }
-}
-
-/**
- * Reset a performance monitor, throwing away any results.
- */
-static void
-brw_reset_perf_monitor(struct gl_context *ctx,
-                       struct gl_perf_monitor_object *m)
-{
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-
-   if (monitor->bo) {
-      drm_intel_bo_unreference(monitor->bo);
-      monitor->bo = NULL;
-   }
-
-   if (m->Active) {
-      brw_begin_perf_monitor(ctx, m);
-   }
-}
-
-/**
- * Is a performance monitor result available?
- */
-static GLboolean
-brw_is_perf_monitor_result_available(struct gl_context *ctx,
-                                     struct gl_perf_monitor_object *m)
-{
-   struct brw_context *brw = brw_context(ctx);
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-   return !m->Active && monitor->bo &&
-          !drm_intel_bo_references(brw->batch.bo, monitor->bo) &&
-          !drm_intel_bo_busy(monitor->bo);
-}
-
-/**
- * Get the performance monitor result.
- */
-static void
-brw_get_perf_monitor_result(struct gl_context *ctx,
-                            struct gl_perf_monitor_object *m,
-                            GLsizei data_size,
-                            GLuint *data,
-                            GLint *bytes_written)
-{
-   struct brw_context *brw = brw_context(ctx);
-   struct brw_perf_monitor_object *monitor = brw_perf_monitor(m);
-
-   /* This hook should only be called when results are available. */
-   assert(monitor->bo != NULL);
-
-   drm_intel_bo_map(monitor->bo, false);
-   unsigned *gpu_bo = monitor->bo->virtual;
-
-   /* Copy data from the BO to the supplied array.
-    *
-    * The output data format is: <group ID, counter ID, value> for each
-    * active counter.  The API allows counters to appear in any order.
-    */
-   GLsizei offset = 0;
-
-   /* Look for expected report ID values to ensure data is present. */
-   assert(gpu_bo[0] == FIRST_SNAPSHOT_REPORT_ID);
-   assert(gpu_bo[SECOND_SNAPSHOT_OFFSET_IN_BYTES/4] == SECOND_SNAPSHOT_REPORT_ID);
-
-   for (int i = 0; i < brw->perfmon.entries_in_bo; i++) {
-      int group = brw->perfmon.bo_layout[i].group;
-      int counter = brw->perfmon.bo_layout[i].counter;
-
-      if (group < 0 || !BITSET_TEST(m->ActiveCounters[group], counter))
-         continue;
-
-      const struct gl_perf_monitor_group *group_obj =
-         &ctx->PerfMonitor.Groups[group];
-
-      const struct gl_perf_monitor_counter *c = &group_obj->Counters[counter];
-
-      data[offset++] = group;
-      data[offset++] = counter;
-
-      uint32_t second_snapshot_index =
-         SECOND_SNAPSHOT_OFFSET_IN_BYTES / sizeof(uint32_t) + i;
-
-      /* Won't work for uint64_t values, but we don't expose any yet. */
-      data[offset] = gpu_bo[second_snapshot_index] - gpu_bo[i];
-      offset += _mesa_perf_monitor_counter_size(c) / sizeof(uint32_t);
-   }
-
-   drm_intel_bo_unmap(monitor->bo);
-
-   if (bytes_written)
-      *bytes_written = offset * sizeof(uint32_t);
-}
-
-void
-brw_init_performance_monitors(struct brw_context *brw)
-{
-   struct gl_context *ctx = &brw->ctx;
-
-   ctx->Driver.NewPerfMonitor = brw_new_perf_monitor;
-   ctx->Driver.DeletePerfMonitor = brw_delete_perf_monitor;
-   ctx->Driver.BeginPerfMonitor = brw_begin_perf_monitor;
-   ctx->Driver.EndPerfMonitor = brw_end_perf_monitor;
-   ctx->Driver.ResetPerfMonitor = brw_reset_perf_monitor;
-   ctx->Driver.IsPerfMonitorResultAvailable = brw_is_perf_monitor_result_available;
-   ctx->Driver.GetPerfMonitorResult = brw_get_perf_monitor_result;
-
-   if (brw->gen == 5) {
-      ctx->PerfMonitor.Groups = gen5_groups;
-      ctx->PerfMonitor.NumGroups = ARRAY_SIZE(gen5_groups);
-      brw->perfmon.bo_layout = gen5_perf_bo_layout;
-      brw->perfmon.entries_in_bo = ARRAY_SIZE(gen5_perf_bo_layout);
-   }
-}
diff --git a/src/mesa/drivers/dri/i965/brw_reg.h b/src/mesa/drivers/dri/i965/brw_reg.h
index e9cf892..548d677 100644
--- a/src/mesa/drivers/dri/i965/brw_reg.h
+++ b/src/mesa/drivers/dri/i965/brw_reg.h
@@ -299,6 +299,7 @@ brw_vecn_reg(unsigned width, unsigned file, unsigned nr, unsigned subnr)
    default:
       assert(!"Invalid register width");
    }
+   unreachable();
 }
 
 static inline struct brw_reg
diff --git a/src/mesa/drivers/dri/i965/brw_reset.c b/src/mesa/drivers/dri/i965/brw_reset.c
new file mode 100644
index 0000000..e93b2e2
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/brw_reset.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright © 2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+#include "brw_context.h"
+
+/**
+ * Query information about GPU resets observed by this context
+ *
+ * Called via \c dd_function_table::GetGraphicsResetStatus.
+ */
+GLenum
+brw_get_graphics_reset_status(struct gl_context *ctx)
+{
+   struct brw_context *brw = brw_context(ctx);
+   int err;
+   uint32_t reset_count;
+   uint32_t active;
+   uint32_t pending;
+
+   /* If hardware contexts are not being used (or
+    * DRM_IOCTL_I915_GET_RESET_STATS is not supported), this function should
+    * not be accessible.
+    */
+   assert(brw->hw_ctx != NULL);
+
+#if 0
+   /* This is waiting until the kernel code can be merged and a new libdrm
+    * actually released.
+    */
+   err = drm_intel_get_reset_stats(brw->hw_ctx, &reset_count, &active,
+                                   &pending);
+   if (err)
+      return GL_NO_ERROR;
+#else
+   return GL_NO_ERROR;
+#endif
+
+   /* A reset was observed while a batch from this context was executing.
+    * Assume that this context was at fault.
+    */
+   if (active != 0)
+      return GL_GUILTY_CONTEXT_RESET_ARB;
+
+   /* A reset was observed while a batch from this context was in progress,
+    * but the batch was not executing.  In this case, assume that the context
+    * was not at fault.
+    */
+   if (pending != 0)
+      return GL_INNOCENT_CONTEXT_RESET_ARB;
+
+   /* FINISHME: Should we report anything if reset_count > brw->reset_count?
+    */
+
+   return GL_NO_ERROR;
+}
diff --git a/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp b/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
index 5dcd0e8..a4fae0d 100644
--- a/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
+++ b/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
@@ -56,29 +56,12 @@ using namespace brw;
 
 static bool debug = false;
 
+class instruction_scheduler;
+
 class schedule_node : public exec_node
 {
 public:
-   schedule_node(backend_instruction *inst, const struct brw_context *brw)
-   {
-      this->inst = inst;
-      this->child_array_size = 0;
-      this->children = NULL;
-      this->child_latency = NULL;
-      this->child_count = 0;
-      this->parent_count = 0;
-      this->unblocked_time = 0;
-      this->cand_generation = 0;
-
-      /* We can't measure Gen6 timings directly but expect them to be much
-       * closer to Gen7 than Gen4.
-       */
-      if (brw->gen >= 6)
-         set_latency_gen7(brw->is_haswell);
-      else
-         set_latency_gen4();
-   }
-
+   schedule_node(backend_instruction *inst, instruction_scheduler *sched);
    void set_latency_gen4();
    void set_latency_gen7(bool is_haswell);
 
@@ -354,6 +337,47 @@ schedule_node::set_latency_gen7(bool is_haswell)
       latency = 50;
       break;
 
+   case SHADER_OPCODE_UNTYPED_ATOMIC:
+      /* Test code:
+       *   mov(8)    g112<1>ud       0x00000000ud       { align1 WE_all 1Q };
+       *   mov(1)    g112.7<1>ud     g1.7<0,1,0>ud      { align1 WE_all };
+       *   mov(8)    g113<1>ud       0x00000000ud       { align1 WE_normal 1Q };
+       *   send(8)   g4<1>ud         g112<8,8,1>ud
+       *             data (38, 5, 6) mlen 2 rlen 1      { align1 WE_normal 1Q };
+       *
+       * Running it 100 times as fragment shader on a 128x128 quad
+       * gives an average latency of 13867 cycles per atomic op,
+       * standard deviation 3%.  Note that this is a rather
+       * pessimistic estimate, the actual latency in cases with few
+       * collisions between threads and favorable pipelining has been
+       * seen to be reduced by a factor of 100.
+       */
+      latency = 14000;
+      break;
+
+   case SHADER_OPCODE_UNTYPED_SURFACE_READ:
+      /* Test code:
+       *   mov(8)    g112<1>UD       0x00000000UD       { align1 WE_all 1Q };
+       *   mov(1)    g112.7<1>UD     g1.7<0,1,0>UD      { align1 WE_all };
+       *   mov(8)    g113<1>UD       0x00000000UD       { align1 WE_normal 1Q };
+       *   send(8)   g4<1>UD         g112<8,8,1>UD
+       *             data (38, 6, 5) mlen 2 rlen 1      { align1 WE_normal 1Q };
+       *   .
+       *   . [repeats 8 times]
+       *   .
+       *   mov(8)    g112<1>UD       0x00000000UD       { align1 WE_all 1Q };
+       *   mov(1)    g112.7<1>UD     g1.7<0,1,0>UD      { align1 WE_all };
+       *   mov(8)    g113<1>UD       0x00000000UD       { align1 WE_normal 1Q };
+       *   send(8)   g4<1>UD         g112<8,8,1>UD
+       *             data (38, 6, 5) mlen 2 rlen 1      { align1 WE_normal 1Q };
+       *
+       * Running it 100 times as fragment shader on a 128x128 quad
+       * gives an average latency of 583 cycles per surface read,
+       * standard deviation 0.9%.
+       */
+      latency = is_haswell ? 300 : 600;
+      break;
+
    default:
       /* 2 cycles:
        * mul(8) g4<1>F g2<0,1,0>F      0.5F            { align1 WE_normal 1Q };
@@ -369,15 +393,24 @@ schedule_node::set_latency_gen7(bool is_haswell)
 
 class instruction_scheduler {
 public:
-   instruction_scheduler(backend_visitor *v, int grf_count, bool post_reg_alloc)
+   instruction_scheduler(backend_visitor *v, int grf_count,
+                         instruction_scheduler_mode mode)
    {
       this->bv = v;
       this->mem_ctx = ralloc_context(NULL);
       this->grf_count = grf_count;
       this->instructions.make_empty();
       this->instructions_to_schedule = 0;
-      this->post_reg_alloc = post_reg_alloc;
+      this->post_reg_alloc = (mode == SCHEDULE_POST);
+      this->mode = mode;
       this->time = 0;
+      if (!post_reg_alloc) {
+         this->remaining_grf_uses = rzalloc_array(mem_ctx, int, grf_count);
+         this->grf_active = rzalloc_array(mem_ctx, bool, grf_count);
+      } else {
+         this->remaining_grf_uses = NULL;
+         this->grf_active = NULL;
+      }
    }
 
    ~instruction_scheduler()
@@ -403,6 +436,10 @@ public:
     */
    virtual int issue_time(backend_instruction *inst) = 0;
 
+   virtual void count_remaining_grf_uses(backend_instruction *inst) = 0;
+   virtual void update_register_pressure(backend_instruction *inst) = 0;
+   virtual int get_register_pressure_benefit(backend_instruction *inst) = 0;
+
    void schedule_instructions(backend_instruction *next_block_header);
 
    void *mem_ctx;
@@ -413,27 +450,116 @@ public:
    int time;
    exec_list instructions;
    backend_visitor *bv;
+
+   instruction_scheduler_mode mode;
+
+   /**
+    * Number of instructions left to schedule that reference each vgrf.
+    *
+    * Used so that we can prefer scheduling instructions that will end the
+    * live intervals of multiple variables, to reduce register pressure.
+    */
+   int *remaining_grf_uses;
+
+   /**
+    * Tracks whether each VGRF has had an instruction scheduled that uses it.
+    *
+    * This is used to estimate whether scheduling a new instruction will
+    * increase register pressure.
+    */
+   bool *grf_active;
 };
 
 class fs_instruction_scheduler : public instruction_scheduler
 {
 public:
-   fs_instruction_scheduler(fs_visitor *v, int grf_count, bool post_reg_alloc);
+   fs_instruction_scheduler(fs_visitor *v, int grf_count,
+                            instruction_scheduler_mode mode);
    void calculate_deps();
    bool is_compressed(fs_inst *inst);
    schedule_node *choose_instruction_to_schedule();
    int issue_time(backend_instruction *inst);
    fs_visitor *v;
+
+   void count_remaining_grf_uses(backend_instruction *inst);
+   void update_register_pressure(backend_instruction *inst);
+   int get_register_pressure_benefit(backend_instruction *inst);
 };
 
 fs_instruction_scheduler::fs_instruction_scheduler(fs_visitor *v,
                                                    int grf_count,
-                                                   bool post_reg_alloc)
-   : instruction_scheduler(v, grf_count, post_reg_alloc),
+                                                   instruction_scheduler_mode mode)
+   : instruction_scheduler(v, grf_count, mode),
      v(v)
 {
 }
 
+void
+fs_instruction_scheduler::count_remaining_grf_uses(backend_instruction *be)
+{
+   fs_inst *inst = (fs_inst *)be;
+
+   if (!remaining_grf_uses)
+      return;
+
+   if (inst->dst.file == GRF)
+      remaining_grf_uses[inst->dst.reg]++;
+
+   for (int i = 0; i < 3; i++) {
+      if (inst->src[i].file != GRF)
+         continue;
+
+      remaining_grf_uses[inst->src[i].reg]++;
+   }
+}
+
+void
+fs_instruction_scheduler::update_register_pressure(backend_instruction *be)
+{
+   fs_inst *inst = (fs_inst *)be;
+
+   if (!remaining_grf_uses)
+      return;
+
+   if (inst->dst.file == GRF) {
+      remaining_grf_uses[inst->dst.reg]--;
+      grf_active[inst->dst.reg] = true;
+   }
+
+   for (int i = 0; i < 3; i++) {
+      if (inst->src[i].file == GRF) {
+         remaining_grf_uses[inst->src[i].reg]--;
+         grf_active[inst->src[i].reg] = true;
+      }
+   }
+}
+
+int
+fs_instruction_scheduler::get_register_pressure_benefit(backend_instruction *be)
+{
+   fs_inst *inst = (fs_inst *)be;
+   int benefit = 0;
+
+   if (inst->dst.file == GRF) {
+      if (remaining_grf_uses[inst->dst.reg] == 1)
+         benefit += v->virtual_grf_sizes[inst->dst.reg];
+      if (!grf_active[inst->dst.reg])
+         benefit -= v->virtual_grf_sizes[inst->dst.reg];
+   }
+
+   for (int i = 0; i < 3; i++) {
+      if (inst->src[i].file != GRF)
+         continue;
+
+      if (remaining_grf_uses[inst->src[i].reg] == 1)
+         benefit += v->virtual_grf_sizes[inst->src[i].reg];
+      if (!grf_active[inst->src[i].reg])
+         benefit -= v->virtual_grf_sizes[inst->src[i].reg];
+   }
+
+   return benefit;
+}
+
 class vec4_instruction_scheduler : public instruction_scheduler
 {
 public:
@@ -442,19 +568,65 @@ public:
    schedule_node *choose_instruction_to_schedule();
    int issue_time(backend_instruction *inst);
    vec4_visitor *v;
+
+   void count_remaining_grf_uses(backend_instruction *inst);
+   void update_register_pressure(backend_instruction *inst);
+   int get_register_pressure_benefit(backend_instruction *inst);
 };
 
 vec4_instruction_scheduler::vec4_instruction_scheduler(vec4_visitor *v,
                                                        int grf_count)
-   : instruction_scheduler(v, grf_count, true),
+   : instruction_scheduler(v, grf_count, SCHEDULE_POST),
      v(v)
 {
 }
 
 void
+vec4_instruction_scheduler::count_remaining_grf_uses(backend_instruction *be)
+{
+}
+
+void
+vec4_instruction_scheduler::update_register_pressure(backend_instruction *be)
+{
+}
+
+int
+vec4_instruction_scheduler::get_register_pressure_benefit(backend_instruction *be)
+{
+   return 0;
+}
+
+schedule_node::schedule_node(backend_instruction *inst,
+                             instruction_scheduler *sched)
+{
+   struct brw_context *brw = sched->bv->brw;
+
+   this->inst = inst;
+   this->child_array_size = 0;
+   this->children = NULL;
+   this->child_latency = NULL;
+   this->child_count = 0;
+   this->parent_count = 0;
+   this->unblocked_time = 0;
+   this->cand_generation = 0;
+   this->delay = 0;
+
+   /* We can't measure Gen6 timings directly but expect them to be much
+    * closer to Gen7 than Gen4.
+    */
+   if (!sched->post_reg_alloc)
+      this->latency = 1;
+   else if (brw->gen >= 6)
+      set_latency_gen7(brw->is_haswell);
+   else
+      set_latency_gen4();
+}
+
+void
 instruction_scheduler::add_inst(backend_instruction *inst)
 {
-   schedule_node *n = new(mem_ctx) schedule_node(inst, bv->brw);
+   schedule_node *n = new(mem_ctx) schedule_node(inst, this);
 
    assert(!inst->is_head_sentinel());
    assert(!inst->is_tail_sentinel());
@@ -603,7 +775,8 @@ fs_instruction_scheduler::calculate_deps()
       schedule_node *n = (schedule_node *)node;
       fs_inst *inst = (fs_inst *)n->inst;
 
-      if (inst->opcode == FS_OPCODE_PLACEHOLDER_HALT)
+      if (inst->opcode == FS_OPCODE_PLACEHOLDER_HALT ||
+         inst->has_side_effects())
          add_barrier_deps(n);
 
       /* read-after-write deps. */
@@ -832,6 +1005,9 @@ vec4_instruction_scheduler::calculate_deps()
       schedule_node *n = (schedule_node *)node;
       vec4_instruction *inst = (vec4_instruction *)n->inst;
 
+      if (inst->has_side_effects())
+         add_barrier_deps(n);
+
       /* read-after-write deps. */
       for (int i = 0; i < 3; i++) {
          if (inst->src[i].file == GRF) {
@@ -994,40 +1170,59 @@ fs_instruction_scheduler::choose_instruction_to_schedule()
             continue;
          }
 
-         /* Prefer instructions that recently became available for scheduling.
-          * These are the things that are most likely to (eventually) make a
-          * variable dead and reduce register pressure.  Typical register
-          * pressure estimates don't work for us because most of our pressure
-          * comes from texturing, where no single instruction to schedule will
-          * make a vec4 value dead.
+         /* Most important: If we can definitely reduce register pressure, do
+          * so immediately.
           */
-         if (n->cand_generation > chosen->cand_generation) {
+         int register_pressure_benefit = get_register_pressure_benefit(n->inst);
+         int chosen_register_pressure_benefit =
+            get_register_pressure_benefit(chosen->inst);
+
+         if (register_pressure_benefit > 0 &&
+             register_pressure_benefit > chosen_register_pressure_benefit) {
             chosen = n;
             continue;
-         } else if (n->cand_generation < chosen->cand_generation) {
+         } else if (chosen_register_pressure_benefit > 0 &&
+                    (register_pressure_benefit <
+                     chosen_register_pressure_benefit)) {
             continue;
          }
 
-         /* On MRF-using chips, prefer non-SEND instructions.  If we don't do
-          * this, then because we prefer instructions that just became
-          * candidates, we'll end up in a pattern of scheduling a SEND, then
-          * the MRFs for the next SEND, then the next SEND, then the MRFs,
-          * etc., without ever consuming the results of a send.
-          */
-         if (v->brw->gen < 7) {
-            fs_inst *chosen_inst = (fs_inst *)chosen->inst;
-
-            /* We use regs_written > 1 as our test for the kind of send
-             * instruction to avoid -- only sends generate many regs, and a
-             * single-result send is probably actually reducing register
-             * pressure.
+         if (mode == SCHEDULE_PRE_LIFO) {
+            /* Prefer instructions that recently became available for
+             * scheduling.  These are the things that are most likely to
+             * (eventually) make a variable dead and reduce register pressure.
+             * Typical register pressure estimates don't work for us because
+             * most of our pressure comes from texturing, where no single
+             * instruction to schedule will make a vec4 value dead.
              */
-            if (inst->regs_written <= 1 && chosen_inst->regs_written > 1) {
+            if (n->cand_generation > chosen->cand_generation) {
                chosen = n;
                continue;
-            } else if (inst->regs_written > chosen_inst->regs_written) {
+            } else if (n->cand_generation < chosen->cand_generation) {
                continue;
             }
+
+            /* On MRF-using chips, prefer non-SEND instructions.  If we don't
+             * do this, then because we prefer instructions that just became
+             * candidates, we'll end up in a pattern of scheduling a SEND,
+             * then the MRFs for the next SEND, then the next SEND, then the
+             * MRFs, etc., without ever consuming the results of a send.
+             */
+            if (v->brw->gen < 7) {
+               fs_inst *chosen_inst = (fs_inst *)chosen->inst;
+
+               /* We use regs_written > 1 as our test for the kind of send
+                * instruction to avoid -- only sends generate many regs, and a
+                * single-result send is probably actually reducing register
+                * pressure.
+                */
+               if (inst->regs_written <= 1 && chosen_inst->regs_written > 1) {
+                  chosen = n;
+                  continue;
+               } else if (inst->regs_written > chosen_inst->regs_written) {
+                  continue;
+               }
+            }
          }
 
          /* For instructions pushed on the cands list at the same time, prefer
@@ -1110,6 +1305,7 @@ instruction_scheduler::schedule_instructions(backend_instruction *next_block_hea
       chosen->remove();
       next_block_header->insert_before(chosen->inst);
       instructions_to_schedule--;
+      update_register_pressure(chosen->inst);
 
       /* Update the clock for how soon an instruction could start after the
        * chosen one.
@@ -1185,6 +1381,15 @@ instruction_scheduler::run(exec_list *all_instructions)
       bv->dump_instructions();
    }
 
+   /* Populate the remaining GRF uses array to improve the pre-regalloc
+    * scheduling.
+    */
+   if (remaining_grf_uses) {
+      foreach_list(node, all_instructions) {
+         count_remaining_grf_uses((backend_instruction *)node);
+      }
+   }
+
    while (!next_block_header->is_tail_sentinel()) {
       /* Add things to be scheduled until we get to a new BB. */
       while (!next_block_header->is_tail_sentinel()) {
@@ -1212,18 +1417,18 @@ instruction_scheduler::run(exec_list *all_instructions)
 }
 
 void
-fs_visitor::schedule_instructions(bool post_reg_alloc)
+fs_visitor::schedule_instructions(instruction_scheduler_mode mode)
 {
    int grf_count;
-   if (post_reg_alloc)
+   if (mode == SCHEDULE_POST)
       grf_count = grf_used;
    else
       grf_count = virtual_grf_count;
 
-   fs_instruction_scheduler sched(this, grf_count, post_reg_alloc);
+   fs_instruction_scheduler sched(this, grf_count, mode);
    sched.run(&instructions);
 
-   if (unlikely(INTEL_DEBUG & DEBUG_WM) && post_reg_alloc) {
+   if (unlikely(INTEL_DEBUG & DEBUG_WM) && mode == SCHEDULE_POST) {
       printf("fs%d estimated execution time: %d cycles\n",
              dispatch_width, sched.time);
    }
diff --git a/src/mesa/drivers/dri/i965/brw_shader.cpp b/src/mesa/drivers/dri/i965/brw_shader.cpp
index b7b0a5b..ddb4524 100644
--- a/src/mesa/drivers/dri/i965/brw_shader.cpp
+++ b/src/mesa/drivers/dri/i965/brw_shader.cpp
@@ -602,6 +602,17 @@ backend_instruction::can_do_source_mods()
    }
 }
 
+bool
+backend_instruction::has_side_effects() const
+{
+   switch (opcode) {
+   case SHADER_OPCODE_UNTYPED_ATOMIC:
+      return true;
+   default:
+      return false;
+   }
+}
+
 void
 backend_visitor::dump_instructions()
 {
diff --git a/src/mesa/drivers/dri/i965/brw_shader.h b/src/mesa/drivers/dri/i965/brw_shader.h
index cc76a44..aba24c5 100644
--- a/src/mesa/drivers/dri/i965/brw_shader.h
+++ b/src/mesa/drivers/dri/i965/brw_shader.h
@@ -46,12 +46,25 @@ public:
    bool is_control_flow();
    bool can_do_source_mods();
 
+   /**
+    * True if the instruction has side effects other than writing to
+    * its destination registers.  You are expected not to reorder or
+    * optimize these out unless you know what you are doing.
+    */
+   bool has_side_effects() const;
+
    enum opcode opcode; /* BRW_OPCODE_* or FS_OPCODE_* */
 
    uint32_t predicate;
    bool predicate_inverse;
 };
 
+enum instruction_scheduler_mode {
+   SCHEDULE_PRE_NON_LIFO,
+   SCHEDULE_PRE_LIFO,
+   SCHEDULE_POST,
+};
+
 class backend_visitor : public ir_visitor {
 public:
 
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index 471f1da..2a4b23c 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -200,6 +200,7 @@ int brw_get_texture_swizzle(const struct gl_context *ctx,
                             const struct gl_texture_object *t);
 
 /* gen7_wm_surface_state.c */
+unsigned brw_swizzle_to_scs(GLenum swizzle, bool need_green_to_blue);
 uint32_t gen7_surface_tiling_mode(uint32_t tiling);
 uint32_t gen7_surface_msaa_bits(unsigned num_samples, enum intel_msaa_layout l);
 void gen7_set_surface_mcs_info(struct brw_context *brw,
diff --git a/src/mesa/drivers/dri/i965/brw_tex_layout.c b/src/mesa/drivers/dri/i965/brw_tex_layout.c
index d912862..d05dbeb 100644
--- a/src/mesa/drivers/dri/i965/brw_tex_layout.c
+++ b/src/mesa/drivers/dri/i965/brw_tex_layout.c
@@ -86,7 +86,7 @@ intel_horizontal_texture_alignment_unit(struct brw_context *brw,
 
 static unsigned int
 intel_vertical_texture_alignment_unit(struct brw_context *brw,
-                                     gl_format format)
+                                      gl_format format, bool multisampled)
 {
    /**
     * From the "Alignment Unit Size" section of various specs, namely:
@@ -110,8 +110,6 @@ intel_vertical_texture_alignment_unit(struct brw_context *brw,
     *
     * On SNB+, non-special cases can be overridden by setting the SURFACE_STATE
     * "Surface Vertical Alignment" field to VALIGN_2 or VALIGN_4.
-    *
-    * We currently don't support multisampling.
     */
    if (_mesa_is_format_compressed(format))
       return 4;
@@ -119,6 +117,9 @@ intel_vertical_texture_alignment_unit(struct brw_context *brw,
    if (format == MESA_FORMAT_S8)
       return brw->gen >= 7 ? 8 : 4;
 
+   if (multisampled)
+      return 4;
+
    GLenum base_format = _mesa_get_format_base_format(format);
 
    if (brw->gen >= 6 &&
@@ -276,8 +277,10 @@ brw_miptree_layout_texture_3d(struct brw_context *brw,
 void
 brw_miptree_layout(struct brw_context *brw, struct intel_mipmap_tree *mt)
 {
+   bool multisampled = mt->num_samples > 1;
    mt->align_w = intel_horizontal_texture_alignment_unit(brw, mt->format);
-   mt->align_h = intel_vertical_texture_alignment_unit(brw, mt->format);
+   mt->align_h =
+      intel_vertical_texture_alignment_unit(brw, mt->format, multisampled);
 
    switch (mt->target) {
    case GL_TEXTURE_CUBE_MAP:
diff --git a/src/mesa/drivers/dri/i965/brw_vec4.cpp b/src/mesa/drivers/dri/i965/brw_vec4.cpp
index 3225912..20fbd45 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4.cpp
@@ -318,7 +318,7 @@ vec4_visitor::dead_code_eliminate()
    foreach_list_safe(node, &this->instructions) {
       vec4_instruction *inst = (vec4_instruction *)node;
 
-      if (inst->dst.file == GRF) {
+      if (inst->dst.file == GRF && !inst->has_side_effects()) {
          assert(this->virtual_grf_end[inst->dst.reg] >= pc);
          if (this->virtual_grf_end[inst->dst.reg] == pc) {
             /* Don't dead code eliminate instructions that write to the
diff --git a/src/mesa/drivers/dri/i965/brw_vec4.h b/src/mesa/drivers/dri/i965/brw_vec4.h
index a479646..1f29e57 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4.h
+++ b/src/mesa/drivers/dri/i965/brw_vec4.h
@@ -489,6 +489,13 @@ public:
    void emit_shader_time_write(enum shader_time_shader_type type,
                                src_reg value);
 
+   void emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
+                            dst_reg dst, src_reg offset, src_reg src0,
+                            src_reg src1);
+
+   void emit_untyped_surface_read(unsigned surf_index, dst_reg dst,
+                                  src_reg offset);
+
    src_reg get_scratch_offset(vec4_instruction *inst,
 			      src_reg *reladdr, int reg_offset);
    src_reg get_pull_constant_offset(vec4_instruction *inst,
@@ -514,6 +521,8 @@ public:
 
    void dump_instruction(backend_instruction *inst);
 
+   void visit_atomic_counter_intrinsic(ir_call *ir);
+
 protected:
    void emit_vertex();
    void lower_attributes_to_hw_regs(const int *attribute_map,
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp b/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
index 7a0dfa5..423f693 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
@@ -177,11 +177,11 @@ vec4_visitor::IF(uint32_t predicate)
    return inst;
 }
 
-/** Gen6+ IF with embedded comparison. */
+/** Gen6 IF with embedded comparison. */
 vec4_instruction *
 vec4_visitor::IF(src_reg src0, src_reg src1, uint32_t condition)
 {
-   assert(brw->gen >= 6);
+   assert(brw->gen == 6);
 
    vec4_instruction *inst;
 
@@ -974,8 +974,11 @@ vec4_visitor::visit(ir_variable *ir)
       /* Thanks to the lower_ubo_reference pass, we will see only
        * ir_binop_ubo_load expressions and not ir_dereference_variable for UBO
        * variables, so no need for them to be in variable_ht.
+       *
+       * Atomic counters take no uniform storage, no need to do
+       * anything here.
        */
-      if (ir->is_in_uniform_block())
+      if (ir->is_in_uniform_block() || ir->type->contains_atomic())
          return;
 
       /* Track how big the whole uniform variable is, in case we need to put a
@@ -2161,9 +2164,56 @@ vec4_visitor::visit(ir_constant *ir)
 }
 
 void
+vec4_visitor::visit_atomic_counter_intrinsic(ir_call *ir)
+{
+   ir_dereference *deref = static_cast<ir_dereference *>(
+      ir->actual_parameters.get_head());
+   ir_variable *location = deref->variable_referenced();
+   unsigned surf_index = (prog_data->base.binding_table.abo_start +
+                          location->atomic.buffer_index);
+
+   /* Calculate the surface offset */
+   src_reg offset(this, glsl_type::uint_type);
+   ir_dereference_array *deref_array = deref->as_dereference_array();
+   if (deref_array) {
+      deref_array->array_index->accept(this);
+
+      src_reg tmp(this, glsl_type::uint_type);
+      emit(MUL(dst_reg(tmp), this->result, ATOMIC_COUNTER_SIZE));
+      emit(ADD(dst_reg(offset), tmp, location->atomic.offset));
+   } else {
+      offset = location->atomic.offset;
+   }
+
+   /* Emit the appropriate machine instruction */
+   const char *callee = ir->callee->function_name();
+   dst_reg dst = get_assignment_lhs(ir->return_deref, this);
+
+   if (!strcmp("__intrinsic_atomic_read", callee)) {
+      emit_untyped_surface_read(surf_index, dst, offset);
+
+   } else if (!strcmp("__intrinsic_atomic_increment", callee)) {
+      emit_untyped_atomic(BRW_AOP_INC, surf_index, dst, offset,
+                          src_reg(), src_reg());
+
+   } else if (!strcmp("__intrinsic_atomic_predecrement", callee)) {
+      emit_untyped_atomic(BRW_AOP_PREDEC, surf_index, dst, offset,
+                          src_reg(), src_reg());
+   }
+}
+
+void
 vec4_visitor::visit(ir_call *ir)
 {
-   assert(!"not reached");
+   const char *callee = ir->callee->function_name();
+
+   if (!strcmp("__intrinsic_atomic_read", callee) ||
+       !strcmp("__intrinsic_atomic_increment", callee) ||
+       !strcmp("__intrinsic_atomic_predecrement", callee)) {
+      visit_atomic_counter_intrinsic(ir);
+   } else {
+      assert(!"Unsupported intrinsic.");
+   }
 }
 
 void
@@ -2558,6 +2608,55 @@ vec4_visitor::visit(ir_end_primitive *)
 }
 
 void
+vec4_visitor::emit_untyped_atomic(unsigned atomic_op, unsigned surf_index,
+                                  dst_reg dst, src_reg offset,
+                                  src_reg src0, src_reg src1)
+{
+   unsigned mlen = 0;
+
+   /* Set the atomic operation offset. */
+   emit(MOV(brw_writemask(brw_uvec_mrf(8, mlen, 0), WRITEMASK_X), offset));
+   mlen++;
+
+   /* Set the atomic operation arguments. */
+   if (src0.file != BAD_FILE) {
+      emit(MOV(brw_writemask(brw_uvec_mrf(8, mlen, 0), WRITEMASK_X), src0));
+      mlen++;
+   }
+
+   if (src1.file != BAD_FILE) {
+      emit(MOV(brw_writemask(brw_uvec_mrf(8, mlen, 0), WRITEMASK_X), src1));
+      mlen++;
+   }
+
+   /* Emit the instruction.  Note that this maps to the normal SIMD8
+    * untyped atomic message on Ivy Bridge, but that's OK because
+    * unused channels will be masked out.
+    */
+   vec4_instruction *inst = emit(SHADER_OPCODE_UNTYPED_ATOMIC, dst,
+                                 src_reg(atomic_op), src_reg(surf_index));
+   inst->base_mrf = 0;
+   inst->mlen = mlen;
+}
+
+void
+vec4_visitor::emit_untyped_surface_read(unsigned surf_index, dst_reg dst,
+                                        src_reg offset)
+{
+   /* Set the surface read offset. */
+   emit(MOV(brw_writemask(brw_uvec_mrf(8, 0, 0), WRITEMASK_X), offset));
+
+   /* Emit the instruction.  Note that this maps to the normal SIMD8
+    * untyped surface read message, but that's OK because unused
+    * channels will be masked out.
+    */
+   vec4_instruction *inst = emit(SHADER_OPCODE_UNTYPED_SURFACE_READ,
+                                 dst, src_reg(surf_index));
+   inst->base_mrf = 0;
+   inst->mlen = 1;
+}
+
+void
 vec4_visitor::emit_ndc_computation()
 {
    /* Get the position */
@@ -3151,7 +3250,12 @@ vec4_visitor::vec4_visitor(struct brw_context *brw,
 			   void *mem_ctx,
                            bool debug_flag,
                            bool no_spills)
-   : debug_flag(debug_flag), no_spills(no_spills)
+   : sanity_param_count(0),
+     fail_msg(NULL),
+     first_non_payload_grf(0),
+     need_all_constants_in_pull_buffer(false),
+     debug_flag(debug_flag),
+     no_spills(no_spills)
 {
    this->brw = brw;
    this->ctx = &brw->ctx;
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp b/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
index 1f3d75c..d98bad1 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
@@ -493,7 +493,7 @@ vec4_vs_visitor::get_vp_dst_reg(const prog_dst_register &dst)
       return dst_null_f();
 
    default:
-      assert("vec4_vp: bad destination register file");
+      assert(!"vec4_vp: bad destination register file");
       return dst_reg(this, glsl_type::vec4_type);
    }
 
diff --git a/src/mesa/drivers/dri/i965/brw_vs_state.c b/src/mesa/drivers/dri/i965/brw_vs_state.c
index cdffac3..216b3dd 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_state.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_state.c
@@ -79,7 +79,8 @@ brw_upload_vs_unit(struct brw_context *brw)
    */
    vs->thread1.single_program_flow = (brw->gen == 5);
 
-   vs->thread1.binding_table_entry_count = 0;
+   vs->thread1.binding_table_entry_count =
+      brw->vs.prog_data->base.base.binding_table.size_bytes / 4;
 
    if (brw->vs.prog_data->base.total_scratch != 0) {
       vs->thread2.scratch_space_base_pointer =
diff --git a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
index ca8577a..9834c11 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
@@ -85,9 +85,9 @@ brw_upload_vec4_pull_constants(struct brw_context *brw,
 
    drm_intel_gem_bo_unmap_gtt(stage_state->const_bo);
 
-   brw->vtbl.create_constant_surface(brw, stage_state->const_bo, 0, size,
-                                     &stage_state->surf_offset[surf_index],
-                                     false);
+   brw_create_constant_surface(brw, stage_state->const_bo, 0, size,
+                               &stage_state->surf_offset[surf_index],
+                               false);
 
    brw->state.dirty.brw |= brw_new_constbuf;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm.c b/src/mesa/drivers/dri/i965/brw_wm.c
index e404d99..bc1480c 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.c
+++ b/src/mesa/drivers/dri/i965/brw_wm.c
@@ -290,6 +290,10 @@ brw_wm_debug_recompile(struct brw_context *brw,
                       old_key->drawable_height, key->drawable_height);
    found |= key_debug(brw, "input slots valid",
                       old_key->input_slots_valid, key->input_slots_valid);
+   found |= key_debug(brw, "mrt alpha test function",
+                      old_key->alpha_test_func, key->alpha_test_func);
+   found |= key_debug(brw, "mrt alpha test reference value",
+                      old_key->alpha_test_ref, key->alpha_test_ref);
 
    found |= brw_debug_recompile_sampler_key(brw, &old_key->tex, &key->tex);
 
@@ -500,6 +504,18 @@ static void brw_wm_populate_key( struct brw_context *brw,
                                          BRW_FS_VARYING_INPUT_MASK) > 16)
       key->input_slots_valid = brw->vue_map_geom_out.slots_valid;
 
+
+   /* _NEW_COLOR | _NEW_BUFFERS */
+   /* Pre-gen6, the hardware alpha test always used each render
+    * target's alpha to do alpha test, as opposed to render target 0's alpha
+    * like GL requires.  Fix that by building the alpha test into the
+    * shader, and we'll skip enabling the fixed function alpha test.
+    */
+   if (brw->gen < 6 && ctx->DrawBuffer->_NumColorDrawBuffers > 1 && ctx->Color.AlphaEnabled) {
+      key->alpha_test_func = ctx->Color.AlphaFunc;
+      key->alpha_test_ref = ctx->Color.AlphaRef;
+   }
+
    /* The unique fragment program ID */
    key->program_string_id = fp->id;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_wm.h b/src/mesa/drivers/dri/i965/brw_wm.h
index f5823f4..df5fb4c 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.h
+++ b/src/mesa/drivers/dri/i965/brw_wm.h
@@ -73,6 +73,8 @@ struct brw_wm_prog_key {
    GLushort drawable_height;
    GLbitfield64 input_slots_valid;
    GLuint program_string_id:32;
+   GLenum alpha_test_func;          /* < For Gen4/5 MRT alpha test */
+   float alpha_test_ref;
 
    struct brw_sampler_prog_key_data tex;
 };
diff --git a/src/mesa/drivers/dri/i965/brw_wm_state.c b/src/mesa/drivers/dri/i965/brw_wm_state.c
index 9aa32c0..406dbbe 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_state.c
@@ -120,7 +120,8 @@ brw_upload_wm_unit(struct brw_context *brw)
    else
       wm->thread1.floating_point_mode = BRW_FLOATING_POINT_IEEE_754;
 
-   wm->thread1.binding_table_entry_count = 0;
+   wm->thread1.binding_table_entry_count =
+      brw->wm.prog_data->base.binding_table.size_bytes / 4;
 
    if (brw->wm.prog_data->total_scratch != 0) {
       wm->thread2.scratch_space_base_pointer =
diff --git a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
index 46871c7..662c975 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
@@ -197,7 +197,9 @@ gen4_emit_buffer_surface_state(struct brw_context *brw,
                                unsigned buffer_offset,
                                unsigned surface_format,
                                unsigned buffer_size,
-                               unsigned pitch)
+                               unsigned pitch,
+                               unsigned mocs,
+                               bool rw)
 {
    uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE,
                                     6 * 4, 32, out_offset);
@@ -219,11 +221,12 @@ gen4_emit_buffer_surface_state(struct brw_context *brw,
    if (bo) {
       drm_intel_bo_emit_reloc(brw->batch.bo, *out_offset + 4,
                               bo, buffer_offset,
-                              I915_GEM_DOMAIN_SAMPLER, 0);
+                              I915_GEM_DOMAIN_SAMPLER,
+                              (rw ? I915_GEM_DOMAIN_SAMPLER : 0));
    }
 }
 
-static void
+void
 brw_update_buffer_texture_surface(struct gl_context *ctx,
                                   unsigned unit,
                                   uint32_t *surf_offset)
@@ -248,11 +251,13 @@ brw_update_buffer_texture_surface(struct gl_context *ctx,
 		    _mesa_get_format_name(format));
    }
 
-   gen4_emit_buffer_surface_state(brw, surf_offset, bo,
-                                  tObj->BufferOffset,
-                                  brw_format,
-                                  size / texel_size,
-                                  texel_size);
+   brw->vtbl.emit_buffer_surface_state(brw, surf_offset, bo,
+                                       tObj->BufferOffset,
+                                       brw_format,
+                                       size / texel_size,
+                                       texel_size,
+                                       0, /* mocs */
+                                       false /* rw */);
 }
 
 static void
@@ -316,7 +321,7 @@ brw_update_texture_surface(struct gl_context *ctx,
  * Create the constant buffer surface.  Vertex/fragment shader constants will be
  * read from this buffer with Data Port Read instructions/messages.
  */
-static void
+void
 brw_create_constant_surface(struct brw_context *brw,
 			    drm_intel_bo *bo,
 			    uint32_t offset,
@@ -327,9 +332,9 @@ brw_create_constant_surface(struct brw_context *brw,
    uint32_t stride = dword_pitch ? 4 : 16;
    uint32_t elements = ALIGN(size, stride) / stride;
 
-   gen4_emit_buffer_surface_state(brw, out_offset, bo, offset,
-                                  BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
-                                  elements, stride);
+   brw->vtbl.emit_buffer_surface_state(brw, out_offset, bo, offset,
+                                       BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
+                                       elements, stride, 0, false);
 }
 
 /**
@@ -464,9 +469,9 @@ brw_upload_wm_pull_constants(struct brw_context *brw)
    }
    drm_intel_gem_bo_unmap_gtt(brw->wm.base.const_bo);
 
-   brw->vtbl.create_constant_surface(brw, brw->wm.base.const_bo, 0, size,
-                                     &brw->wm.base.surf_offset[surf_index],
-                                     true);
+   brw_create_constant_surface(brw, brw->wm.base.const_bo, 0, size,
+                               &brw->wm.base.surf_offset[surf_index],
+                               true);
 
    brw->state.dirty.brw |= BRW_NEW_SURFACES;
 }
@@ -835,10 +840,10 @@ brw_upload_ubo_surfaces(struct brw_context *brw,
        * glBindBufferRange case is undefined, we can just bind the whole buffer
        * glBindBufferBase wants and be a correct implementation.
        */
-      brw->vtbl.create_constant_surface(brw, bo, binding->Offset,
-                                        bo->size - binding->Offset,
-                                        &surf_offsets[i],
-                                        shader->Type == GL_FRAGMENT_SHADER);
+      brw_create_constant_surface(brw, bo, binding->Offset,
+                                  bo->size - binding->Offset,
+                                  &surf_offsets[i],
+                                  shader->Type == GL_FRAGMENT_SHADER);
    }
 
    if (shader->NumUniformBlocks)
@@ -885,7 +890,7 @@ brw_upload_abo_surfaces(struct brw_context *brw,
       struct intel_buffer_object *intel_bo =
          intel_buffer_object(binding->BufferObject);
       drm_intel_bo *bo = intel_bufferobj_buffer(
-         brw, intel_bo, binding->Offset, bo->size - binding->Offset);
+         brw, intel_bo, binding->Offset, intel_bo->Base.Size - binding->Offset);
 
       brw->vtbl.create_raw_surface(brw, bo, binding->Offset,
                                    bo->size - binding->Offset,
@@ -926,5 +931,5 @@ gen4_init_vtable_surface_functions(struct brw_context *brw)
    brw->vtbl.update_renderbuffer_surface = brw_update_renderbuffer_surface;
    brw->vtbl.update_null_renderbuffer_surface =
       brw_update_null_renderbuffer_surface;
-   brw->vtbl.create_constant_surface = brw_create_constant_surface;
+   brw->vtbl.emit_buffer_surface_state = gen4_emit_buffer_surface_state;
 }
diff --git a/src/mesa/drivers/dri/i965/gen6_blorp.cpp b/src/mesa/drivers/dri/i965/gen6_blorp.cpp
index 8735270..8fb8ca1 100644
--- a/src/mesa/drivers/dri/i965/gen6_blorp.cpp
+++ b/src/mesa/drivers/dri/i965/gen6_blorp.cpp
@@ -45,17 +45,6 @@
                              * sizeof(float))
 /** \} */
 
-void
-gen6_blorp_emit_batch_head(struct brw_context *brw,
-                           const brw_blorp_params *params)
-{
-   /* To ensure that the batch contains only the resolve, flush the batch
-    * before beginning and after finishing emitting the resolve packets.
-    */
-   intel_batchbuffer_flush(brw);
-}
-
-
 /**
  * CMD_STATE_BASE_ADDRESS
  *
@@ -1045,7 +1034,6 @@ gen6_blorp_exec(struct brw_context *brw,
    uint32_t wm_bind_bo_offset = 0;
 
    uint32_t prog_offset = params->get_wm_prog(brw, &prog_data);
-   gen6_blorp_emit_batch_head(brw, params);
    gen6_emit_3dstate_multisample(brw, params->num_samples);
    gen6_emit_3dstate_sample_mask(brw, params->num_samples, 1.0, false, ~0u);
    gen6_blorp_emit_state_base_address(brw, params);
diff --git a/src/mesa/drivers/dri/i965/gen6_clip_state.c b/src/mesa/drivers/dri/i965/gen6_clip_state.c
index 08b57c7..03d0f90 100644
--- a/src/mesa/drivers/dri/i965/gen6_clip_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_clip_state.c
@@ -36,6 +36,7 @@ static void
 upload_clip_state(struct brw_context *brw)
 {
    struct gl_context *ctx = &brw->ctx;
+   /* BRW_NEW_META_IN_PROGRESS */
    uint32_t dw1 = brw->meta_in_progress ? 0 : GEN6_CLIP_STATISTICS_ENABLE;
    uint32_t dw2 = 0;
 
@@ -48,6 +49,33 @@ upload_clip_state(struct brw_context *brw)
       dw2 |= GEN6_CLIP_NON_PERSPECTIVE_BARYCENTRIC_ENABLE;
    }
 
+   if (brw->gen >= 7) {
+      dw1 |= GEN7_CLIP_EARLY_CULL;
+
+      /* _NEW_POLYGON */
+      if ((ctx->Polygon.FrontFace == GL_CCW) ^ _mesa_is_user_fbo(fb))
+         dw1 |= GEN7_CLIP_WINDING_CCW;
+
+      if (ctx->Polygon.CullFlag) {
+         switch (ctx->Polygon.CullFaceMode) {
+         case GL_FRONT:
+            dw1 |= GEN7_CLIP_CULLMODE_FRONT;
+            break;
+         case GL_BACK:
+            dw1 |= GEN7_CLIP_CULLMODE_BACK;
+            break;
+         case GL_FRONT_AND_BACK:
+            dw1 |= GEN7_CLIP_CULLMODE_BOTH;
+            break;
+         default:
+            assert(!"Should not get here: invalid CullFlag");
+            break;
+         }
+      } else {
+         dw1 |= GEN7_CLIP_CULLMODE_NONE;
+      }
+   }
+
    if (!ctx->Transform.DepthClamp)
       dw2 |= GEN6_CLIP_Z_TEST;
 
@@ -79,7 +107,8 @@ upload_clip_state(struct brw_context *brw)
    if (ctx->RasterDiscard) {
       dw2 |= GEN6_CLIP_MODE_REJECT_ALL;
       perf_debug("Rasterizer discard is currently implemented via the clipper; "
-                 "having the GS not write primitives would likely be faster.");
+                 "%s be faster.", brw->gen >= 7 ? "using the SOL unit may" :
+                 "having the GS not write primitives would likely");
    }
 
    BEGIN_BATCH(4);
@@ -92,7 +121,7 @@ upload_clip_state(struct brw_context *brw)
 	     dw2);
    OUT_BATCH(U_FIXED(0.125, 3) << GEN6_CLIP_MIN_POINT_WIDTH_SHIFT |
              U_FIXED(255.875, 3) << GEN6_CLIP_MAX_POINT_WIDTH_SHIFT |
-             GEN6_CLIP_FORCE_ZERO_RTAINDEX);
+             (fb->Layered ? 0 : GEN6_CLIP_FORCE_ZERO_RTAINDEX));
    ADVANCE_BATCH();
 }
 
@@ -106,3 +135,14 @@ const struct brw_tracked_state gen6_clip_state = {
    },
    .emit = upload_clip_state,
 };
+
+const struct brw_tracked_state gen7_clip_state = {
+   .dirty = {
+      .mesa  = _NEW_BUFFERS | _NEW_LIGHT | _NEW_POLYGON | _NEW_TRANSFORM,
+      .brw   = BRW_NEW_CONTEXT |
+               BRW_NEW_META_IN_PROGRESS |
+               BRW_NEW_RASTERIZER_DISCARD,
+      .cache = CACHE_NEW_WM_PROG
+   },
+   .emit = upload_clip_state,
+};
diff --git a/src/mesa/drivers/dri/i965/gen6_vs_state.c b/src/mesa/drivers/dri/i965/gen6_vs_state.c
index 569ec8c..80129cd 100644
--- a/src/mesa/drivers/dri/i965/gen6_vs_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_vs_state.c
@@ -165,7 +165,9 @@ upload_vs_state(struct brw_context *brw)
    OUT_BATCH(_3DSTATE_VS << 16 | (6 - 2));
    OUT_BATCH(stage_state->prog_offset);
    OUT_BATCH(floating_point_mode |
-	     ((ALIGN(stage_state->sampler_count, 4)/4) << GEN6_VS_SAMPLER_COUNT_SHIFT));
+	     ((ALIGN(stage_state->sampler_count, 4)/4) << GEN6_VS_SAMPLER_COUNT_SHIFT) |
+             ((brw->vs.prog_data->base.base.binding_table.size_bytes / 4) <<
+              GEN6_VS_BINDING_TABLE_ENTRY_COUNT_SHIFT));
 
    if (brw->vs.prog_data->base.total_scratch) {
       OUT_RELOC(stage_state->scratch_bo,
diff --git a/src/mesa/drivers/dri/i965/gen6_wm_state.c b/src/mesa/drivers/dri/i965/gen6_wm_state.c
index 42d8789..83a1708 100644
--- a/src/mesa/drivers/dri/i965/gen6_wm_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_wm_state.c
@@ -146,10 +146,10 @@ upload_wm_state(struct brw_context *brw)
    /* CACHE_NEW_SAMPLER */
    dw2 |= (ALIGN(brw->wm.base.sampler_count, 4) / 4) <<
            GEN6_WM_SAMPLER_COUNT_SHIFT;
-   dw4 |= (brw->wm.prog_data->first_curbe_grf <<
-	   GEN6_WM_DISPATCH_START_GRF_SHIFT_0);
-   dw4 |= (brw->wm.prog_data->first_curbe_grf_16 <<
-	   GEN6_WM_DISPATCH_START_GRF_SHIFT_2);
+
+   /* CACHE_NEW_WM_PROG */
+   dw2 |= ((brw->wm.prog_data->base.binding_table.size_bytes / 4) <<
+           GEN6_WM_BINDING_TABLE_ENTRY_COUNT_SHIFT);
 
    dw5 |= (brw->max_wm_threads - 1) << GEN6_WM_MAX_THREADS_SHIFT;
 
@@ -166,11 +166,22 @@ upload_wm_state(struct brw_context *brw)
 
    if (brw->wm.prog_data->prog_offset_16) {
       dw5 |= GEN6_WM_16_DISPATCH_ENABLE;
-      if (min_inv_per_frag == 1)
+
+      if (min_inv_per_frag == 1) {
          dw5 |= GEN6_WM_8_DISPATCH_ENABLE;
+         dw4 |= (brw->wm.prog_data->first_curbe_grf <<
+                 GEN6_WM_DISPATCH_START_GRF_SHIFT_0);
+         dw4 |= (brw->wm.prog_data->first_curbe_grf_16 <<
+                 GEN6_WM_DISPATCH_START_GRF_SHIFT_2);
+      } else
+         dw4 |= (brw->wm.prog_data->first_curbe_grf_16 <<
+                GEN6_WM_DISPATCH_START_GRF_SHIFT_0);
    }
-   else
+   else {
       dw5 |= GEN6_WM_8_DISPATCH_ENABLE;
+      dw4 |= (brw->wm.prog_data->first_curbe_grf <<
+              GEN6_WM_DISPATCH_START_GRF_SHIFT_0);
+   }
 
    /* CACHE_NEW_WM_PROG | _NEW_COLOR */
    if (brw->wm.prog_data->dual_src_blend &&
@@ -229,8 +240,40 @@ upload_wm_state(struct brw_context *brw)
 
       if (min_inv_per_frag > 1)
          dw6 |= GEN6_WM_MSDISPMODE_PERSAMPLE;
-      else
+      else {
          dw6 |= GEN6_WM_MSDISPMODE_PERPIXEL;
+
+         /* From the Sandy Bridge PRM, Vol 2 part 1, 7.7.1 ("Pixel Grouping
+          * (Dispatch Size) Control"), p.334:
+          *
+          *     Note: in the table below, the Valid column indicates which
+          *     products that combination is supported on. Combinations of
+          *     dispatch enables not listed in the table are not available on
+          *     any product.
+          *
+          *     A: Valid on all products
+          *
+          *     B: Not valid on [DevSNB] if 4x PERPIXEL mode with pixel shader
+          *     computed depth.
+          *
+          *     D: Valid on all products, except when in non-1x PERSAMPLE mode
+          *     (applies to [DevSNB+] only). Not valid on [DevSNB] if 4x
+          *     PERPIXEL mode with pixel shader computed depth.
+          *
+          *     E: Not valid on [DevSNB] if 4x PERPIXEL mode with pixel shader
+          *     computed depth.
+          *
+          *     F: Valid on all products, except not valid on [DevSNB] if 4x
+          *     PERPIXEL mode with pixel shader computed depth.
+          *
+          * In the table that follows, the only entry with "A" in the Valid
+          * column is the entry where only 8 pixel dispatch is enabled.
+          * Therefore, when we are in PERPIXEL mode with pixel shader computed
+          * depth, we need to disable SIMD16 dispatch.
+          */
+         if (dw5 & GEN6_WM_COMPUTED_DEPTH)
+            dw5 &= ~GEN6_WM_16_DISPATCH_ENABLE;
+      }
    } else {
       dw6 |= GEN6_WM_MSRAST_OFF_PIXEL;
       dw6 |= GEN6_WM_MSDISPMODE_PERSAMPLE;
diff --git a/src/mesa/drivers/dri/i965/gen7_blorp.cpp b/src/mesa/drivers/dri/i965/gen7_blorp.cpp
index 71f31b7..540c46d 100644
--- a/src/mesa/drivers/dri/i965/gen7_blorp.cpp
+++ b/src/mesa/drivers/dri/i965/gen7_blorp.cpp
@@ -844,7 +844,6 @@ gen7_blorp_exec(struct brw_context *brw,
    uint32_t sampler_offset = 0;
 
    uint32_t prog_offset = params->get_wm_prog(brw, &prog_data);
-   gen6_blorp_emit_batch_head(brw, params);
    gen6_emit_3dstate_multisample(brw, params->num_samples);
    gen6_emit_3dstate_sample_mask(brw, params->num_samples, 1.0, false, ~0u);
    gen6_blorp_emit_state_base_address(brw, params);
diff --git a/src/mesa/drivers/dri/i965/gen7_clip_state.c b/src/mesa/drivers/dri/i965/gen7_clip_state.c
deleted file mode 100644
index 5c095a1..0000000
--- a/src/mesa/drivers/dri/i965/gen7_clip_state.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright © 2011 Intel Corporation
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice (including the next
- * paragraph) shall be included in all copies or substantial portions of the
- * Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
- * IN THE SOFTWARE.
- */
-
-#include "brw_context.h"
-#include "brw_state.h"
-#include "brw_defines.h"
-#include "brw_util.h"
-#include "intel_batchbuffer.h"
-#include "main/fbobject.h"
-
-static void
-upload_clip_state(struct brw_context *brw)
-{
-   struct gl_context *ctx = &brw->ctx;
-   uint32_t dw1 = 0, dw2 = 0;
-
-   /* _NEW_BUFFERS */
-   struct gl_framebuffer *fb = ctx->DrawBuffer;
-   bool render_to_fbo = _mesa_is_user_fbo(fb);
-
-   /* BRW_NEW_META_IN_PROGRESS */
-   if (!brw->meta_in_progress)
-      dw1 |= GEN6_CLIP_STATISTICS_ENABLE;
-
-   /* CACHE_NEW_WM_PROG */
-   if (brw->wm.prog_data->barycentric_interp_modes &
-       BRW_WM_NONPERSPECTIVE_BARYCENTRIC_BITS) {
-      dw2 |= GEN6_CLIP_NON_PERSPECTIVE_BARYCENTRIC_ENABLE;
-   }
-
-   dw1 |= GEN7_CLIP_EARLY_CULL;
-
-   /* _NEW_POLYGON */
-   if ((ctx->Polygon.FrontFace == GL_CCW) ^ render_to_fbo)
-      dw1 |= GEN7_CLIP_WINDING_CCW;
-
-   if (ctx->Polygon.CullFlag) {
-      switch (ctx->Polygon.CullFaceMode) {
-      case GL_FRONT:
-	 dw1 |= GEN7_CLIP_CULLMODE_FRONT;
-	 break;
-      case GL_BACK:
-	 dw1 |= GEN7_CLIP_CULLMODE_BACK;
-	 break;
-      case GL_FRONT_AND_BACK:
-	 dw1 |= GEN7_CLIP_CULLMODE_BOTH;
-	 break;
-      default:
-	 assert(!"Should not get here: invalid CullFlag");
-	 break;
-      }
-   } else {
-      dw1 |= GEN7_CLIP_CULLMODE_NONE;
-   }
-
-   /* _NEW_TRANSFORM */
-   if (!ctx->Transform.DepthClamp)
-      dw2 |= GEN6_CLIP_Z_TEST;
-
-   /* _NEW_LIGHT */
-   if (ctx->Light.ProvokingVertex == GL_FIRST_VERTEX_CONVENTION) {
-      dw2 |=
-	 (0 << GEN6_CLIP_TRI_PROVOKE_SHIFT) |
-	 (1 << GEN6_CLIP_TRIFAN_PROVOKE_SHIFT) |
-	 (0 << GEN6_CLIP_LINE_PROVOKE_SHIFT);
-   } else {
-      dw2 |=
-	 (2 << GEN6_CLIP_TRI_PROVOKE_SHIFT) |
-	 (2 << GEN6_CLIP_TRIFAN_PROVOKE_SHIFT) |
-	 (1 << GEN6_CLIP_LINE_PROVOKE_SHIFT);
-   }
-
-   /* _NEW_TRANSFORM */
-   dw2 |= (ctx->Transform.ClipPlanesEnabled <<
-           GEN6_USER_CLIP_CLIP_DISTANCES_SHIFT);
-
-   if (ctx->Viewport.X == 0 &&
-       ctx->Viewport.Y == 0 &&
-       ctx->Viewport.Width == fb->Width &&
-       ctx->Viewport.Height == fb->Height) {
-      dw2 |= GEN6_CLIP_GB_TEST;
-   }
-
-   /* BRW_NEW_RASTERIZER_DISCARD */
-   if (ctx->RasterDiscard) {
-      dw2 |= GEN6_CLIP_MODE_REJECT_ALL;
-      perf_debug("Rasterizer discard is currently implemented via the clipper; "
-                 "using the SOL unit may be faster.");
-   }
-
-   BEGIN_BATCH(4);
-   OUT_BATCH(_3DSTATE_CLIP << 16 | (4 - 2));
-   OUT_BATCH(dw1);
-   OUT_BATCH(GEN6_CLIP_ENABLE |
-	     GEN6_CLIP_API_OGL |
-	     GEN6_CLIP_MODE_NORMAL |
-	     GEN6_CLIP_XY_TEST |
-             dw2);
-   OUT_BATCH(U_FIXED(0.125, 3) << GEN6_CLIP_MIN_POINT_WIDTH_SHIFT |
-             U_FIXED(255.875, 3) << GEN6_CLIP_MAX_POINT_WIDTH_SHIFT |
-             (fb->Layered ? 0 : GEN6_CLIP_FORCE_ZERO_RTAINDEX));
-   ADVANCE_BATCH();
-}
-
-const struct brw_tracked_state gen7_clip_state = {
-   .dirty = {
-      .mesa  = (_NEW_BUFFERS |
-                _NEW_POLYGON |
-                _NEW_LIGHT |
-                _NEW_TRANSFORM),
-      .brw   = BRW_NEW_CONTEXT |
-               BRW_NEW_META_IN_PROGRESS |
-               BRW_NEW_RASTERIZER_DISCARD,
-      .cache = CACHE_NEW_WM_PROG
-   },
-   .emit = upload_clip_state,
-};
diff --git a/src/mesa/drivers/dri/i965/gen7_gs_state.c b/src/mesa/drivers/dri/i965/gen7_gs_state.c
index 2602200..584f2db 100644
--- a/src/mesa/drivers/dri/i965/gen7_gs_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_gs_state.c
@@ -85,7 +85,9 @@ upload_gs_state(struct brw_context *brw)
       OUT_BATCH(_3DSTATE_GS << 16 | (7 - 2));
       OUT_BATCH(stage_state->prog_offset);
       OUT_BATCH(((ALIGN(stage_state->sampler_count, 4)/4) <<
-                 GEN6_GS_SAMPLER_COUNT_SHIFT));
+                 GEN6_GS_SAMPLER_COUNT_SHIFT) |
+                ((brw->gs.prog_data->base.base.binding_table.size_bytes / 4) <<
+                 GEN6_GS_BINDING_TABLE_ENTRY_COUNT_SHIFT));
 
       if (brw->gs.prog_data->base.total_scratch) {
          OUT_RELOC(stage_state->scratch_bo,
diff --git a/src/mesa/drivers/dri/i965/gen7_vs_state.c b/src/mesa/drivers/dri/i965/gen7_vs_state.c
index 4fd1913..1e76eb1 100644
--- a/src/mesa/drivers/dri/i965/gen7_vs_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_vs_state.c
@@ -100,7 +100,9 @@ upload_vs_state(struct brw_context *brw)
    OUT_BATCH(stage_state->prog_offset);
    OUT_BATCH(floating_point_mode |
 	     ((ALIGN(stage_state->sampler_count, 4)/4) <<
-              GEN6_VS_SAMPLER_COUNT_SHIFT));
+              GEN6_VS_SAMPLER_COUNT_SHIFT) |
+             ((brw->vs.prog_data->base.base.binding_table.size_bytes / 4) <<
+              GEN6_VS_BINDING_TABLE_ENTRY_COUNT_SHIFT));
 
    if (brw->vs.prog_data->base.total_scratch) {
       OUT_RELOC(stage_state->scratch_bo,
diff --git a/src/mesa/drivers/dri/i965/gen7_wm_state.c b/src/mesa/drivers/dri/i965/gen7_wm_state.c
index 58a6438..65c9bbf 100644
--- a/src/mesa/drivers/dri/i965/gen7_wm_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_wm_state.c
@@ -160,6 +160,10 @@ upload_ps_state(struct brw_context *brw)
    dw2 |=
       (ALIGN(brw->wm.base.sampler_count, 4) / 4) << GEN7_PS_SAMPLER_COUNT_SHIFT;
 
+   /* CACHE_NEW_WM_PROG */
+   dw2 |= ((brw->wm.prog_data->base.binding_table.size_bytes / 4) <<
+           GEN7_PS_BINDING_TABLE_ENTRY_COUNT_SHIFT);
+
    /* Use ALT floating point mode for ARB fragment programs, because they
     * require 0^0 == 1.  Even though _CurrentFragmentProgram is used for
     * rendering, CurrentFragmentProgram is used for this check to
@@ -230,16 +234,21 @@ upload_ps_state(struct brw_context *brw)
 
    if (brw->wm.prog_data->prog_offset_16) {
       dw4 |= GEN7_PS_16_DISPATCH_ENABLE;
-      if (min_inv_per_frag == 1)
+      if (min_inv_per_frag == 1) {
          dw4 |= GEN7_PS_8_DISPATCH_ENABLE;
+         dw5 |= (brw->wm.prog_data->first_curbe_grf <<
+                 GEN7_PS_DISPATCH_START_GRF_SHIFT_0);
+         dw5 |= (brw->wm.prog_data->first_curbe_grf_16 <<
+                 GEN7_PS_DISPATCH_START_GRF_SHIFT_2);
+      } else
+         dw5 |= (brw->wm.prog_data->first_curbe_grf_16 <<
+                 GEN7_PS_DISPATCH_START_GRF_SHIFT_0);
    }
-   else
+   else {
       dw4 |= GEN7_PS_8_DISPATCH_ENABLE;
-
-   dw5 |= (brw->wm.prog_data->first_curbe_grf <<
-	   GEN7_PS_DISPATCH_START_GRF_SHIFT_0);
-   dw5 |= (brw->wm.prog_data->first_curbe_grf_16 <<
-	   GEN7_PS_DISPATCH_START_GRF_SHIFT_2);
+      dw5 |= (brw->wm.prog_data->first_curbe_grf <<
+              GEN7_PS_DISPATCH_START_GRF_SHIFT_0);
+   }
 
    BEGIN_BATCH(8);
    OUT_BATCH(_3DSTATE_PS << 16 | (8 - 2));
diff --git a/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c b/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
index ed7565f..c3bd96d 100644
--- a/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
@@ -41,8 +41,8 @@
  * Convert an swizzle enumeration (i.e. SWIZZLE_X) to one of the Gen7.5+
  * "Shader Channel Select" enumerations (i.e. HSW_SCS_RED)
  */
-static unsigned
-swizzle_to_scs(GLenum swizzle, bool need_green_to_blue)
+unsigned
+brw_swizzle_to_scs(GLenum swizzle, bool need_green_to_blue)
 {
    switch (swizzle) {
    case SWIZZLE_X:
@@ -268,44 +268,6 @@ gen7_emit_buffer_surface_state(struct brw_context *brw,
 }
 
 static void
-gen7_update_buffer_texture_surface(struct gl_context *ctx,
-                                   unsigned unit,
-                                   uint32_t *surf_offset)
-{
-   struct brw_context *brw = brw_context(ctx);
-   struct gl_texture_object *tObj = ctx->Texture.Unit[unit]._Current;
-   struct intel_buffer_object *intel_obj =
-      intel_buffer_object(tObj->BufferObject);
-   uint32_t size = tObj->BufferSize;
-   drm_intel_bo *bo = NULL;
-
-   if (intel_obj) {
-      size = MIN2(size, intel_obj->Base.Size);
-      bo = intel_bufferobj_buffer(brw, intel_obj, tObj->BufferOffset, size);
-   }
-
-   gl_format format = tObj->_BufferObjectFormat;
-
-   uint32_t surface_format = brw_format_for_mesa_format(format);
-   if (surface_format == 0 && format != MESA_FORMAT_RGBA_FLOAT32) {
-      _mesa_problem(NULL, "bad format %s for texture buffer\n",
-                    _mesa_get_format_name(format));
-   }
-
-   int texel_size = _mesa_get_format_bytes(format);
-
-   gen7_emit_buffer_surface_state(brw,
-                                  surf_offset,
-                                  bo,
-                                  tObj->BufferOffset,
-                                  surface_format,
-                                  size / texel_size,
-                                  texel_size,
-                                  0 /* mocs */,
-                                  false /* rw */);
-}
-
-static void
 gen7_update_texture_surface(struct gl_context *ctx,
                             unsigned unit,
                             uint32_t *surf_offset,
@@ -319,7 +281,7 @@ gen7_update_texture_surface(struct gl_context *ctx,
    struct gl_sampler_object *sampler = _mesa_get_samplerobj(ctx, unit);
 
    if (tObj->Target == GL_TEXTURE_BUFFER) {
-      gen7_update_buffer_texture_surface(ctx, unit, surf_offset);
+      brw_update_buffer_texture_surface(ctx, unit, surf_offset);
       return;
    }
 
@@ -381,10 +343,10 @@ gen7_update_texture_surface(struct gl_context *ctx,
       const bool need_scs_green_to_blue = for_gather && tex_format == BRW_SURFACEFORMAT_R32G32_FLOAT_LD;
 
       surf[7] =
-         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 0), need_scs_green_to_blue), GEN7_SURFACE_SCS_R) |
-         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 1), need_scs_green_to_blue), GEN7_SURFACE_SCS_G) |
-         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 2), need_scs_green_to_blue), GEN7_SURFACE_SCS_B) |
-         SET_FIELD(swizzle_to_scs(GET_SWZ(swizzle, 3), need_scs_green_to_blue), GEN7_SURFACE_SCS_A);
+         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 0), need_scs_green_to_blue), GEN7_SURFACE_SCS_R) |
+         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 1), need_scs_green_to_blue), GEN7_SURFACE_SCS_G) |
+         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 2), need_scs_green_to_blue), GEN7_SURFACE_SCS_B) |
+         SET_FIELD(brw_swizzle_to_scs(GET_SWZ(swizzle, 3), need_scs_green_to_blue), GEN7_SURFACE_SCS_A);
    }
 
    /* Emit relocation to surface contents */
@@ -398,32 +360,6 @@ gen7_update_texture_surface(struct gl_context *ctx,
 }
 
 /**
- * Create the constant buffer surface.  Vertex/fragment shader constants will
- * be read from this buffer with Data Port Read instructions/messages.
- */
-static void
-gen7_create_constant_surface(struct brw_context *brw,
-			     drm_intel_bo *bo,
-			     uint32_t offset,
-			     uint32_t size,
-			     uint32_t *out_offset,
-                             bool dword_pitch)
-{
-   uint32_t stride = dword_pitch ? 4 : 16;
-   uint32_t elements = ALIGN(size, stride) / stride;
-
-   gen7_emit_buffer_surface_state(brw,
-                                  out_offset,
-                                  bo,
-                                  offset,
-                                  BRW_SURFACEFORMAT_R32G32B32A32_FLOAT,
-                                  elements,
-                                  stride,
-                                  0 /* mocs */,
-                                  false /* rw */);
-}
-
-/**
  * Create a raw surface for untyped R/W access.
  */
 static void
@@ -613,6 +549,6 @@ gen7_init_vtable_surface_functions(struct brw_context *brw)
    brw->vtbl.update_renderbuffer_surface = gen7_update_renderbuffer_surface;
    brw->vtbl.update_null_renderbuffer_surface =
       gen7_update_null_renderbuffer_surface;
-   brw->vtbl.create_constant_surface = gen7_create_constant_surface;
    brw->vtbl.create_raw_surface = gen7_create_raw_surface;
+   brw->vtbl.emit_buffer_surface_state = gen7_emit_buffer_surface_state;
 }
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index 6d1ae79..fb0b45b 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -178,6 +178,9 @@ do_batch_dump(struct brw_context *brw)
 static void
 brw_new_batch(struct brw_context *brw)
 {
+   /* Create a new batchbuffer and reset the associated state: */
+   intel_batchbuffer_reset(brw);
+
    /* If the kernel supports hardware contexts, then most hardware state is
     * preserved between batches; we only need to re-emit state that is required
     * to be in every batch.  Otherwise we need to re-emit all the state that
@@ -198,12 +201,6 @@ brw_new_batch(struct brw_context *brw)
 
    brw->ib.type = -1;
 
-   /* Mark that the current program cache BO has been used by the GPU.
-    * It will be reallocated if we need to put new programs in for the
-    * next batch.
-    */
-   brw->cache.bo_used_by_gpu = true;
-
    /* We need to periodically reap the shader time results, because rollover
     * happens every few seconds.  We also want to see results every once in a
     * while, because many programs won't cleanly destroy our context, so the
@@ -232,6 +229,12 @@ brw_finish_batch(struct brw_context *brw)
       drm_intel_bo_unreference(brw->curbe.curbe_bo);
       brw->curbe.curbe_bo = NULL;
    }
+
+   /* Mark that the current program cache BO has been used by the GPU.
+    * It will be reallocated if we need to put new programs in for the
+    * next batch.
+    */
+   brw->cache.bo_used_by_gpu = true;
 }
 
 /* TODO: Push this whole function into bufmgr.
@@ -286,7 +289,6 @@ do_flush_locked(struct brw_context *brw)
       fprintf(stderr, "intel_do_flush_locked failed: %s\n", strerror(-ret));
       exit(1);
    }
-   brw_new_batch(brw);
 
    return ret;
 }
@@ -339,9 +341,8 @@ _intel_batchbuffer_flush(struct brw_context *brw,
       drm_intel_bo_wait_rendering(brw->batch.bo);
    }
 
-   /* Reset the buffer:
-    */
-   intel_batchbuffer_reset(brw);
+   /* Start a new batch buffer. */
+   brw_new_batch(brw);
 
    return ret;
 }
diff --git a/src/mesa/drivers/dri/i965/intel_blit.c b/src/mesa/drivers/dri/i965/intel_blit.c
index b5857bb..0a03859 100644
--- a/src/mesa/drivers/dri/i965/intel_blit.c
+++ b/src/mesa/drivers/dri/i965/intel_blit.c
@@ -417,8 +417,7 @@ intelEmitImmediateColorExpandBlit(struct brw_context *brw,
 	 return false;
    }
 
-   assert( logic_op - GL_CLEAR >= 0 );
-   assert( logic_op - GL_CLEAR < 0x10 );
+   assert((logic_op >= GL_CLEAR) && (logic_op <= (GL_CLEAR + 0x0f)));
    assert(dst_pitch > 0);
 
    if (w < 0 || h < 0)
diff --git a/src/mesa/drivers/dri/i965/intel_extensions.c b/src/mesa/drivers/dri/i965/intel_extensions.c
index 5eae84f..62c0b15 100644
--- a/src/mesa/drivers/dri/i965/intel_extensions.c
+++ b/src/mesa/drivers/dri/i965/intel_extensions.c
@@ -210,6 +210,7 @@ intelInitExtensions(struct gl_context *ctx)
       ctx->Extensions.ARB_shading_language_packing = true;
       ctx->Extensions.ARB_texture_multisample = true;
       ctx->Extensions.ARB_sample_shading = true;
+      ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev = true;
 
       /* Test if the kernel has the ioctl. */
       if (drm_intel_reg_read(brw->bufmgr, TIMESTAMP, &dummy) == 0)
@@ -223,9 +224,6 @@ intelInitExtensions(struct gl_context *ctx)
       ctx->Extensions.ARB_texture_query_levels = ctx->Const.GLSLVersion >= 130;
    }
 
-   if (brw->gen == 5)
-      ctx->Extensions.AMD_performance_monitor = true;
-
    if (brw->gen >= 7) {
       ctx->Extensions.ARB_texture_gather = true;
       ctx->Extensions.ARB_conservative_depth = true;
@@ -245,4 +243,7 @@ intelInitExtensions(struct gl_context *ctx)
       ctx->Extensions.EXT_texture_compression_s3tc = true;
 
    ctx->Extensions.ANGLE_texture_compression_dxt = true;
+
+   if (brw->gen >= 7)
+      ctx->Extensions.ARB_shader_atomic_counters = true;
 }
diff --git a/src/mesa/drivers/dri/i965/intel_mipmap_tree.c b/src/mesa/drivers/dri/i965/intel_mipmap_tree.c
index 2f5e04f..884ddef 100644
--- a/src/mesa/drivers/dri/i965/intel_mipmap_tree.c
+++ b/src/mesa/drivers/dri/i965/intel_mipmap_tree.c
@@ -44,6 +44,7 @@
 #include "main/glformats.h"
 #include "main/texcompress_etc.h"
 #include "main/teximage.h"
+#include "main/streaming-load-memcpy.h"
 
 #define FILE_DEBUG_FLAG DEBUG_MIPTREE
 
@@ -635,8 +636,10 @@ intel_miptree_create_for_bo(struct brw_context *brw,
                                     0, 0,
                                     width, height, 1,
                                     true, 0 /* num_samples */);
-   if (!mt)
+   if (!mt) {
+      free(region);
       return mt;
+   }
 
    region->cpp = mt->cpp;
    region->width = width;
@@ -725,6 +728,67 @@ intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
    return multisample_mt;
 }
 
+/**
+ * For a singlesample image buffer, this simply wraps the given region with a miptree.
+ *
+ * For a multisample image buffer, this wraps the given region with
+ * a singlesample miptree, then creates a multisample miptree into which the
+ * singlesample miptree is embedded as a child.
+ */
+struct intel_mipmap_tree*
+intel_miptree_create_for_image_buffer(struct brw_context *intel,
+                                      enum __DRIimageBufferMask buffer_type,
+                                      gl_format format,
+                                      uint32_t num_samples,
+                                      struct intel_region *region)
+{
+   struct intel_mipmap_tree *singlesample_mt = NULL;
+   struct intel_mipmap_tree *multisample_mt = NULL;
+
+   /* Only the front and back buffers, which are color buffers, are allocated
+    * through the image loader.
+    */
+   assert(_mesa_get_format_base_format(format) == GL_RGB ||
+          _mesa_get_format_base_format(format) == GL_RGBA);
+
+   singlesample_mt = intel_miptree_create_for_bo(intel,
+                                                 region->bo,
+                                                 format,
+                                                 0,
+                                                 region->width,
+                                                 region->height,
+                                                 region->pitch,
+                                                 region->tiling);
+   if (!singlesample_mt)
+      return NULL;
+
+   intel_region_reference(&singlesample_mt->region, region);
+
+   if (num_samples == 0)
+      return singlesample_mt;
+
+   multisample_mt = intel_miptree_create_for_renderbuffer(intel,
+                                                          format,
+                                                          region->width,
+                                                          region->height,
+                                                          num_samples);
+   if (!multisample_mt) {
+      intel_miptree_release(&singlesample_mt);
+      return NULL;
+   }
+
+   multisample_mt->singlesample_mt = singlesample_mt;
+   multisample_mt->need_downsample = false;
+
+   intel_region_reference(&multisample_mt->region, region);
+
+   if (intel->is_front_buffer_rendering && buffer_type == __DRI_IMAGE_BUFFER_FRONT) {
+      intel_miptree_upsample(intel, multisample_mt);
+   }
+
+   return multisample_mt;
+}
+
 struct intel_mipmap_tree*
 intel_miptree_create_for_renderbuffer(struct brw_context *brw,
                                       gl_format format,
@@ -1774,6 +1838,79 @@ intel_miptree_unmap_blit(struct brw_context *brw,
    intel_miptree_release(&map->mt);
 }
 
+#ifdef __SSE4_1__
+/**
+ * "Map" a buffer by copying it to an untiled temporary using MOVNTDQA.
+ */
+static void
+intel_miptree_map_movntdqa(struct brw_context *brw,
+                           struct intel_mipmap_tree *mt,
+                           struct intel_miptree_map *map,
+                           unsigned int level, unsigned int slice)
+{
+   assert(map->mode & GL_MAP_READ_BIT);
+   assert(!(map->mode & GL_MAP_WRITE_BIT));
+
+   DBG("%s: %d,%d %dx%d from mt %p (%s) %d,%d = %p/%d\n", __FUNCTION__,
+       map->x, map->y, map->w, map->h,
+       mt, _mesa_get_format_name(mt->format),
+       level, slice, map->ptr, map->stride);
+
+   /* Map the original image */
+   uint32_t image_x;
+   uint32_t image_y;
+   intel_miptree_get_image_offset(mt, level, slice, &image_x, &image_y);
+   image_x += map->x;
+   image_y += map->y;
+
+   void *src = intel_miptree_map_raw(brw, mt);
+   if (!src)
+      return;
+   src += image_y * mt->region->pitch;
+   src += image_x * mt->region->cpp;
+
+   /* Due to the pixel offsets for the particular image being mapped, our
+    * src pointer may not be 16-byte aligned.  However, if the pitch is
+    * divisible by 16, then the amount by which it's misaligned will remain
+    * consistent from row to row.
+    */
+   assert((mt->region->pitch % 16) == 0);
+   const int misalignment = ((uintptr_t) src) & 15;
+
+   /* Create an untiled temporary buffer for the mapping. */
+   const unsigned width_bytes = _mesa_format_row_stride(mt->format, map->w);
+
+   map->stride = ALIGN(misalignment + width_bytes, 16);
+
+   map->buffer = malloc(map->stride * map->h);
+   /* Offset the destination so it has the same misalignment as src. */
+   map->ptr = map->buffer + misalignment;
+
+   assert((((uintptr_t) map->ptr) & 15) == misalignment);
+
+   for (uint32_t y = 0; y < map->h; y++) {
+      void *dst_ptr = map->ptr + y * map->stride;
+      void *src_ptr = src + y * mt->region->pitch;
+
+      _mesa_streaming_load_memcpy(dst_ptr, src_ptr, width_bytes);
+   }
+
+   intel_miptree_unmap_raw(brw, mt);
+}
+
+static void
+intel_miptree_unmap_movntdqa(struct brw_context *brw,
+                             struct intel_mipmap_tree *mt,
+                             struct intel_miptree_map *map,
+                             unsigned int level,
+                             unsigned int slice)
+{
+   free(map->buffer);
+   map->buffer = NULL;
+   map->ptr = NULL;
+}
+#endif
+
 static void
 intel_miptree_map_s8(struct brw_context *brw,
 		     struct intel_mipmap_tree *mt,
@@ -2137,6 +2274,10 @@ intel_miptree_map_singlesample(struct brw_context *brw,
               mt->region->bo->size >= brw->max_gtt_map_object_size) {
       assert(mt->region->pitch < 32768);
       intel_miptree_map_blit(brw, mt, map, level, slice);
+#ifdef __SSE4_1__
+   } else if (!(mode & GL_MAP_WRITE_BIT) && !mt->compressed) {
+      intel_miptree_map_movntdqa(brw, mt, map, level, slice);
+#endif
    } else {
       intel_miptree_map_gtt(brw, mt, map, level, slice);
    }
@@ -2173,6 +2314,10 @@ intel_miptree_unmap_singlesample(struct brw_context *brw,
       intel_miptree_unmap_depthstencil(brw, mt, map, level, slice);
    } else if (map->mt) {
       intel_miptree_unmap_blit(brw, mt, map, level, slice);
+#ifdef __SSE4_1__
+   } else if (map->buffer) {
+      intel_miptree_unmap_movntdqa(brw, mt, map, level, slice);
+#endif
    } else {
       intel_miptree_unmap_gtt(brw, mt, map, level, slice);
    }
diff --git a/src/mesa/drivers/dri/i965/intel_mipmap_tree.h b/src/mesa/drivers/dri/i965/intel_mipmap_tree.h
index d718125..8777a8c 100644
--- a/src/mesa/drivers/dri/i965/intel_mipmap_tree.h
+++ b/src/mesa/drivers/dri/i965/intel_mipmap_tree.h
@@ -32,6 +32,7 @@
 
 #include "intel_regions.h"
 #include "intel_resolve_map.h"
+#include <GL/internal/dri_interface.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -529,6 +530,13 @@ intel_miptree_create_for_dri2_buffer(struct brw_context *brw,
                                      uint32_t num_samples,
                                      struct intel_region *region);
 
+struct intel_mipmap_tree*
+intel_miptree_create_for_image_buffer(struct brw_context *intel,
+                                     enum __DRIimageBufferMask buffer_type,
+                                     gl_format format,
+                                     uint32_t num_samples,
+                                     struct intel_region *region);
+
 /**
  * Create a miptree appropriate as the storage for a non-texture renderbuffer.
  * The miptree has the following properties:
diff --git a/src/mesa/drivers/dri/i965/intel_pixel.c b/src/mesa/drivers/dri/i965/intel_pixel.c
index 623f4f4..fc70381 100644
--- a/src/mesa/drivers/dri/i965/intel_pixel.c
+++ b/src/mesa/drivers/dri/i965/intel_pixel.c
@@ -115,6 +115,11 @@ intel_check_blit_fragment_ops(struct gl_context * ctx, bool src_alpha_is_one)
       return false;
    }
 
+   if (ctx->Pixel.ZoomX != 1.0F || ctx->Pixel.ZoomY != 1.0F) {
+      DBG("fallback due to pixel zoom\n");
+      return false;
+   }
+
    if (ctx->RenderMode != GL_RENDER) {
       DBG("fallback due to render mode\n");
       return false;
diff --git a/src/mesa/drivers/dri/i965/intel_pixel_draw.c b/src/mesa/drivers/dri/i965/intel_pixel_draw.c
index af618a2..477586e 100644
--- a/src/mesa/drivers/dri/i965/intel_pixel_draw.c
+++ b/src/mesa/drivers/dri/i965/intel_pixel_draw.c
@@ -29,14 +29,115 @@
 #include "main/enums.h"
 #include "main/image.h"
 #include "main/mtypes.h"
+#include "main/condrender.h"
+#include "main/fbobject.h"
 #include "main/teximage.h"
 #include "main/texobj.h"
 #include "main/texstate.h"
+#include "main/bufferobj.h"
 #include "swrast/swrast.h"
 #include "drivers/common/meta.h"
 
 #include "brw_context.h"
+#include "intel_screen.h"
+#include "intel_blit.h"
+#include "intel_buffers.h"
+#include "intel_fbo.h"
+#include "intel_mipmap_tree.h"
+#include "intel_regions.h"
 #include "intel_pixel.h"
+#include "intel_buffer_objects.h"
+
+#define FILE_DEBUG_FLAG DEBUG_PIXEL
+
+static bool
+do_blit_drawpixels(struct gl_context * ctx,
+		   GLint x, GLint y, GLsizei width, GLsizei height,
+		   GLenum format, GLenum type,
+		   const struct gl_pixelstore_attrib *unpack,
+		   const GLvoid * pixels)
+{
+   struct brw_context *brw = brw_context(ctx);
+   struct intel_buffer_object *src = intel_buffer_object(unpack->BufferObj);
+   GLuint src_offset;
+   drm_intel_bo *src_buffer;
+
+   DBG("%s\n", __FUNCTION__);
+
+   if (!intel_check_blit_fragment_ops(ctx, false))
+      return false;
+
+   if (ctx->DrawBuffer->_NumColorDrawBuffers != 1) {
+      DBG("%s: fallback due to MRT\n", __FUNCTION__);
+      return false;
+   }
+
+   struct gl_renderbuffer *rb = ctx->DrawBuffer->_ColorDrawBuffers[0];
+   struct intel_renderbuffer *irb = intel_renderbuffer(rb);
+
+   if (!_mesa_format_matches_format_and_type(irb->mt->format, format, type,
+                                             false)) {
+      DBG("%s: bad format for blit\n", __FUNCTION__);
+      return false;
+   }
+
+   if (unpack->SwapBytes || unpack->LsbFirst ||
+       unpack->SkipPixels || unpack->SkipRows) {
+      DBG("%s: bad packing params\n", __FUNCTION__);
+      return false;
+   }
+
+   int src_stride = _mesa_image_row_stride(unpack, width, format, type);
+   bool src_flip = false;
+   /* Mesa flips the src_stride for unpack->Invert, but we want our mt to have
+    * a normal src_stride.
+    */
+   if (unpack->Invert) {
+      src_stride = -src_stride;
+      src_flip = true;
+   }
+
+   src_offset = (GLintptr)pixels;
+   src_offset += _mesa_image_offset(2, unpack, width, height,
+				    format, type, 0, 0, 0);
+
+   intel_prepare_render(brw);
+
+   src_buffer = intel_bufferobj_buffer(brw, src,
+				       src_offset, width * height *
+                                       irb->mt->cpp);
+
+   struct intel_mipmap_tree *pbo_mt =
+      intel_miptree_create_for_bo(brw,
+                                  src_buffer,
+                                  irb->mt->format,
+                                  src_offset,
+                                  width, height,
+                                  src_stride, I915_TILING_NONE);
+   if (!pbo_mt)
+      return false;
+
+   if (!intel_miptree_blit(brw,
+                           pbo_mt, 0, 0,
+                           0, 0, src_flip,
+                           irb->mt, irb->mt_level, irb->mt_layer,
+                           x, y, _mesa_is_winsys_fbo(ctx->DrawBuffer),
+                           width, height, GL_COPY)) {
+      DBG("%s: blit failed\n", __FUNCTION__);
+      intel_miptree_release(&pbo_mt);
+      return false;
+   }
+
+   intel_miptree_release(&pbo_mt);
+
+   if (ctx->Query.CurrentOcclusionObject)
+      ctx->Query.CurrentOcclusionObject->Result += width * height;
+
+   intel_check_front_buffer_rendering(brw);
+
+   DBG("%s: success\n", __FUNCTION__);
+   return true;
+}
 
 void
 intelDrawPixels(struct gl_context * ctx,
@@ -47,12 +148,26 @@ intelDrawPixels(struct gl_context * ctx,
                 const struct gl_pixelstore_attrib *unpack,
                 const GLvoid * pixels)
 {
+   struct brw_context *brw = brw_context(ctx);
+
+   if (!_mesa_check_conditional_render(ctx))
+      return;
+
    if (format == GL_STENCIL_INDEX) {
       _swrast_DrawPixels(ctx, x, y, width, height, format, type,
                          unpack, pixels);
       return;
    }
 
+   if (_mesa_is_bufferobj(unpack->BufferObj)) {
+      if (do_blit_drawpixels(ctx, x, y, width, height, format, type, unpack,
+			     pixels)) {
+	 return;
+      }
+
+      perf_debug("%s: fallback to generic code in PBO case\n", __FUNCTION__);
+   }
+
    _mesa_meta_DrawPixels(ctx, x, y, width, height, format, type,
                          unpack, pixels);
 }
diff --git a/src/mesa/drivers/dri/i965/intel_regions.c b/src/mesa/drivers/dri/i965/intel_regions.c
index a6b80fd..3920f4f 100644
--- a/src/mesa/drivers/dri/i965/intel_regions.c
+++ b/src/mesa/drivers/dri/i965/intel_regions.c
@@ -209,6 +209,7 @@ struct intel_region *
 intel_region_alloc_for_fd(struct intel_screen *screen,
                           GLuint cpp,
                           GLuint width, GLuint height, GLuint pitch,
+                          GLuint size,
                           int fd, const char *name)
 {
    struct intel_region *region;
@@ -216,8 +217,7 @@ intel_region_alloc_for_fd(struct intel_screen *screen,
    int ret;
    uint32_t bit_6_swizzle, tiling;
 
-   buffer = drm_intel_bo_gem_create_from_prime(screen->bufmgr,
-                                               fd, height * pitch);
+   buffer = drm_intel_bo_gem_create_from_prime(screen->bufmgr, fd, size);
    if (buffer == NULL)
       return NULL;
    ret = drm_intel_bo_get_tiling(buffer, &tiling, &bit_6_swizzle);
diff --git a/src/mesa/drivers/dri/i965/intel_regions.h b/src/mesa/drivers/dri/i965/intel_regions.h
index f08a113..05dfef3 100644
--- a/src/mesa/drivers/dri/i965/intel_regions.h
+++ b/src/mesa/drivers/dri/i965/intel_regions.h
@@ -92,6 +92,7 @@ struct intel_region *
 intel_region_alloc_for_fd(struct intel_screen *screen,
                           GLuint cpp,
                           GLuint width, GLuint height, GLuint pitch,
+                          GLuint size,
                           int fd, const char *name);
 
 bool
diff --git a/src/mesa/drivers/dri/i965/intel_screen.c b/src/mesa/drivers/dri/i965/intel_screen.c
index eafafa2..e44d0f6 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.c
+++ b/src/mesa/drivers/dri/i965/intel_screen.c
@@ -27,6 +27,7 @@
 
 #include <errno.h>
 #include <time.h>
+#include <unistd.h>
 #include "main/glheader.h"
 #include "main/context.h"
 #include "main/framebuffer.h"
@@ -63,11 +64,17 @@ DRI_CONF_BEGIN
       DRI_CONF_OPT_BEGIN_B(disable_derivative_optimization, "false")
 	 DRI_CONF_DESC(en, "Derivatives with finer granularity by default")
       DRI_CONF_OPT_END
-
    DRI_CONF_SECTION_END
+
    DRI_CONF_SECTION_QUALITY
       DRI_CONF_FORCE_S3TC_ENABLE("false")
+
+      DRI_CONF_OPT_BEGIN(clamp_max_samples, int, -1)
+              DRI_CONF_DESC(en, "Clamp the value of GL_MAX_SAMPLES to the "
+                            "given integer. If negative, then do not clamp.")
+      DRI_CONF_OPT_END
    DRI_CONF_SECTION_END
+
    DRI_CONF_SECTION_DEBUG
       DRI_CONF_NO_RAST("false")
       DRI_CONF_ALWAYS_FLUSH_BATCH("false")
@@ -292,38 +299,9 @@ intel_allocate_image(int dri_format, void *loaderPrivate)
     image->dri_format = dri_format;
     image->offset = 0;
 
-    switch (dri_format) {
-    case __DRI_IMAGE_FORMAT_RGB565:
-       image->format = MESA_FORMAT_RGB565;
-       break;
-    case __DRI_IMAGE_FORMAT_XRGB8888:
-       image->format = MESA_FORMAT_XRGB8888;
-       break;
-    case __DRI_IMAGE_FORMAT_ARGB2101010:
-       image->format = MESA_FORMAT_ARGB2101010;
-       break;
-    case __DRI_IMAGE_FORMAT_XRGB2101010:
-       image->format = MESA_FORMAT_XRGB2101010_UNORM;
-       break;
-    case __DRI_IMAGE_FORMAT_ARGB8888:
-       image->format = MESA_FORMAT_ARGB8888;
-       break;
-    case __DRI_IMAGE_FORMAT_ABGR8888:
-       image->format = MESA_FORMAT_RGBA8888_REV;
-       break;
-    case __DRI_IMAGE_FORMAT_XBGR8888:
-       image->format = MESA_FORMAT_RGBX8888_REV;
-       break;
-    case __DRI_IMAGE_FORMAT_R8:
-       image->format = MESA_FORMAT_R8;
-       break;
-    case __DRI_IMAGE_FORMAT_GR88:
-       image->format = MESA_FORMAT_GR88;
-       break;
-    case __DRI_IMAGE_FORMAT_NONE:
-       image->format = MESA_FORMAT_NONE;
-       break;
-    default:
+    image->format = driImageFormatToGLFormat(dri_format);
+    if (dri_format != __DRI_IMAGE_FORMAT_NONE &&
+        image->format == MESA_FORMAT_NONE) {
        free(image);
        return NULL;
     }
@@ -375,31 +353,6 @@ intel_setup_image_from_dimensions(__DRIimage *image)
    image->has_depthstencil = false;
 }
 
-static inline uint32_t
-intel_dri_format(GLuint format)
-{
-   switch (format) {
-   case MESA_FORMAT_RGB565:
-      return __DRI_IMAGE_FORMAT_RGB565;
-   case MESA_FORMAT_XRGB8888:
-      return __DRI_IMAGE_FORMAT_XRGB8888;
-   case MESA_FORMAT_ARGB8888:
-      return __DRI_IMAGE_FORMAT_ARGB8888;
-   case MESA_FORMAT_RGBA8888_REV:
-      return __DRI_IMAGE_FORMAT_ABGR8888;
-   case MESA_FORMAT_R8:
-      return __DRI_IMAGE_FORMAT_R8;
-   case MESA_FORMAT_RG88:
-      return __DRI_IMAGE_FORMAT_GR88;
-   case MESA_FORMAT_XRGB2101010_UNORM:
-      return __DRI_IMAGE_FORMAT_XRGB2101010;
-   case MESA_FORMAT_ARGB2101010:
-      return __DRI_IMAGE_FORMAT_ARGB2101010;
-   }
-
-   return MESA_FORMAT_NONE;
-}
-
 static __DRIimage *
 intel_create_image_from_name(__DRIscreen *screen,
 			     int width, int height, int format,
@@ -458,7 +411,7 @@ intel_create_image_from_renderbuffer(__DRIcontext *context,
    image->data = loaderPrivate;
    intel_region_reference(&image->region, irb->mt->region);
    intel_setup_image_from_dimensions(image);
-   image->dri_format = intel_dri_format(image->format);
+   image->dri_format = driGLFormatToImageFormat(image->format);
    image->has_depthstencil = irb->mt->stencil_mt? true : false;
 
    rb->NeedsFinishRenderTexture = true;
@@ -513,7 +466,7 @@ intel_create_image_from_texture(__DRIcontext *context, int target,
    image->format = obj->Image[face][level]->TexFormat;
    image->data = loaderPrivate;
    intel_setup_image_from_mipmap_tree(brw, image, iobj->mt, level, zoffset);
-   image->dri_format = intel_dri_format(image->format);
+   image->dri_format = driGLFormatToImageFormat(image->format);
    image->has_depthstencil = iobj->mt->stencil_mt? true : false;
    if (image->dri_format == MESA_FORMAT_NONE) {
       *error = __DRI_IMAGE_ERROR_BAD_PARAMETER;
@@ -712,8 +665,8 @@ intel_create_image_from_fds(__DRIscreen *screen,
       return NULL;
 
    image->region = intel_region_alloc_for_fd(intelScreen,
-                                             1, width, height,
-                                             strides[0], fds[0], "image");
+                                             f->planes[0].cpp, width, height, strides[0],
+                                             height * strides[0], fds[0], "image");
    if (image->region == NULL) {
       free(image);
       return NULL;
@@ -851,11 +804,102 @@ static struct __DRIimageExtensionRec intelImageExtension = {
     .createImageFromDmaBufs             = intel_create_image_from_dma_bufs
 };
 
+static int
+brw_query_renderer_integer(__DRIscreen *psp, int param, unsigned int *value)
+{
+   const struct intel_screen *const intelScreen =
+      (struct intel_screen *) psp->driverPrivate;
+
+   switch (param) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      value[0] = 0x8086;
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      value[0] = intelScreen->deviceID;
+      return 0;
+   case __DRI2_RENDERER_ACCELERATED:
+      value[0] = 1;
+      return 0;
+   case __DRI2_RENDERER_VIDEO_MEMORY: {
+      /* Once a batch uses more than 75% of the maximum mappable size, we
+       * assume that there's some fragmentation, and we start doing extra
+       * flushing, etc.  That's the big cliff apps will care about.
+       */
+      size_t aper_size;
+      size_t mappable_size;
+
+      drm_intel_get_aperture_sizes(psp->fd, &mappable_size, &aper_size);
+
+      const unsigned gpu_mappable_megabytes =
+         (aper_size / (1024 * 1024)) * 3 / 4;
+
+      const long system_memory_pages = sysconf(_SC_PHYS_PAGES);
+      const long system_page_size = sysconf(_SC_PAGE_SIZE);
+
+      if (system_memory_pages <= 0 || system_page_size <= 0)
+         return -1;
+
+      const uint64_t system_memory_bytes = (uint64_t) system_memory_pages
+         * (uint64_t) system_page_size;
+
+      const unsigned system_memory_megabytes =
+         (unsigned) (system_memory_bytes / 1024);
+
+      value[0] = MIN2(system_memory_megabytes, gpu_mappable_megabytes);
+      return 0;
+   }
+   case __DRI2_RENDERER_UNIFIED_MEMORY_ARCHITECTURE:
+      value[0] = 1;
+      return 0;
+   case __DRI2_RENDERER_PREFERRED_PROFILE:
+      value[0] = (psp->max_gl_core_version != 0)
+         ? (1U << __DRI_API_OPENGL_CORE) : (1U << __DRI_API_OPENGL);
+      return 0;
+   default:
+      return driQueryRendererIntegerCommon(psp, param, value);
+   }
+
+   return -1;
+}
+
+static int
+brw_query_renderer_string(__DRIscreen *psp, int param, const char **value)
+{
+   const struct intel_screen *intelScreen =
+      (struct intel_screen *) psp->driverPrivate;
+
+   switch (param) {
+   case __DRI2_RENDERER_VENDOR_ID:
+      value[0] = brw_vendor_string;
+      return 0;
+   case __DRI2_RENDERER_DEVICE_ID:
+      value[0] = brw_get_renderer_string(intelScreen->deviceID);
+      return 0;
+   default:
+      break;
+   }
+
+   return -1;
+}
+
+static struct __DRI2rendererQueryExtensionRec intelRendererQueryExtension = {
+   .base = { __DRI2_RENDERER_QUERY, 1 },
+
+   .queryInteger = brw_query_renderer_integer,
+   .queryString = brw_query_renderer_string
+};
+
+static const struct __DRIrobustnessExtensionRec dri2Robustness = {
+   { __DRI2_ROBUSTNESS, 1 }
+};
+
 static const __DRIextension *intelScreenExtensions[] = {
     &intelTexBufferExtension.base,
     &intelFlushExtension.base,
     &intelImageExtension.base,
+    &intelRendererQueryExtension.base,
     &dri2ConfigQueryExtension.base,
+    &dri2Robustness.base,
     NULL
 };
 
@@ -1225,7 +1269,8 @@ __DRIconfig **intelInitScreen2(__DRIscreen *psp)
 {
    struct intel_screen *intelScreen;
 
-   if (psp->dri2.loader->base.version <= 2 ||
+   if (psp->image.loader) {
+   } else if (psp->dri2.loader->base.version <= 2 ||
        psp->dri2.loader->getBuffersWithFormat == NULL) {
       fprintf(stderr,
 	      "\nERROR!  DRI2 loader with getBuffersWithFormat() "
@@ -1313,7 +1358,6 @@ intelReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
    free(intelBuffer);
 }
 
-
 static const struct __DriverAPIRec brw_driver_api = {
    .InitScreen		 = intelInitScreen2,
    .DestroyScreen	 = intelDestroyScreen,
@@ -1334,6 +1378,7 @@ static const struct __DRIDriverVtableExtensionRec brw_vtable = {
 
 static const __DRIextension *brw_driver_extensions[] = {
     &driCoreExtension.base,
+    &driImageDriverExtension.base,
     &driDRI2Extension.base,
     &brw_vtable.base,
     &brw_config_options.base,
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_context.c b/src/mesa/drivers/dri/nouveau/nouveau_context.c
index 0b648ac..d44864c 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_context.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_context.c
@@ -53,6 +53,7 @@ nouveau_context_create(gl_api api,
 		       unsigned major_version,
 		       unsigned minor_version,
 		       uint32_t flags,
+		       bool notify_reset,
 		       unsigned *error,
 		       void *share_ctx)
 {
@@ -61,9 +62,15 @@ nouveau_context_create(gl_api api,
 	struct nouveau_context *nctx;
 	struct gl_context *ctx;
 
-	/* API and flag filtering is handled in dri2CreateContextAttribs.
-	 */
-	(void) flags;
+	if (flags & ~__DRI_CTX_FLAG_DEBUG) {
+		*error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+		return false;
+	}
+
+	if (notify_reset) {
+		*error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+		return false;
+	}
 
 	ctx = screen->driver->context_create(screen, visual, share_ctx);
 	if (!ctx) {
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_context.h b/src/mesa/drivers/dri/nouveau/nouveau_context.h
index 2bcc1e1..07d9605 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_context.h
+++ b/src/mesa/drivers/dri/nouveau/nouveau_context.h
@@ -111,7 +111,8 @@ GLboolean
 nouveau_context_create(gl_api api,
 		       const struct gl_config *visual, __DRIcontext *dri_ctx,
 		       unsigned major_version, unsigned minor_version,
-		       uint32_t flags, unsigned *error, void *share_ctx);
+		       uint32_t flags, bool notify_reset, unsigned *error,
+		       void *share_ctx);
 
 GLboolean
 nouveau_context_init(struct gl_context *ctx, struct nouveau_screen *screen,
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_screen.c b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
index 4ab830e..ce98242 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_screen.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
@@ -93,22 +93,6 @@ nouveau_init_screen2(__DRIscreen *dri_screen)
 	if (!screen)
 		return NULL;
 
-
-        /* Compat version validation will occur at context init after
-         * _mesa_compute_version().
-         */
-        dri_screen->max_gl_compat_version = 15;
-
-        /* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
-         * cannot do even that.
-         */
-        if ((screen->device->chipset & 0xf0) != 0x00)
-                dri_screen->max_gl_es1_version = 10;
-
-	dri_screen->driverPrivate = screen;
-	dri_screen->extensions = nouveau_screen_extensions;
-	screen->dri_screen = dri_screen;
-
 	/* Open the DRM device. */
 	ret = nouveau_device_wrap(dri_screen->fd, 0, &screen->device);
 	if (ret) {
@@ -131,6 +115,21 @@ nouveau_init_screen2(__DRIscreen *dri_screen)
 		assert(0);
 	}
 
+	/* Compat version validation will occur at context init after
+	 * _mesa_compute_version().
+	 */
+	dri_screen->max_gl_compat_version = 15;
+
+	/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
+	 * cannot do even that.
+	 */
+	if ((screen->device->chipset & 0xf0) != 0x00)
+		dri_screen->max_gl_es1_version = 10;
+
+	dri_screen->driverPrivate = screen;
+	dri_screen->extensions = nouveau_screen_extensions;
+	screen->dri_screen = dri_screen;
+
 	configs = nouveau_get_configs();
 	if (!configs)
 		goto fail;
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_state.c b/src/mesa/drivers/dri/nouveau/nouveau_state.c
index 5155da9..3e7ed21 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_state.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_state.c
@@ -107,12 +107,6 @@ nouveau_depth_mask(struct gl_context *ctx, GLboolean flag)
 }
 
 static void
-nouveau_depth_range(struct gl_context *ctx, GLclampd nearval, GLclampd farval)
-{
-	context_dirty(ctx, VIEWPORT);
-}
-
-static void
 nouveau_read_buffer(struct gl_context *ctx, GLenum buffer)
 {
 	nouveau_validate_framebuffer(ctx);
@@ -343,12 +337,6 @@ nouveau_render_mode(struct gl_context *ctx, GLenum mode)
 }
 
 static void
-nouveau_scissor(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
-{
-	context_dirty(ctx, SCISSOR);
-}
-
-static void
 nouveau_shade_model(struct gl_context *ctx, GLenum mode)
 {
 	context_dirty(ctx, SHADE_MODEL);
@@ -429,12 +417,6 @@ nouveau_tex_parameter(struct gl_context *ctx, GLenum target,
 	}
 }
 
-static void
-nouveau_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
-{
-	context_dirty(ctx, VIEWPORT);
-}
-
 void
 nouveau_emit_nothing(struct gl_context *ctx, int emit)
 {
@@ -483,6 +465,12 @@ nouveau_update_state(struct gl_context *ctx, GLbitfield new_state)
 			context_dirty_i(ctx, TEX_MAT, i);
 	}
 
+	if (new_state & _NEW_SCISSOR)
+		context_dirty(ctx, SCISSOR);
+
+	if (new_state & _NEW_VIEWPORT)
+		context_dirty(ctx, VIEWPORT);
+
 	if (new_state & _NEW_CURRENT_ATTRIB &&
 	    new_state & _NEW_LIGHT) {
 		context_dirty(ctx, MATERIAL_FRONT_AMBIENT);
@@ -524,7 +512,6 @@ nouveau_state_init(struct gl_context *ctx)
 	ctx->Driver.FrontFace = nouveau_front_face;
 	ctx->Driver.DepthFunc = nouveau_depth_func;
 	ctx->Driver.DepthMask = nouveau_depth_mask;
-	ctx->Driver.DepthRange = nouveau_depth_range;
 	ctx->Driver.ReadBuffer = nouveau_read_buffer;
 	ctx->Driver.DrawBuffers = nouveau_draw_buffers;
 	ctx->Driver.Enable = nouveau_enable;
@@ -540,7 +527,6 @@ nouveau_state_init(struct gl_context *ctx)
 	ctx->Driver.PolygonOffset = nouveau_polygon_offset;
 	ctx->Driver.PolygonStipple = nouveau_polygon_stipple;
 	ctx->Driver.RenderMode = nouveau_render_mode;
-	ctx->Driver.Scissor = nouveau_scissor;
 	ctx->Driver.ShadeModel = nouveau_shade_model;
 	ctx->Driver.StencilFuncSeparate = nouveau_stencil_func_separate;
 	ctx->Driver.StencilMaskSeparate = nouveau_stencil_mask_separate;
@@ -548,7 +534,6 @@ nouveau_state_init(struct gl_context *ctx)
 	ctx->Driver.TexGen = nouveau_tex_gen;
 	ctx->Driver.TexEnv = nouveau_tex_env;
 	ctx->Driver.TexParameter = nouveau_tex_parameter;
-	ctx->Driver.Viewport = nouveau_viewport;
 
 	ctx->Driver.UpdateState = nouveau_update_state;
 
diff --git a/src/mesa/drivers/dri/r200/r200_context.c b/src/mesa/drivers/dri/r200/r200_context.c
index 8ed2c0c..d4e9ca8 100644
--- a/src/mesa/drivers/dri/r200/r200_context.c
+++ b/src/mesa/drivers/dri/r200/r200_context.c
@@ -201,6 +201,7 @@ GLboolean r200CreateContext( gl_api api,
 			     unsigned major_version,
 			     unsigned minor_version,
 			     uint32_t flags,
+                             bool notify_reset,
 			     unsigned *error,
 			     void *sharedContextPrivate)
 {
@@ -212,9 +213,15 @@ GLboolean r200CreateContext( gl_api api,
    int i;
    int tcl_mode;
 
-   /* Flag filtering is handled in dri2CreateContextAttribs.
-    */
-   (void) flags;
+   if (flags & ~__DRI_CTX_FLAG_DEBUG) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return false;
+   }
+
+   if (notify_reset) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      return false;
+   }
 
    assert(glVisual);
    assert(driContextPriv);
diff --git a/src/mesa/drivers/dri/r200/r200_context.h b/src/mesa/drivers/dri/r200/r200_context.h
index fb25dce..fed5d29 100644
--- a/src/mesa/drivers/dri/r200/r200_context.h
+++ b/src/mesa/drivers/dri/r200/r200_context.h
@@ -638,6 +638,7 @@ extern GLboolean r200CreateContext( gl_api api,
 				    unsigned major_version,
 				    unsigned minor_version,
 				    uint32_t flags,
+                                    bool notify_reset,
 				    unsigned *error,
 				    void *sharedContextPrivate);
 extern GLboolean r200MakeCurrent( __DRIcontext *driContextPriv,
diff --git a/src/mesa/drivers/dri/r200/r200_state.c b/src/mesa/drivers/dri/r200/r200_state.c
index d3e8114..ee7b945 100644
--- a/src/mesa/drivers/dri/r200/r200_state.c
+++ b/src/mesa/drivers/dri/r200/r200_state.c
@@ -1603,13 +1603,18 @@ void r200_vtbl_update_scissor( struct gl_context *ctx )
 static void r200Viewport( struct gl_context *ctx, GLint x, GLint y,
 			    GLsizei width, GLsizei height )
 {
+   (void) x;
+   (void) y;
+   (void) width;
+   (void) height;
+
    /* Don't pipeline viewport changes, conflict with window offset
     * setting below.  Could apply deltas to rescue pipelined viewport
     * values, or keep the originals hanging around.
     */
    r200UpdateWindow( ctx );
 
-   radeon_viewport(ctx, x, y, width, height);
+   radeon_viewport(ctx);
 }
 
 static void r200DepthRange( struct gl_context *ctx, GLclampd nearval,
diff --git a/src/mesa/drivers/dri/r200/r200_vertprog.c b/src/mesa/drivers/dri/r200/r200_vertprog.c
index 461b7cb..2397473 100644
--- a/src/mesa/drivers/dri/r200/r200_vertprog.c
+++ b/src/mesa/drivers/dri/r200/r200_vertprog.c
@@ -210,8 +210,6 @@ static unsigned long t_src_class(gl_register_file file)
    case PROGRAM_INPUT:
       return VSF_IN_CLASS_ATTR;
 
-   case PROGRAM_LOCAL_PARAM:
-   case PROGRAM_ENV_PARAM:
    case PROGRAM_CONSTANT:
    case PROGRAM_STATE_VAR:
       return VSF_IN_CLASS_PARAM;
diff --git a/src/mesa/drivers/dri/radeon/radeon_common.c b/src/mesa/drivers/dri/radeon/radeon_common.c
index 0f0945d..7be0ba7 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common.c
+++ b/src/mesa/drivers/dri/radeon/radeon_common.c
@@ -407,7 +407,7 @@ void radeon_window_moved(radeonContextPtr radeon)
 	radeonSetCliprects(radeon);
 }
 
-void radeon_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei width, GLsizei height)
+void radeon_viewport(struct gl_context *ctx)
 {
 	radeonContextPtr radeon = RADEON_CONTEXT(ctx);
 	__DRIcontext *driContext = radeon->dri.context;
diff --git a/src/mesa/drivers/dri/radeon/radeon_common.h b/src/mesa/drivers/dri/radeon/radeon_common.h
index 636822f..69a1727 100644
--- a/src/mesa/drivers/dri/radeon/radeon_common.h
+++ b/src/mesa/drivers/dri/radeon/radeon_common.h
@@ -23,7 +23,7 @@ void radeon_window_moved(radeonContextPtr radeon);
 void radeon_draw_buffer(struct gl_context *ctx, struct gl_framebuffer *fb);
 void radeonDrawBuffer( struct gl_context *ctx, GLenum mode );
 void radeonReadBuffer( struct gl_context *ctx, GLenum mode );
-void radeon_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei width, GLsizei height);
+void radeon_viewport(struct gl_context *ctx);
 void radeon_fbo_init(struct radeon_context *radeon);
 void
 radeon_renderbuffer_set_bo(struct radeon_renderbuffer *rb,
diff --git a/src/mesa/drivers/dri/radeon/radeon_context.c b/src/mesa/drivers/dri/radeon/radeon_context.c
index a9f29d7..76bfe55 100644
--- a/src/mesa/drivers/dri/radeon/radeon_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_context.c
@@ -168,6 +168,7 @@ r100CreateContext( gl_api api,
 		   unsigned major_version,
 		   unsigned minor_version,
 		   uint32_t flags,
+                   bool notify_reset,
 		   unsigned *error,
 		   void *sharedContextPrivate)
 {
@@ -179,9 +180,15 @@ r100CreateContext( gl_api api,
    int i;
    int tcl_mode, fthrottle_mode;
 
-   /* Flag filtering is handled in dri2CreateContextAttribs.
-    */
-   (void) flags;
+   if (flags & ~__DRI_CTX_FLAG_DEBUG) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_FLAG;
+      return false;
+   }
+
+   if (notify_reset) {
+      *error = __DRI_CTX_ERROR_UNKNOWN_ATTRIBUTE;
+      return false;
+   }
 
    assert(glVisual);
    assert(driContextPriv);
diff --git a/src/mesa/drivers/dri/radeon/radeon_context.h b/src/mesa/drivers/dri/radeon/radeon_context.h
index 6ad1d4d..847baef 100644
--- a/src/mesa/drivers/dri/radeon/radeon_context.h
+++ b/src/mesa/drivers/dri/radeon/radeon_context.h
@@ -458,6 +458,7 @@ extern GLboolean r100CreateContext( gl_api api,
 				    unsigned major_version,
 				    unsigned minor_version,
 				    uint32_t flags,
+                                    bool notify_reset,
 				    unsigned *error,
 				    void *sharedContextPrivate);
 
diff --git a/src/mesa/drivers/dri/radeon/radeon_state.c b/src/mesa/drivers/dri/radeon/radeon_state.c
index 70542f6..625271d 100644
--- a/src/mesa/drivers/dri/radeon/radeon_state.c
+++ b/src/mesa/drivers/dri/radeon/radeon_state.c
@@ -1386,13 +1386,18 @@ void radeonUpdateWindow( struct gl_context *ctx )
 static void radeonViewport( struct gl_context *ctx, GLint x, GLint y,
 			    GLsizei width, GLsizei height )
 {
+   (void) x;
+   (void) y;
+   (void) width;
+   (void) height;
+
    /* Don't pipeline viewport changes, conflict with window offset
     * setting below.  Could apply deltas to rescue pipelined viewport
     * values, or keep the originals hanging around.
     */
    radeonUpdateWindow( ctx );
 
-   radeon_viewport(ctx, x, y, width, height);
+   radeon_viewport(ctx);
 }
 
 static void radeonDepthRange( struct gl_context *ctx, GLclampd nearval,
diff --git a/src/mesa/drivers/dri/swrast/swrast.c b/src/mesa/drivers/dri/swrast/swrast.c
index bfa2efd..c062071 100644
--- a/src/mesa/drivers/dri/swrast/swrast.c
+++ b/src/mesa/drivers/dri/swrast/swrast.c
@@ -664,6 +664,7 @@ dri_create_context(gl_api api,
 		   unsigned major_version,
 		   unsigned minor_version,
 		   uint32_t flags,
+		   bool notify_reset,
 		   unsigned *error,
 		   void *sharedContextPrivate)
 {
diff --git a/src/mesa/drivers/haiku/swrast/SConscript b/src/mesa/drivers/haiku/swrast/SConscript
new file mode 100644
index 0000000..71ce88e
--- /dev/null
+++ b/src/mesa/drivers/haiku/swrast/SConscript
@@ -0,0 +1,28 @@
+Import('*')
+
+env = env.Clone()
+
+env.Append(CPPPATH = [
+    '#/src/mapi',
+    '#/src/mesa',
+    '#/src/mesa/main',
+    '/boot/system/develop/headers/private',
+    Dir('../../../mapi'), # src/mapi build path for python-generated GL API files/headers
+])
+
+env.Prepend(LIBS = [
+    glsl,
+    mesa,
+])
+
+sources = [
+	'SoftwareRast.cpp'
+]
+
+# Disallow undefined symbols
+#env.Append(SHLINKFLAGS = ['-Wl,-z,defs'])
+
+libswrast = env.SharedLibrary(
+    target = 'swrast',
+    source = sources
+)
diff --git a/src/mesa/drivers/haiku/swrast/SoftwareRast.cpp b/src/mesa/drivers/haiku/swrast/SoftwareRast.cpp
new file mode 100644
index 0000000..df697e4
--- /dev/null
+++ b/src/mesa/drivers/haiku/swrast/SoftwareRast.cpp
@@ -0,0 +1,697 @@
+/*
+ * Copyright 2006-2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jérôme Duval, korli@users.berlios.de
+ *		Philippe Houdoin, philippe.houdoin@free.fr
+ *		Artur Wyszynski, harakash@gmail.com
+ *		Alexander von Gluck, kallisti5@unixzen.com
+ */
+
+
+#include <kernel/image.h>
+#include "SoftwareRast.h"
+
+#include <Autolock.h>
+#include <interface/DirectWindowPrivate.h>
+#include <GraphicsDefs.h>
+#include <Screen.h>
+#include <stdio.h>
+#include <string.h>
+
+extern "C" {
+#include "extensions.h"
+#include "drivers/common/driverfuncs.h"
+#include "drivers/common/meta.h"
+#include "main/api_exec.h"
+#include "main/colormac.h"
+#include "main/cpuinfo.h"
+#include "main/buffers.h"
+#include "main/formats.h"
+#include "main/framebuffer.h"
+#include "main/renderbuffer.h"
+#include "main/version.h"
+#include "main/vtxfmt.h"
+#include "swrast/swrast.h"
+#include "swrast/s_renderbuffer.h"
+#include "swrast_setup/swrast_setup.h"
+#include "tnl/tnl.h"
+#include "tnl/t_context.h"
+#include "tnl/t_pipeline.h"
+#include "vbo/vbo.h"
+
+
+#ifdef DEBUG
+#	define TRACE(x...) printf("MesaSoftwareRast: " x)
+#	define CALLED() printf("MesaSoftwareRast: %s\n", __PRETTY_FUNCTION__)
+#else
+#	define TRACE(x...)
+#	define CALLED()
+#endif
+
+#define ERROR(x...) printf("MesaSoftwareRast: " x)
+}
+
+
+extern const char* color_space_name(color_space space);
+
+
+extern "C" _EXPORT BGLRenderer*
+instantiate_gl_renderer(BGLView* view, ulong options,
+	BGLDispatcher* dispatcher)
+{
+	return new MesaSoftwareRast(view, options, dispatcher);
+}
+
+
+MesaSoftwareRast::MesaSoftwareRast(BGLView* view, ulong options,
+	BGLDispatcher* dispatcher)
+	: BGLRenderer(view, options, dispatcher),
+	fBitmap(NULL),
+	fDirectModeEnabled(false),
+	fInfo(NULL),
+	fInfoLocker("info locker"),
+	fVisual(NULL),
+	fFrameBuffer(NULL),
+	fFrontRenderBuffer(NULL),
+	fBackRenderBuffer(NULL),
+	fColorSpace(B_NO_COLOR_SPACE)
+{
+	CALLED();
+
+	fColorSpace = BScreen(GLView()->Window()).ColorSpace();
+
+	// We force single buffering for the time being
+	options &= ~BGL_DOUBLE;
+
+	const GLboolean rgbFlag = ((options & BGL_INDEX) == 0);
+	const GLboolean alphaFlag = ((options & BGL_ALPHA) == BGL_ALPHA);
+	const GLboolean dblFlag = ((options & BGL_DOUBLE) == BGL_DOUBLE);
+	const GLboolean stereoFlag = false;
+	const GLint depth = (options & BGL_DEPTH) ? 16 : 0;
+	const GLint stencil = (options & BGL_STENCIL) ? 8 : 0;
+	const GLint accum = (options & BGL_ACCUM) ? 16 : 0;
+	const GLint red = rgbFlag ? 8 : 0;
+	const GLint green = rgbFlag ? 8 : 0;
+	const GLint blue = rgbFlag ? 8 : 0;
+	const GLint alpha = alphaFlag ? 8 : 0;
+
+	fOptions = options; // | BGL_INDIRECT;
+	struct dd_function_table functions;
+
+	fVisual = _mesa_create_visual(dblFlag, stereoFlag, red, green,
+		blue, alpha, depth, stencil, accum, accum, accum,
+		alpha ? accum : 0, 1);
+
+	// Initialize device driver function table
+	_mesa_init_driver_functions(&functions);
+
+	functions.GetString = _GetString;
+	functions.UpdateState = _UpdateState;
+	functions.MapRenderbuffer = _RenderBufferMap;
+	functions.Flush = _Flush;
+
+	// create core context
+	// We inherit gl_context to this class
+	_mesa_initialize_context(this, API_OPENGL_COMPAT, fVisual, NULL,
+		&functions);
+
+	/* Initialize the software rasterizer and helper modules. */
+	_swrast_CreateContext(this);
+	_vbo_CreateContext(this);
+	_tnl_CreateContext(this);
+	_swsetup_CreateContext(this);
+	_swsetup_Wakeup(this);
+
+	// Use default TCL pipeline
+	TNL_CONTEXT(this)->Driver.RunPipeline = _tnl_run_pipeline;
+
+	_mesa_meta_init(this);
+	_mesa_enable_sw_extensions(this);
+
+	_mesa_compute_version(this);
+
+	_mesa_initialize_dispatch_tables(this);
+	_mesa_initialize_vbo_vtxfmt(this);
+
+	// create core framebuffer
+	fFrameBuffer = _mesa_create_framebuffer(fVisual);
+	if (fFrameBuffer == NULL) {
+		ERROR("%s: Unable to calloc GL FrameBuffer!\n", __func__);
+		_mesa_destroy_visual(fVisual);
+		return;
+	}
+
+	// Setup front render buffer
+	fFrontRenderBuffer = _NewRenderBuffer(true);
+	if (fFrontRenderBuffer == NULL) {
+		ERROR("%s: FrontRenderBuffer is requested but unallocated!\n",
+			__func__);
+		_mesa_destroy_visual(fVisual);
+		free(fFrameBuffer);
+		return;
+	}
+	_mesa_add_renderbuffer(fFrameBuffer, BUFFER_FRONT_LEFT,
+		&fFrontRenderBuffer->Base);
+
+	// Setup back render buffer (if requested)
+	if (fVisual->doubleBufferMode) {
+		fBackRenderBuffer = _NewRenderBuffer(false);
+		if (fBackRenderBuffer == NULL) {
+			ERROR("%s: BackRenderBuffer is requested but unallocated!\n",
+				__func__);
+			_mesa_destroy_visual(fVisual);
+			free(fFrameBuffer);
+			return;
+		}
+		_mesa_add_renderbuffer(fFrameBuffer, BUFFER_BACK_LEFT,
+			&fBackRenderBuffer->Base);
+	}
+
+	_swrast_add_soft_renderbuffers(fFrameBuffer, GL_FALSE,
+		fVisual->haveDepthBuffer, fVisual->haveStencilBuffer,
+		fVisual->haveAccumBuffer, alphaFlag, GL_FALSE);
+
+	BRect bounds = view->Bounds();
+	fWidth = (GLint)bounds.Width();
+	fHeight = (GLint)bounds.Height();
+
+	// some stupid applications (Quake2) don't even think about calling LockGL()
+	// before using glGetString and its glGet*() friends...
+	// so make sure there is at least a valid context.
+
+	if (!_mesa_get_current_context()) {
+		LockGL();
+		// not needed, we don't have a looper yet: UnlockLooper();
+	}
+}
+
+
+MesaSoftwareRast::~MesaSoftwareRast()
+{
+	CALLED();
+	_swsetup_DestroyContext(this);
+	_swrast_DestroyContext(this);
+	_tnl_DestroyContext(this);
+	_vbo_DestroyContext(this);
+	_mesa_destroy_visual(fVisual);
+	_mesa_destroy_framebuffer(fFrameBuffer);
+	_mesa_destroy_context(this);
+
+	free(fInfo);
+	free(fFrameBuffer);
+
+	delete fBitmap;
+}
+
+
+void
+MesaSoftwareRast::LockGL()
+{
+	CALLED();
+	BGLRenderer::LockGL();
+
+	_mesa_make_current(this, fFrameBuffer, fFrameBuffer);
+
+	color_space colorSpace = BScreen(GLView()->Window()).ColorSpace();
+
+	GLuint width = fWidth;
+	GLuint height = fHeight;
+
+	BAutolock lock(fInfoLocker);
+	if (fDirectModeEnabled && fInfo != NULL) {
+		width = fInfo->window_bounds.right
+			- fInfo->window_bounds.left + 1;
+		height = fInfo->window_bounds.bottom
+			- fInfo->window_bounds.top + 1;
+	}
+
+	if (fColorSpace != colorSpace) {
+		fColorSpace = colorSpace;
+		_SetupRenderBuffer(&fFrontRenderBuffer->Base, fColorSpace);
+		if (fVisual->doubleBufferMode)
+			_SetupRenderBuffer(&fBackRenderBuffer->Base, fColorSpace);
+	}
+
+	_CheckResize(width, height);
+}
+
+
+void
+MesaSoftwareRast::UnlockGL()
+{
+	CALLED();
+	_mesa_make_current(this, NULL, NULL);
+	BGLRenderer::UnlockGL();
+}
+
+
+void
+MesaSoftwareRast::SwapBuffers(bool VSync)
+{
+	CALLED();
+
+	if (!fBitmap)
+		return;
+
+	if (fVisual->doubleBufferMode)
+		_mesa_notifySwapBuffers(this);
+
+	if (!fDirectModeEnabled || fInfo == NULL) {
+		if (GLView()->LockLooperWithTimeout(1000) == B_OK) {
+			GLView()->DrawBitmap(fBitmap, B_ORIGIN);
+			GLView()->UnlockLooper();
+		}
+	} else {
+		// TODO: Here the BGLView needs to be drawlocked.
+		_CopyToDirect();
+	}
+
+	if (VSync) {
+		BScreen screen(GLView()->Window());
+		screen.WaitForRetrace();
+	}
+}
+
+
+void
+MesaSoftwareRast::Draw(BRect updateRect)
+{
+	CALLED();
+	if (fBitmap && (!fDirectModeEnabled || (fInfo == NULL)))
+		GLView()->DrawBitmap(fBitmap, updateRect, updateRect);
+}
+
+
+status_t
+MesaSoftwareRast::CopyPixelsOut(BPoint location, BBitmap* bitmap)
+{
+	CALLED();
+	color_space scs = fBitmap->ColorSpace();
+	color_space dcs = bitmap->ColorSpace();
+
+	if (scs != dcs && (scs != B_RGBA32 || dcs != B_RGB32)) {
+		fprintf(stderr, "CopyPixelsOut(): incompatible color space: %s != %s\n",
+			color_space_name(scs),
+			color_space_name(dcs));
+		return B_BAD_TYPE;
+	}
+
+	BRect sr = fBitmap->Bounds();
+	BRect dr = bitmap->Bounds();
+
+	sr = sr & dr.OffsetBySelf(location);
+	dr = sr.OffsetByCopy(-location.x, -location.y);
+
+	uint8* ps = (uint8*)fBitmap->Bits();
+	uint8* pd = (uint8*)bitmap->Bits();
+	uint32* s;
+	uint32* d;
+	uint32 y;
+	for (y = (uint32)sr.top; y <= (uint32)sr.bottom; y++) {
+		s = (uint32*)(ps + y * fBitmap->BytesPerRow());
+		s += (uint32)sr.left;
+
+		d = (uint32*)(pd + (y + (uint32)(dr.top - sr.top))
+			* bitmap->BytesPerRow());
+		d += (uint32)dr.left;
+
+		memcpy(d, s, dr.IntegerWidth() * 4);
+	}
+	return B_OK;
+}
+
+
+status_t
+MesaSoftwareRast::CopyPixelsIn(BBitmap* bitmap, BPoint location)
+{
+	CALLED();
+	color_space scs = bitmap->ColorSpace();
+	color_space dcs = fBitmap->ColorSpace();
+
+	if (scs != dcs && (dcs != B_RGBA32 || scs != B_RGB32)) {
+		fprintf(stderr, "CopyPixelsIn(): incompatible color space: %s != %s\n",
+			color_space_name(scs),
+			color_space_name(dcs));
+		return B_BAD_TYPE;
+	}
+
+	BRect sr = bitmap->Bounds();
+	BRect dr = fBitmap->Bounds();
+
+	sr = sr & dr.OffsetBySelf(location);
+	dr = sr.OffsetByCopy(-location.x, -location.y);
+
+	uint8* ps = (uint8*)bitmap->Bits();
+	uint8* pd = (uint8*)fBitmap->Bits();
+	uint32* s;
+	uint32* d;
+	uint32 y;
+	for (y = (uint32)sr.top; y <= (uint32)sr.bottom; y++) {
+		s = (uint32*)(ps + y * bitmap->BytesPerRow());
+		s += (uint32)sr.left;
+
+		d = (uint32*)(pd + (y + (uint32)(dr.top - sr.top))
+			* fBitmap->BytesPerRow());
+		d += (uint32)dr.left;
+
+		memcpy(d, s, dr.IntegerWidth() * 4);
+	}
+	return B_OK;
+}
+
+
+void
+MesaSoftwareRast::EnableDirectMode(bool enabled)
+{
+	fDirectModeEnabled = enabled;
+}
+
+
+void
+MesaSoftwareRast::DirectConnected(direct_buffer_info* info)
+{
+	// TODO: I'm not sure we need to do this: BGLView already
+	// keeps a local copy of the direct_buffer_info passed by
+	// BDirectWindow::DirectConnected().
+	BAutolock lock(fInfoLocker);
+	if (info) {
+		if (!fInfo) {
+			fInfo = (direct_buffer_info*)malloc(DIRECT_BUFFER_INFO_AREA_SIZE);
+			if (!fInfo)
+				return;
+		}
+		memcpy(fInfo, info, DIRECT_BUFFER_INFO_AREA_SIZE);
+	} else if (fInfo) {
+		free(fInfo);
+		fInfo = NULL;
+	}
+}
+
+
+void
+MesaSoftwareRast::FrameResized(float width, float height)
+{
+	BAutolock lock(fInfoLocker);
+	_CheckResize((GLuint)width, (GLuint)height);
+}
+
+
+void
+MesaSoftwareRast::_CheckResize(GLuint newWidth, GLuint newHeight)
+{
+	CALLED();
+
+	if (fBitmap && newWidth == fWidth
+		&& newHeight == fHeight) {
+		return;
+	}
+
+	_mesa_resize_framebuffer(this, fFrameBuffer, newWidth, newHeight);
+	fHeight = newHeight;
+	fWidth = newWidth;
+
+	_AllocateBitmap();
+}
+
+
+void
+MesaSoftwareRast::_AllocateBitmap()
+{
+	CALLED();
+
+	// allocate new size of back buffer bitmap
+	delete fBitmap;
+	fBitmap = NULL;
+
+	if (fWidth < 1 || fHeight < 1) {
+		TRACE("%s: Cannot allocate bitmap < 1x1!\n", __func__);
+		return;
+	}
+
+	BRect rect(0.0, 0.0, fWidth - 1, fHeight - 1);
+	fBitmap = new BBitmap(rect, fColorSpace);
+
+	#if 0
+	// Used for platform optimized drawing
+	for (uint i = 0; i < fHeight; i++) {
+		fRowAddr[fHeight - i - 1] = (GLvoid *)((GLubyte *)fBitmap->Bits()
+			+ i * fBitmap->BytesPerRow());
+	}
+	#endif
+
+	fFrameBuffer->Width = fWidth;
+	fFrameBuffer->Height = fHeight;
+	TRACE("%s: Bitmap Size: %" B_PRIu32 "\n", __func__, fBitmap->BitsLength());
+
+	fFrontRenderBuffer->Buffer = (GLubyte*)fBitmap->Bits();
+}
+
+
+// #pragma mark - static
+
+
+const GLubyte*
+MesaSoftwareRast::_GetString(gl_context* ctx, GLenum name)
+{
+	switch (name) {
+		case GL_VENDOR:
+			return (const GLubyte*) "Mesa Project";
+		case GL_RENDERER:
+			return (const GLubyte*) "Software Rasterizer";
+		default:
+			// Let core library handle all other cases
+			return NULL;
+	}
+}
+
+
+void
+MesaSoftwareRast::_UpdateState(gl_context* ctx, GLuint new_state)
+{
+	if (!ctx)
+		return;
+
+	CALLED();
+	_swrast_InvalidateState(ctx, new_state);
+	_swsetup_InvalidateState(ctx, new_state);
+	_vbo_InvalidateState(ctx, new_state);
+	_tnl_InvalidateState(ctx, new_state);
+}
+
+
+GLboolean
+MesaSoftwareRast::_RenderBufferStorage(gl_context* ctx,
+	struct gl_renderbuffer* render, GLenum internalFormat,
+	GLuint width, GLuint height)
+{
+	CALLED();
+
+	render->Width = width;
+	render->Height = height;
+
+	struct swrast_renderbuffer *swRenderBuffer = swrast_renderbuffer(render);
+
+	swRenderBuffer->RowStride = width * _mesa_get_format_bytes(render->Format);
+
+	return GL_TRUE;
+}
+
+
+GLboolean
+MesaSoftwareRast::_RenderBufferStorageMalloc(gl_context* ctx,
+	struct gl_renderbuffer* render, GLenum internalFormat,
+	GLuint width, GLuint height)
+{
+	CALLED();
+
+	render->Width = width;
+	render->Height = height;
+
+	struct swrast_renderbuffer *swRenderBuffer = swrast_renderbuffer(render);
+
+	if (swRenderBuffer != NULL) {
+		free(swRenderBuffer->Buffer);
+		swRenderBuffer->RowStride
+			= width * _mesa_get_format_bytes(render->Format);
+
+		uint32 size = swRenderBuffer->RowStride * height;
+		TRACE("%s: Allocate %" B_PRIu32 " bytes for RenderBuffer\n",
+			__func__, size);
+		swRenderBuffer->Buffer = (GLubyte*)malloc(size);
+		if (!swRenderBuffer->Buffer) {
+			ERROR("%s: Memory allocation failure!\n", __func__);
+			return GL_FALSE;
+		}
+	} else {
+		ERROR("%s: Couldn't obtain software renderbuffer!\n",
+			__func__);
+		return GL_FALSE;
+	}
+
+	return GL_TRUE;
+}
+
+
+void
+MesaSoftwareRast::_Flush(gl_context* ctx)
+{
+	CALLED();
+	MesaSoftwareRast* driverContext = static_cast<MesaSoftwareRast*>(ctx);
+
+	//MesaSoftwareRast* driverContext = (MesaSoftwareRast*)ctx->DriverCtx;
+	if ((driverContext->fOptions & BGL_DOUBLE) == 0) {
+		// TODO: SwapBuffers() can call _CopyToDirect(), which should
+		// be always called with with the BGLView drawlocked.
+		// This is not always the case if called from here.
+		driverContext->SwapBuffers();
+	}
+}
+
+
+struct swrast_renderbuffer*
+MesaSoftwareRast::_NewRenderBuffer(bool front)
+{
+	CALLED();
+	struct swrast_renderbuffer *swRenderBuffer
+		= (struct swrast_renderbuffer*)calloc(1, sizeof *swRenderBuffer);
+
+	if (!swRenderBuffer) {
+		ERROR("%s: Failed calloc RenderBuffer\n", __func__);
+		return NULL;
+	}
+
+	_mesa_init_renderbuffer(&swRenderBuffer->Base, 0);
+
+	swRenderBuffer->Base.ClassID = HAIKU_SWRAST_RENDERBUFFER_CLASS;
+	swRenderBuffer->Base.RefCount = 1;
+	swRenderBuffer->Base.Delete = _RenderBufferDelete;
+
+	if (!front)
+		swRenderBuffer->Base.AllocStorage = _RenderBufferStorageMalloc;
+	else
+		swRenderBuffer->Base.AllocStorage = _RenderBufferStorage;
+
+	if (_SetupRenderBuffer(&swRenderBuffer->Base, fColorSpace) != B_OK) {
+		free(swRenderBuffer);
+		return NULL;
+	}
+
+	return swRenderBuffer;
+}
+
+
+status_t
+MesaSoftwareRast::_SetupRenderBuffer(struct gl_renderbuffer* rb,
+	color_space colorSpace)
+{
+	CALLED();
+
+	rb->InternalFormat = GL_RGBA;
+
+	switch (colorSpace) {
+		case B_RGBA32:
+			rb->_BaseFormat = GL_RGBA;
+			rb->Format = MESA_FORMAT_ARGB8888;
+			break;
+		case B_RGB32:
+			rb->_BaseFormat = GL_RGB;
+			rb->Format = MESA_FORMAT_XRGB8888;
+			break;
+		case B_RGB24:
+			rb->_BaseFormat = GL_RGB;
+			rb->Format = MESA_FORMAT_RGB888;
+			break;
+		case B_RGB16:
+			rb->_BaseFormat = GL_RGB;
+			rb->Format = MESA_FORMAT_RGB565;
+			break;
+		case B_RGB15:
+			rb->_BaseFormat = GL_RGB;
+			rb->Format = MESA_FORMAT_ARGB1555;
+			break;
+		default:
+			fprintf(stderr, "Unsupported screen color space %s\n",
+				color_space_name(fColorSpace));
+			debugger("Unsupported OpenGL color space");
+			return B_ERROR;
+	}
+	return B_OK;
+}
+
+
+/*!	Y inverted Map RenderBuffer function
+	We use a BBitmap for storage which has Y inverted.
+	If the Mesa provided Map function ever allows external
+	control of this we can omit this function.
+*/
+void
+MesaSoftwareRast::_RenderBufferMap(gl_context *ctx,
+	struct gl_renderbuffer *rb, GLuint x, GLuint y, GLuint w, GLuint h,
+	GLbitfield mode, GLubyte **mapOut, GLint *rowStrideOut)
+{
+	if (rb->ClassID == HAIKU_SWRAST_RENDERBUFFER_CLASS) {
+		struct swrast_renderbuffer *srb = swrast_renderbuffer(rb);
+		const GLuint bpp = _mesa_get_format_bytes(rb->Format);
+		GLint rowStride = rb->Width * bpp; // in Bytes
+
+		y = rb->Height - y - 1;
+
+		*rowStrideOut = -rowStride;
+		*mapOut = (GLubyte *) srb->Buffer + y * rowStride + x * bpp;
+	} else {
+		_swrast_map_soft_renderbuffer(ctx, rb, x, y, w, h, mode,
+			mapOut, rowStrideOut);
+	}
+}
+
+
+void
+MesaSoftwareRast::_RenderBufferDelete(struct gl_context *ctx,
+	struct gl_renderbuffer* rb)
+{
+	CALLED();
+	if (rb != NULL) {
+		struct swrast_renderbuffer *swRenderBuffer
+			= swrast_renderbuffer(rb);
+		if (swRenderBuffer != NULL)
+			free(swRenderBuffer->Buffer);
+	}
+	free(rb);
+}
+
+
+void
+MesaSoftwareRast::_CopyToDirect()
+{
+	BAutolock lock(fInfoLocker);
+
+	// check the bitmap size still matches the size
+	if (fInfo->window_bounds.bottom - fInfo->window_bounds.top
+		!= fBitmap->Bounds().IntegerHeight()
+		|| fInfo->window_bounds.right - fInfo->window_bounds.left
+			!= fBitmap->Bounds().IntegerWidth())
+		return;
+
+	uint8 bytesPerPixel = fInfo->bits_per_pixel / 8;
+	uint32 bytesPerRow = fBitmap->BytesPerRow();
+	for (uint32 i = 0; i < fInfo->clip_list_count; i++) {
+		clipping_rect *clip = &fInfo->clip_list[i];
+		int32 height = clip->bottom - clip->top + 1;
+		int32 bytesWidth
+			= (clip->right - clip->left + 1) * bytesPerPixel;
+		uint8* p = (uint8*)fInfo->bits + clip->top
+			* fInfo->bytes_per_row + clip->left * bytesPerPixel;
+		uint8* b = (uint8*)fBitmap->Bits()
+			+ (clip->top - fInfo->window_bounds.top) * bytesPerRow
+			+ (clip->left - fInfo->window_bounds.left)
+				* bytesPerPixel;
+
+		for (int y = 0; y < height; y++) {
+			memcpy(p, b, bytesWidth);
+			p += fInfo->bytes_per_row;
+			b += bytesPerRow;
+		}
+	}
+}
diff --git a/src/mesa/drivers/haiku/swrast/SoftwareRast.h b/src/mesa/drivers/haiku/swrast/SoftwareRast.h
new file mode 100644
index 0000000..8f0f018
--- /dev/null
+++ b/src/mesa/drivers/haiku/swrast/SoftwareRast.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2006-2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jérôme Duval, korli@users.berlios.de
+ * 		Philippe Houdoin, philippe.houdoin@free.fr
+ *		Artur Wyszynski, harakash@gmail.com
+ */
+#ifndef MESASOFTWARERENDERER_H
+#define MESASOFTWARERENDERER_H
+
+
+#define HAIKU_SWRAST_RENDERBUFFER_CLASS 0x737752 // swR
+
+
+#include "GLRenderer.h"
+
+extern "C" {
+#include "context.h"
+#include "main/version.h"
+#include "swrast/s_chan.h"
+#include "swrast/s_context.h"
+}
+
+
+class MesaSoftwareRast : public BGLRenderer, public gl_context {
+public:
+							MesaSoftwareRast(BGLView* view,
+								ulong bgl_options,
+								BGLDispatcher* dispatcher);
+	virtual					~MesaSoftwareRast();
+
+	virtual	void			LockGL();
+	virtual	void 			UnlockGL();
+
+	virtual	void 			SwapBuffers(bool VSync = false);
+	virtual	void			Draw(BRect updateRect);
+	virtual	status_t		CopyPixelsOut(BPoint source, BBitmap* dest);
+	virtual	status_t		CopyPixelsIn(BBitmap* source, BPoint dest);
+	virtual void			FrameResized(float width, float height);
+
+	virtual	void			EnableDirectMode(bool enabled);
+	virtual	void			DirectConnected(direct_buffer_info* info);
+
+private:
+	static	const GLubyte*	_GetString(gl_context* ctx, GLenum name);
+			void			_CheckResize(GLuint newWidth, GLuint newHeight);
+	static	void			_UpdateState(gl_context* ctx, GLuint newState);
+	static	void			_Flush(gl_context *ctx);
+
+	struct	swrast_renderbuffer* _NewRenderBuffer(bool front);
+			status_t		_SetupRenderBuffer(struct gl_renderbuffer* rb,
+								color_space colorSpace);
+
+/* Mesa callbacks */
+	static	void			_RenderBufferDelete(struct gl_context *ctx,
+								struct gl_renderbuffer* rb);
+	static	GLboolean		_RenderBufferStorage(gl_context* ctx,
+								struct gl_renderbuffer* render,
+								GLenum internalFormat,
+								GLuint width, GLuint height);
+	static	GLboolean		_RenderBufferStorageMalloc(gl_context* ctx,
+								struct gl_renderbuffer* render,
+								GLenum internalFormat,
+								GLuint width, GLuint height);
+	static	void			_RenderBufferMap(gl_context *ctx,
+								struct gl_renderbuffer *rb,
+								GLuint x, GLuint y, GLuint w, GLuint h,
+								GLbitfield mode, GLubyte **mapOut,
+								GLint *rowStrideOut);
+
+			void			_AllocateBitmap();
+			void			_CopyToDirect();
+
+			BBitmap*		fBitmap;
+			bool			fDirectModeEnabled;
+			direct_buffer_info* fInfo;
+			BLocker			fInfoLocker;
+			ulong			fOptions;
+
+			gl_config*		fVisual;
+
+			struct gl_framebuffer* fFrameBuffer;
+			struct swrast_renderbuffer* fFrontRenderBuffer;
+			struct swrast_renderbuffer* fBackRenderBuffer;
+
+			GLuint			fWidth;
+			GLuint			fHeight;
+			color_space		fColorSpace;
+
+			void*			fRowAddr[SWRAST_MAX_HEIGHT];
+};
+
+#endif	// MESASOFTWARERENDERER_H
diff --git a/src/mesa/drivers/haiku/swrast/SoftwareRast.rdef b/src/mesa/drivers/haiku/swrast/SoftwareRast.rdef
new file mode 100644
index 0000000..cb60332
--- /dev/null
+++ b/src/mesa/drivers/haiku/swrast/SoftwareRast.rdef
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+resource app_signature "application/x-vnd.Haiku-swrast";
+
+resource app_version {
+    major  = 9,
+    middle = 0,
+    minor  = 0,
+    variety = 0,
+    internal = 0,
+    short_info = "Software Rasterizer",
+    long_info = "Haiku Mesa Software GL Rasterizer"
+};
+
+resource vector_icon {
+	$"6E6369660A0200140294A9FF18020014028DFFFF97058C0500020006023B10B7"
+	$"37F036BA1A993D466848C719BEBE2000919292FFD5D5D5020016023900000000"
+	$"000000003EE0004AE00048E0005EF884C702000203392E8D383001BAD97F3C12"
+	$"8B4786BD48B8AD0D97BBFFFF7B4168DBE9FF4168DB97020002023A0C1238D099"
+	$"BE44203F4BD14B38844678240DF56A7D9FE1EA064CC704016B0500090A044024"
+	$"2438404C5C380A044028243C40505C3C0A042438243B5C3C5C380608BFBE4D59"
+	$"4D59515957575659585560406044603C5E3A5C3CCB4FBFBA5E3ECA9DC11F564B"
+	$"584A544C504C0606AF0F2F3D2F3D393D4034BF593542324130432F42364432C0"
+	$"3FBC5A2F48354A2F480608AE9A22303EB5BD3AB42542B755422E412F3C29322D"
+	$"32223C0204263726372538263F253E263F304430443143303C313D303C02043D"
+	$"423D423C433D4A3C493D4A495049504A4F49474A484947060DAEAAAE014E445A"
+	$"3456365E325E3D5D3F5A3A5542544E4D573A4E364439463342324A2242310A0A"
+	$"0002020102403CA00C88888C8CC1401673C40D6544F2950A01010002403CA000"
+	$"0000000000401673C40D65446CF80A08020304023EC16A0000000000003EC16A"
+	$"45DD1844C6550A030105123EC16A0000000000003EC16A45DD1844C655011784"
+	$"22040A040105023EC16A0000000000003EC16A45DD1844C6550A030108123EC1"
+	$"6A0000000000003EC16A45DD1844C65501178422040A0503080706023EC16A00"
+	$"00000000003EC16A45DD1844C6550A030206071A3EC16A0000000000003EC16A"
+	$"45DD1844C65510FF0215810004178222040A060106023EC16A0000000000003E"
+	$"C16A45DD1844C6550A070107023EC16A0000000000003EC16A45DD1844C655"
+};
diff --git a/src/mesa/drivers/osmesa/osmesa.c b/src/mesa/drivers/osmesa/osmesa.c
index 102001e..97cd41c 100644
--- a/src/mesa/drivers/osmesa/osmesa.c
+++ b/src/mesa/drivers/osmesa/osmesa.c
@@ -197,26 +197,39 @@ osmesa_choose_line_function( struct gl_context *ctx )
    const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
    const SWcontext *swrast = SWRAST_CONTEXT(ctx);
 
-   if (ctx->RenderMode != GL_RENDER)      return NULL;
-   if (ctx->Line.SmoothFlag)              return NULL;
-   if (ctx->Texture._EnabledUnits)        return NULL;
-   if (ctx->Light.ShadeModel != GL_FLAT)  return NULL;
-   if (ctx->Line.Width != 1.0F)           return NULL;
-   if (ctx->Line.StippleFlag)             return NULL;
-   if (ctx->Line.SmoothFlag)              return NULL;
+   if (ctx->DrawBuffer &&
+       ctx->DrawBuffer->Visual.redBits == 32) {
+      /* the special-case line functions in this file don't work
+       * for float color channels.
+       */
+      return NULL;
+   }
+
+   if (ctx->RenderMode != GL_RENDER ||
+       ctx->Line.SmoothFlag ||
+       ctx->Texture._EnabledUnits ||
+       ctx->Light.ShadeModel != GL_FLAT ||
+       ctx->Line.Width != 1.0F ||
+       ctx->Line.StippleFlag ||
+       ctx->Line.SmoothFlag) {
+      return NULL;
+   }
+
    if (osmesa->format != OSMESA_RGBA &&
        osmesa->format != OSMESA_BGRA &&
-       osmesa->format != OSMESA_ARGB)     return NULL;
+       osmesa->format != OSMESA_ARGB) {
+      return NULL;
+   }
 
-   if (swrast->_RasterMask==DEPTH_BIT
-       && ctx->Depth.Func==GL_LESS
-       && ctx->Depth.Mask==GL_TRUE
+   if (swrast->_RasterMask == DEPTH_BIT
+       && ctx->Depth.Func == GL_LESS
+       && ctx->Depth.Mask == GL_TRUE
        && ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS) {
-      return (swrast_line_func) flat_rgba_z_line;
+      return flat_rgba_z_line;
    }
 
    if (swrast->_RasterMask == 0) {
-      return (swrast_line_func) flat_rgba_line;
+      return flat_rgba_line;
    }
 
    return (swrast_line_func) NULL;
@@ -298,29 +311,45 @@ osmesa_choose_triangle_function( struct gl_context *ctx )
    const OSMesaContext osmesa = OSMESA_CONTEXT(ctx);
    const SWcontext *swrast = SWRAST_CONTEXT(ctx);
 
-   if (ctx->RenderMode != GL_RENDER)    return (swrast_tri_func) NULL;
-   if (ctx->Polygon.SmoothFlag)         return (swrast_tri_func) NULL;
-   if (ctx->Polygon.StippleFlag)        return (swrast_tri_func) NULL;
-   if (ctx->Texture._EnabledUnits)      return (swrast_tri_func) NULL;
+   if (ctx->DrawBuffer &&
+       ctx->DrawBuffer->Visual.redBits == 32) {
+      /* the special-case triangle functions in this file don't work
+       * for float color channels.
+       */
+      return NULL;
+   }
+
+   if (ctx->RenderMode != GL_RENDER ||
+       ctx->Polygon.SmoothFlag ||
+       ctx->Polygon.StippleFlag ||
+       ctx->Texture._EnabledUnits) {
+      return NULL;
+   }
+
    if (osmesa->format != OSMESA_RGBA &&
        osmesa->format != OSMESA_BGRA &&
-       osmesa->format != OSMESA_ARGB)   return (swrast_tri_func) NULL;
-   if (ctx->Polygon.CullFlag && 
-       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK)
-                                        return (swrast_tri_func) NULL;
+       osmesa->format != OSMESA_ARGB) {
+      return NULL;
+   }
+
+   if (ctx->Polygon.CullFlag &&
+       ctx->Polygon.CullFaceMode == GL_FRONT_AND_BACK) {
+      return NULL;
+   }
 
    if (swrast->_RasterMask == DEPTH_BIT &&
        ctx->Depth.Func == GL_LESS &&
        ctx->Depth.Mask == GL_TRUE &&
        ctx->Visual.depthBits == DEFAULT_SOFTWARE_DEPTH_BITS) {
       if (ctx->Light.ShadeModel == GL_SMOOTH) {
-         return (swrast_tri_func) smooth_rgba_z_triangle;
+         return smooth_rgba_z_triangle;
       }
       else {
-         return (swrast_tri_func) flat_rgba_z_triangle;
+         return flat_rgba_z_triangle;
       }
    }
-   return (swrast_tri_func) NULL;
+
+   return NULL;
 }
 
 
diff --git a/src/mesa/main/api_arrayelt.c b/src/mesa/main/api_arrayelt.c
index ea09238..c9d4d03 100644
--- a/src/mesa/main/api_arrayelt.c
+++ b/src/mesa/main/api_arrayelt.c
@@ -35,6 +35,7 @@
  */
 
 #include "glheader.h"
+#include "arrayobj.h"
 #include "api_arrayelt.h"
 #include "bufferobj.h"
 #include "context.h"
@@ -1468,6 +1469,18 @@ check_vbo(AEcontext *actx, struct gl_buffer_object *vbo)
 }
 
 
+static inline void
+update_derived_client_arrays(struct gl_context *ctx)
+{
+   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+
+   if (arrayObj->NewArrays) {
+      _mesa_update_array_object_client_arrays(ctx, arrayObj);
+      arrayObj->NewArrays = 0;
+   }
+}
+
+
 /**
  * Make a list of per-vertex functions to call for each glArrayElement call.
  * These functions access the array data (i.e. glVertex, glColor, glNormal,
@@ -1486,45 +1499,45 @@ _ae_update_state(struct gl_context *ctx)
    actx->nr_vbos = 0;
 
    /* conventional vertex arrays */
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR_INDEX];
       aa->offset = IndexFuncs[TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_EDGEFLAG];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_EDGEFLAG].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_EDGEFLAG];
       aa->offset = _gloffset_EdgeFlagv;
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_NORMAL];
       aa->offset = NormalFuncs[TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR0];
       aa->offset = ColorFuncs[aa->array->Size-3][TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR1];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR1].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR1];
       aa->offset = SecondaryColorFuncs[TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_FOG];
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_FOG].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_FOG];
       aa->offset = FogCoordFuncs[TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
    for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++) {
       struct gl_client_array *attribArray =
-         &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)];
+         &arrayObj->_VertexAttrib[VERT_ATTRIB_TEX(i)];
       if (attribArray->Enabled) {
          /* NOTE: we use generic glVertexAttribNV functions here.
           * If we ever remove GL_NV_vertex_program this will have to change.
@@ -1543,7 +1556,7 @@ _ae_update_state(struct gl_context *ctx)
    /* generic vertex attribute arrays */
    for (i = 1; i < VERT_ATTRIB_GENERIC_MAX; i++) {  /* skip zero! */
       struct gl_client_array *attribArray =
-         &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)];
+         &arrayObj->_VertexAttrib[VERT_ATTRIB_GENERIC(i)];
       if (attribArray->Enabled) {
          GLint intOrNorm;
          at->array = attribArray;
@@ -1570,18 +1583,18 @@ _ae_update_state(struct gl_context *ctx)
    }
 
    /* finally, vertex position */
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_GENERIC0].Enabled) {
       /* Use glVertex(v) instead of glVertexAttrib(0, v) to be sure it's
        * issued as the last (provoking) attribute).
        */
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC0];
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_GENERIC0];
       assert(aa->array->Size >= 2); /* XXX fix someday? */
       aa->offset = VertexFuncs[aa->array->Size-2][TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
    }
-   else if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled) {
-      aa->array = &arrayObj->VertexAttrib[VERT_ATTRIB_POS];
+   else if (arrayObj->_VertexAttrib[VERT_ATTRIB_POS].Enabled) {
+      aa->array = &arrayObj->_VertexAttrib[VERT_ATTRIB_POS];
       aa->offset = VertexFuncs[aa->array->Size-2][TYPE_IDX(aa->array->Type)];
       check_vbo(actx, aa->array->BufferObj);
       aa++;
@@ -1611,6 +1624,8 @@ _ae_map_vbos(struct gl_context *ctx)
    if (actx->mapped_vbos)
       return;
 
+   update_derived_client_arrays(ctx);
+
    if (actx->NewState)
       _ae_update_state(ctx);
 
@@ -1662,6 +1677,8 @@ _ae_ArrayElement(GLint elt)
    const struct _glapi_table * const disp = GET_DISPATCH();
    GLboolean do_map;
 
+   update_derived_client_arrays(ctx);
+
    /* If PrimitiveRestart is enabled and the index is the RestartIndex
     * then we call PrimitiveRestartNV and return.
     */
diff --git a/src/mesa/main/arbprogram.c b/src/mesa/main/arbprogram.c
index 51a2993..8bd3f0b 100644
--- a/src/mesa/main/arbprogram.c
+++ b/src/mesa/main/arbprogram.c
@@ -265,6 +265,12 @@ get_local_param_pointer(struct gl_context *ctx, const char *func,
       return GL_FALSE;
    }
 
+   if (!prog->LocalParams) {
+      prog->LocalParams = calloc(maxParams, sizeof(float[4]));
+      if (!prog->LocalParams)
+         return GL_FALSE;
+   }
+
    *param = prog->LocalParams[index];
    return GL_TRUE;
 }
diff --git a/src/mesa/main/arrayobj.c b/src/mesa/main/arrayobj.c
index 5d50d29..fdcf172 100644
--- a/src/mesa/main/arrayobj.c
+++ b/src/mesa/main/arrayobj.c
@@ -53,7 +53,7 @@
 
 /**
  * Look up the array object for the given ID.
- * 
+ *
  * \returns
  * Either a pointer to the array object with the specified ID or \c NULL for
  * a non-existent ID.  The spec defines ID 0 as being technically
@@ -72,7 +72,7 @@ _mesa_lookup_arrayobj(struct gl_context *ctx, GLuint id)
 
 
 /**
- * For all the vertex arrays in the array object, unbind any pointers
+ * For all the vertex binding points in the array object, unbind any pointers
  * to any buffer objects (VBOs).
  * This is done just prior to array object destruction.
  */
@@ -81,14 +81,17 @@ unbind_array_object_vbos(struct gl_context *ctx, struct gl_array_object *obj)
 {
    GLuint i;
 
-   for (i = 0; i < Elements(obj->VertexAttrib); i++)
-      _mesa_reference_buffer_object(ctx, &obj->VertexAttrib[i].BufferObj, NULL);
+   for (i = 0; i < Elements(obj->VertexBinding); i++)
+      _mesa_reference_buffer_object(ctx, &obj->VertexBinding[i].BufferObj, NULL);
+
+   for (i = 0; i < Elements(obj->_VertexAttrib); i++)
+      _mesa_reference_buffer_object(ctx, &obj->_VertexAttrib[i].BufferObj, NULL);
 }
 
 
 /**
  * Allocate and initialize a new vertex array object.
- * 
+ *
  * This function is intended to be called via
  * \c dd_function_table::NewArrayObject.
  */
@@ -104,7 +107,7 @@ _mesa_new_array_object( struct gl_context *ctx, GLuint name )
 
 /**
  * Delete an array object.
- * 
+ *
  * This function is intended to be called via
  * \c dd_function_table::DeleteArrayObject.
  */
@@ -181,20 +184,30 @@ _mesa_reference_array_object_(struct gl_context *ctx,
 
 static void
 init_array(struct gl_context *ctx,
-           struct gl_client_array *array, GLint size, GLint type)
+           struct gl_array_object *obj, GLuint index, GLint size, GLint type)
 {
+   struct gl_vertex_attrib_array *array = &obj->VertexAttrib[index];
+   struct gl_vertex_buffer_binding *binding = &obj->VertexBinding[index];
+
    array->Size = size;
    array->Type = type;
    array->Format = GL_RGBA; /* only significant for GL_EXT_vertex_array_bgra */
    array->Stride = 0;
-   array->StrideB = 0;
    array->Ptr = NULL;
+   array->RelativeOffset = 0;
    array->Enabled = GL_FALSE;
    array->Normalized = GL_FALSE;
    array->Integer = GL_FALSE;
    array->_ElementSize = size * _mesa_sizeof_type(type);
+   array->VertexBinding = index;
+
+   binding->Offset = 0;
+   binding->Stride = array->_ElementSize;
+   binding->BufferObj = NULL;
+   binding->_BoundArrays = BITFIELD64_BIT(index);
+
    /* Vertex array buffers */
-   _mesa_reference_buffer_object(ctx, &array->BufferObj,
+   _mesa_reference_buffer_object(ctx, &binding->BufferObj,
                                  ctx->Shared->NullBufferObj);
 }
 
@@ -215,31 +228,31 @@ _mesa_initialize_array_object( struct gl_context *ctx,
    obj->RefCount = 1;
 
    /* Init the individual arrays */
-   for (i = 0; i < Elements(obj->VertexAttrib); i++) {
+   for (i = 0; i < Elements(obj->_VertexAttrib); i++) {
       switch (i) {
       case VERT_ATTRIB_WEIGHT:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_WEIGHT], 1, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_WEIGHT, 1, GL_FLOAT);
          break;
       case VERT_ATTRIB_NORMAL:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_NORMAL], 3, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_NORMAL, 3, GL_FLOAT);
          break;
       case VERT_ATTRIB_COLOR1:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR1], 3, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_COLOR1, 3, GL_FLOAT);
          break;
       case VERT_ATTRIB_FOG:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_FOG], 1, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_FOG, 1, GL_FLOAT);
          break;
       case VERT_ATTRIB_COLOR_INDEX:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_COLOR_INDEX], 1, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_COLOR_INDEX, 1, GL_FLOAT);
          break;
       case VERT_ATTRIB_EDGEFLAG:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_EDGEFLAG], 1, GL_BOOL);
+         init_array(ctx, obj, VERT_ATTRIB_EDGEFLAG, 1, GL_BOOL);
          break;
       case VERT_ATTRIB_POINT_SIZE:
-         init_array(ctx, &obj->VertexAttrib[VERT_ATTRIB_POINT_SIZE], 1, GL_FLOAT);
+         init_array(ctx, obj, VERT_ATTRIB_POINT_SIZE, 1, GL_FLOAT);
          break;
       default:
-         init_array(ctx, &obj->VertexAttrib[i], 4, GL_FLOAT);
+         init_array(ctx, obj, i, 4, GL_FLOAT);
          break;
       }
    }
@@ -279,24 +292,24 @@ remove_array_object( struct gl_context *ctx, struct gl_array_object *obj )
 
 /**
  * Helper for _mesa_update_array_object_max_element().
- * \return  min(arrayObj->VertexAttrib[*]._MaxElement).
+ * \return  min(arrayObj->_VertexAttrib[*]._MaxElement).
  */
 static GLuint
 compute_max_element(struct gl_array_object *arrayObj, GLbitfield64 enabled)
 {
    GLuint min = ~((GLuint)0);
-   
+
    while (enabled) {
       struct gl_client_array *client_array;
       GLint attrib = ffsll(enabled) - 1;
       enabled ^= BITFIELD64_BIT(attrib);
-      
-      client_array = &arrayObj->VertexAttrib[attrib];
+
+      client_array = &arrayObj->_VertexAttrib[attrib];
       assert(client_array->Enabled);
       _mesa_update_array_max_element(client_array);
       min = MIN2(min, client_array->_MaxElement);
    }
-   
+
    return min;
 }
 
@@ -322,6 +335,34 @@ _mesa_update_array_object_max_element(struct gl_context *ctx,
 }
 
 
+/**
+ * Updates the derived gl_client_arrays when a gl_vertex_attrib_array
+ * or a gl_vertex_buffer_binding has changed.
+ */
+void
+_mesa_update_array_object_client_arrays(struct gl_context *ctx,
+                                        struct gl_array_object *arrayObj)
+{
+   GLbitfield64 arrays = arrayObj->NewArrays;
+
+   while (arrays) {
+      struct gl_client_array *client_array;
+      struct gl_vertex_attrib_array *attrib_array;
+      struct gl_vertex_buffer_binding *buffer_binding;
+
+      GLint attrib = ffsll(arrays) - 1;
+      arrays ^= BITFIELD64_BIT(attrib);
+
+      attrib_array = &arrayObj->VertexAttrib[attrib];
+      buffer_binding = &arrayObj->VertexBinding[attrib_array->VertexBinding];
+      client_array = &arrayObj->_VertexAttrib[attrib];
+
+      _mesa_update_client_array(ctx, client_array, attrib_array,
+                                buffer_binding);
+   }
+}
+
+
 /**********************************************************************/
 /* API Functions                                                      */
 /**********************************************************************/
@@ -357,7 +398,8 @@ bind_vertex_array(struct gl_context *ctx, GLuint id, GLboolean genRequired)
       newObj = _mesa_lookup_arrayobj(ctx, id);
       if (!newObj) {
          if (genRequired) {
-            _mesa_error(ctx, GL_INVALID_OPERATION, "glBindVertexArray(non-gen name)");
+            _mesa_error(ctx, GL_INVALID_OPERATION,
+                        "glBindVertexArray(non-gen name)");
             return;
          }
 
@@ -424,7 +466,7 @@ _mesa_BindVertexArrayAPPLE( GLuint id )
 
 /**
  * Delete a set of array objects.
- * 
+ *
  * \param n      Number of array objects to delete.
  * \param ids    Array of \c n array object IDs.
  */
@@ -472,7 +514,7 @@ _mesa_DeleteVertexArrays(GLsizei n, const GLuint *ids)
  * \param arrays  Array of \c n locations to store the IDs.
  * \param vboOnly Will arrays have to reside in VBOs?
  */
-static void 
+static void
 gen_vertex_arrays(struct gl_context *ctx, GLsizei n, GLuint *arrays)
 {
    GLuint first;
@@ -531,9 +573,9 @@ _mesa_GenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
 
 /**
  * Determine if ID is the name of an array object.
- * 
+ *
  * \param id  ID of the potential array object.
- * \return  \c GL_TRUE if \c id is the name of a array object, 
+ * \return  \c GL_TRUE if \c id is the name of a array object,
  *          \c GL_FALSE otherwise.
  */
 GLboolean GLAPIENTRY
diff --git a/src/mesa/main/arrayobj.h b/src/mesa/main/arrayobj.h
index 492ef35..7c37202 100644
--- a/src/mesa/main/arrayobj.h
+++ b/src/mesa/main/arrayobj.h
@@ -78,6 +78,11 @@ extern void
 _mesa_update_array_object_max_element(struct gl_context *ctx,
                                       struct gl_array_object *arrayObj);
 
+extern void
+_mesa_update_array_object_client_arrays(struct gl_context *ctx,
+                                        struct gl_array_object *arrayObj);
+
+
 /** Returns the bitmask of all enabled arrays in fixed function mode.
  *
  *  In fixed function mode only the traditional fixed function arrays
diff --git a/src/mesa/main/attrib.c b/src/mesa/main/attrib.c
index ca617f7..c9332bd 100644
--- a/src/mesa/main/attrib.c
+++ b/src/mesa/main/attrib.c
@@ -1369,8 +1369,11 @@ copy_array_object(struct gl_context *ctx,
    /* In theory must be the same anyway, but on recreate make sure it matches */
    dest->ARBsemantics = src->ARBsemantics;
 
-   for (i = 0; i < Elements(src->VertexAttrib); i++)
-      _mesa_copy_client_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);
+   for (i = 0; i < Elements(src->_VertexAttrib); i++) {
+      _mesa_copy_client_array(ctx, &dest->_VertexAttrib[i], &src->_VertexAttrib[i]);
+      _mesa_copy_vertex_attrib_array(ctx, &dest->VertexAttrib[i], &src->VertexAttrib[i]);
+      _mesa_copy_vertex_buffer_binding(ctx, &dest->VertexBinding[i], &src->VertexBinding[i]);
+   }
 
    /* _Enabled must be the same than on push */
    dest->_Enabled = src->_Enabled;
diff --git a/src/mesa/main/bufferobj.c b/src/mesa/main/bufferobj.c
index 1f55061..b27f592 100644
--- a/src/mesa/main/bufferobj.c
+++ b/src/mesa/main/bufferobj.c
@@ -655,16 +655,17 @@ _mesa_free_buffer_objects( struct gl_context *ctx )
    }
 }
 
-static bool
-handle_bind_buffer_gen(struct gl_context *ctx,
-		       GLenum target,
-		       GLuint buffer,
-		       struct gl_buffer_object **buf_handle)
+bool
+_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
+                             GLenum target,
+                             GLuint buffer,
+                             struct gl_buffer_object **buf_handle,
+                             const char *caller)
 {
    struct gl_buffer_object *buf = *buf_handle;
 
    if (!buf && ctx->API == API_OPENGL_CORE) {
-      _mesa_error(ctx, GL_INVALID_OPERATION, "glBindBuffer(non-gen name)");
+      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", caller);
       return false;
    }
 
@@ -675,7 +676,7 @@ handle_bind_buffer_gen(struct gl_context *ctx,
       ASSERT(ctx->Driver.NewBufferObject);
       buf = ctx->Driver.NewBufferObject(ctx, buffer, target);
       if (!buf) {
-	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindBufferARB");
+	 _mesa_error(ctx, GL_OUT_OF_MEMORY, "%s", caller);
 	 return false;
       }
       _mesa_HashInsert(ctx->Shared->BufferObjects, buffer, buf);
@@ -719,7 +720,8 @@ bind_buffer_object(struct gl_context *ctx, GLenum target, GLuint buffer)
    else {
       /* non-default buffer object */
       newBufObj = _mesa_lookup_bufferobj(ctx, buffer);
-      if (!handle_bind_buffer_gen(ctx, target, buffer, &newBufObj))
+      if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
+                                        &newBufObj, "glBindBuffer"))
          return;
    }
    
@@ -862,8 +864,8 @@ _mesa_DeleteBuffers(GLsizei n, const GLuint *ids)
          }
 
          /* unbind any vertex pointers bound to this buffer */
-         for (j = 0; j < Elements(arrayObj->VertexAttrib); j++) {
-            unbind(ctx, &arrayObj->VertexAttrib[j].BufferObj, bufObj);
+         for (j = 0; j < Elements(arrayObj->VertexBinding); j++) {
+            unbind(ctx, &arrayObj->VertexBinding[j].BufferObj, bufObj);
          }
 
          if (ctx->Array.ArrayBufferObj == bufObj) {
@@ -2181,7 +2183,8 @@ _mesa_BindBufferRange(GLenum target, GLuint index,
    } else {
       bufObj = _mesa_lookup_bufferobj(ctx, buffer);
    }
-   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
+   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
+                                     &bufObj, "glBindBufferRange"))
       return;
 
    if (!bufObj) {
@@ -2227,7 +2230,8 @@ _mesa_BindBufferBase(GLenum target, GLuint index, GLuint buffer)
    } else {
       bufObj = _mesa_lookup_bufferobj(ctx, buffer);
    }
-   if (!handle_bind_buffer_gen(ctx, target, buffer, &bufObj))
+   if (!_mesa_handle_bind_buffer_gen(ctx, target, buffer,
+                                     &bufObj, "glBindBufferBase"))
       return;
 
    if (!bufObj) {
diff --git a/src/mesa/main/bufferobj.h b/src/mesa/main/bufferobj.h
index 9b582f8c..0b898a2 100644
--- a/src/mesa/main/bufferobj.h
+++ b/src/mesa/main/bufferobj.h
@@ -28,7 +28,7 @@
 #ifndef BUFFEROBJ_H
 #define BUFFEROBJ_H
 
-
+#include <stdbool.h>
 #include "mtypes.h"
 
 
@@ -62,6 +62,13 @@ _mesa_init_buffer_objects( struct gl_context *ctx );
 extern void
 _mesa_free_buffer_objects( struct gl_context *ctx );
 
+extern bool
+_mesa_handle_bind_buffer_gen(struct gl_context *ctx,
+                             GLenum target,
+                             GLuint buffer,
+                             struct gl_buffer_object **buf_handle,
+                             const char *caller);
+
 extern void
 _mesa_update_default_objects_buffer_objects(struct gl_context *ctx);
 
diff --git a/src/mesa/main/compiler.h b/src/mesa/main/compiler.h
index d806d5b..97075f5 100644
--- a/src/mesa/main/compiler.h
+++ b/src/mesa/main/compiler.h
@@ -36,11 +36,7 @@
 
 #include <assert.h>
 #include <ctype.h>
-#if defined(__alpha__) && defined(CCPML)
-#include <cpml.h> /* use Compaq's Fast Math Library on Alpha */
-#else
 #include <math.h>
-#endif
 #include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -84,15 +80,13 @@ extern "C" {
  */
 #if defined(_MSC_VER)
 #  define finite _finite
-#elif defined(__WATCOMC__)
-#  define finite _finite
 #endif
 
 
 /**
  * Disable assorted warnings
  */
-#if !defined(OPENSTEP) && (defined(_WIN32) && !defined(__CYGWIN__)) && !defined(BUILD_FOR_SNAP)
+#if defined(_WIN32) && !defined(__CYGWIN__)
 #  if !defined(__GNUC__) /* mingw environment */
 #    pragma warning( disable : 4068 ) /* unknown pragma */
 #    pragma warning( disable : 4710 ) /* function 'foo' not inlined */
@@ -107,9 +101,6 @@ extern "C" {
 #    endif
 #  endif
 #endif
-#if defined(__WATCOMC__)
-#  pragma disable_message(201) /* Disable unreachable code warnings */
-#endif
 
 
 
@@ -198,7 +189,7 @@ static INLINE GLuint CPU_TO_LE32(GLuint x)
 
 
 
-#if !defined(CAPI) && defined(_WIN32) && !defined(BUILD_FOR_SNAP)
+#if !defined(CAPI) && defined(_WIN32)
 #define CAPI _cdecl
 #endif
 
@@ -208,7 +199,7 @@ static INLINE GLuint CPU_TO_LE32(GLuint x)
  * than GNU C
  */
 #ifndef _ASMAPI
-#if defined(_WIN32) && !defined(BUILD_FOR_SNAP)/* was: !defined( __GNUC__ ) && !defined( VMS ) && !defined( __INTEL_COMPILER )*/
+#if defined(_WIN32)
 #define _ASMAPI __cdecl
 #else
 #define _ASMAPI
@@ -239,9 +230,7 @@ static INLINE GLuint CPU_TO_LE32(GLuint x)
  * ASSERT macro
  */
 #if !defined(_WIN32_WCE)
-#if defined(BUILD_FOR_SNAP) && defined(CHECKED)
-#  define ASSERT(X)   _CHECK(X) 
-#elif defined(DEBUG)
+#if defined(DEBUG)
 #  define ASSERT(X)   assert(X)
 #else
 #  define ASSERT(X)
@@ -259,6 +248,21 @@ static INLINE GLuint CPU_TO_LE32(GLuint x)
       (void) sizeof(char [1 - 2*!(COND)]); \
    } while (0)
 
+/**
+ * Unreachable macro. Useful for suppressing "control reaches end of non-void
+ * function" warnings.
+ */
+#if __GNUC__ >= 4 && __GNUC_MINOR__ >= 5
+#define unreachable() __builtin_unreachable()
+#elif (defined(__clang__) && defined(__has_builtin))
+# if __has_builtin(__builtin_unreachable)
+#  define unreachable() __builtin_unreachable()
+# endif
+#endif
+
+#ifndef unreachable
+#define unreachable()
+#endif
 
 #if (__GNUC__ >= 3)
 #define PRINTFLIKE(f, a) __attribute__ ((format(__printf__, f, a)))
@@ -322,7 +326,7 @@ static INLINE GLuint CPU_TO_LE32(GLuint x)
     defined(ia64) || defined(__ia64__) || \
     defined(__hppa__) || defined(hpux) || \
     defined(__mips) || defined(_MIPS_ARCH) || \
-    defined(__arm__) || \
+    defined(__arm__) || defined(__aarch64__) || \
     defined(__sh__) || defined(__m32r__) || \
     (defined(__sun) && defined(_IEEE_754)) || \
     defined(__alpha__)
@@ -383,36 +387,6 @@ do {									\
    __asm__ ( "fnclex ; fldcw %0" : : "m" (*&(x)) );			\
 } while (0)
 
-#elif defined(__WATCOMC__) && defined(__386__)
-#define DEFAULT_X86_FPU		0x037f /* See GCC comments above */
-#define FAST_X86_FPU		0x003f /* See GCC comments above */
-void _watcom_start_fast_math(unsigned short *x,unsigned short *mask);
-#pragma aux _watcom_start_fast_math =                                   \
-   "fnstcw  word ptr [eax]"                                             \
-   "fldcw   word ptr [ecx]"                                             \
-   parm [eax] [ecx]                                                     \
-   modify exact [];
-void _watcom_end_fast_math(unsigned short *x);
-#pragma aux _watcom_end_fast_math =                                     \
-   "fnclex"                                                             \
-   "fldcw   word ptr [eax]"                                             \
-   parm [eax]                                                           \
-   modify exact [];
-#if defined(NO_FAST_MATH)
-#define START_FAST_MATH(x)                                              \
-do {                                                                    \
-   static GLushort mask = DEFAULT_X86_FPU;	                        \
-   _watcom_start_fast_math(&x,&mask);                                   \
-} while (0)
-#else
-#define START_FAST_MATH(x)                                              \
-do {                                                                    \
-   static GLushort mask = FAST_X86_FPU;                                 \
-   _watcom_start_fast_math(&x,&mask);                                   \
-} while (0)
-#endif
-#define END_FAST_MATH(x)  _watcom_end_fast_math(&x)
-
 #elif defined(_MSC_VER) && defined(_M_IX86)
 #define DEFAULT_X86_FPU		0x037f /* See GCC comments above */
 #define FAST_X86_FPU		0x003f /* See GCC comments above */
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 6cdeed1..8cbc935 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -494,7 +494,7 @@ init_program_limits(struct gl_context *ctx, GLenum type,
       prog->MaxParameters = MAX_VERTEX_PROGRAM_PARAMS;
       prog->MaxAttribs = MAX_VERTEX_GENERIC_ATTRIBS;
       prog->MaxAddressRegs = MAX_VERTEX_PROGRAM_ADDRESS_REGS;
-      prog->MaxUniformComponents = MAX_GEOMETRY_UNIFORM_COMPONENTS;
+      prog->MaxUniformComponents = 4 * MAX_UNIFORMS;
       prog->MaxInputComponents = 16 * 4; /* old limit not to break tnl and swrast */
       prog->MaxOutputComponents = 16 * 4; /* old limit not to break tnl and swrast */
       break;
@@ -678,6 +678,10 @@ _mesa_init_constants(struct gl_context *ctx)
    ctx->Const.MaxAtomicBufferSize = MAX_ATOMIC_COUNTERS * ATOMIC_COUNTER_SIZE;
    ctx->Const.MaxCombinedAtomicBuffers = MAX_COMBINED_ATOMIC_BUFFERS;
    ctx->Const.MaxCombinedAtomicCounters = MAX_ATOMIC_COUNTERS;
+
+   /* GL_ARB_vertex_attrib_binding */
+   ctx->Const.MaxVertexAttribRelativeOffset = 2047;
+   ctx->Const.MaxVertexAttribBindings = MAX_VERTEX_GENERIC_ATTRIBS;
 }
 
 
@@ -804,7 +808,7 @@ init_attrib_groups(struct gl_context *ctx)
    ctx->NewState = _NEW_ALL;
    ctx->NewDriverState = ~0;
    ctx->ErrorValue = GL_NO_ERROR;
-   ctx->ResetStatus = GL_NO_ERROR;
+   ctx->ShareGroupReset = false;
    ctx->varying_vp_inputs = VERT_BIT_ALL;
 
    return GL_TRUE;
diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index d7c4327..b5b874f 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -890,6 +890,15 @@ struct dd_function_table {
                              struct gl_texture_object *texObj,
                              struct gl_texture_image *texImage,
                              const GLvoid *vdpSurface, GLuint index);
+
+   /**
+    * Query reset status for GL_ARB_robustness
+    *
+    * Per \c glGetGraphicsResetStatusARB, this function should return a
+    * non-zero value once after a reset.  If a reset is non-atomic, the
+    * non-zero status should be returned for the duration of the reset.
+    */
+   GLenum (*GetGraphicsResetStatus)(struct gl_context *ctx);
 };
 
 
diff --git a/src/mesa/main/enable.c b/src/mesa/main/enable.c
index dd6a772..c047f5d 100644
--- a/src/mesa/main/enable.c
+++ b/src/mesa/main/enable.c
@@ -135,6 +135,8 @@ client_state(struct gl_context *ctx, GLenum cap, GLboolean state)
    else
       arrayObj->_Enabled &= ~flag;
 
+   arrayObj->NewArrays |= flag;
+
    if (ctx->Driver.Enable) {
       ctx->Driver.Enable( ctx, cap, state );
    }
diff --git a/src/mesa/main/extensions.c b/src/mesa/main/extensions.c
index 48c4e9f..104618c 100644
--- a/src/mesa/main/extensions.c
+++ b/src/mesa/main/extensions.c
@@ -165,9 +165,11 @@ static const struct extension extension_table[] = {
    { "GL_ARB_uniform_buffer_object",               o(ARB_uniform_buffer_object),               GL,             2009 },
    { "GL_ARB_vertex_array_bgra",                   o(EXT_vertex_array_bgra),                   GL,             2008 },
    { "GL_ARB_vertex_array_object",                 o(dummy_true),                              GL,             2006 },
+   { "GL_ARB_vertex_attrib_binding",               o(dummy_true),                              GL,             2012 },
    { "GL_ARB_vertex_buffer_object",                o(dummy_true),                              GLL,            2003 },
    { "GL_ARB_vertex_program",                      o(ARB_vertex_program),                      GLL,            2002 },
    { "GL_ARB_vertex_shader",                       o(ARB_vertex_shader),                       GL,             2002 },
+   { "GL_ARB_vertex_type_10f_11f_11f_rev",         o(ARB_vertex_type_10f_11f_11f_rev),         GL,             2013 },
    { "GL_ARB_vertex_type_2_10_10_10_rev",          o(ARB_vertex_type_2_10_10_10_rev),          GL,             2009 },
    { "GL_ARB_window_pos",                          o(dummy_true),                              GLL,            2001 },
    /* EXT extensions */
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index 6a0de0c..eee8550 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -550,7 +550,7 @@ static void
 find_custom_value(struct gl_context *ctx, const struct value_desc *d, union value *v)
 {
    struct gl_buffer_object **buffer_obj;
-   struct gl_client_array *array;
+   struct gl_vertex_attrib_array *array;
    GLuint unit, *p;
 
    switch (d->pname) {
@@ -775,7 +775,7 @@ find_custom_value(struct gl_context *ctx, const struct value_desc *d, union valu
       break;
    case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB:
       v->value_int =
-	 ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
+	 ctx->Array.ArrayObj->VertexBinding[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj->Name;
       break;
    case GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB:
       v->value_int = ctx->Array.ArrayObj->ElementArrayBufferObj->Name;
@@ -819,7 +819,7 @@ find_custom_value(struct gl_context *ctx, const struct value_desc *d, union valu
 	 ctx->CurrentRenderbuffer ? ctx->CurrentRenderbuffer->Name : 0;
       break;
    case GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES:
-      v->value_int = ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
+      v->value_int = ctx->Array.ArrayObj->VertexBinding[VERT_ATTRIB_POINT_SIZE].BufferObj->Name;
       break;
 
    case GL_FOG_COLOR:
@@ -1740,6 +1740,30 @@ find_value_indexed(const char *func, GLenum pname, GLuint index, union value *v)
          goto invalid_value;
       v->value_int64 = ctx->AtomicBufferBindings[index].Size;
       return TYPE_INT64;
+
+   case GL_VERTEX_BINDING_DIVISOR:
+      if (!_mesa_is_desktop_gl(ctx) || !ctx->Extensions.ARB_instanced_arrays)
+          goto invalid_enum;
+      if (index >= ctx->Const.VertexProgram.MaxAttribs)
+          goto invalid_value;
+      v->value_int = ctx->Array.ArrayObj->VertexBinding[VERT_ATTRIB_GENERIC(index)].InstanceDivisor;
+      return TYPE_INT;
+
+   case GL_VERTEX_BINDING_OFFSET:
+      if (!_mesa_is_desktop_gl(ctx))
+          goto invalid_enum;
+      if (index >= ctx->Const.VertexProgram.MaxAttribs)
+          goto invalid_value;
+      v->value_int = ctx->Array.ArrayObj->VertexBinding[VERT_ATTRIB_GENERIC(index)].Offset;
+      return TYPE_INT;
+
+   case GL_VERTEX_BINDING_STRIDE:
+      if (!_mesa_is_desktop_gl(ctx))
+          goto invalid_enum;
+      if (index >= ctx->Const.VertexProgram.MaxAttribs)
+          goto invalid_value;
+      v->value_int = ctx->Array.ArrayObj->VertexBinding[VERT_ATTRIB_GENERIC(index)].Stride;
+      return TYPE_INT;
    }
 
  invalid_enum:
diff --git a/src/mesa/main/get_hash_params.py b/src/mesa/main/get_hash_params.py
index 0851b7b..c961fee 100644
--- a/src/mesa/main/get_hash_params.py
+++ b/src/mesa/main/get_hash_params.py
@@ -221,9 +221,9 @@ descriptor=[
   [ "SAMPLE_ALPHA_TO_ONE_ARB", "CONTEXT_BOOL(Multisample.SampleAlphaToOne), NO_EXTRA" ],
 
 # GL_ARB_vertex_buffer_object
-  [ "VERTEX_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_POS].BufferObj), NO_EXTRA" ],
-  [ "NORMAL_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_NORMAL].BufferObj), NO_EXTRA" ],
-  [ "COLOR_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_COLOR0].BufferObj), NO_EXTRA" ],
+  [ "VERTEX_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_POS].BufferObj), NO_EXTRA" ],
+  [ "NORMAL_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_NORMAL].BufferObj), NO_EXTRA" ],
+  [ "COLOR_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_COLOR0].BufferObj), NO_EXTRA" ],
   [ "TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, NO_OFFSET, NO_EXTRA" ],
 
 # GL_OES_point_sprite
@@ -585,10 +585,10 @@ descriptor=[
   [ "PRIMITIVE_RESTART_INDEX_NV", "CONTEXT_INT(Array.RestartIndex), extra_NV_primitive_restart" ],
 
 # GL_ARB_vertex_buffer_object
-  [ "INDEX_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_COLOR_INDEX].BufferObj), NO_EXTRA" ],
-  [ "EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_EDGEFLAG].BufferObj), NO_EXTRA" ],
-  [ "SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_COLOR1].BufferObj), NO_EXTRA" ],
-  [ "FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexAttrib[VERT_ATTRIB_FOG].BufferObj), NO_EXTRA" ],
+  [ "INDEX_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_COLOR_INDEX].BufferObj), NO_EXTRA" ],
+  [ "EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_EDGEFLAG].BufferObj), NO_EXTRA" ],
+  [ "SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_COLOR1].BufferObj), NO_EXTRA" ],
+  [ "FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_array_object, VertexBinding[VERT_ATTRIB_FOG].BufferObj), NO_EXTRA" ],
 
 # GL_ARB_vertex_program
 # == GL_VERTEX_PROGRAM_NV
@@ -737,6 +737,10 @@ descriptor=[
   [ "MAX_GEOMETRY_ATOMIC_COUNTERS", "CONTEXT_INT(Const.GeometryProgram.MaxAtomicCounters), extra_ARB_shader_atomic_counters_and_geometry_shader" ],
   [ "MAX_COMBINED_ATOMIC_COUNTER_BUFFERS", "CONTEXT_INT(Const.MaxCombinedAtomicBuffers), extra_ARB_shader_atomic_counters" ],
   [ "MAX_COMBINED_ATOMIC_COUNTERS", "CONTEXT_INT(Const.MaxCombinedAtomicCounters), extra_ARB_shader_atomic_counters" ],
+
+# GL_ARB_vertex_attrib_binding
+  [ "MAX_VERTEX_ATTRIB_RELATIVE_OFFSET", "CONTEXT_ENUM(Const.MaxVertexAttribRelativeOffset), NO_EXTRA" ],
+  [ "MAX_VERTEX_ATTRIB_BINDINGS", "CONTEXT_ENUM(Const.MaxVertexAttribBindings), NO_EXTRA" ],
 ]},
 
 # Enums restricted to OpenGL Core profile
diff --git a/src/mesa/main/getstring.c b/src/mesa/main/getstring.c
index 0e07542..d818911 100644
--- a/src/mesa/main/getstring.c
+++ b/src/mesa/main/getstring.c
@@ -23,7 +23,7 @@
  */
 
 
-
+#include <stdbool.h>
 #include "glheader.h"
 #include "context.h"
 #include "get.h"
@@ -305,11 +305,50 @@ GLenum GLAPIENTRY
 _mesa_GetGraphicsResetStatusARB( void )
 {
    GET_CURRENT_CONTEXT(ctx);
-   GLenum status = ctx->ResetStatus;
+   GLenum status = GL_NO_ERROR;
+
+   /* The ARB_robustness specification says:
+    *
+    *     "If the reset notification behavior is NO_RESET_NOTIFICATION_ARB,
+    *     then the implementation will never deliver notification of reset
+    *     events, and GetGraphicsResetStatusARB will always return NO_ERROR."
+    */
+   if (ctx->Const.ResetStrategy == GL_NO_RESET_NOTIFICATION_ARB) {
+      if (MESA_VERBOSE & VERBOSE_API)
+         _mesa_debug(ctx,
+                     "glGetGraphicsResetStatusARB always returns GL_NO_ERROR "
+                     "because reset notifictation was not requested at context "
+                     "creation.\n");
+
+      return GL_NO_ERROR;
+   }
 
-   if (MESA_VERBOSE & VERBOSE_API)
-      _mesa_debug(ctx, "glGetGraphicsResetStatusARB"
-                       "(always returns GL_NO_ERROR)\n");
+   if (ctx->Driver.GetGraphicsResetStatus) {
+      /* Query the reset status of this context from the driver core.
+       */
+      status = ctx->Driver.GetGraphicsResetStatus(ctx);
+
+      _glthread_LOCK_MUTEX(ctx->Shared->Mutex);
+
+      /* If this context has not been affected by a GPU reset, check to see if
+       * some other context in the share group has been affected by a reset.
+       * If another context saw a reset but this context did not, assume that
+       * this context was not guilty.
+       */
+      if (status != GL_NO_ERROR) {
+         ctx->Shared->ShareGroupReset = true;
+      } else if (ctx->Shared->ShareGroupReset && !ctx->ShareGroupReset) {
+         status = GL_INNOCENT_CONTEXT_RESET_ARB;
+      }
+
+      ctx->ShareGroupReset = ctx->Shared->ShareGroupReset;
+      _glthread_UNLOCK_MUTEX(ctx->Shared->Mutex);
+   }
+
+   if (!ctx->Driver.GetGraphicsResetStatus && (MESA_VERBOSE & VERBOSE_API))
+      _mesa_debug(ctx,
+                  "glGetGraphicsResetStatusARB always returns GL_NO_ERROR "
+                  "because the driver doesn't track reset status.\n");
 
    return status;
 }
diff --git a/src/mesa/main/glformats.c b/src/mesa/main/glformats.c
index dfee6f1..740faa8 100644
--- a/src/mesa/main/glformats.c
+++ b/src/mesa/main/glformats.c
@@ -345,6 +345,11 @@ _mesa_bytes_per_vertex_attrib(GLint comps, GLenum type)
          return sizeof(GLuint);
       else
          return -1;
+   case GL_UNSIGNED_INT_10F_11F_11F_REV:
+      if (comps == 3)
+         return sizeof(GLuint);
+      else
+         return -1;
    default:
       return -1;
    }
diff --git a/src/mesa/main/glheader.h b/src/mesa/main/glheader.h
index 4ed51b3..7f7f9a3 100644
--- a/src/mesa/main/glheader.h
+++ b/src/mesa/main/glheader.h
@@ -33,22 +33,6 @@
 #define GLHEADER_H
 
 
-#ifdef WGLAPI
-#undef WGLAPI
-#endif
-
-
-#if !defined(OPENSTEP) && (defined(__WIN32__) && !defined(__CYGWIN__)) && !defined(BUILD_FOR_SNAP)
-#  if (defined(_MSC_VER) || defined(__MINGW32__)) && defined(BUILD_GL32) /* tag specify we're building mesa as a DLL */
-#    define WGLAPI __declspec(dllexport)
-#  elif (defined(_MSC_VER) || defined(__MINGW32__)) && defined(_DLL) /* tag specifying we're building for DLL runtime support */
-#    define WGLAPI __declspec(dllimport)
-#  else /* for use with static link lib build of Win32 edition only */
-#    define WGLAPI __declspec(dllimport)
-#  endif /* _STATIC_MESA support */
-#endif /* WIN32 / CYGWIN bracket */
-
-
 #define GL_GLEXT_PROTOTYPES
 #include "GL/gl.h"
 #include "GL/glext.h"
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index b5c5583..67c4996 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -35,6 +35,7 @@
 
 
 #include <stdint.h>             /* uint32_t */
+#include <stdbool.h>
 
 #include "main/glheader.h"
 #include "main/config.h"
@@ -1474,6 +1475,50 @@ struct gl_client_array
 
 
 /**
+ * Vertex attribute array as seen by the client.
+ *
+ * Contains the size, type, format and normalization flag,
+ * along with the index of a vertex buffer binding point.
+ *
+ * Note that the Stride field corresponds to VERTEX_ATTRIB_ARRAY_STRIDE
+ * and is only present for backwards compatibility reasons.
+ * Rendering always uses VERTEX_BINDING_STRIDE.
+ * The gl*Pointer() functions will set VERTEX_ATTRIB_ARRAY_STRIDE
+ * and VERTEX_BINDING_STRIDE to the same value, while
+ * glBindVertexBuffer() will only set VERTEX_BINDING_STRIDE.
+ */
+struct gl_vertex_attrib_array
+{
+   GLint Size;              /**< Components per element (1,2,3,4) */
+   GLenum Type;             /**< Datatype: GL_FLOAT, GL_INT, etc */
+   GLenum Format;           /**< Default: GL_RGBA, but may be GL_BGRA */
+   GLsizei Stride;          /**< Stride as specified with gl*Pointer() */
+   const GLubyte *Ptr;      /**< Points to client array data. Not used when a VBO is bound */
+   GLintptr RelativeOffset; /**< Offset of the first element relative to the binding offset */
+   GLboolean Enabled;       /**< Whether the array is enabled */
+   GLboolean Normalized;    /**< Fixed-point values are normalized when converted to floats */
+   GLboolean Integer;       /**< Fixed-point values are not converted to floats */
+   GLuint _ElementSize;     /**< Size of each element in bytes */
+   GLuint VertexBinding;    /**< Vertex buffer binding */
+};
+
+
+/**
+ * This describes the buffer object used for a vertex array (or
+ * multiple vertex arrays).  If BufferObj points to the default/null
+ * buffer object, then the vertex array lives in user memory and not a VBO.
+ */
+struct gl_vertex_buffer_binding
+{
+   GLintptr Offset;                    /**< User-specified offset */
+   GLsizei Stride;                     /**< User-specified stride */
+   GLuint InstanceDivisor;             /**< GL_ARB_instanced_arrays */
+   struct gl_buffer_object *BufferObj; /**< GL_ARB_vertex_buffer_object */
+   GLbitfield64 _BoundArrays;          /**< Arrays bound to this binding point */
+};
+
+
+/**
  * Collection of vertex arrays.  Defined by the GL_APPLE_vertex_array_object
  * extension, but a nice encapsulation in any case.
  */
@@ -1507,12 +1552,21 @@ struct gl_array_object
     */
    GLboolean EverBound;
 
+   /** Derived vertex attribute arrays */
+   struct gl_client_array _VertexAttrib[VERT_ATTRIB_MAX];
+
    /** Vertex attribute arrays */
-   struct gl_client_array VertexAttrib[VERT_ATTRIB_MAX];
+   struct gl_vertex_attrib_array VertexAttrib[VERT_ATTRIB_MAX];
+
+   /** Vertex buffer bindings */
+   struct gl_vertex_buffer_binding VertexBinding[VERT_ATTRIB_MAX];
 
    /** Mask of VERT_BIT_* values indicating which arrays are enabled */
    GLbitfield64 _Enabled;
 
+   /** Mask of VERT_BIT_* values indicating changed/dirty arrays */
+   GLbitfield64 NewArrays;
+
    /**
     * Min of all enabled arrays' _MaxElement.  When arrays reside inside VBOs
     * we can determine the max legal (in bounds) glDrawElements array index.
@@ -1876,10 +1930,9 @@ struct gl_perf_monitor_state
  * NOTE: first four tokens must fit into 2 bits (see t_vb_arbprogram.c)
  * All values should fit in a 4-bit field.
  *
- * NOTE: PROGRAM_ENV_PARAM, PROGRAM_STATE_VAR,
- * PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be considered to
- * be "uniform" variables since they can only be set outside glBegin/End.
- * They're also all stored in the same Parameters array.
+ * NOTE: PROGRAM_STATE_VAR, PROGRAM_CONSTANT, and PROGRAM_UNIFORM can all be
+ * considered to be "uniform" variables since they can only be set outside
+ * glBegin/End.  They're also all stored in the same Parameters array.
  */
 typedef enum
 {
@@ -1887,8 +1940,6 @@ typedef enum
    PROGRAM_ARRAY,       /**< Arrays & Matrixes */
    PROGRAM_INPUT,       /**< machine->Inputs[] */
    PROGRAM_OUTPUT,      /**< machine->Outputs[] */
-   PROGRAM_LOCAL_PARAM, /**< gl_program->LocalParams[] */
-   PROGRAM_ENV_PARAM,   /**< gl_program->Parameters[] */
    PROGRAM_STATE_VAR,   /**< gl_program->Parameters[] */
    PROGRAM_CONSTANT,    /**< gl_program->Parameters[] */
    PROGRAM_UNIFORM,     /**< gl_program->Parameters[] */
@@ -1984,8 +2035,15 @@ struct gl_program
 
    /** Named parameters, constants, etc. from program text */
    struct gl_program_parameter_list *Parameters;
-   /** Numbered local parameters */
-   GLfloat LocalParams[MAX_PROGRAM_LOCAL_PARAMS][4];
+
+   /**
+    * Local parameters used by the program.
+    *
+    * It's dynamically allocated because it is rarely used (just
+    * assembly-style programs), and MAX_PROGRAM_LOCAL_PARAMS entries once it's
+    * allocated.
+    */
+   GLfloat (*LocalParams)[4];
 
    /** Map from sampler unit to texture unit (set by glUniform1i()) */
    GLubyte SamplerUnits[MAX_SAMPLERS];
@@ -2765,6 +2823,17 @@ struct gl_shared_state
 
    /** GL_ARB_sampler_objects */
    struct _mesa_HashTable *SamplerObjects;
+
+   /**
+    * Some context in this share group was affected by a GPU reset
+    *
+    * On the next call to \c glGetGraphicsResetStatus, contexts that have not
+    * been affected by a GPU reset must also return
+    * \c GL_INNOCENT_CONTEXT_RESET_ARB.
+    *
+    * Once this field becomes true, it is never reset to false.
+    */
+   bool ShareGroupReset;
 };
 
 
@@ -3213,6 +3282,10 @@ struct gl_constants
    GLuint MaxAtomicBufferSize;
    GLuint MaxCombinedAtomicBuffers;
    GLuint MaxCombinedAtomicCounters;
+
+   /** GL_ARB_vertex_attrib_binding */
+   GLint MaxVertexAttribRelativeOffset;
+   GLint MaxVertexAttribBindings;
 };
 
 
@@ -3291,6 +3364,7 @@ struct gl_extensions
    GLboolean ARB_uniform_buffer_object;
    GLboolean ARB_vertex_program;
    GLboolean ARB_vertex_shader;
+   GLboolean ARB_vertex_type_10f_11f_11f_rev;
    GLboolean ARB_vertex_type_2_10_10_10_rev;
    GLboolean EXT_blend_color;
    GLboolean EXT_blend_equation_separate;
@@ -3851,9 +3925,6 @@ struct gl_context
 
    GLenum ErrorValue;        /**< Last error code */
 
-   /* GL_ARB_robustness */
-   GLenum ResetStatus;
-
    /**
     * Recognize and silence repeated error debug messages in buggy apps.
     */
@@ -3918,6 +3989,13 @@ struct gl_context
    const void *vdpGetProcAddress;
    struct set *vdpSurfaces;
    /*@}*/
+
+   /**
+    * Has this context observed a GPU reset in any context in the share group?
+    *
+    * Once this field becomes true, it is never reset to false.
+    */
+   GLboolean ShareGroupReset;
 };
 
 
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index 7da860d..1d9aac3 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -825,6 +825,8 @@ compile_shader(struct gl_context *ctx, GLuint shaderObj)
          fprintf(stderr, "GLSL source for %s shader %d:\n",
                  _mesa_glsl_shader_target_name(sh->Type), sh->Name);
          fprintf(stderr, "%s\n", sh->Source);
+         fprintf(stderr, "Info Log:\n%s\n", sh->InfoLog);
+         fflush(stderr);
       }
 
       if (ctx->Shader.Flags & GLSL_REPORT_ERRORS) {
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 2392641..33070b7 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -410,6 +410,9 @@ _mesa_update_state_locked( struct gl_context *ctx )
       new_prog_state |= update_program( ctx );
    }
 
+   if (new_state & _NEW_ARRAY)
+      _mesa_update_array_object_client_arrays(ctx, ctx->Array.ArrayObj);
+
    if (ctx->Const.CheckArrayBounds &&
        new_state & (_NEW_ARRAY | _NEW_PROGRAM | _NEW_BUFFER_OBJECT)) {
       _mesa_update_array_object_max_element(ctx, ctx->Array.ArrayObj);
@@ -430,6 +433,7 @@ _mesa_update_state_locked( struct gl_context *ctx )
    new_state = ctx->NewState | new_prog_state;
    ctx->NewState = 0;
    ctx->Driver.UpdateState(ctx, new_state);
+   ctx->Array.ArrayObj->NewArrays = 0x0;
 }
 
 
diff --git a/src/mesa/main/streaming-load-memcpy.c b/src/mesa/main/streaming-load-memcpy.c
new file mode 100644
index 0000000..d7147af
--- /dev/null
+++ b/src/mesa/main/streaming-load-memcpy.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *    Matt Turner <mattst88@gmail.com>
+ *
+ */
+
+#include "main/macros.h"
+#include "main/streaming-load-memcpy.h"
+#include <smmintrin.h>
+
+/* Copies memory from src to dst, using SSE 4.1's MOVNTDQA to get streaming
+ * read performance from uncached memory.
+ */
+void
+_mesa_streaming_load_memcpy(void *restrict dst, void *restrict src, size_t len)
+{
+   char *restrict d = dst;
+   char *restrict s = src;
+
+   /* If dst and src are not co-aligned, fallback to memcpy(). */
+   if (((uintptr_t)d & 15) != ((uintptr_t)s & 15)) {
+      memcpy(d, s, len);
+      return;
+   }
+
+   /* memcpy() the misaligned header. At the end of this if block, <d> and <s>
+    * are aligned to a 16-byte boundary or <len> == 0.
+    */
+   if ((uintptr_t)d & 15) {
+      uintptr_t bytes_before_alignment_boundary = 16 - ((uintptr_t)d & 15);
+      assert(bytes_before_alignment_boundary < 16);
+
+      memcpy(d, s, MIN2(bytes_before_alignment_boundary, len));
+
+      d = (char *)ALIGN((uintptr_t)d, 16);
+      s = (char *)ALIGN((uintptr_t)s, 16);
+      len -= MIN2(bytes_before_alignment_boundary, len);
+   }
+
+   while (len >= 64) {
+      __m128i *dst_cacheline = (__m128i *)d;
+      __m128i *src_cacheline = (__m128i *)s;
+
+      __m128i temp1 = _mm_stream_load_si128(src_cacheline + 0);
+      __m128i temp2 = _mm_stream_load_si128(src_cacheline + 1);
+      __m128i temp3 = _mm_stream_load_si128(src_cacheline + 2);
+      __m128i temp4 = _mm_stream_load_si128(src_cacheline + 3);
+
+      _mm_store_si128(dst_cacheline + 0, temp1);
+      _mm_store_si128(dst_cacheline + 1, temp2);
+      _mm_store_si128(dst_cacheline + 2, temp3);
+      _mm_store_si128(dst_cacheline + 3, temp4);
+
+      d += 64;
+      s += 64;
+      len -= 64;
+   }
+
+   /* memcpy() the tail. */
+   if (len) {
+      memcpy(d, s, len);
+   }
+}
diff --git a/src/mesa/main/streaming-load-memcpy.h b/src/mesa/main/streaming-load-memcpy.h
new file mode 100644
index 0000000..41eeeec
--- /dev/null
+++ b/src/mesa/main/streaming-load-memcpy.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *    Matt Turner <mattst88@gmail.com>
+ *
+ */
+
+/* Copies memory from src to dst, using SSE 4.1's MOVNTDQA to get streaming
+ * read performance from uncached memory.
+ */
+void
+_mesa_streaming_load_memcpy(void *restrict dst, void *restrict src, size_t len);
diff --git a/src/mesa/main/tests/Makefile.am b/src/mesa/main/tests/Makefile.am
index 97713f2..0d3a51f 100644
--- a/src/mesa/main/tests/Makefile.am
+++ b/src/mesa/main/tests/Makefile.am
@@ -7,6 +7,7 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gtest/include \
 	-I$(top_srcdir)/src/mapi \
 	-I$(top_srcdir)/src/mesa \
+	-I$(top_builddir)/src/mesa \
 	-I$(top_srcdir)/include \
 	$(DEFINES) $(INCLUDE_DIRS)
 
diff --git a/src/mesa/main/tests/dispatch_sanity.cpp b/src/mesa/main/tests/dispatch_sanity.cpp
index 58cff9b..922f0ac 100644
--- a/src/mesa/main/tests/dispatch_sanity.cpp
+++ b/src/mesa/main/tests/dispatch_sanity.cpp
@@ -854,12 +854,12 @@ const struct function gl_core_functions_possible[] = {
 // { "glDispatchComputeIndirect", 43, -1 },             // XXX: Add to xml
 // { "glCopyImageSubData", 43, -1 },                    // XXX: Add to xml
 // { "glTextureView", 43, -1 },                         // XXX: Add to xml
-// { "glBindVertexBuffer", 43, -1 },                    // XXX: Add to xml
-// { "glVertexAttribFormat", 43, -1 },                  // XXX: Add to xml
-// { "glVertexAttribIFormat", 43, -1 },                 // XXX: Add to xml
-// { "glVertexAttribLFormat", 43, -1 },                 // XXX: Add to xml
-// { "glVertexAttribBinding", 43, -1 },                 // XXX: Add to xml
-// { "glVertexBindingDivisor", 43, -1 },                // XXX: Add to xml
+   { "glBindVertexBuffer", 43, -1 },
+   { "glVertexAttribFormat", 43, -1 },
+   { "glVertexAttribIFormat", 43, -1 },
+   { "glVertexAttribLFormat", 43, -1 },
+   { "glVertexAttribBinding", 43, -1 },
+   { "glVertexBindingDivisor", 43, -1 },
 // { "glVertexArrayBindVertexBufferEXT", 43, -1 },      // XXX: Add to xml
 // { "glVertexArrayVertexAttribFormatEXT", 43, -1 },    // XXX: Add to xml
 // { "glVertexArrayVertexAttribIFormatEXT", 43, -1 },   // XXX: Add to xml
diff --git a/src/mesa/main/varray.c b/src/mesa/main/varray.c
index dee476a..0f38270 100644
--- a/src/mesa/main/varray.c
+++ b/src/mesa/main/varray.c
@@ -60,6 +60,7 @@
 #define FIXED_GL_BIT         0x800
 #define UNSIGNED_INT_2_10_10_10_REV_BIT 0x1000
 #define INT_2_10_10_10_REV_BIT 0x2000
+#define UNSIGNED_INT_10F_11F_11F_REV_BIT 0x4000
 
 
 /** Convert GL datatype enum into a <type>_BIT value seen above */
@@ -96,6 +97,8 @@ type_to_bit(const struct gl_context *ctx, GLenum type)
       return UNSIGNED_INT_2_10_10_10_REV_BIT;
    case GL_INT_2_10_10_10_REV:
       return INT_2_10_10_10_REV_BIT;
+   case GL_UNSIGNED_INT_10F_11F_11F_REV:
+      return UNSIGNED_INT_10F_11F_11F_REV_BIT;
    default:
       return 0;
    }
@@ -103,54 +106,110 @@ type_to_bit(const struct gl_context *ctx, GLenum type)
 
 
 /**
- * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
- * functions.
- *
- * \param func  name of calling function used for error reporting
- * \param attrib  the attribute array index to update
- * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
- * \param sizeMin  min allowable size value
- * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
- * \param size  components per element (1, 2, 3 or 4)
- * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
- * \param stride  stride between elements, in elements
- * \param normalized  are integer types converted to floats in [-1, 1]?
- * \param integer  integer-valued values (will not be normalized to [-1,1])
- * \param ptr  the address (or offset inside VBO) of the array data
+ * Sets the VertexBinding field in the vertex attribute given by attribIndex.
  */
 static void
-update_array(struct gl_context *ctx,
-             const char *func,
-             GLuint attrib, GLbitfield legalTypesMask,
-             GLint sizeMin, GLint sizeMax,
-             GLint size, GLenum type, GLsizei stride,
-             GLboolean normalized, GLboolean integer,
-             const GLvoid *ptr)
+vertex_attrib_binding(struct gl_context *ctx, GLuint attribIndex,
+                      GLuint bindingIndex)
 {
-   struct gl_client_array *array;
-   GLbitfield typeBit;
-   GLsizei elementSize;
-   GLenum format = GL_RGBA;
+   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+   struct gl_vertex_attrib_array *array = &arrayObj->VertexAttrib[attribIndex];
 
-   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
-    *
-    *     "Client vertex arrays - all vertex array attribute pointers must
-    *     refer to buffer objects (section 2.9.2). The default vertex array
-    *     object (the name zero) is also deprecated. Calling
-    *     VertexAttribPointer when no buffer object or no vertex array object
-    *     is bound will generate an INVALID_OPERATION error..."
-    *
-    * The check for VBOs is handled below.
-    */
-   if (ctx->API == API_OPENGL_CORE
-       && (ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj)) {
-      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
-                  func);
-      return;
+   if (array->VertexBinding != bindingIndex) {
+      const GLbitfield64 array_bit = VERT_BIT(attribIndex);
+
+      FLUSH_VERTICES(ctx, _NEW_ARRAY);
+
+      arrayObj->VertexBinding[array->VertexBinding]._BoundArrays &= ~array_bit;
+      arrayObj->VertexBinding[bindingIndex]._BoundArrays |= array_bit;
+
+      array->VertexBinding = bindingIndex;
+
+      arrayObj->NewArrays |= array_bit;
    }
+}
+
+
+/**
+ * Binds a buffer object to the vertex buffer binding point given by index,
+ * and sets the Offset and Stride fields.
+ */
+static void
+bind_vertex_buffer(struct gl_context *ctx, GLuint index,
+                   struct gl_buffer_object *vbo,
+                   GLintptr offset, GLsizei stride)
+{
+   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+   struct gl_vertex_buffer_binding *binding = &arrayObj->VertexBinding[index];
+
+   if (binding->BufferObj != vbo ||
+       binding->Offset != offset ||
+       binding->Stride != stride) {
+
+      FLUSH_VERTICES(ctx, _NEW_ARRAY);
+
+      _mesa_reference_buffer_object(ctx, &binding->BufferObj, vbo);
+
+      binding->Offset = offset;
+      binding->Stride = stride;
+
+      arrayObj->NewArrays |= binding->_BoundArrays;
+   }
+}
+
+
+/**
+ * Sets the InstanceDivisor field in the vertex buffer binding point
+ * given by bindingIndex.
+ */
+static void
+vertex_binding_divisor(struct gl_context *ctx, GLuint bindingIndex,
+                       GLuint divisor)
+{
+   struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+   struct gl_vertex_buffer_binding *binding =
+      &arrayObj->VertexBinding[bindingIndex];
+
+   if (binding->InstanceDivisor != divisor) {
+      FLUSH_VERTICES(ctx, _NEW_ARRAY);
+      binding->InstanceDivisor = divisor;
+      arrayObj->NewArrays |= binding->_BoundArrays;
+   }
+}
+
+
+/**
+ * Does error checking and updates the format in an attrib array.
+ *
+ * Called by update_array() and VertexAttrib*Format().
+ *
+ * \param func         Name of calling function used for error reporting
+ * \param attrib       The index of the attribute array
+ * \param legalTypes   Bitmask of *_BIT above indicating legal datatypes
+ * \param sizeMin      Min allowable size value
+ * \param sizeMax      Max allowable size value (may also be BGRA_OR_4)
+ * \param size         Components per element (1, 2, 3 or 4)
+ * \param type         Datatype of each component (GL_FLOAT, GL_INT, etc)
+ * \param normalized   Whether integer types are converted to floats in [-1, 1]
+ * \param integer      Integer-valued values (will not be normalized to [-1, 1])
+ * \param relativeOffset Offset of the first element relative to the binding offset.
+ */
+static bool
+update_array_format(struct gl_context *ctx,
+                    const char *func,
+                    GLuint attrib, GLbitfield legalTypesMask,
+                    GLint sizeMin, GLint sizeMax,
+                    GLint size, GLenum type,
+                    GLboolean normalized, GLboolean integer,
+                    GLuint relativeOffset)
+{
+   struct gl_vertex_attrib_array *array;
+   GLbitfield typeBit;
+   GLuint elementSize;
+   GLenum format = GL_RGBA;
 
    if (_mesa_is_gles(ctx)) {
-      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT);
+      legalTypesMask &= ~(FIXED_GL_BIT | DOUBLE_BIT | UNSIGNED_INT_10F_11F_11F_REV_BIT);
 
       /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
        * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
@@ -180,13 +239,16 @@ update_array(struct gl_context *ctx,
       if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
          legalTypesMask &= ~(UNSIGNED_INT_2_10_10_10_REV_BIT |
                              INT_2_10_10_10_REV_BIT);
+
+      if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
+         legalTypesMask &= ~UNSIGNED_INT_10F_11F_11F_REV_BIT;
    }
 
    typeBit = type_to_bit(ctx, type);
    if (typeBit == 0x0 || (typeBit & legalTypesMask) == 0x0) {
       _mesa_error(ctx, GL_INVALID_ENUM, "%s(type = %s)",
                   func, _mesa_lookup_enum_by_nr(type));
-      return;
+      return false;
    }
 
    /* Do size parameter checking.
@@ -206,26 +268,26 @@ update_array(struct gl_context *ctx,
        *    ...
        *    • size is BGRA and normalized is FALSE;"
        */
-      GLboolean bgra_error = GL_FALSE;
+      bool bgra_error = false;
 
       if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev) {
          if (type != GL_UNSIGNED_INT_2_10_10_10_REV &&
              type != GL_INT_2_10_10_10_REV &&
              type != GL_UNSIGNED_BYTE)
-            bgra_error = GL_TRUE;
+            bgra_error = true;
       } else if (type != GL_UNSIGNED_BYTE)
-         bgra_error = GL_TRUE;
+         bgra_error = true;
 
       if (bgra_error) {
          _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=GL_BGRA and type=%s)",
                      func, _mesa_lookup_enum_by_nr(type));
-         return;
+         return false;
       }
 
       if (!normalized) {
          _mesa_error(ctx, GL_INVALID_OPERATION,
                      "%s(size=GL_BGRA and normalized=GL_FALSE)", func);
-         return;
+         return false;
       }
 
       format = GL_BGRA;
@@ -233,18 +295,101 @@ update_array(struct gl_context *ctx,
    }
    else if (size < sizeMin || size > sizeMax || size > 4) {
       _mesa_error(ctx, GL_INVALID_VALUE, "%s(size=%d)", func, size);
-      return;
+      return false;
    }
 
    if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
        (type == GL_UNSIGNED_INT_2_10_10_10_REV ||
         type == GL_INT_2_10_10_10_REV) && size != 4) {
       _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
-      return;
+      return false;
+   }
+
+   /* The ARB_vertex_attrib_binding_spec says:
+    *
+    *   An INVALID_VALUE error is generated if <relativeoffset> is larger than
+    *   the value of MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
+    */
+   if (relativeOffset > ctx->Const.MaxVertexAttribRelativeOffset) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "%s(relativeOffset=%d > "
+                  "GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET)",
+                  func, relativeOffset);
+      return false;
+   }
+
+   if (ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev &&
+         type == GL_UNSIGNED_INT_10F_11F_11F_REV && size != 3) {
+      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
+      return false;
    }
 
    ASSERT(size <= 4);
 
+   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
+   assert(elementSize != -1);
+
+   array = &ctx->Array.ArrayObj->VertexAttrib[attrib];
+   array->Size = size;
+   array->Type = type;
+   array->Format = format;
+   array->Normalized = normalized;
+   array->Integer = integer;
+   array->RelativeOffset = relativeOffset;
+   array->_ElementSize = elementSize;
+
+   ctx->Array.ArrayObj->NewArrays |= VERT_BIT(attrib);
+   ctx->NewState |= _NEW_ARRAY;
+
+   return true;
+}
+
+
+/**
+ * Do error checking and update state for glVertex/Color/TexCoord/...Pointer
+ * functions.
+ *
+ * \param func  name of calling function used for error reporting
+ * \param attrib  the attribute array index to update
+ * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
+ * \param sizeMin  min allowable size value
+ * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
+ * \param size  components per element (1, 2, 3 or 4)
+ * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
+ * \param stride  stride between elements, in elements
+ * \param normalized  are integer types converted to floats in [-1, 1]?
+ * \param integer  integer-valued values (will not be normalized to [-1,1])
+ * \param ptr  the address (or offset inside VBO) of the array data
+ */
+static void
+update_array(struct gl_context *ctx,
+             const char *func,
+             GLuint attrib, GLbitfield legalTypesMask,
+             GLint sizeMin, GLint sizeMax,
+             GLint size, GLenum type, GLsizei stride,
+             GLboolean normalized, GLboolean integer,
+             const GLvoid *ptr)
+{
+   struct gl_vertex_attrib_array *array;
+   GLsizei effectiveStride;
+
+   /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
+    *
+    *     "Client vertex arrays - all vertex array attribute pointers must
+    *     refer to buffer objects (section 2.9.2). The default vertex array
+    *     object (the name zero) is also deprecated. Calling
+    *     VertexAttribPointer when no buffer object or no vertex array object
+    *     is bound will generate an INVALID_OPERATION error..."
+    *
+    * The check for VBOs is handled below.
+    */
+   if (ctx->API == API_OPENGL_CORE
+       && (ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj)) {
+      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
+                  func);
+      return;
+   }
+
    if (stride < 0) {
       _mesa_error( ctx, GL_INVALID_VALUE, "%s(stride=%d)", func, stride );
       return;
@@ -268,24 +413,23 @@ update_array(struct gl_context *ctx,
       return;
    }
 
-   elementSize = _mesa_bytes_per_vertex_attrib(size, type);
-   assert(elementSize != -1);
+   if (!update_array_format(ctx, func, attrib, legalTypesMask, sizeMin,
+                            sizeMax, size, type, normalized, integer, 0)) {
+      return;
+   }
+
+   /* Reset the vertex attrib binding */
+   vertex_attrib_binding(ctx, attrib, attrib);
 
+   /* The Stride and Ptr fields are not set by update_array_format() */
    array = &ctx->Array.ArrayObj->VertexAttrib[attrib];
-   array->Size = size;
-   array->Type = type;
-   array->Format = format;
    array->Stride = stride;
-   array->StrideB = stride ? stride : elementSize;
-   array->Normalized = normalized;
-   array->Integer = integer;
-   array->Ptr = (const GLubyte *) ptr;
-   array->_ElementSize = elementSize;
+   array->Ptr = (const GLvoid *) ptr;
 
-   _mesa_reference_buffer_object(ctx, &array->BufferObj,
-                                 ctx->Array.ArrayBufferObj);
-
-   ctx->NewState |= _NEW_ARRAY;
+   /* Update the vertex buffer binding */
+   effectiveStride = stride != 0 ? stride : array->_ElementSize;
+   bind_vertex_buffer(ctx, attrib, ctx->Array.ArrayBufferObj,
+                      (GLintptr) ptr, effectiveStride);
 }
 
 
@@ -473,7 +617,8 @@ _mesa_VertexAttribPointer(GLuint index, GLint size, GLenum type,
                                   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
                                   FIXED_ES_BIT | FIXED_GL_BIT |
                                   UNSIGNED_INT_2_10_10_10_REV_BIT |
-                                  INT_2_10_10_10_REV_BIT);
+                                  INT_2_10_10_10_REV_BIT |
+                                  UNSIGNED_INT_10F_11F_11F_REV_BIT);
    GET_CURRENT_CONTEXT(ctx);
 
    if (index >= ctx->Const.VertexProgram.MaxAttribs) {
@@ -530,13 +675,14 @@ _mesa_EnableVertexAttribArray(GLuint index)
 
    arrayObj = ctx->Array.ArrayObj;
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
+   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->_VertexAttrib));
 
    if (!arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
       /* was disabled, now being enabled */
       FLUSH_VERTICES(ctx, _NEW_ARRAY);
       arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_TRUE;
       arrayObj->_Enabled |= VERT_BIT_GENERIC(index);
+      arrayObj->NewArrays |= VERT_BIT_GENERIC(index);
    }
 }
 
@@ -555,13 +701,14 @@ _mesa_DisableVertexAttribArray(GLuint index)
 
    arrayObj = ctx->Array.ArrayObj;
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
+   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->_VertexAttrib));
 
    if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled) {
       /* was enabled, now being disabled */
       FLUSH_VERTICES(ctx, _NEW_ARRAY);
       arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Enabled = GL_FALSE;
       arrayObj->_Enabled &= ~VERT_BIT_GENERIC(index);
+      arrayObj->NewArrays |= VERT_BIT_GENERIC(index);
    }
 }
 
@@ -575,16 +722,17 @@ static GLuint
 get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
                   const char *caller)
 {
-   const struct gl_client_array *array;
+   const struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+   const struct gl_vertex_attrib_array *array;
 
    if (index >= ctx->Const.VertexProgram.MaxAttribs) {
       _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)", caller, index);
       return 0;
    }
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
+   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(arrayObj->VertexAttrib));
 
-   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
+   array = &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
 
    switch (pname) {
    case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB:
@@ -598,7 +746,7 @@ get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
    case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB:
       return array->Normalized;
    case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
-      return array->BufferObj->Name;
+      return arrayObj->VertexBinding[array->VertexBinding].BufferObj->Name;
    case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
       if ((_mesa_is_desktop_gl(ctx)
            && (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4))
@@ -609,7 +757,17 @@ get_vertex_array_attrib(struct gl_context *ctx, GLuint index, GLenum pname,
    case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB:
       if ((_mesa_is_desktop_gl(ctx) && ctx->Extensions.ARB_instanced_arrays)
           || _mesa_is_gles3(ctx)) {
-         return array->InstanceDivisor;
+         return arrayObj->VertexBinding[array->VertexBinding].InstanceDivisor;
+      }
+      goto error;
+   case GL_VERTEX_ATTRIB_BINDING:
+      if (_mesa_is_desktop_gl(ctx)) {
+         return array->VertexBinding - VERT_ATTRIB_GENERIC0;
+      }
+      goto error;
+   case GL_VERTEX_ATTRIB_RELATIVE_OFFSET:
+      if (_mesa_is_desktop_gl(ctx)) {
+         return array->RelativeOffset;
       }
       goto error;
    default:
@@ -643,7 +801,7 @@ get_current_attrib(struct gl_context *ctx, GLuint index, const char *function)
       return NULL;
    }
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
+   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->_VertexAttrib));
 
    FLUSH_CURRENT(ctx, 0);
    return ctx->Current.Attrib[VERT_ATTRIB_GENERIC(index)];
@@ -765,7 +923,7 @@ _mesa_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
       return;
    }
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
+   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->_VertexAttrib));
 
    *pointer = (GLvoid *) ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
 }
@@ -1141,9 +1299,10 @@ _mesa_PrimitiveRestartIndex(GLuint index)
 void GLAPIENTRY
 _mesa_VertexAttribDivisor(GLuint index, GLuint divisor)
 {
-   struct gl_client_array *array;
    GET_CURRENT_CONTEXT(ctx);
 
+   const GLuint genericIndex = VERT_ATTRIB_GENERIC(index);
+
    if (!ctx->Extensions.ARB_instanced_arrays) {
       _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexAttribDivisor()");
       return;
@@ -1155,13 +1314,21 @@ _mesa_VertexAttribDivisor(GLuint index, GLuint divisor)
       return;
    }
 
-   ASSERT(VERT_ATTRIB_GENERIC(index) < Elements(ctx->Array.ArrayObj->VertexAttrib));
+   ASSERT(genericIndex < Elements(ctx->Array.ArrayObj->VertexAttrib));
 
-   array = &ctx->Array.ArrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(index)];
-   if (array->InstanceDivisor != divisor) {
-      FLUSH_VERTICES(ctx, _NEW_ARRAY);
-      array->InstanceDivisor = divisor;
-   }
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "The command
+    *
+    *       void VertexAttribDivisor(uint index, uint divisor);
+    *
+    *     is equivalent to (assuming no errors are generated):
+    *
+    *       VertexAttribBinding(index, index);
+    *       VertexBindingDivisor(index, divisor);"
+    */
+   vertex_attrib_binding(ctx, genericIndex, genericIndex);
+   vertex_binding_divisor(ctx, genericIndex, divisor);
 }
 
 
@@ -1191,6 +1358,329 @@ _mesa_primitive_restart_index(const struct gl_context *ctx, GLenum ib_type)
 
 
 /**
+ * GL_ARB_vertex_attrib_binding
+ */
+void GLAPIENTRY
+_mesa_BindVertexBuffer(GLuint bindingIndex, GLuint buffer, GLintptr offset,
+                       GLsizei stride)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   const struct gl_array_object *arrayObj = ctx->Array.ArrayObj;
+   struct gl_buffer_object *vbo;
+
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_OPERATION error is generated if no vertex array object
+    *     is bound."
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glBindVertexBuffer(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_VALUE error is generated if <bindingindex> is greater than
+    *     the value of MAX_VERTEX_ATTRIB_BINDINGS."
+    */
+   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glBindVertexBuffer(bindingindex=%u > "
+                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
+                  bindingIndex);
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "The error INVALID_VALUE is generated if <stride> or <offset>
+    *     are negative."
+    */
+   if (offset < 0) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glBindVertexBuffer(offset=%lld < 0)", (long long)offset);
+      return;
+   }
+
+   if (stride < 0) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glBindVertexBuffer(stride=%d < 0)", stride);
+      return;
+   }
+
+   if (buffer == arrayObj->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj->Name) {
+      vbo = arrayObj->VertexBinding[VERT_ATTRIB_GENERIC(bindingIndex)].BufferObj;
+   } else if (buffer != 0) {
+      vbo = _mesa_lookup_bufferobj(ctx, buffer);
+
+      /* From the GL_ARB_vertex_attrib_array spec:
+       *
+       *   "[Core profile only:]
+       *    An INVALID_OPERATION error is generated if buffer is not zero or a
+       *    name returned from a previous call to GenBuffers, or if such a name
+       *    has since been deleted with DeleteBuffers.
+       *
+       * Otherwise, we fall back to the same compat profile behavior as other
+       * object references (automatically gen it).
+       */
+      if (!_mesa_handle_bind_buffer_gen(ctx, GL_ARRAY_BUFFER, buffer,
+                                        &vbo, "glBindVertexBuffer"))
+         return;
+   } else {
+      /* The ARB_vertex_attrib_binding spec says:
+       *
+       *    "If <buffer> is zero, any buffer object attached to this
+       *     bindpoint is detached."
+       */
+      vbo = ctx->Shared->NullBufferObj;
+   }
+
+   bind_vertex_buffer(ctx, VERT_ATTRIB_GENERIC(bindingIndex),
+                      vbo, offset, stride);
+}
+
+
+void GLAPIENTRY
+_mesa_VertexAttribFormat(GLuint attribIndex, GLint size, GLenum type,
+                         GLboolean normalized, GLuint relativeOffset)
+{
+    const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
+                                   SHORT_BIT | UNSIGNED_SHORT_BIT |
+                                   INT_BIT | UNSIGNED_INT_BIT |
+                                   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
+                                   FIXED_GL_BIT |
+                                   UNSIGNED_INT_2_10_10_10_REV_BIT |
+                                   INT_2_10_10_10_REV_BIT |
+                                   UNSIGNED_INT_10F_11F_11F_REV_BIT);
+
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_OPERATION error is generated under any of the following
+    *     conditions:
+    *     - if no vertex array object is currently bound (see section 2.10);
+    *     - ..."
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glVertexAttribFormat(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *   "The error INVALID_VALUE is generated if index is greater than or equal
+    *     to the value of MAX_VERTEX_ATTRIBS."
+    */
+   if (attribIndex >= ctx->Const.VertexProgram.MaxAttribs) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexAttribFormat(attribindex=%u > "
+                  "GL_MAX_VERTEX_ATTRIBS)",
+                  attribIndex);
+      return;
+   }
+
+   FLUSH_VERTICES(ctx, 0);
+
+   update_array_format(ctx, "glVertexAttribFormat",
+                       VERT_ATTRIB_GENERIC(attribIndex),
+                       legalTypes, 1, BGRA_OR_4, size, type, normalized,
+                       GL_FALSE, relativeOffset);
+}
+
+
+void GLAPIENTRY
+_mesa_VertexAttribIFormat(GLuint attribIndex, GLint size, GLenum type,
+                          GLuint relativeOffset)
+{
+   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
+                                  SHORT_BIT | UNSIGNED_SHORT_BIT |
+                                  INT_BIT | UNSIGNED_INT_BIT);
+
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_OPERATION error is generated under any of the following
+    *     conditions:
+    *     - if no vertex array object is currently bound (see section 2.10);
+    *     - ..."
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glVertexAttribIFormat(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *   "The error INVALID_VALUE is generated if index is greater than
+    *    or equal to the value of MAX_VERTEX_ATTRIBS."
+    */
+   if (attribIndex >= ctx->Const.VertexProgram.MaxAttribs) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexAttribIFormat(attribindex=%u > "
+                  "GL_MAX_VERTEX_ATTRIBS)",
+                  attribIndex);
+      return;
+   }
+
+   FLUSH_VERTICES(ctx, 0);
+
+   update_array_format(ctx, "glVertexAttribIFormat",
+                       VERT_ATTRIB_GENERIC(attribIndex),
+                       legalTypes, 1, 4, size, type, GL_FALSE, GL_TRUE,
+                       relativeOffset);
+}
+
+
+void GLAPIENTRY
+_mesa_VertexAttribLFormat(GLuint attribIndex, GLint size, GLenum type,
+                          GLuint relativeOffset)
+{
+   const GLbitfield legalTypes = DOUBLE_BIT;
+
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
+    *
+    *    "An INVALID_OPERATION error is generated under any of the following
+    *     conditions:
+    *     • if no vertex array object is currently bound (see section 10.4);
+    *     • ..."
+    *
+    * This language is missing from the extension spec, but we assume
+    * that this is an oversight.
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glVertexAttribLFormat(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *   "The error INVALID_VALUE is generated if <attribindex> is greater than
+    *    or equal to the value of MAX_VERTEX_ATTRIBS."
+    */
+   if (attribIndex >= ctx->Const.VertexProgram.MaxAttribs) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexAttribLFormat(attribindex=%u > "
+                  "GL_MAX_VERTEX_ATTRIBS)",
+                  attribIndex);
+      return;
+   }
+
+   FLUSH_VERTICES(ctx, 0);
+
+   update_array_format(ctx, "glVertexAttribLFormat",
+                       VERT_ATTRIB_GENERIC(attribIndex),
+                       legalTypes, 1, 4, size, type, GL_FALSE, GL_FALSE,
+                       relativeOffset);
+}
+
+
+void GLAPIENTRY
+_mesa_VertexAttribBinding(GLuint attribIndex, GLuint bindingIndex)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_OPERATION error is generated if no vertex array object
+    *     is bound."
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glVertexAttribBinding(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "<attribindex> must be less than the value of MAX_VERTEX_ATTRIBS and
+    *     <bindingindex> must be less than the value of
+    *     MAX_VERTEX_ATTRIB_BINDINGS, otherwise the error INVALID_VALUE
+    *     is generated."
+    */
+   if (attribIndex >= ctx->Const.VertexProgram.MaxAttribs) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexAttribBinding(attribindex=%u >= "
+                  "GL_MAX_VERTEX_ATTRIBS)",
+                  attribIndex);
+      return;
+   }
+
+   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexAttribBinding(bindingindex=%u >= "
+                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
+                  bindingIndex);
+      return;
+   }
+
+   ASSERT(VERT_ATTRIB_GENERIC(attribIndex) <
+          Elements(ctx->Array.ArrayObj->VertexAttrib));
+
+   vertex_attrib_binding(ctx, VERT_ATTRIB_GENERIC(attribIndex),
+                         VERT_ATTRIB_GENERIC(bindingIndex));
+}
+
+
+void GLAPIENTRY
+_mesa_VertexBindingDivisor(GLuint bindingIndex, GLuint divisor)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   if (!ctx->Extensions.ARB_instanced_arrays) {
+      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexBindingDivisor()");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_OPERATION error is generated if no vertex array object
+    *     is bound."
+    */
+   if (ctx->API == API_OPENGL_CORE &&
+       ctx->Array.ArrayObj == ctx->Array.DefaultArrayObj) {
+      _mesa_error(ctx, GL_INVALID_OPERATION,
+                  "glVertexBindingDivisor(No array object bound)");
+      return;
+   }
+
+   /* The ARB_vertex_attrib_binding spec says:
+    *
+    *    "An INVALID_VALUE error is generated if <bindingindex> is greater
+    *     than or equal to the value of MAX_VERTEX_ATTRIB_BINDINGS."
+    */
+   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
+      _mesa_error(ctx, GL_INVALID_VALUE,
+                  "glVertexBindingDivisor(bindingindex=%u > "
+                  "GL_MAX_VERTEX_ATTRIB_BINDINGS)",
+                  bindingIndex);
+      return;
+   }
+
+   vertex_binding_divisor(ctx, VERT_ATTRIB_GENERIC(bindingIndex), divisor);
+}
+
+
+/**
  * Copy one client vertex array to another.
  */
 void
@@ -1213,7 +1703,36 @@ _mesa_copy_client_array(struct gl_context *ctx,
    dst->_MaxElement = src->_MaxElement;
 }
 
+void
+_mesa_copy_vertex_attrib_array(struct gl_context *ctx,
+                               struct gl_vertex_attrib_array *dst,
+                               const struct gl_vertex_attrib_array *src)
+{
+   dst->Size           = src->Size;
+   dst->Type           = src->Type;
+   dst->Format         = src->Format;
+   dst->VertexBinding  = src->VertexBinding;
+   dst->RelativeOffset = src->RelativeOffset;
+   dst->Format         = src->Format;
+   dst->Integer        = src->Integer;
+   dst->Normalized     = src->Normalized;
+   dst->Ptr            = src->Ptr;
+   dst->Enabled        = src->Enabled;
+   dst->_ElementSize   = src->_ElementSize;
+}
 
+void
+_mesa_copy_vertex_buffer_binding(struct gl_context *ctx,
+                                 struct gl_vertex_buffer_binding *dst,
+                                 const struct gl_vertex_buffer_binding *src)
+{
+   dst->Offset          = src->Offset;
+   dst->Stride          = src->Stride;
+   dst->InstanceDivisor = src->InstanceDivisor;
+   dst->_BoundArrays    = src->_BoundArrays;
+
+   _mesa_reference_buffer_object(ctx, &dst->BufferObj, src->BufferObj);
+}
 
 /**
  * Print vertex array's fields.
@@ -1245,18 +1764,18 @@ _mesa_print_arrays(struct gl_context *ctx)
    _mesa_update_array_object_max_element(ctx, arrayObj);
 
    printf("Array Object %u\n", arrayObj->Name);
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_POS].Enabled)
-      print_array("Vertex", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_POS]);
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
-      print_array("Normal", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_NORMAL]);
-   if (arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
-      print_array("Color", -1, &arrayObj->VertexAttrib[VERT_ATTRIB_COLOR0]);
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_POS].Enabled)
+      print_array("Vertex", -1, &arrayObj->_VertexAttrib[VERT_ATTRIB_POS]);
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_NORMAL].Enabled)
+      print_array("Normal", -1, &arrayObj->_VertexAttrib[VERT_ATTRIB_NORMAL]);
+   if (arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR0].Enabled)
+      print_array("Color", -1, &arrayObj->_VertexAttrib[VERT_ATTRIB_COLOR0]);
    for (i = 0; i < ctx->Const.MaxTextureCoordUnits; i++)
-      if (arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
-         print_array("TexCoord", i, &arrayObj->VertexAttrib[VERT_ATTRIB_TEX(i)]);
+      if (arrayObj->_VertexAttrib[VERT_ATTRIB_TEX(i)].Enabled)
+         print_array("TexCoord", i, &arrayObj->_VertexAttrib[VERT_ATTRIB_TEX(i)]);
    for (i = 0; i < VERT_ATTRIB_GENERIC_MAX; i++)
-      if (arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
-         print_array("Attrib", i, &arrayObj->VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
+      if (arrayObj->_VertexAttrib[VERT_ATTRIB_GENERIC(i)].Enabled)
+         print_array("Attrib", i, &arrayObj->_VertexAttrib[VERT_ATTRIB_GENERIC(i)]);
    printf("  _MaxElement = %u\n", arrayObj->_MaxElement);
 }
 
diff --git a/src/mesa/main/varray.h b/src/mesa/main/varray.h
index 7e611e8..bc820ed 100644
--- a/src/mesa/main/varray.h
+++ b/src/mesa/main/varray.h
@@ -29,6 +29,7 @@
 
 
 #include "glheader.h"
+#include "bufferobj.h"
 
 struct gl_client_array;
 struct gl_context;
@@ -50,8 +51,10 @@ _mesa_update_array_max_element(struct gl_client_array *array)
       GLsizeiptrARB bufSize = (GLsizeiptrARB) array->BufferObj->Size;
 
       if (offset < bufSize) {
-	 array->_MaxElement = (bufSize - offset + array->StrideB
-                               - array->_ElementSize) / array->StrideB;
+         const GLuint stride = array->StrideB ?
+                                 array->StrideB : array->_ElementSize;
+         array->_MaxElement = (bufSize - offset + stride
+                                  - array->_ElementSize) / stride;
       }
       else {
 	 array->_MaxElement = 0;
@@ -64,15 +67,48 @@ _mesa_update_array_max_element(struct gl_client_array *array)
 }
 
 
-extern void GLAPIENTRY
-_mesa_VertexPointer(GLint size, GLenum type, GLsizei stride,
-                    const GLvoid *ptr);
+/**
+ * Returns a pointer to the vertex attribute data in a client array,
+ * or the offset into the vertex buffer for an array that resides in
+ * a vertex buffer.
+ */
+static inline const GLubyte *
+_mesa_vertex_attrib_address(const struct gl_vertex_attrib_array *array,
+                            const struct gl_vertex_buffer_binding *binding)
+{
+   if (_mesa_is_bufferobj(binding->BufferObj))
+      return (const GLubyte *) (binding->Offset + array->RelativeOffset);
+   else
+      return array->Ptr;       
+}
 
-extern void GLAPIENTRY
-_mesa_UnlockArraysEXT( void );
+/**
+ * Sets the fields in a gl_client_array to values derived from a
+ * gl_vertex_attrib_array and a gl_vertex_buffer_binding.
+ */
+static inline void
+_mesa_update_client_array(struct gl_context *ctx,
+                          struct gl_client_array *dst,
+                          const struct gl_vertex_attrib_array *src,
+                          const struct gl_vertex_buffer_binding *binding)
+{
+   dst->Size = src->Size;
+   dst->Type = src->Type;
+   dst->Format = src->Format;
+   dst->Stride = src->Stride;
+   dst->StrideB = binding->Stride;
+   dst->Ptr = _mesa_vertex_attrib_address(src, binding);
+   dst->Enabled = src->Enabled;
+   dst->Normalized = src->Normalized;
+   dst->Integer = src->Integer;
+   dst->InstanceDivisor = binding->InstanceDivisor;
+   dst->_ElementSize = src->_ElementSize;
+   _mesa_reference_buffer_object(ctx, &dst->BufferObj, binding->BufferObj);
+}
 
 extern void GLAPIENTRY
-_mesa_LockArraysEXT(GLint first, GLsizei count);
+_mesa_VertexPointer(GLint size, GLenum type, GLsizei stride,
+                    const GLvoid *ptr);
 
 
 extern void GLAPIENTRY
@@ -250,11 +286,43 @@ _mesa_VertexAttribDivisor(GLuint index, GLuint divisor);
 extern unsigned
 _mesa_primitive_restart_index(const struct gl_context *ctx, GLenum ib_type);
 
+extern void GLAPIENTRY
+_mesa_BindVertexBuffer(GLuint bindingIndex, GLuint buffer, GLintptr offset,
+                       GLsizei stride);
+
+extern void GLAPIENTRY
+_mesa_VertexAttribFormat(GLuint attribIndex, GLint size, GLenum type,
+                         GLboolean normalized, GLuint relativeOffset);
+
+extern void GLAPIENTRY
+_mesa_VertexAttribIFormat(GLuint attribIndex, GLint size, GLenum type,
+                          GLuint relativeOffset);
+
+extern void GLAPIENTRY
+_mesa_VertexAttribLFormat(GLuint attribIndex, GLint size, GLenum type,
+                          GLuint relativeOffset);
+
+extern void GLAPIENTRY
+_mesa_VertexAttribBinding(GLuint attribIndex, GLuint bindingIndex);
+
+extern void GLAPIENTRY
+_mesa_VertexBindingDivisor(GLuint bindingIndex, GLuint divisor);
+
+
 extern void
 _mesa_copy_client_array(struct gl_context *ctx,
                         struct gl_client_array *dst,
                         struct gl_client_array *src);
 
+extern void
+_mesa_copy_vertex_attrib_array(struct gl_context *ctx,
+                               struct gl_vertex_attrib_array *dst,
+                               const struct gl_vertex_attrib_array *src);
+
+extern void
+_mesa_copy_vertex_buffer_binding(struct gl_context *ctx,
+                                 struct gl_vertex_buffer_binding *dst,
+                                 const struct gl_vertex_buffer_binding *src);
 
 extern void
 _mesa_print_arrays(struct gl_context *ctx);
diff --git a/src/mesa/math/m_clip_tmp.h b/src/mesa/math/m_clip_tmp.h
index 5cfcf91..45dec47 100644
--- a/src/mesa/math/m_clip_tmp.h
+++ b/src/mesa/math/m_clip_tmp.h
@@ -60,7 +60,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_points4)( GLvector4f *clip_vec,
       const GLfloat cy = from[1];
       const GLfloat cz = from[2];
       const GLfloat cw = from[3];
-#if defined(macintosh) || defined(__powerpc__)
+#if defined(__powerpc__)
       /* on powerpc cliptest is 17% faster in this way. */
       GLuint mask;
       mask = (((cw < cx) << CLIP_RIGHT_SHIFT));
@@ -71,7 +71,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_points4)( GLvector4f *clip_vec,
 	 mask |= (((cw < cz) << CLIP_FAR_SHIFT));
 	 mask |= (((cw < -cz) << CLIP_NEAR_SHIFT));
       }
-#else /* !defined(macintosh)) */
+#else
       GLubyte mask = 0;
       if (-cx + cw < 0) mask |= CLIP_RIGHT_BIT;
       if ( cx + cw < 0) mask |= CLIP_LEFT_BIT;
@@ -81,7 +81,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_points4)( GLvector4f *clip_vec,
 	 if (-cz + cw < 0) mask |= CLIP_FAR_BIT;
 	 if ( cz + cw < 0) mask |= CLIP_NEAR_BIT;
       }
-#endif /* defined(macintosh) */
+#endif
 
       clipMask[i] = mask;
       if (mask) {
@@ -140,7 +140,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_np_points4)( GLvector4f *clip_vec,
       const GLfloat cy = from[1];
       const GLfloat cz = from[2];
       const GLfloat cw = from[3];
-#if defined(macintosh) || defined(__powerpc__)
+#if defined(__powerpc__)
       /* on powerpc cliptest is 17% faster in this way. */
       GLuint mask;
       mask = (((cw < cx) << CLIP_RIGHT_SHIFT));
@@ -151,7 +151,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_np_points4)( GLvector4f *clip_vec,
 	 mask |= (((cw < cz) << CLIP_FAR_SHIFT));
 	 mask |= (((cw < -cz) << CLIP_NEAR_SHIFT));
       }
-#else /* !defined(macintosh)) */
+#else
       GLubyte mask = 0;
       if (-cx + cw < 0) mask |= CLIP_RIGHT_BIT;
       if ( cx + cw < 0) mask |= CLIP_LEFT_BIT;
@@ -161,7 +161,7 @@ static GLvector4f * _XFORMAPI TAG(cliptest_np_points4)( GLvector4f *clip_vec,
 	 if (-cz + cw < 0) mask |= CLIP_FAR_BIT;
 	 if ( cz + cw < 0) mask |= CLIP_NEAR_BIT;
       }
-#endif /* defined(macintosh) */
+#endif
 
       clipMask[i] = mask;
       if (mask) {
diff --git a/src/mesa/math/m_debug_util.h b/src/mesa/math/m_debug_util.h
index d526e96..d05da89 100644
--- a/src/mesa/math/m_debug_util.h
+++ b/src/mesa/math/m_debug_util.h
@@ -305,8 +305,6 @@ enum { NIL = 0, ONE = 1, NEG = -1, VAR = 2 };
 #  define ALIGN16(type, array)	type array __attribute__ ((aligned (16)))
 #elif defined(_MSC_VER)
 #  define ALIGN16(type, array)	type array __declspec(align(16)) /* GH: Does this work? */
-#elif defined(__WATCOMC__)
-#  define ALIGN16(type, array)	                    /* Watcom does not support this */ 
 #elif defined(__xlC__)
 #  define ALIGN16(type, array)       type __align (16) array 
 #else
diff --git a/src/mesa/program/Android.mk b/src/mesa/program/Android.mk
index 29a1b6a..e85afe6 100644
--- a/src/mesa/program/Android.mk
+++ b/src/mesa/program/Android.mk
@@ -47,8 +47,6 @@ LOCAL_MODULE_CLASS := STATIC_LIBRARIES
 
 intermediates := $(call local-intermediates-dir)
 
-MESA_ENABLED_APIS := ES1 ES2
-
 # TODO(chadv): In Makefile.sources, move these vars to a different list so we can
 # remove this kludge.
 generated_sources_basenames := \
diff --git a/src/mesa/program/Makefile.am b/src/mesa/program/Makefile.am
deleted file mode 100644
index 5e05782..0000000
--- a/src/mesa/program/Makefile.am
+++ /dev/null
@@ -1,45 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-include ../Makefile.sources
-
-AM_CPPFLAGS = $(DEFINES) $(INCLUDE_DIRS)
-AM_CFLAGS = $(VISIBILITY_CFLAGS)
-AM_CXXFLAGS = $(VISIBILITY_CXXFLAGS)
-
-SRCDIR = $(top_srcdir)/src/mesa/
-BUILDDIR = $(top_builddir)/src/mesa/
-
-noinst_LTLIBRARIES = libprogram.la
-
-libprogram_la_SOURCES = $(PROGRAM_FILES)
-
-lex.yy.c: program_lexer.l
-	$(AM_V_GEN) $(LEX) --never-interactive --outfile=$@ $<
-
-program_parse.tab.c program_parse.tab.h: program_parse.y
-	$(AM_V_GEN) $(YACC) -p "_mesa_program_" -v -d --output=program_parse.tab.c $<
-
-BUILT_SOURCES = \
-	program_parse.tab.c \
-	program_parse.tab.h \
-	lex.yy.c
-CLEANFILES = $(BUILT_SOURCES)
diff --git a/src/mesa/program/prog_execute.c b/src/mesa/program/prog_execute.c
index 560332a..115525e 100644
--- a/src/mesa/program/prog_execute.c
+++ b/src/mesa/program/prog_execute.c
@@ -118,16 +118,6 @@ get_src_register_pointer(const struct prog_src_register *source,
          return ZeroVec;
       return machine->Outputs[reg];
 
-   case PROGRAM_LOCAL_PARAM:
-      if (reg >= MAX_PROGRAM_LOCAL_PARAMS)
-         return ZeroVec;
-      return machine->CurProgram->LocalParams[reg];
-
-   case PROGRAM_ENV_PARAM:
-      if (reg >= MAX_PROGRAM_ENV_PARAMS)
-         return ZeroVec;
-      return machine->EnvParams[reg];
-
    case PROGRAM_STATE_VAR:
       /* Fallthrough */
    case PROGRAM_CONSTANT:
diff --git a/src/mesa/program/prog_print.c b/src/mesa/program/prog_print.c
index fa9063f..fa120cc 100644
--- a/src/mesa/program/prog_print.c
+++ b/src/mesa/program/prog_print.c
@@ -50,10 +50,6 @@ _mesa_register_file_name(gl_register_file f)
    switch (f) {
    case PROGRAM_TEMPORARY:
       return "TEMP";
-   case PROGRAM_LOCAL_PARAM:
-      return "LOCAL";
-   case PROGRAM_ENV_PARAM:
-      return "ENV";
    case PROGRAM_STATE_VAR:
       return "STATE";
    case PROGRAM_INPUT:
@@ -382,12 +378,6 @@ reg_string(gl_register_file f, GLint index, gl_prog_print_mode mode,
       case PROGRAM_TEMPORARY:
          sprintf(str, "temp%d", index);
          break;
-      case PROGRAM_ENV_PARAM:
-         sprintf(str, "program.env[%s%d]", addr, index);
-         break;
-      case PROGRAM_LOCAL_PARAM:
-         sprintf(str, "program.local[%s%d]", addr, index);
-         break;
       case PROGRAM_CONSTANT: /* extension */
          sprintf(str, "constant[%s%d]", addr, index);
          break;
diff --git a/src/mesa/program/program.c b/src/mesa/program/program.c
index a102ec1..01f8c6f 100644
--- a/src/mesa/program/program.c
+++ b/src/mesa/program/program.c
@@ -349,6 +349,7 @@ _mesa_delete_program(struct gl_context *ctx, struct gl_program *prog)
       return;
 
    free(prog->String);
+   free(prog->LocalParams);
 
    if (prog->Instructions) {
       _mesa_free_instructions(prog->Instructions, prog->NumInstructions);
@@ -477,7 +478,16 @@ _mesa_clone_program(struct gl_context *ctx, const struct gl_program *prog)
 
    if (prog->Parameters)
       clone->Parameters = _mesa_clone_parameter_list(prog->Parameters);
-   memcpy(clone->LocalParams, prog->LocalParams, sizeof(clone->LocalParams));
+   if (prog->LocalParams) {
+      clone->LocalParams = malloc(MAX_PROGRAM_LOCAL_PARAMS *
+                                  sizeof(float[4]));
+      if (!clone->LocalParams) {
+         _mesa_reference_program(ctx, &clone, NULL);
+         return NULL;
+      }
+      memcpy(clone->LocalParams, prog->LocalParams,
+             MAX_PROGRAM_LOCAL_PARAMS * sizeof(float[4]));
+   }
    clone->IndirectRegisterFiles = prog->IndirectRegisterFiles;
    clone->NumInstructions = prog->NumInstructions;
    clone->NumTemporaries = prog->NumTemporaries;
@@ -909,12 +919,6 @@ _mesa_valid_register_index(const struct gl_context *ctx,
    case PROGRAM_TEMPORARY:
       return index >= 0 && index < (GLint) c->MaxTemps;
 
-   case PROGRAM_ENV_PARAM:
-      return index >= 0 && index < (GLint) c->MaxEnvParams;
-
-   case PROGRAM_LOCAL_PARAM:
-      return index >= 0 && index < (GLint) c->MaxLocalParams;
-
    case PROGRAM_UNIFORM:
    case PROGRAM_STATE_VAR:
       /* aka constant buffer */
diff --git a/src/mesa/program/program_parse.y b/src/mesa/program/program_parse.y
index a76db4e..03c0a3d 100644
--- a/src/mesa/program/program_parse.y
+++ b/src/mesa/program/program_parse.y
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "main/macros.h"
 #include "main/mtypes.h"
 #include "main/imports.h"
 #include "program/program.h"
@@ -2559,6 +2560,12 @@ initialize_symbol_from_param(struct gl_program *prog,
    param_var->type = at_param;
    param_var->param_binding_type = PROGRAM_STATE_VAR;
 
+   /* Dynamically allocate LocalParams, since it's a large array to have
+    * statically in every gl_program otherwise.
+    */
+   if (state_tokens[1] == STATE_LOCAL && !prog->LocalParams)
+      prog->LocalParams = calloc(MAX_PROGRAM_LOCAL_PARAMS, sizeof(float[4]));
+
    /* If we are adding a STATE_ENV or STATE_LOCAL that has multiple elements,
     * we need to unroll it and call add_state_reference() for each row
     */
diff --git a/src/mesa/program/program_parser.h b/src/mesa/program/program_parser.h
index ca36bb6..04c64f4 100644
--- a/src/mesa/program/program_parser.h
+++ b/src/mesa/program/program_parser.h
@@ -44,7 +44,7 @@ struct asm_symbol {
    unsigned output_binding;   /**< Output / result register number. */
 
    /**
-    * One of PROGRAM_STATE_VAR, PROGRAM_LOCAL_PARAM, or PROGRAM_ENV_PARAM.
+    * One of PROGRAM_STATE_VAR or PROGRAM_CONSTANT.
     */
    unsigned param_binding_type;
 
diff --git a/src/mesa/state_tracker/st_atom_array.c b/src/mesa/state_tracker/st_atom_array.c
index 87a0a17..76a94bc 100644
--- a/src/mesa/state_tracker/st_atom_array.c
+++ b/src/mesa/state_tracker/st_atom_array.c
@@ -214,7 +214,8 @@ st_pipe_vertex_format(GLenum type, GLuint size, GLenum format,
    assert((type >= GL_BYTE && type <= GL_DOUBLE) ||
           type == GL_FIXED || type == GL_HALF_FLOAT ||
           type == GL_INT_2_10_10_10_REV ||
-          type == GL_UNSIGNED_INT_2_10_10_10_REV);
+          type == GL_UNSIGNED_INT_2_10_10_10_REV ||
+          type == GL_UNSIGNED_INT_10F_11F_11F_REV);
    assert(size >= 1);
    assert(size <= 4);
    assert(format == GL_RGBA || format == GL_BGRA);
@@ -251,6 +252,14 @@ st_pipe_vertex_format(GLenum type, GLuint size, GLenum format,
       }
    }
 
+   if (type == GL_UNSIGNED_INT_10F_11F_11F_REV) {
+      assert(size == 3);
+      assert(!integer);
+      assert(format == GL_RGBA);
+
+      return PIPE_FORMAT_R11G11B10_FLOAT;
+   }
+
    if (format == GL_BGRA) {
       /* this is an odd-ball case */
       assert(type == GL_UNSIGNED_BYTE);
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 97c5d55..e8d0902 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -507,6 +507,8 @@ void st_init_extensions(struct st_context *st)
           PIPE_FORMAT_B10G10R10A2_USCALED,
           PIPE_FORMAT_R10G10B10A2_SSCALED,
           PIPE_FORMAT_B10G10R10A2_SSCALED } },
+      { { o(ARB_vertex_type_10f_11f_11f_rev) },
+        { PIPE_FORMAT_R11G11B10_FLOAT } },
    };
 
    static const struct st_extension_format_mapping tbo_rgb32[] = {
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
index 0eaf746..6319079 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
@@ -70,9 +70,7 @@ extern "C" {
 }
 
 #define PROGRAM_IMMEDIATE PROGRAM_FILE_MAX
-#define PROGRAM_ANY_CONST ((1 << PROGRAM_LOCAL_PARAM) |  \
-                           (1 << PROGRAM_ENV_PARAM) |    \
-                           (1 << PROGRAM_STATE_VAR) |    \
+#define PROGRAM_ANY_CONST ((1 << PROGRAM_STATE_VAR) |    \
                            (1 << PROGRAM_CONSTANT) |     \
                            (1 << PROGRAM_UNIFORM))
 
@@ -565,8 +563,6 @@ glsl_to_tgsi_visitor::emit(ir_instruction *ir, unsigned op,
    /* Update indirect addressing status used by TGSI */
    if (dst.reladdr) {
       switch(dst.file) {
-      case PROGRAM_LOCAL_PARAM:
-      case PROGRAM_ENV_PARAM:
       case PROGRAM_STATE_VAR:
       case PROGRAM_CONSTANT:
       case PROGRAM_UNIFORM:
@@ -583,8 +579,6 @@ glsl_to_tgsi_visitor::emit(ir_instruction *ir, unsigned op,
       for (i=0; i<3; i++) {
          if(inst->src[i].reladdr) {
             switch(inst->src[i].file) {
-            case PROGRAM_LOCAL_PARAM:
-            case PROGRAM_ENV_PARAM:
             case PROGRAM_STATE_VAR:
             case PROGRAM_CONSTANT:
             case PROGRAM_UNIFORM:
@@ -4311,8 +4305,6 @@ src_register(struct st_translate *t,
    case PROGRAM_ARRAY:
       return ureg_src(dst_register(t, file, index));
 
-   case PROGRAM_ENV_PARAM:
-   case PROGRAM_LOCAL_PARAM:
    case PROGRAM_UNIFORM:
       assert(index >= 0);
       return t->constants[index];
@@ -4962,8 +4954,6 @@ st_translate_program(
 
       for (i = 0; i < proginfo->Parameters->NumParameters; i++) {
          switch (proginfo->Parameters->Parameters[i].Type) {
-         case PROGRAM_ENV_PARAM:
-         case PROGRAM_LOCAL_PARAM:
          case PROGRAM_STATE_VAR:
          case PROGRAM_UNIFORM:
             t->constants[i] = ureg_DECL_constant(ureg, i);
diff --git a/src/mesa/state_tracker/st_mesa_to_tgsi.c b/src/mesa/state_tracker/st_mesa_to_tgsi.c
index 1bbeced..921b0f9 100644
--- a/src/mesa/state_tracker/st_mesa_to_tgsi.c
+++ b/src/mesa/state_tracker/st_mesa_to_tgsi.c
@@ -46,9 +46,7 @@
 #include "util/u_memory.h"
 
 
-#define PROGRAM_ANY_CONST ((1 << PROGRAM_LOCAL_PARAM) |  \
-                           (1 << PROGRAM_ENV_PARAM) |    \
-                           (1 << PROGRAM_STATE_VAR) |    \
+#define PROGRAM_ANY_CONST ((1 << PROGRAM_STATE_VAR) |    \
                            (1 << PROGRAM_CONSTANT) |     \
                            (1 << PROGRAM_UNIFORM))
 
@@ -214,8 +212,6 @@ src_register( struct st_translate *t,
          t->temps[index] = ureg_DECL_temporary( t->ureg );
       return ureg_src(t->temps[index]);
 
-   case PROGRAM_ENV_PARAM:
-   case PROGRAM_LOCAL_PARAM:
    case PROGRAM_UNIFORM:
       assert(index >= 0);
       return t->constants[index];
@@ -1195,8 +1191,6 @@ st_translate_mesa_program(
 
       for (i = 0; i < program->Parameters->NumParameters; i++) {
          switch (program->Parameters->Parameters[i].Type) {
-         case PROGRAM_ENV_PARAM:
-         case PROGRAM_LOCAL_PARAM:
          case PROGRAM_STATE_VAR:
          case PROGRAM_UNIFORM:
             t->constants[i] = ureg_DECL_constant( ureg, i );
diff --git a/src/mesa/vbo/vbo_attrib_tmp.h b/src/mesa/vbo/vbo_attrib_tmp.h
index bbc0205..358d12d 100644
--- a/src/mesa/vbo/vbo_attrib_tmp.h
+++ b/src/mesa/vbo/vbo_attrib_tmp.h
@@ -25,6 +25,8 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 **************************************************************************/
 
+#include "util/u_format_r11g11b10f.h"
+
 /* float */
 #define ATTR1FV( A, V ) ATTR( A, 1, GL_FLOAT, (V)[0], 0, 0, 1 )
 #define ATTR2FV( A, V ) ATTR( A, 2, GL_FLOAT, (V)[0], (V)[1], 0, 1 )
@@ -205,6 +207,10 @@ static inline float conv_i2_to_norm_float(const struct gl_context *ctx, int i2)
       } else {							\
 	 ATTRI10_##val((attr), (arg));				\
       }								\
+   } else if ((type) == GL_UNSIGNED_INT_10F_11F_11F_REV) {	\
+      float res[4];						\
+      r11g11b10f_to_float3((arg), res);				\
+      ATTR##val##FV((attr), res);				\
    } else							\
       ERROR(GL_INVALID_VALUE);					\
    } while(0)
@@ -835,12 +841,26 @@ TAG(VertexAttrib4fvNV)(GLuint index, const GLfloat * v)
       ATTR4FV(index, v);
 }
 
+
 #define ERROR_IF_NOT_PACKED_TYPE(ctx, type, func) \
    if (type != GL_INT_2_10_10_10_REV && type != GL_UNSIGNED_INT_2_10_10_10_REV) { \
       _mesa_error(ctx, GL_INVALID_ENUM, "%s(type)", func); \
       return; \
    }
 
+/* Extended version of ERROR_IF_NOT_PACKED_TYPE which also
+ * accepts GL_UNSIGNED_INT_10F_11F_11F_REV.
+ *
+ * Only used for VertexAttribP[123]ui[v]; VertexAttribP4* cannot use this type,
+ * and neither can legacy vertex attribs.
+ */
+#define ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, func) \
+   if (type != GL_INT_2_10_10_10_REV && type != GL_UNSIGNED_INT_2_10_10_10_REV && \
+       type != GL_UNSIGNED_INT_10F_11F_11F_REV) { \
+      _mesa_error(ctx, GL_INVALID_ENUM, "%s(type)", func); \
+      return; \
+   }
+
 static void GLAPIENTRY
 TAG(VertexP2ui)(GLenum type, GLuint value)
 {
@@ -1094,7 +1114,7 @@ TAG(VertexAttribP1ui)(GLuint index, GLenum type, GLboolean normalized,
 		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP1ui");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP1ui");
    ATTR_UI_INDEX(ctx, 1, type, normalized, index, value);
 }
 
@@ -1103,7 +1123,7 @@ TAG(VertexAttribP2ui)(GLuint index, GLenum type, GLboolean normalized,
 		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP2ui");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP2ui");
    ATTR_UI_INDEX(ctx, 2, type, normalized, index, value);
 }
 
@@ -1112,7 +1132,7 @@ TAG(VertexAttribP3ui)(GLuint index, GLenum type, GLboolean normalized,
 		      GLuint value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP3ui");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP3ui");
    ATTR_UI_INDEX(ctx, 3, type, normalized, index, value);
 }
 
@@ -1130,7 +1150,7 @@ TAG(VertexAttribP1uiv)(GLuint index, GLenum type, GLboolean normalized,
 		       const GLuint *value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP1uiv");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP1uiv");
    ATTR_UI_INDEX(ctx, 1, type, normalized, index, *value);
 }
 
@@ -1139,7 +1159,7 @@ TAG(VertexAttribP2uiv)(GLuint index, GLenum type, GLboolean normalized,
 		       const GLuint *value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP2uiv");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP2uiv");
    ATTR_UI_INDEX(ctx, 2, type, normalized, index, *value);
 }
 
@@ -1148,7 +1168,7 @@ TAG(VertexAttribP3uiv)(GLuint index, GLenum type, GLboolean normalized,
 		       const GLuint *value)
 {
    GET_CURRENT_CONTEXT(ctx);
-   ERROR_IF_NOT_PACKED_TYPE(ctx, type, "glVertexAttribP3uiv");
+   ERROR_IF_NOT_PACKED_TYPE_EXT(ctx, type, "glVertexAttribP3uiv");
    ATTR_UI_INDEX(ctx, 3, type, normalized, index, *value);
 }
 
diff --git a/src/mesa/vbo/vbo_exec_array.c b/src/mesa/vbo/vbo_exec_array.c
index f25a9de..d723823 100644
--- a/src/mesa/vbo/vbo_exec_array.c
+++ b/src/mesa/vbo/vbo_exec_array.c
@@ -318,8 +318,8 @@ check_draw_elements_data(struct gl_context *ctx, GLsizei count, GLenum elemType,
       }
 
       /* check element j of each enabled array */
-      for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
-         check_array_data(ctx, &arrayObj->VertexAttrib[k], k, j);
+      for (k = 0; k < Elements(arrayObj->_VertexAttrib); k++) {
+         check_array_data(ctx, &arrayObj->_VertexAttrib[k], k, j);
       }
    }
 
@@ -327,8 +327,8 @@ check_draw_elements_data(struct gl_context *ctx, GLsizei count, GLenum elemType,
       ctx->Driver.UnmapBuffer(ctx, ctx->Array.ArrayObj->ElementArrayBufferObj);
    }
 
-   for (k = 0; k < Elements(arrayObj->VertexAttrib); k++) {
-      unmap_array_buffer(ctx, &arrayObj->VertexAttrib[k]);
+   for (k = 0; k < Elements(arrayObj->_VertexAttrib); k++) {
+      unmap_array_buffer(ctx, &arrayObj->_VertexAttrib[k]);
    }
 }
 
@@ -368,7 +368,7 @@ print_draw_arrays(struct gl_context *ctx,
 	     exec->array.inputs[i]->Size,
 	     stride,
 	     /*exec->array.inputs[i]->Enabled,*/
-	     arrayObj->VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
+	     arrayObj->_VertexAttrib[VERT_ATTRIB_FF(i)].Enabled,
 	     exec->array.inputs[i]->Ptr,
 	     bufName);
 
@@ -405,7 +405,7 @@ recalculate_input_bindings(struct gl_context *ctx)
 {
    struct vbo_context *vbo = vbo_context(ctx);
    struct vbo_exec_context *exec = &vbo->exec;
-   struct gl_client_array *vertexAttrib = ctx->Array.ArrayObj->VertexAttrib;
+   struct gl_client_array *vertexAttrib = ctx->Array.ArrayObj->_VertexAttrib;
    const struct gl_client_array **inputs = &exec->array.inputs[0];
    GLbitfield64 const_inputs = 0x0;
    GLuint i;
diff --git a/src/mesa/x86-64/.gitignore b/src/mesa/x86-64/.gitignore
deleted file mode 100644
index ca3130d..0000000
--- a/src/mesa/x86-64/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-gen_matypes
-matypes.h
diff --git a/src/mesa/x86-64/Makefile.am b/src/mesa/x86-64/Makefile.am
deleted file mode 100644
index b62387d..0000000
--- a/src/mesa/x86-64/Makefile.am
+++ /dev/null
@@ -1,49 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-if HAVE_X86_64_ASM
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	$(DEFINES)
-
-noinst_PROGRAMS = gen_matypes
-
-gen_matypes_SOURCES = ../x86/gen_matypes.c
-BUILT_SOURCES = matypes.h
-CLEANFILES = matypes.h
-
-if GEN_ASM_OFFSETS
-
-matypes.h: $(gen_matypes_SOURCES)
-	$(AM_V_GEN)$(COMPILE) $< -DASM_OFFSETS -S -o - | \
-		sed -n '/^->/{s:^->::;/[$$]/{s:^:#define :;s:[$$]::};p}' > $@
-
-else
-
-matypes.h: gen_matypes
-	$(AM_V_GEN)./gen_matypes > $@
-
-endif
-
-endif
diff --git a/src/mesa/x86/.gitignore b/src/mesa/x86/.gitignore
deleted file mode 100644
index ca3130d..0000000
--- a/src/mesa/x86/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-gen_matypes
-matypes.h
diff --git a/src/mesa/x86/Makefile.am b/src/mesa/x86/Makefile.am
deleted file mode 100644
index 1678576..0000000
--- a/src/mesa/x86/Makefile.am
+++ /dev/null
@@ -1,49 +0,0 @@
-# Copyright © 2012 Intel Corporation
-#
-# Permission is hereby granted, free of charge, to any person obtaining a
-# copy of this software and associated documentation files (the "Software"),
-# to deal in the Software without restriction, including without limitation
-# the rights to use, copy, modify, merge, publish, distribute, sublicense,
-# and/or sell copies of the Software, and to permit persons to whom the
-# Software is furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice (including the next
-# paragraph) shall be included in all copies or substantial portions of the
-# Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-# IN THE SOFTWARE.
-
-if HAVE_X86_ASM
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/src/mesa \
-	-I$(top_srcdir)/src/mapi \
-	$(DEFINES)
-
-noinst_PROGRAMS = gen_matypes
-
-gen_matypes_SOURCES = gen_matypes.c
-BUILT_SOURCES = matypes.h
-CLEANFILES = matypes.h
-
-if GEN_ASM_OFFSETS
-
-matypes.h: $(gen_matypes_SOURCES)
-	$(AM_V_GEN)$(COMPILE) $< -DASM_OFFSETS -S -o - | \
-		sed -n '/^->/{s:^->::;/[$$]/{s:^:#define :;s:[$$]::};p}' > $@
-
-else
-
-matypes.h: gen_matypes
-	$(AM_V_GEN)./gen_matypes > $@
-
-endif
-
-endif
diff --git a/src/mesa/x86/assyntax.h b/src/mesa/x86/assyntax.h
index 4a41812..fa7d92e 100644
--- a/src/mesa/x86/assyntax.h
+++ b/src/mesa/x86/assyntax.h
@@ -920,17 +920,9 @@
 #define D_BYTE		db
 /* #define SPACE */
 /* #define COMM */
-#if defined(__WATCOMC__)
-SECTION _TEXT public align=16 class=CODE use32 flat
-SECTION _DATA public align=16 class=DATA use32 flat
-#define SEG_TEXT	SECTION _TEXT
-#define SEG_DATA	SECTION _DATA
-#define SEG_BSS		SECTION .bss
-#else
 #define SEG_DATA	SECTION .data
 #define SEG_TEXT	SECTION .text
 #define SEG_BSS		SECTION .bss
-#endif
 
 #define D_SPACE(n)	db n REP 0
 
