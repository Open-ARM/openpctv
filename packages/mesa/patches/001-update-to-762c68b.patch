diff --git a/configure.ac b/configure.ac
index 0ed9325..03f1bca 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1465,6 +1465,7 @@ AC_ARG_WITH([clang-libdir],
    [CLANG_LIBDIR=''])
 
 PKG_CHECK_EXISTS([libclc], [have_libclc=yes], [have_libclc=no])
+AC_CHECK_LIB([elf], [elf_memory], [have_libelf=yes;ELF_LIB=-lelf])
 
 if test "x$enable_opencl" = xyes; then
     if test -z "$with_gallium_drivers"; then
@@ -1495,6 +1496,10 @@ if test "x$enable_opencl" = xyes; then
     else
         OPENCL_LIBNAME="OpenCL"
     fi
+
+    if test "x$have_libelf" != xyes; then
+       AC_MSG_ERROR([Clover requires libelf])
+    fi
 fi
 AM_CONDITIONAL(HAVE_CLOVER, test "x$enable_opencl" = xyes)
 AM_CONDITIONAL(HAVE_CLOVER_ICD, test "x$enable_opencl_icd" = xyes)
@@ -1714,7 +1719,7 @@ if test "x$enable_gallium_llvm" = xyes; then
         fi
 
         LLVM_REQUIRED_VERSION_MAJOR="3"
-        LLVM_REQUIRED_VERSION_MINOR="1"
+        LLVM_REQUIRED_VERSION_MINOR="3"
         if test "$LLVM_VERSION_INT" -lt "${LLVM_REQUIRED_VERSION_MAJOR}0${LLVM_REQUIRED_VERSION_MINOR}"; then
             AC_MSG_ERROR([LLVM $LLVM_REQUIRED_VERSION_MAJOR.$LLVM_REQUIRED_VERSION_MINOR or newer is required])
         fi
@@ -1870,8 +1875,9 @@ radeon_llvm_check() {
     fi
     LLVM_COMPONENTS="${LLVM_COMPONENTS} r600 bitreader ipo"
     NEED_RADEON_LLVM=yes
-    AC_CHECK_LIB([elf], [elf_memory], [ELF_LIB=-lelf],
-                                 [AC_MSG_ERROR([$1 requires libelf when using LLVM])])
+    if test "x$have_libelf" != xyes; then
+       AC_MSG_ERROR([$1 requires libelf when using llvm])
+    fi
 }
 
 dnl Duplicates in GALLIUM_DRIVERS_DIRS are removed by sorting it after this block
diff --git a/docs/GL3.txt b/docs/GL3.txt
index 07d1d2c..6a988d5 100644
--- a/docs/GL3.txt
+++ b/docs/GL3.txt
@@ -187,7 +187,7 @@ GL 4.4, GLSL 4.40:
 GL 4.5, GLSL 4.50:
 
   GL_ARB_ES3_1_compatibility                           not started
-  GL_ARB_clip_control                                  not started
+  GL_ARB_clip_control                                  DONE (llvmpipe, softpipe, r300, r600, radeonsi)
   GL_ARB_conditional_render_inverted                   DONE (i965, nvc0, llvmpipe, softpipe)
   GL_ARB_cull_distance                                 not started
   GL_ARB_derivative_control                            DONE (i965, nv50, nvc0, r600)
diff --git a/docs/index.html b/docs/index.html
index 244a7a3..0a491a2 100644
--- a/docs/index.html
+++ b/docs/index.html
@@ -16,6 +16,12 @@
 
 <h1>News</h1>
 
+<h2>October 24, 2014</h2>
+<p>
+<a href="relnotes/10.3.2.html">Mesa 10.3.2</a> is released.
+This is a bug-fix release.
+</p>
+
 <h2>October 12, 2014</h2>
 <p>
 <a href="relnotes/10.2.9.html">Mesa 10.2.9</a>
diff --git a/docs/relnotes.html b/docs/relnotes.html
index d546e85..1c97edd 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -21,6 +21,7 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <ul>
+<li><a href="relnotes/10.3.2.html">10.3.2 release notes</a>
 <li><a href="relnotes/10.3.1.html">10.3.1 release notes</a>
 <li><a href="relnotes/10.2.9.html">10.2.9 release notes</a>
 <li><a href="relnotes/10.3.html">10.3 release notes</a>
diff --git a/docs/relnotes/10.3.2.html b/docs/relnotes/10.3.2.html
new file mode 100644
index 0000000..4c08f65
--- /dev/null
+++ b/docs/relnotes/10.3.2.html
@@ -0,0 +1,115 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 10.3.2 Release Notes / October 24, 2014</h1>
+
+<p>
+Mesa 10.3.2 is a bug fix release which fixes bugs found since the 10.3 release.
+</p>
+<p>
+Mesa 10.3.2 implements the OpenGL 3.3 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.3.  OpenGL
+3.3 is <strong>only</strong> available if requested at context creation
+because compatibility contexts are not supported.
+</p>
+
+<h2>SHA256 checksums</h2>
+<pre>
+e65f8e691f06f111c1aeb3a376b13c9cc88cb162bee2709e0e7e6b0e6628ca75  MesaLib-10.3.2.tar.gz
+e9849bcb9aa9acd98a753d6d46d2e7d7238d3367036e11357a60efd16de8bea3  MesaLib-10.3.2.tar.bz2
+427dc0d670d38e713ebff2675665ec2fe4ff7d04ce227bd54de946999fc1d234  MesaLib-10.3.2.zip
+</pre>
+
+<h2>New features</h2>
+<p>None</p>
+
+<h2>Bug fixes</h2>
+
+<p>This list is likely incomplete.</p>
+
+<ul>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=54372">Bug 54372</a> - GLX_INTEL_swap_event crashes driver when swapping window buffers</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=81680">Bug 81680</a> - [r600g] Firefox crashes with hardware acceleration turned on</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=84140">Bug 84140</a> - mplayer crashes playing some files using vdpau output</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=84662">Bug 84662</a> - Long pauses with Unreal demo Elemental on R9270X since : Always flush the HDP cache before submitting a CS to the GPU</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=85267">Bug 85267</a> - vlc crashes with vdpau (Radeon 3850HD) [r600]</li>
+
+</ul>
+
+<h2>Changes</h2>
+
+<p>Brian Paul (3):</p>
+<ul>
+  <li>mesa: fix spurious wglGetProcAddress / GL_INVALID_OPERATION error</li>
+  <li>st/wgl: add WINAPI qualifiers on wgl function typedefs</li>
+  <li>glsl: fix several use-after-free bugs</li>
+</ul>
+
+<p>Daniel Manjarres (1):</p>
+<ul>
+  <li>glx: Fix glxUseXFont for glxWindow and glxPixmaps</li>
+</ul>
+
+<p>Dave Airlie (1):</p>
+<ul>
+  <li>mesa: fix GetTexImage for 1D array depth textures</li>
+</ul>
+
+<p>Emil Velikov (2):</p>
+<ul>
+  <li>docs: Add sha256 sums for the 10.3.1 release</li>
+  <li>Update VERSION to 10.3.2</li>
+</ul>
+
+<p>Ilia Mirkin (4):</p>
+<ul>
+  <li>gm107/ir: add dnz emission for fmul</li>
+  <li>gk110/ir: add dnz flag emission for fmul/fmad</li>
+  <li>nouveau: 3d textures are unsupported, limit 3d levels to 1</li>
+  <li>st/gbm: fix order of arguments passed to is_format_supported</li>
+</ul>
+
+<p>Kenneth Graunke (3):</p>
+<ul>
+  <li>i965: Add a BRW_MOCS_PTE #define.</li>
+  <li>i965: Use BDW_MOCS_PTE for renderbuffers.</li>
+  <li>i965: Fix register write checks.</li>
+</ul>
+
+<p>Marek Olšák (2):</p>
+<ul>
+  <li>st/mesa: use pipe_sampler_view_release for releasing sampler views</li>
+  <li>glsl_to_tgsi: fix the value of gl_FrontFacing with native integers</li>
+</ul>
+
+<p>Michel Dänzer (4):</p>
+<ul>
+  <li>radeonsi: Clear sampler view flags when binding a buffer</li>
+  <li>r600g,radeonsi: Always use GTT again for PIPE_USAGE_STREAM buffers</li>
+  <li>winsys/radeon: Use separate caching buffer manager for each set of flags</li>
+  <li>r600g: Drop references to destroyed blend state</li>
+</ul>
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/10.4.html b/docs/relnotes/10.4.html
index 64cbfae..67c3087 100644
--- a/docs/relnotes/10.4.html
+++ b/docs/relnotes/10.4.html
@@ -46,6 +46,7 @@ Note: some of the new features are only available with certain drivers.
 <ul>
 <li>GL_ARB_sample_shading on r600</li>
 <li>GL_ARB_texture_view on nv50, nvc0</li>
+<li>GL_ARB_clip_control on llvmpipe, softpipe, r300, r600, radeonsi</li>
 </ul>
 
 
diff --git a/scons/llvm.py b/scons/llvm.py
index 288a080..1e312f9 100644
--- a/scons/llvm.py
+++ b/scons/llvm.py
@@ -37,7 +37,7 @@ import SCons.Errors
 import SCons.Util
 
 
-required_llvm_version = '3.1'
+required_llvm_version = '3.3'
 
 
 def generate(env):
@@ -98,7 +98,7 @@ def generate(env):
             'HAVE_STDINT_H',
         ])
         env.Prepend(LIBPATH = [os.path.join(llvm_dir, 'lib')])
-        if llvm_version >= distutils.version.LooseVersion('3.2'):
+        if True:
             # 3.2
             env.Prepend(LIBS = [
                 'LLVMBitWriter', 'LLVMX86Disassembler', 'LLVMX86AsmParser',
@@ -110,18 +110,6 @@ def generate(env):
                 'LLVMAnalysis', 'LLVMTarget', 'LLVMMC', 'LLVMCore',
                 'LLVMSupport', 'LLVMRuntimeDyld', 'LLVMObject'
             ])
-        else:
-            # 3.1
-            env.Prepend(LIBS = [
-                'LLVMBitWriter', 'LLVMX86Disassembler', 'LLVMX86AsmParser',
-                'LLVMX86CodeGen', 'LLVMX86Desc', 'LLVMSelectionDAG',
-                'LLVMAsmPrinter', 'LLVMMCParser', 'LLVMX86AsmPrinter',
-                'LLVMX86Utils', 'LLVMX86Info', 'LLVMMCJIT', 'LLVMJIT',
-                'LLVMExecutionEngine', 'LLVMCodeGen', 'LLVMScalarOpts',
-                'LLVMInstCombine', 'LLVMTransformUtils', 'LLVMipa',
-                'LLVMAnalysis', 'LLVMTarget', 'LLVMMC', 'LLVMCore',
-                'LLVMSupport'
-            ])
         env.Append(LIBS = [
             'imagehlp',
             'psapi',
diff --git a/src/gallium/auxiliary/gallivm/lp_bld.h b/src/gallium/auxiliary/gallivm/lp_bld.h
index a01c216..7ba925c 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld.h
@@ -53,8 +53,8 @@
 #ifndef HAVE_LLVM
 #error "HAVE_LLVM should be set with LLVM's version number, e.g. (0x0207 for 2.7)"
 #endif
-#if HAVE_LLVM < 0x301
-#error "LLVM 3.1 or newer required"
+#if HAVE_LLVM < 0x303
+#error "LLVM 3.3 or newer required"
 #endif
 
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_debug.cpp b/src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
index b6b52c8..bad65c2 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_debug.cpp
@@ -43,11 +43,7 @@
 
 #include <llvm/Support/Host.h>
 
-#if HAVE_LLVM >= 0x0303
 #include <llvm/IR/Module.h>
-#else
-#include <llvm/Module.h>
-#endif
 
 #include <llvm/MC/MCDisassembler.h>
 #include <llvm/MC/MCAsmInfo.h>
@@ -57,7 +53,7 @@
 
 #if HAVE_LLVM >= 0x0305
 #define OwningPtr std::unique_ptr
-#elif HAVE_LLVM >= 0x0303
+#else
 #include <llvm/ADT/OwningPtr.h>
 #endif
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init.c b/src/gallium/auxiliary/gallivm/lp_bld_init.c
index 8d7a0b6..23a7c45 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_init.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init.c
@@ -45,35 +45,13 @@
 
 /* Only MCJIT is available as of LLVM SVN r216982 */
 #if HAVE_LLVM >= 0x0306
-
-#define USE_MCJIT 1
-#define HAVE_AVX 1
-
-#else
-
-/**
- * AVX is supported in:
- * - standard JIT from LLVM 3.2 onwards
- * - MC-JIT from LLVM 3.1
- *   - MC-JIT supports limited OSes (MacOSX and Linux)
- * - standard JIT in LLVM 3.1, with backports
- */
-#if defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
 #  define USE_MCJIT 1
-#  define HAVE_AVX 0
-#elif HAVE_LLVM >= 0x0302 || (HAVE_LLVM == 0x0301 && defined(HAVE_JIT_AVX_SUPPORT))
-#  define USE_MCJIT 0
-#  define HAVE_AVX 1
-#elif HAVE_LLVM == 0x0301 && (defined(PIPE_OS_LINUX) || defined(PIPE_OS_APPLE))
+#elif defined(PIPE_ARCH_PPC_64) || defined(PIPE_ARCH_S390) || defined(PIPE_ARCH_ARM) || defined(PIPE_ARCH_AARCH64)
 #  define USE_MCJIT 1
-#  define HAVE_AVX 1
 #else
 #  define USE_MCJIT 0
-#  define HAVE_AVX 0
 #endif
 
-#endif /* HAVE_LLVM >= 0x0306 */
-
 #if USE_MCJIT
 void LLVMLinkInMCJIT();
 #endif
@@ -315,13 +293,9 @@ init_gallivm_state(struct gallivm_state *gallivm, const char *name,
    if (!gallivm->builder)
       goto fail;
 
-#if HAVE_LLVM < 0x0306
    gallivm->memorymgr = lp_get_default_memory_manager();
    if (!gallivm->memorymgr)
       goto fail;
-#else
-   gallivm->memorymgr = 0;
-#endif
 
    /* FIXME: MC-JIT only allows compiling one module at a time, and it must be
     * complete when MC-JIT is created. So defer the MC-JIT engine creation for
@@ -386,13 +360,6 @@ lp_build_init(void)
    if (gallivm_initialized)
       return TRUE;
 
-   /* XXX: Remove this once lp_bld_misc.cpp has been adapted to the removal
-    * of JITMemoryManager
-    */
-#if HAVE_LLVM >= 0x0306
-   return FALSE;
-#endif
-
 #ifdef DEBUG
    gallivm_debug = debug_get_option_gallivm_debug();
 #endif
@@ -414,8 +381,7 @@ lp_build_init(void)
     * See also:
     * - http://www.anandtech.com/show/4955/the-bulldozer-review-amd-fx8150-tested/2
     */
-   if (HAVE_AVX &&
-       util_cpu_caps.has_avx &&
+   if (util_cpu_caps.has_avx &&
        util_cpu_caps.has_intel) {
       lp_native_vector_width = 256;
    } else {
@@ -440,16 +406,6 @@ lp_build_init(void)
       util_cpu_caps.has_avx2 = 0;
    }
 
-   if (!HAVE_AVX) {
-      /*
-       * note these instructions are VEX-only, so can only emit if we use
-       * avx (don't want to base it on has_avx & has_f16c later as that would
-       * omit it unnecessarily on amd cpus, see above).
-       */
-      util_cpu_caps.has_f16c = 0;
-      util_cpu_caps.has_xop = 0;
-   }
-
 #ifdef PIPE_ARCH_PPC_64
    /* Set the NJ bit in VSCR to 0 so denormalized values are handled as
     * specified by IEEE standard (PowerISA 2.06 - Section 6.3). This guarantees
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
index 9c2de2c..6bc4d81 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
+++ b/src/gallium/auxiliary/gallivm/lp_bld_misc.cpp
@@ -57,6 +57,8 @@
 #include <llvm/ADT/Triple.h>
 #if HAVE_LLVM < 0x0306
 #include <llvm/ExecutionEngine/JITMemoryManager.h>
+#else
+#include <llvm/ExecutionEngine/SectionMemoryManager.h>
 #endif
 #include <llvm/Support/CommandLine.h>
 #include <llvm/Support/Host.h>
@@ -64,11 +66,9 @@
 
 #include <llvm/Support/TargetSelect.h>
 
-#if HAVE_LLVM >= 0x0303
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/Module.h>
 #include <llvm/Support/CBindingWrapping.h>
-#endif
 
 #include "pipe/p_config.h"
 #include "util/u_debug.h"
@@ -82,15 +82,9 @@ class LLVMEnsureMultithreaded {
 public:
    LLVMEnsureMultithreaded()
    {
-#if HAVE_LLVM < 0x0303
-      if (!llvm::llvm_is_multithreaded()) {
-         llvm::llvm_start_multithreaded();
-      }
-#else
       if (!LLVMIsMultithreaded()) {
          LLVMStartMultithreaded();
       }
-#endif
    }
 };
 
@@ -140,24 +134,31 @@ lp_set_load_alignment(LLVMValueRef Inst,
 extern "C"
 void
 lp_set_store_alignment(LLVMValueRef Inst,
-		       unsigned Align)
+                       unsigned Align)
 {
    llvm::unwrap<llvm::StoreInst>(Inst)->setAlignment(Align);
 }
 
+
 #if HAVE_LLVM < 0x0306
+typedef llvm::JITMemoryManager BaseMemoryManager;
+#else
+typedef llvm::RTDyldMemoryManager BaseMemoryManager;
+#endif
+
 
 /*
  * Delegating is tedious but the default manager class is hidden in an
  * anonymous namespace in LLVM, so we cannot just derive from it to change
  * its behavior.
  */
-class DelegatingJITMemoryManager : public llvm::JITMemoryManager {
+class DelegatingJITMemoryManager : public BaseMemoryManager {
 
    protected:
-      virtual llvm::JITMemoryManager *mgr() const = 0;
+      virtual BaseMemoryManager *mgr() const = 0;
 
    public:
+#if HAVE_LLVM < 0x0306
       /*
        * From JITMemoryManager
        */
@@ -241,6 +242,7 @@ class DelegatingJITMemoryManager : public llvm::JITMemoryManager {
       virtual unsigned GetNumStubSlabs() {
          return mgr()->GetNumStubSlabs();
       }
+#endif
 
       /*
        * From RTDyldMemoryManager
@@ -260,7 +262,6 @@ class DelegatingJITMemoryManager : public llvm::JITMemoryManager {
          return mgr()->allocateCodeSection(Size, Alignment, SectionID);
       }
 #endif
-#if HAVE_LLVM >= 0x0303
       virtual uint8_t *allocateDataSection(uintptr_t Size,
                                            unsigned Alignment,
                                            unsigned SectionID,
@@ -286,22 +287,15 @@ class DelegatingJITMemoryManager : public llvm::JITMemoryManager {
          mgr()->registerEHFrames(SectionData);
       }
 #endif
-#else
-      virtual uint8_t *allocateDataSection(uintptr_t Size,
-                                           unsigned Alignment,
-                                           unsigned SectionID) {
-         return mgr()->allocateDataSection(Size, Alignment, SectionID);
-      }
-#endif
       virtual void *getPointerToNamedFunction(const std::string &Name,
                                               bool AbortOnFailure=true) {
          return mgr()->getPointerToNamedFunction(Name, AbortOnFailure);
       }
-#if HAVE_LLVM == 0x0303
+#if HAVE_LLVM <= 0x0303
       virtual bool applyPermissions(std::string *ErrMsg = 0) {
          return mgr()->applyPermissions(ErrMsg);
       }
-#elif HAVE_LLVM > 0x0303
+#else
       virtual bool finalizeMemory(std::string *ErrMsg = 0) {
          return mgr()->finalizeMemory(ErrMsg);
       }
@@ -322,14 +316,14 @@ class DelegatingJITMemoryManager : public llvm::JITMemoryManager {
  */
 class ShaderMemoryManager : public DelegatingJITMemoryManager {
 
-   llvm::JITMemoryManager *TheMM;
+   BaseMemoryManager *TheMM;
 
    struct GeneratedCode {
       typedef std::vector<void *> Vec;
       Vec FunctionBody, ExceptionTable;
-      llvm::JITMemoryManager *TheMM;
+      BaseMemoryManager *TheMM;
 
-      GeneratedCode(llvm::JITMemoryManager *MM) {
+      GeneratedCode(BaseMemoryManager *MM) {
          TheMM = MM;
       }
 
@@ -338,27 +332,29 @@ class ShaderMemoryManager : public DelegatingJITMemoryManager {
           * Deallocate things as previously requested and
           * free shared manager when no longer used.
           */
-	 Vec::iterator i;
+#if HAVE_LLVM < 0x0306
+         Vec::iterator i;
 
-	 assert(TheMM);
-	 for ( i = FunctionBody.begin(); i != FunctionBody.end(); ++i )
-	    TheMM->deallocateFunctionBody(*i);
+         assert(TheMM);
+         for ( i = FunctionBody.begin(); i != FunctionBody.end(); ++i )
+            TheMM->deallocateFunctionBody(*i);
 #if HAVE_LLVM < 0x0304
-	 for ( i = ExceptionTable.begin(); i != ExceptionTable.end(); ++i )
-	    TheMM->deallocateExceptionTable(*i);
-#endif
+         for ( i = ExceptionTable.begin(); i != ExceptionTable.end(); ++i )
+            TheMM->deallocateExceptionTable(*i);
+#endif /* HAVE_LLVM < 0x0304 */
+#endif /* HAVE_LLVM < 0x0306 */
       }
    };
 
    GeneratedCode *code;
 
-   llvm::JITMemoryManager *mgr() const {
+   BaseMemoryManager *mgr() const {
       return TheMM;
    }
 
    public:
 
-      ShaderMemoryManager(llvm::JITMemoryManager* MM) {
+      ShaderMemoryManager(BaseMemoryManager* MM) {
          TheMM = MM;
          code = new GeneratedCode(MM);
       }
@@ -391,7 +387,6 @@ class ShaderMemoryManager : public DelegatingJITMemoryManager {
       }
 };
 
-#endif
 
 /**
  * Same as LLVMCreateJITCompilerForModule, but:
@@ -415,11 +410,6 @@ lp_build_create_jit_compiler_for_module(LLVMExecutionEngineRef *OutJIT,
 {
    using namespace llvm;
 
-#if HAVE_LLVM >= 0x0306
-   *OutError = strdup("MCJIT not supported");
-   return 1;
-#else
-
    std::string Error;
 #if HAVE_LLVM >= 0x0306
    EngineBuilder builder(std::unique_ptr<Module>(unwrap(M)));
@@ -501,25 +491,30 @@ lp_build_create_jit_compiler_for_module(LLVMExecutionEngineRef *OutJIT,
    builder.setMCPU(MCPU);
 #endif
 
-   llvm::JITMemoryManager* JMM = reinterpret_cast<llvm::JITMemoryManager*>(CMM);
-   ShaderMemoryManager *MM = new ShaderMemoryManager(JMM);
-   *OutCode = MM->getGeneratedCode();
+   ShaderMemoryManager *MM;
+   if (useMCJIT) {
+#if HAVE_LLVM > 0x0303
+       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
+       MM = new ShaderMemoryManager(JMM);
+       *OutCode = MM->getGeneratedCode();
 
-   builder.setJITMemoryManager(MM);
+       builder.setMCJITMemoryManager(MM);
+#endif
+   } else {
+#if HAVE_LLVM < 0x0306
+       BaseMemoryManager* JMM = reinterpret_cast<BaseMemoryManager*>(CMM);
+       MM = new ShaderMemoryManager(JMM);
+       *OutCode = MM->getGeneratedCode();
+
+       builder.setJITMemoryManager(MM);
+#else
+       assert(0);
+#endif
+   }
 
    ExecutionEngine *JIT;
 
-#if HAVE_LLVM >= 0x0302
    JIT = builder.create();
-#else
-   /*
-    * Workaround http://llvm.org/PR12833
-    */
-   StringRef MArch = "";
-   StringRef MCPU = "";
-   Triple TT(unwrap(M)->getTargetTriple());
-   JIT = builder.create(builder.selectTarget(TT, MArch, MCPU, MAttrs));
-#endif
    if (JIT) {
       *OutJIT = wrap(JIT);
       return 0;
@@ -529,7 +524,6 @@ lp_build_create_jit_compiler_for_module(LLVMExecutionEngineRef *OutJIT,
    delete MM;
    *OutError = strdup(Error.c_str());
    return 1;
-#endif
 }
 
 
@@ -537,29 +531,25 @@ extern "C"
 void
 lp_free_generated_code(struct lp_generated_code *code)
 {
-#if HAVE_LLVM < 0x0306
    ShaderMemoryManager::freeGeneratedCode(code);
-#endif
 }
 
 extern "C"
 LLVMMCJITMemoryManagerRef
 lp_get_default_memory_manager()
 {
+   BaseMemoryManager *mm;
 #if HAVE_LLVM < 0x0306
-   llvm::JITMemoryManager *mm;
    mm = llvm::JITMemoryManager::CreateDefaultMemManager();
-   return reinterpret_cast<LLVMMCJITMemoryManagerRef>(mm);
 #else
-   return 0;
+   mm = new llvm::SectionMemoryManager();
 #endif
+   return reinterpret_cast<LLVMMCJITMemoryManagerRef>(mm);
 }
 
 extern "C"
 void
 lp_free_memory_manager(LLVMMCJITMemoryManagerRef memorymgr)
 {
-#if HAVE_LLVM < 0x0306
-   delete reinterpret_cast<llvm::JITMemoryManager*>(memorymgr);
-#endif
+   delete reinterpret_cast<BaseMemoryManager*>(memorymgr);
 }
diff --git a/src/gallium/auxiliary/os/os_mman.h b/src/gallium/auxiliary/os/os_mman.h
index 19478d2..19c9a5b 100644
--- a/src/gallium/auxiliary/os/os_mman.h
+++ b/src/gallium/auxiliary/os/os_mman.h
@@ -58,7 +58,8 @@ extern "C" {
 
 extern void *__mmap2(void *, size_t, int, int, int, size_t);
 
-static INLINE void *os_mmap(void *addr, size_t length, int prot, int flags, int fd, loff_t offset)
+static INLINE void *os_mmap(void *addr, size_t length, int prot, int flags,
+                            int fd, loff_t offset)
 {
    /* offset must be aligned to 4096 (not necessarily the page size) */
    if (unlikely(offset & 4095)) {
@@ -69,20 +70,26 @@ static INLINE void *os_mmap(void *addr, size_t length, int prot, int flags, int
    return __mmap2(addr, length, prot, flags, fd, (size_t) (offset >> 12));
 }
 
+#  define drm_munmap(addr, length) \
+              munmap(addr, length)
+
 #else
 /* assume large file support exists */
-#  define os_mmap(addr, length, prot, flags, fd, offset) mmap(addr, length, prot, flags, fd, offset)
-#endif
+#  define os_mmap(addr, length, prot, flags, fd, offset) \
+             mmap(addr, length, prot, flags, fd, offset)
 
 static INLINE int os_munmap(void *addr, size_t length)
 {
    /* Copied from configure code generated by AC_SYS_LARGEFILE */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
-   STATIC_ASSERT(LARGE_OFF_T % 2147483629 == 721 && LARGE_OFF_T % 2147483647 == 1);
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + \
+                     (((off_t) 1 << 31) << 31))
+   STATIC_ASSERT(LARGE_OFF_T % 2147483629 == 721 &&
+                 LARGE_OFF_T % 2147483647 == 1);
 #undef LARGE_OFF_T
 
    return munmap(addr, length);
 }
+#endif
 
 
 #ifdef	__cplusplus
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index f3fe949..e59fa04 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -134,6 +134,7 @@ struct blitter_context_priv
    boolean has_stream_out;
    boolean has_stencil_export;
    boolean has_texture_multisample;
+   boolean cached_all_shaders;
 
    /* The Draw module overrides these functions.
     * Always create the blitter before Draw. */
@@ -356,10 +357,11 @@ static void bind_fs_empty(struct blitter_context_priv *ctx)
    struct pipe_context *pipe = ctx->base.pipe;
 
    if (!ctx->fs_empty) {
+      assert(!ctx->cached_all_shaders);
       ctx->fs_empty = util_make_empty_fragment_shader(pipe);
    }
 
-   pipe->bind_fs_state(pipe, ctx->fs_empty);
+   ctx->bind_fs_state(pipe, ctx->fs_empty);
 }
 
 static void bind_fs_write_one_cbuf(struct blitter_context_priv *ctx)
@@ -367,12 +369,13 @@ static void bind_fs_write_one_cbuf(struct blitter_context_priv *ctx)
    struct pipe_context *pipe = ctx->base.pipe;
 
    if (!ctx->fs_write_one_cbuf) {
+      assert(!ctx->cached_all_shaders);
       ctx->fs_write_one_cbuf =
          util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                                TGSI_INTERPOLATE_CONSTANT, FALSE);
    }
 
-   pipe->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
+   ctx->bind_fs_state(pipe, ctx->fs_write_one_cbuf);
 }
 
 static void bind_fs_write_all_cbufs(struct blitter_context_priv *ctx)
@@ -380,12 +383,13 @@ static void bind_fs_write_all_cbufs(struct blitter_context_priv *ctx)
    struct pipe_context *pipe = ctx->base.pipe;
 
    if (!ctx->fs_write_all_cbufs) {
+      assert(!ctx->cached_all_shaders);
       ctx->fs_write_all_cbufs =
          util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
                                                TGSI_INTERPOLATE_CONSTANT, TRUE);
    }
 
-   pipe->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
+   ctx->bind_fs_state(pipe, ctx->fs_write_all_cbufs);
 }
 
 void util_blitter_destroy(struct blitter_context *blitter)
@@ -850,6 +854,7 @@ static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
             shader = &ctx->fs_resolve[target][index][filter];
 
          if (!*shader) {
+            assert(!ctx->cached_all_shaders);
             if (filter == PIPE_TEX_FILTER_LINEAR) {
                *shader = util_make_fs_msaa_resolve_bilinear(pipe, tgsi_tex,
                                                    src_nr_samples,
@@ -870,6 +875,7 @@ static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
 
          /* Create the fragment shader on-demand. */
          if (!*shader) {
+            assert(!ctx->cached_all_shaders);
             *shader = util_make_fs_blit_msaa_color(pipe, tgsi_tex);
          }
       }
@@ -880,6 +886,7 @@ static void *blitter_get_fs_texfetch_col(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
+         assert(!ctx->cached_all_shaders);
          *shader = util_make_fragment_tex_shader(pipe, tgsi_tex,
                                                  TGSI_INTERPOLATE_LINEAR);
       }
@@ -902,11 +909,10 @@ void *blitter_get_fs_texfetch_depth(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
-                                                       nr_samples);
-
-         *shader =
-            util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
+         *shader = util_make_fs_blit_msaa_depth(pipe, tgsi_tex);
       }
 
       return *shader;
@@ -915,8 +921,9 @@ void *blitter_get_fs_texfetch_depth(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
-
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
          *shader =
             util_make_fragment_tex_shader_writedepth(pipe, tgsi_tex,
                                                      TGSI_INTERPOLATE_LINEAR);
@@ -940,11 +947,10 @@ void *blitter_get_fs_texfetch_depthstencil(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
-                                                       nr_samples);
-
-         *shader =
-            util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
+         *shader = util_make_fs_blit_msaa_depthstencil(pipe, tgsi_tex);
       }
 
       return *shader;
@@ -953,8 +959,9 @@ void *blitter_get_fs_texfetch_depthstencil(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
-
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
          *shader =
             util_make_fragment_tex_shader_writedepthstencil(pipe, tgsi_tex,
                                                      TGSI_INTERPOLATE_LINEAR);
@@ -978,11 +985,10 @@ void *blitter_get_fs_texfetch_stencil(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target,
-                                                       nr_samples);
-
-         *shader =
-            util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, nr_samples);
+         *shader = util_make_fs_blit_msaa_stencil(pipe, tgsi_tex);
       }
 
       return *shader;
@@ -991,8 +997,9 @@ void *blitter_get_fs_texfetch_stencil(struct blitter_context_priv *ctx,
 
       /* Create the fragment shader on-demand. */
       if (!*shader) {
-         unsigned tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
-
+         unsigned tgsi_tex;
+         assert(!ctx->cached_all_shaders);
+         tgsi_tex = util_pipe_tex_to_tgsi_tex(target, 0);
          *shader =
             util_make_fragment_tex_shader_writestencil(pipe, tgsi_tex,
                                                        TGSI_INTERPOLATE_LINEAR);
@@ -1002,10 +1009,18 @@ void *blitter_get_fs_texfetch_stencil(struct blitter_context_priv *ctx,
    }
 }
 
+
+/**
+ * Generate and save all fragment shaders that we will ever need for
+ * blitting.  Drivers which use the 'draw' fallbacks will typically use
+ * this to make sure we generate/use shaders that don't go through the
+ * draw module's wrapper functions.
+ */
 void util_blitter_cache_all_shaders(struct blitter_context *blitter)
 {
    struct blitter_context_priv *ctx = (struct blitter_context_priv*)blitter;
-   struct pipe_screen *screen = blitter->pipe->screen;
+   struct pipe_context *pipe = blitter->pipe;
+   struct pipe_screen *screen = pipe->screen;
    unsigned samples, j, f, target, max_samples;
    boolean has_arraytex, has_cubearraytex;
 
@@ -1065,6 +1080,18 @@ void util_blitter_cache_all_shaders(struct blitter_context *blitter)
          }
       }
    }
+
+   ctx->fs_empty = util_make_empty_fragment_shader(pipe);
+
+   ctx->fs_write_one_cbuf =
+      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
+                                            TGSI_INTERPOLATE_CONSTANT, FALSE);
+
+   ctx->fs_write_all_cbufs =
+      util_make_fragment_passthrough_shader(pipe, TGSI_SEMANTIC_GENERIC,
+                                            TGSI_INTERPOLATE_CONSTANT, TRUE);
+
+   ctx->cached_all_shaders = TRUE;
 }
 
 static void blitter_set_common_draw_rect_state(struct blitter_context_priv *ctx,
diff --git a/src/gallium/auxiliary/util/u_math.h b/src/gallium/auxiliary/util/u_math.h
index f95c111..0113fb1 100644
--- a/src/gallium/auxiliary/util/u_math.h
+++ b/src/gallium/auxiliary/util/u_math.h
@@ -799,7 +799,7 @@ util_bswap64(uint64_t n)
 #if defined(HAVE___BUILTIN_BSWAP64)
    return __builtin_bswap64(n);
 #else
-   return ((uint64_t)util_bswap32(n) << 32) |
+   return ((uint64_t)util_bswap32((uint32_t)n) << 32) |
           util_bswap32((n >> 32));
 #endif
 }
diff --git a/src/gallium/docs/source/screen.rst b/src/gallium/docs/source/screen.rst
index 88d7e49..e711ad4 100644
--- a/src/gallium/docs/source/screen.rst
+++ b/src/gallium/docs/source/screen.rst
@@ -230,6 +230,9 @@ The integer capabilities:
   different than the underlying resource's, as permitted by
   ARB_texture_view. For example a 2d array texture may be reinterpreted as a
   cube (array) texture and vice-versa.
+* ``PIPE_CAP_CLIP_HALFZ``: Whether the driver supports the
+  pipe_rasterizer_state::clip_halfz being set to true. This is required
+  for enabling ARB_clip_control.
 
 
 .. _pipe_capf:
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_draw.c b/src/gallium/drivers/freedreno/a3xx/fd3_draw.c
index 0fb0625..c4e3d8d 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_draw.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_draw.c
@@ -136,21 +136,14 @@ fd3_draw(struct fd_context *ctx, const struct pipe_draw_info *info)
 		},
 		.rasterflat = ctx->rasterizer && ctx->rasterizer->flatshade,
 	};
-	uint32_t dirty, vconst;
+	unsigned dirty;
 
 	fixup_shader_state(ctx, &emit.key);
 
-	/* save/restore vertex const state too, so that vertex
-	 * shader consts also get emitted for render pass:
-	 */
-	vconst = ctx->constbuf[PIPE_SHADER_VERTEX].dirty_mask;
-
 	dirty = ctx->dirty;
 	emit.dirty = dirty & ~(FD_DIRTY_BLEND);
 	draw_impl(ctx, ctx->binning_ring, &emit);
 
-	ctx->constbuf[PIPE_SHADER_VERTEX].dirty_mask = vconst;
-
 	/* and now regular (non-binning) pass: */
 	emit.key.binning_pass = false;
 	emit.dirty = dirty;
@@ -337,7 +330,6 @@ fd3_clear(struct fd_context *ctx, unsigned buffers,
 
 	fd3_emit_vertex_bufs(ring, &emit);
 
-	ctx->constbuf[PIPE_SHADER_FRAGMENT].dirty_mask = ~0;
 	fd3_emit_constant(ring, SB_FRAG_SHADER, 0, 0, 4, color->ui, NULL);
 
 	OUT_PKT0(ring, REG_A3XX_PC_PRIM_VTX_CNTL, 1);
diff --git a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
index 5bf41b1..e22a5ba 100644
--- a/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
+++ b/src/gallium/drivers/freedreno/a3xx/fd3_emit.c
@@ -93,6 +93,10 @@ emit_constants(struct fd_ringbuffer *ring,
 	uint32_t first_immediate;
 	uint32_t base = 0;
 
+	// XXX TODO only emit dirty consts.. but we need to keep track if
+	// they are clobbered by a clear, gmem2mem, or mem2gmem..
+	constbuf->dirty_mask = enabled_mask;
+
 	/* in particular, with binning shader we may end up with unused
 	 * consts, ie. we could end up w/ constlen that is smaller
 	 * than first_immediate.  In that case truncate the user consts
diff --git a/src/gallium/drivers/freedreno/freedreno_resource.c b/src/gallium/drivers/freedreno/freedreno_resource.c
index 49ae517..6b31d26 100644
--- a/src/gallium/drivers/freedreno/freedreno_resource.c
+++ b/src/gallium/drivers/freedreno/freedreno_resource.c
@@ -104,6 +104,8 @@ fd_resource_transfer_map(struct pipe_context *pctx,
 	char *buf;
 	int ret = 0;
 
+	DBG("prsc=%p, level=%u, usage=%x", prsc, level, usage);
+
 	ptrans = util_slab_alloc(&ctx->transfer_pool);
 	if (!ptrans)
 		return NULL;
@@ -124,18 +126,15 @@ fd_resource_transfer_map(struct pipe_context *pctx,
 	if (usage & PIPE_TRANSFER_WRITE)
 		op |= DRM_FREEDRENO_PREP_WRITE;
 
-	if (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE)
-		op |= DRM_FREEDRENO_PREP_NOSYNC;
-
 	/* some state trackers (at least XA) don't do this.. */
 	if (!(usage & (PIPE_TRANSFER_FLUSH_EXPLICIT | PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE)))
 		fd_resource_transfer_flush_region(pctx, ptrans, box);
 
-	if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
+	if (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE) {
+		realloc_bo(rsc, fd_bo_size(rsc->bo));
+	} else if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
 		ret = fd_bo_cpu_prep(rsc->bo, ctx->screen->pipe, op);
-		if ((ret == -EBUSY) && (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE))
-			realloc_bo(rsc, fd_bo_size(rsc->bo));
-		else if (ret)
+		if (ret)
 			goto fail;
 	}
 
diff --git a/src/gallium/drivers/freedreno/freedreno_screen.c b/src/gallium/drivers/freedreno/freedreno_screen.c
index 90156b4..7a3cd95 100644
--- a/src/gallium/drivers/freedreno/freedreno_screen.c
+++ b/src/gallium/drivers/freedreno/freedreno_screen.c
@@ -226,6 +226,7 @@ fd_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
 	case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
 	case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
 	case PIPE_CAP_SAMPLER_VIEW_TARGET:
+	case PIPE_CAP_CLIP_HALFZ:
 		return 0;
 
 	case PIPE_CAP_MAX_VIEWPORTS:
diff --git a/src/gallium/drivers/i915/i915_screen.c b/src/gallium/drivers/i915/i915_screen.c
index 2a6e751..062f1a6 100644
--- a/src/gallium/drivers/i915/i915_screen.c
+++ b/src/gallium/drivers/i915/i915_screen.c
@@ -225,6 +225,7 @@ i915_get_param(struct pipe_screen *screen, enum pipe_cap cap)
    case PIPE_CAP_TEXTURE_GATHER_OFFSETS:
    case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
    case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
+   case PIPE_CAP_CLIP_HALFZ:
       return 0;
 
    case PIPE_CAP_MAX_DUAL_SOURCE_RENDER_TARGETS:
diff --git a/src/gallium/drivers/ilo/ilo_builder_decode.c b/src/gallium/drivers/ilo/ilo_builder_decode.c
index 922acc0..3a9ae24 100644
--- a/src/gallium/drivers/ilo/ilo_builder_decode.c
+++ b/src/gallium/drivers/ilo/ilo_builder_decode.c
@@ -79,21 +79,44 @@ writer_decode_blob(const struct ilo_builder *builder,
                    enum ilo_builder_writer_type which,
                    const struct ilo_builder_item *item)
 {
-   const unsigned state_size = sizeof(uint32_t) * 4;
+   const unsigned state_size = sizeof(uint32_t);
    const unsigned count = item->size / state_size;
    unsigned offset = item->offset;
    unsigned i;
 
-   for (i = 0; i < count; i++) {
+   for (i = 0; i < count; i += 4) {
       const uint32_t *dw = writer_pointer(builder, which, offset);
 
-      writer_dw(builder, which, offset, 0, "BLOB%d", i);
-      /* output a single line for all four DWords */
-      ilo_printf("(% f, % f, % f, % f) (0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
-               uif(dw[0]), uif(dw[1]), uif(dw[2]), uif(dw[3]),
-               dw[0], dw[1], dw[2], dw[3]);
+      writer_dw(builder, which, offset, 0, "BLOB%d", i / 4);
+
+      switch (count - i) {
+      case 1:
+         ilo_printf("(%10.4f, %10c, %10c, %10c) "
+                    "(0x%08x, %10c, %10c, %10c)\n",
+                    uif(dw[0]), 'X', 'X', 'X',
+                        dw[0],  'X', 'X', 'X');
+         break;
+      case 2:
+         ilo_printf("(%10.4f, %10.4f, %10c, %10c) "
+                    "(0x%08x, 0x%08x, %10c, %10c)\n",
+                    uif(dw[0]), uif(dw[1]), 'X', 'X',
+                        dw[0],      dw[1],  'X', 'X');
+         break;
+      case 3:
+         ilo_printf("(%10.4f, %10.4f, %10.4f, %10c) "
+                    "(0x%08x, 0x%08x, 0x%08x, %10c)\n",
+                    uif(dw[0]), uif(dw[1]), uif(dw[2]), 'X',
+                        dw[0],      dw[1],      dw[2],  'X');
+         break;
+      default:
+         ilo_printf("(%10.4f, %10.4f, %10.4f, %10.4f) "
+                    "(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
+                    uif(dw[0]), uif(dw[1]), uif(dw[2]), uif(dw[3]),
+                        dw[0],      dw[1],      dw[2],      dw[3]);
+         break;
+      }
 
-      offset += state_size;
+      offset += state_size * 4;
    }
 }
 
diff --git a/src/gallium/drivers/ilo/ilo_screen.c b/src/gallium/drivers/ilo/ilo_screen.c
index 48c3dea..da6cf76 100644
--- a/src/gallium/drivers/ilo/ilo_screen.c
+++ b/src/gallium/drivers/ilo/ilo_screen.c
@@ -469,6 +469,8 @@ ilo_get_param(struct pipe_screen *screen, enum pipe_cap param)
    }
    case PIPE_CAP_UMA:
       return true;
+   case PIPE_CAP_CLIP_HALFZ:
+      return true;
 
    default:
       return 0;
diff --git a/src/gallium/drivers/llvmpipe/lp_screen.c b/src/gallium/drivers/llvmpipe/lp_screen.c
index a264f99..cec0fcb 100644
--- a/src/gallium/drivers/llvmpipe/lp_screen.c
+++ b/src/gallium/drivers/llvmpipe/lp_screen.c
@@ -277,6 +277,8 @@ llvmpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
    }
    case PIPE_CAP_UMA:
       return 0;
+   case PIPE_CAP_CLIP_HALFZ:
+      return 1;
    }
    /* should only get here on unhandled cases */
    debug_printf("Unexpected PIPE_CAP %d query\n", param);
@@ -551,12 +553,6 @@ llvmpipe_create_screen(struct sw_winsys *winsys)
 
    util_cpu_detect();
 
-#if defined(PIPE_ARCH_X86) && HAVE_LLVM < 0x0302
-   /* require SSE2 due to LLVM PR6960. */
-   if (!util_cpu_caps.has_sse2)
-       return NULL;
-#endif
-
 #ifdef DEBUG
    LP_DEBUG = debug_get_flags_option("LP_DEBUG", lp_debug_flags, 0 );
 #endif
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index a7a55f8..0fc3686 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -1666,15 +1666,7 @@ generate_unswizzled_blend(struct gallivm_state *gallivm,
    partial_mask |= !variant->opaque;
    i32_zero = lp_build_const_int32(gallivm, 0);
 
-#if HAVE_LLVM < 0x0302
-   /*
-    * undef triggers a crash in LLVMBuildTrunc in convert_from_blend_type in some
-    * cases (seen with r10g10b10a2, 128bit wide vectors) (only used for 1d case).
-    */
-   undef_src_val = lp_build_zero(gallivm, fs_type);
-#else
    undef_src_val = lp_build_undef(gallivm, fs_type);
-#endif
 
    row_type.length = fs_type.length;
    vector_width    = dst_type.floating ? lp_native_vector_width : lp_integer_vector_width;
diff --git a/src/gallium/drivers/llvmpipe/lp_test_arit.c b/src/gallium/drivers/llvmpipe/lp_test_arit.c
index 660ad4d..3fc64ce 100644
--- a/src/gallium/drivers/llvmpipe/lp_test_arit.c
+++ b/src/gallium/drivers/llvmpipe/lp_test_arit.c
@@ -395,6 +395,7 @@ test_unary(unsigned verbose, FILE *fp, const struct unary_test_t *test)
             printf("%s(%.9g): ref = %.9g, out = %.9g, precision = %f bits, %s\n",
                   test->name, in[i], ref, out[i], precision,
                   pass ? "PASS" : "FAIL");
+            fflush(stdout);
          }
 
          if (!pass) {
diff --git a/src/gallium/drivers/llvmpipe/lp_test_format.c b/src/gallium/drivers/llvmpipe/lp_test_format.c
index cdacb1b..48bf06e 100644
--- a/src/gallium/drivers/llvmpipe/lp_test_format.c
+++ b/src/gallium/drivers/llvmpipe/lp_test_format.c
@@ -133,6 +133,7 @@ test_format_float(unsigned verbose, FILE *fp,
    struct gallivm_state *gallivm;
    LLVMValueRef fetch = NULL;
    fetch_ptr_t fetch_ptr;
+   PIPE_ALIGN_VAR(16) uint8_t packed[UTIL_FORMAT_MAX_PACKED_BYTES];
    PIPE_ALIGN_VAR(16) float unpacked[4];
    boolean first = TRUE;
    boolean success = TRUE;
@@ -156,16 +157,20 @@ test_format_float(unsigned verbose, FILE *fp,
          if (first) {
             printf("Testing %s (float) ...\n",
                    desc->name);
+            fflush(stdout);
             first = FALSE;
          }
 
+         /* To ensure it's 16-byte aligned */
+         memcpy(packed, test->packed, sizeof packed);
+
          for (i = 0; i < desc->block.height; ++i) {
             for (j = 0; j < desc->block.width; ++j) {
                boolean match = TRUE;
 
                memset(unpacked, 0, sizeof unpacked);
 
-               fetch_ptr(unpacked, test->packed, j, i);
+               fetch_ptr(unpacked, packed, j, i);
 
                for(k = 0; k < 4; ++k) {
                   if (util_double_inf_sign(test->unpacked[i][j][k]) != util_inf_sign(unpacked[k])) {
@@ -194,6 +199,7 @@ test_format_float(unsigned verbose, FILE *fp,
                          test->unpacked[i][j][1],
                          test->unpacked[i][j][2],
                          test->unpacked[i][j][3]);
+                  fflush(stdout);
                   success = FALSE;
                }
             }
@@ -218,6 +224,7 @@ test_format_unorm8(unsigned verbose, FILE *fp,
    struct gallivm_state *gallivm;
    LLVMValueRef fetch = NULL;
    fetch_ptr_t fetch_ptr;
+   PIPE_ALIGN_VAR(16) uint8_t packed[UTIL_FORMAT_MAX_PACKED_BYTES];
    uint8_t unpacked[4];
    boolean first = TRUE;
    boolean success = TRUE;
@@ -244,13 +251,16 @@ test_format_unorm8(unsigned verbose, FILE *fp,
             first = FALSE;
          }
 
+         /* To ensure it's 16-byte aligned */
+         memcpy(packed, test->packed, sizeof packed);
+
          for (i = 0; i < desc->block.height; ++i) {
             for (j = 0; j < desc->block.width; ++j) {
                boolean match;
 
                memset(unpacked, 0, sizeof unpacked);
 
-               fetch_ptr(unpacked, test->packed, j, i);
+               fetch_ptr(unpacked, packed, j, i);
 
                match = TRUE;
                for(k = 0; k < 4; ++k) {
diff --git a/src/gallium/drivers/nouveau/Android.mk b/src/gallium/drivers/nouveau/Android.mk
index 5870aa0..3f6ec5b 100644
--- a/src/gallium/drivers/nouveau/Android.mk
+++ b/src/gallium/drivers/nouveau/Android.mk
@@ -32,7 +32,7 @@ LOCAL_SRC_FILES := \
 	$(C_SOURCES) \
 	$(NV30_C_SOURCES) \
 	$(NV50_CODEGEN_SOURCES) \
-	$(NV50_C_SOURES) \
+	$(NV50_C_SOURCES) \
 	$(NVC0_CODEGEN_SOURCES) \
 	$(NVC0_C_SOURCES)
 
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_screen.c b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
index 700b9bb..2b65f8c 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_screen.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_screen.c
@@ -156,6 +156,7 @@ nv30_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
    case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
    case PIPE_CAP_SAMPLER_VIEW_TARGET:
+   case PIPE_CAP_CLIP_HALFZ:
       return 0;
 
    case PIPE_CAP_VENDOR_ID:
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_screen.c b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
index d26a438..4ee5980 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_screen.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_screen.c
@@ -204,6 +204,7 @@ nv50_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_COMPUTE:
    case PIPE_CAP_DRAW_INDIRECT:
    case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
+   case PIPE_CAP_CLIP_HALFZ:
       return 0;
 
    case PIPE_CAP_VENDOR_ID:
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
index a673eb9..88fc926 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_screen.c
@@ -188,6 +188,7 @@ nvc0_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
    case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
    case PIPE_CAP_FAKE_SW_MSAA:
    case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
+   case PIPE_CAP_CLIP_HALFZ:
       return 0;
 
    case PIPE_CAP_VENDOR_ID:
diff --git a/src/gallium/drivers/r300/r300_context.h b/src/gallium/drivers/r300/r300_context.h
index 92a35d5..4d2b153 100644
--- a/src/gallium/drivers/r300/r300_context.h
+++ b/src/gallium/drivers/r300/r300_context.h
@@ -580,6 +580,7 @@ struct r300_context {
     /* Whether two-sided color selection is enabled (AKA light_twoside). */
     boolean two_sided_color;
     boolean flatshade;
+    boolean clip_halfz;
     /* Whether fast color clear is enabled. */
     boolean cbzb_clear;
     /* Whether fragment shader needs to be validated. */
diff --git a/src/gallium/drivers/r300/r300_emit.c b/src/gallium/drivers/r300/r300_emit.c
index b201334..b632963 100644
--- a/src/gallium/drivers/r300/r300_emit.c
+++ b/src/gallium/drivers/r300/r300_emit.c
@@ -1136,6 +1136,7 @@ void r300_emit_vs_state(struct r300_context* r300, unsigned size, void* state)
             R300_PVS_NUM_CNTLRS(pvs_num_controllers) |
             R300_PVS_NUM_FPUS(r300screen->caps.num_vert_fpus) |
             R300_PVS_VF_MAX_VTX_NUM(12) |
+            (r300->clip_halfz ? R300_DX_CLIP_SPACE_DEF : 0) |
             (r300screen->caps.is_r500 ? R500_TCL_STATE_OPTIMIZATION : 0));
 
     /* Emit flow control instructions.  Even if there are no fc instructions,
diff --git a/src/gallium/drivers/r300/r300_screen.c b/src/gallium/drivers/r300/r300_screen.c
index db9ad15..47616f6 100644
--- a/src/gallium/drivers/r300/r300_screen.c
+++ b/src/gallium/drivers/r300/r300_screen.c
@@ -107,6 +107,7 @@ static int r300_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
         case PIPE_CAP_USER_CONSTANT_BUFFERS:
         case PIPE_CAP_PREFER_BLIT_BASED_TEXTURE_TRANSFER:
         case PIPE_CAP_BUFFER_MAP_PERSISTENT_COHERENT:
+        case PIPE_CAP_CLIP_HALFZ:
             return 1;
 
         case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index fd67e35..cfcc19d 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1390,6 +1390,7 @@ static void r300_bind_rs_state(struct pipe_context* pipe, void* state)
     boolean last_two_sided_color = r300->two_sided_color;
     boolean last_msaa_enable = r300->msaa_enable;
     boolean last_flatshade = r300->flatshade;
+    boolean last_clip_halfz = r300->clip_halfz;
 
     if (r300->draw && rs) {
         draw_set_rasterizer_state(r300->draw, &rs->rs_draw, state);
@@ -1401,12 +1402,14 @@ static void r300_bind_rs_state(struct pipe_context* pipe, void* state)
         r300->two_sided_color = rs->rs.light_twoside;
         r300->msaa_enable = rs->rs.multisample;
         r300->flatshade = rs->rs.flatshade;
+        r300->clip_halfz = rs->rs.clip_halfz;
     } else {
         r300->polygon_offset_enabled = FALSE;
         r300->sprite_coord_enable = 0;
         r300->two_sided_color = FALSE;
         r300->msaa_enable = FALSE;
         r300->flatshade = FALSE;
+        r300->clip_halfz = FALSE;
     }
 
     UPDATE_STATE(state, r300->rs_state);
@@ -1428,6 +1431,10 @@ static void r300_bind_rs_state(struct pipe_context* pipe, void* state)
             r300->fs_status = FRAGMENT_SHADER_MAYBE_DIRTY;
         }
     }
+
+    if (last_clip_halfz != r300->clip_halfz) {
+        r300_mark_atom_dirty(r300, &r300->vs_state);
+    }
 }
 
 /* Free rasterizer state. */
diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index 78c1b68..f74dd91 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -476,6 +476,7 @@ static void *evergreen_create_rs_state(struct pipe_context *ctx,
 				S_028A0C_REPEAT_COUNT(state->line_stipple_factor) : 0;
 	rs->pa_cl_clip_cntl =
 		S_028810_PS_UCP_MODE(3) |
+		S_028810_DX_CLIP_SPACE_DEF(state->clip_halfz) |
 		S_028810_ZCLIP_NEAR_DISABLE(!state->depth_clip) |
 		S_028810_ZCLIP_FAR_DISABLE(!state->depth_clip) |
 		S_028810_DX_LINEAR_ATTR_CLIP_ENA(1) |
diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index c794530..c86daa6 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -266,6 +266,7 @@ static int r600_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
 	case PIPE_CAP_TGSI_VS_WINDOW_SPACE_POSITION:
 	case PIPE_CAP_TGSI_VS_LAYER_VIEWPORT:
 	case PIPE_CAP_SAMPLE_SHADING:
+	case PIPE_CAP_CLIP_HALFZ:
 		return 1;
 
 	case PIPE_CAP_COMPUTE:
@@ -539,8 +540,8 @@ struct pipe_screen *r600_screen_create(struct radeon_winsys *ws)
 		rscreen->b.debug_flags |= DBG_COMPUTE;
 	if (debug_get_bool_option("R600_DUMP_SHADERS", FALSE))
 		rscreen->b.debug_flags |= DBG_FS | DBG_VS | DBG_GS | DBG_PS | DBG_CS;
-	if (debug_get_bool_option("R600_HYPERZ", FALSE))
-		rscreen->b.debug_flags |= DBG_HYPERZ;
+	if (!debug_get_bool_option("R600_HYPERZ", TRUE))
+		rscreen->b.debug_flags |= DBG_NO_HYPERZ;
 	if (debug_get_bool_option("R600_LLVM", FALSE))
 		rscreen->b.debug_flags |= DBG_LLVM;
 
diff --git a/src/gallium/drivers/r600/r600_state.c b/src/gallium/drivers/r600/r600_state.c
index 1f933ef..8dc25da 100644
--- a/src/gallium/drivers/r600/r600_state.c
+++ b/src/gallium/drivers/r600/r600_state.c
@@ -461,6 +461,7 @@ static void *r600_create_rs_state(struct pipe_context *ctx,
 				S_028A0C_REPEAT_COUNT(state->line_stipple_factor) : 0;
 	rs->pa_cl_clip_cntl =
 		S_028810_PS_UCP_MODE(3) |
+		S_028810_DX_CLIP_SPACE_DEF(state->clip_halfz) |
 		S_028810_ZCLIP_NEAR_DISABLE(!state->depth_clip) |
 		S_028810_ZCLIP_FAR_DISABLE(!state->depth_clip) |
 		S_028810_DX_LINEAR_ATTR_CLIP_ENA(1);
diff --git a/src/gallium/drivers/radeon/r600_pipe_common.c b/src/gallium/drivers/radeon/r600_pipe_common.c
index ae203b6..a6dbd78 100644
--- a/src/gallium/drivers/radeon/r600_pipe_common.c
+++ b/src/gallium/drivers/radeon/r600_pipe_common.c
@@ -314,7 +314,7 @@ static const struct debug_named_value common_debug_options[] = {
 
 	/* features */
 	{ "nodma", DBG_NO_ASYNC_DMA, "Disable asynchronous DMA" },
-	{ "hyperz", DBG_HYPERZ, "Enable Hyper-Z" },
+	{ "nohyperz", DBG_NO_HYPERZ, "Disable Hyper-Z" },
 	/* GL uses the word INVALIDATE, gallium uses the word DISCARD */
 	{ "noinvalrange", DBG_NO_DISCARD_RANGE, "Disable handling of INVALIDATE_RANGE map flags" },
 	{ "no2d", DBG_NO_2D_TILING, "Disable 2D tiling" },
diff --git a/src/gallium/drivers/radeon/r600_pipe_common.h b/src/gallium/drivers/radeon/r600_pipe_common.h
index 4651bf8..dfd8fff 100644
--- a/src/gallium/drivers/radeon/r600_pipe_common.h
+++ b/src/gallium/drivers/radeon/r600_pipe_common.h
@@ -97,7 +97,7 @@
 #define DBG_CS			(1 << 9)
 /* features */
 #define DBG_NO_ASYNC_DMA	(1 << 10)
-#define DBG_HYPERZ		(1 << 11)
+#define DBG_NO_HYPERZ		(1 << 11)
 #define DBG_NO_DISCARD_RANGE	(1 << 12)
 #define DBG_NO_2D_TILING	(1 << 13)
 #define DBG_NO_TILING		(1 << 14)
diff --git a/src/gallium/drivers/radeon/r600_texture.c b/src/gallium/drivers/radeon/r600_texture.c
index 1d4e966..fdf4d76 100644
--- a/src/gallium/drivers/radeon/r600_texture.c
+++ b/src/gallium/drivers/radeon/r600_texture.c
@@ -603,7 +603,7 @@ r600_texture_create_object(struct pipe_screen *screen,
 	if (rtex->is_depth) {
 		if (!(base->flags & (R600_RESOURCE_FLAG_TRANSFER |
 				     R600_RESOURCE_FLAG_FLUSHED_DEPTH)) &&
-		    (rscreen->debug_flags & DBG_HYPERZ)) {
+		    !(rscreen->debug_flags & DBG_NO_HYPERZ)) {
 
 			r600_texture_allocate_htile(rscreen, rtex);
 		}
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index 8397115..0577cd2 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -210,6 +210,7 @@ static int si_get_param(struct pipe_screen* pscreen, enum pipe_cap param)
 	case PIPE_CAP_CUBE_MAP_ARRAY:
 	case PIPE_CAP_SAMPLE_SHADING:
 	case PIPE_CAP_DRAW_INDIRECT:
+	case PIPE_CAP_CLIP_HALFZ:
 		return 1;
 
 	case PIPE_CAP_TEXTURE_MULTISAMPLE:
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index c845df1..16d8493 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -607,6 +607,7 @@ static void *si_create_rs_state(struct pipe_context *ctx,
 		S_028814_POLYMODE_BACK_PTYPE(si_translate_fill(state->fill_back));
 	rs->pa_cl_clip_cntl =
 		S_028810_PS_UCP_MODE(3) |
+		S_028810_DX_CLIP_SPACE_DEF(state->clip_halfz) |
 		S_028810_ZCLIP_NEAR_DISABLE(!state->depth_clip) |
 		S_028810_ZCLIP_FAR_DISABLE(!state->depth_clip) |
 		S_028810_DX_RASTERIZATION_KILL(state->rasterizer_discard) |
diff --git a/src/gallium/drivers/softpipe/sp_screen.c b/src/gallium/drivers/softpipe/sp_screen.c
index a6e7fc0..47126ef 100644
--- a/src/gallium/drivers/softpipe/sp_screen.c
+++ b/src/gallium/drivers/softpipe/sp_screen.c
@@ -227,6 +227,8 @@ softpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
       return 0;
    case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
       return 1;
+   case PIPE_CAP_CLIP_HALFZ:
+      return 1;
    }
    /* should only get here on unhandled cases */
    debug_printf("Unexpected PIPE_CAP %d query\n", param);
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index 587eaad..691d9df 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -281,6 +281,7 @@ svga_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
    case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
    case PIPE_CAP_SAMPLER_VIEW_TARGET:
+   case PIPE_CAP_CLIP_HALFZ:
       return 0;
    case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
       return 64;
diff --git a/src/gallium/drivers/vc4/vc4_context.c b/src/gallium/drivers/vc4/vc4_context.c
index 87f0251..b1f0f35 100644
--- a/src/gallium/drivers/vc4/vc4_context.c
+++ b/src/gallium/drivers/vc4/vc4_context.c
@@ -350,13 +350,13 @@ vc4_pipe_flush(struct pipe_context *pctx, struct pipe_fence_handle **fence,
  *
  * This helps avoid flushing the command buffers when unnecessary.
  */
-void
-vc4_flush_for_bo(struct pipe_context *pctx, struct vc4_bo *bo)
+bool
+vc4_cl_references_bo(struct pipe_context *pctx, struct vc4_bo *bo)
 {
         struct vc4_context *vc4 = vc4_context(pctx);
 
         if (!vc4->needs_flush)
-                return;
+                return false;
 
         /* Walk all the referenced BOs in the drawing command list to see if
          * they match.
@@ -365,8 +365,7 @@ vc4_flush_for_bo(struct pipe_context *pctx, struct vc4_bo *bo)
         for (int i = 0; i < (vc4->bo_handles.next -
                              vc4->bo_handles.base) / 4; i++) {
                 if (referenced_bos[i] == bo) {
-                        vc4_flush(pctx);
-                        return;
+                        return true;
                 }
         }
 
@@ -377,8 +376,7 @@ vc4_flush_for_bo(struct pipe_context *pctx, struct vc4_bo *bo)
         if (csurf) {
                 struct vc4_resource *ctex = vc4_resource(csurf->base.texture);
                 if (ctex->bo == bo) {
-                        vc4_flush(pctx);
-                        return;
+                        return true;
                 }
         }
 
@@ -387,10 +385,11 @@ vc4_flush_for_bo(struct pipe_context *pctx, struct vc4_bo *bo)
                 struct vc4_resource *ztex =
                         vc4_resource(zsurf->base.texture);
                 if (ztex->bo == bo) {
-                        vc4_flush(pctx);
-                        return;
+                        return true;
                 }
         }
+
+        return false;
 }
 
 static void
diff --git a/src/gallium/drivers/vc4/vc4_context.h b/src/gallium/drivers/vc4/vc4_context.h
index 45dfa02..9eaff8f 100644
--- a/src/gallium/drivers/vc4/vc4_context.h
+++ b/src/gallium/drivers/vc4/vc4_context.h
@@ -79,6 +79,10 @@ struct vc4_shader_uniform_info {
 };
 
 struct vc4_uncompiled_shader {
+        /** A name for this program, so you can track it in shader-db output. */
+        uint32_t program_id;
+        /** How many variants of this program were compiled, for shader-db. */
+        uint32_t compiled_variant_count;
         struct pipe_shader_state base;
         const struct tgsi_token *twoside_tokens;
 };
@@ -183,6 +187,7 @@ struct vc4_context {
         struct primconvert_context *primconvert;
 
         struct util_hash_table *fs_cache, *vs_cache;
+        uint32_t next_uncompiled_program_id;
         uint64_t next_compiled_program_id;
 
         struct ra_regs *regs;
@@ -273,7 +278,7 @@ void vc4_write_uniforms(struct vc4_context *vc4,
                         struct vc4_texture_stateobj *texstate);
 
 void vc4_flush(struct pipe_context *pctx);
-void vc4_flush_for_bo(struct pipe_context *pctx, struct vc4_bo *bo);
+bool vc4_cl_references_bo(struct pipe_context *pctx, struct vc4_bo *bo);
 void vc4_emit_state(struct pipe_context *pctx);
 void vc4_generate_code(struct vc4_context *vc4, struct vc4_compile *c);
 struct qpu_reg *vc4_register_allocate(struct vc4_context *vc4, struct vc4_compile *c);
diff --git a/src/gallium/drivers/vc4/vc4_opt_cse.c b/src/gallium/drivers/vc4/vc4_opt_cse.c
index d3ef910..bebfb652 100644
--- a/src/gallium/drivers/vc4/vc4_opt_cse.c
+++ b/src/gallium/drivers/vc4/vc4_opt_cse.c
@@ -132,7 +132,7 @@ qir_opt_cse(struct vc4_compile *c)
         foreach_s(node, t, &c->instructions) {
                 struct qinst *inst = (struct qinst *)node;
 
-                if (qir_has_side_effects(inst)) {
+                if (qir_has_side_effects(c, inst)) {
                         if (inst->op == QOP_TLB_DISCARD_SETUP)
                                 last_sf = NULL;
                         continue;
diff --git a/src/gallium/drivers/vc4/vc4_opt_dead_code.c b/src/gallium/drivers/vc4/vc4_opt_dead_code.c
index f08818a..d958dcb 100644
--- a/src/gallium/drivers/vc4/vc4_opt_dead_code.c
+++ b/src/gallium/drivers/vc4/vc4_opt_dead_code.c
@@ -63,7 +63,7 @@ qir_opt_dead_code(struct vc4_compile *c)
 
                 if (inst->dst.file == QFILE_TEMP &&
                     !used[inst->dst.index] &&
-                    (!qir_has_side_effects(inst) ||
+                    (!qir_has_side_effects(c, inst) ||
                      inst->op == QOP_TEX_RESULT)) {
                         if (inst->op == QOP_TEX_RESULT) {
                                 dce_tex = true;
diff --git a/src/gallium/drivers/vc4/vc4_program.c b/src/gallium/drivers/vc4/vc4_program.c
index c6d9fb3..c6b7edb 100644
--- a/src/gallium/drivers/vc4/vc4_program.c
+++ b/src/gallium/drivers/vc4/vc4_program.c
@@ -114,6 +114,13 @@ add_uniform(struct vc4_compile *c,
             enum quniform_contents contents,
             uint32_t data)
 {
+        for (int i = 0; i < c->num_uniforms; i++) {
+                if (c->uniform_contents[i] == contents &&
+                    c->uniform_data[i] == data) {
+                        return (struct qreg) { QFILE_UNIF, i };
+                }
+        }
+
         uint32_t uniform = c->num_uniforms++;
         struct qreg u = { QFILE_UNIF, uniform };
 
@@ -1827,6 +1834,8 @@ vc4_shader_tgsi_to_qir(struct vc4_context *vc4, enum qstage stage,
 
         c->stage = stage;
         c->shader_state = &key->shader_state->base;
+        c->program_id = key->shader_state->program_id;
+        c->variant_id = key->shader_state->compiled_variant_count++;
 
         c->key = key;
         switch (stage) {
@@ -1874,7 +1883,9 @@ vc4_shader_tgsi_to_qir(struct vc4_context *vc4, enum qstage stage,
         assert(ret == TGSI_PARSE_OK);
 
         if (vc4_debug & VC4_DEBUG_TGSI) {
-                fprintf(stderr, "TGSI:\n");
+                fprintf(stderr, "%s prog %d/%d TGSI:\n",
+                        qir_get_stage_name(c->stage),
+                        c->program_id, c->variant_id);
                 tgsi_dump(tokens, 0);
         }
 
@@ -1918,17 +1929,23 @@ vc4_shader_tgsi_to_qir(struct vc4_context *vc4, enum qstage stage,
         qir_optimize(c);
 
         if (vc4_debug & VC4_DEBUG_QIR) {
-                fprintf(stderr, "QIR:\n");
+                fprintf(stderr, "%s prog %d/%d QIR:\n",
+                        qir_get_stage_name(c->stage),
+                        c->program_id, c->variant_id);
                 qir_dump(c);
         }
         qir_reorder_uniforms(c);
         vc4_generate_code(vc4, c);
 
         if (vc4_debug & VC4_DEBUG_SHADERDB) {
-                fprintf(stderr, "SHADER-DB: %s: %d instructions\n",
-                        qir_get_stage_name(c->stage), c->qpu_inst_count);
-                fprintf(stderr, "SHADER-DB: %s: %d uniforms\n",
-                        qir_get_stage_name(c->stage), c->num_uniforms);
+                fprintf(stderr, "SHADER-DB: %s prog %d/%d: %d instructions\n",
+                        qir_get_stage_name(c->stage),
+                        c->program_id, c->variant_id,
+                        c->qpu_inst_count);
+                fprintf(stderr, "SHADER-DB: %s prog %d/%d: %d uniforms\n",
+                        qir_get_stage_name(c->stage),
+                        c->program_id, c->variant_id,
+                        c->num_uniforms);
         }
 
         return c;
@@ -1938,6 +1955,7 @@ static void *
 vc4_shader_state_create(struct pipe_context *pctx,
                         const struct pipe_shader_state *cso)
 {
+        struct vc4_context *vc4 = vc4_context(pctx);
         struct vc4_uncompiled_shader *so = CALLOC_STRUCT(vc4_uncompiled_shader);
         if (!so)
                 return NULL;
@@ -1961,6 +1979,7 @@ vc4_shader_state_create(struct pipe_context *pctx,
         so->base.tokens = tgsi_transform_lowering(&lowering_config, cso->tokens, &info);
         if (!so->base.tokens)
                 so->base.tokens = tgsi_dup_tokens(cso->tokens);
+        so->program_id = vc4->next_uncompiled_program_id++;
 
         return so;
 }
@@ -2006,6 +2025,18 @@ vc4_get_compiled_shader(struct vc4_context *vc4, enum qstage stage,
 
         shader->program_id = vc4->next_compiled_program_id++;
         if (stage == QSTAGE_FRAG) {
+                bool input_live[c->num_input_semantics];
+                struct simple_node *node;
+
+                memset(input_live, 0, sizeof(input_live));
+                foreach(node, &c->instructions) {
+                        struct qinst *inst = (struct qinst *)node;
+                        for (int i = 0; i < qir_get_op_nsrc(inst->op); i++) {
+                                if (inst->src[i].file == QFILE_VARY)
+                                        input_live[inst->src[i].index] = true;
+                        }
+                }
+
                 shader->input_semantics = ralloc_array(shader,
                                                        struct vc4_varying_semantic,
                                                        c->num_input_semantics);
@@ -2013,6 +2044,9 @@ vc4_get_compiled_shader(struct vc4_context *vc4, enum qstage stage,
                 for (int i = 0; i < c->num_input_semantics; i++) {
                         struct vc4_varying_semantic *sem = &c->input_semantics[i];
 
+                        if (!input_live[i])
+                                continue;
+
                         /* Skip non-VS-output inputs. */
                         if (sem->semantic == (uint8_t)~0)
                                 continue;
diff --git a/src/gallium/drivers/vc4/vc4_qir.c b/src/gallium/drivers/vc4/vc4_qir.c
index 9c7c15e..a7a4d96 100644
--- a/src/gallium/drivers/vc4/vc4_qir.c
+++ b/src/gallium/drivers/vc4/vc4_qir.c
@@ -122,12 +122,23 @@ qir_get_op_nsrc(enum qop qop)
                 abort();
 }
 
+/**
+ * Returns whether the instruction has any side effects that must be
+ * preserved.
+ */
 bool
-qir_has_side_effects(struct qinst *inst)
+qir_has_side_effects(struct vc4_compile *c, struct qinst *inst)
 {
+        /* We can dead-code eliminate varyings, because we only tell the VS
+         * about the live ones at the end.  But we have to preserve the
+         * point/line coordinates reads, because they're generated by
+         * fixed-function hardware.
+         */
         for (int i = 0; i < qir_get_op_nsrc(inst->op); i++) {
-                if (inst->src[i].file == QFILE_VARY)
+                if (inst->src[i].file == QFILE_VARY &&
+                    c->input_semantics[inst->src[i].index].semantic == 0xff) {
                         return true;
+                }
         }
 
         return qir_op_info[inst->op].has_side_effects;
diff --git a/src/gallium/drivers/vc4/vc4_qir.h b/src/gallium/drivers/vc4/vc4_qir.h
index b95dbc3..077a55a 100644
--- a/src/gallium/drivers/vc4/vc4_qir.h
+++ b/src/gallium/drivers/vc4/vc4_qir.h
@@ -289,6 +289,9 @@ struct vc4_compile {
         uint32_t qpu_inst_count;
         uint32_t qpu_inst_size;
         uint32_t num_inputs;
+
+        uint32_t program_id;
+        uint32_t variant_id;
 };
 
 struct vc4_compile *qir_compile_init(void);
@@ -306,7 +309,7 @@ void qir_emit(struct vc4_compile *c, struct qinst *inst);
 struct qreg qir_get_temp(struct vc4_compile *c);
 int qir_get_op_nsrc(enum qop qop);
 bool qir_reg_equals(struct qreg a, struct qreg b);
-bool qir_has_side_effects(struct qinst *inst);
+bool qir_has_side_effects(struct vc4_compile *c, struct qinst *inst);
 bool qir_depends_on_flags(struct qinst *inst);
 bool qir_writes_r4(struct qinst *inst);
 bool qir_reads_r4(struct qinst *inst);
diff --git a/src/gallium/drivers/vc4/vc4_qpu_emit.c b/src/gallium/drivers/vc4/vc4_qpu_emit.c
index 99e634e..1d9bff3 100644
--- a/src/gallium/drivers/vc4/vc4_qpu_emit.c
+++ b/src/gallium/drivers/vc4/vc4_qpu_emit.c
@@ -30,7 +30,9 @@
 static void
 vc4_dump_program(struct vc4_compile *c)
 {
-        fprintf(stderr, "%s:\n", qir_get_stage_name(c->stage));
+        fprintf(stderr, "%s prog %d/%d QPU:\n",
+                qir_get_stage_name(c->stage),
+                c->program_id, c->variant_id);
 
         for (int i = 0; i < c->qpu_inst_count; i++) {
                 fprintf(stderr, "0x%016"PRIx64" ", c->qpu_insts[i]);
diff --git a/src/gallium/drivers/vc4/vc4_resource.c b/src/gallium/drivers/vc4/vc4_resource.c
index c198ab9..b02e289 100644
--- a/src/gallium/drivers/vc4/vc4_resource.c
+++ b/src/gallium/drivers/vc4/vc4_resource.c
@@ -34,6 +34,20 @@
 #include "vc4_tiling.h"
 
 static void
+vc4_resource_bo_alloc(struct vc4_resource *rsc)
+{
+        struct pipe_resource *prsc = &rsc->base.b;
+        struct pipe_screen *pscreen = prsc->screen;
+
+        vc4_bo_unreference(&rsc->bo);
+        rsc->bo = vc4_bo_alloc(vc4_screen(pscreen),
+                               rsc->slices[0].offset +
+                               rsc->slices[0].size +
+                               rsc->cube_map_stride * (prsc->array_size - 1),
+                               "resource");
+}
+
+static void
 vc4_resource_transfer_unmap(struct pipe_context *pctx,
                             struct pipe_transfer *ptrans)
 {
@@ -75,14 +89,21 @@ vc4_resource_transfer_map(struct pipe_context *pctx,
         char *buf;
 
         if (usage & PIPE_TRANSFER_DISCARD_WHOLE_RESOURCE) {
-                uint32_t size = rsc->bo->size;
-                vc4_bo_unreference(&rsc->bo);
-                rsc->bo = vc4_bo_alloc(vc4->screen, size, "resource");
+                vc4_resource_bo_alloc(rsc);
+        } else if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED)) {
+                if (vc4_cl_references_bo(pctx, rsc->bo)) {
+                        if ((usage & PIPE_TRANSFER_DISCARD_RANGE) &&
+                            prsc->last_level == 0 &&
+                            prsc->width0 == box->width &&
+                            prsc->height0 == box->height &&
+                            prsc->depth0 == box->depth) {
+                                vc4_resource_bo_alloc(rsc);
+                        } else {
+                                vc4_flush(pctx);
+                        }
+                }
         }
 
-        if (!(usage & PIPE_TRANSFER_UNSYNCHRONIZED))
-                vc4_flush_for_bo(pctx, rsc->bo);
-
         if (usage & PIPE_TRANSFER_WRITE)
                 rsc->writes++;
 
@@ -322,12 +343,7 @@ vc4_resource_create(struct pipe_screen *pscreen,
         }
 
         vc4_setup_slices(rsc);
-
-        rsc->bo = vc4_bo_alloc(vc4_screen(pscreen),
-                               rsc->slices[0].offset +
-                               rsc->slices[0].size +
-                               rsc->cube_map_stride * (prsc->array_size - 1),
-                               "resource");
+        vc4_resource_bo_alloc(rsc);
         if (!rsc->bo)
                 goto fail;
 
diff --git a/src/gallium/drivers/vc4/vc4_screen.c b/src/gallium/drivers/vc4/vc4_screen.c
index 4c0455d..b84b6b0 100644
--- a/src/gallium/drivers/vc4/vc4_screen.c
+++ b/src/gallium/drivers/vc4/vc4_screen.c
@@ -164,6 +164,7 @@ vc4_screen_get_param(struct pipe_screen *pscreen, enum pipe_cap param)
         case PIPE_CAP_TGSI_FS_FINE_DERIVATIVE:
         case PIPE_CAP_CONDITIONAL_RENDER_INVERTED:
         case PIPE_CAP_SAMPLER_VIEW_TARGET:
+        case PIPE_CAP_CLIP_HALFZ:
                 return 0;
 
                 /* Stream output. */
diff --git a/src/gallium/include/pipe/p_defines.h b/src/gallium/include/pipe/p_defines.h
index 42b6f37..8c4e415 100644
--- a/src/gallium/include/pipe/p_defines.h
+++ b/src/gallium/include/pipe/p_defines.h
@@ -571,6 +571,7 @@ enum pipe_cap {
    PIPE_CAP_CONDITIONAL_RENDER_INVERTED = 108,
    PIPE_CAP_MAX_VERTEX_ATTRIB_STRIDE = 109,
    PIPE_CAP_SAMPLER_VIEW_TARGET = 110,
+   PIPE_CAP_CLIP_HALFZ = 111,
 };
 
 #define PIPE_QUIRK_TEXTURE_BORDER_COLOR_SWIZZLE_NV50 (1 << 0)
diff --git a/src/gallium/state_trackers/clover/llvm/invocation.cpp b/src/gallium/state_trackers/clover/llvm/invocation.cpp
index 7c31008..e953822 100644
--- a/src/gallium/state_trackers/clover/llvm/invocation.cpp
+++ b/src/gallium/state_trackers/clover/llvm/invocation.cpp
@@ -36,17 +36,11 @@
 #include <llvm/IR/DiagnosticInfo.h>
 #include <llvm/IR/DiagnosticPrinter.h>
 #endif
-#if HAVE_LLVM < 0x0303
-#include <llvm/DerivedTypes.h>
-#include <llvm/LLVMContext.h>
-#include <llvm/Module.h>
-#else
 #include <llvm/IR/DerivedTypes.h>
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/IR/Module.h>
 #include <llvm/Support/SourceMgr.h>
 #include <llvm/IRReader/IRReader.h>
-#endif
 #if HAVE_LLVM < 0x0305
 #include <llvm/ADT/OwningPtr.h>
 #endif
@@ -54,9 +48,6 @@
 #include <llvm/Support/CodeGen.h>
 #include <llvm/Support/TargetSelect.h>
 #include <llvm/Support/MemoryBuffer.h>
-#if HAVE_LLVM < 0x0303
-#include <llvm/Support/PathV1.h>
-#endif
 #include <llvm/Support/FormattedStream.h>
 #include <llvm/Support/TargetRegistry.h>
 #include <llvm/Transforms/IPO.h>
@@ -64,13 +55,7 @@
 #include <llvm/Transforms/Utils/Cloning.h>
 
 
-#if HAVE_LLVM < 0x0302
-#include <llvm/Target/TargetData.h>
-#elif HAVE_LLVM < 0x0303
-#include <llvm/DataLayout.h>
-#else
 #include <llvm/IR/DataLayout.h>
-#endif
 #include <llvm/Target/TargetLibraryInfo.h>
 #include <llvm/Target/TargetMachine.h>
 #include <llvm/Target/TargetOptions.h>
@@ -203,9 +188,6 @@ namespace {
       c.getHeaderSearchOpts().AddPath(LIBCLC_INCLUDEDIR,
                                       clang::frontend::Angled,
                                       false, false
-#if HAVE_LLVM < 0x0303
-                                      , false
-#endif
                                       );
 
       // Add libclc include
@@ -223,23 +205,12 @@ namespace {
       // of warnings and errors to be printed to stderr.
       // http://www.llvm.org/bugs/show_bug.cgi?id=19735
       c.getDiagnosticOpts().ShowCarets = false;
-#if HAVE_LLVM <= 0x0301
-      c.getInvocation().setLangDefaults(clang::IK_OpenCL);
-#else
       c.getInvocation().setLangDefaults(c.getLangOpts(), clang::IK_OpenCL,
                                         clang::LangStandard::lang_opencl11);
-#endif
       c.createDiagnostics(
-#if HAVE_LLVM < 0x0303
-                          0, NULL,
-#endif
                           new clang::TextDiagnosticPrinter(
                                  s_log,
-#if HAVE_LLVM <= 0x0301
-                                 c.getDiagnosticOpts()));
-#else
                                  &c.getDiagnosticOpts()));
-#endif
 
 #if HAVE_LLVM >= 0x0306
       c.getPreprocessorOpts().addRemappedFile(name,
@@ -255,9 +226,6 @@ namespace {
          c.getHeaderSearchOpts().AddPath(tmp_header_path,
                                          clang::frontend::Angled,
                                          false, false
-#if HAVE_LLVM < 0x0303
-                                         , false
-#endif
                                          );
 
          for (header_map::const_iterator it = headers.begin();
@@ -368,9 +336,7 @@ namespace {
       compat::vector<module::argument> args;
       llvm::Function *kernel_func = mod->getFunction(kernel_name);
 
-#if HAVE_LLVM < 0x0302
-         llvm::TargetData TD(kernel_func->getParent());
-#elif HAVE_LLVM < 0x0305
+#if HAVE_LLVM < 0x0305
          llvm::DataLayout TD(kernel_func->getParent()->getDataLayout());
 #else
          llvm::DataLayout TD(mod);
diff --git a/src/gallium/state_trackers/clover/util/compat.hpp b/src/gallium/state_trackers/clover/util/compat.hpp
index a52a6af..735994f 100644
--- a/src/gallium/state_trackers/clover/util/compat.hpp
+++ b/src/gallium/state_trackers/clover/util/compat.hpp
@@ -417,8 +417,8 @@ namespace clover {
          pair(T first, S second) :
             first(first), second(second) {}
 
-         S first;
-         T second;
+         T first;
+         S second;
       };
 
       class exception {
diff --git a/src/gallium/state_trackers/wgl/stw_pixelformat.c b/src/gallium/state_trackers/wgl/stw_pixelformat.c
index 96169e2..b0cd5ab 100644
--- a/src/gallium/state_trackers/wgl/stw_pixelformat.c
+++ b/src/gallium/state_trackers/wgl/stw_pixelformat.c
@@ -303,7 +303,7 @@ stw_pixelformat_get_extended_count( void )
 const struct stw_pixelformat_info *
 stw_pixelformat_get_info( int iPixelFormat )
 {
-   int index;
+   unsigned index;
 
    if (iPixelFormat <= 0) {
       return NULL;
diff --git a/src/glsl/ast_array_index.cpp b/src/glsl/ast_array_index.cpp
index 49a8574..ff0c757 100644
--- a/src/glsl/ast_array_index.cpp
+++ b/src/glsl/ast_array_index.cpp
@@ -49,12 +49,12 @@ ast_array_specifier::print(void) const
  * loc and state to report the error.
  */
 static void
-update_max_array_access(ir_rvalue *ir, unsigned idx, YYLTYPE *loc,
+update_max_array_access(ir_rvalue *ir, int idx, YYLTYPE *loc,
                         struct _mesa_glsl_parse_state *state)
 {
    if (ir_dereference_variable *deref_var = ir->as_dereference_variable()) {
       ir_variable *var = deref_var->var;
-      if (idx > var->data.max_array_access) {
+      if (idx > (int)var->data.max_array_access) {
          var->data.max_array_access = idx;
 
          /* Check whether this access will, as a side effect, implicitly cause
@@ -94,7 +94,7 @@ update_max_array_access(ir_rvalue *ir, unsigned idx, YYLTYPE *loc,
 
             assert(max_ifc_array_access != NULL);
 
-            if (idx > max_ifc_array_access[field_index]) {
+            if (idx > (int)max_ifc_array_access[field_index]) {
                max_ifc_array_access[field_index] = idx;
 
                /* Check whether this access will, as a side effect, implicitly
diff --git a/src/glsl/linker.cpp b/src/glsl/linker.cpp
index 47a722d..2d31801 100644
--- a/src/glsl/linker.cpp
+++ b/src/glsl/linker.cpp
@@ -1679,7 +1679,7 @@ link_intrastage_shaders(void *mem_ctx,
 
    populate_symbol_table(linked);
 
-   /* The a pointer to the main function in the final linked shader (i.e., the
+   /* The pointer to the main function in the final linked shader (i.e., the
     * copy of the original shader that contained the main function).
     */
    ir_function_signature *const main_sig =
@@ -1882,7 +1882,7 @@ find_available_slots(unsigned used_mask, unsigned needed_count)
 
 
 /**
- * Assign locations for either VS inputs for FS outputs
+ * Assign locations for either VS inputs or FS outputs
  *
  * \param prog          Shader program whose variables need locations assigned
  * \param target_index  Selector for the program target to receive location
@@ -2484,20 +2484,6 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
    prog->Validated = false;
    prog->_Used = false;
 
-   ralloc_free(prog->InfoLog);
-   prog->InfoLog = ralloc_strdup(NULL, "");
-
-   ralloc_free(prog->UniformBlocks);
-   prog->UniformBlocks = NULL;
-   prog->NumUniformBlocks = 0;
-   for (int i = 0; i < MESA_SHADER_STAGES; i++) {
-      ralloc_free(prog->UniformBlockStageIndex[i]);
-      prog->UniformBlockStageIndex[i] = NULL;
-   }
-
-   ralloc_free(prog->AtomicBuffers);
-   prog->AtomicBuffers = NULL;
-   prog->NumAtomicBuffers = 0;
    prog->ARB_fragment_coord_conventions_enable = false;
 
    /* Separate the shaders into groups based on their type.
diff --git a/src/glsl/lower_offset_array.cpp b/src/glsl/lower_offset_array.cpp
index 5b48526..c30f801 100644
--- a/src/glsl/lower_offset_array.cpp
+++ b/src/glsl/lower_offset_array.cpp
@@ -22,7 +22,7 @@
  */
 
 /**
- * \file brw_lower_offset_array.cpp
+ * \file lower_offset_array.cpp
  *
  * IR lower pass to decompose ir_texture ir_tg4 with an array of offsets
  * into four ir_tg4s with a single ivec2 offset, select the .w component of each,
@@ -39,9 +39,9 @@
 
 using namespace ir_builder;
 
-class brw_lower_offset_array_visitor : public ir_rvalue_visitor {
+class lower_offset_array_visitor : public ir_rvalue_visitor {
 public:
-   brw_lower_offset_array_visitor()
+   lower_offset_array_visitor()
    {
       progress = false;
    }
@@ -52,7 +52,7 @@ public:
 };
 
 void
-brw_lower_offset_array_visitor::handle_rvalue(ir_rvalue **rv)
+lower_offset_array_visitor::handle_rvalue(ir_rvalue **rv)
 {
    if (*rv == NULL || (*rv)->ir_type != ir_type_texture)
       return;
@@ -83,7 +83,7 @@ brw_lower_offset_array_visitor::handle_rvalue(ir_rvalue **rv)
 bool
 lower_offset_arrays(exec_list *instructions)
 {
-   brw_lower_offset_array_visitor v;
+   lower_offset_array_visitor v;
 
    visit_list_elements(&v, instructions);
 
diff --git a/src/glsl/main.cpp b/src/glsl/main.cpp
index feed100..9b36a1f 100644
--- a/src/glsl/main.cpp
+++ b/src/glsl/main.cpp
@@ -403,6 +403,8 @@ main(int argc, char **argv)
    }
 
    if ((status == EXIT_SUCCESS) && do_link)  {
+      _mesa_clear_shader_program_data(whole_program);
+
       link_shaders(ctx, whole_program);
       status = (whole_program->LinkStatus) ? EXIT_SUCCESS : EXIT_FAILURE;
 
diff --git a/src/glsl/opt_array_splitting.cpp b/src/glsl/opt_array_splitting.cpp
index ebb076b..9e73f3c 100644
--- a/src/glsl/opt_array_splitting.cpp
+++ b/src/glsl/opt_array_splitting.cpp
@@ -295,7 +295,7 @@ ir_array_splitting_visitor::split_deref(ir_dereference **deref)
    ir_constant *constant = deref_array->array_index->as_constant();
    assert(constant);
 
-   if (constant->value.i[0] < (int)entry->size) {
+   if (constant->value.i[0] >= 0 && constant->value.i[0] < (int)entry->size) {
       *deref = new(entry->mem_ctx)
 	 ir_dereference_variable(entry->components[constant->value.i[0]]);
    } else {
diff --git a/src/glsl/standalone_scaffolding.cpp b/src/glsl/standalone_scaffolding.cpp
index 2b76dd1..67b0d0c 100644
--- a/src/glsl/standalone_scaffolding.cpp
+++ b/src/glsl/standalone_scaffolding.cpp
@@ -83,6 +83,33 @@ _mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type)
    return shader;
 }
 
+void
+_mesa_clear_shader_program_data(struct gl_shader_program *shProg)
+{
+   unsigned i;
+
+   shProg->NumUserUniformStorage = 0;
+   shProg->UniformStorage = NULL;
+   shProg->NumUniformRemapTable = 0;
+   shProg->UniformRemapTable = NULL;
+   shProg->UniformHash = NULL;
+
+   ralloc_free(shProg->InfoLog);
+   shProg->InfoLog = ralloc_strdup(shProg, "");
+
+   ralloc_free(shProg->UniformBlocks);
+   shProg->UniformBlocks = NULL;
+   shProg->NumUniformBlocks = 0;
+   for (i = 0; i < MESA_SHADER_STAGES; i++) {
+      ralloc_free(shProg->UniformBlockStageIndex[i]);
+      shProg->UniformBlockStageIndex[i] = NULL;
+   }
+
+   ralloc_free(shProg->AtomicBuffers);
+   shProg->AtomicBuffers = NULL;
+   shProg->NumAtomicBuffers = 0;
+}
+
 void initialize_context_to_defaults(struct gl_context *ctx, gl_api api)
 {
    memset(ctx, 0, sizeof(*ctx));
diff --git a/src/glsl/standalone_scaffolding.h b/src/glsl/standalone_scaffolding.h
index df783af..895dd27 100644
--- a/src/glsl/standalone_scaffolding.h
+++ b/src/glsl/standalone_scaffolding.h
@@ -45,6 +45,9 @@ extern "C" struct gl_shader *
 _mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type);
 
 extern "C" void
+_mesa_clear_shader_program_data(struct gl_shader_program *);
+
+extern "C" void
 _mesa_shader_debug(struct gl_context *ctx, GLenum type, GLuint *id,
                    const char *msg, int len);
 
diff --git a/src/mapi/glapi/gen/ARB_clip_control.xml b/src/mapi/glapi/gen/ARB_clip_control.xml
new file mode 100644
index 0000000..2973a31
--- /dev/null
+++ b/src/mapi/glapi/gen/ARB_clip_control.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0"?>
+<!DOCTYPE OpenGLAPI SYSTEM "gl_API.dtd">
+
+<OpenGLAPI>
+
+<category name="GL_ARB_clip_control" number="160">
+
+    <enum name="LOWER_LEFT" value = "0x8CA1"/>
+    <enum name="UPPER_LEFT" value = "0x8CA2"/>
+
+    <enum name="NEGATIVE_ONE_TO_ONE" value = "0x935E"/>
+    <enum name="ZERO_TO_ONE" value = "0x935F"/>
+
+    <enum name="CLIP_ORIGIN" value = "0x935C"/>
+    <enum name="CLIP_DEPTH_MODE" value = "0x935D"/>
+
+    <function name="ClipControl" offset="assign">
+        <param name="origin" type="GLenum"/>
+        <param name="depth" type="GLenum"/>
+        <glx rop="1340"/>
+    </function>
+
+</category>
+
+</OpenGLAPI>
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 73f2f75..534e6a0 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -8364,7 +8364,9 @@
 
 <xi:include href="ARB_multi_bind.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
 
-<!-- ARB extensions 148 - 160 -->
+<!-- ARB extensions 148 - 159 -->
+
+<xi:include href="ARB_clip_control.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
 
 <category name="GL_ARB_conditional_render_inverted" number="161">
     <enum name="QUERY_WAIT_INVERTED"                      value="0x8E17"/>
diff --git a/src/mapi/glapi/gen/gl_gentable.py b/src/mapi/glapi/gen/gl_gentable.py
index deffcee..06a5ebf 100644
--- a/src/mapi/glapi/gen/gl_gentable.py
+++ b/src/mapi/glapi/gen/gl_gentable.py
@@ -100,7 +100,7 @@ static void
 __glapi_gentable_set_remaining_noop(struct _glapi_table *disp) {
     GLuint entries = _glapi_get_dispatch_table_size();
     void **dispatch = (void **) disp;
-    int i;
+    unsigned i;
 
     /* ISO C is annoying sometimes */
     union {_glapi_proc p; void *v;} p;
@@ -147,7 +147,7 @@ class PrintCode(gl_XML.gl_print_base):
     def __init__(self):
         gl_XML.gl_print_base.__init__(self)
 
-        self.name = "gl_gen_table.py (from Mesa)"
+        self.name = "gl_gentable.py (from Mesa)"
         self.license = license.bsd_license_template % ( \
 """Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
 (C) Copyright IBM Corporation 2004, 2005
diff --git a/src/mesa/drivers/common/meta.c b/src/mesa/drivers/common/meta.c
index 7a8e627..87532c1 100644
--- a/src/mesa/drivers/common/meta.c
+++ b/src/mesa/drivers/common/meta.c
@@ -680,6 +680,12 @@ _mesa_meta_begin(struct gl_context *ctx, GLbitfield state)
          _mesa_Ortho(0.0, ctx->DrawBuffer->Width,
                      0.0, ctx->DrawBuffer->Height,
                      -1.0, 1.0);
+
+      if (ctx->Extensions.ARB_clip_control) {
+         save->ClipOrigin = ctx->Transform.ClipOrigin;
+         save->ClipDepthMode = ctx->Transform.ClipDepthMode;
+         _mesa_ClipControl(GL_LOWER_LEFT, GL_NEGATIVE_ONE_TO_ONE);
+      }
    }
 
    if (state & MESA_META_CLIP) {
@@ -1081,6 +1087,9 @@ _mesa_meta_end(struct gl_context *ctx)
       _mesa_LoadMatrixf(save->ProjectionMatrix);
 
       _mesa_MatrixMode(save->MatrixMode);
+
+      if (ctx->Extensions.ARB_clip_control)
+         _mesa_ClipControl(save->ClipOrigin, save->ClipDepthMode);
    }
 
    if (state & MESA_META_CLIP) {
diff --git a/src/mesa/drivers/common/meta.h b/src/mesa/drivers/common/meta.h
index 2c9517b..6ecf3c0 100644
--- a/src/mesa/drivers/common/meta.h
+++ b/src/mesa/drivers/common/meta.h
@@ -136,6 +136,9 @@ struct save_state
    GLfloat ModelviewMatrix[16];
    GLfloat ProjectionMatrix[16];
    GLfloat TextureMatrix[16];
+   /** GL_ARB_clip_control */
+   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
+   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
 
    /** MESA_META_CLIP */
    GLbitfield ClipPlanesEnabled;
diff --git a/src/mesa/drivers/dri/i915/i915_state.c b/src/mesa/drivers/dri/i915/i915_state.c
index f31b271..f9aecba 100644
--- a/src/mesa/drivers/dri/i915/i915_state.c
+++ b/src/mesa/drivers/dri/i915/i915_state.c
@@ -34,6 +34,7 @@
 #include "main/dd.h"
 #include "main/state.h"
 #include "main/stencil.h"
+#include "main/viewport.h"
 #include "tnl/tnl.h"
 #include "tnl/t_context.h"
 
@@ -401,26 +402,17 @@ void
 intelCalcViewport(struct gl_context * ctx)
 {
    struct intel_context *intel = intel_context(ctx);
+   double scale[3], translate[3];
+
+   _mesa_get_viewport_xform(ctx, 0, scale, translate);
 
    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
-      _math_matrix_viewport(&intel->ViewportMatrix,
-			    ctx->ViewportArray[0].X,
-			    ctx->DrawBuffer->Height - ctx->ViewportArray[0].Y,
-			    ctx->ViewportArray[0].Width,
-			    -ctx->ViewportArray[0].Height,
-			    ctx->ViewportArray[0].Near,
-			    ctx->ViewportArray[0].Far,
-			    1.0);
-   } else {
-      _math_matrix_viewport(&intel->ViewportMatrix,
-			    ctx->ViewportArray[0].X,
-			    ctx->ViewportArray[0].Y,
-			    ctx->ViewportArray[0].Width,
-			    ctx->ViewportArray[0].Height,
-			    ctx->ViewportArray[0].Near,
-			    ctx->ViewportArray[0].Far,
-			    1.0);
+      scale[1] = -scale[1];
+      translate[1] = ctx->DrawBuffer->Height - translate[1];
    }
+
+   _math_matrix_viewport(&intel->ViewportMatrix,
+                         scale, translate, 1.0);
 }
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 8b3f45b..e1a994a 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -814,7 +814,7 @@ brwCreateContext(gl_api api,
    brw->max_gtt_map_object_size = gtt_size / 4;
 
    if (brw->gen == 6)
-      brw->urb.gen6_gs_previously_active = false;
+      brw->urb.gs_present = false;
 
    brw->prim_restart.in_progress = false;
    brw->prim_restart.enable_cut_index = false;
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index 45d72d2..eb37e75 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -1169,6 +1169,7 @@ struct brw_context
     */
    struct {
       GLuint vsize;		/* vertex size plus header in urb registers */
+      GLuint gsize;	        /* GS output size in urb registers */
       GLuint csize;		/* constant buffer size in urb registers */
       GLuint sfsize;		/* setup data size in urb registers */
 
@@ -1191,10 +1192,10 @@ struct brw_context
       GLuint cs_start;
       GLuint size; /* Hardware URB size, in KB. */
 
-      /* gen6: True if the most recently sent _3DSTATE_URB message allocated
+      /* True if the most recently sent _3DSTATE_URB message allocated
        * URB space for the GS.
        */
-      bool gen6_gs_previously_active;
+      bool gs_present;
    } urb;
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs.cpp b/src/mesa/drivers/dri/i965/brw_fs.cpp
index e941c58..aa1d8d2 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs.cpp
@@ -2601,6 +2601,7 @@ fs_visitor::emit_repclear_shader()
       write->header_present = false;
       write->mlen = 1;
    } else {
+      assume(key->nr_color_regions > 0);
       for (int i = 0; i < key->nr_color_regions; ++i) {
          write = emit(FS_OPCODE_REP_FB_WRITE);
          write->saturate = key->clamp_fragment_color;
@@ -3696,7 +3697,7 @@ brw_wm_fs_emit(struct brw_context *brw,
       shader = (brw_shader *) prog->_LinkedShaders[MESA_SHADER_FRAGMENT];
 
    if (unlikely(INTEL_DEBUG & DEBUG_WM))
-      brw_dump_ir(brw, "fragment", prog, &shader->base, &fp->Base);
+      brw_dump_ir("fragment", prog, &shader->base, &fp->Base);
 
    /* Now the main event: Visit the shader IR and generate our FS IR for it.
     */
diff --git a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
index 65a09a0..7ae6c75 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
@@ -102,7 +102,7 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
     * regs).
     */
    int class_count;
-   int class_sizes[BRW_MAX_MRF];
+   int class_sizes[MAX_VGRF_SIZE];
 
    if (devinfo->gen >= 7) {
       for (class_count = 0; class_count < MAX_VGRF_SIZE; class_count++)
@@ -152,6 +152,13 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
    int *classes = ralloc_array(screen, int, class_count);
    int aligned_pairs_class = -1;
 
+   /* Allocate space for q values.  We allocate class_count + 1 because we
+    * want to leave room for the aligned pairs class if we have it. */
+   unsigned int **q_values = ralloc_array(screen, unsigned int *,
+                                          class_count + 1);
+   for (int i = 0; i < class_count + 1; ++i)
+      q_values[i] = ralloc_array(q_values, unsigned int, class_count + 1);
+
    /* Now, add the registers to their classes, and add the conflicts
     * between them and the base GRF registers (and also each other).
     */
@@ -162,8 +169,41 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
       int class_reg_count;
       if (devinfo->gen <= 5 && reg_width == 2) {
          class_reg_count = (base_reg_count - (class_sizes[i] - 1)) / 2;
+
+         /* See comment below.  The only difference here is that we are
+          * dealing with pairs of registers instead of single registers.
+          * Registers of odd sizes simply get rounded up. */
+         for (int j = 0; j < class_count; j++)
+            q_values[i][j] = (class_sizes[i] + 1) / 2 +
+                             (class_sizes[j] + 1) / 2 - 1;
       } else {
          class_reg_count = base_reg_count - (class_sizes[i] - 1);
+
+         /* From register_allocate.c:
+          *
+          * q(B,C) (indexed by C, B is this register class) in
+          * Runeson/Nyström paper.  This is "how many registers of B could
+          * the worst choice register from C conflict with".
+          *
+          * If we just let the register allocation algorithm compute these
+          * values, is extremely expensive.  However, since all of our
+          * registers are laid out, we can very easily compute them
+          * ourselves.  View the register from C as fixed starting at GRF n
+          * somwhere in the middle, and the register from B as sliding back
+          * and forth.  Then the first register to conflict from B is the
+          * one starting at n - class_size[B] + 1 and the last register to
+          * conflict will start at n + class_size[B] - 1.  Therefore, the
+          * number of conflicts from B is class_size[B] + class_size[C] - 1.
+          *
+          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
+          * B | | | | | |n| --> | | | | | | |
+          *   +-+-+-+-+-+-+     +-+-+-+-+-+-+
+          *             +-+-+-+-+-+
+          * C           |n| | | | |
+          *             +-+-+-+-+-+
+          */
+         for (int j = 0; j < class_count; j++)
+            q_values[i][j] = class_sizes[i] + class_sizes[j] - 1;
       }
       classes[i] = ra_alloc_reg_class(regs);
 
@@ -179,8 +219,8 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
 
             ra_reg_to_grf[reg] = j * 2;
 
-            for (int base_reg = j * 2;
-                 base_reg < j * 2 + class_sizes[i];
+            for (int base_reg = j;
+                 base_reg < j + (class_sizes[i] + 1) / 2;
                  base_reg++) {
                ra_add_transitive_reg_conflict(regs, base_reg, reg);
             }
@@ -208,7 +248,7 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
    /* Add a special class for aligned pairs, which we'll put delta_x/y
     * in on gen5 so that we can do PLN.
     */
-   if (devinfo->has_pln && devinfo->gen < 6) {
+   if (devinfo->has_pln && reg_width == 1 && devinfo->gen < 6) {
       aligned_pairs_class = ra_alloc_reg_class(regs);
 
       for (int i = 0; i < pairs_reg_count; i++) {
@@ -216,9 +256,23 @@ brw_alloc_reg_set(struct intel_screen *screen, int reg_width)
 	    ra_class_add_reg(regs, aligned_pairs_class, pairs_base_reg + i);
 	 }
       }
+
+      for (int i = 0; i < class_count; i++) {
+         /* These are a little counter-intuitive because the pair registers
+          * are required to be aligned while the register they are
+          * potentially interferring with are not.  In the case where the
+          * size is even, the worst-case is that the register is
+          * odd-aligned.  In the odd-size case, it doesn't matter.
+          */
+         q_values[class_count][i] = class_sizes[i] / 2 + 1;
+         q_values[i][class_count] = class_sizes[i] + 1;
+      }
+      q_values[class_count][class_count] = 1;
    }
 
-   ra_set_finalize(regs, NULL);
+   ra_set_finalize(regs, q_values);
+
+   ralloc_free(q_values);
 
    screen->wm_reg_sets[index].regs = regs;
    for (unsigned i = 0; i < ARRAY_SIZE(screen->wm_reg_sets[index].classes); i++)
@@ -390,7 +444,16 @@ fs_visitor::setup_payload_interference(struct ra_graph *g,
        * The alternative would be to have per-physical-register classes, which
        * would just be silly.
        */
-      ra_set_node_reg(g, first_payload_node + i, i);
+      if (brw->intelScreen->devinfo->gen <= 5 && dispatch_width == 16) {
+         /* We have to divide by 2 here because we only have even numbered
+          * registers.  Some of the payload registers will be odd, but
+          * that's ok because their physical register numbers have already
+          * been assigned.  The only thing this is used for is interference.
+          */
+         ra_set_node_reg(g, first_payload_node + i, i / 2);
+      } else {
+         ra_set_node_reg(g, first_payload_node + i, i);
+      }
    }
 }
 
diff --git a/src/mesa/drivers/dri/i965/brw_program.c b/src/mesa/drivers/dri/i965/brw_program.c
index b37da4e..17edb09 100644
--- a/src/mesa/drivers/dri/i965/brw_program.c
+++ b/src/mesa/drivers/dri/i965/brw_program.c
@@ -120,14 +120,6 @@ static void brwDeleteProgram( struct gl_context *ctx,
 
 
 static GLboolean
-brwIsProgramNative(struct gl_context *ctx,
-		   GLenum target,
-		   struct gl_program *prog)
-{
-   return true;
-}
-
-static GLboolean
 brwProgramStringNotify(struct gl_context *ctx,
 		       GLenum target,
 		       struct gl_program *prog)
@@ -233,11 +225,9 @@ void brwInitFragProgFuncs( struct dd_function_table *functions )
 
    functions->NewProgram = brwNewProgram;
    functions->DeleteProgram = brwDeleteProgram;
-   functions->IsProgramNative = brwIsProgramNative;
    functions->ProgramStringNotify = brwProgramStringNotify;
 
    functions->NewShader = brw_new_shader;
-   functions->NewShaderProgram = brw_new_shader_program;
    functions->LinkShader = brw_link_shader;
 }
 
@@ -565,8 +555,7 @@ brw_stage_prog_data_free(const void *p)
 }
 
 void
-brw_dump_ir(struct brw_context *brw, const char *stage,
-            struct gl_shader_program *shader_prog,
+brw_dump_ir(const char *stage, struct gl_shader_program *shader_prog,
             struct gl_shader *shader, struct gl_program *prog)
 {
    if (shader_prog) {
diff --git a/src/mesa/drivers/dri/i965/brw_program.h b/src/mesa/drivers/dri/i965/brw_program.h
index a8650c3..672777f 100644
--- a/src/mesa/drivers/dri/i965/brw_program.h
+++ b/src/mesa/drivers/dri/i965/brw_program.h
@@ -82,8 +82,7 @@ void
 brw_stage_prog_data_free(const void *prog_data);
 
 void
-brw_dump_ir(struct brw_context *brw, const char *stage,
-            struct gl_shader_program *shader_prog,
+brw_dump_ir(const char *stage, struct gl_shader_program *shader_prog,
             struct gl_shader *shader, struct gl_program *prog);
 
 #ifdef __cplusplus
diff --git a/src/mesa/drivers/dri/i965/brw_shader.cpp b/src/mesa/drivers/dri/i965/brw_shader.cpp
index 935514c..21dcf2d 100644
--- a/src/mesa/drivers/dri/i965/brw_shader.cpp
+++ b/src/mesa/drivers/dri/i965/brw_shader.cpp
@@ -49,17 +49,6 @@ brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type)
    return &shader->base;
 }
 
-struct gl_shader_program *
-brw_new_shader_program(struct gl_context *ctx, GLuint name)
-{
-   struct gl_shader_program *prog = rzalloc(NULL, struct gl_shader_program);
-   if (prog) {
-      prog->Name = name;
-      _mesa_init_shader_program(ctx, prog);
-   }
-   return prog;
-}
-
 /**
  * Performs a compile of the shader stages even when we don't know
  * what non-orthogonal state will be set, in the hope that it reflects
diff --git a/src/mesa/drivers/dri/i965/brw_vec4.cpp b/src/mesa/drivers/dri/i965/brw_vec4.cpp
index 46aa7d5..df589b8 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4.cpp
@@ -1875,7 +1875,7 @@ brw_vs_emit(struct brw_context *brw,
       shader = (brw_shader *) prog->_LinkedShaders[MESA_SHADER_VERTEX];
 
    if (unlikely(INTEL_DEBUG & DEBUG_VS))
-      brw_dump_ir(brw, "vertex", prog, &shader->base, &c->vp->program.Base);
+      brw_dump_ir("vertex", prog, &shader->base, &c->vp->program.Base);
 
    vec4_vs_visitor v(brw, c, prog_data, prog, mem_ctx);
    if (!v.run()) {
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp b/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
index c569e0a..db0e6cc 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
@@ -632,7 +632,7 @@ brw_gs_emit(struct brw_context *brw,
       struct brw_shader *shader =
          (brw_shader *) prog->_LinkedShaders[MESA_SHADER_GEOMETRY];
 
-      brw_dump_ir(brw, "geometry", prog, &shader->base, NULL);
+      brw_dump_ir("geometry", prog, &shader->base, NULL);
    }
 
    if (brw->gen >= 7) {
diff --git a/src/mesa/drivers/dri/i965/brw_wm.h b/src/mesa/drivers/dri/i965/brw_wm.h
index 77a3644..0e0039b 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.h
+++ b/src/mesa/drivers/dri/i965/brw_wm.h
@@ -96,7 +96,6 @@ const unsigned *brw_wm_fs_emit(struct brw_context *brw,
 
 GLboolean brw_link_shader(struct gl_context *ctx, struct gl_shader_program *prog);
 struct gl_shader *brw_new_shader(struct gl_context *ctx, GLuint name, GLuint type);
-struct gl_shader_program *brw_new_shader_program(struct gl_context *ctx, GLuint name);
 
 bool brw_color_buffer_write_enabled(struct brw_context *brw);
 bool do_wm_prog(struct brw_context *brw,
diff --git a/src/mesa/drivers/dri/i965/gen6_urb.c b/src/mesa/drivers/dri/i965/gen6_urb.c
index 7af1f37..46cc4cc2 100644
--- a/src/mesa/drivers/dri/i965/gen6_urb.c
+++ b/src/mesa/drivers/dri/i965/gen6_urb.c
@@ -119,9 +119,9 @@ gen6_upload_urb( struct brw_context *brw )
     * doesn't exist on Gen6).  So for now we just do a full pipeline flush as
     * a workaround.
     */
-   if (brw->urb.gen6_gs_previously_active && !gs_present)
+   if (brw->urb.gs_present && !gs_present)
       intel_batchbuffer_emit_mi_flush(brw);
-   brw->urb.gen6_gs_previously_active = gs_present;
+   brw->urb.gs_present = gs_present;
 }
 
 const struct brw_tracked_state gen6_urb = {
diff --git a/src/mesa/drivers/dri/i965/gen7_urb.c b/src/mesa/drivers/dri/i965/gen7_urb.c
index 190d6f0..eb3784a 100644
--- a/src/mesa/drivers/dri/i965/gen7_urb.c
+++ b/src/mesa/drivers/dri/i965/gen7_urb.c
@@ -150,6 +150,19 @@ gen7_upload_urb(struct brw_context *brw)
    unsigned gs_size = gs_present ? brw->gs.prog_data->base.urb_entry_size : 1;
    unsigned gs_entry_size_bytes = gs_size * 64;
 
+   /* If we're just switching between programs with the same URB requirements,
+    * skip the rest of the logic.
+    */
+   if (!(brw->state.dirty.brw & BRW_NEW_CONTEXT) &&
+       brw->urb.vsize == vs_size &&
+       brw->urb.gs_present == gs_present &&
+       brw->urb.gsize == gs_size) {
+      return;
+   }
+   brw->urb.vsize = vs_size;
+   brw->urb.gs_present = gs_present;
+   brw->urb.gsize = gs_size;
+
    /* From p35 of the Ivy Bridge PRM (section 1.7.1: 3DSTATE_URB_GS):
     *
     *     VS Number of URB Entries must be divisible by 8 if the VS URB Entry
diff --git a/src/mesa/drivers/dri/i965/intel_buffer_objects.c b/src/mesa/drivers/dri/i965/intel_buffer_objects.c
index b4eb076..a7242b0 100644
--- a/src/mesa/drivers/dri/i965/intel_buffer_objects.c
+++ b/src/mesa/drivers/dri/i965/intel_buffer_objects.c
@@ -476,9 +476,8 @@ intel_bufferobj_flush_mapped_range(struct gl_context *ctx,
 {
    struct brw_context *brw = brw_context(ctx);
    struct intel_buffer_object *intel_obj = intel_buffer_object(obj);
-   GLbitfield access = obj->Mappings[index].AccessFlags;
 
-   assert(access & GL_MAP_FLUSH_EXPLICIT_BIT);
+   assert(obj->Mappings[index].AccessFlags & GL_MAP_FLUSH_EXPLICIT_BIT);
 
    /* If we gave a direct mapping of the buffer instead of using a temporary,
     * then there's nothing to do.
diff --git a/src/mesa/main/attrib.c b/src/mesa/main/attrib.c
index d90e662..5345339 100644
--- a/src/mesa/main/attrib.c
+++ b/src/mesa/main/attrib.c
@@ -1345,6 +1345,7 @@ _mesa_PopAttrib(void)
                if (xform->DepthClamp != ctx->Transform.DepthClamp)
                   _mesa_set_enable(ctx, GL_DEPTH_CLAMP,
                                    ctx->Transform.DepthClamp);
+               _mesa_ClipControl(xform->ClipOrigin, xform->ClipDepthMode);
             }
             break;
          case GL_TEXTURE_BIT:
diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index c07e83a..2f40915 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -758,8 +758,7 @@ struct dd_function_table {
    struct gl_shader *(*NewShader)(struct gl_context *ctx,
                                   GLuint name, GLenum type);
    void (*DeleteShader)(struct gl_context *ctx, struct gl_shader *shader);
-   struct gl_shader_program *(*NewShaderProgram)(struct gl_context *ctx,
-                                                 GLuint name);
+   struct gl_shader_program *(*NewShaderProgram)(GLuint name);
    void (*DeleteShaderProgram)(struct gl_context *ctx,
                                struct gl_shader_program *shProg);
    void (*UseProgram)(struct gl_context *ctx, struct gl_shader_program *shProg);
diff --git a/src/mesa/main/dlist.c b/src/mesa/main/dlist.c
index 5c7160d..4b7b060 100644
--- a/src/mesa/main/dlist.c
+++ b/src/mesa/main/dlist.c
@@ -398,6 +398,9 @@ typedef enum
    OPCODE_PROGRAM_UNIFORM_MATRIX34F,
    OPCODE_PROGRAM_UNIFORM_MATRIX43F,
 
+   /* GL_ARB_clip_control */
+   OPCODE_CLIP_CONTROL,
+
    /* GL_ARB_color_buffer_float */
    OPCODE_CLAMP_COLOR,
 
@@ -7208,6 +7211,22 @@ save_ProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count,
 }
 
 static void GLAPIENTRY
+save_ClipControl(GLenum origin, GLenum depth)
+{
+   GET_CURRENT_CONTEXT(ctx);
+   Node *n;
+   ASSERT_OUTSIDE_SAVE_BEGIN_END_AND_FLUSH(ctx);
+   n = alloc_instruction(ctx, OPCODE_CLIP_CONTROL, 2);
+   if (n) {
+      n[1].e = origin;
+      n[2].e = depth;
+   }
+   if (ctx->ExecuteFlag) {
+      CALL_ClipControl(ctx->Exec, (origin, depth));
+   }
+}
+
+static void GLAPIENTRY
 save_ClampColorARB(GLenum target, GLenum clamp)
 {
    GET_CURRENT_CONTEXT(ctx);
@@ -8617,6 +8636,10 @@ execute_list(struct gl_context *ctx, GLuint list)
                                           get_pointer(&n[5])));
             break;
 
+         case OPCODE_CLIP_CONTROL:
+            CALL_ClipControl(ctx->Exec, (n[1].e, n[2].e));
+            break;
+
          case OPCODE_CLAMP_COLOR:
             CALL_ClampColor(ctx->Exec, (n[1].e, n[2].e));
             break;
@@ -9551,6 +9574,9 @@ _mesa_initialize_save_table(const struct gl_context *ctx)
    SET_TexParameterIiv(table, save_TexParameterIiv);
    SET_TexParameterIuiv(table, save_TexParameterIuiv);
 
+   /* GL_ARB_clip_control */
+   SET_ClipControl(table, save_ClipControl);
+
    /* GL_ARB_color_buffer_float */
    SET_ClampColor(table, save_ClampColorARB);
 
diff --git a/src/mesa/main/extensions.c b/src/mesa/main/extensions.c
index f0e2f89..15d66a7 100644
--- a/src/mesa/main/extensions.c
+++ b/src/mesa/main/extensions.c
@@ -91,6 +91,7 @@ static const struct extension extension_table[] = {
    { "GL_ARB_buffer_storage",                      o(ARB_buffer_storage),                      GL,             2013 },
    { "GL_ARB_clear_buffer_object",                 o(dummy_true),                              GL,             2012 },
    { "GL_ARB_clear_texture",                       o(ARB_clear_texture),                       GL,             2013 },
+   { "GL_ARB_clip_control",                        o(ARB_clip_control),                        GL,             2014 },
    { "GL_ARB_color_buffer_float",                  o(ARB_color_buffer_float),                  GL,             2004 },
    { "GL_ARB_compressed_texture_pixel_storage",    o(dummy_true),                              GL,             2011 },
    { "GL_ARB_compute_shader",                      o(ARB_compute_shader),                      GL,             2012 },
diff --git a/src/mesa/main/ff_fragment_shader.cpp b/src/mesa/main/ff_fragment_shader.cpp
index 9bb706c..5591d57 100644
--- a/src/mesa/main/ff_fragment_shader.cpp
+++ b/src/mesa/main/ff_fragment_shader.cpp
@@ -665,7 +665,7 @@ static GLboolean args_match( const struct state_key *key, GLuint unit )
 }
 
 static ir_rvalue *
-smear(texenv_fragment_program *p, ir_rvalue *val)
+smear(ir_rvalue *val)
 {
    if (!val->type->is_scalar())
       return val;
@@ -722,7 +722,7 @@ emit_combine(texenv_fragment_program *p,
       tmp1 = mul(src[1], new(p->mem_ctx) ir_constant(2.0f));
       tmp1 = add(tmp1, new(p->mem_ctx) ir_constant(-1.0f));
 
-      return dot(swizzle_xyz(smear(p, tmp0)), swizzle_xyz(smear(p, tmp1)));
+      return dot(swizzle_xyz(smear(tmp0)), swizzle_xyz(smear(tmp1)));
    }
    case MODE_MODULATE_ADD_ATI:
       return add(mul(src[0], src[2]), src[1]);
@@ -804,7 +804,7 @@ emit_texenv(texenv_fragment_program *p, GLuint unit)
 			 key->unit[unit].NumArgsRGB,
 			 key->unit[unit].ModeRGB,
 			 key->unit[unit].OptRGB);
-      val = smear(p, val);
+      val = smear(val);
       if (rgb_saturate)
 	 val = saturate(val);
 
@@ -816,7 +816,7 @@ emit_texenv(texenv_fragment_program *p, GLuint unit)
 				    key->unit[unit].NumArgsRGB,
 				    key->unit[unit].ModeRGB,
 				    key->unit[unit].OptRGB);
-      val = smear(p, val);
+      val = smear(val);
       if (rgb_saturate)
 	 val = saturate(val);
       p->emit(assign(temp_var, val));
@@ -829,7 +829,7 @@ emit_texenv(texenv_fragment_program *p, GLuint unit)
 			 key->unit[unit].NumArgsRGB,
 			 key->unit[unit].ModeRGB,
 			 key->unit[unit].OptRGB);
-      val = swizzle_xyz(smear(p, val));
+      val = swizzle_xyz(smear(val));
       if (rgb_saturate)
 	 val = saturate(val);
       p->emit(assign(temp_var, val, WRITEMASK_XYZ));
@@ -838,7 +838,7 @@ emit_texenv(texenv_fragment_program *p, GLuint unit)
 			 key->unit[unit].NumArgsA,
 			 key->unit[unit].ModeA,
 			 key->unit[unit].OptA);
-      val = swizzle_w(smear(p, val));
+      val = swizzle_w(smear(val));
       if (alpha_saturate)
 	 val = saturate(val);
       p->emit(assign(temp_var, val, WRITEMASK_W));
@@ -1212,7 +1212,7 @@ create_new_program(struct gl_context *ctx, struct state_key *key)
    p.top_instructions = p.shader->ir;
    p.instructions = p.shader->ir;
    p.state = key;
-   p.shader_program = ctx->Driver.NewShaderProgram(ctx, 0);
+   p.shader_program = ctx->Driver.NewShaderProgram(0);
 
    /* Tell the linker to ignore the fact that we're building a
     * separate shader, in case we're in a GLES2 context that would
diff --git a/src/mesa/main/get.c b/src/mesa/main/get.c
index 0e2d8f6..6091efc 100644
--- a/src/mesa/main/get.c
+++ b/src/mesa/main/get.c
@@ -391,6 +391,7 @@ EXTRA_EXT(ARB_gpu_shader5);
 EXTRA_EXT2(ARB_transform_feedback3, ARB_gpu_shader5);
 EXTRA_EXT(INTEL_performance_query);
 EXTRA_EXT(ARB_explicit_uniform_location);
+EXTRA_EXT(ARB_clip_control);
 
 static const int
 extra_ARB_color_buffer_float_or_glcore[] = {
diff --git a/src/mesa/main/get_hash_params.py b/src/mesa/main/get_hash_params.py
index da35684..aa9f282 100644
--- a/src/mesa/main/get_hash_params.py
+++ b/src/mesa/main/get_hash_params.py
@@ -414,6 +414,8 @@ descriptor=[
   [ "AUX_BUFFERS", "BUFFER_INT(Visual.numAuxBuffers), NO_EXTRA" ],
   [ "BLUE_BIAS", "CONTEXT_FLOAT(Pixel.BlueBias), NO_EXTRA" ],
   [ "BLUE_SCALE", "CONTEXT_FLOAT(Pixel.BlueScale), NO_EXTRA" ],
+  [ "CLIP_DEPTH_MODE", "CONTEXT_ENUM(Transform.ClipDepthMode), extra_ARB_clip_control" ],
+  [ "CLIP_ORIGIN", "CONTEXT_ENUM(Transform.ClipOrigin), extra_ARB_clip_control" ],
   [ "CLIENT_ATTRIB_STACK_DEPTH", "CONTEXT_INT(ClientAttribStackDepth), NO_EXTRA" ],
   [ "COLOR_MATERIAL_FACE", "CONTEXT_ENUM(Light.ColorMaterialFace), NO_EXTRA" ],
   [ "COLOR_MATERIAL_PARAMETER", "CONTEXT_ENUM(Light.ColorMaterialMode), NO_EXTRA" ],
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 415d302..e1f1f1d 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -1430,6 +1430,9 @@ struct gl_transform_attrib
    GLboolean RescaleNormals;			/**< GL_EXT_rescale_normal */
    GLboolean RasterPositionUnclipped;           /**< GL_IBM_rasterpos_clip */
    GLboolean DepthClamp;			/**< GL_ARB_depth_clamp */
+   /** GL_ARB_clip_control */
+   GLenum ClipOrigin;     /**< GL_LOWER_LEFT or GL_UPPER_LEFT */
+   GLenum ClipDepthMode;  /**< GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE */
 };
 
 
@@ -3698,6 +3701,7 @@ struct gl_extensions
    GLboolean ARB_blend_func_extended;
    GLboolean ARB_buffer_storage;
    GLboolean ARB_clear_texture;
+   GLboolean ARB_clip_control;
    GLboolean ARB_color_buffer_float;
    GLboolean ARB_compute_shader;
    GLboolean ARB_conditional_render_inverted;
diff --git a/src/mesa/main/polygon.c b/src/mesa/main/polygon.c
index 611cef6..76d6019 100644
--- a/src/mesa/main/polygon.c
+++ b/src/mesa/main/polygon.c
@@ -104,8 +104,6 @@ _mesa_FrontFace( GLenum mode )
    FLUSH_VERTICES(ctx, _NEW_POLYGON);
    ctx->Polygon.FrontFace = mode;
 
-   ctx->Polygon._FrontBit = (GLboolean) (mode == GL_CW);
-
    if (ctx->Driver.FrontFace)
       ctx->Driver.FrontFace( ctx, mode );
 }
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index 3e6f610..2be9092 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -316,7 +316,7 @@ create_shader_program(struct gl_context *ctx)
 
    name = _mesa_HashFindFreeKeyBlock(ctx->Shared->ShaderObjects, 1);
 
-   shProg = ctx->Driver.NewShaderProgram(ctx, name);
+   shProg = ctx->Driver.NewShaderProgram(name);
 
    _mesa_HashInsert(ctx->Shared->ShaderObjects, name, shProg);
 
diff --git a/src/mesa/main/shaderapi.h b/src/mesa/main/shaderapi.h
index 17b05b3..047d256 100644
--- a/src/mesa/main/shaderapi.h
+++ b/src/mesa/main/shaderapi.h
@@ -205,15 +205,6 @@ _mesa_use_shader_program(struct gl_context *ctx, GLenum type,
                          struct gl_shader_program *shProg,
                          struct gl_pipeline_object *shTarget);
 
-extern void GLAPIENTRY
-_mesa_UseShaderProgramEXT(GLenum type, GLuint program);
-
-extern void GLAPIENTRY
-_mesa_ActiveProgramEXT(GLuint program);
-
-extern GLuint GLAPIENTRY
-_mesa_CreateShaderProgramEXT(GLenum type, const GLchar *string);
-
 extern void
 _mesa_copy_linked_program_data(gl_shader_stage type,
                                const struct gl_shader_program *src,
diff --git a/src/mesa/main/shaderimage.c b/src/mesa/main/shaderimage.c
index 9e62f42..dcbcca6 100644
--- a/src/mesa/main/shaderimage.c
+++ b/src/mesa/main/shaderimage.c
@@ -384,7 +384,7 @@ validate_image_unit(struct gl_context *ctx, struct gl_image_unit *u)
 void
 _mesa_validate_image_units(struct gl_context *ctx)
 {
-   int i;
+   unsigned i;
 
    for (i = 0; i < ctx->Const.MaxImageUnits; ++i) {
       struct gl_image_unit *u = &ctx->ImageUnits[i];
diff --git a/src/mesa/main/shaderobj.c b/src/mesa/main/shaderobj.c
index 693e9a2..81bd782 100644
--- a/src/mesa/main/shaderobj.c
+++ b/src/mesa/main/shaderobj.c
@@ -235,8 +235,8 @@ _mesa_reference_shader_program(struct gl_context *ctx,
    }
 }
 
-void
-_mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog)
+static void
+init_shader_program(struct gl_shader_program *prog)
 {
    prog->Type = GL_SHADER_PROGRAM_MESA;
    prog->RefCount = 1;
@@ -261,13 +261,13 @@ _mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog
  * Called via ctx->Driver.NewShaderProgram()
  */
 static struct gl_shader_program *
-_mesa_new_shader_program(struct gl_context *ctx, GLuint name)
+_mesa_new_shader_program(GLuint name)
 {
    struct gl_shader_program *shProg;
    shProg = rzalloc(NULL, struct gl_shader_program);
    if (shProg) {
       shProg->Name = name;
-      _mesa_init_shader_program(ctx, shProg);
+      init_shader_program(shProg);
    }
    return shProg;
 }
@@ -277,11 +277,11 @@ _mesa_new_shader_program(struct gl_context *ctx, GLuint name)
  * Clear (free) the shader program state that gets produced by linking.
  */
 void
-_mesa_clear_shader_program_data(struct gl_context *ctx,
-                                struct gl_shader_program *shProg)
+_mesa_clear_shader_program_data(struct gl_shader_program *shProg)
 {
+   unsigned i;
+
    if (shProg->UniformStorage) {
-      unsigned i;
       for (i = 0; i < shProg->NumUserUniformStorage; ++i)
          _mesa_uniform_detach_all_driver_storage(&shProg->UniformStorage[i]);
       ralloc_free(shProg->UniformStorage);
@@ -303,6 +303,18 @@ _mesa_clear_shader_program_data(struct gl_context *ctx,
    assert(shProg->InfoLog != NULL);
    ralloc_free(shProg->InfoLog);
    shProg->InfoLog = ralloc_strdup(shProg, "");
+
+   ralloc_free(shProg->UniformBlocks);
+   shProg->UniformBlocks = NULL;
+   shProg->NumUniformBlocks = 0;
+   for (i = 0; i < MESA_SHADER_STAGES; i++) {
+      ralloc_free(shProg->UniformBlockStageIndex[i]);
+      shProg->UniformBlockStageIndex[i] = NULL;
+   }
+
+   ralloc_free(shProg->AtomicBuffers);
+   shProg->AtomicBuffers = NULL;
+   shProg->NumAtomicBuffers = 0;
 }
 
 
@@ -319,7 +331,7 @@ _mesa_free_shader_program_data(struct gl_context *ctx,
 
    assert(shProg->Type == GL_SHADER_PROGRAM_MESA);
 
-   _mesa_clear_shader_program_data(ctx, shProg);
+   _mesa_clear_shader_program_data(shProg);
 
    if (shProg->AttributeBindings) {
       string_to_uint_map_dtor(shProg->AttributeBindings);
diff --git a/src/mesa/main/shaderobj.h b/src/mesa/main/shaderobj.h
index d72919c..05ddfeb 100644
--- a/src/mesa/main/shaderobj.h
+++ b/src/mesa/main/shaderobj.h
@@ -71,9 +71,6 @@ _mesa_init_shader(struct gl_context *ctx, struct gl_shader *shader);
 extern struct gl_shader *
 _mesa_new_shader(struct gl_context *ctx, GLuint name, GLenum type);
 
-extern void
-_mesa_init_shader_program(struct gl_context *ctx, struct gl_shader_program *prog);
-
 extern struct gl_shader_program *
 _mesa_lookup_shader_program(struct gl_context *ctx, GLuint name);
 
@@ -82,8 +79,7 @@ _mesa_lookup_shader_program_err(struct gl_context *ctx, GLuint name,
                                 const char *caller);
 
 extern void
-_mesa_clear_shader_program_data(struct gl_context *ctx,
-                                struct gl_shader_program *shProg);
+_mesa_clear_shader_program_data(struct gl_shader_program *shProg);
 
 extern void
 _mesa_free_shader_program_data(struct gl_context *ctx,
diff --git a/src/mesa/main/state.c b/src/mesa/main/state.c
index 80287c4..45bce78 100644
--- a/src/mesa/main/state.c
+++ b/src/mesa/main/state.c
@@ -51,6 +51,7 @@
 #include "texobj.h"
 #include "texstate.h"
 #include "varray.h"
+#include "viewport.h"
 #include "blend.h"
 
 
@@ -281,16 +282,29 @@ update_viewport_matrix(struct gl_context *ctx)
     * NOTE: RasterPos uses this.
     */
    for (i = 0; i < ctx->Const.MaxViewports; i++) {
+      double scale[3], translate[3];
+
+      _mesa_get_viewport_xform(ctx, i, scale, translate);
       _math_matrix_viewport(&ctx->ViewportArray[i]._WindowMap,
-                            ctx->ViewportArray[i].X, ctx->ViewportArray[i].Y,
-                            ctx->ViewportArray[i].Width, ctx->ViewportArray[i].Height,
-                            ctx->ViewportArray[i].Near, ctx->ViewportArray[i].Far,
-                            depthMax);
+                            scale, translate, depthMax);
    }
 }
 
 
 /**
+ * Update the ctx->Polygon._FrontBit flag.
+ */
+static void
+update_frontbit(struct gl_context *ctx)
+{
+   if (ctx->Transform.ClipOrigin == GL_LOWER_LEFT)
+      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CW);
+   else
+      ctx->Polygon._FrontBit = (ctx->Polygon.FrontFace == GL_CCW);
+}
+
+
+/**
  * Update derived multisample state.
  */
 static void
@@ -372,6 +386,9 @@ _mesa_update_state_locked( struct gl_context *ctx )
    if (new_state & (_NEW_PROGRAM|_NEW_TEXTURE|_NEW_TEXTURE_MATRIX))
       _mesa_update_texture( ctx, new_state );
 
+   if (new_state & _NEW_POLYGON)
+      update_frontbit( ctx );
+
    if (new_state & _NEW_BUFFERS)
       _mesa_update_framebuffer(ctx);
 
diff --git a/src/mesa/main/tests/dispatch_sanity.cpp b/src/mesa/main/tests/dispatch_sanity.cpp
index 04fa86b..03428dd 100644
--- a/src/mesa/main/tests/dispatch_sanity.cpp
+++ b/src/mesa/main/tests/dispatch_sanity.cpp
@@ -951,6 +951,9 @@ const struct function gl_core_functions_possible[] = {
    { "glClearTexImage", 13, -1 },
    { "glClearTexSubImage", 13, -1 },
 
+   /* GL_ARB_clip_control */
+   { "glClipControl", 45, -1 },
+
    { NULL, 0, -1 }
 };
 
diff --git a/src/mesa/main/uniform_query.cpp b/src/mesa/main/uniform_query.cpp
index db97d3d..fcb14c4 100644
--- a/src/mesa/main/uniform_query.cpp
+++ b/src/mesa/main/uniform_query.cpp
@@ -973,8 +973,7 @@ _mesa_uniform_matrix(struct gl_context *ctx, struct gl_shader_program *shProg,
  * array offset in *offset, or GL_INVALID_INDEX (-1).
  */
 extern "C" unsigned
-_mesa_get_uniform_location(struct gl_context *ctx,
-                           struct gl_shader_program *shProg,
+_mesa_get_uniform_location(struct gl_shader_program *shProg,
                            const GLchar *name,
                            unsigned *out_offset)
 {
diff --git a/src/mesa/main/uniforms.c b/src/mesa/main/uniforms.c
index 598b4d4..c307107 100644
--- a/src/mesa/main/uniforms.c
+++ b/src/mesa/main/uniforms.c
@@ -931,7 +931,7 @@ _mesa_GetUniformLocation(GLuint programObj, const GLcharARB *name)
       return -1;
    }
 
-   index = _mesa_get_uniform_location(ctx, shProg, name, &offset);
+   index = _mesa_get_uniform_location(shProg, name, &offset);
    if (index == GL_INVALID_INDEX)
       return -1;
 
@@ -1004,7 +1004,7 @@ _mesa_GetUniformIndices(GLuint program,
 
    for (i = 0; i < uniformCount; i++) {
       unsigned offset;
-      uniformIndices[i] = _mesa_get_uniform_location(ctx, shProg,
+      uniformIndices[i] = _mesa_get_uniform_location(shProg,
 						     uniformNames[i], &offset);
    }
 }
@@ -1110,7 +1110,7 @@ _mesa_GetActiveUniformBlockiv(GLuint program,
       for (i = 0; i < block->NumUniforms; i++) {
 	 unsigned offset;
          const int idx =
-            _mesa_get_uniform_location(ctx, shProg,
+            _mesa_get_uniform_location(shProg,
                                        block->Uniforms[i].IndexName,
                                        &offset);
          if (idx != -1)
@@ -1127,7 +1127,7 @@ _mesa_GetActiveUniformBlockiv(GLuint program,
       for (i = 0; i < block->NumUniforms; i++) {
 	 unsigned offset;
          const int idx =
-            _mesa_get_uniform_location(ctx, shProg,
+            _mesa_get_uniform_location(shProg,
                                        block->Uniforms[i].IndexName,
                                        &offset);
 
diff --git a/src/mesa/main/uniforms.h b/src/mesa/main/uniforms.h
index e7a370e..6575a52 100644
--- a/src/mesa/main/uniforms.h
+++ b/src/mesa/main/uniforms.h
@@ -259,7 +259,7 @@ _mesa_parse_program_resource_name(const GLchar *name,
                                   const GLchar **out_base_name_end);
 
 unsigned
-_mesa_get_uniform_location(struct gl_context *ctx, struct gl_shader_program *shProg,
+_mesa_get_uniform_location(struct gl_shader_program *shProg,
 			   const GLchar *name, unsigned *offset);
 
 void
diff --git a/src/mesa/main/version.c b/src/mesa/main/version.c
index 71f7011..4951891 100644
--- a/src/mesa/main/version.c
+++ b/src/mesa/main/version.c
@@ -381,7 +381,6 @@ compute_version_es2(const struct gl_extensions *extensions)
                               extensions->ARB_shader_texture_lod &&
                               extensions->ARB_texture_float &&
                               extensions->ARB_texture_rg &&
-                              extensions->ARB_texture_compression_rgtc &&
                               extensions->EXT_draw_buffers2 &&
                               /* extensions->ARB_framebuffer_object && */
                               extensions->EXT_framebuffer_sRGB &&
@@ -389,7 +388,6 @@ compute_version_es2(const struct gl_extensions *extensions)
                               extensions->EXT_texture_array &&
                               extensions->EXT_texture_shared_exponent &&
                               extensions->EXT_transform_feedback &&
-                              extensions->NV_conditional_render &&
                               extensions->ARB_draw_instanced &&
                               extensions->ARB_uniform_buffer_object &&
                               extensions->EXT_texture_snorm &&
diff --git a/src/mesa/main/viewport.c b/src/mesa/main/viewport.c
index 222ae30..d6a9e29 100644
--- a/src/mesa/main/viewport.c
+++ b/src/mesa/main/viewport.c
@@ -30,6 +30,7 @@
 
 
 #include "context.h"
+#include "enums.h"
 #include "macros.h"
 #include "mtypes.h"
 #include "viewport.h"
@@ -39,6 +40,8 @@ set_viewport_no_notify(struct gl_context *ctx, unsigned idx,
                        GLfloat x, GLfloat y,
                        GLfloat width, GLfloat height)
 {
+   double scale[3], translate[3];
+
    /* clamp width and height to the implementation dependent range */
    width  = MIN2(width, (GLfloat) ctx->Const.MaxViewportWidth);
    height = MIN2(height, (GLfloat) ctx->Const.MaxViewportHeight);
@@ -75,14 +78,9 @@ set_viewport_no_notify(struct gl_context *ctx, unsigned idx,
     * the WindowMap matrix being up to date in the driver's Viewport
     * and DepthRange functions.
     */
+   _mesa_get_viewport_xform(ctx, idx, scale, translate);
    _math_matrix_viewport(&ctx->ViewportArray[idx]._WindowMap,
-                         ctx->ViewportArray[idx].X,
-                         ctx->ViewportArray[idx].Y,
-                         ctx->ViewportArray[idx].Width,
-                         ctx->ViewportArray[idx].Height,
-                         ctx->ViewportArray[idx].Near,
-                         ctx->ViewportArray[idx].Far,
-                         ctx->DrawBuffer->_DepthMaxF);
+                         scale, translate, ctx->DrawBuffer->_DepthMaxF);
 #endif
 }
 
@@ -248,6 +246,8 @@ static void
 set_depth_range_no_notify(struct gl_context *ctx, unsigned idx,
                           GLclampd nearval, GLclampd farval)
 {
+   double scale[3], translate[3];
+
    if (ctx->ViewportArray[idx].Near == nearval &&
        ctx->ViewportArray[idx].Far == farval)
       return;
@@ -261,14 +261,9 @@ set_depth_range_no_notify(struct gl_context *ctx, unsigned idx,
     * the WindowMap matrix being up to date in the driver's Viewport
     * and DepthRange functions.
     */
+   _mesa_get_viewport_xform(ctx, idx, scale, translate);
    _math_matrix_viewport(&ctx->ViewportArray[idx]._WindowMap,
-                         ctx->ViewportArray[idx].X,
-                         ctx->ViewportArray[idx].Y,
-                         ctx->ViewportArray[idx].Width,
-                         ctx->ViewportArray[idx].Height,
-                         ctx->ViewportArray[idx].Near,
-                         ctx->ViewportArray[idx].Far,
-                         ctx->DrawBuffer->_DepthMaxF);
+                         scale, translate, ctx->DrawBuffer->_DepthMaxF);
 #endif
 }
 
@@ -396,10 +391,15 @@ void _mesa_init_viewport(struct gl_context *ctx)
    GLfloat depthMax = 65535.0F; /* sorf of arbitrary */
    unsigned i;
 
+   ctx->Transform.ClipOrigin = GL_LOWER_LEFT;
+   ctx->Transform.ClipDepthMode = GL_NEGATIVE_ONE_TO_ONE;
+
    /* Note: ctx->Const.MaxViewports may not have been set by the driver yet,
     * so just initialize all of them.
     */
    for (i = 0; i < MAX_VIEWPORTS; i++) {
+      double scale[3], translate[3];
+
       /* Viewport group */
       ctx->ViewportArray[i].X = 0;
       ctx->ViewportArray[i].Y = 0;
@@ -409,8 +409,9 @@ void _mesa_init_viewport(struct gl_context *ctx)
       ctx->ViewportArray[i].Far = 1.0;
       _math_matrix_ctr(&ctx->ViewportArray[i]._WindowMap);
 
-      _math_matrix_viewport(&ctx->ViewportArray[i]._WindowMap, 0, 0, 0, 0,
-                            0.0F, 1.0F, depthMax);
+      _mesa_get_viewport_xform(ctx, i, scale, translate);
+      _math_matrix_viewport(&ctx->ViewportArray[i]._WindowMap,
+                            scale, translate, depthMax);
    }
 }
 
@@ -427,3 +428,92 @@ void _mesa_free_viewport_data(struct gl_context *ctx)
       _math_matrix_dtr(&ctx->ViewportArray[i]._WindowMap);
 }
 
+extern void GLAPIENTRY
+_mesa_ClipControl(GLenum origin, GLenum depth)
+{
+   GET_CURRENT_CONTEXT(ctx);
+
+   if (MESA_VERBOSE&VERBOSE_API)
+      _mesa_debug(ctx, "glClipControl(%s, %s)\n",
+	          _mesa_lookup_enum_by_nr(origin),
+                  _mesa_lookup_enum_by_nr(depth));
+
+   ASSERT_OUTSIDE_BEGIN_END(ctx);
+
+   if (!ctx->Extensions.ARB_clip_control) {
+      _mesa_error(ctx, GL_INVALID_OPERATION, "glClipControl");
+      return;
+   }
+
+   if (origin != GL_LOWER_LEFT && origin != GL_UPPER_LEFT) {
+      _mesa_error(ctx, GL_INVALID_ENUM, "glClipControl");
+      return;
+   }
+
+   if (depth != GL_NEGATIVE_ONE_TO_ONE && depth != GL_ZERO_TO_ONE) {
+      _mesa_error(ctx, GL_INVALID_ENUM, "glClipControl");
+      return;
+   }
+
+   if (ctx->Transform.ClipOrigin == origin &&
+       ctx->Transform.ClipDepthMode == depth)
+      return;
+
+   FLUSH_VERTICES(ctx, 0);
+
+   if (ctx->Transform.ClipOrigin != origin) {
+      ctx->Transform.ClipOrigin = origin;
+
+      /* Affects the winding order of the front face. */
+      ctx->NewState |= _NEW_POLYGON;
+      /* Affects the y component of the viewport transform. */
+      ctx->NewState |= _NEW_VIEWPORT;
+
+      if (ctx->Driver.FrontFace)
+         ctx->Driver.FrontFace(ctx, ctx->Polygon.FrontFace);
+   }
+
+   if (ctx->Transform.ClipDepthMode != depth) {
+      ctx->Transform.ClipDepthMode = depth;
+
+      /* Affects the z part of the viewpoint transform. */
+      ctx->NewState |= _NEW_VIEWPORT;
+
+      if (ctx->Driver.DepthRange)
+         ctx->Driver.DepthRange(ctx);
+   }
+}
+
+/**
+ * Computes the scaling and the translation part of the
+ * viewport transform matrix of the \param i-th viewport
+ * and writes that into \param scale and \param translate.
+ */
+void
+_mesa_get_viewport_xform(struct gl_context *ctx, unsigned i,
+                         double scale[3], double translate[3])
+{
+   double x = ctx->ViewportArray[i].X;
+   double y = ctx->ViewportArray[i].Y;
+   double half_width = 0.5*ctx->ViewportArray[i].Width;
+   double half_height = 0.5*ctx->ViewportArray[i].Height;
+   double n = ctx->ViewportArray[i].Near;
+   double f = ctx->ViewportArray[i].Far;
+
+   scale[0] = half_width;
+   translate[0] = half_width + x;
+   if (ctx->Transform.ClipOrigin == GL_UPPER_LEFT) {
+      scale[1] = -half_height;
+      translate[1] = half_height - y;
+   } else {
+      scale[1] = half_height;
+      translate[1] = half_height + y;
+   }
+   if (ctx->Transform.ClipDepthMode == GL_NEGATIVE_ONE_TO_ONE) {
+      scale[2] = 0.5*(f - n);
+      translate[2] = 0.5*(n + f);
+   } else {
+      scale[2] = f - n;
+      translate[2] = n;
+   }
+}
diff --git a/src/mesa/main/viewport.h b/src/mesa/main/viewport.h
index f2311c0..426e194 100644
--- a/src/mesa/main/viewport.h
+++ b/src/mesa/main/viewport.h
@@ -71,5 +71,11 @@ _mesa_init_viewport(struct gl_context *ctx);
 extern void 
 _mesa_free_viewport_data(struct gl_context *ctx);
 
+extern void GLAPIENTRY
+_mesa_ClipControl(GLenum origin, GLenum depth);
+
+extern void
+_mesa_get_viewport_xform(struct gl_context *ctx, unsigned i,
+                         double scale[3], double translate[3]);
 
 #endif
diff --git a/src/mesa/math/m_matrix.c b/src/mesa/math/m_matrix.c
index e512e45..9c9310d 100644
--- a/src/mesa/math/m_matrix.c
+++ b/src/mesa/math/m_matrix.c
@@ -1110,16 +1110,15 @@ _math_matrix_translate( GLmatrix *mat, GLfloat x, GLfloat y, GLfloat z )
  * Transforms Normalized Device Coords to window/Z values.
  */
 void
-_math_matrix_viewport(GLmatrix *m, GLfloat x, GLfloat y,
-                      GLfloat width, GLfloat height,
-                      GLdouble zNear, GLdouble zFar, GLdouble depthMax)
+_math_matrix_viewport(GLmatrix *m, const double scale[3],
+                      const double translate[3], double depthMax)
 {
-   m->m[MAT_SX] = width / 2.0F;
-   m->m[MAT_TX] = m->m[MAT_SX] + x;
-   m->m[MAT_SY] = height / 2.0F;
-   m->m[MAT_TY] = m->m[MAT_SY] + y;
-   m->m[MAT_SZ] = (GLfloat) (depthMax * ((zFar - zNear) / 2.0));
-   m->m[MAT_TZ] = (GLfloat) (depthMax * ((zFar - zNear) / 2.0 + zNear));
+   m->m[MAT_SX] = scale[0];
+   m->m[MAT_TX] = translate[0];
+   m->m[MAT_SY] = scale[1];
+   m->m[MAT_TY] = translate[1];
+   m->m[MAT_SZ] = depthMax*scale[2];
+   m->m[MAT_TZ] = depthMax*translate[2];
    m->flags = MAT_FLAG_GENERAL_SCALE | MAT_FLAG_TRANSLATION;
    m->type = MATRIX_3D_NO_ROT;
 }
diff --git a/src/mesa/math/m_matrix.h b/src/mesa/math/m_matrix.h
index dddce70..778d716 100644
--- a/src/mesa/math/m_matrix.h
+++ b/src/mesa/math/m_matrix.h
@@ -122,8 +122,8 @@ _math_matrix_frustum( GLmatrix *mat,
 		      GLfloat nearval, GLfloat farval );
 
 extern void
-_math_matrix_viewport(GLmatrix *m, GLfloat x, GLfloat y, GLfloat width, GLfloat height,
-                      GLdouble zNear, GLdouble zFar, GLdouble depthMax);
+_math_matrix_viewport( GLmatrix *m, const double scale[3],
+                       const double translate[3], double depthMax );
 
 extern void
 _math_matrix_set_identity( GLmatrix *dest );
diff --git a/src/mesa/program/ir_to_mesa.cpp b/src/mesa/program/ir_to_mesa.cpp
index b3e04d7..5cd9058 100644
--- a/src/mesa/program/ir_to_mesa.cpp
+++ b/src/mesa/program/ir_to_mesa.cpp
@@ -3020,7 +3020,7 @@ _mesa_glsl_link_shader(struct gl_context *ctx, struct gl_shader_program *prog)
 {
    unsigned int i;
 
-   _mesa_clear_shader_program_data(ctx, prog);
+   _mesa_clear_shader_program_data(prog);
 
    prog->LinkStatus = GL_TRUE;
 
diff --git a/src/mesa/state_tracker/st_atom_rasterizer.c b/src/mesa/state_tracker/st_atom_rasterizer.c
index dfa728b..5020978 100644
--- a/src/mesa/state_tracker/st_atom_rasterizer.c
+++ b/src/mesa/state_tracker/st_atom_rasterizer.c
@@ -72,6 +72,11 @@ static void update_raster_state( struct st_context *st )
    {
       raster->front_ccw = (ctx->Polygon.FrontFace == GL_CCW);
 
+      /* _NEW_VIEWPORT */
+      if (ctx->Transform.ClipOrigin == GL_UPPER_LEFT) {
+         raster->front_ccw ^= 1;
+      }
+
       /*
        * Gallium's surfaces are Y=0=TOP orientation.  OpenGL is the
        * opposite.  Window system surfaces are Y=0=TOP.  Mesa's FBOs
@@ -241,6 +246,12 @@ static void update_raster_state( struct st_context *st )
    raster->half_pixel_center = 1;
    if (st_fb_orientation(ctx->DrawBuffer) == Y_0_TOP)
       raster->bottom_edge_rule = 1;
+   /* _NEW_VIEWPORT */
+   if (ctx->Transform.ClipOrigin == GL_UPPER_LEFT)
+      raster->bottom_edge_rule ^= 1;
+
+   /* _NEW_VIEWPORT */
+   raster->clip_halfz = (ctx->Transform.ClipDepthMode == GL_ZERO_TO_ONE);
 
    /* ST_NEW_RASTERIZER */
    raster->rasterizer_discard = ctx->RasterDiscard;
@@ -272,7 +283,8 @@ const struct st_tracked_state st_update_rasterizer = {
        _NEW_PROGRAM |
        _NEW_SCISSOR |
        _NEW_FRAG_CLAMP |
-       _NEW_TRANSFORM),      /* mesa state dependencies*/
+       _NEW_TRANSFORM |
+       _NEW_VIEWPORT),      /* mesa state dependencies*/
       (ST_NEW_VERTEX_PROGRAM |
        ST_NEW_RASTERIZER),  /* state tracker dependencies */
    },
diff --git a/src/mesa/state_tracker/st_atom_viewport.c b/src/mesa/state_tracker/st_atom_viewport.c
index 7584f9b..5b99208 100644
--- a/src/mesa/state_tracker/st_atom_viewport.c
+++ b/src/mesa/state_tracker/st_atom_viewport.c
@@ -27,6 +27,7 @@
 
 
 #include "main/context.h"
+#include "main/viewport.h"
 #include "st_context.h"
 #include "st_atom.h"
 #include "pipe/p_context.h"
@@ -63,21 +64,17 @@ update_viewport( struct st_context *st )
     */
    for (i = 0; i < ctx->Const.MaxViewports; i++)
    {
-      GLfloat x = ctx->ViewportArray[i].X;
-      GLfloat y = ctx->ViewportArray[i].Y;
-      GLfloat z = ctx->ViewportArray[i].Near;
-      GLfloat half_width = ctx->ViewportArray[i].Width * 0.5f;
-      GLfloat half_height = ctx->ViewportArray[i].Height * 0.5f;
-      GLfloat half_depth = (GLfloat)(ctx->ViewportArray[i].Far - ctx->ViewportArray[i].Near) * 0.5f;
-      
-      st->state.viewport[i].scale[0] = half_width;
-      st->state.viewport[i].scale[1] = half_height * yScale;
-      st->state.viewport[i].scale[2] = half_depth;
+      double scale[3], translate[3];
+      _mesa_get_viewport_xform(ctx, i, scale, translate);
+
+      st->state.viewport[i].scale[0] = scale[0];
+      st->state.viewport[i].scale[1] = scale[1] * yScale;
+      st->state.viewport[i].scale[2] = scale[2];
       st->state.viewport[i].scale[3] = 1.0;
 
-      st->state.viewport[i].translate[0] = half_width + x;
-      st->state.viewport[i].translate[1] = (half_height + y) * yScale + yBias;
-      st->state.viewport[i].translate[2] = half_depth + z;
+      st->state.viewport[i].translate[0] = translate[0];
+      st->state.viewport[i].translate[1] = translate[1] * yScale + yBias;
+      st->state.viewport[i].translate[2] = translate[2];
       st->state.viewport[i].translate[3] = 0.0;
    }
 
diff --git a/src/mesa/state_tracker/st_cb_program.c b/src/mesa/state_tracker/st_cb_program.c
index 82e1fd1..faff9c4 100644
--- a/src/mesa/state_tracker/st_cb_program.c
+++ b/src/mesa/state_tracker/st_cb_program.c
@@ -242,7 +242,5 @@ st_init_program_functions(struct dd_function_table *functions)
    functions->IsProgramNative = st_is_program_native;
    functions->ProgramStringNotify = st_program_string_notify;
    
-   functions->NewShader = st_new_shader;
-   functions->NewShaderProgram = st_new_shader_program;
    functions->LinkShader = st_link_shader;
 }
diff --git a/src/mesa/state_tracker/st_extensions.c b/src/mesa/state_tracker/st_extensions.c
index 78bfe30..aff3dde 100644
--- a/src/mesa/state_tracker/st_extensions.c
+++ b/src/mesa/state_tracker/st_extensions.c
@@ -463,6 +463,7 @@ void st_init_extensions(struct pipe_screen *screen,
       { o(ARB_derivative_control),           PIPE_CAP_TGSI_FS_FINE_DERIVATIVE          },
       { o(ARB_conditional_render_inverted),  PIPE_CAP_CONDITIONAL_RENDER_INVERTED      },
       { o(ARB_texture_view),                 PIPE_CAP_SAMPLER_VIEW_TARGET              },
+      { o(ARB_clip_control),                 PIPE_CAP_CLIP_HALFZ                       },
    };
 
    /* Required: render target and sampler support */
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
index a6ce033..a4e2c8d 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
@@ -5331,34 +5331,6 @@ get_mesa_program(struct gl_context *ctx,
 
 extern "C" {
 
-struct gl_shader *
-st_new_shader(struct gl_context *ctx, GLuint name, GLuint type)
-{
-   struct gl_shader *shader;
-   assert(type == GL_FRAGMENT_SHADER || type == GL_VERTEX_SHADER ||
-          type == GL_GEOMETRY_SHADER_ARB);
-   shader = rzalloc(NULL, struct gl_shader);
-   if (shader) {
-      shader->Type = type;
-      shader->Stage = _mesa_shader_enum_to_shader_stage(type);
-      shader->Name = name;
-      _mesa_init_shader(ctx, shader);
-   }
-   return shader;
-}
-
-struct gl_shader_program *
-st_new_shader_program(struct gl_context *ctx, GLuint name)
-{
-   struct gl_shader_program *shProg;
-   shProg = rzalloc(NULL, struct gl_shader_program);
-   if (shProg) {
-      shProg->Name = name;
-      _mesa_init_shader_program(ctx, shProg);
-   }
-   return shProg;
-}
-
 /**
  * Link a shader.
  * Called via ctx->Driver.LinkShader()
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi.h b/src/mesa/state_tracker/st_glsl_to_tgsi.h
index 18f666f..5ed6407 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi.h
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi.h
@@ -61,11 +61,6 @@ void get_bitmap_visitor(struct st_fragment_program *fp,
                         struct glsl_to_tgsi_visitor *original,
                         int samplerIndex);
 
-struct gl_shader *st_new_shader(struct gl_context *ctx, GLuint name, GLuint type);
-
-struct gl_shader_program *
-st_new_shader_program(struct gl_context *ctx, GLuint name);
-
 GLboolean st_link_shader(struct gl_context *ctx, struct gl_shader_program *prog);
 
 void
diff --git a/src/util/macros.h b/src/util/macros.h
index 40ebf02..ff37a7d 100644
--- a/src/util/macros.h
+++ b/src/util/macros.h
@@ -75,6 +75,20 @@ do {                        \
 #define unreachable(str)
 #endif
 
+/**
+ * Assume macro. Useful for expressing our assumptions to the compiler,
+ * typically for purposes of silencing warnings.
+ */
+#ifdef HAVE___BUILTIN_UNREACHABLE
+#define assume(expr) ((expr) ? ((void) 0) \
+                             : (assert(!"assumption failed"), \
+                                __builtin_unreachable()))
+#elif _MSC_VER >= 1200
+#define assume(expr) __assume(expr)
+#else
+#define assume(expr) assert(expr)
+#endif
+
 #ifdef HAVE_FUNC_ATTRIBUTE_FLATTEN
 #define FLATTEN __attribute__((__flatten__))
 #else
diff --git a/src/util/register_allocate.c b/src/util/register_allocate.c
index afab9dd..6cf7ce7 100644
--- a/src/util/register_allocate.c
+++ b/src/util/register_allocate.c
@@ -335,7 +335,7 @@ ra_set_finalize(struct ra_regs *regs, unsigned int **q_values)
 
 	    for (i = 0; i < regs->regs[rc].num_conflicts; i++) {
 	       unsigned int rb = regs->regs[rc].conflict_list[i];
-	       if (BITSET_TEST(regs->classes[b]->regs, rb))
+	       if (reg_belongs_to_class(rb, regs->classes[b]))
 		  conflicts++;
 	    }
 	    max_conflicts = MAX2(max_conflicts, conflicts);
