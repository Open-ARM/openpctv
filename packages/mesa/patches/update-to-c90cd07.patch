diff --git a/Android.mk b/Android.mk
index 591c2fc..e190f74 100644
--- a/Android.mk
+++ b/Android.mk
@@ -81,6 +81,7 @@ SUBDIRS := \
 	src/mapi \
 	src/glsl \
 	src/mesa \
+	src/util \
 	src/egl/main
 
 ifeq ($(strip $(MESA_BUILD_CLASSIC)),true)
diff --git a/configure.ac b/configure.ac
index 4320045..41b35a9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1704,11 +1704,10 @@ if test "x$enable_gallium_llvm" = xyes; then
         AC_COMPUTE_INT([LLVM_VERSION_MINOR], [LLVM_VERSION_MINOR],
             [#include "${LLVM_INCLUDEDIR}/llvm/Config/llvm-config.h"])
 
-        dnl In LLVM 3.4.1 patch level was defined in config.h and not
-        dnl llvm-config.h
-        AC_COMPUTE_INT([LLVM_VERSION_PATCH], [LLVM_VERSION_PATCH],
-            [#include "${LLVM_INCLUDEDIR}/llvm/Config/config.h"],
-            LLVM_VERSION_PATCH=0) dnl Default if LLVM_VERSION_PATCH not found
+        LLVM_VERSION_PATCH=`echo $LLVM_VERSION | cut -d. -f3 | egrep -o '^[[0-9]]+'`
+        if test -z "$LLVM_VERSION_PATCH"; then
+            LLVM_VERSION_PATCH=0
+        fi
 
         if test -n "${LLVM_VERSION_MAJOR}"; then
             LLVM_VERSION_INT="${LLVM_VERSION_MAJOR}0${LLVM_VERSION_MINOR}"
diff --git a/docs/index.html b/docs/index.html
index 5fb5567..481de58 100644
--- a/docs/index.html
+++ b/docs/index.html
@@ -16,6 +16,17 @@
 
 <h1>News</h1>
 
+<h2>September 19, 2014</h2>
+<p>
+<a href="relnotes/10.3.html">Mesa 10.3</a> is released.  This is a new
+development release.  See the release notes for more information about
+the release.
+</p>
+<p>
+Also, <a href="relnotes/10.2.8.html">Mesa 10.2.8</a> is released.
+This is a bug fix release from the 10.2 branch.
+</p>
+
 <h2>August 19, 2014</h2>
 <p>
 <a href="relnotes/10.2.6.html">Mesa 10.2.6</a> is released.
diff --git a/docs/relnotes.html b/docs/relnotes.html
index b84f498..e913bd0 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -21,6 +21,8 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <ul>
+<li><a href="relnotes/10.3.html">10.3 release notes</a>
+<li><a href="relnotes/10.2.8.html">10.2.8 release notes</a>
 <li><a href="relnotes/10.2.6.html">10.2.6 release notes</a>
 <li><a href="relnotes/10.2.5.html">10.2.5 release notes</a>
 <li><a href="relnotes/10.2.4.html">10.2.4 release notes</a>
diff --git a/docs/relnotes/10.3.html b/docs/relnotes/10.3.html
index 2a252d6..53cd62d 100644
--- a/docs/relnotes/10.3.html
+++ b/docs/relnotes/10.3.html
@@ -31,9 +31,11 @@ because compatibility contexts are not supported.
 </p>
 
 
-<h2>MD5 checksums</h2>
+<h2>SHA256 checksums</h2>
 <pre>
-TBD.
+9a1bf52040fc3dda81e83a35f944f1c3f532847dbe9fdf57161265cf71ea1bae  MesaLib-10.3.0.tar.gz
+0283bfe710fa449ed82e465cfa09612a269e19abb7e0382082608062ce7960b5  MesaLib-10.3.0.tar.bz2
+221420763c2c3a244836a736e735612c4a6a0377b4e5223fca1e612f49906789  MesaLib-10.3.0.zip
 </pre>
 
 
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index e272beb..a39f8ae 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -681,6 +681,7 @@ dri2_initialize_drm(_EGLDriver *drv, _EGLDisplay *disp)
                       i + 1, EGL_WINDOW_BIT, attr_list, NULL);
    }
 
+   disp->Extensions.KHR_image_pixmap = EGL_TRUE;
    if (dri2_dpy->dri2)
       disp->Extensions.EXT_buffer_age = EGL_TRUE;
 
diff --git a/src/egl/main/Android.mk b/src/egl/main/Android.mk
index 8c37e79..8537381 100644
--- a/src/egl/main/Android.mk
+++ b/src/egl/main/Android.mk
@@ -143,6 +143,7 @@ LOCAL_STATIC_LIBRARIES := \
 	libmesa_st_egl \
 	$(gallium_DRIVERS) \
 	libmesa_st_mesa \
+	libmesa_util \
 	libmesa_glsl \
 	libmesa_glsl_utils \
 	libmesa_gallium \
diff --git a/src/gallium/auxiliary/Android.mk b/src/gallium/auxiliary/Android.mk
index 11fc225..8046943 100644
--- a/src/gallium/auxiliary/Android.mk
+++ b/src/gallium/auxiliary/Android.mk
@@ -30,7 +30,9 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES := $(C_SOURCES)
 
-LOCAL_C_INCLUDES := $(GALLIUM_TOP)/auxiliary/util
+LOCAL_C_INCLUDES := \
+	$(GALLIUM_TOP)/auxiliary/util \
+	$(MESA_TOP)/src
 
 LOCAL_MODULE := libmesa_gallium
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
index b9546db..722aa9a 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
@@ -1248,8 +1248,24 @@ idiv_emit_cpu(
    struct lp_build_tgsi_context * bld_base,
    struct lp_build_emit_data * emit_data)
 {
-   emit_data->output[emit_data->chan] = lp_build_div(&bld_base->int_bld,
-                                   emit_data->args[0], emit_data->args[1]);
+   LLVMBuilderRef builder = bld_base->base.gallivm->builder;
+   LLVMValueRef div_mask = lp_build_cmp(&bld_base->uint_bld,
+                                        PIPE_FUNC_EQUAL, emit_data->args[1],
+                                        bld_base->uint_bld.zero);
+   /* We want to make sure that we never divide/mod by zero to not
+    * generate sigfpe. We don't want to crash just because the
+    * shader is doing something weird. */
+   LLVMValueRef divisor = LLVMBuildOr(builder,
+                                      div_mask,
+                                      emit_data->args[1], "");
+   LLVMValueRef result = lp_build_div(&bld_base->int_bld,
+                                      emit_data->args[0], divisor);
+   LLVMValueRef not_div_mask = LLVMBuildNot(builder,
+                                            div_mask,"");
+   /* idiv by zero doesn't have a guaranteed return value chose 0 for now. */
+   emit_data->output[emit_data->chan] = LLVMBuildAnd(builder,
+                                                     not_div_mask,
+                                                     result, "");
 }
 
 /* TGSI_OPCODE_INEG (CPU Only) */
@@ -1675,15 +1691,15 @@ udiv_emit_cpu(
    LLVMValueRef div_mask = lp_build_cmp(&bld_base->uint_bld,
                                         PIPE_FUNC_EQUAL, emit_data->args[1],
                                         bld_base->uint_bld.zero);
-   /* We want to make sure that we never divide/mod by zero to not 
-    * generate sigfpe. We don't want to crash just because the 
+   /* We want to make sure that we never divide/mod by zero to not
+    * generate sigfpe. We don't want to crash just because the
     * shader is doing something weird. */
    LLVMValueRef divisor = LLVMBuildOr(builder,
                                       div_mask,
                                       emit_data->args[1], "");
    LLVMValueRef result = lp_build_div(&bld_base->uint_bld,
                                       emit_data->args[0], divisor);
-   /* udiv by zero is guaranteed to return 0xffffffff */
+   /* udiv by zero is guaranteed to return 0xffffffff at least with d3d10 */
    emit_data->output[emit_data->chan] = LLVMBuildOr(builder,
                                                     div_mask,
                                                     result, "");
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index d848348..dc20b4e 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -3340,10 +3340,10 @@ micro_idiv(union tgsi_exec_channel *dst,
            const union tgsi_exec_channel *src0,
            const union tgsi_exec_channel *src1)
 {
-   dst->i[0] = src0->i[0] / src1->i[0];
-   dst->i[1] = src0->i[1] / src1->i[1];
-   dst->i[2] = src0->i[2] / src1->i[2];
-   dst->i[3] = src0->i[3] / src1->i[3];
+   dst->i[0] = src1->i[0] ? src0->i[0] / src1->i[0] : 0;
+   dst->i[1] = src1->i[1] ? src0->i[1] / src1->i[1] : 0;
+   dst->i[2] = src1->i[2] ? src0->i[2] / src1->i[2] : 0;
+   dst->i[3] = src1->i[3] ? src0->i[3] / src1->i[3] : 0;
 }
 
 static void
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gm107.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gm107.cpp
index 070b20a..64989ac 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gm107.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_gm107.cpp
@@ -58,6 +58,7 @@ GM107LoweringPass::handleManualTXD(TexInstruction *i)
    Value *zero = bld.loadImm(bld.getSSA(), 0);
    int l, c;
    const int dim = i->tex.target.getDim();
+   const int array = i->tex.target.isArray();
 
    i->op = OP_TEX; // no need to clone dPdx/dPdy later
 
@@ -69,7 +70,7 @@ GM107LoweringPass::handleManualTXD(TexInstruction *i)
       // mov coordinates from lane l to all lanes
       bld.mkOp(OP_QUADON, TYPE_NONE, NULL);
       for (c = 0; c < dim; ++c) {
-         bld.mkOp2(OP_SHFL, TYPE_F32, crd[c], i->getSrc(c), bld.mkImm(l));
+         bld.mkOp2(OP_SHFL, TYPE_F32, crd[c], i->getSrc(c + array), bld.mkImm(l));
          add = bld.mkOp2(OP_QUADOP, TYPE_F32, crd[c], crd[c], zero);
          add->subOp = 0x00;
          add->lanes = 1; /* abused for .ndv */
@@ -94,7 +95,7 @@ GM107LoweringPass::handleManualTXD(TexInstruction *i)
       // texture
       bld.insert(tex = cloneForward(func, i));
       for (c = 0; c < dim; ++c)
-         tex->setSrc(c, crd[c]);
+         tex->setSrc(c + array, crd[c]);
       bld.mkOp(OP_QUADPOP, TYPE_NONE, NULL);
 
       // save results
@@ -158,7 +159,10 @@ GM107LoweringPass::handlePFETCH(Instruction *i)
    bld.mkOp2(OP_SHR , TYPE_U32, tmp1, tmp0, bld.mkImm(16));
    bld.mkOp2(OP_AND , TYPE_U32, tmp0, tmp0, bld.mkImm(0xff));
    bld.mkOp2(OP_AND , TYPE_U32, tmp1, tmp1, bld.mkImm(0xff));
-   bld.mkOp1(OP_MOV , TYPE_U32, tmp2, bld.mkImm(i->getSrc(0)->reg.data.u32));
+   if (i->getSrc(1))
+      bld.mkOp2(OP_ADD , TYPE_U32, tmp2, i->getSrc(0), i->getSrc(1));
+   else
+      bld.mkOp1(OP_MOV , TYPE_U32, tmp2, i->getSrc(0));
    bld.mkOp3(OP_MAD , TYPE_U32, tmp0, tmp0, tmp1, tmp2);
    i->setSrc(0, tmp0);
    i->setSrc(1, NULL);
@@ -240,6 +244,20 @@ GM107LoweringPass::visit(Instruction *i)
             i->op = OP_VFETCH;
             assert(prog->getType() != Program::TYPE_FRAGMENT); // INTERP
          }
+      } else if (i->src(0).getFile() == FILE_MEMORY_CONST) {
+         if (i->src(0).isIndirect(1)) {
+            Value *ptr;
+            if (i->src(0).isIndirect(0))
+               ptr = bld.mkOp3v(OP_INSBF, TYPE_U32, bld.getSSA(),
+                                i->getIndirect(0, 1), bld.mkImm(0x1010),
+                                i->getIndirect(0, 0));
+            else
+               ptr = bld.mkOp2v(OP_SHL, TYPE_U32, bld.getSSA(),
+                                i->getIndirect(0, 1), bld.mkImm(16));
+            i->setIndirect(0, 1, NULL);
+            i->setIndirect(0, 0, ptr);
+            i->subOp = NV50_IR_SUBOP_LDC_IS;
+         }
       }
       break;
    case OP_ATOM:
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
index b3e1e69..31ff56c 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_lowering_nvc0.cpp
@@ -607,6 +607,21 @@ NVC0LoweringPass::handleTEX(TexInstruction *i)
    //  lod bias
    //  depth compare
    //  offsets (same as fermi, except txd which takes it with array)
+   //
+   // Maxwell (tex):
+   //  array
+   //  coords
+   //  indirect handle
+   //  sample
+   //  lod bias
+   //  depth compare
+   //  offsets
+   //
+   // Maxwell (txd):
+   //  indirect handle
+   //  coords
+   //  array + offsets
+   //  derivatives
 
    if (chipset >= NVISA_GK104_CHIPSET) {
       if (i->tex.rIndirectSrc >= 0 || i->tex.sIndirectSrc >= 0) {
@@ -640,12 +655,17 @@ NVC0LoweringPass::handleTEX(TexInstruction *i)
          const int sat = (i->op == OP_TXF) ? 1 : 0;
          DataType sTy = (i->op == OP_TXF) ? TYPE_U32 : TYPE_F32;
          bld.mkCvt(OP_CVT, TYPE_U16, layer, sTy, src)->saturate = sat;
-         for (int s = dim; s >= 1; --s)
-            i->setSrc(s, i->getSrc(s - 1));
-         i->setSrc(0, layer);
+         if (i->op != OP_TXD || chipset < NVISA_GM107_CHIPSET) {
+            for (int s = dim; s >= 1; --s)
+               i->setSrc(s, i->getSrc(s - 1));
+            i->setSrc(0, layer);
+         } else {
+            i->setSrc(dim, layer);
+         }
       }
       // Move the indirect reference to the first place
-      if (i->tex.rIndirectSrc >= 0) {
+      if (i->tex.rIndirectSrc >= 0 && (
+                i->op == OP_TXD || chipset < NVISA_GM107_CHIPSET)) {
          Value *hnd = i->getIndirectR();
 
          i->setIndirectR(NULL);
@@ -748,8 +768,10 @@ NVC0LoweringPass::handleTEX(TexInstruction *i)
             // create it if it's not already there, and INSBF it if it already
             // is.
             s = (i->tex.rIndirectSrc >= 0) ? 1 : 0;
+            if (chipset >= NVISA_GM107_CHIPSET)
+               s += dim;
             if (i->tex.target.isArray()) {
-               bld.mkOp3(OP_INSBF, TYPE_U32, i->getSrc(0),
+               bld.mkOp3(OP_INSBF, TYPE_U32, i->getSrc(s),
                          bld.loadImm(NULL, imm), bld.mkImm(0xc10),
                          i->getSrc(s));
             } else {
diff --git a/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp b/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
index 4b105b4..898653c 100644
--- a/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
+++ b/src/gallium/drivers/nouveau/codegen/nv50_ir_ra.cpp
@@ -25,6 +25,7 @@
 
 #include <stack>
 #include <limits>
+#include <tr1/unordered_set>
 
 namespace nv50_ir {
 
@@ -1547,6 +1548,11 @@ SpillCodeInserter::run(const std::list<ValuePair>& lst)
       LValue *lval = it->first->asLValue();
       Symbol *mem = it->second ? it->second->asSym() : NULL;
 
+      // Keep track of which instructions to delete later. Deleting them
+      // inside the loop is unsafe since a single instruction may have
+      // multiple destinations that all need to be spilled (like OP_SPLIT).
+      std::tr1::unordered_set<Instruction *> to_del;
+
       for (Value::DefIterator d = lval->defs.begin(); d != lval->defs.end();
            ++d) {
          Value *slot = mem ?
@@ -1579,7 +1585,7 @@ SpillCodeInserter::run(const std::list<ValuePair>& lst)
             d = lval->defs.erase(d);
             --d;
             if (slot->reg.file == FILE_MEMORY_LOCAL)
-               delete_Instruction(func->getProgram(), defi);
+               to_del.insert(defi);
             else
                defi->setDef(0, slot);
          } else {
@@ -1587,6 +1593,9 @@ SpillCodeInserter::run(const std::list<ValuePair>& lst)
          }
       }
 
+      for (std::tr1::unordered_set<Instruction *>::const_iterator it = to_del.begin();
+           it != to_del.end(); ++it)
+         delete_Instruction(func->getProgram(), *it);
    }
 
    // TODO: We're not trying to reuse old slots in a potential next iteration.
@@ -1912,6 +1921,13 @@ RegAlloc::InsertConstraintsPass::texConstraintGM107(TexInstruction *tex)
    if (isTextureOp(tex->op)) {
       if (tex->op != OP_TXQ) {
          s = tex->tex.target.getArgCount() - tex->tex.target.isMS();
+         if (tex->op == OP_TXD) {
+            // Indirect handle belongs in the first arg
+            if (tex->tex.rIndirectSrc >= 0)
+               s++;
+            if (!tex->tex.target.isArray() && tex->tex.useOffsets)
+               s++;
+         }
          n = tex->srcCount(0xff) - s;
       } else {
          s = tex->srcCount(0xff);
diff --git a/src/gallium/drivers/radeonsi/si_pipe.c b/src/gallium/drivers/radeonsi/si_pipe.c
index ae1d043..04f8b9a 100644
--- a/src/gallium/drivers/radeonsi/si_pipe.c
+++ b/src/gallium/drivers/radeonsi/si_pipe.c
@@ -39,6 +39,8 @@ static void si_destroy_context(struct pipe_context *context)
 
 	si_release_all_descriptors(sctx);
 
+	pipe_resource_reference(&sctx->esgs_ring.buffer, NULL);
+	pipe_resource_reference(&sctx->gsvs_ring.buffer, NULL);
 	pipe_resource_reference(&sctx->null_const_buf.buffer, NULL);
 	r600_resource_reference(&sctx->border_color_table, NULL);
 
diff --git a/src/gallium/drivers/radeonsi/si_shader.c b/src/gallium/drivers/radeonsi/si_shader.c
index 08ba8b0..23109dc 100644
--- a/src/gallium/drivers/radeonsi/si_shader.c
+++ b/src/gallium/drivers/radeonsi/si_shader.c
@@ -2894,5 +2894,9 @@ out:
 
 void si_pipe_shader_destroy(struct pipe_context *ctx, struct si_pipe_shader *shader)
 {
+	if (shader->gs_copy_shader)
+		si_pipe_shader_destroy(ctx, shader->gs_copy_shader);
+
 	r600_resource_reference(&shader->bo, NULL);
+	r600_resource_reference(&shader->scratch_bo, NULL);
 }
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 571c487..0ed044f 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -2316,9 +2316,10 @@ static void si_delete_shader_selector(struct pipe_context *ctx,
 
 	while (p) {
 		c = p->next_variant;
-		if (sel->type == PIPE_SHADER_GEOMETRY)
+		if (sel->type == PIPE_SHADER_GEOMETRY) {
 			si_pm4_delete_state(sctx, gs, p->pm4);
-		else if (sel->type == PIPE_SHADER_FRAGMENT)
+			si_pm4_delete_state(sctx, vs, p->gs_copy_shader->pm4);
+		} else if (sel->type == PIPE_SHADER_FRAGMENT)
 			si_pm4_delete_state(sctx, ps, p->pm4);
 		else if (p->key.vs.as_es)
 			si_pm4_delete_state(sctx, es, p->pm4);
@@ -2331,7 +2332,7 @@ static void si_delete_shader_selector(struct pipe_context *ctx,
 
 	free(sel->tokens);
 	free(sel);
- }
+}
 
 static void si_delete_vs_shader(struct pipe_context *ctx, void *state)
 {
diff --git a/src/gallium/state_trackers/clover/core/memory.cpp b/src/gallium/state_trackers/clover/core/memory.cpp
index ba6869d..905ebc0 100644
--- a/src/gallium/state_trackers/clover/core/memory.cpp
+++ b/src/gallium/state_trackers/clover/core/memory.cpp
@@ -29,14 +29,16 @@ using namespace clover;
 memory_obj::memory_obj(clover::context &ctx, cl_mem_flags flags,
                        size_t size, void *host_ptr) :
    context(ctx), _flags(flags),
-   _size(size), _host_ptr(host_ptr),
-   _destroy_notify([]{}) {
+   _size(size), _host_ptr(host_ptr) {
    if (flags & (CL_MEM_COPY_HOST_PTR | CL_MEM_USE_HOST_PTR))
       data.append((char *)host_ptr, size);
 }
 
 memory_obj::~memory_obj() {
-   _destroy_notify();
+   while (_destroy_notify.size()) {
+      _destroy_notify.top()();
+      _destroy_notify.pop();
+   }
 }
 
 bool
@@ -46,7 +48,7 @@ memory_obj::operator==(const memory_obj &obj) const {
 
 void
 memory_obj::destroy_notify(std::function<void ()> f) {
-   _destroy_notify = f;
+   _destroy_notify.push(f);
 }
 
 cl_mem_flags
diff --git a/src/gallium/state_trackers/clover/core/memory.hpp b/src/gallium/state_trackers/clover/core/memory.hpp
index f649ca0..bd6da6b 100644
--- a/src/gallium/state_trackers/clover/core/memory.hpp
+++ b/src/gallium/state_trackers/clover/core/memory.hpp
@@ -26,6 +26,7 @@
 #include <functional>
 #include <map>
 #include <memory>
+#include <stack>
 
 #include "core/object.hpp"
 #include "core/queue.hpp"
@@ -61,7 +62,7 @@ namespace clover {
       cl_mem_flags _flags;
       size_t _size;
       void *_host_ptr;
-      std::function<void ()> _destroy_notify;
+      std::stack<std::function<void ()>> _destroy_notify;
 
    protected:
       std::string data;
diff --git a/src/gallium/state_trackers/dri/dri_screen.c b/src/gallium/state_trackers/dri/dri_screen.c
index fdcedcb..9cdebf8 100644
--- a/src/gallium/state_trackers/dri/dri_screen.c
+++ b/src/gallium/state_trackers/dri/dri_screen.c
@@ -227,37 +227,6 @@ dri_fill_in_modes(struct dri_screen *screen)
    return (const __DRIconfig **)configs;
 }
 
-/* The Gallium way to force MSAA. */
-DEBUG_GET_ONCE_NUM_OPTION(msaa, "GALLIUM_MSAA", 0);
-
-/* The NVIDIA way to force MSAA. The same variable is used by the NVIDIA
- * driver. */
-DEBUG_GET_ONCE_NUM_OPTION(msaa_nv, "__GL_FSAA_MODE", 0);
-
-static void
-dri_force_msaa_visual(struct st_visual *stvis,
-                      struct pipe_screen *screen)
-{
-   int i;
-   int samples = debug_get_option_msaa();
-
-   if (!samples)
-      samples = debug_get_option_msaa_nv();
-
-   if (samples <= 1)
-      return; /* nothing to do */
-
-   /* Choose a supported sample count greater than or equal to samples. */
-   for (i = samples; i <= MSAA_VISUAL_MAX_SAMPLES; i++) {
-      if (screen->is_format_supported(screen, stvis->color_format,
-                                      PIPE_TEXTURE_2D, i,
-                                      PIPE_BIND_RENDER_TARGET)) {
-         stvis->samples = i;
-         break;
-      }
-   }
-}
-
 /**
  * Roughly the converse of dri_fill_in_modes.
  */
@@ -282,10 +251,6 @@ dri_fill_st_visual(struct st_visual *stvis, struct dri_screen *screen,
    if (mode->sampleBuffers) {
       stvis->samples = mode->samples;
    }
-   else {
-      /* This must be done after stvis->color_format is set. */
-      dri_force_msaa_visual(stvis, screen->base.screen);
-   }
 
    switch (mode->depthBits) {
    default:
diff --git a/src/gallium/state_trackers/xa/xa_renderer.c b/src/gallium/state_trackers/xa/xa_renderer.c
index 121d8ed..780b247 100644
--- a/src/gallium/state_trackers/xa/xa_renderer.c
+++ b/src/gallium/state_trackers/xa/xa_renderer.c
@@ -530,11 +530,22 @@ renderer_draw_yuv(struct xa_context *r,
                          src_x, src_y, src_w, src_h,
                          dst_x, dst_y, dst_w, dst_h, srf);
 
+   if (!r->scissor_valid) {
+       r->scissor.minx = 0;
+       r->scissor.miny = 0;
+       r->scissor.maxx = r->dst->tex->width0;
+       r->scissor.maxy = r->dst->tex->height0;
+   }
+
+   r->pipe->set_scissor_states(r->pipe, 0, 1, &r->scissor);
+
    cso_set_vertex_elements(r->cso, num_attribs, r->velems);
    util_draw_user_vertex_buffer(r->cso, r->buffer, PIPE_PRIM_QUADS,
                                 4,	/* verts */
                                 num_attribs);	/* attribs/vert */
    r->buffer_size = 0;
+
+   xa_scissor_reset(r);
 }
 
 void
diff --git a/src/gallium/state_trackers/xa/xa_yuv.c b/src/gallium/state_trackers/xa/xa_yuv.c
index 43f56ff..1519639 100644
--- a/src/gallium/state_trackers/xa/xa_yuv.c
+++ b/src/gallium/state_trackers/xa/xa_yuv.c
@@ -146,6 +146,7 @@ xa_yuv_planar_blit(struct xa_context *r,
 	int w = box->x2 - box->x1;
 	int h = box->y2 - box->y1;
 
+        xa_scissor_update(r, x, y, box->x2, box->y2);
 	renderer_draw_yuv(r,
 			  (float)src_x + scale_x * (x - dst_x),
 			  (float)src_y + scale_y * (y - dst_y),
diff --git a/src/glsl/Android.mk b/src/glsl/Android.mk
index 7b1fa7e..1cbc5c6 100644
--- a/src/glsl/Android.mk
+++ b/src/glsl/Android.mk
@@ -39,6 +39,7 @@ LOCAL_SRC_FILES := \
 	$(LIBGLSL_FILES)
 
 LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/mapi \
 	$(MESA_TOP)/src/mesa
 
@@ -59,10 +60,11 @@ LOCAL_SRC_FILES := \
 	$(GLSL_COMPILER_CXX_FILES)
 
 LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/mapi \
 	$(MESA_TOP)/src/mesa
 
-LOCAL_STATIC_LIBRARIES := libmesa_glsl libmesa_glsl_utils
+LOCAL_STATIC_LIBRARIES := libmesa_glsl libmesa_glsl_utils libmesa_util
 
 LOCAL_MODULE_TAGS := eng
 LOCAL_MODULE := glsl_compiler
diff --git a/src/glsl/glsl_types.cpp b/src/glsl/glsl_types.cpp
index 66e9b13..56b96f5 100644
--- a/src/glsl/glsl_types.cpp
+++ b/src/glsl/glsl_types.cpp
@@ -965,7 +965,7 @@ glsl_type::std140_size(bool row_major) const
          if (field_type->is_record() && (i + 1 < this->length))
             size = glsl_align(size, 16);
       }
-      size = glsl_align(size, max_align);
+      size = glsl_align(size, MAX2(max_align, 16));
       return size;
    }
 
diff --git a/src/glsl/lower_ubo_reference.cpp b/src/glsl/lower_ubo_reference.cpp
index 3cdfc04..43dd067 100644
--- a/src/glsl/lower_ubo_reference.cpp
+++ b/src/glsl/lower_ubo_reference.cpp
@@ -111,7 +111,7 @@ is_dereferenced_thing_row_major(const ir_dereference *deref)
          case GLSL_MATRIX_LAYOUT_COLUMN_MAJOR:
             return false;
          case GLSL_MATRIX_LAYOUT_ROW_MAJOR:
-            return matrix || deref->type->is_record();
+            return matrix || deref->type->without_array()->is_record();
          }
 
          unreachable("invalid matrix layout");
@@ -301,7 +301,14 @@ lower_ubo_reference_visitor::handle_rvalue(ir_rvalue **rvalue)
             deref = deref_array->array->as_dereference();
             break;
 	 } else {
-	    array_stride = deref_array->type->std140_size(row_major);
+            /* Whether or not the field is row-major (because it might be a
+             * bvec2 or something) does not affect the array itself.  We need
+             * to know whether an array element in its entirety is row-major.
+             */
+            const bool array_row_major =
+               is_dereferenced_thing_row_major(deref_array);
+
+	    array_stride = deref_array->type->std140_size(array_row_major);
 	    array_stride = glsl_align(array_stride, 16);
 	 }
 
@@ -327,6 +334,15 @@ lower_ubo_reference_visitor::handle_rvalue(ir_rvalue **rvalue)
 	 const glsl_type *struct_type = deref_record->record->type;
 	 unsigned intra_struct_offset = 0;
 
+         /* glsl_type::std140_base_alignment doesn't grok interfaces.  Use
+          * 16-bytes for the alignment because that is the general minimum of
+          * std140.
+          */
+         const unsigned struct_alignment = struct_type->is_interface()
+            ? 16
+            : struct_type->std140_base_alignment(row_major);
+
+
 	 for (unsigned int i = 0; i < struct_type->length; i++) {
 	    const glsl_type *type = struct_type->fields.structure[i].type;
 
@@ -346,6 +362,19 @@ lower_ubo_reference_visitor::handle_rvalue(ir_rvalue **rvalue)
 		       deref_record->field) == 0)
 	       break;
             intra_struct_offset += type->std140_size(field_row_major);
+
+            /* If the field just examined was itself a structure, apply rule
+             * #9:
+             *
+             *     "The structure may have padding at the end; the base offset
+             *     of the member following the sub-structure is rounded up to
+             *     the next multiple of the base alignment of the structure."
+             */
+            if (type->without_array()->is_record()) {
+               intra_struct_offset = glsl_align(intra_struct_offset,
+                                                struct_alignment);
+
+            }
 	 }
 
 	 const_offset += intra_struct_offset;
diff --git a/src/glx/dri3_glx.c b/src/glx/dri3_glx.c
index e3fc4de..ed30094 100644
--- a/src/glx/dri3_glx.c
+++ b/src/glx/dri3_glx.c
@@ -813,11 +813,15 @@ dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
     */
 
    fence_fd = xshmfence_alloc_shm();
-   if (fence_fd < 0)
+   if (fence_fd < 0) {
+      ErrorMessageF("DRI3 Fence object allocation failure %s\n", strerror(errno));
       return NULL;
+   }
    shm_fence = xshmfence_map_shm(fence_fd);
-   if (shm_fence == NULL)
+   if (shm_fence == NULL) {
+      ErrorMessageF("DRI3 Fence object map failure %s\n", strerror(errno));
       goto no_shm_fence;
+   }
 
    /* Allocate the image from the driver
     */
@@ -826,8 +830,10 @@ dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
       goto no_buffer;
 
    buffer->cpp = dri3_cpp_for_format(format);
-   if (!buffer->cpp)
+   if (!buffer->cpp) {
+      ErrorMessageF("DRI3 buffer format %d invalid\n", format);
       goto no_image;
+   }
 
    if (!psc->is_different_gpu) {
       buffer->image = (*psc->image->createImage) (psc->driScreen,
@@ -838,8 +844,10 @@ dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
                                                   buffer);
       pixmap_buffer = buffer->image;
 
-      if (!buffer->image)
+      if (!buffer->image) {
+         ErrorMessageF("DRI3 gpu image creation failure\n");
          goto no_image;
+      }
    } else {
       buffer->image = (*psc->image->createImage) (psc->driScreen,
                                                   width, height,
@@ -847,8 +855,10 @@ dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
                                                   0,
                                                   buffer);
 
-      if (!buffer->image)
+      if (!buffer->image) {
+         ErrorMessageF("DRI3 other gpu image creation failure\n");
          goto no_image;
+      }
 
       buffer->linear_buffer = (*psc->image->createImage) (psc->driScreen,
                                                           width, height,
@@ -858,19 +868,25 @@ dri3_alloc_render_buffer(struct glx_screen *glx_screen, Drawable draw,
                                                           buffer);
       pixmap_buffer = buffer->linear_buffer;
 
-      if (!buffer->linear_buffer)
+      if (!buffer->linear_buffer) {
+         ErrorMessageF("DRI3 gpu linear image creation failure\n");
          goto no_linear_buffer;
+      }
    }
 
    /* X wants the stride, so ask the image for it
     */
-   if (!(*psc->image->queryImage)(pixmap_buffer, __DRI_IMAGE_ATTRIB_STRIDE, &stride))
+   if (!(*psc->image->queryImage)(pixmap_buffer, __DRI_IMAGE_ATTRIB_STRIDE, &stride)) {
+      ErrorMessageF("DRI3 get image stride failed\n");
       goto no_buffer_attrib;
+   }
 
    buffer->pitch = stride;
 
-   if (!(*psc->image->queryImage)(pixmap_buffer, __DRI_IMAGE_ATTRIB_FD, &buffer_fd))
+   if (!(*psc->image->queryImage)(pixmap_buffer, __DRI_IMAGE_ATTRIB_FD, &buffer_fd)) {
+      ErrorMessageF("DRI3 get image FD failed\n");
       goto no_buffer_attrib;
+   }
 
    xcb_dri3_pixmap_from_buffer(c,
                                (pixmap = xcb_generate_id(c)),
@@ -910,6 +926,7 @@ no_buffer:
    xshmfence_unmap_shm(shm_fence);
 no_shm_fence:
    close(fence_fd);
+   ErrorMessageF("DRI3 alloc_render_buffer failed\n");
    return NULL;
 }
 
diff --git a/src/mesa/Android.gen.mk b/src/mesa/Android.gen.mk
index c6280f5..c7b7f7e 100644
--- a/src/mesa/Android.gen.mk
+++ b/src/mesa/Android.gen.mk
@@ -115,3 +115,12 @@ GET_HASH_GEN := $(LOCAL_PATH)/main/get_hash_generator.py
 $(intermediates)/main/get_hash.h: $(glapi)/gl_and_es_API.xml \
                $(LOCAL_PATH)/main/get_hash_params.py $(GET_HASH_GEN)
 	@$(MESA_PYTHON2) $(GET_HASH_GEN) -f $< > $@
+
+FORMAT_INFO := $(LOCAL_PATH)/main/format_info.py
+format_info_deps := \
+	$(LOCAL_PATH)/main/formats.csv \
+	$(LOCAL_PATH)/main/format_parser.py \
+	$(FORMAT_INFO)
+
+$(intermediates)/main/format_info.c: $(format_info_deps)
+	@$(MESA_PYTHON2) $(FORMAT_INFO) $< > $@
diff --git a/src/mesa/Android.libmesa_dricore.mk b/src/mesa/Android.libmesa_dricore.mk
index 28d6feb..1e6d948 100644
--- a/src/mesa/Android.libmesa_dricore.mk
+++ b/src/mesa/Android.libmesa_dricore.mk
@@ -32,6 +32,8 @@ LOCAL_PATH := $(call my-dir)
 #     MESA_FILES
 #     X86_FILES
 include $(LOCAL_PATH)/Makefile.sources
+SRCDIR :=
+BUILDDIR :=
 
 include $(CLEAR_VARS)
 
@@ -55,6 +57,7 @@ endif
 
 LOCAL_C_INCLUDES := \
 	$(call intermediates-dir-for STATIC_LIBRARIES,libmesa_program,,) \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/mapi \
 	$(MESA_TOP)/src/glsl \
 	$(MESA_TOP)/src/gallium/auxiliary
diff --git a/src/mesa/Android.libmesa_glsl_utils.mk b/src/mesa/Android.libmesa_glsl_utils.mk
index e93891f..a9f6ff5 100644
--- a/src/mesa/Android.libmesa_glsl_utils.mk
+++ b/src/mesa/Android.libmesa_glsl_utils.mk
@@ -36,11 +36,11 @@ include $(CLEAR_VARS)
 LOCAL_MODULE := libmesa_glsl_utils
 
 LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/glsl \
 	$(MESA_TOP)/src/mapi
 
 LOCAL_SRC_FILES := \
-	main/hash_table.c \
 	main/imports.c \
 	program/prog_hash_table.c \
 	program/symbol_table.c
@@ -59,11 +59,11 @@ LOCAL_IS_HOST_MODULE := true
 LOCAL_CFLAGS := -D_POSIX_C_SOURCE=199309L
 
 LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/glsl \
 	$(MESA_TOP)/src/mapi
 
 LOCAL_SRC_FILES := \
-	main/hash_table.c \
 	main/imports.c \
 	program/prog_hash_table.c \
 	program/symbol_table.c
diff --git a/src/mesa/Android.libmesa_st_mesa.mk b/src/mesa/Android.libmesa_st_mesa.mk
index e6374a6..8b8d652 100644
--- a/src/mesa/Android.libmesa_st_mesa.mk
+++ b/src/mesa/Android.libmesa_st_mesa.mk
@@ -32,6 +32,8 @@ LOCAL_PATH := $(call my-dir)
 # 	MESA_GALLIUM_FILES.
 # 	X86_FILES
 include $(LOCAL_PATH)/Makefile.sources
+SRCDIR :=
+BUILDDIR :=
 
 include $(CLEAR_VARS)
 
@@ -50,6 +52,7 @@ LOCAL_C_INCLUDES := \
 	$(call intermediates-dir-for STATIC_LIBRARIES,libmesa_program,,) \
 	$(MESA_TOP)/src/gallium/auxiliary \
 	$(MESA_TOP)/src/gallium/include \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/glsl \
 	$(MESA_TOP)/src/mapi
 
diff --git a/src/mesa/drivers/dri/i915/intel_screen.c b/src/mesa/drivers/dri/i915/intel_screen.c
index 3aaa45f..00d8580 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.c
+++ b/src/mesa/drivers/dri/i915/intel_screen.c
@@ -616,6 +616,8 @@ intel_create_image_from_fds(__DRIscreen *screen,
       return NULL;
    }
 
+   intel_setup_image_from_dimensions(image);
+
    image->planar_format = f;
    for (i = 0; i < f->nplanes; i++) {
       index = f->planes[i].buffer_index;
diff --git a/src/mesa/main/format_unpack.c b/src/mesa/main/format_unpack.c
index b84ed02..0e2c438 100644
--- a/src/mesa/main/format_unpack.c
+++ b/src/mesa/main/format_unpack.c
@@ -2100,7 +2100,7 @@ unpack_R8G8B8X8_SRGB(const void *src, GLfloat dst[][4], GLuint n)
       dst[i][RCOMP] = util_format_srgb_8unorm_to_linear_float( (s[i]      ) & 0xff );
       dst[i][GCOMP] = util_format_srgb_8unorm_to_linear_float( (s[i] >>  8) & 0xff );
       dst[i][BCOMP] = util_format_srgb_8unorm_to_linear_float( (s[i] >> 16) & 0xff );
-      dst[i][ACOMP] = UBYTE_TO_FLOAT( s[i] >> 24 ); /* linear! */
+      dst[i][ACOMP] = 1.0f;
    }
 }
 
diff --git a/src/mesa/main/get_hash_params.py b/src/mesa/main/get_hash_params.py
index ff85820..cd16c79 100644
--- a/src/mesa/main/get_hash_params.py
+++ b/src/mesa/main/get_hash_params.py
@@ -203,10 +203,10 @@ descriptor=[
   [ "COLOR_ARRAY_SIZE", "LOC_CUSTOM, TYPE_INT, 0, NO_EXTRA" ],
   [ "COLOR_ARRAY_TYPE", "ARRAY_ENUM(VertexAttrib[VERT_ATTRIB_COLOR0].Type), NO_EXTRA" ],
   [ "COLOR_ARRAY_STRIDE", "ARRAY_INT(VertexAttrib[VERT_ATTRIB_COLOR0].Stride), NO_EXTRA" ],
-  [ "TEXTURE_COORD_ARRAY", "LOC_CUSTOM, TYPE_BOOLEAN, offsetof(struct gl_client_array, Enabled), NO_EXTRA" ],
-  [ "TEXTURE_COORD_ARRAY_SIZE", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Size), NO_EXTRA" ],
-  [ "TEXTURE_COORD_ARRAY_TYPE", "LOC_CUSTOM, TYPE_ENUM, offsetof(struct gl_client_array, Type), NO_EXTRA" ],
-  [ "TEXTURE_COORD_ARRAY_STRIDE", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_client_array, Stride), NO_EXTRA" ],
+  [ "TEXTURE_COORD_ARRAY", "LOC_CUSTOM, TYPE_BOOLEAN, offsetof(struct gl_vertex_attrib_array, Enabled), NO_EXTRA" ],
+  [ "TEXTURE_COORD_ARRAY_SIZE", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_vertex_attrib_array, Size), NO_EXTRA" ],
+  [ "TEXTURE_COORD_ARRAY_TYPE", "LOC_CUSTOM, TYPE_ENUM, offsetof(struct gl_vertex_attrib_array, Type), NO_EXTRA" ],
+  [ "TEXTURE_COORD_ARRAY_STRIDE", "LOC_CUSTOM, TYPE_INT, offsetof(struct gl_vertex_attrib_array, Stride), NO_EXTRA" ],
 
 # GL_ARB_multitexture
   [ "MAX_TEXTURE_UNITS", "CONTEXT_INT(Const.MaxTextureUnits), NO_EXTRA" ],
diff --git a/src/mesa/program/Android.mk b/src/mesa/program/Android.mk
index e85afe6..19c4be0 100644
--- a/src/mesa/program/Android.mk
+++ b/src/mesa/program/Android.mk
@@ -39,6 +39,8 @@ endef
 # Import the following variables:
 #     PROGRAM_FILES
 include $(MESA_TOP)/src/mesa/Makefile.sources
+SRCDIR :=
+BUILDDIR :=
 
 include $(CLEAR_VARS)
 
@@ -71,6 +73,7 @@ $(intermediates)/program/lex.yy.c: $(LOCAL_PATH)/program_lexer.l
 
 LOCAL_C_INCLUDES := \
 	$(intermediates) \
+	$(MESA_TOP)/src \
 	$(MESA_TOP)/src/mapi \
 	$(MESA_TOP)/src/mesa \
 	$(MESA_TOP)/src/glsl
diff --git a/src/mesa/program/prog_optimize.c b/src/mesa/program/prog_optimize.c
index 6153f5e..0aa43d5 100644
--- a/src/mesa/program/prog_optimize.c
+++ b/src/mesa/program/prog_optimize.c
@@ -114,7 +114,6 @@ get_src_arg_mask(const struct prog_instruction *inst,
    read_mask = 0x0;
    for (comp = 0; comp < 4; ++comp) {
       const GLuint coord = GET_SWZ(inst->SrcReg[arg].Swizzle, comp);
-      ASSERT(coord < 4);
       if (channel_mask & (1 << comp) && coord <= SWIZZLE_W)
          read_mask |= 1 << coord;
    }
@@ -284,11 +283,11 @@ _mesa_remove_dead_code_global(struct gl_program *prog)
 
 	    for (comp = 0; comp < 4; comp++) {
 	       const GLuint swz = GET_SWZ(inst->SrcReg[j].Swizzle, comp);
-	       ASSERT(swz < 4);
-               if ((read_mask & (1 << swz)) == 0)
-		  continue;
-               if (swz <= SWIZZLE_W)
+               if (swz <= SWIZZLE_W) {
+                  if ((read_mask & (1 << swz)) == 0)
+                     continue;
                   tempRead[index][swz] = GL_TRUE;
+               }
 	    }
          }
       }
diff --git a/src/mesa/state_tracker/st_cb_bufferobjects.c b/src/mesa/state_tracker/st_cb_bufferobjects.c
index e0cb979..d53602c 100644
--- a/src/mesa/state_tracker/st_cb_bufferobjects.c
+++ b/src/mesa/state_tracker/st_cb_bufferobjects.c
@@ -246,21 +246,23 @@ st_bufferobj_data(struct gl_context *ctx,
       /* BufferData */
       switch (usage) {
       case GL_STATIC_DRAW:
-      case GL_STATIC_READ:
       case GL_STATIC_COPY:
       default:
 	 pipe_usage = PIPE_USAGE_DEFAULT;
          break;
       case GL_DYNAMIC_DRAW:
-      case GL_DYNAMIC_READ:
       case GL_DYNAMIC_COPY:
          pipe_usage = PIPE_USAGE_DYNAMIC;
          break;
       case GL_STREAM_DRAW:
-      case GL_STREAM_READ:
       case GL_STREAM_COPY:
          pipe_usage = PIPE_USAGE_STREAM;
          break;
+      case GL_STATIC_READ:
+      case GL_DYNAMIC_READ:
+      case GL_STREAM_READ:
+         pipe_usage = PIPE_USAGE_STAGING;
+         break;
       }
    }
 
diff --git a/src/mesa/swrast/s_texfetch_tmp.h b/src/mesa/swrast/s_texfetch_tmp.h
index 72037ec..3923e2b 100644
--- a/src/mesa/swrast/s_texfetch_tmp.h
+++ b/src/mesa/swrast/s_texfetch_tmp.h
@@ -808,11 +808,11 @@ static void
 FETCH(L8A8_SRGB)(const struct swrast_texture_image *texImage,
                  GLint i, GLint j, GLint k, GLfloat *texel)
 {
-   const GLubyte *src = TEXEL_ADDR(GLubyte, texImage, i, j, k, 2);
+   const GLushort s = *TEXEL_ADDR(GLushort, texImage, i, j, k, 1);
    texel[RCOMP] =
    texel[GCOMP] =
-   texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(src[0]);
-   texel[ACOMP] = UBYTE_TO_FLOAT(src[1]); /* linear */
+   texel[BCOMP] = util_format_srgb_8unorm_to_linear_float(s & 0xff);
+   texel[ACOMP] = UBYTE_TO_FLOAT(s >> 8); /* linear */
 }
 
 
diff --git a/src/mesa/vbo/vbo_exec_api.c b/src/mesa/vbo/vbo_exec_api.c
index 74aec12..2871100 100644
--- a/src/mesa/vbo/vbo_exec_api.c
+++ b/src/mesa/vbo/vbo_exec_api.c
@@ -1067,7 +1067,7 @@ void vbo_exec_vtx_init( struct vbo_exec_context *exec )
          struct gl_client_array *array;
          array = &arrays[VERT_ATTRIB_FF(i)];
          array->BufferObj = NULL;
-         _mesa_reference_buffer_object(ctx, &arrays->BufferObj,
+         _mesa_reference_buffer_object(ctx, &array->BufferObj,
                                  vbo->currval[VBO_ATTRIB_POS+i].BufferObj);
       }
 
diff --git a/src/util/Android.mk b/src/util/Android.mk
new file mode 100644
index 0000000..6b38cf9
--- /dev/null
+++ b/src/util/Android.mk
@@ -0,0 +1,102 @@
+# Mesa 3-D graphics library
+#
+# Copyright (C) 2014 Tomasz Figa <tomasz.figa@gmail.com>
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+# DEALINGS IN THE SOFTWARE.
+
+LOCAL_PATH := $(call my-dir)
+
+include $(LOCAL_PATH)/Makefile.sources
+
+# ---------------------------------------
+# Build libmesa_util
+# ---------------------------------------
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	$(MESA_UTIL_FILES)
+
+LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src/mesa \
+	$(MESA_TOP)/src/mapi \
+	$(MESA_TOP)/src
+
+LOCAL_MODULE := libmesa_util
+
+# Generated sources
+
+ifeq ($(LOCAL_MODULE_CLASS),)
+LOCAL_MODULE_CLASS := STATIC_LIBRARIES
+endif
+
+intermediates := $(call local-intermediates-dir)
+
+# This is the list of auto-generated files: sources and headers
+sources := $(addprefix $(intermediates)/, $(MESA_UTIL_GENERATED_FILES))
+
+LOCAL_GENERATED_SOURCES += $(sources)
+
+FORMAT_SRGB := $(LOCAL_PATH)/format_srgb.py
+
+$(intermediates)/format_srgb.c: $(FORMAT_SRGB)
+	@$(MESA_PYTHON2) $(FORMAT_SRGB) $< > $@
+
+include $(MESA_COMMON_MK)
+include $(BUILD_STATIC_LIBRARY)
+
+# ---------------------------------------
+# Build host libmesa_util
+# ---------------------------------------
+
+include $(CLEAR_VARS)
+
+LOCAL_IS_HOST_MODULE := true
+LOCAL_CFLAGS := -D_POSIX_C_SOURCE=199309L
+
+LOCAL_SRC_FILES := \
+	$(MESA_UTIL_FILES)
+
+LOCAL_C_INCLUDES := \
+	$(MESA_TOP)/src/mesa \
+	$(MESA_TOP)/src/mapi \
+	$(MESA_TOP)/src
+
+LOCAL_MODULE := libmesa_util
+
+# Generated sources
+
+ifeq ($(LOCAL_MODULE_CLASS),)
+LOCAL_MODULE_CLASS := STATIC_LIBRARIES
+endif
+
+intermediates := $(call local-intermediates-dir)
+
+# This is the list of auto-generated files: sources and headers
+sources := $(addprefix $(intermediates)/, $(MESA_UTIL_GENERATED_FILES))
+
+LOCAL_GENERATED_SOURCES += $(sources)
+
+FORMAT_SRGB := $(LOCAL_PATH)/format_srgb.py
+
+$(intermediates)/format_srgb.c: $(FORMAT_SRGB)
+	@$(MESA_PYTHON2) $(FORMAT_SRGB) $< > $@
+
+include $(MESA_COMMON_MK)
+include $(BUILD_HOST_STATIC_LIBRARY)
