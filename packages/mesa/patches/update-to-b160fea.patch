diff --git a/Makefile.am b/Makefile.am
index 361fb51..600adad 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -36,7 +36,6 @@ PACKAGE_NAME = MesaLib-$(PACKAGE_VERSION)
 EXTRA_FILES = \
 	aclocal.m4					\
 	configure					\
-	VERSION					\
 	bin/ar-lib					\
 	bin/compile					\
 	bin/config.sub					\
diff --git a/docs/relnotes/10.0.html b/docs/relnotes/10.0.html
index d3b1f8f..4622f45 100644
--- a/docs/relnotes/10.0.html
+++ b/docs/relnotes/10.0.html
@@ -33,7 +33,9 @@ because compatibility contexts are not supported.
 
 <h2>MD5 checksums</h2>
 <pre>
-TBD.
+b38626b96c664db67a534d7859682436  MesaLib-10.0.0.tar.gz
+f3fe55d9735bea158bbe97ed9a0da819  MesaLib-10.0.0.tar.bz2
+c6ee1ce51e3bf35947d2978b872daf51  MesaLib-10.0.0.zip
 </pre>
 
 
diff --git a/src/gallium/drivers/nouveau/nouveau_buffer.c b/src/gallium/drivers/nouveau/nouveau_buffer.c
index 3e04049..95905a8 100644
--- a/src/gallium/drivers/nouveau/nouveau_buffer.c
+++ b/src/gallium/drivers/nouveau/nouveau_buffer.c
@@ -205,6 +205,9 @@ nouveau_transfer_write(struct nouveau_context *nv, struct nouveau_transfer *tx,
                   base, size / 4, (const uint32_t *)data);
    else
       nv->push_data(nv, buf->bo, buf->offset + base, buf->domain, size, data);
+
+   nouveau_fence_ref(nv->screen->fence.current, &buf->fence);
+   nouveau_fence_ref(nv->screen->fence.current, &buf->fence_wr);
 }
 
 
diff --git a/src/gallium/drivers/nouveau/nouveau_fence.c b/src/gallium/drivers/nouveau/nouveau_fence.c
index dea146c..c686710 100644
--- a/src/gallium/drivers/nouveau/nouveau_fence.c
+++ b/src/gallium/drivers/nouveau/nouveau_fence.c
@@ -189,16 +189,15 @@ nouveau_fence_wait(struct nouveau_fence *fence)
    /* wtf, someone is waiting on a fence in flush_notify handler? */
    assert(fence->state != NOUVEAU_FENCE_STATE_EMITTING);
 
-   if (fence->state < NOUVEAU_FENCE_STATE_EMITTED) {
+   if (fence->state < NOUVEAU_FENCE_STATE_EMITTED)
       nouveau_fence_emit(fence);
 
-      if (fence == screen->fence.current)
-         nouveau_fence_new(screen, &screen->fence.current, FALSE);
-   }
-   if (fence->state < NOUVEAU_FENCE_STATE_FLUSHED) {
+   if (fence->state < NOUVEAU_FENCE_STATE_FLUSHED)
       if (nouveau_pushbuf_kick(screen->pushbuf, screen->pushbuf->channel))
          return FALSE;
-   }
+
+   if (fence == screen->fence.current)
+      nouveau_fence_next(screen);
 
    do {
       nouveau_fence_update(screen, FALSE);
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c b/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
index 866829c..86b9a23 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state_validate.c
@@ -61,7 +61,7 @@ nv50_validate_fb(struct nv50_context *nv50)
       if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
          nv50->state.rt_serialize = TRUE;
       mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
-      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;
+      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
 
       /* only register for writing, otherwise we'd always serialize here */
       BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
@@ -91,7 +91,7 @@ nv50_validate_fb(struct nv50_context *nv50)
       if (mt->base.status & NOUVEAU_BUFFER_STATUS_GPU_READING)
          nv50->state.rt_serialize = TRUE;
       mt->base.status |= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
-      mt->base.status &= NOUVEAU_BUFFER_STATUS_GPU_READING;
+      mt->base.status &= ~NOUVEAU_BUFFER_STATUS_GPU_READING;
 
       BCTX_REFN(nv50->bufctx_3d, FB, &mt->base, WR);
    } else {
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_tex.c b/src/gallium/drivers/nouveau/nv50/nv50_tex.c
index 9e51292..f7284fa 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_tex.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_tex.c
@@ -271,7 +271,7 @@ nv50_validate_tic(struct nv50_context *nv50, int s)
 
       nv50->screen->tic.lock[tic->id / 32] |= 1 << (tic->id % 32);
 
-      res->status &= NOUVEAU_BUFFER_STATUS_GPU_WRITING;
+      res->status &= ~NOUVEAU_BUFFER_STATUS_GPU_WRITING;
       res->status |= NOUVEAU_BUFFER_STATUS_GPU_READING;
 
       BCTX_REFN(nv50->bufctx_3d, TEXTURES, res, RD);
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_vbo.c b/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
index c6162b5..947c67d 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_vbo.c
@@ -597,6 +597,15 @@ nv50_draw_elements(struct nv50_context *nv50, boolean shorten,
 
       assert(nouveau_resource_mapped_by_gpu(nv50->idxbuf.buffer));
 
+      /* This shouldn't have to be here. The going theory is that the buffer
+       * is being filled in by PGRAPH, and it's not done yet by the time it
+       * gets submitted to PFIFO, which in turn starts immediately prefetching
+       * the not-yet-written data. Ideally this wait would only happen on
+       * pushbuf submit, but it's probably not a big performance difference.
+       */
+      if (buf->fence_wr && !nouveau_fence_signalled(buf->fence_wr))
+         nouveau_fence_wait(buf->fence_wr);
+
       while (instance_count--) {
          BEGIN_NV04(push, NV50_3D(VERTEX_BEGIN_GL), 1);
          PUSH_DATA (push, prim);
diff --git a/src/gallium/state_trackers/xa/xa_tracker.h b/src/gallium/state_trackers/xa/xa_tracker.h
index 65a67bb..1230dab 100644
--- a/src/gallium/state_trackers/xa/xa_tracker.h
+++ b/src/gallium/state_trackers/xa/xa_tracker.h
@@ -36,7 +36,7 @@
 
 #include <stdint.h>
 
-#define XA_TRACKER_VERSION_MAJOR 1
+#define XA_TRACKER_VERSION_MAJOR 2
 #define XA_TRACKER_VERSION_MINOR 0
 #define XA_TRACKER_VERSION_PATCH 0
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
index 7e436f7..bbb8cb0 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
@@ -2102,6 +2102,21 @@ brw_blorp_blit_params::brw_blorp_blit_params(struct brw_context *brw,
       src.brw_surfaceformat = dst.brw_surfaceformat;
    }
 
+   /* When doing a multisample resolve of a GL_LUMINANCE32F or GL_INTENSITY32F
+    * texture, the above code configures the source format for L32_FLOAT or
+    * I32_FLOAT, and the destination format for R32_FLOAT.  On Sandy Bridge,
+    * the SAMPLE message appears to handle multisampled L32_FLOAT and
+    * I32_FLOAT textures incorrectly, resulting in blocky artifacts.  So work
+    * around the problem by using a source format of R32_FLOAT.  This
+    * shouldn't affect rendering correctness, since the destination format is
+    * R32_FLOAT, so only the contents of the red channel matters.
+    */
+   if (brw->gen == 6 && src.num_samples > 1 && dst.num_samples <= 1 &&
+       src_mt->format == dst_mt->format &&
+       dst.brw_surfaceformat == BRW_SURFACEFORMAT_R32_FLOAT) {
+      src.brw_surfaceformat = dst.brw_surfaceformat;
+   }
+
    use_wm_prog = true;
    memset(&wm_prog_key, 0, sizeof(wm_prog_key));
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp b/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
index 02ec273..1904bde 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
@@ -265,24 +265,17 @@ brw_blorp_clear_params::brw_blorp_clear_params(struct brw_context *brw,
       x_align *= 16;
       y_align *= 32;
 
-      if (brw->is_haswell && brw->gt == 3) {
-         /* From BSpec: 3D-Media-GPGPU Engine > 3D Pipeline > Pixel > Pixel
-          * Backend > MCS Buffer for Render Target(s) [DevIVB+]:
-          * [DevHSW:GT3]: Clear rectangle must be aligned to two times the
-          * number of pixels in the table shown below...
-          * x_align, y_align values computed above are the relevant entries
-          * in the referred table.
-          */
-         x0 = ROUND_DOWN_TO(x0, 2 * x_align);
-         y0 = ROUND_DOWN_TO(y0, 2 * y_align);
-         x1 = ALIGN(x1, 2 * x_align);
-         y1 = ALIGN(y1, 2 * y_align);
-      } else {
-         x0 = ROUND_DOWN_TO(x0,  x_align);
-         y0 = ROUND_DOWN_TO(y0, y_align);
-         x1 = ALIGN(x1, x_align);
-         y1 = ALIGN(y1, y_align);
-      }
+      /* From BSpec: 3D-Media-GPGPU Engine > 3D Pipeline > Pixel > Pixel
+       * Backend > MCS Buffer for Render Target(s) [DevIVB+] > Table "Color
+       * Clear of Non-MultiSampled Render Target Restrictions":
+       *
+       *   Clear rectangle must be aligned to two times the number of pixels in
+       *   the table shown below due to 16x16 hashing across the slice.
+       */
+      x0 = ROUND_DOWN_TO(x0, 2 * x_align);
+      y0 = ROUND_DOWN_TO(y0, 2 * y_align);
+      x1 = ALIGN(x1, 2 * x_align);
+      y1 = ALIGN(y1, 2 * y_align);
 
       /* From the Ivy Bridge PRM, Vol2 Part1 11.7 "MCS Buffer for Render
        * Target(s)", beneath the "Fast Color Clear" bullet (p327):
diff --git a/src/mesa/main/context.c b/src/mesa/main/context.c
index 8cbc935..55d797b 100644
--- a/src/mesa/main/context.c
+++ b/src/mesa/main/context.c
@@ -1194,6 +1194,7 @@ _mesa_free_context_data( struct gl_context *ctx )
    _mesa_free_sync_data(ctx);
    _mesa_free_varray_data(ctx);
    _mesa_free_transform_feedback(ctx);
+   _mesa_free_performance_monitors(ctx);
 
    _mesa_reference_buffer_object(ctx, &ctx->Pack.BufferObj, NULL);
    _mesa_reference_buffer_object(ctx, &ctx->Unpack.BufferObj, NULL);
diff --git a/src/mesa/main/performance_monitor.c b/src/mesa/main/performance_monitor.c
index 17cae51..3d9b4f8 100644
--- a/src/mesa/main/performance_monitor.c
+++ b/src/mesa/main/performance_monitor.c
@@ -89,6 +89,25 @@ fail:
    return NULL;
 }
 
+static void
+free_performance_monitor(GLuint key, void *data, void *user)
+{
+   struct gl_perf_monitor_object *m = data;
+   struct gl_context *ctx = user;
+
+   ralloc_free(m->ActiveGroups);
+   ralloc_free(m->ActiveCounters);
+   ctx->Driver.DeletePerfMonitor(ctx, m);
+}
+
+void
+_mesa_free_performance_monitors(struct gl_context *ctx)
+{
+   _mesa_HashDeleteAll(ctx->PerfMonitor.Monitors,
+                       free_performance_monitor, ctx);
+   _mesa_DeleteHashTable(ctx->PerfMonitor.Monitors);
+}
+
 static inline struct gl_perf_monitor_object *
 lookup_monitor(struct gl_context *ctx, GLuint id)
 {
diff --git a/src/mesa/main/performance_monitor.h b/src/mesa/main/performance_monitor.h
index a852a41..76234e5 100644
--- a/src/mesa/main/performance_monitor.h
+++ b/src/mesa/main/performance_monitor.h
@@ -35,6 +35,9 @@
 extern void
 _mesa_init_performance_monitors(struct gl_context *ctx);
 
+extern void
+_mesa_free_performance_monitors(struct gl_context *ctx);
+
 extern void GLAPIENTRY
 _mesa_GetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize,
                               GLuint *groups);
