diff -uNr enigma2-20130618/lib/base/cachedtssource.cpp enigma2/lib/base/cachedtssource.cpp
--- enigma2-20130618/lib/base/cachedtssource.cpp	1970-01-01 08:00:00.000000000 +0800
+++ enigma2/lib/base/cachedtssource.cpp	2013-06-24 17:15:12.047261662 +0800
@@ -0,0 +1,55 @@
+#include <lib/base/cachedtssource.h>
+
+static const unsigned int CACHE_SIZE = 32*1024;
+
+DEFINE_REF(eCachedSource);
+
+eCachedSource::eCachedSource(ePtr<iTsSource>& source)
+	: iTsSource(source->getPacketSize())
+	, m_source(source)
+	, m_cache_buffer((char*)malloc(CACHE_SIZE))
+	, m_cache_offset(0)
+	, m_cache_bytes(0)
+{
+}
+
+eCachedSource::~eCachedSource()
+{
+	free(m_cache_buffer);
+}
+
+ssize_t eCachedSource::read(off_t offset, void *buf, size_t count)
+{
+	/* Not quite optimal, but just enough to read bit more efficient than tiny 188 byte chunks */
+	if (count >= CACHE_SIZE)
+		return m_source->read(offset, buf, count);
+	if ((offset < m_cache_offset) || (offset+count >= m_cache_offset + m_cache_bytes))
+	{
+		/* Update the cache */
+		ssize_t bytes = m_source->read(offset, m_cache_buffer, CACHE_SIZE);
+		if (bytes <= 0)
+			return bytes;
+		if ((size_t)bytes < count)
+			count = bytes; /* probably past EOF */
+		m_cache_offset = offset;
+		m_cache_bytes = bytes;
+	}
+	unsigned int cache_index = offset - m_cache_offset;
+	memcpy(buf, m_cache_buffer + cache_index, count);
+	return count;
+}
+
+int eCachedSource::valid()
+{
+	return (m_cache_buffer != NULL) && m_source->valid();
+}
+
+off_t eCachedSource::length()
+{
+	return m_source->length();
+}
+
+off_t eCachedSource::offset()
+{
+	return m_cache_offset;
+}
diff -uNr enigma2-20130618/lib/base/cachedtssource.h enigma2/lib/base/cachedtssource.h
--- enigma2-20130618/lib/base/cachedtssource.h	1970-01-01 08:00:00.000000000 +0800
+++ enigma2/lib/base/cachedtssource.h	2013-06-25 13:12:39.504172560 +0800
@@ -0,0 +1,26 @@
+#ifndef __lib_base_cachedtssource_h
+#define __lib_base_cachedtssource_h
+
+#include <lib/base/itssource.h>
+
+class eCachedSource: public iTsSource
+{
+	DECLARE_REF(eCachedSource);
+public:
+	eCachedSource(ePtr<iTsSource>& source);
+	~eCachedSource();
+
+	// iTsSource
+	ssize_t read(off_t offset, void *buf, size_t count);
+	off_t length();
+	off_t offset();
+	int valid();
+	bool isStream() { return m_source->isStream(); };
+private:
+	ePtr<iTsSource> m_source;
+	char* m_cache_buffer;
+	off_t m_cache_offset;
+	unsigned int m_cache_bytes;
+};
+
+#endif
diff -uNr enigma2-20130618/lib/base/httpstream.cpp enigma2/lib/base/httpstream.cpp
--- enigma2-20130618/lib/base/httpstream.cpp	2013-06-18 00:27:46.671072339 +0800
+++ enigma2/lib/base/httpstream.cpp	2013-06-25 13:12:39.504172560 +0800
@@ -10,10 +10,12 @@
 eHttpStream::eHttpStream()
 {
 	streamSocket = -1;
+	connectionStatus = FAILED;
 }
 
 eHttpStream::~eHttpStream()
 {
+	kill(true);
 	close();
 }
 
@@ -157,19 +159,38 @@
 
 int eHttpStream::open(const char *url)
 {
+	streamUrl = url;
+	/*
+	 * We're in gui thread context here, and establishing
+	 * a connection might block for up to 10 seconds.
+	 * Spawn a new thread to establish the connection.
+	 */
+	connectionStatus = BUSY;
+	eDebug("eHttpStream::Start thread");
+	run();
+	return 0;
+}
+
+void eHttpStream::thread()
+{
+	hasStarted();
 	std::string currenturl, newurl;
-	currenturl = url;
+	currenturl = streamUrl;
 	for (unsigned int i = 0; i < 3; i++)
 	{
 		if (openUrl(currenturl, newurl) < 0)
 		{
 			/* connection failed */
-			return -1;
+			eDebug("eHttpStream::Thread end NO connection");
+			connectionStatus = FAILED;
+			return;
 		}
 		if (newurl == "")
 		{
 			/* we have a valid stream connection */
-			return 0;
+			eDebug("eHttpStream::Thread end connection");
+			connectionStatus = CONNECTED;
+			return;
 		}
 		/* switch to new url */
 		close();
@@ -177,14 +198,16 @@
 		newurl = "";
 	}
 	/* too many redirect / playlist levels (we accept one redirect + one playlist) */
-	return -1;
+	eDebug("eHttpStream::Thread end NO connection");
+	connectionStatus = FAILED;
+	return;
 }
-
+/*---
 off_t eHttpStream::lseek(off_t offset, int whence)
 {
 	return (off_t)-1;
 }
-
+*/
 int eHttpStream::close()
 {
 	int retval = -1;
@@ -198,11 +221,17 @@
 
 ssize_t eHttpStream::read(off_t offset, void *buf, size_t count)
 {
+	if (connectionStatus == BUSY)
+		return 0;
+	else if (connectionStatus == FAILED)
+		return -1;
 	return timedRead(streamSocket, buf, count, 5000, 500);
 }
 
 int eHttpStream::valid()
 {
+	if (connectionStatus == BUSY)
+		return 0;
 	return streamSocket >= 0;
 }
 
diff -uNr enigma2-20130618/lib/base/httpstream.h enigma2/lib/base/httpstream.h
--- enigma2-20130618/lib/base/httpstream.h	2013-06-18 00:27:46.671072339 +0800
+++ enigma2/lib/base/httpstream.h	2013-06-25 13:12:39.504172560 +0800
@@ -4,22 +4,26 @@
 #include <string>
 #include <lib/base/ebase.h>
 #include <lib/base/itssource.h>
+#include <lib/base/thread.h>
 
-class eHttpStream: public iTsSource, public Object
+class eHttpStream: public iTsSource, public Object, public eThread
 {
 	DECLARE_REF(eHttpStream);
 
 	int streamSocket;
+	enum { BUSY, CONNECTED, FAILED } connectionStatus;
+	std::string streamUrl;
 	std::string authorizationData;
 
 	int openUrl(const std::string &url, std::string &newurl);
+	void thread();
 
 	/* iTsSource */
-	off_t lseek(off_t offset, int whence);
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	off_t offset();
 	int valid();
+	bool isStream() { return true; };
 
 public:
 	eHttpStream();
diff -uNr enigma2-20130618/lib/base/itssource.h enigma2/lib/base/itssource.h
--- enigma2-20130618/lib/base/itssource.h	2013-06-18 00:27:46.671072339 +0800
+++ enigma2/lib/base/itssource.h	2013-06-25 13:12:39.504172560 +0800
@@ -10,15 +10,14 @@
 
 public:
 	iTsSource(int packetsize = 188) : packetSize(packetsize) {}
-	 /* NOTE: should only be used to get current position or filelength */
-	virtual off_t lseek(off_t offset, int whence)=0;
-	
+
 	/* NOTE: you must be able to handle short reads! */
 	virtual ssize_t read(off_t offset, void *buf, size_t count)=0; /* NOTE: this is what you in normal case have to use!! */
 
 	virtual off_t length()=0;
 	virtual int valid()=0;
 	virtual off_t offset() = 0;
+	virtual bool isStream() { return false; }
 	int getPacketSize() const { return packetSize; }
 };
 
diff -uNr enigma2-20130618/lib/base/Makefile.inc enigma2/lib/base/Makefile.inc
--- enigma2-20130618/lib/base/Makefile.inc	2013-06-18 00:27:46.667072339 +0800
+++ enigma2/lib/base/Makefile.inc	2013-06-24 17:15:12.031261663 +0800
@@ -2,6 +2,7 @@
 
 base_libenigma_base_a_SOURCES = \
 	base/buffer.cpp \
+	base/cachedtssource.cpp \
 	base/connection.cpp \
 	base/console.cpp \
 	base/ebase.cpp \
@@ -31,6 +32,7 @@
 baseincludedir = $(pkgincludedir)/lib/base
 baseinclude_HEADERS = \
 	base/buffer.h \
+	base/cachedtssource.h \
 	base/console.h \
 	base/ebase.h \
 	base/eenv.h \
diff -uNr enigma2-20130618/lib/base/rawfile.cpp enigma2/lib/base/rawfile.cpp
--- enigma2-20130618/lib/base/rawfile.cpp	2013-06-18 00:27:46.671072339 +0800
+++ enigma2/lib/base/rawfile.cpp	2013-07-23 19:15:59.923132605 +0800
@@ -10,7 +10,6 @@
 	: iTsSource(packetsize)
 	, m_lock(false)
 	, m_fd(-1)
-	, m_file(NULL)
 	, m_splitsize(0)
 	, m_totallength(0)
 	, m_current_offset(0)
@@ -27,98 +26,47 @@
 	close();
 }
 
-int eRawFile::open(const char *filename, int cached)
+int eRawFile::open(const char *filename)
 {
 	close();
-	m_cached = cached;
 	m_basename = filename;
 	scan();
 	m_current_offset = 0;
 	m_last_offset = 0;
-	if (!cached)
-	{
-		m_fd = ::open(filename, O_RDONLY | O_LARGEFILE);
-		return m_fd;
-	} else
-	{
-		m_file = ::fopen64(filename, "rb");
-		if (!m_file)
-			return -1;
-		return 0;
-	}
+	m_fd = ::open(filename, O_RDONLY | O_LARGEFILE);
+	posix_fadvise(m_fd, 0, 0, POSIX_FADV_SEQUENTIAL);
+	return m_fd;
 }
 
 void eRawFile::setfd(int fd)
 {
 	close();
-	m_cached = 0;
 	m_nrfiles = 1;
 	m_fd = fd;
 }
 
-off_t eRawFile::lseek(off_t offset, int whence)
-{
-	eSingleLocker l(m_lock);
-	m_current_offset = lseek_internal(offset, whence);
-	return m_current_offset;
-}
-
-off_t eRawFile::lseek_internal(off_t offset, int whence)
+off_t eRawFile::lseek_internal(off_t offset)
 {
 //	eDebug("lseek: %lld, %d", offset, whence);
 		/* if there is only one file, use the native lseek - the file could be growing! */
 	if (m_nrfiles < 2)
 	{
-		if (!m_cached)
-			return ::lseek(m_fd, offset, whence);
-		else
-		{
-			if (::fseeko(m_file, offset, whence) < 0)
-				perror("fseeko");
-			return ::ftello(m_file);
-		}
+		return ::lseek(m_fd, offset, SEEK_SET);
 	}
-	switch (whence)
-	{
-	case SEEK_SET:
-		m_current_offset = offset;
-		break;
-	case SEEK_CUR:
-		m_current_offset += offset;
-		break;
-	case SEEK_END:
-		m_current_offset = m_totallength + offset;
-		break;
-	}
-
-	if (m_current_offset < 0)
-		m_current_offset = 0;
+	m_current_offset = offset;
 	return m_current_offset;
 }
 
 int eRawFile::close()
 {
-	if (m_cached)
-	{
-		if (!m_file)
-			return -1;
-		posix_fadvise(fileno(m_file), 0, 0, POSIX_FADV_DONTNEED);
-		m_fadvise_chunk = 0;
-		::fclose(m_file);
-		m_file = 0;
-		return 0;
-	} else
+	int ret = 0;
+	if (m_fd >= 0)
 	{
-		int ret = 0;
-		if (m_fd >= 0)
-		{
-			posix_fadvise(m_fd, 0, 0, POSIX_FADV_DONTNEED);
-			m_fadvise_chunk = 0;
-			ret = ::close(m_fd);
-			m_fd = -1;
-		}
-		return ret;
+		posix_fadvise(m_fd, 0, 0, POSIX_FADV_DONTNEED);
+		ret = ::close(m_fd);
+		m_fd = -1;
 	}
+	return ret;
 }
 
 ssize_t eRawFile::read(off_t offset, void *buf, size_t count)
@@ -127,7 +75,7 @@
 
 	if (offset != m_current_offset)
 	{
-		m_current_offset = lseek_internal(offset, SEEK_SET);
+		m_current_offset = lseek_internal(offset);
 		if (m_current_offset < 0)
 			return m_current_offset;
 	}
@@ -144,33 +92,18 @@
 	
 	int ret;
 	
-	if (!m_cached)
-		ret = ::read(m_fd, buf, count);
-	else
-		ret = ::fread(buf, 1, count, m_file);
+	ret = ::read(m_fd, buf, count);
 
 	if (ret > 0)
 	{
 		m_current_offset = m_last_offset += ret;
-		if (!m_cached)
-		{
-			m_fadvise_chunk += ret;
-			if (m_fadvise_chunk >= 4 * 1024 * 1024)
-			{
-				posix_fadvise(m_fd, 0, m_current_offset - m_base_offset, POSIX_FADV_DONTNEED);
-				m_fadvise_chunk = 0;
-			}
-		}
 	}
 	return ret;
 }
 
 int eRawFile::valid()
 {
-	if (!m_cached)
-		return m_fd != -1;
-	else
-		return !!m_file;
+	return m_fd != -1;
 }
 
 void eRawFile::scan()
@@ -179,27 +112,13 @@
 	m_totallength = 0;
 	while (m_nrfiles < 1000) /* .999 is the last possible */
 	{
-		if (!m_cached)
-		{
-			int f = openFileUncached(m_nrfiles);
-			if (f < 0)
-				break;
-			if (!m_nrfiles)
-				m_splitsize = ::lseek(f, 0, SEEK_END);
-			m_totallength += ::lseek(f, 0, SEEK_END);
-			::close(f);
-		} else
-		{
-			FILE *f = openFileCached(m_nrfiles);
-			if (!f)
-				break;
-			::fseeko(f, 0, SEEK_END);
-			if (!m_nrfiles)
-				m_splitsize = ::ftello(f);
-			m_totallength += ::ftello(f);
-			::fclose(f);
-		}
-		
+		int f = openFileUncached(m_nrfiles);
+		if (f < 0)
+			break;
+		if (!m_nrfiles)
+			m_splitsize = ::lseek(f, 0, SEEK_END);
+		m_totallength += ::lseek(f, 0, SEEK_END);
+		::close(f);
 		++m_nrfiles;
 	}
 //	eDebug("found %d files, splitsize: %llx, totallength: %llx", m_nrfiles, m_splitsize, m_totallength);
@@ -216,10 +135,7 @@
 		{	
 //			eDebug("-> %d", filenr);
 			close();
-			if (!m_cached)
-				m_fd = openFileUncached(filenr);
-			else
-				m_file = openFileCached(filenr);
+			m_fd = openFileUncached(filenr);
 			m_last_offset = m_base_offset = m_splitsize * filenr;
 			m_current_file = filenr;
 		}
@@ -228,13 +144,7 @@
 	
 	if (off != m_last_offset)
 	{
-		if (!m_cached)
-			m_last_offset = ::lseek(m_fd, off - m_base_offset, SEEK_SET) + m_base_offset;
-		else
-		{
-			::fseeko(m_file, off - m_base_offset, SEEK_SET);
-			m_last_offset = ::ftello(m_file) + m_base_offset;
-		}
+		m_last_offset = ::lseek(m_fd, off - m_base_offset, SEEK_SET) + m_base_offset;
 		return m_last_offset;
 	} else
 	{
@@ -242,20 +152,6 @@
 	}
 }
 
-/* m_cached */
-FILE *eRawFile::openFileCached(int nr)
-{
-	std::string filename = m_basename;
-	if (nr)
-	{
-		char suffix[5];
-		snprintf(suffix, 5, ".%03d", nr);
-		filename += suffix;
-	}
-	return ::fopen64(filename.c_str(), "rb");
-}
-
-/* !m_cached */
 int eRawFile::openFileUncached(int nr)
 {
 	std::string filename = m_basename;
@@ -270,7 +166,17 @@
 
 off_t eRawFile::length()
 {
-	return m_totallength;
+	if (m_nrfiles >= 2)
+	{
+		return m_totallength;
+	}
+	else
+	{
+		struct stat st;
+		if (::fstat(m_fd, &st) < 0)
+			return -1;
+		return st.st_size;
+	}
 }
 
 off_t eRawFile::offset()
@@ -289,7 +195,7 @@
  : eRawFile(packetsize)
 {
 	ringBuffer = new cRingBufferLinear(KILOBYTE(2024),TS_SIZE,true,"IN-TS");
-	ringBuffer->SetTimeouts(200,200);
+	ringBuffer->SetTimeouts(100,100);
 	bs_size = dvbcsa_bs_batch_size();
 	delivered=false;
 	lastPacketsCount = 0;
diff -uNr enigma2-20130618/lib/base/rawfile.h enigma2/lib/base/rawfile.h
--- enigma2-20130618/lib/base/rawfile.h	2013-06-18 00:27:46.667072339 +0800
+++ enigma2/lib/base/rawfile.h	2013-06-24 17:15:12.047261662 +0800
@@ -12,32 +12,29 @@
 public:
 	eRawFile(int packetsize = 188);
 	~eRawFile();
-	int open(const char *filename, int cached = 0);
+	int open(const char *filename);
 	void setfd(int fd);
 	int close();
 
 	// iTsSource
-	off_t lseek(off_t offset, int whence);
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	off_t offset();
 	int valid();
 protected:
 	eSingleLock m_lock;
-	int m_fd;     /* for uncached */
+	int m_fd;
 private:
-	FILE *m_file; /* for cached */
-	int m_cached;
 	off_t m_splitsize, m_totallength, m_current_offset, m_base_offset, m_last_offset;
 	int m_nrfiles;
 	int m_current_file;
 	int m_fadvise_chunk;
 	std::string m_basename;
 
+//	int close();
 	void scan();
 	int switchOffset(off_t off);
-	off_t lseek_internal(off_t offset, int whence);
-	FILE *openFileCached(int nr);
+	off_t lseek_internal(off_t offset);
 	int openFileUncached(int nr);
 };
 
diff -uNr enigma2-20130618/lib/dvb/decsa.cpp enigma2/lib/dvb/decsa.cpp
--- enigma2-20130618/lib/dvb/decsa.cpp	2013-06-18 00:27:46.747072336 +0800
+++ enigma2/lib/dvb/decsa.cpp	2013-07-23 19:15:59.931132605 +0800
@@ -4,31 +4,40 @@
 
 #include <lib/dvb/decsa.h>
 
-cDeCSA::cDeCSA(int _adapter, int _demux) {
+static bool CheckNull(const unsigned char *data, int len)
+{
+  while(--len>=0)
+    if(data[len])
+      return false;
+  return true;
+}
+
+cDeCSA::cDeCSA(int _adapter, int _demux)
+  :stall(MAX_STALL_MS)
+{
   adapter = _adapter;
   demux = _demux;
 
   cs=dvbcsa_bs_batch_size();
-  pcks = new dvbcsa_bs_batch_s[cs+1];
-
-  for (int i=0; i<=cs; i++) {
-    pcks[i].data = NULL;
-  }
+  cs_tsbbatch_even = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  cs_tsbbatch_odd = (dvbcsa_bs_batch_s *) malloc((cs + 1) * sizeof(struct dvbcsa_bs_batch_s));
+  memset(cs_key_even, 0, sizeof(cs_key_even));
+  memset(cs_key_odd, 0, sizeof(cs_key_odd));
+  memset(pidmap, 0, sizeof(pidmap));
 
-  memset(csa_bs_key_even,0,sizeof(csa_bs_key_even));
-  memset(csa_bs_key_odd,0,sizeof(csa_bs_key_odd));
-  memset(pidmap,0,sizeof(pidmap));
   ResetState();
 }
 
 cDeCSA::~cDeCSA()
 {
   for(int i=0; i<MAX_CSA_IDX; i++) {
-    if(csa_bs_key_even[i])
-      dvbcsa_bs_key_free(csa_bs_key_even[i]);
-    if(csa_bs_key_odd[i])
-      dvbcsa_bs_key_free(csa_bs_key_odd[i]);
+    if (cs_key_even[i])
+      dvbcsa_bs_key_free(cs_key_even[i]);
+    if (cs_key_odd[i])
+      dvbcsa_bs_key_free(cs_key_odd[i]);
   }
+  free(cs_tsbbatch_even);
+  free(cs_tsbbatch_odd);
 }
 
 void cDeCSA::ResetState(void)
@@ -36,26 +45,17 @@
   printf("adapter%d/demux%d: reset state", adapter, demux);
   memset(even_odd,0,sizeof(even_odd));
   memset(flags,0,sizeof(flags));
-  memset(usedPids,0,sizeof(usedPids));
+//  memset(usedPids,0,sizeof(usedPids));
   lastData=0;
 }
 
-static bool CheckNull(const unsigned char *data, int len)
-{
-  while(--len>=0)
-    if(data[len])
-      return false;
-  return true;
-}
-
 bool cDeCSA::GetKeyStruct(int idx)
 {
-  if(!csa_bs_key_even[idx])
-    csa_bs_key_even[idx] = dvbcsa_bs_key_alloc();
-  if(!csa_bs_key_odd[idx])
-    csa_bs_key_odd[idx] = dvbcsa_bs_key_alloc();
-
-  return (csa_bs_key_even[idx]!=0 && csa_bs_key_odd[idx]!=0);
+  if (!cs_key_even[idx])
+    cs_key_even[idx] = dvbcsa_bs_key_alloc();
+  if (!cs_key_odd[idx])
+    cs_key_odd[idx] = dvbcsa_bs_key_alloc();
+  return (cs_key_even[idx] != 0) && (cs_key_odd[idx] != 0);
 }
 
 bool cDeCSA::SetDescr(ca_descr_t *ca_descr, bool initial)
@@ -76,7 +76,7 @@
         printf("adapter%d/demux%d idx %d: late key set...\n", adapter, demux, idx);
     }
     if(ca_descr->parity==0) {
-      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_even[idx]);
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_even[idx]);
 
       if(!CheckNull(ca_descr->cw,8))
         flags[idx] |= FL_EVEN_GOOD|FL_ACTIVITY;
@@ -84,7 +84,7 @@
         printf("adapter%d/demux%d idx %d: zero even CW\n", adapter, demux, idx);
       wait.Broadcast();
     } else {
-      dvbcsa_bs_key_set(ca_descr->cw, csa_bs_key_odd[idx]);
+      dvbcsa_bs_key_set(ca_descr->cw, cs_key_odd[idx]);
 
       if(!CheckNull(ca_descr->cw,8))
         flags[idx] |= FL_ODD_GOOD|FL_ACTIVITY;
@@ -102,47 +102,76 @@
   cMutexLock lock(&mutex);
 
   if(ca_pid->index<MAX_CSA_IDX && ca_pid->pid<MAX_CSA_PIDS) {
-    int idx;
-
-    if (ca_pid->index!=-1) {
-      idx = ca_pid->index;
-      usedPids[idx]++;
-    } else {
-      idx = pidmap[ca_pid->pid];
-      usedPids[idx]--;
-      if (usedPids[idx]==0) {
-        even_odd[idx] = 0;
-        flags[idx] = 0;
-      }
-    }
 
-    pidmap[ca_pid->pid]=ca_pid->index;
-    //printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
+    pidmap[ca_pid->pid] = ca_pid->index;
+    printf("adapter%d/demux%d idx %d: set pid %04x\n", adapter, demux, ca_pid->index, ca_pid->pid);
     //printf("adapter%d/demux%d idx %d: udedPids %d\n", adapter, demux, idx, usedPids[idx]);
   }
 
   return true;
 }
 
+unsigned char ts_packet_get_payload_offset(unsigned char *ts_packet)
+{
+  if (ts_packet[0] != TS_SYNC_BYTE)
+    return 0;
+
+  unsigned char adapt_field   = (ts_packet[3] &~ 0xDF) >> 5; // 11x11111
+  unsigned char payload_field = (ts_packet[3] &~ 0xEF) >> 4; // 111x1111
+
+  if (!adapt_field && !payload_field)     // Not allowed
+    return 0;
+
+  if (adapt_field)
+  {
+    unsigned char adapt_len = ts_packet[4];
+    if (payload_field && adapt_len > 182) // Validity checks
+      return 0;
+    if (!payload_field && adapt_len > 183)
+      return 0;
+    if (adapt_len + 4 > TS_SIZE)  // adaptation field takes the whole packet
+      return 0;
+    return 4 + 1 + adapt_len;     // ts header + adapt_field_len_byte + adapt_field_len
+  }
+  else
+  {
+    return 4; // No adaptation, data starts directly after TS header
+  }
+}
+
 bool cDeCSA::Decrypt(unsigned char *data, int len, int& packetsCount)
 {
   cMutexLock lock(&mutex);
 //  printf("Begin Decrypting %d\n", len);
-  int currIdx=-1;
+  if (!cs_tsbbatch_even || !cs_tsbbatch_odd)
+  {
+    printf("Error allocating memory for DeCSA\n");
+    return false;
+  }
+
+  int ccs = 0, currIdx=-1;
+  int payload_len, offset;
+  int cs_fill_even = 0;
+  int cs_fill_odd = 0;
   len-=(TS_SIZE-1);
   int l;
-  int packets=0, cryptedPackets=0;
+  int packets=0;
 
-  for(l=0; l<len && cryptedPackets<cs; l+=TS_SIZE) {
+  for(l=0; l<len; l+=TS_SIZE) {
+    if (data[l] != TS_SYNC_BYTE)
+    {                           // let higher level cope with that
+      break;
+    }
     unsigned int ev_od=data[l+3]&0xC0;
-    int adaptation_field_exist = (data[l+3]&0x30)>>4;
-
-    if((ev_od==0x80 || ev_od==0xC0) && adaptation_field_exist!=2) { // encrypted
+    if(ev_od==0x80 || ev_od==0xC0) { // encrypted
+      offset = ts_packet_get_payload_offset(data + l);
+      payload_len = TS_SIZE - offset;
       int idx=pidmap[((data[l+1]<<8)+data[l+2])&(MAX_CSA_PIDS-1)];
       if(currIdx<0 || idx==currIdx) { // same or no index
+        data[l + 3] &= 0x3F;
         currIdx=idx;
-        if(ev_od!=even_odd[idx]) {
-          if (cryptedPackets==0) {
+        if(ccs == 0 && ev_od!=even_odd[idx]) {
+//          if (cryptedPackets==0) {
             even_odd[idx]=ev_od;
             wait.Broadcast();
             printf("adapter%d/demux%d idx %d: change to %s key\n", adapter, demux, idx, (ev_od&0x40)?"odd":"even");
@@ -168,42 +197,46 @@
               } else
                 printf("adapter%d/demux%d idx %d: not active. wait skipped\n", adapter, demux, idx);
             }
-          } else {
-            break;
-          }
+//          } else {
+//            break;
+//          }
         }
       }
-      else
-        break;
+//      else
+//        break;
 
-      if (adaptation_field_exist==1) {
-        pcks[cryptedPackets].data = data+l+4;
-        pcks[cryptedPackets].len = 184;
-      } else if (adaptation_field_exist==3) {
-        pcks[cryptedPackets].data = data+l+5+data[l+4];
-        pcks[cryptedPackets].len = 183-data[l+4];
+      if (((ev_od & 0x40) >> 6) == 0) {
+          cs_tsbbatch_even[cs_fill_even].data = &data[l + offset];
+          cs_tsbbatch_even[cs_fill_even].len = payload_len;
+          cs_fill_even++;
+      } else {
+          cs_tsbbatch_odd[cs_fill_odd].data = &data[l + offset];
+          cs_tsbbatch_odd[cs_fill_odd].len = payload_len;
+          cs_fill_odd++;
       }
-      cryptedPackets++;
+
+      if(++ccs >= cs)
+        break;
     }
 
-    data[l+3] &= 0x3F;
     packets++;
   }
 
-  if (cryptedPackets>0) {
-//  	printf("Begin Decrypting cryptedPackets %d\n",cryptedPackets);
-    for (int i=cryptedPackets;i<=cs;i++) {
-      pcks[i].data = NULL;
+  if (GetKeyStruct(currIdx)) {
+   if (cs_fill_even)
+    {
+      cs_tsbbatch_even[cs_fill_even].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_even[currIdx], cs_tsbbatch_even, 184);
+      cs_fill_even = 0;
+    }
+    if (cs_fill_odd)
+    {
+      cs_tsbbatch_odd[cs_fill_odd].data = NULL;
+      dvbcsa_bs_decrypt(cs_key_odd[currIdx], cs_tsbbatch_odd, 184);
+      cs_fill_odd = 0;
     }
+    stall.Set(MAX_STALL_MS);
 
-    if (GetKeyStruct(currIdx)) {
-//    	printf("Begin Decrypting GetKeyStruct %d\n",currIdx);
-      if (even_odd[currIdx]&0x40) {
-        dvbcsa_bs_decrypt(csa_bs_key_odd[currIdx], pcks, 184);
-      } else {
-        dvbcsa_bs_decrypt(csa_bs_key_even[currIdx], pcks, 184);
-      }
-    }
   }
 
   packetsCount = packets;
diff -uNr enigma2-20130618/lib/dvb/decsa.h enigma2/lib/dvb/decsa.h
--- enigma2-20130618/lib/dvb/decsa.h	2013-06-18 00:27:46.747072336 +0800
+++ enigma2/lib/dvb/decsa.h	2013-07-23 19:15:59.931132605 +0800
@@ -13,6 +13,7 @@
 
 #define MAX_REL_WAIT 100 // time to wait if key in used on set
 #define MAX_KEY_WAIT 500 // time to wait if key not ready on change
+#define MAX_STALL_MS 70
 
 #define MAX_CSA_PIDS 8192
 #define MAX_CSA_IDX  16
@@ -28,10 +29,12 @@
   unsigned int even_odd[MAX_CSA_IDX], flags[MAX_CSA_IDX], usedPids[MAX_CSA_IDX];
   cMutex mutex;
   cCondVar wait;
+  cTimeMs stall;
   int adapter, demux;
-  struct dvbcsa_bs_key_s* csa_bs_key_even[MAX_CSA_IDX];
-  struct dvbcsa_bs_key_s* csa_bs_key_odd[MAX_CSA_IDX];
-  struct dvbcsa_bs_batch_s *pcks;
+  struct dvbcsa_bs_key_s *cs_key_even[MAX_CSA_IDX];
+  struct dvbcsa_bs_key_s *cs_key_odd[MAX_CSA_IDX];
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_even;
+  struct dvbcsa_bs_batch_s *cs_tsbbatch_odd;
 
   bool GetKeyStruct(int idx);
   void ResetState(void);
diff -uNr enigma2-20130618/lib/dvb/dvb.cpp enigma2/lib/dvb/dvb.cpp
--- enigma2-20130618/lib/dvb/dvb.cpp	2013-06-18 00:27:46.751072336 +0800
+++ enigma2/lib/dvb/dvb.cpp	2013-06-25 13:12:39.504172560 +0800
@@ -2082,7 +2082,7 @@
 		m_pvr_thread = 0;
 	}
 
-	if (!source->valid())
+	if (!source->valid() && !source->isStream())
 	{
 		eDebug("PVR source is not valid!");
 		return -ENOENT;
@@ -2133,8 +2133,7 @@
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
 	m_pvr_thread->enablePVRCommit(1);
-	/* If the source specifies a length, it's a file. If not, it's a stream */
-	m_pvr_thread->setStreamMode(m_source->length() <= 0);
+	m_pvr_thread->setStreamMode(m_source->isStream());
 	m_pvr_thread->setScatterGather(this);
 
 	m_event(this, evtPreStart);
diff -uNr enigma2-20130618/lib/dvb/tstools.cpp enigma2/lib/dvb/tstools.cpp
--- enigma2-20130618/lib/dvb/tstools.cpp	2013-06-18 00:27:46.751072336 +0800
+++ enigma2/lib/dvb/tstools.cpp	2013-06-24 17:15:12.047261662 +0800
@@ -1,6 +1,7 @@
 #include <lib/dvb/tstools.h>
 #include <lib/dvb/specs.h>
 #include <lib/base/eerror.h>
+#include <lib/base/cachedtssource.h>
 #include <unistd.h>
 #include <fcntl.h>
 
@@ -76,9 +77,11 @@
 	eRawFile *f = new eRawFile();
 	ePtr<iTsSource> src = f;
 
-	if (f->open(filename, 1) < 0)
+	if (f->open(filename) < 0)
 		return -1;
 
+	src = new eCachedSource(src);
+
 	setSource(src, nostreaminfo ? NULL : filename);
 
 	return 0;
@@ -532,7 +535,7 @@
 	// If there's a structure file, the calculation is much smarter, so we can try more often
 	off_t threshold = m_streaminfo.hasStructure() ? 100*1024 : 1024*1024;
 
-	off_t end = m_source->lseek(0, SEEK_END);
+	off_t end = m_source->length();
 	if (llabs(end - m_last_filelength) > threshold)
 	{
 		m_last_filelength = end;
diff -uNr enigma2-20130618/lib/gdi/xineLib.cpp enigma2/lib/gdi/xineLib.cpp
--- enigma2-20130618/lib/gdi/xineLib.cpp	2013-06-18 00:27:46.667072339 +0800
+++ enigma2/lib/gdi/xineLib.cpp	2013-06-27 17:06:40.583984159 +0800
@@ -234,32 +234,19 @@
 	if( !xine_play(stream, 0, 0) ) {
 		printf("Unable to play stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
 	}
-	printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
-
-/*	if (xine_queue==0)
-	{
-		xine_queue = xine_event_new_queue (stream);
-		xine_event_create_listener_thread(xine_queue, xine_event_handler, this);
+	else {
+		printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
+		videoPlayed = true;
 	}
-*/
-	videoPlayed = true;
 }
 
 void cXineLib::stopVideo(void) {
-	xine_stop(stream);
-/*	if (this->postplugins) {
-		rewire_posts_unload();
+
+	if (videoPlayed) {
+		xine_stop(stream);
+		end_of_stream = true;
+		videoPlayed = false;
 	}
-*/
-//	xine_close (stream);
-/*	if (xine_queue)
-        {
-                xine_queue = xine_event_new_queue (stream);
-                xine_event_create_listener_thread(xine_queue, xine_event_handler, this);
-        }
-*/
-	end_of_stream = false;
-	videoPlayed = false;
 }
 
 void cXineLib::setStreamType(int video) {
diff -uNr enigma2-20130618/lib/service/servicem2ts.cpp enigma2/lib/service/servicem2ts.cpp
--- enigma2-20130618/lib/service/servicem2ts.cpp	2013-06-18 00:27:46.743072336 +0800
+++ enigma2/lib/service/servicem2ts.cpp	2013-06-24 17:15:12.063261661 +0800
@@ -16,7 +16,6 @@
 	~eM2TSFile();
 
 	// iTsSource
-	off_t lseek(off_t offset, int whence);
 	ssize_t read(off_t offset, void *buf, size_t count);
 	off_t length();
 	off_t offset();
@@ -174,18 +173,6 @@
 		::close(m_fd);
 }
 
-off_t eM2TSFile::lseek(off_t offset, int whence)
-{
-	eSingleLocker l(m_lock);
-
-	offset = (offset % 188) + (offset * 192) / 188;
-
-	if (offset != m_current_offset)
-		m_current_offset = lseek_internal(offset, whence);
-
-	return m_current_offset;
-}
-
 off_t eM2TSFile::lseek_internal(off_t offset, int whence)
 {
 	off_t ret;
