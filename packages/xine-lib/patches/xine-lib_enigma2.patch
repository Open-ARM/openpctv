diff -urN xine-lib-1.2/debian/dh_xine.in xine-lib-1.2.enigmaw/debian/dh_xine.in
--- xine-lib-1.2/debian/dh_xine.in	2014-11-09 17:50:35.630622073 +0100
+++ xine-lib-1.2.enigmaw/debian/dh_xine.in	2013-08-10 04:21:19.000000000 +0200
@@ -27,7 +27,7 @@
 recommendations (almost) at will.  If you don't specify any, then 'x' and
 'console' are used, generating xine-x:Depends and xine-console:Depends.
 
-'-' generates xine:Depends which contains a dependency on libxine2 which is
+'-' generates xine:Depends which contains a dependency on libxine1 which is
 suitable for use by out-of-tree plugins.
 
 =head1 EXAMPLES
@@ -67,10 +67,10 @@
   foreach my $suffix (@suffix) {
     if ($suffix eq '-') {
       delsubstvar($package, "xine:Depends");
-      addsubstvar ($package, "xine:Depends", "libxine2 (>= @VERSION@)");
+      addsubstvar ($package, "xine:Depends", "libxine1 (>= @VERSION@)");
     } else {
       delsubstvar($package, "xine-$suffix:Depends");
-      addsubstvar ($package, "xine-$suffix:Depends", "libxine2-$suffix");
+      addsubstvar ($package, "xine-$suffix:Depends", "libxine1-$suffix");
     }
   }
 }
I file binari xine-lib-1.2/.hg/dirstate e xine-lib-1.2.enigmaw/.hg/dirstate sono diversi
diff -urN xine-lib-1.2/include/configure.h.in xine-lib-1.2.enigmaw/include/configure.h.in
--- xine-lib-1.2/include/configure.h.in	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.enigmaw/include/configure.h.in	2013-08-10 04:21:19.000000000 +0200
@@ -0,0 +1,857 @@
+/* include/configure.h.in.  Generated from configure.ac by autoheader.  */
+
+#ifndef __XINE_LIB_CONFIG_H__
+#define __XINE_LIB_CONFIG_H__ 1
+
+
+#ifndef _XINE_CONFIGURE_H_
+#define _XINE_CONFIGURE_H_
+
+
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
+/* Define this if you're running Alpha architecture */
+#undef ARCH_ALPHA
+
+/* Define this if you're running ARM architecture */
+#undef ARCH_ARM
+
+/* Define this if you're running PowerPC architecture */
+#undef ARCH_PPC
+
+/* Define this if you're running SPARC architecture */
+#undef ARCH_SPARC
+
+/* Define this if you're running x86 architecture */
+#undef ARCH_X86
+
+/* Define this if you're running x86 architecture 32 bits */
+#undef ARCH_X86_32
+
+/* Define this if you're running x86 architecture 64 bits */
+#undef ARCH_X86_64
+
+/* define if '.align n' means alignment to (1 << n) - byte boundaries */
+#undef ASMALIGN_1SLN
+
+/* Define the highest alignment supported */
+#undef ATTRIBUTE_ALIGNED_MAX
+
+/* Define this if built on Mac OS X/Darwin */
+#undef CONFIG_DARWIN
+
+/* what to put between the brackets for empty arrays */
+#undef EMPTY_ARRAY_SIZE
+
+/* Define this if you want to use altivec on PowerPC CPUs */
+#undef ENABLE_ALTIVEC
+
+/* Define this to 1 to enable font antialising. */
+#undef ENABLE_ANTIALIASING
+
+/* Enable this when IPv6 is requested */
+#undef ENABLE_IPV6
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#undef ENABLE_NLS
+
+/* Define this if you have Sun UltraSPARC CPU */
+#undef ENABLE_VIS
+
+/* Mark a symbol as being exported if visibility is changed */
+#undef EXPORTED
+
+/* Get of rid system libcdio build configuration */
+#undef EXTERNAL_LIBCDIO_CONFIG_H
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_64BIT
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_ARM
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_DEFAULT
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_INTEL
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_MIPS
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_PPC
+
+/* Define to select libmad fixed point arithmetic implementation */
+#undef FPM_SPARC
+
+/* Define to 1 if you have the <a52dec/a52.h> header file. */
+#undef HAVE_A52DEC_A52_H
+
+/* Define to 1 if you have the <alloca.h> header file. */
+#undef HAVE_ALLOCA_H
+
+/* Define this if you have ALSA installed */
+#undef HAVE_ALSA
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+#undef HAVE_ASM_TYPES_H
+
+/* Define to 1 if you have the `asprintf' function. */
+#undef HAVE_ASPRINTF
+
+/* Define to 1 if you have the <assert.h> header file. */
+#undef HAVE_ASSERT_H
+
+/* Define to 1 if `output_muted' is a member of `audio_info_t'. */
+#undef HAVE_AUDIO_INFO_T_OUTPUT_MUTED
+
+/* define if compiler supports avx inline assembler */
+#undef HAVE_AVX
+
+/* Define to 1 if you have the `basename' function. */
+#undef HAVE_BASENAME
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#undef HAVE_BYTESWAP_H
+
+/* Define to 1 if you have the `bzero' function. */
+#undef HAVE_BZERO
+
+/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+#undef HAVE_CFLOCALECOPYCURRENT
+
+/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+#undef HAVE_CFPREFERENCESCOPYAPPVALUE
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#undef HAVE_DCGETTEXT
+
+/* Define this if you have DirectX */
+#undef HAVE_DIRECTX
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#undef HAVE_DIRENT_H
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define this if you have a suitable version of libdvdnav */
+#undef HAVE_DVDNAV
+
+/* Define to 1 if you have the environ symbol. */
+#undef HAVE_ENVIRON
+
+/* Define to 1 if you have the <errno.h> header file. */
+#undef HAVE_ERRNO_H
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+#undef HAVE_EXECINFO_H
+
+/* Define to 1 if you have the <fame.h> header file. */
+#undef HAVE_FAME_H
+
+/* Define this if you have linux framebuffer support */
+#undef HAVE_FB
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define this if you have ffmpeg library */
+#undef HAVE_FFMPEG
+
+/* Define to 1 if you have the <ffmpeg/avutil.h> header file. */
+#undef HAVE_FFMPEG_AVUTIL_H
+
+/* Define to 1 if you have the <FLAC/stream_decoder.h> header file. */
+#undef HAVE_FLAC_STREAM_DECODER_H
+
+/* Define this if you have fontconfig library */
+#undef HAVE_FONTCONFIG
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#undef HAVE_FSEEKO
+
+/* Define this if you have freetype2 library */
+#undef HAVE_FT2
+
+/* Define this if you have GNU getopt_long() implemented */
+#undef HAVE_GETOPT_LONG
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+#undef HAVE_GETPWUID_R
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#undef HAVE_GETTEXT
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#undef HAVE_GETTIMEOFDAY
+
+/* Define to 1 if you have the <glob.h> header file. */
+#undef HAVE_GLOB_H
+
+/* Define this if you have GLU support available */
+#undef HAVE_GLU
+
+/* Define to 1 if you have the <GL/glu.h> header file. */
+#undef HAVE_GL_GLU_H
+
+/* Define to 1 if you have the <GL/gl.h> header file. */
+#undef HAVE_GL_GL_H
+
+/* Define this if you have GraphicsMagick installed */
+#undef HAVE_GRAPHICSMAGICK
+
+/* Define to 1 if you have 'hstrerror' in <netdb.h> */
+#undef HAVE_HSTRERROR
+
+/* Define if you have the iconv() function and it works. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define this if you have a usable IRIX al interface available */
+#undef HAVE_IRIXAL
+
+/* Supports ISO _Pragma() macro */
+#undef HAVE_ISOC99_PRAGMA
+
+/* Define to 1 if you have the <jpeglib.h> header file. */
+#undef HAVE_JPEGLIB_H
+
+/* Define this if you have kernel statistics available via kstat interface */
+#undef HAVE_KSTAT
+
+/* Define to 1 if you have the <libavutil/avutil.h> header file. */
+#undef HAVE_LIBAVUTIL_AVUTIL_H
+
+/* Define to 1 if you have the <libavutil/sha1.h> header file. */
+#undef HAVE_LIBAVUTIL_SHA1_H
+
+/* Define to 1 if you have the <libavutil/sha.h> header file. */
+#undef HAVE_LIBAVUTIL_SHA_H
+
+/* Define this if you have libfame mpeg encoder installed (fame.sf.net) */
+#undef HAVE_LIBFAME
+
+/* Define to 1 if you have the <libgen.h> header file. */
+#undef HAVE_LIBGEN_H
+
+/* Define to 1 if you have the <libmng.h> header file. */
+#undef HAVE_LIBMNG_H
+
+/* Define to 1 if you have the `posix4' library (-lposix4). */
+#undef HAVE_LIBPOSIX4
+
+/* Define this if you have librte mpeg encoder installed (zapping.sf.net) */
+#undef HAVE_LIBRTE
+
+/* Define to 1 if you have the <libsmbclient.h> header file. */
+#undef HAVE_LIBSMBCLIENT_H
+
+/* Define this if you have libv4l installed */
+#undef HAVE_LIBV4L2_H
+
+/* Define to 1 if you have the `vdpau' library (-lvdpau). */
+#undef HAVE_LIBVDPAU
+
+/* Define 1 if you have Linux-type CD-ROM support */
+#undef HAVE_LINUX_CDROM
+
+/* Define to 1 if you have the <linux/cdrom.h> header file. */
+#undef HAVE_LINUX_CDROM_H
+
+/* Define 1 if timeout is in cdrom_generic_command struct */
+#undef HAVE_LINUX_CDROM_TIMEOUT
+
+/* Define to 1 if you have the <linux/fb.h> header file. */
+#undef HAVE_LINUX_FB_H
+
+/* Define to 1 if you have the <linux/videodev2.h> header file. */
+#undef HAVE_LINUX_VIDEODEV2_H
+
+/* Define to 1 if you have the <linux/videodev.h> header file. */
+#undef HAVE_LINUX_VIDEODEV_H
+
+/* Define this if the 'lrintf' function is declared in math.h */
+#undef HAVE_LRINTF
+
+/* Define to 1 if you have the `lstat' function. */
+#undef HAVE_LSTAT
+
+/* Define to 1 if you have the <machine/soundcard.h> header file. */
+#undef HAVE_MACHINE_SOUNDCARD_H
+
+/* Define to 1 if you have the <mad.h> header file. */
+#undef HAVE_MAD_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
+/* Define to 1 if you have 'MAX' macro in sys/param.h */
+#undef HAVE_MAX_MACRO
+
+/* Define to 1 if you have the `memalign' function. */
+#undef HAVE_MEMALIGN
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the `memmem' function. */
+#undef HAVE_MEMMEM
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `memset' function. */
+#undef HAVE_MEMSET
+
+/* Define to 1 if you have 'MIN' macro in sys/param.h */
+#undef HAVE_MIN_MACRO
+
+/* Define this if you have mlib installed */
+#undef HAVE_MLIB
+
+/* Define to 1 if you have the <mlib_video.h> header file. */
+#undef HAVE_MLIB_VIDEO_H
+
+/* Define to 1 if you have the `mmap' function. */
+#undef HAVE_MMAP
+
+/* Define this if you can compile MMX asm instructions */
+#undef HAVE_MMX
+
+/* Define to 1 if you have the <mpcdec/mpcdec.h> header file. */
+#undef HAVE_MPCDEC_MPCDEC_H
+
+/* Define to 1 if you have the <mpc/mpcdec.h> header file. */
+#undef HAVE_MPC_MPCDEC_H
+
+/* Define to 1 if you have the `nanosleep' function. */
+#undef HAVE_NANOSLEEP
+
+/* Define to 1 if you have the <neaacdec.h> header file. */
+#undef HAVE_NEAACDEC_H
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#undef HAVE_NETDB_H
+
+/* Define this if you have libfame 0.8.10 or above */
+#undef HAVE_NEW_LIBFAME
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#undef HAVE_NL_LANGINFO
+
+/* Define to 1 if you have 'opendir' function */
+#undef HAVE_OPENDIR
+
+/* Define this if you have POSIX timers. */
+#undef HAVE_POSIX_TIMERS
+
+/* Define to 1 if you have 'pthread_mutex_timedlock' in <pthread.h> */
+#undef HAVE_PTHREAD_MUTEX_TIMEDLOCK
+
+/* define this if you have pulseaudio >= 0.9.7 */
+#undef HAVE_PULSEAUDIO_0_9_7
+
+/* Define to 1 if you have the `readlink' function. */
+#undef HAVE_READLINK
+
+/* Define to 1 if you have the <rte.h> header file. */
+#undef HAVE_RTE_H
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the `sigset' function. */
+#undef HAVE_SIGSET
+
+/* Define to 1 if you have the `snprintf' function. */
+#undef HAVE_SNPRINTF
+
+/* Define to 1 if you have the <soundcard.h> header file. */
+#undef HAVE_SOUNDCARD_H
+
+/* Define this if you have speex */
+#undef HAVE_SPEEX
+
+/* Define to 1 if you have the <stdbool.h> header file. */
+#undef HAVE_STDBOOL_H
+
+/* Define to 1 if you have the stderr symbol. */
+#undef HAVE_STDERR
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#undef HAVE_STDIO_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strcasestr' function. */
+#undef HAVE_STRCASESTR
+
+/* Define to 1 if you have the `strchr' function. */
+#undef HAVE_STRCHR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#undef HAVE_STRNCASECMP
+
+/* Define to 1 if you have the `strndup' function. */
+#undef HAVE_STRNDUP
+
+/* Define to 1 if you have the `strpbrk' function. */
+#undef HAVE_STRPBRK
+
+/* Define to 1 if you have the `strsep' function. */
+#undef HAVE_STRSEP
+
+/* Define to 1 if you have the `strtok_r' function. */
+#undef HAVE_STRTOK_R
+
+/* Define to 1 if you have the <sys/cdio.h> header file. */
+#undef HAVE_SYS_CDIO_H
+
+/* Define to 1 if you have the <sys/dvdio.h> header file. */
+#undef HAVE_SYS_DVDIO_H
+
+/* Define to 1 if you have the <sys/fbio.h> header file. */
+#undef HAVE_SYS_FBIO_H
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/mixer.h> header file. */
+#undef HAVE_SYS_MIXER_H
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#undef HAVE_SYS_MMAN_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/scsiio.h> header file. */
+#undef HAVE_SYS_SCSIIO_H
+
+/* Define to 1 if you have the <sys/soundcard.h> header file. */
+#undef HAVE_SYS_SOUNDCARD_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#undef HAVE_SYS_TIMES_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/videodev2.h> header file. */
+#undef HAVE_SYS_VIDEODEV2_H
+
+/* Define to 1 if you have the <sys/videoio.h> header file. */
+#undef HAVE_SYS_VIDEOIO_H
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#undef HAVE_SYS_WAIT_H
+
+/* Define this if you have theora */
+#undef HAVE_THEORA
+
+/* Define to 1 if you have the `timegm' function. */
+#undef HAVE_TIMEGM
+
+/* Define if struct tm has the tm_gmtoff member. */
+#undef HAVE_TM_GMTOFF
+
+/* Define to 1 if you have the <ucontext.h> header file. */
+#undef HAVE_UCONTEXT_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if you have the `unsetenv' function. */
+#undef HAVE_UNSETENV
+
+/* Define to 1 if you have the `va_copy' function. */
+#undef HAVE_VA_COPY
+
+/* Define this if you use external libcdio/libvcdinfo */
+#undef HAVE_VCDNAV
+
+/* Define to 1 if you have the <vdpau/vdpau_x11.h> header file. */
+#undef HAVE_VDPAU_VDPAU_X11_H
+
+/* Define if you have vldXvMC.h */
+#undef HAVE_VLDXVMC
+
+/* Define this if you have vorbis */
+#undef HAVE_VORBIS
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#undef HAVE_VSNPRINTF
+
+/* Define to 1 if you have the `vsscanf' function. */
+#undef HAVE_VSSCANF
+
+/* Define this if you have X11R6 installed */
+#undef HAVE_X11
+
+/* Define to 1 if you have the <X11/extensions/vldXvMC.h> header file. */
+#undef HAVE_X11_EXTENSIONS_VLDXVMC_H
+
+/* Define to 1 if you have the <X11/extensions/XShm.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XSHM_H
+
+/* Define to 1 if you have the <X11/extensions/XvMC.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XVMC_H
+
+/* Define this if you have libXinerama installed */
+#undef HAVE_XINERAMA
+
+/* Define this if you have libXv installed */
+#undef HAVE_XV
+
+/* Define this if you have an XvMC library and XvMC.h installed. */
+#undef HAVE_XVMC
+
+/* Define to 1 if you have the _environ symbol. */
+#undef HAVE__ENVIRON
+
+/* Define to 1 if you have the `_snprintf' function. */
+#undef HAVE__SNPRINTF
+
+/* Define to 1 if you have the `_stricmp' function. */
+#undef HAVE__STRICMP
+
+/* Define to 1 if you have the `_strnicmp' function. */
+#undef HAVE__STRNICMP
+
+/* Define to 1 if you have the `_vsnprintf' function. */
+#undef HAVE__VSNPRINTF
+
+/* Define to 1 if you have the __ctype_b symbol. */
+#undef HAVE___CTYPE_B
+
+/* Define to 1 if you have the __environ symbol. */
+#undef HAVE___ENVIRON
+
+/* Define to 1 if you have the __stderrp symbol. */
+#undef HAVE___STDERRP
+
+/* Define to 1 if you have the ___brk_addr symbol. */
+#undef HAVE____BRK_ADDR
+
+/* Define this if built on Mac OS X/Darwin */
+#undef HOST_OS_DARWIN
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Type of the request parameter for ioctl() */
+#undef IOCTL_REQUEST_TYPE
+
+/* Get of rid system libcdio build configuration */
+#undef LIBCDIO_CONFIG_H
+
+/* Define this if you have mlib installed */
+#undef LIBMPEG2_MLIB
+
+/* The soname of libX11, needed for dlopen() */
+#undef LIBX11_SO
+
+/* The soname of libXv, needed for dlopen() */
+#undef LIBXV_SO
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define this if you want to load mlib lazily */
+#undef MLIB_LAZYLOAD
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Default path in which to find Real binary codecs */
+#undef REAL_CODEC_PATH
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define this if the compiler supports __attribute__(( ifelse([weak, alias],
+   , [alias], [weak, alias]) )) */
+#undef SUPPORT_ATTRIBUTE_ALIAS
+
+/* Define this if the compiler supports __attribute__(( ifelse([], , [const],
+   []) )) */
+#undef SUPPORT_ATTRIBUTE_CONST
+
+/* Define this if the compiler supports __attribute__(( ifelse([], ,
+   [deprecated], []) )) */
+#undef SUPPORT_ATTRIBUTE_DEPRECATED
+
+/* Define this if the compiler supports __attribute__(( ifelse([format(printf,
+   n, n)], , [format], [format(printf, n, n)]) )) */
+#undef SUPPORT_ATTRIBUTE_FORMAT
+
+/* Define this if the compiler supports __attribute__((
+   ifelse([format_arg(printf)], , [format_arg], [format_arg(printf)]) )) */
+#undef SUPPORT_ATTRIBUTE_FORMAT_ARG
+
+/* Define this if the compiler supports __attribute__(( ifelse([], , [malloc],
+   []) )) */
+#undef SUPPORT_ATTRIBUTE_MALLOC
+
+/* Define this if the compiler supports __attribute__(( ifelse([], , [packed],
+   []) )) */
+#undef SUPPORT_ATTRIBUTE_PACKED
+
+/* Define this if the compiler supports __attribute__(( ifelse([], ,
+   [sentinel], []) )) */
+#undef SUPPORT_ATTRIBUTE_SENTINEL
+
+/* Define this if the compiler supports __attribute__(( ifelse([], , [unused],
+   []) )) */
+#undef SUPPORT_ATTRIBUTE_UNUSED
+
+/* Define this if the compiler supports __attribute__((
+   ifelse([visibility("default")], , [visibility_default],
+   [visibility("default")]) )) */
+#undef SUPPORT_ATTRIBUTE_VISIBILITY_DEFAULT
+
+/* Define this if the compiler supports __attribute__((
+   ifelse([visibility("internal")], , [visibility_internal],
+   [visibility("internal")]) )) */
+#undef SUPPORT_ATTRIBUTE_VISIBILITY_INTERNAL
+
+/* Define this if the compiler supports __attribute__((
+   ifelse([visibility("protected")], , [visibility_protected],
+   [visibility("protected")]) )) */
+#undef SUPPORT_ATTRIBUTE_VISIBILITY_PROTECTED
+
+/* Define this if the compiler supports __attribute__(( ifelse([], , [weak],
+   []) )) */
+#undef SUPPORT_ATTRIBUTE_WEAK
+
+/* Define this if the compiler supports the -fvisibility flag */
+#undef SUPPORT_FLAG_VISIBILITY
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
+
+/* Version number of package */
+#undef VERSION
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
+/* Path where aclocal m4 files will be. */
+#undef XINE_ACFLAGS
+
+/* Define this to osd fonts dir location */
+#undef XINE_FONTDIR
+
+/* Path where catalog files will be. */
+#undef XINE_LOCALEDIR
+
+/* xine interface version age */
+#undef XINE_LT_AGE
+
+/* xine interface version number */
+#undef XINE_LT_CURRENT
+
+/* Define this if a universal binary is being built for Mac OS X */
+#undef XINE_MACOSX_UNIVERSAL_BINARY
+
+/* xine major version number */
+#undef XINE_MAJOR
+
+/* xine minor version number */
+#undef XINE_MINOR
+
+/* xine patch version number */
+#undef XINE_PATCH
+
+/* Define this to soecific plugins directory location */
+#undef XINE_PLUGINDIR
+
+/* Define this to general plugins directory location */
+#undef XINE_PLUGINROOT
+
+/* Define this to font directory relative to prefix */
+#undef XINE_REL_FONTDIR
+
+/* Define this to font directory relative to prefix */
+#undef XINE_REL_LOCALEDIR
+
+/* Define this to specific plugin directory relative to execution prefix */
+#undef XINE_REL_PLUGINDIR
+
+/* Define this to general plugin directory relative to execution prefix */
+#undef XINE_REL_PLUGINROOT
+
+/* xine sub version number */
+#undef XINE_SUB
+
+/* catalog message text domain */
+#undef XINE_TEXTDOMAIN
+
+/* Define to 1 if the X Window System is missing or not being used. */
+#undef X_DISPLAY_MISSING
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Define this if you are ISO C9X compliant */
+#undef _ISOC9X_SOURCE
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+#undef _LARGEFILE_SOURCE
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
+/* Define to 1 if on MINIX. */
+#undef _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#undef _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#undef _POSIX_SOURCE
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#undef restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define the real type of socklen_t */
+#undef socklen_t
+
+/* define ssize_t to __int64 if it's missing in default includes */
+#undef ssize_t
+
+#ifdef ASMALIGN_1SLN
+# define ASMALIGN(ZEROBITS) ".align " #ZEROBITS "\n\t"
+#else
+# define ASMALIGN(ZEROBITS) ".align 1<<" #ZEROBITS "\n\t"
+#endif
+
+#endif  /* __XINE_LIB_CONFIG_H__ */
+
+
+
+#if defined (__FreeBSD__) && !defined (__FreeBSD_kernel__)
+#define __FreeBSD_kernel__ __FreeBSD__
+#endif
+
+#if defined (__FreeBSD_kernel__)
+#include <sys/param.h>
+# if defined (__FreeBSD_version) && !defined (__FreeBSD_kernel_version)
+# define __FreeBSD_kernel_version __FreeBSD_version
+# endif
+#endif
+
+
+#endif
+
diff -urN xine-lib-1.2/include/xine/audio_decoder.h xine-lib-1.2.enigmaw/include/xine/audio_decoder.h
--- xine-lib-1.2/include/xine/audio_decoder.h	2014-11-09 17:50:35.650622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/audio_decoder.h	2014-01-11 15:34:05.000000000 +0100
@@ -44,7 +44,7 @@
   /*
    * open a new instance of this plugin class
    */
-  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *this, xine_stream_t *stream);
+  audio_decoder_t* (*open_plugin) (audio_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
    * free all class-related resources
    */
 
-  void (*dispose) (audio_decoder_class_t *this);
+  void (*dispose) (audio_decoder_class_t *self);
 };
 
 #define default_audio_decoder_class_dispose (void (*) (audio_decoder_class_t *this))free
@@ -78,24 +78,24 @@
    * decode data from buf and feed decoded samples to
    * audio output
    */
-  void (*decode_data) (audio_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (audio_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * audio data not related to recently decoded data)
    */
-  void (*reset) (audio_decoder_t *this);
+  void (*reset) (audio_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (audio_decoder_t *this);
+  void (*discontinuity) (audio_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (audio_decoder_t *this);
+  void (*dispose) (audio_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -urN xine-lib-1.2/include/xine/broadcaster.h xine-lib-1.2.enigmaw/include/xine/broadcaster.h
--- xine-lib-1.2/include/xine/broadcaster.h	2014-11-09 17:50:35.650622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/broadcaster.h	2014-01-11 15:34:05.000000000 +0100
@@ -30,8 +30,8 @@
 typedef struct broadcaster_s broadcaster_t;
 
 broadcaster_t *_x_init_broadcaster(xine_stream_t *stream, int port) XINE_MALLOC XINE_PROTECTED;
-void _x_close_broadcaster(broadcaster_t *this) XINE_PROTECTED;
-int _x_get_broadcaster_port(broadcaster_t *this) XINE_PROTECTED;
+void _x_close_broadcaster(broadcaster_t *self) XINE_PROTECTED;
+int _x_get_broadcaster_port(broadcaster_t *self) XINE_PROTECTED;
 
 
 #ifdef __cplusplus
diff -urN xine-lib-1.2/include/xine/demux.h xine-lib-1.2.enigmaw/include/xine/demux.h
--- xine-lib-1.2/include/xine/demux.h	2014-11-09 17:50:35.654622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/demux.h	2014-01-11 15:34:05.000000000 +0100
@@ -49,7 +49,7 @@
   /*
    * open a new instance of this plugin class
    */
-  demux_plugin_t* (*open_plugin) (demux_class_t *this, xine_stream_t *stream, input_plugin_t *input);
+  demux_plugin_t* (*open_plugin) (demux_class_t *self, xine_stream_t *stream, input_plugin_t *input);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -85,7 +85,7 @@
   /*
    * close down, free all resources
    */
-  void (*dispose) (demux_class_t *this);
+  void (*dispose) (demux_class_t *self);
 };
 
 #define default_demux_class_dispose (void (*) (demux_class_t *this))free
@@ -101,7 +101,7 @@
    * fifos, then return. do not start demux thread (yet)
    */
 
-  void (*send_headers) (demux_plugin_t *this);
+  void (*send_headers) (demux_plugin_t *self);
 
   /*
    * ask demux to seek
@@ -122,7 +122,7 @@
    *                           starting the demuxer)
    */
 
-  int (*seek) (demux_plugin_t *this,
+  int (*seek) (demux_plugin_t *self,
 	       off_t start_pos, int start_time, int playing );
 
   /*
@@ -135,37 +135,37 @@
    * the demux current status
    */
 
-  int (*send_chunk) (demux_plugin_t *this);
+  int (*send_chunk) (demux_plugin_t *self);
 
   /*
    * free resources
    */
 
-  void (*dispose) (demux_plugin_t *this) ;
+  void (*dispose) (demux_plugin_t *self) ;
 
   /*
    * returns DEMUX_OK or  DEMUX_FINISHED
    */
 
-  int (*get_status) (demux_plugin_t *this) ;
+  int (*get_status) (demux_plugin_t *self) ;
 
   /*
    * gets stream length in miliseconds (might be estimated)
    * may return 0 for non-seekable streams
    */
 
-  int (*get_stream_length) (demux_plugin_t *this);
+  int (*get_stream_length) (demux_plugin_t *self);
 
   /*
    * return capabilities of demuxed stream
    */
 
-  uint32_t (*get_capabilities) (demux_plugin_t *this);
+  uint32_t (*get_capabilities) (demux_plugin_t *self);
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (demux_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (demux_plugin_t *self, void *data, int data_type);
 
   /*
    * "backwards" link to plugin class
@@ -186,7 +186,7 @@
 #endif
 } ;
 
-#define default_demux_plugin_dispose (void (*) (demux_plugin_t *this))free
+#define default_demux_plugin_dispose (void (*) (demux_plugin_t *self))free
 
 /*
  * possible capabilites a demux plugin can have:
diff -urN xine-lib-1.2/include/xine/input_plugin.h xine-lib-1.2.enigmaw/include/xine/input_plugin.h
--- xine-lib-1.2/include/xine/input_plugin.h	2014-11-09 17:50:35.654622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/input_plugin.h	2014-01-11 15:34:05.000000000 +0100
@@ -43,7 +43,7 @@
    * create a new instance of this plugin class
    * return NULL if the plugin does'nt handle the given mrl
    */
-  input_plugin_t* (*get_instance) (input_class_t *this, xine_stream_t *stream, const char *mrl);
+  input_plugin_t* (*get_instance) (input_class_t *self, xine_stream_t *stream, const char *mrl);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -66,28 +66,28 @@
    * ls function, optional: may be NULL
    * return value: NULL => filename is a file, **char=> filename is a dir
    */
-  xine_mrl_t ** (*get_dir) (input_class_t *this, const char *filename, int *nFiles);
+  xine_mrl_t ** (*get_dir) (input_class_t *self, const char *filename, int *nFiles);
 
   /*
    * generate autoplay list, optional: may be NULL
    * return value: list of MRLs
    */
-  const char * const * (*get_autoplay_list) (input_class_t *this, int *num_files);
+  const char * const * (*get_autoplay_list) (input_class_t *self, int *num_files);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (input_class_t *this);
+  void (*dispose) (input_class_t *self);
 
   /*
    * eject/load the media (if possible), optional: may be NULL
    *
    * returns 0 for temporary failures
    */
-  int (*eject_media) (input_class_t *this);
+  int (*eject_media) (input_class_t *self);
 };
 
-#define default_input_class_dispose (void (*) (input_class_t *this))free
+#define default_input_class_dispose (void (*) (input_class_t *self))free
 
 struct input_plugin_s {
 
@@ -95,7 +95,7 @@
    * open the stream
    * return 0 if an error occured
    */
-  int (*open) (input_plugin_t *this);
+  int (*open) (input_plugin_t *self);
 
   /*
    * return capabilities of the current playable entity. See
@@ -113,14 +113,14 @@
    * make a best-effort attempt to seek, e.g. at least
    * relative forward seeking should work.
    */
-  uint32_t (*get_capabilities) (input_plugin_t *this);
+  uint32_t (*get_capabilities) (input_plugin_t *self);
 
   /*
    * read nlen bytes, return number of bytes read
    * Should block until some bytes available for read;
    * a return value of 0 indicates no data available
    */
-  off_t (*read) (input_plugin_t *this, void *buf, off_t nlen);
+  off_t (*read) (input_plugin_t *self, void *buf, off_t nlen);
 
 
   /*
@@ -128,7 +128,7 @@
    * for blocked input sources len must be == blocksize
    * the fifo parameter is only used to get access to the buffer_pool_alloc function
    */
-  buf_element_t *(*read_block)(input_plugin_t *this, fifo_buffer_t *fifo, off_t len);
+  buf_element_t *(*read_block)(input_plugin_t *self, fifo_buffer_t *fifo, off_t len);
 
 
   /*
@@ -136,7 +136,7 @@
    *
    * if seeking failed, -1 is returned
    */
-  off_t (*seek) (input_plugin_t *this, off_t offset, int origin);
+  off_t (*seek) (input_plugin_t *self, off_t offset, int origin);
 
 
   /*
@@ -148,14 +148,14 @@
    * note: only SEEK_SET (0) is currently supported as origin
    * note: may be NULL is not supported
    */
-  off_t (*seek_time) (input_plugin_t *this, int time_offset, int origin);
+  off_t (*seek_time) (input_plugin_t *self, int time_offset, int origin);
 
 
   /*
    * get current position in stream.
    *
    */
-  off_t (*get_current_pos) (input_plugin_t *this);
+  off_t (*get_current_pos) (input_plugin_t *self);
 
 
   /*
@@ -163,7 +163,7 @@
    *
    * note: may be NULL is not supported
    */
-  int (*get_current_time) (input_plugin_t *this);
+  int (*get_current_time) (input_plugin_t *self);
 
 
   /*
@@ -183,7 +183,7 @@
    * absolute or relative play position or possibly calculating the
    * bit rate.
    */
-  off_t (*get_length) (input_plugin_t *this);
+  off_t (*get_length) (input_plugin_t *self);
 
 
   /*
@@ -199,25 +199,25 @@
    * make this function simply return 0 if unsure.
    */
 
-  uint32_t (*get_blocksize) (input_plugin_t *this);
+  uint32_t (*get_blocksize) (input_plugin_t *self);
 
 
   /*
    * return current MRL
    */
-  const char * (*get_mrl) (input_plugin_t *this);
+  const char * (*get_mrl) (input_plugin_t *self);
 
 
   /*
    * request optional data from input plugin.
    */
-  int (*get_optional_data) (input_plugin_t *this, void *data, int data_type);
+  int (*get_optional_data) (input_plugin_t *self, void *data, int data_type);
 
 
   /*
    * close stream, free instance resources
    */
-  void (*dispose) (input_plugin_t *this);
+  void (*dispose) (input_plugin_t *self);
 
   /*
    * "backward" link to input plugin class struct
diff -urN xine-lib-1.2/include/xine/osd.h xine-lib-1.2.enigmaw/include/xine/osd.h
--- xine-lib-1.2/include/xine/osd.h	2014-11-09 17:50:35.654622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/osd.h	2014-01-11 15:34:05.000000000 +0100
@@ -91,7 +91,7 @@
    * A default palette is initialized (i sugest keeping color 0 as transparent
    * for the sake of simplicity)
    */
-  osd_object_t* (*new_object) (osd_renderer_t *this, int width, int height);
+  osd_object_t* (*new_object) (osd_renderer_t *self, int width, int height);
 
   /*
    * free osd object
@@ -194,7 +194,7 @@
    * loaded fonts are unloaded
    * osd objects are closed
    */
-  void (*close) (osd_renderer_t *this);
+  void (*close) (osd_renderer_t *self);
 
   /*
    * clear an osd object (empty drawing area)
@@ -215,6 +215,10 @@
    */
   int (*show_unscaled) (osd_object_t *osd, int64_t vpts );
 
+
+
+  int (*show_scaled) (osd_object_t *osd, int64_t vpts );
+
   /*
    * see xine.h for defined XINE_OSD_CAP_ values.
    */
diff -urN xine-lib-1.2/include/xine/scratch.h xine-lib-1.2.enigmaw/include/xine/scratch.h
--- xine-lib-1.2/include/xine/scratch.h	2014-11-09 17:50:35.658622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/scratch.h	2014-01-11 15:34:05.000000000 +0100
@@ -33,11 +33,11 @@
 struct scratch_buffer_s {
 
   void         XINE_FORMAT_PRINTF(2, 0)
-               (*scratch_printf) (scratch_buffer_t *this, const char *format, va_list ap);
+               (*scratch_printf) (scratch_buffer_t *self, const char *format, va_list ap);
 
-  char       **(*get_content) (scratch_buffer_t *this);
+  char       **(*get_content) (scratch_buffer_t *self);
 
-  void         (*dispose) (scratch_buffer_t *this);
+  void         (*dispose) (scratch_buffer_t *self);
 
   char         **lines;
   char         **ordered;
diff -urN xine-lib-1.2/include/xine/spu_decoder.h xine-lib-1.2.enigmaw/include/xine/spu_decoder.h
--- xine-lib-1.2/include/xine/spu_decoder.h	2014-11-09 17:50:35.658622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/spu_decoder.h	2013-08-10 04:21:19.000000000 +0200
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *this, xine_stream_t *stream);
+  spu_decoder_t* (*open_plugin) (spu_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (spu_decoder_class_t *this);
+  void (*dispose) (spu_decoder_class_t *self);
 };
 
 #define default_spu_decoder_class_dispose (void (*) (spu_decoder_class_t *this))free
@@ -77,24 +77,24 @@
   /*
    * decode data from buf and feed the overlay to overlay manager
    */
-  void (*decode_data) (spu_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (spu_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * SPU data not related to recently decoded data)
    */
-  void (*reset) (spu_decoder_t *this);
+  void (*reset) (spu_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (spu_decoder_t *this);
+  void (*discontinuity) (spu_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (spu_decoder_t *this);
+  void (*dispose) (spu_decoder_t *self);
 
   /*
    * When the SPU decoder also handles data used in user interaction,
@@ -106,7 +106,7 @@
    * This function pointer may be NULL, if the plugin does not have
    * such functionality.
    */
-  int  (*get_interact_info) (spu_decoder_t *this, void *data);
+  int  (*get_interact_info) (spu_decoder_t *self, void *data);
 
   /*
    * When the SPU decoder also handles menu overlays for user inter-
diff -urN xine-lib-1.2/include/xine/video_decoder.h xine-lib-1.2.enigmaw/include/xine/video_decoder.h
--- xine-lib-1.2/include/xine/video_decoder.h	2014-11-09 17:50:35.658622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/video_decoder.h	2014-01-11 15:34:05.000000000 +0100
@@ -45,7 +45,7 @@
   /*
    * open a new instance of this plugin class
    */
-  video_decoder_t* (*open_plugin) (video_decoder_class_t *this, xine_stream_t *stream);
+  video_decoder_t* (*open_plugin) (video_decoder_class_t *self, xine_stream_t *stream);
 
   /**
    * @brief short human readable identifier for this plugin class
@@ -67,7 +67,7 @@
   /*
    * free all class-related resources
    */
-  void (*dispose) (video_decoder_class_t *this);
+  void (*dispose) (video_decoder_class_t *self);
 };
 
 #define default_video_decoder_class_dispose (void (*) (video_decoder_class_t *this))free
@@ -78,29 +78,29 @@
    * decode data from buf and feed decoded frames to
    * video output
    */
-  void (*decode_data) (video_decoder_t *this, buf_element_t *buf);
+  void (*decode_data) (video_decoder_t *self, buf_element_t *buf);
 
   /*
    * reset decoder after engine flush (prepare for new
    * video data not related to recently decoded data)
    */
-  void (*reset) (video_decoder_t *this);
+  void (*reset) (video_decoder_t *self);
 
   /*
    * inform decoder that a time reference discontinuity has happened.
    * that is, it must forget any currently held pts value
    */
-  void (*discontinuity) (video_decoder_t *this);
+  void (*discontinuity) (video_decoder_t *self);
 
   /*
    * flush out any frames that are still stored in the decoder
    */
-  void (*flush) (video_decoder_t *this);
+  void (*flush) (video_decoder_t *self);
 
   /*
    * close down, free all resources
    */
-  void (*dispose) (video_decoder_t *this);
+  void (*dispose) (video_decoder_t *self);
 
   /**
    * @brief Pointer to the loaded plugin node.
diff -urN xine-lib-1.2/include/xine/video_out.h xine-lib-1.2.enigmaw/include/xine/video_out.h
--- xine-lib-1.2/include/xine/video_out.h	2014-11-09 17:50:35.658622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine/video_out.h	2014-01-11 15:34:05.000000000 +0100
@@ -268,7 +268,10 @@
 #define VO_PROP_BUFS_FREE             27 /* read-only */
 #define VO_PROP_MAX_VIDEO_WIDTH       28 /* read-only */
 #define VO_PROP_MAX_VIDEO_HEIGHT      29 /* read-only */
-#define VO_NUM_PROPERTIES             30
+#define VO_PROP_LAST_PTS              30
+#define VO_PROP_DEINTERLACE_SD        31
+#define VO_PROP_DEINTERLACE_HD        32
+#define VO_NUM_PROPERTIES             33
 
 /* number of colors in the overlay palette. Currently limited to 256
    at most, because some alphablend functions use an 8-bit index into
diff -urN xine-lib-1.2/include/xine/xine_internal.h xine-lib-1.2.enigmaw/include/xine/xine_internal.h
--- xine-lib-1.2/include/xine/xine_internal.h	2014-11-09 17:50:35.662622074 +0100
+++ xine-lib-1.2.enigmaw/include/xine/xine_internal.h	2014-01-11 15:34:05.000000000 +0100
@@ -495,7 +495,7 @@
  * load a specific video output plugin
  */
 
-vo_driver_t *_x_load_video_output_plugin(xine_t *this,
+vo_driver_t *_x_load_video_output_plugin(xine_t *self,
 					 char *id, int visual_type, void *visual) XINE_PROTECTED;
 
 /*
diff -urN xine-lib-1.2/include/xine.h xine-lib-1.2.enigmaw/include/xine.h
--- xine-lib-1.2/include/xine.h	2014-11-09 17:50:35.650622073 +0100
+++ xine-lib-1.2.enigmaw/include/xine.h	2014-01-11 15:34:05.000000000 +0100
@@ -1750,6 +1750,7 @@
 #define XINE_EVENT_MRL_REFERENCE_EXT     13 /* demuxer->frontend: MRL reference(s) for the real stream */
 #define XINE_EVENT_AUDIO_AMP_LEVEL       14 /* report current audio amp level (l/r/mute) */
 #define XINE_EVENT_NBC_STATS             15 /* nbc buffer status */
+#define XINE_EVENT_FRAMERATE_CHANGE      16
 
 
 /* input events coming from frontend */
@@ -1841,6 +1842,10 @@
 /* events generated from post plugins */
 #define XINE_EVENT_POST_TVTIME_FILMMODE_CHANGE   400
 
+#define XINE_EVENT_SET_VIDEO_STREAMTYPE 501
+#define XINE_EVENT_SET_AUDIO_STREAMTYPE 502
+
+
 /*
  * xine event struct
  */
@@ -1874,6 +1879,11 @@
   char                str[256]; /* might be longer */
 } xine_ui_data_t;
 
+typedef struct {
+  int                 pid;
+  int                 streamtype;
+} xine_streamtype_data_t;
+
 /*
  * Send messages to UI. used mostly to report errors.
  */
@@ -1952,6 +1962,10 @@
   int                 type;         /* 0=buffer put, 1=buffer get */
 } xine_nbc_stats_data_t;
 
+typedef struct {
+  int64_t             framerate;
+} xine_framerate_data_t;
+
 /*
  * mrl reference data is sent by demuxers when a reference stream is found.
  * this stream just contains pointers (urls) to the real data, which are
@@ -2242,6 +2256,7 @@
 void        xine_osd_set_position  (xine_osd_t *self, int x, int y) XINE_PROTECTED;
 void        xine_osd_show          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_show_unscaled (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
+void        xine_osd_show_scaled   (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 void        xine_osd_hide          (xine_osd_t *self, int64_t vpts) XINE_PROTECTED;
 /* empty drawing area */
 void        xine_osd_clear         (xine_osd_t *self) XINE_PROTECTED;
diff -urN xine-lib-1.2/src/demuxers/demux_ts.c xine-lib-1.2.enigmaw/src/demuxers/demux_ts.c
--- xine-lib-1.2/src/demuxers/demux_ts.c	2014-11-09 17:50:35.894622078 +0100
+++ xine-lib-1.2.enigmaw/src/demuxers/demux_ts.c	2014-01-11 15:34:05.000000000 +0100
@@ -792,27 +792,6 @@
   demux_ts_send_buffer(m, BUF_FLAG_FRAME_END);
 }
 
-static void post_sequence_end(fifo_buffer_t *fifo, uint32_t video_type) {
-
-  if (video_type == BUF_VIDEO_H264 ||
-      video_type == BUF_VIDEO_MPEG ||
-      video_type == BUF_VIDEO_VC1) {
-
-    buf_element_t *buf = fifo->buffer_pool_try_alloc(fifo);
-    if (buf) {
-      buf->type = video_type;
-      buf->size = 4;
-      buf->decoder_flags = BUF_FLAG_FRAME_END;
-      buf->content[0] = 0x00;
-      buf->content[1] = 0x00;
-      buf->content[2] = 0x01;
-      buf->content[3] = (video_type == BUF_VIDEO_MPEG) ? 0xb7 : 0x0a;
-      fifo->put(fifo, buf);
-    }
-  }
-}
-
-
 static void demux_ts_flush(demux_ts_t *this)
 {
   unsigned int i;
@@ -820,10 +799,6 @@
     demux_ts_flush_media(&this->media[i]);
     this->media[i].corrupted_pes = 1;
   }
-
-  /* append sequence end code to video stream */
-  if (this->videoPid != INVALID_PID)
-    post_sequence_end(this->stream->video_fifo, this->media[this->videoMedia].type);
 }
 
 /*
@@ -1319,6 +1294,9 @@
 
     /* allocate the buffer here, as pes_header needs a valid buf for dvbsubs */
     m->buf = m->fifo->buffer_pool_alloc(m->fifo);
+    /* dont let decoder crash on incomplete frames.
+       Also needed by net_buf_ctrl/dvbspeed. */
+    m->buf->decoder_flags |= BUF_FLAG_FRAME_START;
 
     int pes_header_len = demux_ts_parse_pes_header(this->stream->xine, m, ts, len);
 
@@ -2291,30 +2269,8 @@
   }
 
   /* PAT */
-  if (pid == 0) {
-    demux_ts_parse_pat(this, originalPkt, originalPkt + data_offset,
-		       payload_unit_start_indicator, PKT_SIZE - data_offset);
-    return;
-  }
-
   /* PMT */
-  program_count=0;
-  while ((this->program_number[program_count] != INVALID_PROGRAM) &&
-         (program_count < MAX_PMTS)) {
-    if (pid == this->pmt_pid[program_count]) {
-
-#ifdef TS_LOG
-      printf ("demux_ts: PMT prog: 0x%.4x pid: 0x%.4x\n",
-              this->program_number[program_count],
-              this->pmt_pid[program_count]);
-#endif
-      demux_ts_parse_pmt (this, originalPkt, originalPkt + data_offset,
-                          payload_unit_start_indicator, PKT_SIZE - data_offset,
-                          program_count);
-      return;
-    }
-    program_count++;
-  }
+  // PAT and PMT are not processed for openpliPC. PIDs are recognized in E2
 
   data_len = PKT_SIZE - data_offset;
 
@@ -2376,6 +2332,7 @@
 static void demux_ts_event_handler (demux_ts_t *this) {
 
   xine_event_t *event;
+  int           mi;
 
   while ((event = xine_event_get (this->event_queue))) {
 
@@ -2386,13 +2343,37 @@
       /* flush all streams */
       demux_ts_flush(this);
       /* fall thru */
-
+      break;
+      
     case XINE_EVENT_PIDS_CHANGE:
-
-      demux_ts_dynamic_pmt_clear(this);
+      demux_ts_dynamic_pmt_clear(this); 
       this->send_newpts = 1;
       _x_demux_control_start (this->stream);
       break;
+      
+    case XINE_EVENT_SET_VIDEO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_VIDEO_STREAMTYPE\n");
+ 
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_VIDEO_BASE, data->streamtype);
+        if (mi >= 0) {
+          this->videoPid = data->pid;
+          this->videoMedia = mi;
+        }
+      }
+      break;
+
+    case XINE_EVENT_SET_AUDIO_STREAMTYPE:
+      printf("RECEIVED XINE_EVENT_SET_AUDIO_STREAMTYPE\n");
+
+      if (event->data) {
+        xine_streamtype_data_t* data = (xine_streamtype_data_t*)event->data;
+
+        mi = demux_ts_dynamic_pmt_find (this, data->pid, BUF_AUDIO_BASE, data->streamtype);
+      }
+      break;  
 
     }
 
diff -urN xine-lib-1.2/src/input/combined_enigma.c xine-lib-1.2.enigmaw/src/input/combined_enigma.c
--- xine-lib-1.2/src/input/combined_enigma.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.enigmaw/src/input/combined_enigma.c	2013-08-10 04:21:19.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * plugins for VDR
+ */
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+static const post_info_t enigma_video_special_info = { XINE_POST_TYPE_VIDEO_FILTER };
+static const post_info_t enigma_audio_special_info = { XINE_POST_TYPE_AUDIO_FILTER };
+
+/* exported plugin catalog entry */
+const plugin_info_t xine_plugin_info[] EXPORTED =
+{
+  /* type       , API, "name"     , version          , special_info           , init_function */
+  { PLUGIN_INPUT,  18, "ENIGMA"      , XINE_VERSION_CODE, NULL                   , &init_class },
+  { PLUGIN_POST ,  10, "enigma"      , XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+  { PLUGIN_POST ,  10, "enigma_video", XINE_VERSION_CODE, &enigma_video_special_info, &enigma_video_init_plugin },
+//  { PLUGIN_POST ,  10, "vdr_audio", XINE_VERSION_CODE, &vdr_audio_special_info, &vdr_audio_init_plugin },
+  { PLUGIN_NONE ,   0, ""         , 0                , NULL                   , NULL }
+};
+
diff -urN xine-lib-1.2/src/input/combined_enigma.h xine-lib-1.2.enigmaw/src/input/combined_enigma.h
--- xine-lib-1.2/src/input/combined_enigma.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.enigmaw/src/input/combined_enigma.h	2013-08-10 04:21:19.000000000 +0200
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifndef __COMBINED_ENIGMA_H
+#define __COMBINED_ENIGMA_H
+
+
+
+typedef struct enigma_set_video_window_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+} enigma_set_video_window_data_t;
+
+
+
+typedef struct enigma_frame_size_changed_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  double r;
+
+} enigma_frame_size_changed_data_t;
+
+
+
+typedef struct enigma_select_audio_data_s {
+  uint8_t channels;
+
+} enigma_select_audio_data_t;
+
+
+
+inline static int enigma_is_stream(xine_stream_t *stream)
+{
+  if (!stream
+      || !stream->input_plugin
+      || !stream->input_plugin->input_class)
+  {
+    return 0;
+  }
+
+  if (stream->input_plugin->input_class->identifier &&
+      0 == strcmp(stream->input_plugin->input_class->identifier, "ENIGMA"))
+    return 1;
+
+  return 0;
+}
+
+
+/* plugin class initialization function */
+void *init_class(xine_t *xine, void *data);
+void *enigma_video_init_plugin(xine_t *xine, void *data);
+//void *vdr_audio_init_plugin(xine_t *xine, void *data);
+
+
+
+#endif /* __COMBINED_ENIGMA_H */
+
diff -urN xine-lib-1.2/src/input/input_dvb.c xine-lib-1.2.enigmaw/src/input/input_dvb.c
--- xine-lib-1.2/src/input/input_dvb.c	2014-11-09 17:50:35.930622078 +0100
+++ xine-lib-1.2.enigmaw/src/input/input_dvb.c	2014-11-09 17:22:55.834593000 +0100
@@ -1420,7 +1420,7 @@
    EPG OSD of all channels found in the currently tuned stream. */
 static void load_epg_data(dvb_input_plugin_t *this)
 {
-  /*int table_id;*/
+  int table_id;
   char skip_byte;
   int descriptor_id;
   int section_len = 0;
@@ -1467,7 +1467,7 @@
        xprintf(this->stream->xine,XINE_VERBOSITY_LOG,"Error reading EPG section length\n");
        break;
     }
-    /*table_id =*/ getbits(eit, 0, 8);
+    table_id = getbits(eit, 0, 8);
     section_len = (unsigned int)getbits(eit, 12, 12);
     n = read(this->tuner->fd_pidfilter[EITFILTER], eit + 3, section_len);
     if (n != section_len) {
diff -urN xine-lib-1.2/src/input/input_enigma.c xine-lib-1.2.enigmaw/src/input/input_enigma.c
--- xine-lib-1.2/src/input/input_enigma.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.enigmaw/src/input/input_enigma.c	2013-08-10 04:21:19.000000000 +0200
@@ -0,0 +1,640 @@
+/*
+ * Copyright (C) 2000-2003 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+#define LOG_MODULE "input_enigma"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/input_plugin.h>
+#include "net_buf_ctrl.h"
+#include "combined_enigma.h"
+
+#define ENIGMA_ABS_FIFO_DIR     "/tmp"
+#define DEFAULT_PTS_START       150000
+#define BUFSIZE                 768
+#define FILE_FLAGS O_RDONLY
+#define FIFO_PUT                0
+
+typedef struct enigma_input_plugin_s enigma_input_plugin_t;
+
+struct enigma_input_plugin_s {
+  input_plugin_t      input_plugin;
+  xine_stream_t      *stream;
+  int                 fh;
+  char               *mrl;
+  off_t               curpos;
+  char                seek_buf[BUFSIZE];
+  xine_t             *xine;
+  int                 last_disc_type;
+  nbc_t              *nbc;
+};
+
+typedef struct {
+  input_class_t     input_class;
+  xine_t           *xine;
+} enigma_input_class_t;
+
+
+/* Put callback the fifo mutex is locked */
+static void enigma_nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen) {
+  nbc_t *this = (nbc_t*)this_gen;
+  int64_t progress = 0;
+  int64_t video_p = 0;
+  int64_t audio_p = 0;
+  int force_dvbspeed = 0;
+  int has_video, has_audio;
+  force_dvbspeed = 0;
+  xine_t *xine = this->stream->xine;
+
+  cfg_entry_t *entry;
+	config_values_t *cfg;
+	cfg = xine->config;
+	entry = cfg->lookup_entry(cfg, "input.buffer.dynamic");
+  if  (strdup(entry->unknown_value) == "1");
+  			force_dvbspeed = 1;
+
+  lprintf("enter enigma_nbc_put_cb\n");
+  pthread_mutex_lock(&this->mutex);
+
+  if ((buf->type & BUF_MAJOR_MASK) != BUF_CONTROL_BASE) {
+
+    if (this->enabled) {
+      if (this->dvbspeed)
+        dvbspeed_put (this, fifo, buf);
+      else {
+      nbc_compute_fifo_length(this, fifo, buf, FIFO_PUT);
+
+      if (this->buffering) {
+
+        has_video = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_VIDEO);
+        has_audio = _x_stream_info_get(this->stream, XINE_STREAM_INFO_HAS_AUDIO);
+        /* restart playing if high_water_mark is reached by all fifos
+         * do not restart if has_video and has_audio are false to avoid
+         * a yoyo effect at the beginning of the stream when these values
+         * are not yet known.
+         *
+         * be sure that the next buffer_pool_alloc() call will not deadlock,
+         * we need at least 2 buffers (see buffer.c)
+         */
+//printf("this->video_last_pts %lld   this->audio_last_pts %lld\n", this->video_last_pts, this->audio_last_pts);
+        int64_t first_pts = this->video_first_pts>this->audio_first_pts?this->video_first_pts:this->audio_first_pts;
+        int64_t last_pts = this->video_last_pts<this->audio_last_pts?this->video_last_pts:this->audio_last_pts;
+//printf("AAA first_pts %lld  last_pts %lld\n", first_pts, last_pts);
+        if ( has_video && has_audio && (last_pts-first_pts)>DEFAULT_PTS_START ) {
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+          nbc_set_speed_normal(this);
+        }
+        else if ((((!has_video) || (this->video_fifo_length > this->high_water_mark)) &&
+             ((!has_audio) || (this->audio_fifo_length > this->high_water_mark)) &&
+             (has_video || has_audio))) {
+
+          this->progress = 100;
+          //report_progress (this->stream, 100);
+          this->buffering = 0;
+
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+          nbc_set_speed_normal(this);
+
+          this->high_water_mark += this->high_water_mark / 2;
+
+        } else {
+          /*  compute the buffering progress
+           *    50%: video
+           *    50%: audio */
+          video_p = ((this->video_fifo_length * 50) / this->high_water_mark);
+          if (video_p > 50) video_p = 50;
+          audio_p = ((this->audio_fifo_length * 50) / this->high_water_mark);
+          if (audio_p > 50) audio_p = 50;
+
+          if ((has_video) && (has_audio)) {
+            progress = video_p + audio_p;
+          } else if (has_video) {
+            progress = 2 * video_p;
+          } else {
+            progress = 2 * audio_p;
+          }
+
+          /* if the progress can't be computed using the fifo length,
+             use the number of buffers */
+          if (!progress) {
+            video_p = this->video_fifo_fill;
+            audio_p = this->audio_fifo_fill;
+            progress = (video_p > audio_p) ? video_p : audio_p;
+          }
+
+          if (progress > this->progress) {
+            //report_progress (this->stream, progress);
+            this->progress = progress;
+          }
+        }
+      }
+      //if(this->stream->xine->verbosity >= XINE_VERBOSITY_DEBUG)
+      //  display_stats(this);
+
+      //report_stats(this, 0);
+      }
+  	}
+  } else {
+
+    switch (buf->type) {
+      case BUF_CONTROL_START:
+        lprintf("BUF_CONTROL_START\n");
+        if (!this->enabled) {
+          /* a new stream starts */
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: starts buffering\n");
+          this->enabled           = 1;
+          this->buffering         = 1;
+          this->video_first_pts   = 0;
+          this->video_last_pts    = 0;
+          this->audio_first_pts   = 0;
+          this->audio_last_pts    = 0;
+          this->video_fifo_length = 0;
+          this->audio_fifo_length = 0;
+          dvbspeed_init (this, force_dvbspeed);
+          if (!this->dvbspeed) nbc_set_speed_pause(this);
+/*          this->progress = 0;
+          report_progress (this->stream, progress);*/
+        }
+        break;
+      case BUF_CONTROL_NOP:
+        if (!(buf->decoder_flags & BUF_FLAG_END_USER) &&
+            !(buf->decoder_flags & BUF_FLAG_END_STREAM)) {
+          break;
+        }
+        /* fall through */
+      case BUF_CONTROL_END:
+      case BUF_CONTROL_QUIT:
+        lprintf("BUF_CONTROL_END\n");
+        dvbspeed_close (this);
+        if (this->enabled) {
+          /* end of stream :
+           *   - disable the nbc
+           *   - unpause the engine if buffering
+           */
+          this->enabled = 0;
+
+          lprintf("DISABLE netbuf\n");
+
+          if (this->buffering) {
+            this->buffering = 0;
+            this->progress = 100;
+            //report_progress (this->stream, this->progress);
+
+            xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_put_cb: stops buffering\n");
+
+            nbc_set_speed_normal(this);
+          }
+        }
+        break;
+
+      case BUF_CONTROL_NEWPTS:
+        /* discontinuity management */
+        if (fifo == this->video_fifo) {
+          this->video_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb video disc %d\n", this->video_in_disc);
+        } else {
+          this->audio_in_disc++;
+          xprintf(this->stream->xine, XINE_VERBOSITY_DEBUG,
+		  "\nnet_buf_ctrl: enigma_nbc_put_cb audio disc %d\n", this->audio_in_disc);
+        }
+        break;
+    }
+
+    if (fifo == this->video_fifo) {
+      this->video_fifo_free = fifo->buffer_pool_num_free;
+      this->video_fifo_size = fifo->fifo_data_size;
+    } else {
+      this->audio_fifo_free = fifo->buffer_pool_num_free;
+      this->audio_fifo_size = fifo->fifo_data_size;
+    }
+  }
+  pthread_mutex_unlock(&this->mutex);
+  lprintf("exit enigma_nbc_put_cb\n");
+}
+
+nbc_t *enigma_nbc_init (xine_stream_t *stream) {
+
+  nbc_t *this = calloc(1, sizeof (nbc_t));
+  fifo_buffer_t *video_fifo = stream->video_fifo;
+  fifo_buffer_t *audio_fifo = stream->audio_fifo;
+  
+  
+  double video_fifo_factor, audio_fifo_factor;
+  cfg_entry_t *entry;
+
+  lprintf("enigma_nbc_init\n");
+  pthread_mutex_init (&this->mutex, NULL);
+
+  this->stream              = stream;
+  this->video_fifo          = video_fifo;
+  this->audio_fifo          = audio_fifo;
+
+  /* when the FIFO sizes are increased compared to the default configuration,
+   * apply a factor to the high water mark */
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.video_num_buffers");
+  /* No entry when no video output */
+  if (entry)
+    video_fifo_factor = (double)video_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    video_fifo_factor = 1.0;
+  entry = stream->xine->config->lookup_entry(stream->xine->config, "engine.buffers.audio_num_buffers");
+  /* When there's no audio output, there's no entry */
+  if (entry)
+    audio_fifo_factor = (double)audio_fifo->buffer_pool_capacity / (double)entry->num_default;
+  else
+    audio_fifo_factor = 1.0;
+  /* use the smaller factor */
+  if (video_fifo_factor < audio_fifo_factor)
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * video_fifo_factor;
+  else
+    this->high_water_mark = (double)DEFAULT_HIGH_WATER_MARK * audio_fifo_factor;
+
+  video_fifo->register_alloc_cb(video_fifo, nbc_alloc_cb, this);
+  video_fifo->register_put_cb(video_fifo, enigma_nbc_put_cb, this);
+  video_fifo->register_get_cb(video_fifo, nbc_get_cb, this);
+
+  audio_fifo->register_alloc_cb(audio_fifo, nbc_alloc_cb, this);
+  audio_fifo->register_put_cb(audio_fifo, enigma_nbc_put_cb, this);
+  audio_fifo->register_get_cb(audio_fifo, nbc_get_cb, this);
+
+  return this;
+}
+
+void enigma_nbc_close (nbc_t *this) {
+  fifo_buffer_t *video_fifo = this->stream->video_fifo;
+  fifo_buffer_t *audio_fifo = this->stream->audio_fifo;
+  xine_t        *xine       = this->stream->xine;
+
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close\n");
+
+  /* unregister all fifo callbacks */
+  /* do not lock the mutex to avoid deadlocks if a decoder calls fifo->get() */
+  video_fifo->unregister_alloc_cb(video_fifo, nbc_alloc_cb);
+  video_fifo->unregister_put_cb(video_fifo, enigma_nbc_put_cb);
+  video_fifo->unregister_get_cb(video_fifo, nbc_get_cb);
+
+  audio_fifo->unregister_alloc_cb(audio_fifo, nbc_alloc_cb);
+  audio_fifo->unregister_put_cb(audio_fifo, enigma_nbc_put_cb);
+  audio_fifo->unregister_get_cb(audio_fifo, nbc_get_cb);
+
+  /* now we are sure that nobody will call a callback */
+  this->stream->xine->clock->set_option (this->stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
+
+  pthread_mutex_destroy(&this->mutex);
+  free (this);
+  xprintf(xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: enigma_nbc_close: done\n");
+}
+
+static off_t enigma_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{
+  off_t ret;
+
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+
+    break;
+  }
+
+  return ret;
+}
+
+static off_t enigma_plugin_read (input_plugin_t *this_gen,
+				void *buf_gen, off_t len) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+  uint8_t *buf = (uint8_t *)buf_gen;
+  off_t n, total = 0;
+#ifdef LOG_READ
+  lprintf ("reading %lld bytes...\n", len);
+#endif
+
+  if( len > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = enigma_read_abort (this->stream, this->fh, (char *)&buf[total], len-total);
+      //n = _x_io_file_read (this->stream, this->fh, &buf[total], len - total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); // 200 * 50ms
+#ifdef LOG_READ
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n", n, total, len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+
+  return total;
+
+}
+
+static buf_element_t *enigma_plugin_read_block (input_plugin_t *this_gen, fifo_buffer_t *fifo,
+					       off_t todo) {
+
+  off_t                 total_bytes;
+  /* enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen; */
+  buf_element_t         *buf = fifo->buffer_pool_alloc (fifo);
+
+  if (todo > buf->max_size)
+    todo = buf->max_size;
+  if (todo < 0) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = enigma_plugin_read (this_gen, (char*)buf->content, todo);
+
+  if (total_bytes != todo) {
+    buf->free_buffer (buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t enigma_plugin_seek (input_plugin_t *this_gen, off_t offset, int origin) {
+
+  enigma_input_plugin_t  *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("seek %"PRId64" offset, %d origin...\n", offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0)) {
+
+    for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+      if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET) {
+
+    if (offset < this->curpos) {
+
+      //if( this->curpos <= this->preview_size )
+      //  this->curpos = offset;
+      //else
+        xprintf (this->xine, XINE_VERBOSITY_LOG,
+                 _("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n"),
+                 (intmax_t)this->curpos, (intmax_t)offset);
+        printf ("stdin: cannot seek back! (%" PRIdMAX " > %" PRIdMAX ")\n",
+                 (intmax_t)this->curpos, (intmax_t)offset);
+
+    } else {
+      offset -= this->curpos;
+
+      for (;((int)offset) - BUFSIZE > 0; offset -= BUFSIZE) {
+        if( this_gen->read (this_gen, this->seek_buf, BUFSIZE) <= 0 )
+          return this->curpos;
+      }
+
+      this_gen->read (this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t enigma_plugin_get_length(input_plugin_t *this_gen) {
+  return 0;
+}
+
+static uint32_t enigma_plugin_get_capabilities(input_plugin_t *this_gen) {
+
+  return INPUT_CAP_PREVIEW;
+}
+
+static uint32_t enigma_plugin_get_blocksize(input_plugin_t *this_gen) {
+
+  return 0;
+}
+
+static off_t enigma_plugin_get_current_pos (input_plugin_t *this_gen){
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->curpos;
+}
+
+static const char* enigma_plugin_get_mrl (input_plugin_t *this_gen) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  return this->mrl;
+}
+
+static void enigma_plugin_dispose (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  if (this->nbc) {
+    enigma_nbc_close (this->nbc);
+  }
+
+  if (this->fh != -1)
+    close(this->fh);
+
+  free (this->mrl);
+  free (this);
+}
+
+static int enigma_plugin_get_optional_data (input_plugin_t *this_gen,
+					   void *data, int data_type) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    /* just fake what mpeg_pes demuxer expects */
+    memcpy (data, "\x00\x00\x01\xe0\x00\x03\x80\x00\x00", 9);
+    return 9;
+  case INPUT_OPTIONAL_DATA_DEMUXER:
+    {
+      char **tmp = (char**)data;
+      *tmp = "mpeg-ts";
+    }
+    return 0;
+  }
+
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int enigma_plugin_open (input_plugin_t *this_gen ) {
+  enigma_input_plugin_t *this = (enigma_input_plugin_t *) this_gen;
+
+  printf ("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1) {
+    int err = 0;
+    char *filename = (char *)ENIGMA_ABS_FIFO_DIR "/ENIGMA_FIFO";
+    this->fh = open (filename, FILE_FLAGS);
+
+    printf("filename '%s'\n", filename);
+
+    if (this->fh == -1) {
+      xprintf (this->xine, XINE_VERBOSITY_LOG, _("enigma_fifo: failed to open '%s'\n"), filename);
+      printf ("enigma_fifo: failed to open '%s'\n", filename);
+      return 0;
+    }
+
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this->curpos          = 0;
+
+  return 1;
+}
+
+static input_plugin_t *enigma_class_get_instance (input_class_t *class_gen,
+						 xine_stream_t *stream, const char *data) {
+
+  enigma_input_class_t  *class = (enigma_input_class_t *) class_gen;
+  enigma_input_plugin_t *this;
+  char                 *mrl = strdup(data);
+  int                   fh;
+
+  if (!strncasecmp(mrl, "enigma:/", 8)) {
+    lprintf("Enigma plugin\n");
+  } else {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this       = calloc(1, sizeof(enigma_input_plugin_t));
+
+  this->stream = stream;
+  this->curpos = 0;
+  this->mrl    = mrl;
+  this->fh     = -1;
+  this->xine   = class->xine;
+
+  this->input_plugin.open              = enigma_plugin_open;
+  this->input_plugin.get_capabilities  = enigma_plugin_get_capabilities;
+  this->input_plugin.read              = enigma_plugin_read;
+  this->input_plugin.read_block        = enigma_plugin_read_block;
+  this->input_plugin.seek              = enigma_plugin_seek;
+  this->input_plugin.get_current_pos   = enigma_plugin_get_current_pos;
+  this->input_plugin.get_length        = enigma_plugin_get_length;
+  this->input_plugin.get_blocksize     = enigma_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = enigma_plugin_get_mrl;
+  this->input_plugin.dispose           = enigma_plugin_dispose;
+  this->input_plugin.get_optional_data = enigma_plugin_get_optional_data;
+  this->input_plugin.input_class       = class_gen;
+
+  /*
+   * buffering control
+   */
+  this->nbc    = enigma_nbc_init (this->stream);
+
+  return &this->input_plugin;
+}
+
+
+//static void *init_class (xine_t *xine, void *data) {
+void *init_class (xine_t *xine, void *data) {
+
+  enigma_input_class_t  *this;
+
+  this = calloc(1, sizeof (enigma_input_class_t));
+
+  this->xine   = xine;
+
+  this->input_class.get_instance       = enigma_class_get_instance;
+  this->input_class.identifier         = "ENIGMA";
+  this->input_class.description        = N_("ENIGMA2PC display device plugin");
+  this->input_class.get_dir            = NULL;
+  this->input_class.get_autoplay_list  = NULL;
+  this->input_class.dispose            = default_input_class_dispose;
+  this->input_class.eject_media        = NULL;
+
+  return this;
+}
+
+/*
+ * exported plugin catalog entry
+ */
+
+/*
+const plugin_info_t xine_plugin_info[] EXPORTED = {
+//  type, API, "name", version, special_info, init_function 
+  { PLUGIN_INPUT, 18, "enigma", XINE_VERSION_CODE, NULL, init_class },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
+*/
diff -urN xine-lib-1.2/src/input/Makefile.am xine-lib-1.2.enigmaw/src/input/Makefile.am
--- xine-lib-1.2/src/input/Makefile.am	2014-11-09 17:50:35.918622078 +0100
+++ xine-lib-1.2.enigmaw/src/input/Makefile.am	2014-11-09 17:22:55.834593000 +0100
@@ -88,7 +88,8 @@
 	$(in_pvr) \
 	$(in_dvb) \
 	$(in_bluray) \
-	xineplug_inp_cdda.la
+	xineplug_inp_cdda.la \
+	xineplug_inp_enigma.la
 
 
 xineplug_inp_file_la_SOURCES = input_file.c
@@ -162,3 +163,7 @@
 xineplug_inp_bluray_la_SOURCES = input_bluray.c media_helper.c
 xineplug_inp_bluray_la_LIBADD = $(XINE_LIB) $(LIBBLURAY_LIBS) $(PTHREAD_LIBS) $(LTLIBINTL)
 xineplug_inp_bluray_la_CFLAGS = $(AM_CFLAGS) $(LIBBLURAY_CFLAGS)
+
+xineplug_inp_enigma_la_SOURCES = combined_enigma.c combined_enigma.h input_enigma.c net_buf_ctrl.c post_enigma_video.c
+xineplug_vdr_la_CFLAGS = $(AM_CFLAGS) -fno-strict-aliasing
+xineplug_inp_enigma_la_LIBADD = $(XINE_LIB) $(PTHREAD_LIBS) $(LTLIBINTL)
diff -urN xine-lib-1.2/src/input/net_buf_ctrl.c xine-lib-1.2.enigmaw/src/input/net_buf_ctrl.c
--- xine-lib-1.2/src/input/net_buf_ctrl.c	2014-11-09 17:50:35.986622079 +0100
+++ xine-lib-1.2.enigmaw/src/input/net_buf_ctrl.c	2014-11-09 17:22:55.834593000 +0100
@@ -40,60 +40,12 @@
 
 #include "net_buf_ctrl.h"
 
-#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
-
 #define FULL_FIFO_MARK             5 /* buffers free */
 
 #define FIFO_PUT                   0
 #define FIFO_GET                   1
 
-struct nbc_s {
-
-  xine_stream_t   *stream;
 
-  int              buffering;
-  int              enabled;
-
-  int              progress;
-  fifo_buffer_t   *video_fifo;
-  fifo_buffer_t   *audio_fifo;
-  int              video_fifo_fill;
-  int              audio_fifo_fill;
-  int              video_fifo_free;
-  int              audio_fifo_free;
-  int64_t          video_fifo_length;     /* in ms */
-  int64_t          audio_fifo_length;     /* in ms */
-  int64_t          video_fifo_length_int; /* in ms */
-  int64_t          audio_fifo_length_int; /* in ms */
-
-  int64_t          high_water_mark;
-  /* bitrate */
-  int64_t          video_last_pts;
-  int64_t          audio_last_pts;
-  int64_t          video_first_pts;
-  int64_t          audio_first_pts;
-  int64_t          video_fifo_size;
-  int64_t          audio_fifo_size;
-  int64_t          video_br;
-  int64_t          audio_br;
-
-  int              video_in_disc;
-  int              audio_in_disc;
-
-  pthread_mutex_t  mutex;
-
-  /* follow live dvb delivery speed.
-     0 = fix disabled
-     1 = play at normal speed
-     2 = play 0.5% slower to fill video fifo
-     3 = play 0.5% faster to empty video fifo
-     4..6 = same as 1..3 but watch audio fifo instead
-     7 = pause */
-  int dvbspeed;
-  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
-  int64_t dvbs_audio_in, dvbs_audio_out;
-  int64_t dvbs_video_in, dvbs_video_out;
-};
 
 static void report_progress (xine_stream_t *stream, int p) {
 
@@ -110,7 +62,7 @@
   xine_event_send (stream, &event);
 }
 
-static void nbc_set_speed_pause (nbc_t *this) {
+void nbc_set_speed_pause (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_pause\n");
@@ -118,7 +70,7 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 0);
 }
 
-static void nbc_set_speed_normal (nbc_t *this) {
+void nbc_set_speed_normal (nbc_t *this) {
   xine_stream_t *stream = this->stream;
 
   xprintf(stream->xine, XINE_VERBOSITY_DEBUG, "\nnet_buf_ctrl: nbc_set_speed_normal\n");
@@ -126,13 +78,13 @@
   stream->xine->clock->set_option (stream->xine->clock, CLOCK_SCR_ADJUSTABLE, 1);
 }
 
-static void dvbspeed_init (nbc_t *this) {
+void dvbspeed_init (nbc_t *this, int force) {
   const char *mrl;
-  if (this->stream && this->stream->input_plugin) {
+  if (this->stream && this->stream->input_plugin || force == 1) {
     mrl = this->stream->input_plugin->get_mrl (this->stream->input_plugin);
-    if (mrl) {
+    if (mrl || force == 1) {
       /* detect Kaffeine: fifo://~/.kde4/share/apps/kaffeine/dvbpipe.m2t */
-      if ((strcasestr (mrl, "/dvbpipe.")) ||
+      if (force == 1 || (strcasestr (mrl, "/dvbpipe.")) ||
         ((!strncasecmp (mrl, "dvb", 3)) &&
         ((mrl[3] == ':') || (mrl[3] && (mrl[4] == ':'))))) {
         this->dvbs_center = 2 * 90000;
@@ -158,8 +110,8 @@
 #endif
           }
           if (xine_config_lookup_entry (xine, "engine.buffers.video_num_buffers",
-            &entry) && (entry.num_value < 800)) {
-            config->update_num (config, "engine.buffers.video_num_buffers", 800);
+            &entry) && (entry.num_value < 1800)) {
+            config->update_num (config, "engine.buffers.video_num_buffers", 1800);
 #ifdef LOG_DVBSPEED
             printf ("net_buf_ctrl: enlarged video fifo to 800 buffers\n");
 #endif
@@ -169,9 +121,10 @@
       }
     }
   }
+
 }
 
-static void dvbspeed_close (nbc_t *this) {
+void dvbspeed_close (nbc_t *this) {
   if (((0xec >> this->dvbspeed) & 1) && this->stream)
     _x_set_fine_speed (this->stream, XINE_FINE_SPEED_NORMAL);
 #ifdef LOG_DVBSPEED
@@ -180,7 +133,7 @@
   this->dvbspeed = 0;
 }
 
-static void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -256,7 +209,7 @@
   }
 }
 
-static void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b) {
   int64_t diff, *last;
   int *fill;
   int used, mode;
@@ -372,7 +325,7 @@
  *    else
  *      use the the first and the last pts of the fifo
  */
-static void nbc_compute_fifo_length(nbc_t *this,
+void nbc_compute_fifo_length(nbc_t *this,
                                     fifo_buffer_t *fifo,
                                     buf_element_t *buf,
                                     int action) {
@@ -474,7 +427,7 @@
 }
 
 /* Alloc callback */
-static void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
   lprintf("enter nbc_alloc_cb\n");
@@ -498,13 +451,15 @@
 
 /* Put callback
  * the fifo mutex is locked */
-static void nbc_put_cb (fifo_buffer_t *fifo,
+void nbc_put_cb (fifo_buffer_t *fifo,
                         buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
   int64_t progress = 0;
   int64_t video_p = 0;
   int64_t audio_p = 0;
   int has_video, has_audio;
+	int force_dvbspeed = 1;
+	
 
   lprintf("enter nbc_put_cb\n");
   pthread_mutex_lock(&this->mutex);
@@ -597,7 +552,7 @@
           this->audio_last_pts    = 0;
           this->video_fifo_length = 0;
           this->audio_fifo_length = 0;
-          dvbspeed_init (this);
+          dvbspeed_init (this, force_dvbspeed);
           if (!this->dvbspeed) nbc_set_speed_pause(this);
           this->progress = 0;
           report_progress (this->stream, progress);
@@ -662,7 +617,7 @@
 
 /* Get callback
  * the fifo mutex is locked */
-static void nbc_get_cb (fifo_buffer_t *fifo,
+void nbc_get_cb (fifo_buffer_t *fifo,
 			buf_element_t *buf, void *this_gen) {
   nbc_t *this = (nbc_t*)this_gen;
 
diff -urN xine-lib-1.2/src/input/net_buf_ctrl.h xine-lib-1.2.enigmaw/src/input/net_buf_ctrl.h
--- xine-lib-1.2/src/input/net_buf_ctrl.h	2014-11-09 17:50:35.986622079 +0100
+++ xine-lib-1.2.enigmaw/src/input/net_buf_ctrl.h	2014-01-11 15:34:05.000000000 +0100
@@ -25,10 +25,71 @@
 
 #include <xine/xine_internal.h>
 
+struct nbc_s {
+
+  xine_stream_t   *stream;
+
+  int              buffering;
+  int              enabled;
+
+  int              progress;
+  fifo_buffer_t   *video_fifo;
+  fifo_buffer_t   *audio_fifo;
+  int              video_fifo_fill;
+  int              audio_fifo_fill;
+  int              video_fifo_free;
+  int              audio_fifo_free;
+  int64_t          video_fifo_length;     /* in ms */
+  int64_t          audio_fifo_length;     /* in ms */
+  int64_t          video_fifo_length_int; /* in ms */
+  int64_t          audio_fifo_length_int; /* in ms */
+
+  int64_t          high_water_mark;
+  /* bitrate */
+  int64_t          video_last_pts;
+  int64_t          audio_last_pts;
+  int64_t          video_first_pts;
+  int64_t          audio_first_pts;
+  int64_t          video_fifo_size;
+  int64_t          audio_fifo_size;
+  int64_t          video_br;
+  int64_t          audio_br;
+
+  int              video_in_disc;
+  int              audio_in_disc;
+
+  pthread_mutex_t  mutex;
+
+  /* follow live dvb delivery speed.
+     0 = fix disabled
+     1 = play at normal speed
+     2 = play 0.5% slower to fill video fifo
+     3 = play 0.5% faster to empty video fifo
+     4..6 = same as 1..3 but watch audio fifo instead
+     7 = pause */
+  int dvbspeed;
+  int dvbs_center, dvbs_width, dvbs_audio_fill, dvbs_video_fill;
+  int64_t dvbs_audio_in, dvbs_audio_out;
+  int64_t dvbs_video_in, dvbs_video_out;
+};
+
+
 typedef struct nbc_s nbc_t;
 
 nbc_t *nbc_init (xine_stream_t *xine) XINE_MALLOC;
 
 void nbc_close (nbc_t *this);
+void nbc_set_speed_pause (nbc_t *this);
+void nbc_set_speed_normal (nbc_t *this);
+void dvbspeed_init (nbc_t *this, int force);
+void dvbspeed_close (nbc_t *this);
+void dvbspeed_put (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void dvbspeed_get (nbc_t *this, fifo_buffer_t * fifo, buf_element_t *b);
+void nbc_put_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+void nbc_compute_fifo_length(nbc_t *this, fifo_buffer_t *fifo, buf_element_t *buf, int action);
+void nbc_alloc_cb (fifo_buffer_t *fifo, void *this_gen);
+void nbc_get_cb (fifo_buffer_t *fifo, buf_element_t *buf, void *this_gen);
+
+#define DEFAULT_HIGH_WATER_MARK 5000 /* in 1/1000 s */
 
 #endif
diff -urN xine-lib-1.2/src/input/post_enigma_video.c xine-lib-1.2.enigmaw/src/input/post_enigma_video.c
--- xine-lib-1.2/src/input/post_enigma_video.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib-1.2.enigmaw/src/input/post_enigma_video.c	2013-08-10 04:21:19.000000000 +0200
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ */
+
+/*
+ * frame scaler plugin for ENIGMA2PC
+ */
+
+#define LOG_MODULE "enigma_video"
+/*
+#define LOG
+#define LOG_VERBOSE
+*/
+
+#include <xine/xine_internal.h>
+#include <xine/post.h>
+#include "combined_enigma.h"
+
+
+
+typedef struct enigma_video_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *enigma_stream;
+
+  int8_t trick_speed_mode;
+  int8_t enabled;
+
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+  int32_t old_frame_left;
+  int32_t old_frame_top;
+  int32_t old_frame_width;
+  int32_t old_frame_height;
+  double  old_frame_ratio;
+
+}
+enigma_video_post_plugin_t;
+
+
+static void enigma_video_set_video_window(enigma_video_post_plugin_t *this, int32_t x, int32_t y, int32_t w, int32_t h, int32_t w_ref, int32_t h_ref)
+{
+  this->enabled = 0;
+
+  this->x     = x;
+  this->y     = y;
+  this->w     = w;
+  this->h     = h;
+  this->w_ref = w_ref;
+  this->h_ref = h_ref;
+
+  if (w != w_ref || h != h_ref)
+    this->enabled = 1;
+}
+
+
+/* plugin class functions */
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target);
+
+/* plugin instance functions */
+static void           enigma_video_dispose(post_plugin_t *this_gen);
+
+/* route preprocessing functions check */
+static int            enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame);
+
+/* replaced vo_frame functions */
+static int            enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream);
+
+
+void *enigma_video_init_plugin(xine_t *xine, void *data)
+{
+  post_class_t *class = (post_class_t *)xine_xmalloc(sizeof (post_class_t));
+
+  if (!class)
+    return NULL;
+
+  class->open_plugin     = enigma_video_open_plugin;
+  class->identifier      = "enigma";
+  class->description     = N_("modifies every video frame as requested by ENIGMA");
+  class->dispose         = default_post_class_dispose;
+
+  return class;
+}
+
+static post_plugin_t *enigma_video_open_plugin(post_class_t *class_gen, int inputs,
+                                            xine_audio_port_t **audio_target,
+                                            xine_video_port_t **video_target)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)xine_xmalloc(sizeof (enigma_video_post_plugin_t));
+  post_in_t               *input;
+  post_out_t              *output;
+  post_video_port_t       *port;
+
+  if (!this || !video_target || !video_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  _x_post_init(&this->post_plugin, 0, 1);
+  this->post_plugin.dispose = enigma_video_dispose;
+
+  port = _x_post_intercept_video_port(&this->post_plugin, video_target[ 0 ], &input, &output);
+  port->route_preprocessing_procs = enigma_video_route_preprocessing_procs;
+  port->new_frame->draw           = enigma_video_draw;
+  this->post_plugin.xine_post.video_input[ 0 ] = &port->new_port;
+
+  this->enabled          = 0;
+  this->enigma_stream    = 0;
+  this->event_queue      = 0;
+  this->old_frame_left   = 0;
+  this->old_frame_top    = 0;
+  this->old_frame_width  = 0;
+  this->old_frame_height = 0;
+  this->old_frame_ratio  = 0;
+  this->trick_speed_mode = 0;
+
+  return &this->post_plugin;
+}
+
+static void enigma_video_dispose(post_plugin_t *this_gen)
+{
+  if (_x_post_dispose(this_gen))
+  {
+    enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)this_gen;
+
+    if (this->enigma_stream)
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = 0;
+      event_data.y = 0;
+      event_data.w = 0;
+      event_data.h = 0;
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      xine_event_dispose_queue(this->event_queue);
+    }
+
+    free(this_gen);
+  }
+}
+
+static int enigma_video_route_preprocessing_procs(post_video_port_t *port, vo_frame_t *frame)
+{
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  return !this->enabled
+    || (frame->format != XINE_IMGFMT_YUY2
+      && frame->format != XINE_IMGFMT_YV12);
+}
+
+static inline void enigma_video_scale(uint8_t *src, uint8_t *dst, int y_inc, int x_inc, int w_dst, int h_dst, int x, int y, int w, int h, int w_ref, int h_ref, int init)
+{
+  int x0 = x * w_dst / w_ref;
+  int y0 = y * h_dst / h_ref;
+
+  int x1 = ((x + w) * w_dst - 1 + w_ref) / w_ref;
+  int y1 = ((y + h) * h_dst - 1 + h_ref) / h_ref;
+
+  int dx = x1 - x0;
+  int dy = y1 - y0;
+
+  int yy, xx;
+
+  int dy2    = dy + dy;
+  int h_dst2 = h_dst + h_dst;
+  int y_eps  = h_dst - dy2;
+
+  int dx2    = dx + dx;
+  int w_dst2 = w_dst + w_dst;
+  int x_eps0 = w_dst - dx2;
+
+  for (yy = 0; yy < y0; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+
+  for (yy = y0; yy < y1; yy++)
+  {
+    uint8_t *dst0 = dst;
+    uint8_t *src0 = src;
+
+    int x_eps = x_eps0;
+
+    for (xx = 0; xx < x0; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    for (xx = x0; xx < x1; xx++)
+    {
+      *dst0 = *src0;
+      dst0 += x_inc;
+
+      x_eps += w_dst2;
+      while (x_eps >= 0)
+      {
+        src0  += x_inc;
+        x_eps -= dx2;
+      }
+    }
+
+    for (xx = x1; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+
+    y_eps += h_dst2;
+    while (y_eps >= 0)
+    {
+      src   += y_inc;
+      y_eps -= dy2;
+    }
+  }
+
+  for (yy = y1; yy < h_dst; yy++)
+  {
+    uint8_t *dst0 = dst;
+
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+}
+
+static void enigma_video_scale_YUY2(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] * dst->crop_top + 2 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 2,  w         , h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 1 ] + offset, &dst->base[ 0 ][ 1 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 0 ][ 3 ] + offset, &dst->base[ 0 ][ 3 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+static void enigma_video_scale_YV12(enigma_video_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+
+  if (w < 0)
+    w = 0;
+
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] *   dst->crop_top           + 1 *   dst->crop_left;
+  enigma_video_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 1,  w         ,  h         , this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 1 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 1 ][ 0 ] + offset, &dst->base[ 1 ][ 0 ] + offset, dst->pitches[ 1 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 2 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  enigma_video_scale(&src->base[ 2 ][ 0 ] + offset, &dst->base[ 2 ][ 0 ] + offset, dst->pitches[ 2 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+
+static int enigma_video_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t       *port = (post_video_port_t *)frame->port;
+  enigma_video_post_plugin_t *this = (enigma_video_post_plugin_t *)port->post;
+  vo_frame_t *enigma_frame;
+  xine_event_t *event;
+  int skip;
+
+  if (this->enigma_stream
+      && !_x_continue_stream_processing(this->enigma_stream))
+  {
+    this->enigma_stream = 0;
+
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+
+    this->old_frame_left   = 0;
+    this->old_frame_top    = 0;
+    this->old_frame_width  = 0;
+    this->old_frame_height = 0;
+    this->old_frame_ratio  = 0;
+  }
+
+  if (!this->enigma_stream
+      && enigma_is_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+    {
+      this->enigma_stream = stream;
+
+      {
+        xine_event_t event;
+
+        event.type = XINE_EVENT_VDR_PLUGINSTARTED;
+        event.data = 0;
+        event.data_length = 0; /* vdr_video */
+
+        xine_event_send(this->enigma_stream, &event);
+      }
+    }
+  }
+
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_VDR_SETVIDEOWINDOW)
+      {
+        enigma_set_video_window_data_t *data = (enigma_set_video_window_data_t *)event->data;
+
+        enigma_video_set_video_window(this, data->x, data->y, data->w, data->h, data->w_ref, data->h_ref);
+      }
+      else if (event->type == XINE_EVENT_VDR_TRICKSPEEDMODE)
+      {
+/*
+        fprintf(stderr, "###############################: %p, %d\n", event->data, event->data_length);
+        this->trick_speed_mode = (0 != event->data_length);
+*/
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  {
+    int32_t frame_left   = frame->crop_left;
+    int32_t frame_width  = frame->width - frame->crop_left - frame->crop_right;
+    int32_t frame_top    = frame->crop_top;
+    int32_t frame_height = frame->height - frame->crop_top - frame->crop_bottom;
+    double  frame_ratio  = frame->ratio;
+
+    if (frame_left < 0)
+      frame_left = 0;
+    if (frame_width > frame->width)
+      frame_width = frame->width;
+    if (frame_top < 0)
+      frame_top = 0;
+    if (frame_height > frame->height)
+      frame_height = frame->height;
+
+    if (this->enigma_stream
+        && frame_width != 0
+        && frame_height != 0
+        && (this->old_frame_left    != frame_left
+          || this->old_frame_top    != frame_top
+          || this->old_frame_width  != frame_width
+          || this->old_frame_height != frame_height
+          || this->old_frame_ratio  != frame_ratio))
+    {
+      xine_event_t event;
+      enigma_frame_size_changed_data_t event_data;
+
+      event_data.x = frame_left;
+      event_data.y = frame_top;
+      event_data.w = frame_width;
+      event_data.h = frame_height;
+      event_data.r = frame_ratio;
+
+      xprintf(this->enigma_stream->xine, XINE_VERBOSITY_LOG,
+            _(LOG_MODULE ": osd: (%d, %d)-(%d, %d)@%lg\n"), frame_left, frame_top, frame_width, frame_height, frame_ratio);
+
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+
+      xine_event_send(this->enigma_stream, &event);
+
+// Enigma2PC send event
+      xine_format_change_data_t event_data_enigma;
+
+      event_data_enigma.width = frame_width;
+      event_data_enigma.height = frame_height;
+
+      int ratio = (int)(10000 * frame_ratio + 0.5);
+      int matches4_3 = abs(ratio - 13333);
+      int matches16_9 = abs(ratio - 17778);
+      if (matches4_3 < matches16_9)
+       {
+        event_data_enigma.aspect = 2;
+       }
+      else
+      {
+        event_data_enigma.aspect = 3;
+      }
+      event_data_enigma.pan_scan = 0;
+
+      event.type        = XINE_EVENT_FRAME_FORMAT_CHANGE;
+      event.data        = &event_data_enigma;
+      event.data_length = sizeof (event_data_enigma);
+
+      xine_event_send(this->enigma_stream, &event);
+
+      this->old_frame_left   = frame_left;
+      this->old_frame_top    = frame_top;
+      this->old_frame_width  = frame_width;
+      this->old_frame_height = frame_height;
+      this->old_frame_ratio  = frame_ratio;
+    }
+  }
+/*
+  fprintf(stderr, "~~~~~~~~~~~~ trickspeedmode: %d\n", this->trick_speed_mode);
+
+  if (this->vdr_stream
+      && this->trick_speed_mode)
+  {
+    frame->pts = 0;
+    frame->next->pts = 0;
+  }
+*/
+#if defined(LOG) && defined(LOG_VERBOSE)
+  {
+    int a = 0, b = 0, c = 0, d = 0;
+    if (stream)
+      _x_query_buffer_usage(stream, &a, &b, &c, &d);
+    lprintf("buffer usage: %3d, %2d, %2d, %2d, %p\n", a, b, c, d, stream);
+  }
+#endif
+
+  if (!this->enabled
+      || frame->bad_frame
+      || (frame->format != XINE_IMGFMT_YUY2
+          && frame->format != XINE_IMGFMT_YV12)
+      || frame->proc_frame
+      || frame->proc_slice)
+  {
+    _x_post_frame_copy_down(frame, frame->next);
+    skip = frame->next->draw(frame->next, stream);
+    _x_post_frame_copy_up(frame, frame->next);
+    return skip;
+  }
+
+  enigma_frame = port->original_port->get_frame(port->original_port,
+    frame->width, frame->height, frame->ratio, frame->format, frame->flags | VO_BOTH_FIELDS);
+
+  _x_post_frame_copy_down(frame, enigma_frame);
+
+  switch (enigma_frame->format)
+  {
+  case XINE_IMGFMT_YUY2:
+    enigma_video_scale_YUY2(this, frame, enigma_frame);
+    break;
+
+  case XINE_IMGFMT_YV12:
+    enigma_video_scale_YV12(this, frame, enigma_frame);
+    break;
+  }
+
+  skip = enigma_frame->draw(enigma_frame, stream);
+  _x_post_frame_copy_up(frame, enigma_frame);
+  enigma_frame->free(enigma_frame);
+
+  return skip;
+}
diff -urN xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in xine-lib-1.2.enigmaw/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in
--- xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	2014-11-09 17:50:36.122622081 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libmpeg2new/libmpeg2/libmpeg2convert.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: libmpeg2convert
-Description: libmpeg2 helper functions for converting to various formats.
-Version: @VERSION@
-Libs: -L${libdir} -lmpeg2convert
-Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in xine-lib-1.2.enigmaw/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in
--- xine-lib-1.2/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	2014-11-09 17:50:36.122622081 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libmpeg2new/libmpeg2/libmpeg2.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: libmpeg2
-Description: A decoding library for MPEG-1 and MPEG-2 streams.
-Version: @VERSION@
-Libs: -L${libdir} -lmpeg2
-Cflags: -I${includedir}/@PACKAGE@
diff -urN xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.c xine-lib-1.2.enigmaw/src/video_dec/libvdpau/alterh264_decode.c
--- xine-lib-1.2/src/video_dec/libvdpau/alterh264_decode.c	2014-11-09 17:50:36.126622081 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libvdpau/alterh264_decode.c	2014-01-11 15:34:05.000000000 +0100
@@ -26,7 +26,7 @@
 
 
 #define MAX_DPB_SIZE 16
-#define MIN_BUFFER_SIZE 10000
+#define MIN_BUFFER_SIZE 1000
 #define MAX_BUFFER_SIZE 3145728
 
 #define NAL_UNSPECIFIED 0
@@ -1838,7 +1838,18 @@
     event.data_length = sizeof (data);
     data.width = seq->coded_width;
     data.height = seq->coded_height;
-    data.aspect = seq->ratio;
+
+    if (fabs(seq->ratio-1.0)<0.1)
+      data.aspect = XINE_VO_ASPECT_SQUARE;
+    else if (fabs(seq->ratio-1.33)<0.1)
+      data.aspect = XINE_VO_ASPECT_4_3;
+    else if (fabs(seq->ratio-1.77)<0.1)
+      data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+    else if (fabs(seq->ratio-2.11)<0.1)
+      data.aspect = XINE_VO_ASPECT_DVB;
+    else
+      data.aspect = XINE_VO_ASPECT_AUTO;
+
     xine_event_send (vd->stream, &event);
   }
 
diff -urN xine-lib-1.2/src/video_dec/libvdpau/vdpau_h264.c xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_h264.c
--- xine-lib-1.2/src/video_dec/libvdpau/vdpau_h264.c	2014-11-09 17:50:36.134622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_h264.c	2014-01-11 15:34:05.000000000 +0100
@@ -377,7 +377,18 @@
   event.data_length = sizeof(data);
   data.width = this->width;
   data.height = this->height;
-  data.aspect = this->ratio;
+
+  if (fabs(this->ratio-1.0)<0.1)
+    data.aspect = XINE_VO_ASPECT_SQUARE;
+  else if (fabs(this->ratio-1.33)<0.1)
+    data.aspect = XINE_VO_ASPECT_4_3;
+  else if (fabs(this->ratio-1.77)<0.1)
+    data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+  else if (fabs(this->ratio-2.11)<0.1)
+    data.aspect = XINE_VO_ASPECT_DVB;
+  else
+    data.aspect = XINE_VO_ASPECT_AUTO;
+
   xine_event_send( this->stream, &event );
 
   switch(this->completed_pic->sps_nal->sps.profile_idc) {
diff -urN xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg12.c xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_mpeg12.c
--- xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg12.c	2014-11-09 17:50:36.134622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_mpeg12.c	2014-01-11 15:34:05.000000000 +0100
@@ -405,7 +405,8 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+    //data.aspect = sequence->ratio;
+    data.aspect = sequence->aspect_ratio_information;
     xine_event_send( this_gen->stream, &event );
   }
   else if ( sequence->have_header == 2 && sequence->reported_video_step != sequence->video_step ) {
diff -urN xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg4.c xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_mpeg4.c
--- xine-lib-1.2/src/video_dec/libvdpau/vdpau_mpeg4.c	2014-11-09 17:50:36.134622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_mpeg4.c	2014-01-11 15:34:05.000000000 +0100
@@ -321,7 +321,18 @@
   event.data_length = sizeof(data);
   data.width = sequence->coded_width;
   data.height = sequence->coded_height;
-  data.aspect = sequence->ratio;
+
+  if (fabs(sequence->ratio-1.0)<0.1)
+    data.aspect = XINE_VO_ASPECT_SQUARE;
+  else if (fabs(sequence->ratio-1.33)<0.1)
+    data.aspect = XINE_VO_ASPECT_4_3;
+  else if (fabs(sequence->ratio-1.77)<0.1)
+    data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+  else if (fabs(sequence->ratio-2.11)<0.1)
+    data.aspect = XINE_VO_ASPECT_DVB;
+  else
+    data.aspect = XINE_VO_ASPECT_AUTO;
+
   xine_event_send( this_gen->stream, &event );
 }
 
diff -urN xine-lib-1.2/src/video_dec/libvdpau/vdpau_vc1.c xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_vc1.c
--- xine-lib-1.2/src/video_dec/libvdpau/vdpau_vc1.c	2014-11-09 17:50:36.134622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_dec/libvdpau/vdpau_vc1.c	2014-01-11 15:34:05.000000000 +0100
@@ -239,7 +239,18 @@
     event.data_length = sizeof(data);
     data.width = sequence->coded_width;
     data.height = sequence->coded_height;
-    data.aspect = sequence->ratio;
+
+    if (fabs(sequence->ratio-1.0)<0.1)
+      data.aspect = XINE_VO_ASPECT_SQUARE;
+    else if (fabs(sequence->ratio-1.33)<0.1)
+      data.aspect = XINE_VO_ASPECT_4_3;
+    else if (fabs(sequence->ratio-1.77)<0.1)
+      data.aspect = XINE_VO_ASPECT_ANAMORPHIC;
+    else if (fabs(sequence->ratio-2.11)<0.1)
+      data.aspect = XINE_VO_ASPECT_DVB;
+    else
+      data.aspect = XINE_VO_ASPECT_AUTO;
+
     xine_event_send( this_gen->stream, &event );
   }
 }
diff -urN xine-lib-1.2/src/video_out/video_out_fb.c xine-lib-1.2.enigmaw/src/video_out/video_out_fb.c
--- xine-lib-1.2/src/video_out/video_out_fb.c	2014-11-09 17:50:36.146622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/video_out_fb.c	2014-11-09 17:22:55.838593000 +0100
@@ -97,6 +97,8 @@
 
   vo_scale_t         sc;
 
+  void              *chunk[3]; /* mem alloc by xmalloc_aligned           */
+
   yuv2rgb_t         *yuv2rgb;  /* yuv2rgb converter for this frame */
   uint8_t           *rgb_dst;
   int                yuv_stride;
diff -urN xine-lib-1.2/src/video_out/video_out_opengl.c xine-lib-1.2.enigmaw/src/video_out/video_out_opengl.c
--- xine-lib-1.2/src/video_out/video_out_opengl.c	2014-11-09 17:50:36.150622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/video_out_opengl.c	2014-05-25 15:28:55.000000000 +0200
@@ -139,6 +139,14 @@
 #define MY_PI                3.1415926
 #define MY_2PI               6.2831853
 
+typedef struct opengl_argb_layer_s {
+  pthread_mutex_t  mutex;
+  uint32_t        *buffer;
+  /* dirty area */
+  int width;
+  int height;
+  int changed;
+} opengl_argb_layer_t;
 
 typedef struct {
   vo_frame_t         vo_frame;
@@ -215,8 +223,14 @@
 
   /* Frame state */
   opengl_frame_t    *frame[NUM_FRAMES_BACKLOG];
+  
+  /* Overlay */
   x11osd            *xoverlay;
+  opengl_argb_layer_t argb_layer;
   int                ovl_changed;
+  int                last_ovl_width, last_ovl_height;
+  int                tex_ovl_width, tex_ovl_height; /* independend of frame */
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   config_values_t   *config;
   xine_t            *xine;
@@ -246,6 +260,10 @@
     enum render_e defaction;
     /* Fallback: change to following render backend if this one doesn't work */
     int fallback;
+    /* Upload new overlay image; Returns 0 if failed */
+    int (*ovl_image)(opengl_driver_t *, opengl_frame_t *);
+    /* Display current overlay */
+    void (*ovl_display)(opengl_driver_t *, opengl_frame_t *);
 } opengl_render_t;
 
 
@@ -265,10 +283,21 @@
   float           tx, ty;
 
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
+  
   tx = (float) frame->width  / this->tex_width;
   ty = (float) frame->height / this->tex_height;
   /* Draw quad */
@@ -280,6 +309,56 @@
   glEnd ();
 }
 
+/* Static Overlay display */
+static void render_overlay (opengl_driver_t *this, opengl_frame_t *frame) {
+  int             x1, x2, y1, y2;
+  float           tx, ty;
+
+  glEnable(GL_BLEND);
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  
+  if (this->tex_ovl_width == 0 && this->tex_ovl_height == 0) // Image_Pipeline renderer is active (no texture support)
+  {
+    glPixelZoom   (((float)this->gui_width)    / this->argb_layer.width,
+	       	 - ((float)this->gui_height)   / this->argb_layer.height);
+    glRasterPos2i (0, 0);
+    glDrawPixels  (this->argb_layer.width, this->argb_layer.height, GL_BGRA,
+		             GL_UNSIGNED_BYTE, this->argb_layer.buffer);
+  }
+  else
+  {
+    if (this->glBindTextureEXT) // bind overlay texture
+      this->glBindTextureEXT (GL_TEXTURE_2D, 1000);
+
+    if (this->fprog != -1)  // 2D_Tex_Fragprog is active which uses a pixelshader to make yuv2rgb conversion
+	                    // -> disable it because texture is already argb
+      glDisable(MYGL_FRAGMENT_PROGRAM_ARB);
+		    
+    /* Calc texture/rectangle coords */
+    x1 = 0;
+    y1 = 0;
+    x2 = this->gui_width;
+    y2 = this->gui_height;
+    tx = (float) this->argb_layer.width  / this->tex_ovl_width;
+    ty = (float) this->argb_layer.height / this->tex_ovl_height;
+
+    /* Draw quad */
+    glBegin (GL_QUADS);
+    glTexCoord2f (tx, ty);   glVertex2i (x2, y2);
+    glTexCoord2f (0,  ty);   glVertex2i (x1, y2);
+    glTexCoord2f (0,  0);    glVertex2i (x1, y1);
+    glTexCoord2f (tx, 0);    glVertex2i (x2, y1);
+    glEnd ();
+
+    if (this->fprog != -1)  // enable pixelshader for next normal video frame
+      glEnable(MYGL_FRAGMENT_PROGRAM_ARB);
+
+    if (this->glBindTextureEXT) // unbind overlay texture  
+      this->glBindTextureEXT (GL_TEXTURE_2D, 0);
+  }
+  glDisable(GL_BLEND);
+}
+
 /* Static 2d texture tiled based display */
 static void render_tex2dtiled (opengl_driver_t *this, opengl_frame_t *frame) {
   int    tex_w, tex_h, frame_w, frame_h;
@@ -291,10 +370,20 @@
   frame_w = frame->width;
   frame_h = frame->height;
   /* Calc texture/rectangle coords */
-  x1 = this->sc.output_xoffset;
-  y1 = this->sc.output_yoffset;
-  x2 = x1 + this->sc.output_width;
-  y2 = y1 + this->sc.output_height;
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    x1 = this->video_window_x;
+    y1 = this->video_window_y;
+    x2 = x1 + this->video_window_width;
+    y2 = y1 + this->video_window_height;
+  }
+  else
+  {
+    x1 = this->sc.output_xoffset;
+    y1 = this->sc.output_yoffset;
+    x2 = x1 + this->sc.output_width;
+    y2 = y1 + this->sc.output_height;
+  }
   txa = 1.0 / tex_w;
   tya = 1.0 / tex_h;
   txb = (float) frame_w / (tex_w-2);	/* temporary: total */
@@ -325,11 +414,23 @@
 
 /* Static image pipline based display */
 static void render_draw (opengl_driver_t *this, opengl_frame_t *frame) {
-  glPixelZoom   (((float)this->sc.output_width)    / frame->width,
-		 - ((float)this->sc.output_height) / frame->height);
-  glRasterPos2i (this->sc.output_xoffset, this->sc.output_yoffset);
-  glDrawPixels  (frame->width, frame->height, RGB_TEXTURE_FORMAT,
-		 GL_UNSIGNED_BYTE, frame->rgb);
+	
+  if (this->video_window_width && this->video_window_height) // video is displayed in a small window
+  {
+    glPixelZoom(((float)this->video_window_width)  / frame->width,
+              - ((float)this->video_window_height) / frame->height);
+    glRasterPos2i(this->video_window_x, this->video_window_y);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
+  else
+  {
+    glPixelZoom(((float)this->sc.output_width)  / frame->width,
+              - ((float)this->sc.output_height) / frame->height);
+    glRasterPos2i(this->sc.output_xoffset, this->sc.output_yoffset);
+    glDrawPixels (frame->width, frame->height, RGB_TEXTURE_FORMAT,
+                  GL_UNSIGNED_BYTE, frame->rgb);
+  }
 }
 
 /* Animated spinning cylinder */
@@ -480,6 +581,45 @@
   return 2;
 }
 
+/* holds/allocates extra texture for overlay */
+/* returns 0: allocation failure  1: texture updated  2: texture kept */
+static int render_help_overlay_image_tex(opengl_driver_t *this, int new_w, int new_h,
+				                         GLint glformat, GLint texformat) {
+  int tex_w, tex_h, err;
+
+  /* check necessary texture size and allocate */
+  if (new_w != this->last_ovl_width ||
+      new_h != this->last_ovl_height ||
+      ! this->tex_ovl_width || ! this->tex_ovl_height) {
+    tex_w = tex_h = 16;
+    while (tex_w < new_w)
+      tex_w <<= 1;
+    while (tex_h < new_h)
+      tex_h <<= 1;
+
+    if (tex_w != this->tex_ovl_width || tex_h != this->tex_ovl_height) {
+      char *tmp = calloc (tex_w * tex_h, 4); /* 4 enough until RGBA */
+      if (this->glBindTextureEXT)  // xine code binds without call glGenTextures -> seems to me not correct
+        this->glBindTextureEXT (GL_TEXTURE_2D, 1000);  // bind 1000 to avoid collision with tiledtex textures / don't want to rewrite everything ...
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri (GL_TEXTURE_2D,  GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexImage2D (GL_TEXTURE_2D, 0, glformat, tex_w, tex_h,
+		      0, texformat, GL_UNSIGNED_BYTE, tmp);
+      err = glGetError ();
+      free (tmp);
+      if (err)
+	    return 0;
+      this->tex_ovl_width  = tex_w;
+      this->tex_ovl_height = tex_h;
+      lprintf ("* new texsize: %dx%d\n", tex_w, tex_h);
+    }
+    this->last_ovl_width  = new_w;
+    this->last_ovl_height = new_h;
+    return 1;
+  }
+  return 2;										 
+}
+
 /* returns 0: allocation failure  1: textures updated  2: textures kept */
 static int render_help_image_tiledtex (opengl_driver_t *this,
 				       int new_w, int new_h,
@@ -564,6 +704,24 @@
   return 1;
 }
 
+static int render_overlay_image_tex (opengl_driver_t *this, opengl_frame_t *frame) {
+  int ret;
+  
+  // use own texture
+  ret = render_help_overlay_image_tex (this, this->argb_layer.width, this->argb_layer.height,
+                                       4, GL_BGRA);
+
+  if (! ret)
+    return 0;
+
+  if (this->glBindTextureEXT)
+    this->glBindTextureEXT (GL_TEXTURE_2D, 1000); 
+  glTexSubImage2D (GL_TEXTURE_2D, 0, 4, 0, this->argb_layer.width, this->argb_layer.height,
+                   GL_BGRA, GL_UNSIGNED_BYTE,
+                   this->argb_layer.buffer);
+  return 1;
+}
+
 static int render_image_tiledtex (opengl_driver_t *this, opengl_frame_t *frame) {
   int ret;
   int frame_w, frame_h, tex_w, tex_h, i, j, nx, ny;
@@ -1033,20 +1191,20 @@
 /*
  * List of render backends
  */
-/* name, display, image,  setup, needsrgb, defaction, fallback */
+/* name, display, image,  setup, needsrgb, defaction, fallback, ovl_image, ovl_display */
 static const opengl_render_t opengl_rb[] = {
     {   "2D_Tex_Fragprog",  render_tex2d, render_image_fp_yuv,
-	render_setup_fp_yuv, 0, RENDER_NONE, 1 },
+	render_setup_fp_yuv, 0, RENDER_NONE, 1, render_overlay_image_tex, render_overlay },
     {   "2D_Tex",           render_tex2d, render_image_tex,
-	render_setup_tex2d,  1, RENDER_NONE, 2 },
+	render_setup_tex2d,  1, RENDER_NONE, 2, render_overlay_image_tex, render_overlay },
     {   "2D_Tex_Tiled",     render_tex2dtiled, render_image_tiledtex,
-	render_setup_tex2d,  1, RENDER_NONE, 3 },
+	render_setup_tex2d,  1, RENDER_NONE, 3, render_overlay_image_tex, render_overlay },
     {   "Image_Pipeline",   render_draw, render_image_nop,
-	render_setup_2d,     1, RENDER_NONE, -1 },
+	render_setup_2d,     1, RENDER_NONE, -1, render_image_nop, render_overlay },
     {   "Cylinder",         render_cyl, render_image_tex,
-	render_setup_cyl,    1, RENDER_DRAW, 1 },
+	render_setup_cyl,    1, RENDER_DRAW, 1, render_image_nop, render_image_nop },
     {   "Env_Mapped_Torus", render_env_tor, render_image_envtex,
-	render_setup_torus,  1, RENDER_DRAW, 1 }
+	render_setup_torus,  1, RENDER_DRAW, 1, render_image_nop, render_image_nop }
 } ;
 
 
@@ -1133,12 +1291,27 @@
 	CHECKERR ("pre-render");
 	ret = 1;
 	if (changed)
+	  if (this->argb_layer.changed) // clean window after every overlay change - do it twice because of double buffering
+	  {
+      glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
+      if (this->argb_layer.changed == 1) 
+        this->argb_layer.changed++;
+      else this->argb_layer.changed = 0;
+    }
 	  ret = (render->image) (this, frame);
-	(render->display) (this, frame);
-	if (this->render_double_buffer)
-	  glXSwapBuffers(this->display, this->drawable);
-	else
-	  glFlush ();
+    (render->display) (this, frame);
+    // display overlay
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+    {
+      ret = (render->ovl_image) (this, frame);
+      (render->ovl_display) (this, frame);
+    }
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    if (this->render_double_buffer)
+      glXSwapBuffers(this->display, this->drawable);
+    else
+      glFlush ();
 	/* Note: no glFinish() - work concurrently to the graphics pipe */
 	CHECKERR ("post-render");
 	XUnlockDisplay (this->display);
@@ -1200,6 +1373,7 @@
 	}
 	XUnlockDisplay (this->display);
 	this->tex_width = this->tex_height = 0;
+	this->tex_ovl_width = this->tex_ovl_height = 0;
       }
       break;
 
@@ -1556,6 +1730,9 @@
   opengl_driver_t  *this  = (opengl_driver_t *) this_gen;
   opengl_frame_t   *frame = (opengl_frame_t *) frame_gen;
 
+  if (overlay->width <= 0 || overlay->height <= 0 || (!overlay->rle && (!overlay->argb_layer || !overlay->argb_layer->buffer)))
+    return;
+
   /* Alpha Blend here */
   if (overlay->rle) {
     if (overlay->unscaled) {
@@ -1597,6 +1774,28 @@
 #     endif
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  { 
+    // copy argb_buffer because it gets invalid after overlay_end and rendering is after overlay_end
+    pthread_mutex_lock (&this->argb_layer.mutex);
+    if (this->argb_layer.buffer)
+      free(this->argb_layer.buffer);
+    this->argb_layer.buffer = calloc(overlay->extent_width * overlay->extent_height, sizeof(uint32_t));
+    if (this->argb_layer.buffer == NULL)
+    {
+      printf("Fatal error(opengl_overlay_blend): No memory\n");
+      return;
+    }
+    this->argb_layer.width  = overlay->extent_width;
+    this->argb_layer.height = overlay->extent_height;
+    this->argb_layer.changed= 1;
+    xine_fast_memcpy(this->argb_layer.buffer, overlay->argb_layer->buffer, overlay->extent_width * overlay->extent_height * sizeof(uint32_t));
+    pthread_mutex_unlock (&this->argb_layer.mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static int opengl_redraw_needed (vo_driver_t *this_gen) {
@@ -1890,6 +2089,11 @@
     XUnlockDisplay (this->display);
   }
 
+  pthread_mutex_lock (&this->argb_layer.mutex);
+  if (this->argb_layer.buffer)
+	free(this->argb_layer.buffer);
+  pthread_mutex_unlock (&this->argb_layer.mutex);
+
   _x_alphablend_free(&this->alphablend_extra_data);
 
   free (this);
@@ -1941,7 +2145,17 @@
   this->fprog = -1;
 
   this->xoverlay                = NULL;
+  this->argb_layer.buffer       = NULL;
+  this->argb_layer.width        = 0;
+  this->argb_layer.height       = 0;
+  this->argb_layer.changed      = 0;
   this->ovl_changed             = 0;
+  this->last_ovl_width = this->last_ovl_height = -1;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
+  
   this->xine                    = class->xine;
   this->config                  = config;
 
diff -urN xine-lib-1.2/src/video_out/video_out_raw.c xine-lib-1.2.enigmaw/src/video_out/video_out_raw.c
--- xine-lib-1.2/src/video_out/video_out_raw.c	2014-11-09 17:50:36.154622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/video_out_raw.c	2014-11-09 17:22:55.842593000 +0100
@@ -66,6 +66,7 @@
 
   int                width, height, format, flags;
   double             ratio;
+  void              *chunk[4]; /* mem alloc by xmalloc_aligned           */
   uint8_t           *rgb, *rgb_dst;
   yuv2rgb_t         *yuv2rgb; /* yuv2rgb converter set up for this frame */
 
diff -urN xine-lib-1.2/src/video_out/video_out_xshm.c xine-lib-1.2.enigmaw/src/video_out/video_out_xshm.c
--- xine-lib-1.2/src/video_out/video_out_xshm.c	2014-11-09 17:50:36.170622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/video_out_xshm.c	2014-05-25 15:28:55.000000000 +0200
@@ -128,6 +128,7 @@
   xshm_frame_t      *cur_frame;
   x11osd            *xoverlay;
   int                ovl_changed;
+  int                video_window_width, video_window_height, video_window_x, video_window_y;
 
   int (*x11_old_error_handler)  (Display *, XErrorEvent *);
 
@@ -793,6 +794,18 @@
       }
     }
   }
+  else if (overlay && overlay->argb_layer && overlay->argb_layer->buffer && this->ovl_changed)
+  {
+    pthread_mutex_lock (&overlay->argb_layer->mutex); 
+    LOCK_DISPLAY(this);
+    x11osd_blend(this->xoverlay, overlay);
+    UNLOCK_DISPLAY(this);
+    pthread_mutex_unlock (&overlay->argb_layer->mutex);
+    this->video_window_width  = overlay->video_window_width;
+    this->video_window_height = overlay->video_window_height;
+    this->video_window_x      = overlay->video_window_x;
+    this->video_window_y      = overlay->video_window_y;
+  }
 }
 
 static void clean_output_area (xshm_driver_t *this, xshm_frame_t *frame) {
@@ -806,7 +819,7 @@
   for( i = 0; i < 4; i++ ) {
     if( this->sc.border[i].w && this->sc.border[i].h )
       XFillRectangle(this->display, this->drawable, this->gc,
-                     this->sc.border[i].x, this->sc.border[i].y,
+                     this->sc.border[i].x + this->video_window_x, this->sc.border[i].y + this->video_window_y,
                      this->sc.border[i].w, this->sc.border[i].h);
   }
   if (this->xoverlay) {
@@ -1237,6 +1250,10 @@
   UNLOCK_DISPLAY(this);
   this->xoverlay                = NULL;
   this->ovl_changed             = 0;
+  this->video_window_width      = 0;
+  this->video_window_height     = 0;
+  this->video_window_x          = 0;
+  this->video_window_y          = 0;
 
   this->x11_old_error_handler = NULL;
   this->xine                  = class->xine;
diff -urN xine-lib-1.2/src/video_out/x11osd.c xine-lib-1.2.enigmaw/src/video_out/x11osd.c
--- xine-lib-1.2/src/video_out/x11osd.c	2014-11-09 17:50:36.178622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/x11osd.c	2014-11-09 17:22:55.842593000 +0100
@@ -44,6 +44,9 @@
 #include <X11/extensions/shape.h>
 #include <X11/Xatom.h>
 
+#include <xine/xineutils.h>
+#include "xine_mmx.h"
+
 #define LOG_MODULE "x11osd"
 #define LOG_VERBOSE
 
@@ -78,6 +81,9 @@
   Pixmap bitmap;
   Visual *visual;
   Colormap cmap;
+  XImage *argb_img;
+  void (*scale_func) (uint32_t* src, uint32_t* dst, int width, int step);
+  int scale_mmx;
 
   GC gc;
 
@@ -96,6 +102,12 @@
   assert (osd);
 
   lprintf("expose (state:%d)\n", osd->clean );
+  
+  // copy argb data to bitmap
+  if (osd->argb_img && osd->argb_img->data)
+  {
+     XPutImage(osd->display, osd->bitmap, osd->gc, osd->argb_img, 0, 0, 0, 0, osd->width, osd->height);
+  }
 
   switch (osd->mode) {
     case X11OSD_SHAPED:
@@ -153,6 +165,11 @@
 		       osd->width, osd->height, osd->depth);
       break;
   }
+  
+  // resize argb_img data
+  XDestroyImage(osd->argb_img);
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
 
   osd->clean = UNDEFINED;
   x11osd_clear(osd);
@@ -224,6 +241,11 @@
       break;
   }
 
+  // resize argb_img data
+  XDestroyImage(osd->argb_img);
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
+
   osd->clean = UNDEFINED;
   /* do not x11osd_clear() here: osd->u.colorkey.sc has not being updated yet */
 }
@@ -268,6 +290,26 @@
   assert(osd->width);
   assert(osd->height);
 
+  // create image for argb overlay
+  osd->argb_img = XCreateImage(osd->display, osd->visual, 24, ZPixmap, 0, NULL, osd->width, osd->height, 32, 0);
+  osd->argb_img->data = calloc(osd->width * osd->height, sizeof(uint32_t));
+  
+  // scale function
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+  uint32_t mm = xine_mm_accel();
+  if ((osd->scale_func == NULL) && ((mm & MM_ACCEL_X86_MMX) || (mm & MM_ACCEL_X86_MMXEXT)))
+  {
+    osd->scale_func= x11osd_scale_line_mmx;
+    osd->scale_mmx= 1;
+    printf("X11OSD: MMX OSD scaling active\n");
+  }
+#endif
+  if (osd->scale_func == NULL)
+  {
+    osd->scale_func= x11osd_scale_line;
+    osd->scale_mmx= 0;
+  }  
+
   switch (mode) {
     case X11OSD_SHAPED:
       if (!XShapeQueryExtension (osd->display, &event_basep, &error_basep)) {
@@ -395,7 +437,7 @@
     XFreePixmap (osd->display, osd->u.shaped.mask_bitmap);
     XDestroyWindow (osd->display, osd->u.shaped.window);
   }
-
+  XDestroyImage(osd->argb_img);
   free (osd);
 }
 
@@ -550,5 +592,292 @@
     }
     osd->clean = DRAWN;
   }
+  else if (overlay->argb_layer && overlay->argb_layer->buffer)
+  {
+    osd->argb_img->data = realloc(osd->argb_img->data, osd->width * osd->height * sizeof(uint32_t));
+    
+    x11osd_scale_argb32_image(osd, (uint32_t*)overlay->argb_layer->buffer, (uint32_t*)osd->argb_img->data, overlay->extent_width, overlay->extent_height, osd->width, osd->height);
+	  
+	uint32_t bx, by;
+	uint32_t w, h;
+	if(osd->mode==X11OSD_SHAPED) // fill bitmask / if bit is set, the corresponding pixel is drawn to screen
+	{
+	  w= osd->width - overlay->x;
+	  h= osd->height - overlay->y;
+	  for (by= 0; by < h; by++)
+		for (bx= 0; bx < w; bx++)
+		  if ((((uint32_t*)osd->argb_img->data)[bx+by*w] >> 24) != 0 )
+		    XDrawPoint(osd->display, osd->u.shaped.mask_bitmap, osd->u.shaped.mask_gc, bx, by);
+	}    
+
+	osd->clean = DRAWN;
+  }
+}
+
+// adapted algorithm from yuv2rgb.c to scale rgb images
+void x11osd_scale_argb32_image(x11osd *osd, uint32_t* src, uint32_t* dst, int src_width, int src_height, int dst_width, int dst_height)
+{
+	int step_dx = src_width * 32768 / dst_width;
+	int step_dy = src_height * 32768 / dst_height;
+	int height, dy= 0;
+		
+	if (src_width == dst_width && src_height == dst_height)
+	{
+	  xine_fast_memcpy (dst, src, dst_width*dst_height*4);
+	  return;
+	}
+	
+	for (height = 0;; ) 
+	{
+	  osd->scale_func(src, dst, dst_width, step_dx);  // scale_line with or without mmx
+	    
+      dy += step_dy;
+      dst += dst_width;
+
+      while (--dst_height > 0 && dy < 32768)    // copy scaled line (only enlarging)
+      {
+        xine_fast_memcpy (dst, dst-(dst_width), dst_width*4); // copy last line
+
+	    dy += step_dy;
+	    dst += dst_width;
+      }
+      if (dst_height <= 0)
+	    break;
+
+      do 
+      { // skip at least one line (possibly more if scale factor < 1)
+        dy -= 32768;
+        src += src_width;  
+
+        height++;
+      } while( dy>=32768);
+    }	
+    if (osd->scale_mmx) emms();   // empties the MMX state
 }
 
+// adapted algorithm from yuv2rgb.c to scale single argb line
+void x11osd_scale_line(uint32_t* src, uint32_t* dst, int width, int step)
+{
+  uint32_t p1;
+  uint32_t p2;
+  int dx;
+  
+  p1 = *src++;
+  p2 = *src++;
+  dx = 0;
+  
+  if (step < 32768) 
+  {
+    while (width) 
+    {
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24                   // interpolate A: (A1*(32768-dx)+A2*dx) / 32768
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16 // interpolate R
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8 // interpolate G
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;                        // interpolate B
+      
+      dx += step;
+      if (dx > 32768) 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else if (step <= 65536) 
+  {
+    while (width) 
+    {
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;
+
+      dx += step;
+      if (dx > 65536) 
+      {
+	    dx -= 65536;
+	    p1 = *src++;
+	    p2 = *src++;
+      } else 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else 
+  {
+    while (width) 
+    {
+      int offs;
+
+      *dst = ((((p1 >> 24) * (32768-dx)) + ((p2 >> 24) * dx))>>15) << 24
+           | (((((p1 >> 16) & 0xFF) * (32768-dx)) + (((p2 >> 16) & 0xFF) * dx))>>15) << 16
+           | (((((p1 >>  8) & 0xFF) * (32768-dx)) + (((p2 >>  8) & 0xFF) * dx))>>15) <<  8
+           | (((p1 & 0xFF) * (32768-dx)) + ((p2 & 0xFF) * dx))>>15;
+
+      dx += step;
+      offs=((dx-1)>>15);
+      dx-=offs<<15;
+      src+=offs-2;
+      p1=*src++;
+      p2=*src++;
+      dst ++;
+      width --;
+    }
+  }
+};
+
+// adapted algorithm from yuv2rgb.c to scale single argb line
+void x11osd_scale_line_mmx(uint32_t* src, uint32_t* dst, int width, int step)
+{
+  uint32_t p1;
+  uint32_t p2;
+  int dx;
+  int dx2; 
+  
+  p1 = *src++;
+  p2 = *src++;
+  dx = 0;
+  
+  if (step < 32768) 
+  {
+    while (width) 
+    {
+	  dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+       
+      /*  
+       *  MMX ARGB interpolation between p1(a1,r1,g1,b1) and p2(a2,r2,g2,b2)
+       *  a= (a1* (32768-dx) + a2 * dx) / 32768 -> a = a1 - a1*dx/32768 + a2*dx/32768
+       *  r= (r1* (32768-dx) + r2 * dx) / 32768 -> r = r1 - r1*dx/32768 + r2*dx/32768
+       *  ...
+       *  Doing multiplication of a,r,g,b with dx in one step
+       *  Division by 32768 is not necessary in mmx because you can get only the high 16 bits of a multiplication
+      */
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+      
+      dx += step;
+      if (dx > 32768) 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else if (step <= 65536) 
+  {
+    while (width) 
+    {
+	  dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+	      
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+
+      dx += step;
+      if (dx > 65536) 
+      {
+	    dx -= 65536;
+	    p1 = *src++;
+	    p2 = *src++;
+      } else 
+      {
+	    dx -= 32768;
+	    p1 = p2;
+	    p2 = *src++;
+      }
+
+      dst ++;
+      width --;
+    }
+  } else 
+  {
+    while (width) 
+    {
+      int offs;
+      
+      dx2 = dx * 2;
+	  if (dx2==65536) 
+	    dx2-= 1;
+      
+      movd_m2r(p1,mm0);          // mm0 = p1;  
+      movq_r2r(mm0,mm1);         // mm1 = mm0;  copy because result of unpack overides mm1 and we need p1 later again
+      pxor_r2r(mm2,mm2);         // mm2 = 0;
+      punpcklbw_r2r(mm2,mm1);    // mm1 = unpacked p1 (00 AA 00 RR 00 GG 00 BB)
+      movd_m2r(dx2,mm3);         // mm3 = dx2;   from here i call dx2 = 0xd1d2
+      movd_m2r(dx2,mm4);         // mm4 = dx2;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = 00 00 00 00 d1 d2 d1 d2;
+      movq_r2r(mm4,mm3);         // mm3 = mm4;
+      punpcklwd_r2r(mm3,mm4);    // mm4 = d1 d2 d1 d2 d1 d2 d1 d2;  4 times dx2
+      movq_r2r(mm4,mm5);         // mm5 = mm4; copy
+      pmulhuw_r2r(mm4,mm1);      // mm1 = mm4 * mm1 = dx2 * p1 = dx * p1 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm1);     // mm1 = packed mm1
+      movd_m2r(p2,mm6);          // mm6 = p2;
+      punpcklbw_r2r(mm2,mm6);    // mm6 = unpacked p2 (00 AA 00 RR 00 GG 00 BB)
+      pmulhuw_r2r(mm5,mm6);      // mm6 = mm5 * mm6 = dx2 * p2 = dx * p2 / 32768 // get from multiplication only high 16 bits
+      packuswb_r2r(mm2,mm6);     // mm6 = packed mm6
+      psubusb_r2r(mm1,mm0);      // mm0 = mm0 - mm1 = p1 - (p1*dx/32768)
+      paddusb_r2r(mm0,mm6);      // mm5 = mm0 + mm5 = p1 - (p1*dx/32768) + (p2*dx/32768)
+      
+      movd_r2m(mm6, *dst);
+
+      dx += step;
+      offs=((dx-1)>>15);
+      dx-=offs<<15;
+      src+=offs-2;
+      p1=*src++;
+      p2=*src++;
+      dst ++;
+      width --;
+    }
+  }
+};
diff -urN xine-lib-1.2/src/video_out/x11osd.h xine-lib-1.2.enigmaw/src/video_out/x11osd.h
--- xine-lib-1.2/src/video_out/x11osd.h	2014-11-09 17:50:36.178622082 +0100
+++ xine-lib-1.2.enigmaw/src/video_out/x11osd.h	2014-01-11 15:34:05.000000000 +0100
@@ -29,6 +29,7 @@
 #define X11OSD_H
 
 #include <xine/vo_scale.h>
+#include <sys/time.h>
 
 typedef struct x11osd x11osd;
 enum x11osd_mode {X11OSD_SHAPED, X11OSD_COLORKEY};
@@ -49,4 +50,10 @@
 
 void x11osd_blend(x11osd *osd, vo_overlay_t *overlay);
 
+void x11osd_scale_argb32_image(x11osd *osd, uint32_t* src, uint32_t* dst, int src_width, int src_height, int dst_width, int dst_height);
+
+void x11osd_scale_line(uint32_t* src, uint32_t* dst, int width, int step);
+
+void x11osd_scale_line_mmx(uint32_t* src, uint32_t* dst, int width, int step);
+
 #endif
diff -urN xine-lib-1.2/src/xine-engine/load_plugins.c xine-lib-1.2.enigmaw/src/xine-engine/load_plugins.c
--- xine-lib-1.2/src/xine-engine/load_plugins.c	2014-11-09 17:50:36.206622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/load_plugins.c	2014-11-09 17:22:55.842593000 +0100
@@ -1324,6 +1324,9 @@
   xine_list_delete (plugindirs);
   free(homedir);
 
+ if ((_x_flags & XINE_FLAG_NO_WRITE_CACHE) == 0)
+   save_catalog (this);
+
   load_required_plugins (this);
 
   if ((_x_flags & XINE_FLAG_NO_WRITE_CACHE) == 0)
diff -urN xine-lib-1.2/src/xine-engine/Makefile.am xine-lib-1.2.enigmaw/src/xine-engine/Makefile.am
--- xine-lib-1.2/src/xine-engine/Makefile.am	2014-11-09 17:50:36.182622082 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/Makefile.am	2014-06-12 05:14:28.000000000 +0200
@@ -44,7 +44,8 @@
                     $(LIBXINEPOSIX) $(RT_LIBS) $(NET_LIBS) $(XDG_BASEDIR_LIBS) \
                     $(AVUTIL_LIBS) $(MLIB_LIBS)
 
-libxine_la_LDFLAGS = $(LDFLAGS_NOUNDEFINED) $(AM_LDFLAGS) $(def_ldflags) $(GCSECTIONS) \
+libxine_la_LDFLAGS = $(AM_LDFLAGS) $(def_ldflags) $(GCSECTIONS) \
+	$(LDFLAGS_NOUNDEFINED) \
 	-weak libxine-interface.la \
 	-version-info $(XINE_LT_CURRENT):$(XINE_LT_REVISION):$(XINE_LT_AGE)
 
@@ -74,3 +75,4 @@
 uninstall-local:
 	rm -f "$(DESTDIR)$(libdir)"/libxine-interface.la
 	-rm -f $(DESTDIR)$(libdir)/$(DEF_FILE)
+
diff -urN xine-lib-1.2/src/xine-engine/osd.c xine-lib-1.2.enigmaw/src/xine-engine/osd.c
--- xine-lib-1.2/src/xine-engine/osd.c	2014-11-09 17:50:36.206622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/osd.c	2014-05-25 15:28:55.000000000 +0200
@@ -511,6 +511,10 @@
   return _osd_show(osd, vpts, 1);
 }
 
+static int osd_show_gui_scaled (osd_object_t *osd, int64_t vpts) {
+  return _osd_show(osd, vpts, 2);
+}
+
 /*
  * send event to hide osd at given pts (0=now)
  * the object is not changed. there may be subsequent drawing  on it.
@@ -1917,6 +1921,7 @@
   this->draw_bitmap        = osd_draw_bitmap;
   this->set_argb_buffer    = osd_set_argb_buffer;
   this->show_unscaled      = osd_show_unscaled;
+  this->show_scaled        = osd_show_gui_scaled;
   this->get_capabilities   = osd_get_capabilities;
   this->set_extent         = osd_set_extent;
   this->set_video_window   = osd_set_video_window;
diff -urN xine-lib-1.2/src/xine-engine/video_out.c xine-lib-1.2.enigmaw/src/xine-engine/video_out.c
--- xine-lib-1.2/src/xine-engine/video_out.c	2014-11-09 17:50:36.214622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/video_out.c	2014-11-09 17:22:55.842593000 +0100
@@ -143,7 +143,7 @@
 
   /* pts value when decoder delivered last video frame */
   int64_t                   last_delivery_pts;
-
+  int64_t                   last_pts;
 
   video_overlay_manager_t  *overlay_source;
 
@@ -151,6 +151,7 @@
 
   int                       current_width, current_height;
   int64_t                   current_duration;
+  int                       framerate;
   int                       frame_drop_limit_max;
   int                       frame_drop_limit;
   int                       frame_drop_cpt;
@@ -788,6 +789,24 @@
   this->current_height = img->height;
 
   if (stream) {
+
+    int new_framerate = img->duration==0?0:90000*1000/img->duration;
+    if (this->framerate != new_framerate) {
+      this->framerate = new_framerate;
+
+      xine_event_t event;
+      xine_framerate_data_t data;
+      event.type = XINE_EVENT_FRAMERATE_CHANGE;
+      event.stream = stream;
+      event.data = &data;
+      event.data_length = sizeof(data);
+      data.framerate = this->framerate;
+      xine_event_send( stream, &event );
+    }
+
+    if (img->pts!=0)
+      this->last_pts = img->pts;
+
     _x_refcounter_inc(stream->refcounter);
     _x_extra_info_merge( img->extra_info, stream->video_decoder_extra_info );
     stream->metronom->got_video_frame (stream->metronom, img);
@@ -1308,6 +1327,7 @@
       pthread_mutex_unlock( &this->free_img_buf_queue->mutex );
       if( img ) {
         img->vpts = cur_vpts;
+        img->duration = DEFAULT_FRAME_DURATION;
         /* extra info of the backup is thrown away, because it is not up to date */
         _x_extra_info_reset(img->extra_info);
         img->future_frame = NULL;
@@ -1884,6 +1904,10 @@
     pthread_mutex_unlock(&this->streams_lock);
     break;
 
+  case VO_PROP_LAST_PTS:
+    ret = (int)&this->last_pts;
+    break;
+
   /*
    * handle XINE_PARAM_xxx properties (convert from driver's range)
    */
diff -urN xine-lib-1.2/src/xine-engine/vo_scale.c xine-lib-1.2.enigmaw/src/xine-engine/vo_scale.c
--- xine-lib-1.2/src/xine-engine/vo_scale.c	2014-11-09 17:50:36.214622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/vo_scale.c	2014-06-12 05:14:28.000000000 +0200
@@ -79,7 +79,7 @@
       desired_ratio = 4.0 / 3.0;
     }
 
-    this->video_pixel_aspect = desired_ratio / image_ratio;
+    this->video_pixel_aspect = desired_ratio / image_ratio * this->gui_pixel_aspect;
 
     _x_assert(this->gui_pixel_aspect != 0.0);
 
diff -urN xine-lib-1.2/src/xine-engine/xine_interface.c xine-lib-1.2.enigmaw/src/xine-engine/xine_interface.c
--- xine-lib-1.2/src/xine-engine/xine_interface.c	2014-11-09 17:50:36.218622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-engine/xine_interface.c	2014-01-11 15:34:05.000000000 +0100
@@ -825,6 +825,10 @@
   this->osd.renderer->show_unscaled(&this->osd, vpts);
 }
 
+void xine_osd_show_scaled(xine_osd_t *this, int64_t vpts) {
+  this->osd.renderer->show_scaled(&this->osd, vpts);
+}
+
 void xine_osd_hide(xine_osd_t *this, int64_t vpts) {
   this->osd.renderer->hide(&this->osd, vpts);
 }
diff -urN xine-lib-1.2/src/xine-utils/color.c xine-lib-1.2.enigmaw/src/xine-utils/color.c
--- xine-lib-1.2/src/xine-utils/color.c	2014-11-09 17:50:36.218622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-utils/color.c	2014-11-09 17:22:55.846593000 +0100
@@ -62,10 +62,6 @@
  * instructions.
  */
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
 #include <xine/xine_internal.h>
 #include "xine_mmx.h"
 
diff -urN xine-lib-1.2/src/xine-utils/xine_mmx.h xine-lib-1.2.enigmaw/src/xine-utils/xine_mmx.h
--- xine-lib-1.2/src/xine-utils/xine_mmx.h	2014-11-09 17:50:36.226622083 +0100
+++ xine-lib-1.2.enigmaw/src/xine-utils/xine_mmx.h	2014-01-11 15:34:05.000000000 +0100
@@ -275,15 +275,15 @@
 
 #define	sfence() __asm__ __volatile__ ("sfence\n\t")
 
-typedef	union {
-	int64_t			q[2];	/* Quadword (64-bit) value */
-	uint64_t		uq[2];	/* Unsigned Quadword */
-	int32_t			d[4];	/* Doubleword (32-bit) values */
-	uint32_t		ud[4];	/* Unsigned Doubleword */
-	short			w[8];	/* Word (16-bit) values */
-	unsigned short		uw[8];	/* Unsigned Word */
-	char			b[16];	/* Byte (8-bit) values */
-	unsigned char		ub[16];	/* Unsigned Byte */
+typedef		union {
+	int64_t                 q[2];   /* Quadword (64-bit) value */
+	uint64_t                uq[2];  /* Unsigned Quadword */
+	int32_t                 d[4];   /* Doubleword (32-bit) values */
+	uint32_t                ud[4];  /* Unsigned Doubleword */
+	short                   w[8];   /* Word (16-bit) values */
+	unsigned short          uw[8];  /* Unsigned Word */
+	char                    b[16];  /* Byte (8-bit) values */
+	unsigned char           ub[16]; /* Unsigned Byte */
 	float			sf[4];	/* Single-precision (32-bit) value */
 } ATTR_ALIGN(16) sse_t;	/* On a 16 byte (128-bit) boundary */
 
